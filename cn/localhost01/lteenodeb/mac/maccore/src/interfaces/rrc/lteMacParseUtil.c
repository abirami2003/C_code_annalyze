/******************************************************************************
 *
 *  ARICENT -
 *
 *  Copyright (C) 2009 Aricent Inc. All Rights Reserved.
 *
 ******************************************************************************
 *
 *  $Id: lteMacParseUtil.c
 *
 ******************************************************************************
 *
 *  File Description : This file provide APIs to receive request from RRC Layer,
 *                     configure MAC and send a response to RRC Layer.
 *                     Presently communication with RRC is socket based.
 ******************************************************************************
 *
 * Revision Details
 * ----------------
 * $Log: lteMacParseUtil.c,v $
 * Revision 1.3.6.2.4.2.2.5.4.2  2010/11/08 16:04:47  gur10121
 * UT Bug fix
 *
 * Revision 1.3.6.2.4.2.2.5.4.1  2010/11/08 06:06:26  gur10121
 * Semi static changes merging
 *
 * Revision 1.3.6.2.4.2.2.5  2010/10/25 10:16:55  gur23971
 * warning removed
 *
 * Revision 1.3.6.2.4.2.2.4.4.3  2010/10/29 10:25:48  gur10121
 *  Semi Static UT fixes
 *
 *
 *  Revision 1.3.6.2.4.2.2.4.4.2  2010/10/27 17:13:55  gur10121
 *  UT fixes + review comments incorporation
 * 
 * Revision 1.3.6.2.4.2.2.4.2.1  2010/10/15 13:30:27  gur20439
 * changes to support PUSCH config
 *
 * Revision 1.3.6.2.4.2.2.4  2010/10/13 10:30:27  gur23054
 * Names removed from code
 *
 * Revision 1.3.6.2.4.2.2.3  2010/10/11 12:56:57  gur10121
 * SPR #706 fix
 *
 * Revision 1.3.6.2.4.2.2.2.4.1  2010/10/08 07:42:40  gur10121
 *  SPR 706 Fix - KlockWork Warnings removed
 *
 * Revision 1.3.6.2.4.2.2.2  2010/09/27 14:38:44  gur10694
 * UE config Fix and Review comments
 *
 * Revision 1.3.6.2.4.2.2.1  2010/09/21 15:46:12  gur20491
 * FAPI changes
 *
 * Revision 1.3.6.2  2010/08/02 08:13:42  gur20491
 * FrameworkSetupWith1.0_MAC1.2.4
 *
 * Revision 1.83.26.1  2010/07/21 09:36:44  gur24420
 * Aligned changes with respect to eNode Integration activity(based on RMI-NetLogic Code).
 * Overall Changes Cover:-
 * 1. Merged Endian fixes for receiving data from RRC.
 *
 * Revision 1.83  2009/12/30 16:05:21  gur15697
 * CCCH message to RRC bug fix
 *
 * Revision 1.82  2009/11/14 10:58:36  gur11912
 * remvoed warnings generated by O2
 *
 * Revision 1.81  2009/11/11 07:51:28  gur19413
 * added UT_TESTING Flag
 *
 * Revision 1.80  2009/11/11 07:38:47  gur19413
 * added validation for max ue supported
 *
 * Revision 1.79  2009/10/27 07:12:48  gur19413
 * reverted RAW Socket changes
 *
 *  Revision 1.78  2009/10/27 05:24:02  gur19413
 * socket related changes
 *
 * Revision 1.77  2009/10/26 13:34:31  gur11912
 * removed warnings
 *
 * Revision 1.76  2009/10/26 10:16:38  gur19413
 * modified socket functionality
 *
 * Revision 1.75  2009/10/25 19:19:50  gur19413
 * optimization bug fixed
 *
 * Revision 1.74  2009/10/21 05:25:57  gur19413
 * ue add functionality optimized
 *
 * Revision 1.73  2009/09/09 06:38:49  gur19413
 * zero buffer related changes
 *
 * Revision 1.72  2009/09/01 08:07:19  gur20052
 * Added a warning when MAC is not init of PhY regn not done, and got cell config
 *
 * Revision 1.71  2009/08/30 19:36:43  gur19413
 * updated the check for cqi info length
 *
 * Revision 1.70  2009/08/30 14:07:45  gur19413
 * changed NULL to PNULL
 *
 * Revision 1.69  2009/08/28 13:26:44  gur19413
 * removed older logger system.
 *
 * Revision 1.68  2009/08/20 07:25:36  gur19413
 * fixed bugs
 *
 * Revision 1.67  2009/07/29 13:47:12  gur11083
 * modified parsing cqiPucchResourceIndex ,riConfigIndex for reconfigure UE
 *
 * Revision 1.66  2009/07/29 06:32:22  gur15697
 * UT bug fix
 *
 * Revision 1.65  2009/07/27 16:09:26  gur11083
 * review comments incorporated and set UL Priority
 *
 * Revision 1.64  2009/07/24 15:15:52  gur20052
 * Setting the max DL/UL RBs to DL/UL Available RBs if max RBs are more than Cell config DL/UL Available RBs
 *
 * Revision 1.63  2009/07/23 12:15:59  gur20470
 * changed the check for modulation scheme from != to == QAM64
 *
 * Revision 1.62  2009/07/22 15:18:01  gur11083
 * changed functionargument *origTagLen to origTagLen of parseCreateLcReq
 *
 * Revision 1.61  2009/07/22 11:29:27  gur11083
 * changed for review comment and removed transmission mode validation with cqimode
 *
 * Revision 1.60  2009/07/20 15:38:00  gur15697
 * case MAC_UE_CON_REJ_REQ moved to readAndParseRRCMsg() method
 *
 * Revision 1.59  2009/07/20 08:20:01  gur12140
 * Added init for CQI
 *
 * Revision 1.58  2009/07/17 06:25:12  gur20439
 * changes related to rrc interface modification incorporated.
 *
 * Revision 1.57  2009/07/16 13:11:00  gur11083
 * chnaged to 16 bit for  cqiPMIConfigIndex,cqiPucchResourceIndex,riConfigIndex
 *
 * Revision 1.56  2009/07/16 12:06:22  gur19413
 * ut bugs fixed
 *
 * Revision 1.55  2009/07/16 08:07:44  gur19413
 * added new cqiInfoFlag.
 *
 * Revision 1.54  2009/07/15 11:52:24  gur19413
 * Added support for Sequence Number
 *
 * Revision 1.53  2009/07/14 14:18:25  gur11083
 * removed initPCCHMgr initCCCHMgr initRACHMgr initDeMuxMgr from init
 *
 * Revision 1.52  2009/07/14 09:08:47  gur11083
 * added validation for numharqprocess, set invalid value for transmode,numoflayer,codebookindex,modified cqimode validation
 *
 * Revision 1.51  2009/07/10 13:14:31  gur15697
 * ulCreateReq_p->cRnti = dlCreateReq_p->cRnti added
 *
 * Revision 1.50  2009/07/09 14:14:29  gur11083
 * change for multiple LC
 *
 * Revision 1.49  2009/07/08 12:43:34  gur18569
 * removed compilation error
 *
 * Revision 1.48  2009/07/06 08:26:42  gur15697
 * UT bug fixes
 *
 * Revision 1.47  2009/07/03 11:07:40  gur11083
 * fixed RLC bug
 *
 * Revision 1.46  2009/07/03 08:21:03  gur18569
 * removed the stub for adding context into RLC traffic gen
 *
 * Revision 1.45  2009/07/03 04:52:31  gur15697
 * recvCCCHMessage() arguments modified
 *
 * Revision 1.44  2009/07/01 04:20:53  gur15697
 * review comments incorporated
 *
 * Revision 1.43  2009/06/27 05:39:24  gur15697
 * recvCCCHMessage() recvPagingMessage() arguments modifed
 *
 * Revision 1.42  2009/06/26 11:37:27  gur11083
 * fix error for coding rate
 *
 * Revision 1.41  2009/06/25 11:21:55  gur11083
 * change for codingrate validation
 *
 * Revision 1.40  2009/06/25 06:28:20  gur15697
 * initULQueueLoadMgr() removed
 *
 * Revision 1.39  2009/06/24 08:26:54  gur20470
 * incorporated review comments
 *
 * Revision 1.38  2009/06/22 08:17:15  gur15697
 * parseAndStoreBroadcastMsg() modified
 *
 * Revision 1.37  2009/06/22 08:11:18  gur20470
 * added error handling for create ue and reconfigure ue request
 *
 * Revision 1.36  2009/06/22 05:20:06  gur20470
 * added cqi indication and cqimode for downlink structure
 *
 * Revision 1.35  2009/06/19 13:22:58  gur15697
 * code added for zero buffer copy in sendCCCHMsgToRRC()
 *
 * Revision 1.34  2009/06/19 05:36:08  gur15697
 * review comments incorporated
 *
 * Revision 1.33  2009/06/18 09:12:37  gur15697
 * lowerCRNTIBound_g and upperCRNTIBound_g modified to  lowerRNTIBound_g and upperRNTIBound_g
 *
 * Revision 1.32  2009/06/18 06:25:41  gur15697
 * PUCCH functionality added, review comments incorporated
 *
 * Revision 1.31  2009/06/18 04:51:38  gur15697
 * initPCCHMgr()  and initCCCHMgr() added
 *
 * Revision 1.30  2009/06/17 09:14:50  gur12140
 * Moved initPDCCH after initAllResourceAllocationPolicyInfo
 *
 * Revision 1.29  2009/06/17 06:35:25  gur15697
 * compilation errors removed
 *
 * Revision 1.28  2009/06/15 07:33:48  gur18569
 * added static func initAfterCellConfig
 *
 * Revision 1.27  2009/06/12 11:56:49  gur11083
 * change for validation and fill stuecture for PHICH_CONFIG_INFO
 *
 * Revision 1.26  2009/06/12 09:25:31  gur11083
 * changed for MAC_UE_DRX_CMD
 *
 * Revision 1.25  2009/06/12 08:29:10  gur11083
 * changed for cellconfig
 *
 * Revision 1.24  2009/06/11 08:16:16  gur20470
 * changed the function call for parseOAMMsg
 *
 * Revision 1.23  2009/06/11 07:59:30  gur20470
 * added non blocking functionality for MAC socket
 *
 * Revision 1.22  2009/06/10 11:48:47  gur20470
 * globals for OAM port AND Socket file desriptor
 *
 * Revision 1.21  2009/06/10 11:01:48  gur20470
 * added socket creation for OAM
 *
 * Revision 1.19  2009/06/09 05:59:05  gur11083
 * changed for MIB and SFN
 *
 * Revision 1.18  2009/06/06 15:14:06  gur11083
 * changed for UE reconfig and delete
 *
 * Revision 1.17  2009/06/05 14:12:15  gur11083
 * added number of harq process in add UE
 *
 * Revision 1.16  2009/06/05 13:58:10  gur18569
 * fixed bugs
 *
 * Revision 1.15  2009/06/04 12:56:43  gur15697
 * freeTempRNTI()  changed to  freeRNTI()
 *
 * Revision 1.14  2009/06/04 06:03:57  gur11083
 * modified for cell config and UE create
 *
 * Revision 1.13  2009/06/02 08:05:38  gur18569
 * renamed parseReconfigLCReq to parseReconfigLcReq
 *
 * Revision 1.12  2009/06/01 13:53:16  gur20470
 * changed RXPORT to rxPortMAC_g and TXPORT txPortMacRRC_g
 *
 * Revision 1.11  2009/06/01 10:11:18  gur20470
 * compilation errors solved
 *
 * Revision 1.10  2009/06/01 06:46:14  gur18569
 * removed compilation errors
 *
 * Revision 1.9  2009/05/28 13:26:27  gur20470
 * incorporated review comments
 *
 * Revision 1.8  2009/05/21 15:30:37  gur20470
 * resolved compilation errors
 *
 * Revision 1.7  2009/05/21 15:26:13  gur20470
 * resolved compilation errors
 *
 * Revision 1.6  2009/05/19 13:00:34  gur20470
 * corrected error
 *
 * Revision 1.5  2009/05/18 11:55:34  gur20470
 * added comments
 *
 * Revision 1.4  2009/05/18 08:25:08  gur20470
 * changed the code for all TLV sequence
 *
 * Revision 1.3  2009/05/18 07:27:54  gur20470
 * validations added
 *
 * Revision 1.2  2009/05/18 05:15:57  gur20470
 * sfn err indication added
 *
 * Revision 1.1  2009/05/18 04:28:11  gur20470
 * *** empty log message ***
 *
 *****************************************************************************/

/******************************************************************************
  * Standard Library Includes
 *****************************************************************************/

/******************************************************************************
 * Project Includes
 *****************************************************************************/
#include "lteMacPDCCHMgr.h"
#include "lteMacParseUtil.h"
#include "lteMacSFNMgr.h"
#include "lteMacPCCH.h"
#include "lteMacComPorting.h"
#include "lteMacBCCH.h"
#include "lteMacCCCH.h"
#include "lteMacTypes.h"
#include "lteMacCellConfMgr.h"
#include "lteMacUEConfMgr.h"
#include "lteMacReceiver.h"
#include "lteMacCellConfMgr.h"
#include "lteMacRandomAccess.h"
#include "lteLog.h"
#include "lteMacDemux.h"
#include "lteMacParseOAMMsg.h"
#include "lteMacOAMInterface.h"
#include "lteMacPUCCH.h"
#include "lteMacULQueueLoad.h"
#include "lteMacCQI.h"
#include "lteMacComPorting.h"
#include "lteOamInterface.h"
#include "lteMacPRSMgr.h"
#include "lteCommonStatsManager.h"
#include "lteOamInterface.h"
#include "mqueue.h"
#ifdef TDD_CONFIG
#include "lteMacPRACH.h"
#include "lteMacTDDConfig.h"
    /* + SPS_TDD_Changes*/
#include "lteMacTddMgr.h"
    /* - SPS_TDD_Changes*/
#endif
#include "lteMacPhyCellReconfig.h"
#include "lteMacDLSpsScheduler.h"
#include "lteMacRRMInterface.h"
#include "lteMacPorting.h"
#include "lteMacULQosScheduler.h"
#include "lteMacDLQosScheduler.h"
#include "lteMacRRMPeriodicMgr.h"
#include "lteMacSpsPDSCHmgr.h"
#include "lteMacULSpsScheduler.h"
#include "ltePerfStats.h"
#include "lteMacULResourceInfoMgr.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "lteMacEmbmsUtil.h"
#include "lteMacEMbmsSchedulerStrategy.h"
#include "lteMacEmbmsSyncInterface.h"
#endif

/******************************************************************************
 * Private Definitions
 *****************************************************************************/
/*+ SPR 18399*/
#ifdef LTE_EMBMS_SUPPORTED
/* SPR fix 18197*/
#ifdef LTE_EMBMS_UESIM_TESTING
extern Sib13Info sib13AreaInfo_g[MAX_NUM_CELL][DELETE_AREA_INFO_PTR+1];
#endif
#endif

/* SPR 22275 fix start */
extern UInt16 totalActiveUEsDL_g[MAX_NUM_CELL];
/* SPR 22275 fix end */
/*- SPR 18399*/

#ifdef FDD_CONFIG
extern void triggerSpsImplicitRelease(ULUEContext *ulCntxt_p, SpsCause event, InternalCellIndex internalCellIndex);
extern void triggerSpsExplicitRelease(ULUEContext *ulCntxt_p, SpsCause event, InternalCellIndex internalCellIndex);
#endif
extern ReconfigPhyCell reconfigPhyCell_g[MAX_NUM_CELL];
extern ReconfigMacCell reconfigMacCell_g[MAX_NUM_CELL];
/* SPR 14829 Fix Start */
extern UInt16 macResetStats(InternalCellIndex  internalCellIndex);
/* SPR 14829 Fix Start */
#ifdef TDD_CONFIG
/* SPR 19679: TDD HARQ Multiplexing Changes Start */
#define TDD_CONFIG_FIVE 5
/* SPR 19679: TDD HARQ Multiplexing Changes End */
#endif
/* SPR 23402 Changes Start */
/* MOCN CHANGES START */
extern mocnOperatorParams mocnOperatorParams_g;
/* MOCN CHANGES END */
/* SPR 23402 Changes End */
	/* Dynamic PDCCH + 5117 changes starts*/
	/* CA Changes start */
extern void calculateMCSRBForCodeRateUECategory(InternalCellIndex internalCellIndex);
extern void postCellSetupInd(InternalCellIndex internalCellIndex);
extern void cleanupUlSchUciRachContainer(InternalCellIndex internalCellIndex);
extern void cleanupMacRRMInterface(InternalCellIndex internalCellIndex);
extern void cleanupTpcRntiContextForPusch(InternalCellIndex internalCellIndex);
extern  void cleanpContentionFreeRACHPool(InternalCellIndex internalCellIndex);
extern void deInitTpcRntiContextForPusch(InternalCellIndex internalCellIndex);
extern void deInitAfterCellDeleteDL(UInt32 rmSize, InternalCellIndex internalCellIndex);
extern void deInitAfterCellDeleteUL(UInt32 rmSize, InternalCellIndex internalCellIndex);
extern void triggerSpsExplicitRelease(ULUEContext *ulCntxt_p, SpsCause event, InternalCellIndex internalCellIndex);

#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
extern void resetPrevTickEventFdContainer(InternalCellIndex cellIndex);
#endif

/* + SPR_12546_12547 */
#ifdef KPI_STATS
/* + SPR 17439 */
extern void    checkAndSendKPIStats(void);
/* - SPR 17439 */
#endif
/* - SPR_12546_12547 */
/* CA Changes end */
/* Dynamic PDCCH + 5117 changes ends*/
/* + PRS_CHANGES */
 MacRetType  parsePRSConfigInfo(UInt8 *message_p,
        PRSParseConfigInfo *prsParseConfigInfo_p,
        UInt16  tagLen,
        UInt8 dlRBs,
			UInt8 reconfigFlag
			/* CA changes Start */
			,InternalCellIndex internalCellIndex
			/* CA Changes end */
			);
	/* - PRS_CHANGES */
/* + SPS_TDD_Changes */
static void checkMeasGapAndSendUEForSPSDeactDL( DLUEContext * dlUEContext_p, 
        InternalCellIndex internalCellIndex);
static void checkMeasGapAndSendUEForSPSDeactUL( ULUEContext * ulUEContext_p,
        InternalCellIndex internalCellIndex);
/* - SPS_TDD_Changes */
STATIC  void getFailedLcs( UeContextForDownlink  *dwlkUEInfo_p,
        UeContextForUplink *uplkUEInfo_p, LCConfigResp *lcResp_p,
        ULReconfigUeResp *ulReconfigUeResp_p, 
        DLReconfigUeResp *dlReconfigUeResp_p
        ); 
STATIC  void setLCErrorResponse( DLUEContext *dlUEContext_p,
        ULUEContextInfo *uLUEContextInfo_p, UInt8 *msgBuff, 
        LCConfigResp *lcResp_p, UInt16 *current_p_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ); 
STATIC  void prepareMacCreateUeEntityCnf( UInt16 msgId, UInt8 *msgBuf,
        void  *data_p, UInt16 *current_p_p, UeContextForDownlink *dlUEInfo,
        UeContextForUplink *ulUEInfo
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacReconfigUeEntityCnf( UInt16 msgId, UInt8 *msgBuf,
        void *data_p, UInt16 *current_p_p, UeContextForDownlink *dlUEInfo,
        UeContextForUplink   *ulUEInfo
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeResp *ulReconfigUeResp_p, 
        DLReconfigUeResp *dlReconfigUeResp_p
        );
STATIC  void prepareMacUeEntityPowerHeadroomInd( UInt16 msgId,
        UInt8 *msgBuf, void *data_p, UInt16 *current_p_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacCcchMsgInd( UInt16 msgId, UInt8  *msgBuf,
        void *data_p, UInt16 *current_p_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
RrmMacCellConfigErrorCode  macReconfigureDlUeLCTree (InternalCellIndex  internalCellIndex, DLUEContext  *ueDLContext_p);
RrmMacCellConfigErrorCode  macReconfigureDlUeGBR (InternalCellIndex  internalCellIndex, DLUEContext  *ueDLContext_p);
RrmMacCellConfigErrorCode  macReconfigureUlUeLCTree (InternalCellIndex  internalCellIndex, ULUEContext  *ueULContext_p);
RrmMacCellConfigErrorCode  macReconfigureUlUeGBR (InternalCellIndex  internalCellIndex, ULUEContext *ULUEContext);

	/* Start of change for VARIBLE Declarion*/
	/*CA Changes start  */
mapInfo* measGap40msInfo_gp[MAX_NUM_CELL] = {PNULL};
mapInfo* measGap80msInfo_gp[MAX_NUM_CELL] = {PNULL};
#ifdef ENDC_ENABLED
/*Meas_Gap_Changes_Start*/
mapInfo* measGap20msInfo_gp[MAX_NUM_CELL] = {PNULL};
mapInfo* measGap160msInfo_gp[MAX_NUM_CELL] = {PNULL};
/*Meas_Gap_Changes_End*/
#endif
mapInfo* shortPeriodicSRSMapInfo_gp[MAX_NUM_CELL] = {PNULL};
mapInfo* longPeriodicSRSMapInfo_gp[MAX_NUM_CELL] = {PNULL};
mapInfo* longPeriodicSRCQIPMIRIMapInfo_gp[MAX_NUM_CELL] = {PNULL};
mapInfo* shortPeriodicSRMapShortInfo_gp[MAX_NUM_CELL] = {PNULL};
/*CA Changes end  */

UInt32 ( *dlApiHandlerFunc[MAC_MAX_API] ) (
        RrcOamHiPrioQNode *, RrcOamHiPrioQNode *, InternalCellIndex ) =
{
    NULL,     /* 0 message ID */
    NULL,     /*MAC_CONFIG_CELL_REQ*/
    NULL,     /*MAC_SFN_REQ*/
    NULL,   /*MAC_RECONFIG_CELL_REQ*/
    dlCreateUeReqHPHandler,       /*MAC_CREATE_UE_ENTITY_REQ*/
    dlDeleteUeReqHPHandler,       /*MAC_DELETE_UE_ENTITY_REQ*/
    dlReconfigUeReqHPHandler,     /*MAC_RECONFIGURE_UE_ENTITY_REQ*/
    NULL,         /*MAC_UE_DRX_CMD_REQ*/
    NULL,           /*MAC_BCCH_MSG_REQ*/
    NULL,           /*MAC_PCCH_MSG_REQ*/
    NULL,           /*MAC_CCCH_MSG_REQ*/
    NULL,       /*MAC_UE_CON_REJ_REQ*/
    NULL,     /*MAC_DELETE_CELL_REQ*/
    NULL,      /*MAC_HO_RACH_RESOURCE_REQ*/
	NULL,   /* 14 - API ID not valid */
    dlResetUeReqHPHandler,         /*MAC_RESET_UE_ENTITY_REQ*/
    NULL    /*MAC_CHANGE_CRNTI_REQ*/
} ;

UInt32 ( *ulApiHandlerFunc[MAC_MAX_API] ) (
        RrcOamHiPrioQNode *, RrcOamHiPrioQNode *
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */       
        ) = 
{
    NULL,     /* MessageId 0*/
    NULL,     /*MAC_CONFIG_CELL_REQ*/
    NULL,     /*MAC_SFN_REQ*/
    NULL,   /*MAC_RECONFIG_CELL_REQ*/
    ulCreateUeReqHPHandler,       /*MAC_CREATE_UE_ENTITY_REQ*/
    ulDeleteUeReqHPHandler,       /*MAC_DELETE_UE_ENTITY_REQ*/
    ulReconfigUeReqHPHandler,     /*MAC_RECONFIGURE_UE_ENTITY_REQ*/
    NULL,         /*MAC_UE_DRX_CMD_REQ*/
    NULL,           /*MAC_BCCH_MSG_REQ*/
    NULL,           /*MAC_PCCH_MSG_REQ*/
    NULL,           /*MAC_CCCH_MSG_REQ*/
    NULL,       /*MAC_UE_CON_REJ_REQ*/
    NULL,     /*MAC_DELETE_CELL_REQ*/
    NULL,      /*MAC_HO_RACH_RESOURCE_REQ*/
	NULL,       /* 14 - API ID not valid */
    ulResetUeReqHPHandler,         /*MAC_RESET_UE_ENTITY_REQ*/
    NULL    /*MAC_CHANGE_CRNTI_REQ*/
};

/*CA changes start*/
RrcOamHiPrioQNode *ulRrcOamDeleteUeQNodeReq_p[MAX_NUM_CELL]     = {PNULL};
RrcOamHiPrioQNode *dlRrcOamDeleteUeQNodeReq_p[MAX_NUM_CELL]     = {PNULL};
/*CA changes end */

STATIC  void processAndUpdateULReconfigPucchInfo( UInt16 ueIndex, 
        ULUEContext *ulUEContext_p, ULReconfigUeReq *ulReconfigUeReq_p,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex);
STATIC  void processAndUpdateULReconfigSRSConfig( 
        ULUEContext *ulUEContext_p, ULReconfigUeReq  *ulReconfigUeReq_p,
        ULReconfigUeResp *ulReconfigUeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        );
STATIC  MacRetType processAndUpdateULReconfigSPSParams(
        ULUEContext *ulUEContext_p, ULReconfigUeReq *ulReconfigUeReq_p,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType processAndUpdateULReconfigAmbrInfo(
        ULUEContext *ulUEContext_p);
STATIC  MacRetType processAndUpdateDLReconfigCqiInfo( UInt16 ueIndex,
        DLCQIInfo *dlCQIInfo_p, DLReconfigUeReq *dlReconfigUeReq_p, 
        /* SPR 9427 changes start */
        DLUEContext *dlUEContext_p, ULUEContext *ulUEContext_p,
        /* SPR 9427 changes end */
        /* CA changes Start */
        InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void processAndUpdateDLRecfgMeasGapConfig(
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        ULUEContext *ulUEContext_p,InternalCellIndex internalCellIndex );
#ifdef HD_FDD_CONFIG
STATIC  void processAndUpdateDLReconfigRFParams( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        InternalCellIndex internalCellIndex);
#endif
/* CA changes Start */
STATIC  MacRetType processAndUpdateDLReconfigSPSParams( UInt16 ueIndex,
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType ulConfigureLcInfo(ULReconfigUeReq *ulReconfigLcReq_p, 
        ULUEContext *ueContext_p,
        InternalCellIndex internalCellIndex
        );
extern MacRetType CreateUEDLConfigCnf (DLCreateUeResp *dlCreateUeResp_p,
        UeContextForDownlink *dwlkUEInfo_p, InternalCellIndex internalCellIndex
        );
extern UInt8 phyReleaseCapability_g;
typedef void (*lteLPrioThrApiHandlerFuncPtr) (UInt16, 
        MacProcessRrcOamMsgEvent, LP_RrcOamPendingReq, RrcOamHiPrioQNode *, 
        void *, void *, InternalCellIndex internalCellIndex);
STATIC void setResponseBitmask( UInt8 threadId, void *data_p,
        InternalCellIndex internalCellIndex );
STATIC void rrcMsgProcessPendingHandler( InternalCellIndex internalCellIndex );

STATIC void rrcStateMachineHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacInvalidEvent( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void rrcOamPendingReqHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void rrcOamPendingResetHadler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,    
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void macCreateUeRequestHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacCreateUeReqLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void macReconfigUeRequestHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacReconfigUeReqLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacHoRachResourceReqLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
/* SPR 8379 changes start */
STATIC void lteMacIntraHoResReqLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
/* SPR 8379 changes end */
STATIC void lteMacResetUeBeforeHarqResetLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacResetUeAfterHarqResetLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacChangeCRNTIReqLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void macDeleteUeRequestHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
STATIC void lteMacDeleteUeReqLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
/* SPR 16583 fix start */
STATIC void lteMacHoRachReleaseLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
/* SPR 16583 fix end */
STATIC void rrcMsgEnqueuePendingHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex);
/* CA changes end */
/* SPR 9427 changes start */
void initNonSpatialRAT0RAT1Bitmaps(UInt8 cqiValue,
        CQIInfoNonSpatialMul *cqiInfoNonSpatialMul_p,
        InternalCellIndex internalCellIndex);

void initSpatialRAT0RAT1Bitmaps(UInt8 cqiIndex,
        CQIInfoSpatialMul *cqiInfoSpatialMul_p,
        InternalCellIndex internalCellIndex);

void initNumOfSBperBWpart(DLCQIInfo *dlCQIInfo_p,
        InternalCellIndex internalCellIndex);
/* SPR 9427 changes end */
/*Coverity 66931 Fix*/
STATIC RRCTag checkForOpCode(LCOperationType opCode);
STATIC SInt32 readDataFromRxSockFd(UInt8 *msgHdr ,UInt32 msgLen ,
        SInt32 flag,InternalCellIndex internalCellIndex);

/* State Machine for RRC messages to be handled between HP and LP messages */
static lteLPrioThrApiHandlerFuncPtr lteLPrioThrApiHandlerFuncTable
[MAC_CTRL_MAX_ST]
[MAC_CTRL_MAX_EV] =
{
    { /* MAC_CTRL_IDLE_ST */
        macCreateUeRequestHandler,   /* MAC_RRC_CREATE_UE_ENTITY_EV */
        lteMacInvalidEvent,          /* MAC_HP_CREATE_UE_ENTITY_EV */
        macReconfigUeRequestHandler, /* MAC_RRC_RECONFIG_UE_ENTITY_EV */
        lteMacInvalidEvent,          /* MAC_HP_RECONFIG_UE_ENTITY_EV */
        macDeleteUeRequestHandler,   /* MAC_RRC_DELETE_UE_ENTITY_EV */
        lteMacInvalidEvent,          /* MAC_HP_DELETE_UE_ENTITY_EV */
        rrcOamPendingReqHandler,     /* MAC_RRC_HO_RACH_RESOURCE_EV */
        lteMacInvalidEvent,          /* MAC_HP_HO_RACH_RESOURCE_EV */
        /* SPR 8379 changes start */
        lteMacInvalidEvent,          /* MAC_HP_INTRA_HO_RACH_RESOURCE_EV */
        /* SPR 8379 changes end */
        rrcOamPendingReqHandler,     /* MAC_RRC_RESET_REQ_EV */
        /* MAC_HP_RESET_UE_BEFORE_HARQ_RESET_ENTITY_EV */
        lteMacInvalidEvent, 
        lteMacInvalidEvent, /* MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV */
        /* MAC_HP_SEND_RESET_REQ_AGAIN */
        lteMacInvalidEvent,
        rrcOamPendingReqHandler, /* MAC_RRC_CHANGE_CRNTI_EV */
        lteMacInvalidEvent,      /* MAC_HP_CHANGE_CRNTI_EV */
        /* SPR 16583 fix start */
        rrcOamPendingReqHandler,  /* MAC_RRC_HO_REL_RACH_RESOURCE_EV */
        lteMacInvalidEvent,       /* MAC_HP_HO_REL_RACH_RESOURCE_EV */
        /* SPR 16583 fix end */
    },
    { /* WAIT_FOR_MAC_THREAD */
        rrcMsgEnqueuePendingHandler,  /* MAC_RRC_CREATE_UE_ENTITY_EV */
        lteMacCreateUeReqLPHandler,   /* MAC_HP_CREATE_UE_ENTITY_EV */
        rrcMsgEnqueuePendingHandler,  /* MAC_RRC_RECONFIG_UE_ENTITY_EV */
        lteMacReconfigUeReqLPHandler, /* MAC_HP_RECONFIG_UE_ENTITY_EV */
        rrcMsgEnqueuePendingHandler,  /* MAC_RRC_DELETE_UE_ENTITY_EV */
        lteMacDeleteUeReqLPHandler,   /* MAC_HP_DELETE_UE_ENTITY_EV */
        rrcMsgEnqueuePendingHandler,  /* MAC_RRC_HO_RACH_RESOURCE_EV */
        lteMacHoRachResourceReqLPHandler, /* MAC_HP_HO_RACH_RESOURCE_EV */
        /* SPR 8379 changes start */
        lteMacIntraHoResReqLPHandler, /* MAC_HP_INTRA_HO_RACH_RESOURCE_EV */
        /* SPR 8379 changes end */
        rrcMsgEnqueuePendingHandler,  /* MAC_RRC_RESET_REQ_EV */
        /* MAC_HP_RESET_UE_BEFORE_HARQ_RESET_ENTITY_EV */
        lteMacResetUeBeforeHarqResetLPHandler, 
        /* MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV */
        lteMacResetUeAfterHarqResetLPHandler,
        /* MAC_HP_SEND_RESET_REQ_AGAIN */
        rrcOamPendingResetHadler, 
        rrcMsgEnqueuePendingHandler,   /* MAC_RRC_CHANGE_CRNTI_EV */
        lteMacChangeCRNTIReqLPHandler, /* MAC_HP_CHANGE_CRNTI_EV */
        /* SPR 16583 fix start */
        rrcMsgEnqueuePendingHandler,  /* MAC_RRC_HO_REL_RACH_RESOURCE_EV */
        lteMacHoRachReleaseLPHandler, /* MAC_HP_HO_REL_RACH_RESOURCE_EV */
        /* SPR 16583 fix end */
    },
};

/* Global variable for State machine to handle RRC-OAM messages */
/*+COVERITY 5.2.2 - 32675*/
MacRrcOamMsgHandler rrcOamMsghandler[MAX_NUM_CELL];
/*-COVERITY 5.2.2 - 32675*/

/* CA Changes start */
/* +- SPR 17777 */
STATIC void lteMacProcessControlInfoFromPhysical(
        void* recvBuffer_p, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacTimeOutCellDelPhyHandler (
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacTimeOutCellStopPhyHandler (
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
/* SPR 19288 change start */
#if defined (FLEXRAN)
/*SPR 21001 Changes start */
void lteMacMacInitLayerPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex );
#else
STATIC void lteMacMacInitLayerPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex );
/*SPR 21001 Changes end */
#endif
/* SPR 19288 change end */
STATIC void lteMacReTryMacInitLayerPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex );
STATIC void lteMacReTryStartPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex );

/* SPR 19288 change start */
#if defined (FLEXRAN)
/*SPR 21001 Changes start */
void lteMacStartPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
void lteMacConfigCellReqPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
#else
STATIC void lteMacStartPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacConfigCellReqPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
/*SPR 21001 Changes end */
#endif
/* SPR 19288 change end */
STATIC void lteMacReTryConfigCellReqPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacReconfigCellReqPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacReTryReconfigCellReqAfterCellStopPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacReTryReconfigCellReqInPhyRunningPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacCellStopReqPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
STATIC void lteMacCellDeleteReqPhyHandler(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
/*SPR 21001 Changes end */
STATIC void lteMacInvalidPhyCellEvent(
        void * msgBuf, SInt32 byteRead,InternalCellIndex internalCellIndex);
typedef void (*lteLPrioThrPhyApiHandlerFuncPtr) (void*, 
        SInt32,InternalCellIndex);

/* State Machine for to handle PHY messages */
static lteLPrioThrPhyApiHandlerFuncPtr lteLPrioThrPhyApiHandlerFuncTable
[CELL_CTRL_MAX_ST]
[MAC_PHY_CTRL_MAX_EV] =
{
    {
        /* CELL_INIT */
        lteMacInvalidPhyCellEvent, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacInvalidPhyCellEvent, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    { /* CELL_WAITING_FOR_PHY_CAPABILITY */
        lteMacMacInitLayerPhyHandler,   /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacReTryMacInitLayerPhyHandler, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    {
        /* CELL_PHY_INIT */ 
        lteMacInvalidPhyCellEvent, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacInvalidPhyCellEvent, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    { /* CELL_WAITING_FOR_PHY_CONFIG */
        lteMacConfigCellReqPhyHandler,  /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacReTryConfigCellReqPhyHandler, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    {
        /* CELL_PHY_CONFIG */
        lteMacInvalidPhyCellEvent, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacInvalidPhyCellEvent, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    /* + SPR_10941 */
    { /* CELL_WAIT_FOR_PHY_START */
        lteMacInvalidPhyCellEvent, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacInvalidPhyCellEvent, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    /* - SPR_10941 */
    { /* CELL_WAITING_FOR_FIRST_SFI */
        lteMacStartPhyHandler,         /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacReTryStartPhyHandler,   /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    {
        /* CELL_PHY_RECONFIG_RECVD_AFTER_CELL_STOP */
        lteMacReconfigCellReqPhyHandler,  /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacReTryReconfigCellReqAfterCellStopPhyHandler, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    { 
        /* CELL_PHY_RUNNING_CONFIG_RECVD */
        lteMacProcessControlInfoFromPhysical, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacReTryReconfigCellReqInPhyRunningPhyHandler,   /* MAC_REQ_TIMEOUT_RETRY_EV */

    },
    {
        /* + SPR_10941 */
        /* CELL_WAITING_FOR_PHY_STOP_AFTER_DELETE_REQ */
        /* - SPR_10941 */
        lteMacCellDeleteReqPhyHandler, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacTimeOutCellDelPhyHandler,  /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    {
        /* CELL_PHY_STOP */
        lteMacInvalidPhyCellEvent, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacInvalidPhyCellEvent, /* MAC_REQ_TIMEOUT_RETRY_EV */
    },
    /* + SPR_10941 */
    {
        /* CELL_WAITING_FOR_PHY_STOP_AFTER_STOP_REQ */
        lteMacCellStopReqPhyHandler, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacTimeOutCellStopPhyHandler, /* MAC_REQ_TIMEOUT_RETRY_EV */ 
    },   
    /* - SPR_10941 */
    {
        /* CELL_PHY_RUNNING */
        lteMacInvalidPhyCellEvent, /* MAC_RECV_MSG_FROM_PHY_EV */
        lteMacInvalidPhyCellEvent, /* MAC_REQ_TIMEOUT_RETRY_EV */
    } ,
    /*+ SPR 18399*/
    /*- SPR 18399*/
};
/* SPR 4915 : Start */
extern SEM_T waitForCellSetupIndSemArr_g[NUM_OF_EXEC_FLOWS * MAX_NUM_CELL];
/* CA Changes end */
/* SPR 4915 : End */
/******************************************************************************
  Private Types
 *****************************************************************************/
extern LTE_SQUEUE* recvDataFromPhyQ_gp[MAX_NUM_CELL];
#ifdef TDD_CONFIG
extern void initUlDLExecutionFlow(InternalCellIndex internalCellIndex);
#endif
extern LTE_CIRCQUEUE rcvdRRCOAMMsg_g;
/* Socket FD for receiving messages */ 
SInt32 rxSockFD_g;
void initULSpsTTIContextMap(UInt32 rmSize
        /* CA Changes start */
        , InternalCellIndex internalCellIndex);
/* CA Changes end */
/* SPR 7787 fix start */
/* CA Changes start */
#ifndef FLEXRAN
extern SInt32 phyRxSockFD_g[MAX_NUM_CELL];
#endif
/* CA Changes end */
extern fd_Set staticReadFds;
/* SPR 7787 fix start */
/* This queue is used to store the messages received from RRC-OAM if it is not
 * in a state to process the message, i.e., it is processing some other 
 * message */
RRC_OAM_PENDING_QUEUE_TYPE rrcOamPendingQ_g[MAX_NUM_CELL];

extern RRC_OAM_LPTOHP_THDH_PRIO_TYPE rrcOamLPtoHPThdHPrioQ_g[MAX_NUM_CELL][MAX_THD];
extern RRC_OAM_HPTOLP_THDH_PRIO_TYPE rrcOamHPtoLPThdHPrioQ_g[MAX_NUM_CELL][MAX_THD];
extern PDCCH_RACH_INTERFACE_TYPE* pdcchRachInterfaceQueue_gp[MAX_NUM_CELL];
/* response pointers */
RrcOamHiPrioQNode *rrcOamHPResp_g[MAX_NUM_CELL][MAX_THD] = {{0}};
/* CA changes start */
extern RRMMACCellGlobal *rrmMacCellGlobal_gp[MAX_NUM_CELL];
/* CA changes end */
extern UInt8 ulImplicitReleaseAfterMap[INVALID_IMPLICIT_RELEASE]; 
extern UInt16 allocateSpsCrnti(InternalCellIndex internalCellIndex);
/* + SPR 17439 */
extern void initComRRCAndOAMInterface(void);
/* - SPR 17439 */
extern MacRetType sendConfigPhyCell(InternalCellIndex internalCellIndex);
extern MacRetType fapiSendPhyParamReq(InternalCellIndex internalCellIndex );
/* + SPR_13064 */ 
extern MacRetType sendReConfigPhyCellAfterCellStop(InternalCellIndex internalCellIndex);
/* - SPR_13064 */ 
extern UInt32 handleConfigPhyCellRes( UInt8 * msgBuf, SInt32 bytesRead);

extern UInt32 handleStopPhyRes(UInt8 *msgBuf,SInt32 bytesRead);
/* CA Changes start */
void sendStartPhyInd(InternalCellIndex internalCellIndex);
extern UInt32 handleStartPhyRes(UInt8 *msgBuf,SInt32 bytesRead,
        InternalCellIndex internalCellIndex);
extern UInt32 handleReConfigPhyCellAfterCellStop(UInt8 *msg_p, 
        UInt16 totalMsgLen, InternalCellIndex internalCellIndex );
extern UInt32 handlePhyParamReqResp(UInt8 *msgBuf,SInt32 bytesRead,
        InternalCellIndex internalCellIndex);
extern void processControlInfoFromPhysical (UInt8 * msgBuf, Int bytesRead,
        InternalCellIndex internalCellIndex);
/* +- SPR 17777 */
extern MacRetType parseAndSendConfigPhyCell(UInt8 *msg_p,
        UInt16 totalMsgLen,InternalCellIndex internalCellIndex );
/* +- SPR 17777 */
/* SPR 21407 fix start */
extern MacRetType sendStopReqToPhy(InternalCellIndex internalCellIndex);
/* SPR 21407 fix end */
extern MacRetType sendAndParseReConfigPhyCellAfterCellStop(UInt8 *msg_p,
        UInt16 totalMsgLen, InternalCellIndex internalCellIndex);
#ifndef FLEXRAN
extern SInt32 receiveStartPhyRes(UInt8 *msgBuf,
        InternalCellIndex internalCellIndex);
#endif
extern SInt32 recvControlInfoFromPhysical(void* msgBuf_p,
        InternalCellIndex internalCellIndex);
/* CA Changes end */

UInt32 ueReconfigComplete = 0;

/* + Critical section changes */
extern LTE_SEM cellSyncSem_g;
/* - Critical section changes */
/*****************************************************************************
 * Private Function Prototypes
 ****************************************************************************/
#ifdef UTFWK_SIMULATION
extern volatile UInt8 phyCellConfigured_g; 
#endif
/*SPR 21653 changes start*/
/*code removed*/
/*SPR 21653 changes end*/

#define MAX_STR_LENGTH  32

UInt8 init_arr_ue_context(UChar8 *filename, UInt8 *buffer, UInt8 operation, UInt16 *new_msgLen, UInt16 ueindex);

void handleStopPhyCellDeleteRes(UInt16 transactionId, UInt32 response);
extern MacRetType sendStartReqToPhy(InternalCellIndex internalCellIndex);

#define MAX_PARAM_MAC_INIT_REQUEST_RETRY        3
#define MAX_PARAM_PHY_CONFIG_REQUEST_RETRY      3
#define MAX_PARAM_PHY_RECONFIG_REQUEST_RETRY    3
#define MAX_PARAM_PHY_START_REQUEST_RETRY       3

/*Dynamic Pdcch Changes Start*/
extern UInt8 calNumOfRbFromBitmapfor20And15Mhz(UInt32 resrcAssignementBitMap,UInt32 *numOfOverLappingRbsInfo_p);
extern UInt8 calNumOfRbFromBitmapfor10Mhz(UInt32 resrcAssignementBitMap,UInt32 *numOfOverLappingRbsInfo_p);
extern UInt8 calNumOfRbFromBitmapfor5Mhz(UInt32 resrcAssignementBitMap,UInt32 *numOfOverLappingRbsInfo_p);
extern UInt8 calNumOfRbFromBitmapfor3Mhz(UInt32 resrcAssignementBitMap,UInt32 *numOfOverLappingRbsInfo_p);
/* + SPR 17439 */
extern  void createMapForMaxMCS(void);
/* - SPR 17439 */
/*Dynamic Pdcch Changes End*/

/* This function processes the RRC message and calls
   the functions for different APIs MAC_SFN_REQ, MAC_RECONFIG_CELL_REQ 
   MAC_CREATE_UE_ENTITY_REQ, MAC_UE_DRX_CMD_REQ, MAC_DELETE_UE_ENTITY_REQ,
   MAC_RECONFIGURE_UE_ENTITY_REQ, CREATE_RLC_UE_ENTITY_REQ ,
   RECONFIG_RLC_UE_ENTITY_REQ , DELETE_RLC_UE_ENTITY_REQ, MAC_DELETE_CELL_REQ,
   MAC_CELL_STOP_REQ, MAC_CELL_START_REQ             
   */
/* CA changes Start */
 static void macParseRRCMsg( UInt8 *msg_p,
        UInt16 msgId,
        UInt16 msgLen,
        UInt16 transactionId,
        InternalCellIndex internalCellIndex
        );

/* This function processes the RRC message and call the functions for different APIs                               
   MAC_UE_CON_REJ_REQ, MAC_CONFIG_CELL_REQ, MAC_PCCH_MSG_REQ, MAC_CCCH_MSG_REQ, 
   MAC_BCCH_MSG_REQ
   */
/*SPR 2446 Fix Begins*/
STATIC  void parseZeroBufferRRCMsg ( void *zeroBuffer_p,
        UInt8 *msg_p,
        UInt16 msgId,
        UInt16 totalMsgLen,
        UInt16 transactionId,
        InternalCellIndex internalCellIndex
        );
/*SPR 2446 Fix Ends*/
STATIC  MacRetType parseUEConRejReq( UInt8 *current_p,
        void * zeroBuff_p,
        UInt16 totalMsgLen,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex
        );
/* +- SPR 17777 */
STATIC  MacRetType parseConfigCellReq (
        UInt8 *current_p,
        UInt16 totalMsgLen,
        ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex );
STATIC  MacRetType validatePrachConfigIdx(
        UInt8 prachConfigurationIndex, UInt8 prachFrequencyOffset,
        /* +- SPR 17777 */
        ConfigCellReq *configCellReq_p
        /* +- SPR 17777 */
        );
/* +- SPR 17777 */

STATIC  void initAfterCellConfig(InternalCellIndex internalCellIndex);
STATIC  MacRetType parseReconfigCellReq ( UInt8 *current_p,
        UInt16 totalMsgLen,
        InternalCellIndex internalCellIndex
        );
/* CA Changes end */
STATIC  MacRetType parseCreateUEEntityReq ( UInt8 *msg_p,
        UInt16 msgLen,
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType validateAndParseCreateUEEntityParams( UInt8 **msgBuf, 
        UInt16 *addUEInfoTagLen_p, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUEReqParams( UInt8 **msgBuf, 
        UInt16 *msgLen_p, UInt16 addUEInfoTagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType validateAndParseCreateSRConfigInfo( UInt8 **msgBuf, 
        UInt16 *msgLen_p, UInt16 *tagLen_p, UeContextForUplink *ulCreateReq_p,
        UInt8 *isContinueFlag_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUESRConfigInfo( UInt8 **msgBuf, 
        UInt16 *msgLen_p, UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUESRProhibitTimerV920( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUECqiInfo( UInt8 **msgBuf, UInt16 tagLen,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCqiPeriodicPMIConfigIndex( UInt8 **msg_p,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUECqiV920Info( UInt8 **msgBuf,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUECodebookSubsetRestriction( 
        UInt8 **msgBuf, UInt16 tagLen, UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
/* SPR 12240 Changes Start */
STATIC  MacRetType parseCreateUECodebookSubsetRestrictionV1020( 
        UInt8 **msgBuf, UInt16 tagLen, UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUECodebookSubsetRestrictionV920( 
        UInt8 **msgBuf, UInt16 tagLen, UeContextForDownlink *dlCreateReq_p 
        ,InternalCellIndex internalCellIndex
        );
/* SPR 12240 Changes End */
STATIC  MacRetType parseCreateUEDRXConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUEMeasGapConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUEPuschConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUEULPowerCtrlDedicated( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUETpcPdcchConfigPucch( UInt8 **msgBuf, 
        /* +- SPR 17777 */
        UInt16 tagLen,
        /* +- SPR 17777 */
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUETpcPdcchConfigPusch( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseUECapAdditionalParams (UInt8 **msgBuf, 
        UInt16 len, UeContextForDownlink *dlUEInfo_p, 
        InternalCellIndex internalCellIndex
        );
/* CA Changes end */
STATIC  MacRetType parseCreateUserLocationType( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p );
/* CA changes Start */
STATIC  MacRetType parseCreateRFParams( UInt8 **msgBuf, UInt16 tagLen,
        /* +- SPR 17777 */
#ifdef HD_FDD_CONFIG
        UeContextForUplink *ulCreateReq_p,
#endif
        UeContextForDownlink *dlCreateReq_p,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUECategoryInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateUEPhrTimerConfig( UInt8 **msgBuf, 
        UInt16  tagLen, UeContextForUplink *ulCreateReq_p
        /* +- SPR 17777 */
        );
STATIC  MacRetType parseCreateUEComplianceRelease( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
/* +- SPR 17777 */
UInt32 populateLongSRInfo( PucchConfig *pucchConfig_p,SRConfigInfo *srConfigInfo_p
#ifdef TDD_CONFIG
        ,InternalCellIndex internalCellIndex
#endif
        );
/* +- SPR 17777 */
STATIC MacRetType validateCellIndex(UInt32 ueIndex, 
        InternalCellIndex internalCellIndex);
/* CA Changes end */

STATIC  MacRetType parseCreateUEULMuMimoInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC  void prepareReconfigDLULUEContext( 
        UeContextForUplink *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p);
STATIC  MacRetType parseReconfigureUEEntityReq( UInt8 *current_p,
        UInt16 totalMsgLen,
        UeContextForUplink *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p,
        InternalCellIndex internalCellIndex
        ,ULReconfigUeReq *ulReconfigUeReq_p
        ,DLReconfigUeReq *dlReconfigUeReq_p
        );
STATIC  UInt16 parseReconfigUEInfo( UeContextForDownlink *dlUEInfo_p,
        UInt8 *msg_p,
        UInt16 tagLen,
        UeContextForUplink *ulUEInfo_p
        /* + CL-MIMO LJA*/
        , UInt8 currentTransmissionMode
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        /* - CL-MIMO LJA*/
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        );
STATIC  void prepareLCErrorResponse( 
        UeContextForDownlink  *dwlkUEInfo_p,
        UeContextForUplink *uplkUEInfo_p,
        UInt8 *msgBuff, 
        UInt16 *current_p_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        /*SPR 4870 Changes Start*/ 
        ,ULReconfigUeResp *ulReconfigUeResp_p
        ,DLReconfigUeResp *dlReconfigUeResp_p
        /*SPR 4870 Changes End*/ 
        );
STATIC  MacRetType parseCreateLcReq ( UInt8 *msg_p,
        UInt16 origTagLen,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseUlLcCreateReq( UInt8 rlcMode, UInt8 lchId,
        UInt16 tag, UInt16 tagLen, UInt8 **msg_p, 
        UeContextForUplink *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseDlLcCreateReq( UInt8 rlcMode, UInt8 lchId,
        UInt16 tag, UInt16 tagLen, UInt8 **msg_p, 
        UeContextForDownlink *dlLCCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateLcQosInfo( UInt16 tagLen, UInt8 *msg_p,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseCreateLcRohcProfile( UInt8 lchId, UInt16 tagLen,
        UInt8 *msg_p, UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseDeleteLcReq( UInt8 *msg_p,
        UInt16 deleteLcReqTagLen,
        UeContextForDownlink *dlLCDeleteReq_p,
        UeContextForUplink *ulLCDeleteReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseReconfigLcReq( UInt8 *msg_p,
        UInt16 reconfigLcReqTagLen,
        UeContextForDownlink *dlLCReconfigReq_p,
        UeContextForUplink *ulLCReconfigReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseDLReconfigureLcReq(UeContextForDownlink *dlLCReconfigReq_p,
        UInt16 tagLen,
        UInt8 **msg_p,
        InternalCellIndex internalCellIndex
        );
/* CA Changes end */

STATIC  MacRetType reconfigureLcChangesForQos( UeContextForDownlink *dlLCReconfigReq_p,
        UeContextForUplink *ulLCReconfigReq_p,
        UInt8 **msg_p
        /* +- SPR 17777 */
        );

STATIC  MacRetType parseCqiPeriodicPMIConfigIndexV1020( UInt8 **msg_p,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

/******** Validation Functions ***********/
STATIC  MacRetType  validateNumOfTxAntennas( UInt8 numOfTxAntennas);
/*--coverity-530 CID 52747 */
#ifdef MAC_AUT_TEST
/*--coverity-530 CID 52747 */
STATIC  MacRetType validateRBs( ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType validateHarqParams ( UInt8 maxHarqRetrans);
STATIC  MacRetType  validateStartRARntiRange( UInt8 startRARntiRange,
        UInt8 endRARntiRange,
        InternalCellIndex internalCellIndex
        );
/*Rel 5.3: Coverity 52739 Fix Start */
/* Removed validateEndRARntiRange() */
/*Rel 5.3: Coverity 52739 Fix End */
STATIC  MacRetType  validatePhichDuration( UInt8 phichDuration );
STATIC  MacRetType  validatePhichResource( UInt8 phichResource );
STATIC  MacRetType validateLcGId(UInt8 lcGId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateLcType(UInt8 lcType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateRACHConfigInfo( UInt32 ra_ResponseWindowSize,
        UInt32 contentionResolutionTimer,
        UInt32 prach_ConfigurationIndex,
        UInt32 prach_FrequencyOffset
        );
/*--coverity-530 CID 52747 */
#endif
/*--coverity-530 CID 52747 */
/* + coverity 52748 */
#ifdef MAC_AUT_TEST 
STATIC  MacRetType validateRnti ( UInt16 tcRnti
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
#endif
/* - coverity 52748 */
STATIC  MacRetType validateUEIndex ( UInt32 ueIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* SPR 5084 changes start*/
STATIC  MacRetType validateUeCategory(UInt8 ueCategory
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* SPR 5084 changes end*/

/* SPR_1987 Start */
STATIC  MacRetType validateMaxUlHarqTx(UInt8 maxUlHarqTx
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  UInt8 convertMaxUlHarqEnumInVal(UInt8 maxUlHarqTx);
/* SPR_1987 End */

/*Fix for __SPR_1988__ START*/
STATIC  MacRetType validateTimeAlignmentTimer(UInt16 timeAlignmentTimer);
/*SPR_3061_FIX*/
STATIC  UInt16 convertTATimerInMs(UInt16 timeAlignmentTimer);
/*SPR_3061_FIX*/
/*Fix for __SPR_1988__ END*/

/* FREQ_SELECTIVE CHG */
STATIC  MacRetType validateFreqSelectiveEnable(UInt8 freqSelective);
/* FREQ_SELECTIVE CHG */
/* + coverity 52751, 52753 */
#ifdef MAC_AUT_TEST 
STATIC  MacRetType validateUePriority ( UInt8 uePriority
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateueNumHarqProcess ( UInt8 numHarqProcess
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
#endif
/* - coverity 52751, 52753 */

/* SPR 2063 start */
STATIC  MacRetType validateMcsIndex(UInt32 mcsIndex 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* SPR 2063 end */
STATIC  MacRetType validateDlMaxRB ( UInt8 MaxRB 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* + coverity 52752 */
#ifdef MAC_AUT_TEST
STATIC  MacRetType validatehScheme(UInt8 hScheme
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
#endif
/* + coverity 52752 */
STATIC  MacRetType validateTransmissionMode(UInt8 transmissionMode
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateSimultaneousACKNACKAndCQI( 
        UInt8 simultaneousACKNACKAndCQI
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateSRRequestType(UInt8 requestType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateSrConfigurationIndex(UInt8 srConfigurationIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateSrPucchResourceIndex(UInt16 srPucchResourceIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateCqiMode( UInt8 cqiMode);
STATIC  MacRetType validateNumOfLayer(UInt8 numOfLayer,
        UInt8 ueCategory
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* + coverity 52749 */
#ifdef MAC_AUT_TEST 
STATIC  MacRetType validateServiceType(UInt8 ServiceType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* - coverity 52749 */
#endif
STATIC  MacRetType validatePrecodingIndex(UInt8 precodingIndex,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType validateRlcMode(UInt8 rlcMode
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateLchId(UInt8 lchId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateLchPriority(UInt8 lchPriority
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* + coverity 52750 */
#ifdef MAC_AUT_TEST 
STATIC  MacRetType validateTransportChType(UInt8 transportChType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ); 

UInt8  msgBufferForOAMAndRRCMsgs[MAX_OAM_RESP_SIZE];
#endif
/* - coverity 52750 */
STATIC  MacRetType validateCqiPMIConfigIndex(UInt32 cqiPMIConfigIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateCqiPucchResourceIndex(UInt32 cqiPucchResourceIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateRiConfigIndex(UInt32 riConfigIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType validateTransmissionModeAndLayer(UInt8 transmissionMode, UInt8 numOfLayer,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType validateCqiformatIndicatorPeriodicSubbandK (UInt8 cqiPeriodicSubbandK);
STATIC  MacRetType validateCqiformatIndicatorPeriodic (UInt8 cqiformatIndicatorPeriodic);
/* + CL-MIMO LJA*/
STATIC  MacRetType validateCBSR( codebookSubsetRestrictionInfo *cbsrInfo, UInt8 transmissionMode,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex);
/* - CL-MIMO LJA*/
/* FREQ_SELECTIVE CHG */
STATIC  MacRetType validateFreqSelectiveEnable(UInt8 freqSelective);
/* FREQ_SELECTIVE CHG */
/* ULA_CHG */
/* SRS_CHG */
STATIC MacRetType  parseSRSCommonConfigInfo(UInt8 *message_p,
        UInt16 tagLength, ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );

STATIC MacRetType  parseSRSDedicatedConfigInfo(UInt8 **message_pp,
        UInt16 tagLength, UeContextForUplink *ulUEInfo_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
/* SRS_CHG */

STATIC MacRetType macChangeCrntiReq(ChangeCrntiInfo changeCrntiInfo
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
extern MacRetType configPhyCell(void *zeroBuffer_p, UInt8 *msg_p, UInt16 totalMsgLen );
/* CA Changes start */
extern MacRetType reConfigPhyCell(UInt8 *msg_p, UInt16 totalMsgLen, 
        InternalCellIndex internalCellIndex);
/* +- SPR 17777 */
extern MacRetType ueConfigHandler (UInt16 transId,UInt8 *msg_p,InternalCellIndex internalCellIndex);
/* +- SPR 17777 */
/* CA Changes end */
/* Cell Start Stop */
extern MacRetType reConfigPhyCellAfterCellStop(UInt8 *msg_p, UInt16 totalMsgLen );
/* Cell Start Stop */
extern SInt32 sendPhyCellRespToRRC(UInt16 msgId, SInt32 transId, 
        MacRetType retVal, RrcCellIndex cellIndex);
extern SInt32 handleUeReconfigReq (UInt8 *msg_p,UInt16 transactionId,
        InternalCellIndex internalCellIndex);
extern SInt32 handleUeDeleteReq (UInt8 *msg_p,UInt16 transactionId,
        InternalCellIndex internalCellIndex);

/*QOS_RB_RESTICTION_CHANGE*/
/* CA Changes start */
extern void initDlQosRbRestriction(InternalCellIndex internalCellIndex);
extern void initUlQosRbRestriction(InternalCellIndex internalCellIndex);
/* CA Changes end */
/*QOS_RB_RESTICTION_CHANGE*/
extern SInt32 handlePhyChangeCrntiReq (UInt8 *msg_p,UInt16 transactionId,
        InternalCellIndex internalCellIndex);
/* CELL DELETE CHG */
/* + SPR 17439 */
extern MacRetType stopPhy(void);
extern MacRetType startPhy(void);
/* - SPR 17439 */
/* CELL DELETE CHG */

/* CLPC_CHG */
/* CA Changes start */
extern void initTpcRntiContextForPusch(InternalCellIndex internalCellIndex);
extern void initTpcRntiContextForPucch(InternalCellIndex internalCellIndex);
/* CA Changes end */
/* CLPC_CHG_END */

/*HD FDD Changes Start*/
#ifdef HD_FDD_CONFIG
extern void updateHDFddSemiStaticMap(UInt16 ueIndex, UInt8 reportType);
#endif
/*HD FDD Changes End*/

/* + DRX_CHG */
STATIC  MacRetType parseDRXConfigInfo( UInt8 **message_pp ,
        UInt16 tagLength,
        UeContextForDownlink *dlCreateReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* - DRX_CHG */

/* + MEAS_GAP_CHG */
STATIC  MacRetType parseMeasGapConfigInfo( UInt8 **message_pp,
        UInt16 tagLength,
        UeContextForDownlink *dlCreateReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* - MEAS_GAP_CHG*/
/* +- SPR 19066 */
STATIC  MacRetType parseQosInfo ( UInt8 **msg_p,
        UInt16 origTagLen,
        LogicalChannelConfigInfo* dlLcInfo_p,
        ulLogicalChannelInfo* ulLcInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

/* SPR  3444 changes start */
static  void parseGBRInfo ( UInt8 **msg_p,
        /* SPR  3444 changes end */
        LogicalChannelConfigInfo* dlLcInfo_p,
        ulLogicalChannelInfo* ulLcInfo_p);


/*Functions for Power Control*/
STATIC MacRetType parseTpcRntiRange(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

STATIC MacRetType parsePdschConfigCommonInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

STATIC MacRetType parseCommonDLPowerControlInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

STATIC MacRetType parseCommonULPowerControlInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

STATIC MacRetType parseDedicatedULPowerControlInfo(UInt8 *message_p,
        DedicatedULPowerControlInfo* ulPowCtrlInfo
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );


STATIC MacRetType parseTpcPdcchConfig(UInt8 *message_p,
        UInt16 paramLength,
        TpcPdcchConfig* tpcPdcchConf,
        UInt8 isTpcForPusch /*0-Pucch 1-Pusch*/
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

STATIC MacRetType parsePowerControlEnablelInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

STATIC MacRetType validateTpcRntiRange(UInt16 startTpcRnti,
        UInt16 endTpcRnti,
        /* +- SPR 17777 */
        /* CA changes Start */
        InternalCellIndex internalCellIndex);
/* CA changes end */
/* SPS_CHG */
STATIC MacRetType parseSpsRntiRange(UInt8 *message_p, 
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* Moved to RRM Interface */
/* 
   STATIC MacRetType parseDlSpsSchInfoPerTti(UInt8 *message_p, 
   ConfigCellReq *configCellReq_p, UInt16 tagLength);
   STATIC MacRetType parseUlSpsSchInfoPerTti(UInt8 *message_p, 
   ConfigCellReq *configCellReq_p, UInt16 tagLength);
   */
/* CA changes Start */
STATIC MacRetType validateSpsRntiRange(UInt16 startSpsRnti,
        UInt16 endSpsRnti,
        ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex);
/* CA changes end */

STATIC  MacRetType parseSpsConfigInfo(
        UInt8 *message_p,
        UInt16 tagLength,       
        UeContextForDownlink *dlCreateRequest_p,
        UeContextForUplink *ulCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseSPSDLSetupInfo( UInt16 tagLen, UInt8 **msgBuf, 
        UInt16 *count_p, UeContextForDownlink *dlCreateRequest_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseSPSULSetupInfo( UInt16 tagLen, UInt8 **msgBuf, 
        UInt16 *count_p, UeContextForUplink *ulCreateRequest_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseSPSPZeroPersistentInfo( UInt16 ueIndex, 
        UInt16 tagLen, UInt8 **msgBuf, UInt16 *count_p, 
        UeContextForUplink *ulCreateRequest_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC MacRetType parseRohcProfile(
        UInt8 *message_p,
        UInt16 tagLength,
        LogicalChannelConfigInfo* dlLcInfo_p,
        ulLogicalChannelInfo* ulLcInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC MacRetType parseUEReconfigCompInd(
        UInt8 *message_p,
        UInt16 msgLength,
        UEReconfigCompInd *ueReconfigCompInd_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* SPS_CHG */
/* + CQI_5.0 */
MacRetType validateAperiodicModeForTXMode(UInt8 aperiodicCQIMode,
        UInt8 transmissionMode);
/* - CQI_5.0 */
/* SPR 5084 changes start */
STATIC  MacRetType validateUeCategory(UInt8 ueCategory
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* SPR 5084 changes end */
/* +DYNAMIC_ICIC */
STATIC  MacRetType parsePHRTimerConfig(
        UInt8 **msg_p,
        /* +- SPR 17777 */
        UeContextForUplink *ulCreateReq_p);
/* +DYNAMIC_ICIC */

/* +- SPR 17777 */
UInt16 deleteSplitOnUeEntity( UInt16 ueIndex ,
        UInt16 transactionId, InternalCellIndex internalCellIndex );
/* +- SPR 17777 */
UInt16 resetSplitUeEntity( UInt16 ueIndex , UInt16 msgId,
        UInt16 transactionId, 
        UInt8 scellRelFlag,
        InternalCellIndex internalCellIndex );

void ElprocessOAMAndRRCMsg(UInt8 numOfMsg, UInt32 delayToPhy);
/* CA Changes start */
void sendStopPhyCellDeleteRes(UInt16 transactionId, UInt32 response,
        RrcCellIndex cellIndex);
void sendStopPhyCellStopRes(UInt16 transactionId, UInt32 response,
        RrcCellIndex cellIndex);
void sendConfigPhyCellRes(UInt16 transactionId, UInt32 response,
        InternalCellIndex internalCellIndex);

void sendMacInitLayerRes(UInt16 transactionId, UInt32 response,
        InternalCellIndex internalCellIndex);
#ifndef FLEXRAN
SInt32 receiveStartPhyRes(UInt8 *msgBuf,InternalCellIndex internalCellIndex);
#endif
void sendReConfigPhyCellAfterCellStopRes(UInt16 transactionId, UInt32 response,
        InternalCellIndex internalCellIndex);
void sendStartPhyResDuringMacCellConfig(UInt16 transactionId, UInt32 response, 
        InternalCellIndex internalCellIndex);
/* CA Changes end */
#ifdef UTFWK_SIMULATION

SInt32 receiveForPhyResMsgs(UInt8 * msgBuf);
#endif
STATIC  MacRetType parseCellRachPreambleConfig( UInt16 tagLen,
        UInt32 numContnBasedPreambles, UInt8 **msgBuf, UInt16 *remLen_p,
        UInt32 *numOfPreamblesInGroupA_p, UInt32 *messageSizeGroupA_p,
        UInt32 *preambleGroupAConfigFlag_p
        , InternalCellIndex internalCellIndex 
        );
STATIC  MacRetType validatePhichAndPucchConfigCellInfo( UInt8 **msgBuf,
        UInt16 *remLen_p, UInt16 *n1PUCCH_AN_p, UInt8 *deltaPUCCH_Shift_p,
        UInt8 *nRB_CQI_p, UInt8 *nCS_AN_p, ConfigCellReq *configCellReq_p 
        , InternalCellIndex internalCellIndex 
        );
STATIC  MacRetType validateSrsAndPdschConfigCellParams( UInt8 **msgBuf,
        UInt16 *remLen_p, ConfigCellReq *configCellReq_p 
        , InternalCellIndex internalCellIndex 
        );


STATIC  MacRetType parseOptionalCellConfigParams( UInt8 *msg_p,
        UInt16 remLen, ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex );
STATIC  MacRetType parseExplicitCellStartReqdInfo( UInt16 *remLen_p,
        UInt8  **msgBuf, ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex);
/* SPR 12813 Changes Start */
STATIC  MacRetType parseCellNGapValueInfo( UInt16 tagLen,
        UInt16 *remLen_p, UInt8 **msgBuf,CellConfigParams *cellParams_p 
        ,ConfigCellReq *configCellReq_p, InternalCellIndex internalCellIndex);
/* SPR 12813 Changes End */
/* CA Changes end */
STATIC  MacRetType parseCellULSyncLossTimerInfo( UInt16 tag,
        UInt16 tagLen, UInt16 *remLen_p, UInt8 **msgBuf, 
        ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
STATIC  MacRetType parseCellContentionFreeRachTimerInfo( UInt16 tag,
        UInt16 tagLen, UInt16 *remLen_p, UInt8 **msgBuf,
        ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
/* +- SPR 17777 */
STATIC  MacRetType parseCellFreqSelectiveEnableInfo(
        UInt16 *remLen_p, UInt8 **msgBuf, ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
STATIC  MacRetType parseCellPucchCqiSinrInfo( UInt16 tag, UInt16 tagLen,
        UInt16 *remLen_p, UInt8 **msgBuf, ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
STATIC  MacRetType validatePowerCtrlAndPuschConfigCellParams(
        UInt8 **msgBuf, UInt16 *remLen_p, ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
STATIC  void processRRCPhyConfigCellReq( UInt16 msgId, 
        UInt16 msgLen, UInt8 *msgBuf, UInt16 transactionId,
        /* CA Changes start */
        InternalCellIndex internalCellIndex);
/* CA Changes end */
STATIC  void processRRCPhyReconfigCellReq( UInt16 msgId, 
        UInt16 msgLen, UInt8 *msgBuf, UInt16 transactionId,
        /* CA Changes start */
        InternalCellIndex internalCellIndex);
/* CA Changes end */
STATIC  void processRRCPhyDeleteCellReq( UInt16 msgId, 
        /* +- SPR 17777 */
        UInt8 *msgBuf, UInt16 transactionId,
        /* CA Changes start */
        InternalCellIndex internalCellIndex);
/* CA Changes end */
STATIC  void processRRCPhyCellStopReq (UInt16 msgId, 
        /* +- SPR 17777 */
        UInt8 *msgBuf, UInt16 transactionId
        /* CA Changes start */
        ,InternalCellIndex internalCellIndex
        /* CA changes end */
        );
STATIC  void processRRCPhyCellStartReq( UInt16 msgId, 
        /* +- SPR 17777 */
        UInt8 *msgBuf, UInt16 transactionId
        /* CA Changes start */
        ,InternalCellIndex internalCellIndex
        /* CA changes end */
        );
STATIC  void parseRRCCellConfigMsg( UInt16 msgId, 
        UInt16 msgLen, UInt8 *msgBuf, UInt16 destModuleId, UInt16 transactionId,
        InternalCellIndex internalCellIndex);
/* CA Changes start */
STATIC  void parseMacSfnReq( UInt8 *msg_p,
        UInt16  msgId, UInt16  msgLen, UInt16  transactionId,
        InternalCellIndex internalCellIndex );
STATIC  void parseMacReconfigCellReq( UInt8 *msg_p,
        /* +- SPR 17777 */
        UInt16  msgLen, UInt16  transactionId,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex);
/* +- SPR 17777 */
STATIC  void parseMacDeleteCellReq(
        UInt16  transactionId, InternalCellIndex internalCellIndex );
STATIC  void parseMacCellStopReq( UInt16  msgId,
        UInt16  transactionId, InternalCellIndex internalCellIndex );
STATIC  void parseMacCellStartReq(
        UInt16  transactionId,InternalCellIndex internalCellIndex );
/* +- SPR 17777 */
/*CID 83627 Fix start*/ 
STATIC  MacRetType   sendMacCellStartReq(UInt16  transactionId,
        InternalCellIndex internalCellIndex);
/*CID 83627 Fix end*/ 
/* CA Changes end */
STATIC  void parseMacCreateUEEntityReq( UInt8 *msg_p, UInt16  msgId,
        UInt16  msgLen, UInt16  transactionId,
        InternalCellIndex internalCellIndex
        );
STATIC  void parseMacDeleteUEEntityReq( UInt8 *msg_p, UInt16  msgId,
        UInt16  msgLen, UInt16  transactionId, InternalCellIndex internalCellIndex );
STATIC  void parseMacReconfigureUEEntityReq( UInt8 *msg_p, 
        UInt16  msgId, UInt16  msgLen, UInt16  transactionId, InternalCellIndex internalCellIndex );
STATIC  void parseMacChangeCrntiReq( UInt8 *msg_p, UInt16  msgId,
        UInt16  msgLen, UInt16  transactionId,
        InternalCellIndex internalCellIndex);
STATIC  void parseMacResetUEEntityReq ( UInt8 *msg_p, UInt16 msgId, 
        UInt16 msgLen, UInt16 transactionId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        );
STATIC  void parseMacHORachResourceReq( UInt8 *msg_p, UInt16 msgId,
        UInt16 msgLen, UInt16 transactionId,
        InternalCellIndex internalCellIndex);
/* +- SPR 19066 */
STATIC  void parseMacHORelRachResourceInd( UInt8 *msg_p, UInt16 msgId,
        /*CA Changes start  */
        /* +- SPR 17777 */
        UInt16 msgLen,InternalCellIndex internalCellIndex);
/* +- SPR 17777 */
/*CA Changes end  */
/* CA Changes start */
/* Cyclomatic_complexity_changes_start */
/* +- SPR 19066 */
STATIC  MacRetType parseCellReconfigDciInfo(
        UInt16 tag, UInt16 tagLen, UInt16 *remLen_p, UInt8 **message_p,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType parseCellReconfigOptionalParams( UInt16 tag,
        UInt16 tagLen, UInt16 sfn, UInt8 sf, UInt16 *remLen_p, UInt8 **message_p,
/*Coverity Id 116262 Fix Start*/
/*Coverity Id 116262 Fix Stop*/
        InternalCellIndex internalCellIndex);
STATIC  MacRetType parseContentionFreeRachTimerInfo (
        UInt16 tagLen, UInt16 sfn, UInt8 sf, UInt16 *remLen_p, UInt8 **msg_p,
        InternalCellIndex internalCellIndex, CellState cellState);
/* CA Changes end */
STATIC  MacRetType parsePucchCqiSinrThresholdInfo (
        UInt16 tagLen, UInt16 *remLen, UInt8  **msg_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
STATIC  MacRetType parseULSyncLossTimerInfo( UInt16 tagLen, 
        UInt16 *remLen, UInt8  **msgBuf
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );
/* CA Changes start */
STATIC  MacRetType checkAndparsePdschConfigCommonInfo(
        UInt16 tagLen, UInt16 sfn, UInt8  sf, UInt16 *remLen, UInt8 **msg_p,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType checkAndparseDLPowerCtrlCommonInfo( UInt16 tagLen, 
        UInt16 sfn, UInt8  sf, UInt16 *remLen, UInt8  **msg_p,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType checkAndparseULPowerCtrlCommonInfo( UInt16 tagLen, 
        UInt16 sfn, UInt8  sf, UInt16 *remLen, UInt8  **msg_p,
        InternalCellIndex internalCellIndex);
STATIC  MacRetType parseNGapValue( UInt16 tagLen, UInt16 *remLen, 
        UInt8  **msg_p,InternalCellIndex internalCellIndex);
STATIC  MacRetType validateConfigCellParams( UInt8 **msgBuf,
        ConfigCellReq *configCellReq_p,
        CellConfigParams *cellParams_p,
        InitParams *initParams_p
        ,InternalCellIndex internalCellIndex 
        );
/* CA Changes end */


MacRetType parseSfnGapInfo(CellState cellState,
        CellConfigParams *cellParams_p,
        UInt16 *remLen,
        UInt8  **msgBuf,
        InternalCellIndex internalCellIndex);

MacRetType parsePuschConfigCommonInfo(UInt16 tagLen,
        UInt16 sfn,
        UInt8 sf,
        UInt16 *remLen,
        UInt8  **msgBuf,
        InternalCellIndex internalCellIndex);

void resetSecondCellInResetUeReq(DLUEContext *ueDLContext_p,
        ULUEContext *ueULContext_p,
        LP_RrcOamPendingReq rrcOamPendReq_p,
        UInt16 ueIndex,
        UeCellInfo  *ueCellInfo_p,
        InternalCellIndex internalCellIndex);

void processRRCMsgForPhy(UInt16 msgId,
        UInt16 destModuleId,
        UInt16 msgLen,
        UInt8 *msgBuf_p,
        UInt16 transactionId,
        InternalCellIndex internalCellIndex);

MacRetType getPRSBandwidth(PRSParseConfigInfo *prsParseConfigInfo_p,
        UInt8 prsBandwidth,
        InternalCellIndex internalCellIndex);
/* Cyclomatic_complexity_changes_end */
#ifdef TDD_CONFIG
STATIC  MacRetType validateTddConfigCellParams( UInt8 **msgBuf,
        UInt16 *remLen_p, ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex);
#endif
/* CA Changes start */
/* +- SPR 17777 */
STATIC  void getDlBandwidthCellConfigReq( 
        ConfigCellReq *configCellReq_p);
/* +- SPR 17777 */
STATIC  MacRetType parseRBSelectionAndBroadcastMsgParams(
        /* +- SPR 17777 */
        UInt8 **msgBuf, UInt16 *remLen_p,
        /* +- SPR 17777 */
        CellConfigParams *cellParams_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        );

STATIC  void prepareMacDeleteUEEntityCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacConfigCellCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p,
        UInt8  **msg_pp
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacSfnErrInd ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacReconfigCellCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacCellStartCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* +- SPR 17777 */
STATIC  void prepareMacSfnCnf (
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacChangeCrntiCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  void prepareMacHORachResourceResp ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* +- SPR 19066 */
STATIC  void prepareMacRlfInd ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p,
        /* + Coverity_31952 */
        UInt16 transactionId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        /* - Coverity_31952 */
        );
STATIC  void prepareMacResetUEEntityCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* +- SPR 17777 */
STATIC  void prepareMacUESyncStatusInd (
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p,
        /* + Coverity_31954 */
        UInt16 transactionId
        /* - Coverity_31954 */
        );
STATIC  MacRetType parseReconfigCqiInfo (UInt8 **msgBuf, 
        UInt16               len,
        UInt16               tagLen, 
        UeContextForDownlink *dlUEInfo_p, 
        UeContextForUplink   *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        );
STATIC  MacRetType parsePeriodicReconfigCqiInfo (UInt8 *periodicCQIEnabled,
        UInt8 **msg_p, 
        UeContextForUplink   *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p, 
        /* CA changes Start */
        InternalCellIndex internalCellIndex,
        /* CA Changes end */
        UInt16               len,
        UInt16               tagLen
        /* +- SPR 17777 */
        ,ULCQIReqInfo        *ulCqiReqInfo_p 
        );
/*Complexity Start*/
MacRetType eicicParsePeriodicReconfigCqiInfo(
        UInt8 **msg_p,
        UeContextForUplink *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p,
        UInt16 tagLen,
        CellConfigParams *cellParams_p);
/*Complexity End*/
STATIC  MacRetType parseReconfigUECqiV920Info (  
        /* +- SPR 17777 */
        UInt8                **msgBuf,
        UeContextForUplink   *ulUEInfo_p,
        UeContextForDownlink  *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseReconfigDLMaxRBInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigTXModeInfo (UInt8 **msgBuf, 
        UInt8                len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseRecfgCodebookSubRestriction (UInt8 **msgBuf, 
        UInt8                len,
        UeContextForDownlink *dlUEInfo_p,
        UInt8                currentTransmissionMode
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
/* SPR 12240 Changes Start */
STATIC  MacRetType parseRecfgCodebookSubRestrictionV1020 (UInt8 **msgBuf, 
        UInt8                tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UInt8                currentTransmissionMode
        ,InternalCellIndex internalCellIndex
        );
STATIC  MacRetType parseRecfgCodebookSubRestrictionV920 (UInt8 **msgBuf, 
        UInt8                tagLen,
        UeContextForDownlink *dlUEInfo_p, 
        UInt8                currentTransmissionMode,
        InternalCellIndex internalCellIndex
        );
/* SPR 12240 Changes End */
STATIC  MacRetType parseReconfigNumOfLayerInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigCodebookIndexInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigSRConfigInfo (UInt8 **msgBuf, 
        UInt16             *len_p,
        UeContextForUplink *ulUEInfo_p,
        UInt8              *isContinueFlag_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigSRProhibitTimerV920Info (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseReconfigUECategoryInfo (UInt8 **msgBuf, 
        UInt16               len,
        UInt16               tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigDrxConfigInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigMeasGapConfigInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigTimerAlignTimerInfo (UInt8 **msgBuf, 
        UInt16               len,
        UInt16               tag,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigPdcshConfigInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigP0UEPusch (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForUplink   *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigTPCPdcchConfigPucch (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        /* +- SPR 17777 */
        );
STATIC  MacRetType parseReconfigTPCPdcchConfigPusch (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        /* +- SPR 17777 */
        );
STATIC  MacRetType parseUECapAdditionalParams (UInt8 **msgBuf, 
        UInt16                len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseReconfigRFParams (UInt8 **msgBuf, 
        UInt16                len,
        UeContextForDownlink  *dlUEInfo_p,
        /* +- SPR 17777 */
        /* CA changes Start */
        InternalCellIndex internalCellIndex
        /* CA Changes end */
#ifdef HD_FDD_CONFIG
        ,UeContextForUplink    *ulUEInfo_p
        ,DLReconfigUeReq   *dlReconfigUeReq_p
        ,ULReconfigUeReq   *ulReconfigUeReq_p
#endif
        /* +- SPR 17777 */
        );
STATIC  MacRetType parseReconfigPHRTimerConfig (UInt8 **msgBuf, 
        /* +- SPR 17777 */
        UeContextForUplink *ulUEInfo_p
        );
STATIC  MacRetType parseReconfigUEComplianceRel (UInt8 **msgBuf, 
        UInt16             len,
        UInt16             tagLen,
        UeContextForUplink *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseReconfigTTIBundlingInfo (UInt8 **msgBuf,
        /* +- SPR 17777 */
        UInt16             len
        /*SPR21501 fix start*/
        ,UeContextForUplink *ulUEInfo_p
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        /*SPR21501 fix end*/
        ,InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        );
STATIC  MacRetType parseReconfigPdschEpreToUeRsRatio (UInt8 **msgBuf,
        UInt16             len,
        UeContextForDownlink  *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );
STATIC  MacRetType parseReconfigMaxUlHarqTxInfo (UInt8 **msgBuf,
        UInt16             len,
        UeContextForUplink * ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigPcMaxInfo (UInt8 **msgBuf,
        UInt16             len,
        UeContextForUplink * ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        );
STATIC  MacRetType parseReconfigPuschConfigInfo (UInt8 **msgBuf,
        UInt16             len,
        UeContextForUplink * ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        );
/* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
STATIC  MacRetType parseUEUplinkRAT1Info (UInt8 **msgBuf, 
        UInt16                len,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        );
#endif
/* SPR 21958 PUSCH RAT1 Support End */
/* SPR 19679: TDD HARQ Multiplexing Changes Start */
#ifdef TDD_CONFIG
STATIC  MacRetType validateTddAckNackFeedbackMode(UInt8 **msgBuf, 
        UInt16 tagLen,
        UeContextForUplink *ulCreateReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        );

#endif


/* SPR 19679: TDD HARQ Multiplexing Changes End */
/*CA changes start*/

/* Time after which secondary cell for the UE will be deactivated
 * Possible values are 
 * rf2 = 20ms, rf4=40ms, rf8=80ms, 
 * rf16=160ms, rf32=320ms, rf64=640ms, 
 * rf128=1280ms
 */
UInt8 validScellDeactivationTimerValues_g[SCELL_DEACTIVATION_TIMER_VALUE_COUNT]=
{
    /* + SPR 11784 changes */
    0,
    /* - SPR 11784 changes */
    2,
    4,
    8,
    16,
    32,
    64,
    128
};
UInt8 validnumOfLayerValues_g[NUM_OF_LAYERS_COUNT]=
{
    1,
    2,
    4
};

STATIC void macInitCAParams (UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p );
STATIC MacRetType macParseCreateUECategoryV1020Info( UInt8 **msgBuf_pp, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex);
STATIC MacRetType macParseCreatePUCCHFormatV1020( UInt8 **msgBuf_pp, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p, 
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCreateCAConfig( UInt8 **msgBuf_pp, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p 
        ,InternalCellIndex internalCellIndex
        );
STATIC MacRetType macValidateN1Pucch(UInt16 n1Pucch
        ,InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParsePucchAnCsV1020 ( UInt8 **msgBuf_pp,
        UInt16 remainingTagLen,
        UInt8 pucchAnCsListElement,
        UeContextForDownlink *dlCreateReq_p,
        UeContextForUplink   *ulCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseScellDeactivationTimer(UInt16 tagLen,
        UInt8 **msgBuf_pp,
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        /* + SPR 11631 Changes */
        ,DLReconfigUeReq *dlReconfigUeReq_p
        /* - SPR 11631 Changes */
        );
STATIC MacRetType macValidateScellDeactivationTimer(
        UInt8 scellDeactivationTimer
        ,InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseAndValidateScellInfo(UInt16 tagLen,
        UInt8 **msgBuf_pp,
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCALCBandwidthDistributionInfo(UInt16 tagLen,
        UInt8 **msgBuf_pp,
        UeContextForDownlink *dlCreateReq_p
        ,InternalCellIndex internalCellIndex
        /* + SPR 11631 Changes */
        ,DLReconfigUeReq *dlReconfigUeReq_p
        /* - SPR 11631 Changes */
        );
STATIC MacRetType macParseScellMimoCapabilityV1020(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        InternalCellIndex internalCellIndex
        ) ;
STATIC MacRetType macParseScellTxModeInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseScellReconfigTXModeInfo (UInt8 **msgBuf_pp, 
        UInt8                len,
        ScellInfo *dlUEInfo_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseScellCodeBookSubsetRestV1020(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseScellPDSCHConfigInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseScellDLHarqProc(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p
        );
STATIC MacRetType macParseScellDLInitMCS(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p
        ); 
STATIC MacRetType macParseScellNumOfLayerInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p
        /* +- SPR 17777 */
        );
STATIC MacRetType macParseScellCodebookIndexInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p
        /* +- SPR 17777 */
        );
STATIC MacRetType macParseScellUserLocationType(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p
        );
STATIC MacRetType macParseScellRFParams(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        /* +- SPR 17777 */
#ifdef HD_FDD_CONFIG
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
#endif
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex,
        UInt16 ueIndex
        );
STATIC MacRetType macParseScellActivationStatus(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex
        );

STATIC  MacRetType validateCqiPucchResourceIndexR10(UInt32 cqiPucchResourceIndex
        ,InternalCellIndex internalCellIndex);
STATIC MacRetType macValidateCALCBandwidthDistribution(
        UInt8 bandWidthDistribution);
STATIC MacRetType macParseScellInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        ) ;
STATIC MacRetType macParseScellInfoTag(UInt16 remainingTagLen,
        UInt8 **msgBuf_pp,
        InternalCellIndex internalCellIndex,
        UeContextForDownlink *dlCreateReq_p,
        UeContextForUplink   *ulCreateReq_p
        ) ;
STATIC MacRetType macParseCACreateUECqiInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UInt8  scellCount,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType macValidateCsiTriggerR10 ( UInt8 trigger1r10, UInt8 trigger2r10);
STATIC  MacRetType macValidateScellRel(UInt8 scellRelFlag);
STATIC MacRetType macParseReconfigUECategoryV1020Info( UInt8 **msgBuf, 
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        );
STATIC MacRetType macParseReconfigPUCCHFormatV1020Info( UInt8 **msgBuf, 
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        );
STATIC MacRetType macParseReconfigCAConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        );
STATIC MacRetType macParseScellReconfigInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        );
STATIC  MacRetType macParseScellReconfigInfoTag(UInt16 remainingTagLen,
        UInt8 **msgBuf_pp,
        InternalCellIndex internalCellIndex,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        ); 
STATIC  MacRetType macParseCAUECqiAperiodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCAUECqiPeriodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        );
STATIC  MacRetType macParseCACreateUECqiPMIConfigIndex(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCAUECqiPMIConfigIndexV1020(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        );

STATIC MacRetType macParseCAReconfigUECqiInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        ); 
STATIC MacRetType macParseCAReconfigUECqiAperiodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p, 
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        ,ULCQIReqInfo *ulCqiReqInfo_p
        );
STATIC MacRetType macParseCAReconfigUECqiPeriodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        ,ULCQIReqInfo *ulCqiReqInfo_p
        );
STATIC MacRetType macParseCAReconfigUECqiPMIConfigIndex(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p
        );
STATIC MacRetType macParseCAUECqiRIConfigIndex(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCAUECqiFormatPeriodicSubbandK(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        CellConfigParams *cellParams_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCAUECqiFormatPeriodicSubbandKV1020(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        CellConfigParams *cellParams_p,
        InternalCellIndex internalCellIndex
        );
STATIC MacRetType macParseCAReconfigUECqiPMIIndexV1020(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p
        );
STATIC MacRetType macParseCAUECqiRIConfigIndexV1020(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        );
STATIC void macProcessAndUpdateULReconfigPucchInfoV1020( 
        ULUEContext *ulUEContext_p, ULReconfigUeReq *ulReconfigUeReq_p);

STATIC void macProcessAndUpdateDLReconfigPucchInfoV1020( 
        DLUEContext *dlUEContext_p, DLReconfigUeReq *dlReconfigUeReq_p);

STATIC MacRetType  macProcessAndUpdateDLReconfigCAConfig(
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        InternalCellIndex internalCellIndex
        );

STATIC void macProcessAndUpdateDLReconfigDeactivationTimer( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p);

STATIC void macProcessAndUpdateDLReconfigCALCBandwidthDistributionInfo( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p);

STATIC MacRetType macCheckOperationTypeForUeCategory(
        DLSCELLReconfigInfo *dlReconfigScellInfo_p,
        DLUEContext *dlUEContext_p,UInt8 scellIndex,
        InternalCellIndex internalCellIndex);

STATIC MacRetType macProcessAndUpdateDLReconfigScellInfo( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p, 
        UInt8 cellCount ,InternalCellIndex internalCellIndex
        );

/* +- SPR 17777 */
STATIC MacRetType  macProcessAndUpdateULReconfigCAConfig(
#ifdef HD_FDD_CONFIG
        UInt16 ueIndex,
#endif
        /* +- SPR 17777 */
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p, 
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex
        );

STATIC void macProcessAndUpdateULReconfigDeactivationTimer( 
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p);

/* +- SPR 17777 */
STATIC MacRetType macProcessAndUpdateULReconfigScellInfo(
#ifdef HD_FDD_CONFIG
        UInt16 ueIndex,
#endif
        /* +- SPR 17777 */
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p, 
        UInt8 cellCount,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex
        );
/* +- SPR 17777 */
STATIC void macProcessAndUpdateULReconfigPUCCHScellInfo(
#ifdef HD_FDD_CONFIG
        UInt16 ueIndex,
#endif
        /* +- SPR 17777 */
        ULSCELLReconfigInfo *ulReconfigScellInfo_p, 
        ULUESCellContext *ulUeScellContext_p,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex);

STATIC void macProcessAndUpdateDLReconfigMimoCapabilityV1020( 
        DLSCELLReconfigInfo *dlReconfigScellInfo_p, 
        DLUESCellContext *dlUeScellContext_p);

STATIC void macProcessAndUpdateDLReconfigCodeBookV1020Info( 
        DLSCELLReconfigInfo *dlReconfigScellInfo_p, 
        DLUESCellContext *dlUeScellContext_p);

STATIC MacRetType macProcessAndUpdateDLReconfigScellCQIInfo( UInt16 ueIndex,
        SCELLDLCQIInfo *dlCQIInfo_p, DLSCELLReconfigInfo *dlReconfigScellInfo_p, 
        DLUESCellContext *dlUeScellContext_p,InternalCellIndex internalCellIndex
        );

#ifdef HD_FDD_CONFIG
STATIC void macprocessAndUpdateDLReconfigScellRFParams( 
        DLSCELLReconfigInfo *dlReconfigInfo_p, DLUEContext *dlUEContext_p,
        UInt8 scellIndex ,InternalCellIndex internalCellIndex
        );
#endif

STATIC void macPopulateScellCQIInfo( PucchConfig *pucchConfig_p,ULCQIReqInfo *ulCqiReqInfo_p
        , InternalCellIndex internalCellIndex
        );

STATIC void macPopulateScellCqiAperiodicInfo( PucchConfig *pucchConfig_p,
        ULCQIAperiodicInfo *cqiAperiodicInfo_p);

STATIC void macPopulateScellCqiPeriodicInfo( PucchConfig *pucchConfig_p,ULCQIPeriodicReqInfo *cqiPeriodicReqInfo_p
        , InternalCellIndex internalCellIndex);

UInt32 populateCQIInfo( PucchConfig *pucchConfig_p,ULCQIReqInfo *ulCqiReqInfo_p
        , InternalCellIndex internalCellIndex
        );

UInt32 populateShortSRInfo( PucchConfig *pucchConfig_p,SRConfigInfo *srConfigInfo_p
        , InternalCellIndex internalCellIndex
        );
UInt32 populateShortSRInfo( PucchConfig *pucchConfig_p,SRConfigInfo *srConfigInfo_p
        , InternalCellIndex internalCellIndex
        );

/* CA changes end */
STATIC  MacRetType macParseCAUECqiConfigIndexV10Info(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        InternalCellIndex internalCellIndex
        );


/* Cyclomatic Complexity changes - ends here */
/******************************************************************************
 * Private Constants
 *****************************************************************************/
/******************************************************************************
 * Exported Variables
 *****************************************************************************/
#ifdef LTE_EMBMS_SUPPORTED
extern EmbmsConfigParams embmsConfigParams_g[MAX_NUM_CELL];
#endif

#ifndef FLEXRAN
extern SInt32 phyControlSockFD_g[MAX_NUM_CELL];
#endif
#define STDIN 0
SInt32 txSockFD_g;
SInt32 txOAMSockFD_g;
SockAddr tx_addr_g;
/* SPR 19288 change start */
/* SPR 19288 change end */
SockAddr txOAM_addr_g;

/* ports for RRC,OAM and MAC */
UInt16 rxPortMAC_g;
UInt16 txPortMacOAM_g;
UInt16 txPortMacRRC_g;
/* CA Changes start */
Char8 phyIPAddress_g[MAX_NUM_CELL][HOSTNAME_MAX_LEN];
/* CA Changes end */
Char8 macIPAddress_g[HOSTNAME_MAX_LEN];
Char8 rrcIPAddress_g[HOSTNAME_MAX_LEN];
Char8 oamIPAddress_g[HOSTNAME_MAX_LEN];

#define INVALID_TRANS_ID 0x1FFFF
/* CA Changes start */
UInt32 transactionId_g[MAX_NUM_CELL] = {INVALID_TRANS_ID};
/* CA Changes end */
/* SPR 16091 fix start */
/*SPR 16417 Fix Start*/
UInt16 phyInitTransactionId_g = (UInt16)INVALID_TRANS_ID;
/*SPR 16417 Fix End*/
/* SPR 16091 fix end */

#ifdef LOG_PRINT_ENABLED

UInt32 cellConfigFailValues_g[MAX_NUM_CELL][MAX_RECONFIG_FAIL_VALUES]={{0,0,0,0,0,0,0}};
UInt32 reConfigFailValues_g[MAX_NUM_CELL][MAX_RECONFIG_FAIL_VALUES]={{0,0,0,0,0,0,0}};

#endif
/*Dynamic Pdcch Changes Start*/
UInt32 NumOfOverLappingRbsArrayInfo_g[MAX_DL_BW][RES_BIT_MAP_ARRAY_SIZE]=\
{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},/*For 1.4Mhz*/
    {0,4,8,12,24,28,60,32/*1Rb*/,16/*2Rb*/,20/*3Rb*/,\
        44/*4Rb*/,56/*5Rb*/,36/*2Rb*/,48/*3Rb*/,52/*4Rb*/ },/*For 3Mhz*/
    {0,40/*2Rb*/,32,192/*4Rb*/,96,128/*2Rb*/,224,160/*4Rb*/,0,0,0,0,0,0,0},/*For 5Mhz */
    {0,128,512,256,384,768,896,640,0,0,0,0,0,0,0},/* For 10Mhz*/
    {0,256,1280,1024/*1RB*/,512,768,1792,1536/*5Rb*/,0,0,0,0,0,0,0},/* For 15Mhz*/
    {0,2048,10240,8192/*1RB*/, 4096,6144,\
        14336,12288/*5RB*/,0,0,0,0,0,0,0}/*For 20Mhz*/
};
UInt8 centralSixRbsArrayInfo_g[MAX_DL_BW][MAX_NUM_OVERLAPPING_RB]=\
{{0,1,2,3,4,5},/*For 1.4Mhz*/
    {5,6,7,8,9,10},/*For 3Mhz*/
    {10,11,12,13,14,15},/*For 5Mhz*/
    {22,23,24,25,26,27},/* For 10Mhz*/
    {35,36,37,38,39,40},/* For 15Mhz*/
    {47,48,49,50,51,52}/*For 20Mhz*/};
/*Dynamic Pdcch Changes End*/
/* SPR 22745 Fix Start */
#define MIN_AMBR_VALUE 1000
/* Below validation has been added to handle the scenario if DL/UL Ambr is 
 * set as zero, as in this case the available tokens will be calculated as 0,
 * and no scheduling is possible. This will create problem in scheduling of
 * RLC status PDU in such a case where UL Ambr is set as 0, and DL data is running.
 * Similarly, for the case when DL AMBR is set as 0 and only UL data is running. 
 */
#define VALIDATE_RECEIVED_AMBR(recvAmbr) ((recvAmbr ==0)?MIN_AMBR_VALUE:recvAmbr) 
/* SPR 22745 Fix End */

/** SPR 14505 Changes **/
extern UInt8            *pTxReqMsgBuff_gp[MAX_NUM_CELL]    ;

#ifdef FLEXRAN
extern UInt32 g_flexran_channelId[MAX_NUM_CELL] ; 
#endif

/** SPR 14505 Changes **/
/*****************************************************************************
 * Private Variables (Must be declared static)
 *****************************************************************************/
/*SPR 16855 +-*/
/****************************************************************************
 * Function Name  : getInitializedRefPointer 
 * Inputs         : xi_hiPriorityThd - High priority Thread Type 
 * Outputs        : Initialize the Queue's & List
 * Returns        : None 
 * Description    : This function is used to initialize the reference 
 *                  pointer for DL and UL Node for HP Thread.
 ****************************************************************************/
void *getInitializedRefPointer(UInt32 xi_hiPriorityThd)
{
    LP_RrcOamHiPrioQNode dataNode_p = PNULL;
    RachInterfaceQueueNode *rachNode_p = PNULL;

    switch(xi_hiPriorityThd)
    {
        case DL_THD:
        {
            GET_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q(dataNode_p, RrcOamHiPrioQNode);
            if( dataNode_p == PNULL)
            {
                return PNULL;
            }
            memSet(dataNode_p, 0, sizeof(RrcOamHiPrioQNode));
            return (void *)dataNode_p;
        }
        case UL_THD:
        {
            GET_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q(dataNode_p, RrcOamHiPrioQNode);
            if(dataNode_p == PNULL)
            {
                return PNULL;
            }
            memSet(dataNode_p, 0, sizeof(RrcOamHiPrioQNode));
            return (void *)dataNode_p;
        }
        case RACH_MGRQ:
        {
            GET_MEM_NODE_PDCCH_RACH_INTERFACE_Q(rachNode_p, RachInterfaceQueueNode);
            if(rachNode_p == PNULL)
            {
                return PNULL;
            }
            memSet(rachNode_p, 0, sizeof(RachInterfaceQueueNode));
            return (void *)rachNode_p;
        }
        default:
        return PNULL;
    }
}

/* SPR 9427 changes start */
/****************************************************************************
 * Function Name  :  initNonSpatialRAT0RAT1Bitmaps 
 * Inputs         :  cqiValue - Current CQI
 *                   cqiInfoNonSpatialMul_p - Pointer to CQIInfoNonSpatialMul
 *                   internalCellIndex
 * Output         :  None
 * Returns        :  None
 * Description    :  This function init the Non Spatial bitmaps of RAT0 
 *                   and RAT1. 
 ******************************************************************************/
void initNonSpatialRAT0RAT1Bitmaps(UInt8 cqiValue,
        CQIInfoNonSpatialMul *cqiInfoNonSpatialMul_p,
        InternalCellIndex internalCellIndex)
{
    RAT0NonSpatialMulCQIInfo *rat0CQIInfo_p = PNULL;
    RAT1NonSpatialMulCQIInfo *rat1CQIInfo_p = PNULL;
    RAT0Info *rat0Info_p = PNULL;
    RAT1Info *rat1Info_p = PNULL;
    /* 533 COVERITY FIX 61225 START */
    rat0Info_p = 
        &(dlRAInfo_gp[internalCellIndex] + 
                dlRAInfoIndex_g[internalCellIndex])->raPolicyInfo.rat0Info;
    rat1Info_p = 
        &(dlRAInfo_gp[internalCellIndex] + 
                dlRAInfoIndex_g[internalCellIndex])->raPolicyInfo.rat1Info;
    /* 533 COVERITY FIX 61225 END */
    SubsetInfo *subSetInfo_p = PNULL;
    UInt8 subSetCount =  rat1Info_p->subsetCount;
    UInt8 subsetIndex = 0;
    UInt8 i = 0;
    UInt32 setBits = rat0Info_p->rat0BitMap[CC_USER];
    rat0CQIInfo_p = &cqiInfoNonSpatialMul_p->rat0NonSpatialMulCQIInfo; 
    rat1CQIInfo_p = &cqiInfoNonSpatialMul_p->rat1NonSpatialMulCQIInfo[0];
    subSetInfo_p = &rat1Info_p->subsetInfo[0];

    while(i++ < cqiValue)
    {    
        rat0CQIInfo_p->rat0CQIBitMap[i] =  setBits;
        subsetIndex = subSetCount;

        while (subsetIndex--)
        {
            rat1CQIInfo_p[subsetIndex].subsetCQIBitMapNonZeroSpan[i] =
                subSetInfo_p[subsetIndex].bitMapWithSpanNonZero;

            rat1CQIInfo_p[subsetIndex].subsetCQIBitMapZeroSpan[i] =
                subSetInfo_p[subsetIndex].bitMapWithSpanZero;

        }    
    }

    rat0CQIInfo_p->reportedSubbandBitMap = setBits;
    SET_CQI_REPORT_BIT(rat0CQIInfo_p->reportedCQIBitMap,cqiValue);

    while (subSetCount--)
    {
        SET_CQI_REPORT_BIT(rat1CQIInfo_p[subSetCount].reportedCQIBitMap,cqiValue);
        rat1CQIInfo_p[subSetCount].subsetCQIBitMapALLCQIIndex = 
            subSetInfo_p[subSetCount].subsetBitMap[CC_USER];
    }       
}

/****************************************************************************
 * Function Name  :  initSpatialRAT0RAT1Bitmaps 
 * Inputs         :  cqiIndex -CQI index
 *                   cqiInfoSpatialMul_p - Pointer to CQIInfoSpatialMul
 *                   internalCellIndex
 * Output         :  None
 * Returns        :  None
 * Description    :  This function init the Spatial bitmaps of RAT0 and RAT1 
 *                   for both CWs. 
 ******************************************************************************/
void initSpatialRAT0RAT1Bitmaps(UInt8 cqiIndex,
        CQIInfoSpatialMul *cqiInfoSpatialMul_p,
        InternalCellIndex internalCellIndex)

{
    RAT0SpatialMulCQIInfo *rat0CQIInfo_p = PNULL;
    RAT1SpatialMulCQIInfo *rat1CQIInfo_p = PNULL;
    RAT0Info *rat0Info_p = PNULL;
    RAT1Info *rat1Info_p = PNULL;
    /* 533 COVERITY FIX 61227 START */
    rat0Info_p = 
        &(dlRAInfo_gp[internalCellIndex] + 
                dlRAInfoIndex_g[internalCellIndex])->raPolicyInfo.rat0Info;
    rat1Info_p = 
        &(dlRAInfo_gp[internalCellIndex] + 
                dlRAInfoIndex_g[internalCellIndex])->raPolicyInfo.rat1Info;

    /* 533 COVERITY FIX 61227 END */
    SubsetInfo *subSetInfo_p = PNULL;
    UInt8 rbgCount =  rat0Info_p->rbgCount;
    UInt32 setBits = rat0Info_p->rat0BitMap[CC_USER];
    UInt32 addressableRBGCount =
        ceil_wrapper(((UDouble32)rat1Info_p->maxAddressableRBCount/rat0Info_p->rbgSize));
    UInt8 subSetCount =  rat1Info_p->subsetCount;
    rat0CQIInfo_p = &cqiInfoSpatialMul_p->rat0SpatialMulCQIInfo;

    if ((cqiIndex >= DL_64QAM_LOWEST_CQI_INDEX) &&
            (cqiIndex <= DL_64QAM_HIGHEST_CQI_INDEX))
    {
        /*Comes here when the CQI Index falls in 64QAM Bands*/

        /* Initializing RAT0 information*/
        rat0CQIInfo_p->count64QAMSubBandCW1 = rat0CQIInfo_p->count64QAMSubBandCW2 =
            rat0CQIInfo_p->count16QAMSubBandCW1 = rat0CQIInfo_p->count16QAMSubBandCW2 =
            rat0CQIInfo_p->countQPSKSubBandCW1 = rat0CQIInfo_p->countQPSKSubBandCW2 
            = rbgCount;
        rat0CQIInfo_p->rat064QAMCQIBitMapCW1 = 
            rat0CQIInfo_p->rat064QAMCQIBitMapCW2 = 
            rat0CQIInfo_p->rat016QAMCQIBitMapCW1 = 
            rat0CQIInfo_p->rat016QAMCQIBitMapCW2 = 
            rat0CQIInfo_p->rat0QPSKCQIBitMapCW1  = 
            rat0CQIInfo_p->rat0QPSKCQIBitMapCW2  = setBits;

        while(subSetCount--)
        {    

            rat1CQIInfo_p =  
                &cqiInfoSpatialMul_p->rat1SpatialMulCQIInfo[subSetCount];

            subSetInfo_p = &rat1Info_p->subsetInfo[subSetCount];

            /* Initializing RAT1 Zero span information*/
            rat1CQIInfo_p->subsetZeroSpanCQIInfo.count64QAMSubBandCW1 = 
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.count64QAMSubBandCW2 = 
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.count16QAMSubBandCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.count16QAMSubBandCW2 = 
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.countQPSKSubBandCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.countQPSKSubBandCW2
                = addressableRBGCount; 

            rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat164QAMCQIBitMapCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat164QAMCQIBitMapCW2 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat116QAMCQIBitMapCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat116QAMCQIBitMapCW2 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat1QPSKCQIBitMapCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat1QPSKCQIBitMapCW2 
                = subSetInfo_p->bitMapWithSpanZero;

            /* Initializing RAT1 Non-Zero span information*/
            rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.count64QAMSubBandCW1 = 
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.count64QAMSubBandCW2 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.count16QAMSubBandCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.count16QAMSubBandCW2 = 
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.countQPSKSubBandCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.countQPSKSubBandCW2
                = addressableRBGCount;

            rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat164QAMCQIBitMapCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat164QAMCQIBitMapCW2 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat116QAMCQIBitMapCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat116QAMCQIBitMapCW2 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat1QPSKCQIBitMapCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat1QPSKCQIBitMapCW2
                = subSetInfo_p->bitMapWithSpanNonZero;

            rat1CQIInfo_p->subsetCQIBitMapALLCQIIndex = 
                subSetInfo_p->subsetBitMap[CC_USER]; 

        }
    }

    else if ((cqiIndex >= DL_16QAM_LOWEST_CQI_INDEX) &&
            (cqiIndex <= DL_16QAM_HIGHEST_CQI_INDEX))
    {

        /*Comes here when the CQI Index falls in 16QAM Bands*/

        /* Initializing RAT0 information*/
        rat0CQIInfo_p->count16QAMSubBandCW1 = rat0CQIInfo_p->count16QAMSubBandCW2 =
            rat0CQIInfo_p->countQPSKSubBandCW1 = rat0CQIInfo_p->countQPSKSubBandCW2 
            = rbgCount;
        rat0CQIInfo_p->rat016QAMCQIBitMapCW1 = 
            rat0CQIInfo_p->rat016QAMCQIBitMapCW2 = 
            rat0CQIInfo_p->rat0QPSKCQIBitMapCW1  = 
            rat0CQIInfo_p->rat0QPSKCQIBitMapCW2  = setBits;

        while(subSetCount--)
        {    

            rat1CQIInfo_p =  
                &cqiInfoSpatialMul_p->rat1SpatialMulCQIInfo[subSetCount];

            subSetInfo_p = &rat1Info_p->subsetInfo[subSetCount];

            /* Initializing RAT1 Zero span information*/
            rat1CQIInfo_p->subsetZeroSpanCQIInfo.count16QAMSubBandCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.count16QAMSubBandCW2 = 
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.countQPSKSubBandCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.countQPSKSubBandCW2
                = addressableRBGCount; 

            rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat116QAMCQIBitMapCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat116QAMCQIBitMapCW2 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat1QPSKCQIBitMapCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat1QPSKCQIBitMapCW2 
                = subSetInfo_p->bitMapWithSpanZero;

            /* Initializing RAT1 Non-Zero span information*/
            rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.count16QAMSubBandCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.count16QAMSubBandCW2 = 
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.countQPSKSubBandCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.countQPSKSubBandCW2
                = addressableRBGCount;

            rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat116QAMCQIBitMapCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat116QAMCQIBitMapCW2 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat1QPSKCQIBitMapCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat1QPSKCQIBitMapCW2
                = subSetInfo_p->bitMapWithSpanNonZero;

        }
    }

    else if ((cqiIndex >= DL_QPSK_LOWEST_CQI_INDEX) &&
            (cqiIndex <= DL_QPSK_HIGHEST_CQI_INDEX))
    {

        /*Comes here when the CQI Index falls in QPSK Bands*/

        /* Initializing RAT0 information*/
        rat0CQIInfo_p->countQPSKSubBandCW1 = rat0CQIInfo_p->countQPSKSubBandCW2 
            = rbgCount;
        rat0CQIInfo_p->rat0QPSKCQIBitMapCW1  = 
            rat0CQIInfo_p->rat0QPSKCQIBitMapCW2  = setBits;

        while(subSetCount--)
        {    

            rat1CQIInfo_p =  
                &cqiInfoSpatialMul_p->rat1SpatialMulCQIInfo[subSetCount];

            subSetInfo_p = &rat1Info_p->subsetInfo[subSetCount];

            /* Initializing RAT1 Zero span information*/
            rat1CQIInfo_p->subsetZeroSpanCQIInfo.countQPSKSubBandCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.countQPSKSubBandCW2
                = addressableRBGCount; 

            rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat1QPSKCQIBitMapCW1 =
                rat1CQIInfo_p->subsetZeroSpanCQIInfo.rat1QPSKCQIBitMapCW2 
                = subSetInfo_p->bitMapWithSpanZero;

            /* Initializing RAT1 Non-Zero span information*/
            rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.countQPSKSubBandCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.countQPSKSubBandCW2
                = addressableRBGCount;

            rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat1QPSKCQIBitMapCW1 =
                rat1CQIInfo_p->subsetNonZeroSpanCQIInfo.rat1QPSKCQIBitMapCW2
                = subSetInfo_p->bitMapWithSpanNonZero;


        }
    }      
} 

/****************************************************************************
 * Function Name  :  initNumOfSBperBWpart 
 * Inputs         :  dlCQIInfo_p - Pointer to DLCQIInfo
 *                   internalCellIndex
 * Output         :  None
 * Returns        :  None
 * Description    :   
 ******************************************************************************/
void initNumOfSBperBWpart(DLCQIInfo *dlCQIInfo_p,
        InternalCellIndex internalCellIndex)
{
    /*SPR-15700 Fix start*/
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    if(cellParams_p->dlAvailableRBs == 100 && 
            cellParams_p->bandwidthParts == 4)
    {
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[0] = 4;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[1] = 3;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[2] = 3;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[3] = 3;
    }
    else if(cellParams_p->dlAvailableRBs == 75 && 
            cellParams_p->bandwidthParts == 4)
    {
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[0] = 3;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[1] = 3;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[2] = 2;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[3] = 2;
    }
    else if(cellParams_p->dlAvailableRBs == 50 && 
            cellParams_p->bandwidthParts == 3)
        /*SPR-15700 Fix end*/
    {
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[0] = 3;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[1] = 3;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[2] = 3;
    }
    else if(cellParams_p->dlAvailableRBs == 25 && 
            cellParams_p->bandwidthParts == 2)
    {
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[0] = 4;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[1] = 3;
    }
    else if(cellParams_p->dlAvailableRBs == 15 && 
            cellParams_p->bandwidthParts == 2)
    {
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[0] = 2;
        dlCQIInfo_p->subBandReportInfo_p->numOfSBperBWpart[1] = 2;
    }
}
/* SPR 9427 changes end */ 

/****************************************************************************
 * Function Name  : fillDRXMeasInfo
 * Inputs         : dlBitMapValue - Bit Map repressents the type of 
 *                   DL Configuraion(Meas Gap and DRX) to be processed
 *                  createDlUeEntity_p -  Pointer to the DL UE entity ,
 *                  dwlkUEInfo_p - Pointer to ueContextForDownlink required
 *                                 to configure MAC DL UE Context.
 *                  uplkUEInfo_p - Pointer to ueContextForUplink required
 *                                 to configure MAC UL UE Context.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API will fill DL Map information which has to be sent to HP
 *                  Thread.
 ****************************************************************************/
void fillDRXMeasInfo(UInt32 dlBitMapValue, 
        RrcOamHiPrioQNode *createDlUeEntity_p, 
        UeContextForDownlink *dwlkUEInfo_p,
        UeContextForUplink *uplkUEInfo_p,
        InternalCellIndex internalCellIndex
        )
{
    DLCreateUeReq  *dlCreateUeReqNode_p;
    dlCreateUeReqNode_p = &createDlUeEntity_p->rrcOamReqResp.dlCreateUeReq;

    /* Rel 5.3: Coverity 32235 Fix Start */
    dlCreateUeReqNode_p->createUEMsg = (RRCConfigureDlUEMsg)dlBitMapValue;
    /* Rel 5.3: Coverity 32235 Fix Start */

    switch(dlBitMapValue)
    {
        case RRC_CONFIGURE_MEAS_GAP_40MS_MAP:
        {
            dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap = 
                /*CA Changes start  */
                measGap40msInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */

            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_40MS_MAP \n"\
                    "Active Index for MeasGap 40ms Map = %d \n",__func__,
                    dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap);
        }
        break;
        case RRC_CONFIGURE_MEAS_GAP_80MS_MAP:
        {
            dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap =
                /*CA Changes start  */
                measGap80msInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "
                    "For Create UE:\n At LP Side \n "\
                    "RRC_CONFIGURE_MEAS_GAP_80MS_MAP"\
                    "Active Index for MeasGap 80ms Map At LP Side= %d \n",__func__,
                    dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap);
        }
        break;
        case RRC_CONFIGURE_DRX_MAP:
        {
            dlCreateUeReqNode_p->drxConfigInfo.drxConfigType = 
                dwlkUEInfo_p->drxConfigType; 
            dlCreateUeReqNode_p->drxConfigInfo.drxConfig = 
                dwlkUEInfo_p->drxConfig;
            dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920 
                = uplkUEInfo_p->cqiMaskV920;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]  For Create UE:"\
                    "\n RRC_CONFIGURE_DRX_MAP \n"\
                    "At LP Side \n DRX Config Type = %d \n"\
                    "isDRXShortCycleConfigured = %d \n"\
                    "drxOnDurationTimerIndex = %d \n"\
                    "drxInactivityTimerIndex = %d \n"\
                    "shortDRXCycleIndex = %d \n longDRXCycleIndex = %d\n"\
                    "drxOnDurationTimer = %d\n drxRetransmissionTimer= %d\n"\
                    "drxShortCycleTimer = %d\n drxInactivityTimer = %d\n"\
                    "shortDRXCycle = %d\n longDRXCycle = %d\n"\
                    "drxStartOffset = %d\n CQI Mask = %d\n", 
                    __func__,dlCreateUeReqNode_p->drxConfigInfo.drxConfigType,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.isDRXShortCycleConfigured,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxOnDurationTimerIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxInactivityTimerIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.shortDRXCycleIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.longDRXCycleIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxOnDurationTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxRetransmissionTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxShortCycleTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxInactivityTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.shortDRXCycle,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.longDRXCycle,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxStartOffset,
                    dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920
                        );

        }
        break;
        case RRC_CONFIGURE_DRX_MEAS_GAP_40MS_MAP:
        {
            dlCreateUeReqNode_p->drxConfigInfo.drxConfigType = 
                dwlkUEInfo_p->drxConfigType; 
            dlCreateUeReqNode_p->drxConfigInfo.drxConfig = 
                dwlkUEInfo_p->drxConfig;
            dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap = 
                /*CA Changes start  */
                measGap40msInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920 
                = uplkUEInfo_p->cqiMaskV920;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]  For Create UE:"\
                    "\n RRC_CONFIGURE_DRX_MEAS_GAP_40MS_MAP \n"\
                    "At LP Side \n "\
                    "Active Index for MeasGap 40ms Map = %d \n"\
                    "DRX Config Type = %d \n"\
                    "isDRXShortCycleConfigured = %d \n"\
                    "drxOnDurationTimerIndex = %d \n"\
                    "drxInactivityTimerIndex = %d \n"\
                    "shortDRXCycleIndex = %d \n longDRXCycleIndex = %d\n"\
                    "drxOnDurationTimer = %d\n drxRetransmissionTimer= %d\n"\
                    "drxShortCycleTimer = %d\n drxInactivityTimer = %d\n"\
                    "shortDRXCycle = %d\n longDRXCycle = %d\n"\
                    "drxStartOffset = %d\n CQI Mask = %d\n", 
                    __func__,dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfigType,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.isDRXShortCycleConfigured,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxOnDurationTimerIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxInactivityTimerIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.shortDRXCycleIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.longDRXCycleIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxOnDurationTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxRetransmissionTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxShortCycleTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxInactivityTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.shortDRXCycle,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.longDRXCycle,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxStartOffset,
                    dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920
                        );
        }
        break;
        case RRC_CONFIGURE_DRX_MEAS_GAP_80MS_MAP:
        {
            dlCreateUeReqNode_p->drxConfigInfo.drxConfigType = 
                dwlkUEInfo_p->drxConfigType; 
            dlCreateUeReqNode_p->drxConfigInfo.drxConfig = 
                dwlkUEInfo_p->drxConfig;
            dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap = 
                /*CA Changes start  */
                measGap80msInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920 
                = uplkUEInfo_p->cqiMaskV920;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]  For Create UE:"\
                    "\n RRC_CONFIGURE_DRX_MEAS_GAP_80MS_MAP \n"\
                    "At LP Side \n "\
                    "Active Index for MeasGap 80ms Map = %d \n"\
                    "DRX Config Type = %d \n"\
                    "isDRXShortCycleConfigured = %d \n"\
                    "drxOnDurationTimerIndex = %d \n"\
                    "drxInactivityTimerIndex = %d \n"\
                    "shortDRXCycleIndex = %d \n longDRXCycleIndex = %d\n"\
                    "drxOnDurationTimer = %d\n drxRetransmissionTimer= %d\n"\
                    "drxShortCycleTimer = %d\n drxInactivityTimer = %d\n"\
                    "shortDRXCycle = %d\n longDRXCycle = %d\n"\
                    "drxStartOffset = %d\n CQI Mask = %d\n", 
                    __func__,dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfigType,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.isDRXShortCycleConfigured,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxOnDurationTimerIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxInactivityTimerIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.shortDRXCycleIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.longDRXCycleIndex,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxOnDurationTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxRetransmissionTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxShortCycleTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxInactivityTimer,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.shortDRXCycle,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.longDRXCycle,
                    dlCreateUeReqNode_p->drxConfigInfo.drxConfig.drxStartOffset,
                    dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920
                        );

        }
        break;
#ifdef ENDC_ENABLED
		/*Meas_Gap_Changes_Start*/
        case RRC_CONFIGURE_MEAS_GAP_20MS_MAP:
        {
            dlCreateUeReqNode_p->activeIndexFor20MsMeasGapMap = 
                /*CA Changes start  */
                measGap20msInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */

            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_20MS_MAP \n"\
                    "Active Index for MeasGap 20ms Map = %d \n",__func__,
                    dlCreateUeReqNode_p->activeIndexFor20MsMeasGapMap);
        }
        break;
        case RRC_CONFIGURE_MEAS_GAP_160MS_MAP:
        {
            dlCreateUeReqNode_p->activeIndexFor160MsMeasGapMap = 
                /*CA Changes start  */
                measGap160msInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */

            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_160MS_MAP \n"\
                    "Active Index for MeasGap 160ms Map = %d \n",__func__,
                    dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap);
        }
        break;
        /*Meas_Gap_Changes_End*/
#endif
        default:
        break;
    }
}

/****************************************************************************
 * Function Name  : fillUlMapsInfoToHPthread
 * Inputs         : ulBitMapValue - Represent BIT Map oF UE UL configuration,
 *                  rrcOamHiPrioQNode - Pointer to RrcOamHiPrioQNode  
 *                  rrcMsgId - RRC Message Identifier
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API will fill UL Map information which has to be sent to HP
 *                  Thread.
 ****************************************************************************/
void fillUlMapsInfoToHPthread( UInt32 ulBitMapValue, 
        RrcOamHiPrioQNode *rrcOamHiPrioQNode, 
        /* + Coverity 32221 */
        RRCReqAPI rrcMsgId 
        /*CA changes start*/
        , InternalCellIndex internalCellIndex
        /*CA changes end */
        )
/* - Coverity 32221 */
{
    UInt32          *activeIndexForPUCCHMap_p    = PNULL;
    UInt32          *activeIndexForShortSRMap_p  = PNULL;
    UInt32          *activeIndexForLongSRSMap_p  = PNULL;
    UInt32          *activeIndexForShortSRSMap_p = PNULL;

    if(!rrcOamHiPrioQNode)
    {
        return;
    }
    if(MAC_CREATE_UE_ENTITY_REQ == rrcMsgId)
    {
        /* Rel 5.3: Coverity 32229 Fix Start */
        rrcOamHiPrioQNode->rrcOamReqResp.ulCreateUeReq.createUEMsg = (RRCConfigureUlUEMsg)ulBitMapValue;
        /* Rel 5.3: Coverity 32229 Fix End */
        activeIndexForPUCCHMap_p    = &rrcOamHiPrioQNode->rrcOamReqResp.ulCreateUeReq.activeIndexForPUCCHMap;
        activeIndexForShortSRMap_p  = &rrcOamHiPrioQNode->rrcOamReqResp.ulCreateUeReq.activeIndexForShortSRMap;
        activeIndexForLongSRSMap_p  = &rrcOamHiPrioQNode->rrcOamReqResp.ulCreateUeReq.activeIndexForLongSRSMap;
        activeIndexForShortSRSMap_p = &rrcOamHiPrioQNode->rrcOamReqResp.ulCreateUeReq.activeIndexForShortSRSMap;
    }
    else if(MAC_DELETE_UE_ENTITY_REQ == rrcMsgId)
    {
        /* Rel 5.3: Coverity 32230 Fix Start */
        rrcOamHiPrioQNode->rrcOamReqResp.ulDeleteUeReq.deleteUEMsg = (RRCConfigureUlUEMsg)ulBitMapValue;
        /* Rel 5.3: Coverity 32230 Fix End */

        activeIndexForPUCCHMap_p    = &rrcOamHiPrioQNode->rrcOamReqResp.ulDeleteUeReq.activeIndexForPUCCHMap;
        activeIndexForShortSRMap_p  = &rrcOamHiPrioQNode->rrcOamReqResp.ulDeleteUeReq.activeIndexForShortSRMap;
        activeIndexForLongSRSMap_p  = &rrcOamHiPrioQNode->rrcOamReqResp.ulDeleteUeReq.activeIndexForLongSRSMap;
        activeIndexForShortSRSMap_p = &rrcOamHiPrioQNode->rrcOamReqResp.ulDeleteUeReq.activeIndexForShortSRSMap;
    }
    else
    {
        return;
    }

    switch(ulBitMapValue)
    {
        case RRC_CONFIGURE_PUCCH_MAP:
        {
            *activeIndexForPUCCHMap_p =
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_PUCCH_MAP \n "\
                    "Active Index for PUCCH Map = %d \n",__func__,
                    *activeIndexForPUCCHMap_p);
        }
        break;
        case RRC_CONFIGURE_SHORT_SR_MAP:
        {
            *activeIndexForShortSRMap_p =
                /*CA Changes start  */
                shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_SHORT_SR_MAP \n "\
                    "Active Index for SHORT SR Map = %d \n",__func__,
                    *activeIndexForShortSRMap_p);
        }
        break;
        case RRC_CONFIGURE_SHORT_SRS_MAP:
        {
            *activeIndexForShortSRSMap_p =
                /*CA Changes start  */
                shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_SHORT_SRS_MAP \n "\
                    "Active Index for SHORT SRS Map = %d \n",__func__,
                    *activeIndexForShortSRSMap_p);
        }
        break;
        case RRC_CONFIGURE_LONG_SRS_MAP:
        {
            *activeIndexForLongSRSMap_p = 
                /*CA Changes start  */
                longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_LONG_SRS_MAP \n "\
                    "Active Index for LONG SRS Map = %d \n",__func__,
                    *activeIndexForLongSRSMap_p );
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SR_MAP:
        {
            *activeIndexForPUCCHMap_p = 
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForShortSRMap_p = 
                shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SR_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SR Map = %d \n",__func__,
                    *activeIndexForPUCCHMap_p,
                    *activeIndexForShortSRMap_p);
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SRS_MAP:
        {
            *activeIndexForPUCCHMap_p =
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForShortSRSMap_p = 
                shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SRS Map = %d \n",__func__,
                    *activeIndexForPUCCHMap_p,
                    *activeIndexForShortSRSMap_p);
        }
        break;
        case RRC_CONFIGURE_PUCCH_LONG_SRS_MAP:
        {
            *activeIndexForPUCCHMap_p = 
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForLongSRSMap_p = 
                longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_PUCCH_LONG_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for LONG SRS Map = %d \n",__func__,
                    *activeIndexForPUCCHMap_p,
                    *activeIndexForLongSRSMap_p);
        }
        break;
        case RRC_CONFIGURE_SHORT_SR_SHORT_SRS_MAP:
        {
            /*CA Changes start  */
            *activeIndexForShortSRMap_p = 
                shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForShortSRSMap_p = 
                shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_SHORT_SR_SHORT_SRS_MAP \n "\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for SHORT SRS Map = %d \n",__func__,
                    *activeIndexForShortSRMap_p,
                    *activeIndexForShortSRSMap_p);
        }
        break;
        case RRC_CONFIGURE_SHORT_SR_LONG_SRS_MAP:
        {
            /*CA Changes start  */
            *activeIndexForShortSRMap_p = 
                shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForLongSRSMap_p = 
                longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_SHORT_SR_LONG_SRS_MAP \n "\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for LONG SRS Map = %d \n",__func__,
                    *activeIndexForShortSRMap_p,
                    *activeIndexForLongSRSMap_p);
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SR_SHORT_SRS_MAP:
        {
            *activeIndexForPUCCHMap_p = 
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForShortSRMap_p = 
                shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForShortSRSMap_p = 
                shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SR_SHORT_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for SHORT SRS Map = %d \n",__func__,
                    *activeIndexForPUCCHMap_p,
                    *activeIndexForShortSRMap_p,
                    *activeIndexForShortSRSMap_p);
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SR_LONG_SRS_MAP:
        {
            *activeIndexForPUCCHMap_p = 
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForShortSRMap_p = 
                shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex;
            *activeIndexForLongSRSMap_p = 
                longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT LP Side \n"
                    "RRC_CONFIGURE_PUCCH_SHORT_SR_LONG_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for LONG SRS Map = %d \n",__func__,
                    *activeIndexForPUCCHMap_p,
                    *activeIndexForShortSRMap_p,
                    *activeIndexForLongSRSMap_p);
        }
        break;
        default:
        break;
    }
}

/****************************************************************************
 * Function Name  : sendToHPThread
 * Inputs         : event - Type of RRC event, 
 *                  dlData_p - pointer of RrcOamHiPrioQNode to Downlink Data
 *                  ulData_p - pointer to buffer of uplink data
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API will send Node to HP Thread.
 ****************************************************************************/
void sendToHPThread( MacProcessRrcOamMsgEvent event, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, 
        InternalCellIndex internalCellIndex )
{
    switch( event )
    {
        case MAC_RRC_CREATE_UE_ENTITY_EV:
        case MAC_RRC_RECONFIG_UE_ENTITY_EV:
        case MAC_RRC_RESET_REQ_EV:
        case MAC_HP_SEND_RESET_REQ_AGAIN:
        case MAC_RRC_DELETE_UE_ENTITY_EV:
        {
            if( dlData_p )
            {
                /* to HP Thd HP DL Q */
                if(!ENQUEUE_RRC_OAM_LPTOHP_THDH_PRIO_Q(&(rrcOamLPtoHPThdHPrioQ_g[internalCellIndex][DL_THD]),
                            RrcOamHiPrioQNode, dlData_p ))
                {
                    FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q(dlData_p);
                }
                rrcOamMsghandler[internalCellIndex].bitMaskSent |= MAC_RESPONSE_FRM_DL_THD;
            }
            if( ulData_p )
            {
                /* to HP Thd HP UL Q */
                if(!ENQUEUE_RRC_OAM_LPTOHP_THDH_PRIO_Q(&(rrcOamLPtoHPThdHPrioQ_g[internalCellIndex][UL_THD]),
                            RrcOamHiPrioQNode, ulData_p ))
                {
                    FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q(ulData_p);
                }
                rrcOamMsghandler[internalCellIndex].bitMaskSent |= MAC_RESPONSE_FRM_UL_THD;
            }
            break;
        }
        case MAC_RRC_CHANGE_CRNTI_EV:
        case MAC_RRC_HO_RACH_RESOURCE_EV:
        /* SPR 16583 fix start */
        case MAC_RRC_HO_REL_RACH_RESOURCE_EV:
        /* SPR 16583 fix end */
        {
            if( ulData_p )
            {
                /* to HP Thd RACH MGR Q */
                /*coverity id 25569*/

                if(!ENQUEUE_PDCCH_RACH_INTERFACE_Q(RachInterfaceQueueNode,
                            ulData_p, internalCellIndex))
                {
                    FREE_MEM_NODE_PDCCH_RACH_INTERFACE_Q(ulData_p);
                }    
                rrcOamMsghandler[internalCellIndex].bitMaskSent |= MAC_RESPONSE_FRM_UL_THD;
            }
            break;
        }
        default:
        {
            /* Not a valid event to send request to HP thread */
            break;
        }
    }
}

/****************************************************************************
 * Function Name  : rrcFreeReqBuffer
 * Inputs         : internalCellIndex 
 * Outputs        : None
 * Returns        : None
 * Description    : This function will free all the allocated request buffers 
 *                  for HP thread.
 ****************************************************************************/
void rrcFreeReqBuffer(InternalCellIndex internalCellIndex)
{
    UInt32 qCount  = 0;
    void   *data_p = PNULL;

    /* Check for queue for messages to DL thread */
    qCount = COUNT_RRC_OAM_LPTOHP_THDH_PRIO_Q(
            &(rrcOamLPtoHPThdHPrioQ_g[internalCellIndex][DL_THD]) );
    while( qCount-- )
    {
        DEQUEUE_RRC_OAM_LPTOHP_THDH_PRIO_Q( 
                &(rrcOamLPtoHPThdHPrioQ_g[internalCellIndex][DL_THD]), 
                RrcOamHiPrioQNode, 
                &data_p);
        FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( data_p );
    }

    /* Check for queue for messages to UL thread */
    qCount = COUNT_RRC_OAM_LPTOHP_THDH_PRIO_Q(
            &(rrcOamLPtoHPThdHPrioQ_g[internalCellIndex][UL_THD]) );
    while( qCount-- )
    {
        DEQUEUE_RRC_OAM_LPTOHP_THDH_PRIO_Q( 
                &(rrcOamLPtoHPThdHPrioQ_g[internalCellIndex][UL_THD]),
                RrcOamHiPrioQNode, 
                &data_p);
        FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( data_p );
    }

    /* Check for queue for messages to UL thread for RACH messages */
    qCount = COUNT_PDCCH_RACH_INTERFACE_Q(internalCellIndex); 
    while( qCount-- )
    {
        DEQUEUE_PDCCH_RACH_INTERFACE_Q(RachInterfaceQueueNode, 
                &data_p,
                internalCellIndex);
        FREE_MEM_NODE_PDCCH_RACH_INTERFACE_Q( data_p );
    }
}

/****************************************************************************
 * Function Name  : rrcOamfreeRespBuffer
 * Inputs         : internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API will free all the allocated response buffers.
 ****************************************************************************/
void rrcOamfreeRespBuffer(
        /*CA changes start*/
        InternalCellIndex internalCellIndex
        /*CA changes end */
        )
{
    UInt8 loop = 0;
    /* Memory pool exhaustion fix start */
    for( loop = 0; loop < MAX_THD; loop++ )
    {
        if (rrcOamHPResp_g[internalCellIndex][loop])
        {
            freeMemPool(rrcOamHPResp_g[internalCellIndex][loop]);
            rrcOamHPResp_g[internalCellIndex][loop] = PNULL;
        }
    }
    /* Memory pool exhaustion fix end */
}

/****************************************************************************
 * Function Name  : rrcOamCheckHiPrioResp
 * Inputs         : internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API will check response fropm HP Thread.
 ****************************************************************************/
void rrcOamCheckHiPrioResp(InternalCellIndex internalCellIndex )
{
    UInt16 ueIndex = 0;
    UInt16 retCode = MAC_SUCCESS;
    UInt32 lpRespQCCount = 0;
    MacProcessRrcOamMsgEvent eventId = MAC_CTRL_MAX_EV;
    RrcOamHiPrioQNode *dlData_p = PNULL;
    RrcOamHiPrioQNode *ulData_p = PNULL;

    /* check to which DL Thread Response message */
    lpRespQCCount = COUNT_RRC_OAM_HPTOLP_THDH_PRIO_Q(&rrcOamHPtoLPThdHPrioQ_g[internalCellIndex][DL_THD]);
    while (lpRespQCCount-- )
    {
        DEQUEUE_RRC_OAM_HPTOLP_THDH_PRIO_Q(&rrcOamHPtoLPThdHPrioQ_g[internalCellIndex][DL_THD],
                RrcOamHiPrioQNode, (void **)&dlData_p);
        if(!dlData_p)
        {
            /* this case should never happen */
            LOG_MAC_MSG( MAC_QUEUE_EMPTY, LOGWARNING, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, internalCellIndex, 0, 0, 0, 0 ,0, 
                    __func__, "rrcOamHPtoLPThdHPrioQ_g[internalCellIndex][DL_THD]" );
            retCode = MAC_FAILURE;
        }
        else if( dlData_p->respCode != MAC_SUCCESS ) 
        {
            eventId = dlData_p->eventId;
            ueIndex = dlData_p->ueIndex;
            retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamHPResp_g[internalCellIndex][DL_THD] = dlData_p;
            eventId = dlData_p->eventId;
            ueIndex = dlData_p->ueIndex;
        }
        /* If valid APIId is received, process the response received from HP 
         * thread and further calls state machine to send reponse to RRC. */
        if( MAC_CTRL_MAX_EV != eventId )
        {
            /* Call the state machine handler */
            rrcStateMachineHandler( ueIndex, eventId, PNULL, dlData_p, 
                    ulData_p, &retCode,internalCellIndex);
        }
        retCode = MAC_SUCCESS;
        /* + coverity 40420 */
        dlData_p = PNULL;
        /* - coverity 40420 */
    }

    /* check to which UL Thread Response message */
    lpRespQCCount = COUNT_RRC_OAM_HPTOLP_THDH_PRIO_Q(&rrcOamHPtoLPThdHPrioQ_g[internalCellIndex][UL_THD]);
    while (lpRespQCCount-- )
    {
        DEQUEUE_RRC_OAM_HPTOLP_THDH_PRIO_Q(&rrcOamHPtoLPThdHPrioQ_g[internalCellIndex][UL_THD],
                RrcOamHiPrioQNode, (void **)&ulData_p);
        if(!ulData_p)
        {
            /* this case should never happen */
            LOG_MAC_MSG( MAC_QUEUE_EMPTY, LOGWARNING, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, internalCellIndex, 0, 0, 0, 0 ,0, 
                    __func__, "rrcOamHPtoLPThdHPrioQ_g[internalCellIndex][UL_THD]" );
            retCode = MAC_FAILURE;
        }
        else if( ulData_p->respCode != MAC_SUCCESS ) 
        {
            eventId = ulData_p->eventId;
            ueIndex = ulData_p->ueIndex;
            retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamHPResp_g[internalCellIndex][UL_THD] = ulData_p;
            eventId = ulData_p->eventId;
            ueIndex = ulData_p->ueIndex;
        }
        /* If valid APIId is received, process the response received from HP 
         * thread and further calls state machine to send reponse to RRC. */
        if( MAC_CTRL_MAX_EV != eventId )
        {
            /* Call the state machine handler */
            rrcStateMachineHandler( ueIndex, eventId, PNULL, dlData_p, 
                    ulData_p, &retCode, internalCellIndex);
        }
        /* + coverity 40421 */
        ulData_p = PNULL;
        /* - coverity 40421 */
        retCode = MAC_SUCCESS;
    }
}
/*SPR 16855 +-*/
/****************************************************************************
 * Function Name  : initRRCAndOAMInterface
 * Inputs         : None
 * Outputs        : None
 * Returns        : None
 * Description    : This API will create sockets for receiving/transmitting data
 *                  to/from RRC and OAM.
 ****************************************************************************/

 void initRRCAndOAMInterface(void)
{
    LTE_MAC_UT_LOG(LOG_INFO,PARSE_UTIL,"[%s] Entry ", __func__ );
    /* Socket creation for Receiving data from RRC Layer */
    initComRRCAndOAMInterface();
    /* +- SPR 17777 */
    alarm_init (OAM_MODULE_ID, oamIPAddress_g, txPortMacOAM_g);
    /* +- SPR 17777 */

    /* Memory handling changes start */
#ifdef TDD_CONFIG
    createMemPool(sizeof(ReceivePhyDataQueueNode), 1);
#endif    
    createMemPool(sizeof(MuMimoStatsPerUe), 1);
    createMemPool(MAX_DATA_SIZE,1);
    createMemPool(MAX_MSG_SIZE,1);
#ifdef KPI_STATS    
    createMemPool(MAX_ARRAY_DATA_SIZE,2);
#endif
#ifdef PERF_STATS
    createMemPool(MAX_OAM_PERF_STATS_SIZE,1);
#endif
    /* Memory handling changes end */

    LTE_MAC_UT_LOG(LOG_INFO,PARSE_UTIL,"[%s] Exit ", __func__ );
}



/*****************************************************************************
 * Function Name  : sendMacMsgToRRC 
 * Inputs         : msgBuf - Message which to be send to RRC,
 *                  msgLen - length of Message,
 *                  flag - socket flag
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None 
 * Returns        : SUCCESS or Error Code
 * Description    : This function is used by MAC to send config response to RRC.
 *****************************************************************************/
SInt32 sendMacMsgToRRC(UInt8 *msgBuf, UInt16 msgLen, SInt32 flag,
        InternalCellIndex internalCellIndex)
{
    SInt32 retval = 0;
    /*SPR 10100 changes start */
    flag = MAC_RRC_SOCKET_FLAG;
    /*SPR 10100 changes end */

#ifdef MAC_AUT_TEST
    retval = 0;
    memCpy(msgBufferForOAMAndRRCMsgs,msgBuf,msgLen);
#endif    
    retval = sendto_wrapper(txSockFD_g, (UInt8 *)msgBuf, msgLen, flag,
            ((const SockAddr *)&tx_addr_g), sizeof(tx_addr_g));
    if (retval == -1)
    {
        lteWarning("*** sendMacMsgToRRC() fd:%d errno:%d msgBuf:%p current_p:%u", txSockFD_g, errno, msgBuf, msgLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                txSockFD_g,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "sendMacMsgToRRC failed ");
        /* Review comment fix end RJ13 */
    }
    return retval;
}

/*****************************************************************************
 * Function Name  : receiveOAMAndRRCMsg 
 * Inputs         : msgHdr - Pointer to message header,
 *                  bytesRead_output - Number of bytes received on socket,
 *                  mem_type - Flag to define if it is ZCB or Non-ZCB
 * Outputs        : None
 * Returns        : Pointer to message received in zero/non-zero buffer. 
 * Description    : This function receives the OAM-RRC messages from socket. 
 *****************************************************************************/
UInt8 * receiveOAMAndRRCMsg(UInt8 *msgHdr, SInt32 *bytesRead_output, UInt8 *mem_type)
{
    UInt8 *msgBuf        = PNULL;
    void *buf            = PNULL;
    UInt16 destModuleId  = 0;
    UInt16 srcModuleId   = 0;
    UInt8 *msg_p         = PNULL;
    UInt16 msgId 	     = 0;
    UInt16 msgLen        = 0;
    SInt32 bytesRead     = 0;


    /* this is used for logging only, till the time header is parsed
     * from socket, use default value as 0 */
    InternalCellIndex internalCellIndex = 0;

    /*SPR 16855 +-*/
    /* SPR 6949 Fix Start */
    if ((bytesRead = readDataFromRxSockFd(msgHdr ,RRC_MAC_API_HEADER_LEN ,MSG_PEEK,internalCellIndex ))
            == MAC_RECV_ERROR)
    {
        return PNULL; 
    }

    if ( bytesRead < MAC_API_HEADER_LEN )
    {
        lteWarning ("Wrong Message   Length Received \n");   

        LOG_MAC_MSG(OAM_RRC_INVALID_MSG_LEN_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                errno,bytesRead,LINE_NUMBER,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_MSG");
        /* SPR 6949 Fix Start */
        return PNULL; 
    }
    msg_p = msgHdr;
    msg_p += 2;
    srcModuleId   = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    destModuleId  = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    msgId   = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    msgLen = LTE_GET_U16BIT(msg_p);

#ifdef LOG_PRINT_ENABLED
    internalCellIndex = layer2CommonGetInternalCellIndex(msgHdr[API_HEADER_CELL_INDEX_OFFSET]);
    if (internalCellIndex >= MAX_NUM_CELL)
    {
        /* if cell not yet created (if it is MAC_INIT_LAYEa_REQR or MAC_INIT_CELL_REQ messages
         * assign it as 0, it is used for logging only */
        internalCellIndex = 0;
    }
#endif

    /* + Coverity 31435 */
    /* SPR 8737 Start */
    if(msgLen > MAX_ARRAY_DATA_SIZE)
    {
        /*531 coverity 31435*/
        GET_MEM_FROM_POOL(UInt8,msgBuf,MAX_ARRAY_DATA_SIZE,PNULL);
        /*531 coverity 31435*/

        if( PNULL != msgBuf )
        {
            /*531 coverity 31435*/
            bytesRead = recvfrom_wrapper( rxSockFD_g, msgBuf, MAX_ARRAY_DATA_SIZE,0, PNULL, 0);
            /*531 coverity 31435*/

            /* Coverity_73438 Fix Start */
            if(MAC_RECV_ERROR == bytesRead || MAX_ARRAY_DATA_SIZE != bytesRead )
            {
                ALARM_MSG (MAC_MODULE_ID, RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
                LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        errno,bytesRead,LINE_NUMBER,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"INVALID_MSG");
            }
            /* Coverity_73438 Fix End */

            freeMemPool(msgBuf);
        }

        return PNULL;
    }
    /* SPR 8737 End */
    /* - Coverity 31435 */

    if (( MAC_MODULE_ID == destModuleId ) && 
            ( RRC_MODULE_ID == srcModuleId ) && 
            ( msgId == MAC_CONFIG_CELL_REQ ||
              msgId == MAC_PCCH_MSG_REQ ||     
              msgId == MAC_CCCH_MSG_REQ ||
              msgId == MAC_BCCH_MSG_REQ ||
              msgId == MAC_UE_CON_REJ_REQ 
))

    {
        /* + Coverity 31227 */
        if( PNULL == (buf = msgAlloc(PNULL, 0, 0, 0)) )
        {
            return PNULL;
        }
        msgBuf = msgReserve(buf, 0, msgLen);
        if (msgBuf != PNULL)
        {
            *mem_type = 1; /*This indicate Zero copy buffer*/ 
        }
        else 
        {
            msgFree( buf );
            return PNULL; 
        }
        /* - Coverity 31227 */
    }
    else 
    {
        GET_MEM_FROM_POOL(UInt8,msgBuf,msgLen,PNULL);
        /* + Coverity 31227 */
        if( PNULL == msgBuf )
        {
            return PNULL;
        }
        *mem_type = 0; /*This indicate Non ZCB */ 
        /* - Coverity 31227 */
    }
    /* SPR 6949 Fix Start */
    bytesRead = recvfrom_wrapper( rxSockFD_g, msgBuf, msgLen,0, PNULL, 0);
    /* SPR 6949 Fix End */
    if(MAC_RECV_ERROR == bytesRead || msgLen != bytesRead )
    {
        ALARM_MSG (MAC_MODULE_ID, RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                errno,bytesRead,LINE_NUMBER,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_MSG");
        /* Coverity_31227 Fix */
        if( *mem_type == 1 )
        {
            msgFree(buf);
        }
        else
        {
            freeMemPool(msgBuf);
        }
        /* Coverity_31227 Fix */
        return PNULL; 
    }

    /* + Coverity 31227 */
    *bytesRead_output = bytesRead;

    if(*mem_type == 1)
    {
        return buf;
    }
    else
    {
        return msgBuf; 
    }
    /* - Coverity 31227 */
}
/****************************************************************************
 * Function Name  : processOAMAndRRCMsg
 * Inputs         : delayToPhy - Delay to phy
 *                : msgHdr - Pointer to message header,
 *                  msgBuf - pointer to the message buffer recieved
 *                  bytesRead_output - Number of bytes received on socket,
 * Outputs        : None
 * Returns        : None
 * Description    : This API receives data on socket, parse the msgId and call
 *                  the corresponding API to deal with the message.
 ****************************************************************************/
/* SPR 21412 Fix Start */
/* SPR 21407 fix start */
/* SPR 21407 fix end */
/* SPR 21412 Fix End */
void processOAMAndRRCMsg 
( 
 /* +- SPR 17777 */
 UInt8 *msgHdr,UInt8 *msgBuf,SInt32 bytesRead
 )
{
    UInt16 msgId         = 0;
    UInt16 srcModuleId   = 0;
    UInt16 destModuleId  = 0;
    UInt16 msgLen        = 0;
    UInt8 *msg_p         = PNULL; /* current_p access location in msg buffer*/
    UInt16 transactionId = 0;
    /* CA Changes start */
    RrcCellIndex cellIndex = 0;
    InternalCellIndex internalCellIndex = INVALID_CELL_INDEX;

    /* if issue in receiving the packet */
    if(MAC_RECV_ERROR == bytesRead)
    {
        ALARM_MSG (MAC_MODULE_ID, RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGERROR,MAC_RRC_INF,
                0xFFFFFFFF,
                cellIndex, internalCellIndex, 0,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"OAM_INVALID_MSG");
    }

    msg_p = msgHdr;

    /* OAM/RRC message received */
    /*Parse the buffer header */
    transactionId = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    srcModuleId   = LTE_GET_U16BIT(msg_p);
    msg_p += 2; 
    destModuleId  = LTE_GET_U16BIT(msg_p);
    msg_p += 2; 
    /* decode the msgBuffer and get APIID(2 bytes) */
    msgId         = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    msgLen        = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    /* get the next byte as cell Index */
    cellIndex = (UInt8) *msg_p;
    msg_p += 1;

    if (((msgId ==  MAC_INIT_LAYER_REQ) || (msgId ==  MAC_INIT_CELL_REQ) 
                    ) &&
            ( macCommonGetNumberOfInitReceived() != macParams_g.numCellsConfigured ))
    {
        internalCellIndex =  macCommonUpdateCellIndexMapping(cellIndex);
    }
    else
    {
        internalCellIndex = macCommonGetInternalCellIndex(cellIndex);
    }
    if ((internalCellIndex > MAX_INTERNAL_CELL_INDEX) ||
            /* If init not yet done and message are not for Initialization */
            ((msgId !=  MAC_INIT_LAYER_REQ) &&
             (msgId !=  MAC_INIT_CELL_REQ) &&
             (!(macParams_g.isInitDone))))
        {
            /* if no cell found or INit not yet done */
            LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGERROR,MAC_RRC_INF,
                    0xFFFFFFFF,
                    cellIndex, internalCellIndex, 0,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"OAM_INVALID_MSG");

            /* send failure response for all messages */
            if (OAM_MODULE_ID == srcModuleId)
            {
                macSendOamFailResponse (msgId, transactionId, cellIndex);
            }
            else if (RRC_MODULE_ID == srcModuleId)
            {
                if (PHY_MODULE_ID == destModuleId)
                {
                    macSendRrcPhyFailResponse (msgId, transactionId, cellIndex);
                }
                else
                {
                    macSendRrcFailResponse (msgId, transactionId, cellIndex);
                }
            }
            return;
        }
    if ( (MAC_MODULE_ID != destModuleId) && (PHY_MODULE_ID != destModuleId)
            && (transactionId_g[internalCellIndex] != INVALID_TRANS_ID)
            /* SPR 16091 fix start */
            /*SPR 16417 Fix Start*/
            && ((UInt16)INVALID_TRANS_ID != phyInitTransactionId_g))
        /*SPR 16417 Fix End*/
        /* SPR 16091 fix end */
        {
            /*L2_FIX_27_start*/
            LOG_MAC_MSG(OAM_MAC_MSG_ID,LOGERROR,MAC_OAM_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),destModuleId,transactionId_g[internalCellIndex],
                    bytesRead,internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"Invalid destModuleId Received");
            /*L2_FIX_27_end*/

            return;
        }
    /* +- SPR 16091 */
    /* Msg Recieved from OAM */
    switch(srcModuleId)
    {
        case OAM_MODULE_ID:
        {
            LOG_MAC_MSG(OAM_MAC_MSG_ID,LOGWARNING,MAC_OAM_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),destModuleId,transactionId,
                    bytesRead,internalCellIndex,msgId,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"OAM_MAC_MSG_ID");

				/* CA Changes start */ 

            /* +- SPR 17777 */
            /* UL-SUBFRAME Code Changes Start */
            parseOAMMsg( msgBuf, 
                    msgId, 
                    transactionId, 
                    internalCellIndex);
            /* UL-SUBFRAME Code Changes End */
            /* +- SPR 17777 */
            /* CA Changes end */ 
            break; 
        }/* Msg Recieved from RRC Module */
        case RRC_MODULE_ID:   
        {
            LOG_UT(RRC_MAC_MSG_ID,LOGDEBUG,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    destModuleId,msgId,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"RRC_MSG_RECVD");

			if (MAC_SFN_REQ == msgId)
			{
				//MAC_SFN_REQ has a period of 500ms, don't show it in LOGWARNING
				LOG_MAC_MSG(RRC_MAC_MSG_ID,LOGINFO,MAC_RRC_INF,
						GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
						destModuleId,msgId,msgLen,
						internalCellIndex,DEFAULT_INT_VALUE,
						DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
						FUNCTION_NAME,"RRC_MSG_RECVD");
			}
			else
			{
				LOG_MAC_MSG(RRC_MAC_MSG_ID,LOGWARNING,MAC_RRC_INF,
						GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
						destModuleId,msgId,msgLen,
						internalCellIndex,DEFAULT_INT_VALUE,
						DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
						FUNCTION_NAME,"RRC_MSG_RECVD");
			}

            if (PHY_MODULE_ID == destModuleId)
            {
                processRRCMsgForPhy(msgId,
                        destModuleId,
                        msgLen,
                        msgBuf,
                        transactionId,
                        internalCellIndex);
            }
            /* + SPR_11589 */
				else if (
/*SPR 18132 fix start*/ 
#ifdef LTE_EMBMS_SUPPORTED
                          ((msgId != MAC_AREA_CONFIG_REQUEST) &&
                          (msgId != MAC_COUNTING_MSG) &&
                          (msgId != MAC_RESET_SESSION_REQ))&&
#endif
/*SPR 18132 fix end*/ 
                          ((!macParams_g.isInitDone) || 
                    ((cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]) && 
                     (CELL_INIT == 
						  cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellState)))) 
                /* - SPR_11589 */
            {
                if ( msgId == MAC_CONFIG_CELL_REQ)
                {
                    LOG_MAC_MSG(MAC_CONFIG_CELL_REQ_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            destModuleId,msgId,msgLen,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"MAC_CONFIG_CELL_REQ_RECVD");

                    /* variable of cell configuration request structure */
                    ConfigCellRes configCellRes = {0};
                    configCellRes.response = MAC_FAILURE;
                    configCellRes.transactionId = transactionId;
                    configCellRes.errorType = MAC_RRC_ERROR_CELL_IN_INVALID_STATE;
                    /* CA changes End */

                    /* function that sends the confirmation message to RRC */
                    if(MAC_SEND_ERROR == 
                            sendMsgToRRC( MAC_CONFIG_CELL_CNF, 
                                &configCellRes, cellIndex))
                    {
                        ALARM_MSG (MAC_MODULE_ID, 
                                SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
                    }

                    ALARM_MSG (MAC_MODULE_ID, 
                            RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
                    lteWarning("Either MAC Layer is not initialized yet "
                            "or macPhyRegistration is not successful\n");

                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            configCellRes.response,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Either MAC Layer is not "
                            "initialized yet or macPhyRegistration is not successful");
                }
                return;
            }
            else
            {
                parseRRCCellConfigMsg (msgId, msgLen, msgBuf, 
                        destModuleId, transactionId,internalCellIndex);
            }
            break;  
        }
        default:
        {
            LOG_MAC_MSG(OAM_RRC_MAC_INVALID_SRC_ID, LOGFATAL, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    srcModuleId, internalCellIndex, DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "OAM RRC INVALID SRC ID");

            ltePanic ("Message Received From Wrong Source Module Id.\n");
            return;
        }
    }
    return;
}/* end of processOAMAndRRCMsg */

/*+ SPR 18399*/
/*- SPR 18399*/ 

/****************************************************************************
 * Function Name  : processRRCPhyConfigCellReq
 * Inputs         : msgId - API Id received from RRC
 *                  msgLen - Incoming API length
 *                  msgBuf - Incoming message buffer
 *                  transactionId - Transaction Id of the incoming message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the PHY_CONFIG_CELL_REQ received
 *                  from RRC and sends the response to RRC.
 ****************************************************************************/
STATIC  void processRRCPhyConfigCellReq( UInt16 msgId, 
        UInt16 msgLen, UInt8 *msgBuf, UInt16 transactionId,
        InternalCellIndex  internalCellIndex)
{
    /* + coverity 42183 */
    MacRetType retval = MAC_FAILURE;
    /* - coverity 42183 */
    UInt8 *data_p = PNULL;
    /* +- SPR 17777 */

    data_p = msgBuf;
    LOG_MAC_MSG(RRC_PHY_CELL_CONFIG_REQ_ID,LOGWARNING,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            PHY_MODULE_ID,msgId,DEFAULT_INT_VALUE,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"PHY_CONFIG_CELL_RECVD");
    /* + SPR_11589 */
    /*+ SPR 18399*/
    if ((macParams_g.isInitDone) && 
            (cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]) &&
            (CELL_PHY_INIT == 
             cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellState
            ))
        /* - SPR_11589 */
        /*- SPR 18399*/
    {
        /* +- SPR 17777 */
        /* SPR 19288 change start */
#if defined(FLEXRAN)
        /* SPR 16091 fix start */
        transactionId_g[internalCellIndex] = transactionId;
        /* SPR 16091 fix end */
#endif
        /* SPR 19288 change end */


        if( MAC_SUCCESS == parseAndSendConfigPhyCell(data_p + PHY_API_HEADER_LEN,
                    msgLen - PHY_API_HEADER_LEN,internalCellIndex))
        {
#ifndef FLEXRAN
            cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->cellState = CELL_WAITING_FOR_PHY_CONFIG;
            /* SPR 19288 change start */
            /* +- SPR 15296 */
            /* SPR 16091 fix start */
            transactionId_g[internalCellIndex] = transactionId;
            /* SPR 16091 fix end */
#endif
            /* SPR 19288 change end */
            return;

        }
        else
        {
            retval = MAC_FAILURE;
            LOG_MAC_MSG(RRC_PHY_CELL_CONFIG_REQ_ID, LOGWARNING, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    PHY_MODULE_ID, msgId, DEFAULT_INT_VALUE,
                    internalCellIndex, DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "PHY_CONFIG_CELL Parsing Fail");
        }
    }
    else
    {
        retval = MAC_FAILURE;
        lteWarning ("Invalid PHY Config Request Received from L3\n");
        LOG_MAC_MSG(RRC_PHY_CELL_CONFIG_REQ_ID,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                PHY_MODULE_ID,msgId,
                DEFAULT_INT_VALUE,internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"PHY_CONFIG_CELL Occurence Invalid");
    }
    /* Review comment fix start RJ29 */
    /* CA Changes start */
    if(MAC_SEND_ERROR == sendPhyCellRespToRRC(PHY_CONFIG_CELL_CNF, 
                transactionId, retval,
                macCommonGetRRCCellIndex(internalCellIndex) ))
        /* CA Changes end */
        /* Review comment fix end RJ29 */
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                MAJOR_ALARM);
    }
    else
    {
        LOG_MAC_MSG(RRC_PHY_CELL_CONFIG_REQ_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                PHY_MODULE_ID,msgId,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"PHY_CONFIG_CELL SentRespToRRC");
    }
}

/****************************************************************************
 * Function Name  : processRRCPhyReconfigCellReq 
 * Inputs         : msgId - API Id received from RRC
 *                  msgLen - Incoming API length
 *                  msgBuf - Incoming message buffer
 *                  transactionId - Transaction Id of the incoming message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the PHY_RECONFIG_CELL_REQ 
 *                  received from RRC and sends the response to RRC.
 ****************************************************************************/
/* CA Changes start */
STATIC  void processRRCPhyReconfigCellReq( UInt16 msgId, 
        UInt16 msgLen, UInt8 *msgBuf, UInt16 transactionId,
        InternalCellIndex internalCellIndex)
{
    /* + coverity 42181, 32751 */
    MacRetType  retval = MAC_FAILURE;
    /* - coverity 42181, 32751 */
    UInt8 *data_p = PNULL;

    /* SPR 3224 START */
    UInt8 doRespondToRRc = FALSE;
    /* SPR 3224 END */
    /* CA Changes start */
    CellState cellState = cellSpecificParams_g.cellConfigAndInitParams_p\
                          [internalCellIndex]->cellState;
    /* CA Changes end */
    data_p = msgBuf;
    LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGWARNING,
            MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            PHY_MODULE_ID,msgId,internalCellIndex,
            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"PHY_RECONFIG_CELL_REQ RECVD");
    /*   Cell Start Stop Chg */
    /* CA Changes start */
    if ((cellState < CELL_WAIT_FOR_PHY_START) ||
            (cellState == CELL_WAITING_FOR_FIRST_SFI)||
            /* + SPR_10941 */
            (cellState == CELL_WAITING_FOR_PHY_STOP_AFTER_DELETE_REQ) ||
            (cellState == CELL_WAITING_FOR_PHY_STOP_AFTER_STOP_REQ) ||
            /* - SPR_10941 */
            (cellState == CELL_PHY_STOP))
        /* CA Changes end */
    {
        retval = MAC_FAILURE;
        lteWarning ("Phy Reconfig received in PHY Cell Idle State\n");
        LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGERROR,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                PHY_MODULE_ID,msgId,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PHY_RECONFIG_CELL_REQ RECVD in Cell Idle State");
        /* SPR 3224 START */
        doRespondToRRc = TRUE;
        /* SPR 3224 END */
    }
    else
    { 
        /* CA CHanges start */ 	
        /* If PHY reconfig is ongoing return failure */
        if (( cellState == CELL_PHY_RECONFIG_RECVD_AFTER_CELL_STOP) || 
                (cellState == CELL_PHY_RUNNING_CONFIG_RECVD))
        {
            lteWarning ("Phy Reconfig Already ongoing.\n");
            retval = MAC_FAILURE;
            LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGWARNING,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    PHY_MODULE_ID,msgId,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PHY_RECONFIG_CELL Duplicate Request");
            /* SPR 3224 START */
            /* In this case send the response to RRC since 
               PHY reconfig is ongoing */
            doRespondToRRc = TRUE;
            /* SPR 3224 END */
        }
        else
        {
            /*   Cell Start Stop Chg */
            if (CELL_WAIT_FOR_PHY_START == cellState)
            {
                retval = sendAndParseReConfigPhyCellAfterCellStop(data_p + 
                        PHY_API_HEADER_LEN,
                        msgLen - PHY_API_HEADER_LEN,
                        internalCellIndex);
                if(retval)
                {
                    /* SPR 16091 fix start */
                    transactionId_g[internalCellIndex] = transactionId;
                    /* SPR 16091 fix end */
                    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                        cellState = CELL_PHY_RECONFIG_RECVD_AFTER_CELL_STOP;
                    doRespondToRRc = FALSE;
                }
                else 
                {
                    doRespondToRRc = TRUE;
                }

                /* SPR 3224 START */
                /* Send the response to RRC since 
                   reConfigPhyCellAfterCellStop
                   waits for the response from PHY.
                   So its response is sent to RRC */
                /* SPR 3224 END */
            }
            else if (CELL_PHY_RUNNING == cellState)
            {
                retval = reConfigPhyCell(data_p + PHY_API_HEADER_LEN,
                        msgLen - PHY_API_HEADER_LEN, internalCellIndex );


                switch(retval)
                {
                    case MAC_FAILURE:
                    {
                        reconfigPhyCell_g[internalCellIndex].reconfigUpdate 
                            = FAPI_FALSE;
                        LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,
                                LOGWARNING,
                                MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                PHY_MODULE_ID,msgId, 
                                internalCellIndex,
                                DEFAULT_INT_VALUE,
                                DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "PHY_RECONFIG_CELL_FAIL");
                        break;
                    }
                    case MAC_PARTIAL_SUCCESS: 
                    {
                        reconfigPhyCell_g[internalCellIndex].reconfigUpdate = FAPI_FALSE;
                        break;
                    }	
                    default:  
                    {
                        reconfigPhyCell_g[internalCellIndex].reconfigUpdate = 
                            FAPI_PENDING_RESPONSE;
                        reconfigPhyCell_g[internalCellIndex].transactionId = transactionId; 
                        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                            cellState = CELL_PHY_RUNNING_CONFIG_RECVD;
                    }
                    /* SPR 16091 fix start */
                    transactionId_g[internalCellIndex] = transactionId;
                    /* SPR 16091 fix end */

                    doRespondToRRc = FALSE;
                }
            }
        }
    }
    /* SPR 3224 START */ 
    if (doRespondToRRc == TRUE)
    {
        /* Irrespective of the retVali, send it to RRC */
        /* in case multi sector not enabled, internalCellIndex will be 0 and same
         * will be set towards PHY */
        if( MAC_SEND_ERROR ==
                sendPhyCellRespToRRC(PHY_RECONFIG_CELL_CNF,transactionId, retval,
                    macCommonGetRRCCellIndex(internalCellIndex)))
            /* Review comment fix end RJ29 */
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                    MAJOR_ALARM);
        }
        else
        {
            LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGWARNING,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    PHY_MODULE_ID,msgId,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"Mac Reconfig SentRespToRRC");
        }
    }
    else
    {
        if(MAC_SUCCESS != retval)
        {
            /* case where doRespondToRRc is false 
               and reconfigPhyCell also fails tehn also send the 
               response to RRC */ 
            if (retval == MAC_PARTIAL_SUCCESS)
            {
                /* if partial success is received it means that 
                 * that the received parameters are unchanged*/
                retval = MAC_SUCCESS;
            }
            /* in case multi sector not enabled, internalCellIndex will be 0 and same
             * will be set towards PHY */
            if( MAC_SEND_ERROR == 
                    sendPhyCellRespToRRC(PHY_RECONFIG_CELL_CNF,transactionId, 
                        retval, macCommonGetRRCCellIndex(internalCellIndex))) 
                /* Review comment fix end RJ29 */
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                        MAJOR_ALARM);
            }
            else
            {
                LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGWARNING,
                        MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        PHY_MODULE_ID,msgId,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"Mac Reconfig SentRespToRRC");
            }
        }
        else
        {
            LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGWARNING,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    PHY_MODULE_ID,msgId,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PHY_RECONFIG_CELL_SUCESS");
        }
    }
    /* SPR 3224 END */
}

/* CA Changes end */
/****************************************************************************
 * Function Name  : processRRCPhyDeleteCellReq 
 * Inputs         : msgId - API Id received from RRC
 *                  msgLen - Incoming API length
 *                  msgBuf - Incoming message buffer
 *                  transactionId - Transaction Id of the incoming message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the PHY_DELETE_CELL_REQ 
 *                  received from RRC and sends the response to RRC.
 ****************************************************************************/
/* SPR 21407 fix end */
STATIC  void processRRCPhyDeleteCellReq( UInt16 msgId, 
        /* +- SPR 17777 */
		UInt8 *msgBuf, UInt16 transactionId
		/* CA Changes start */
		,InternalCellIndex internalCellIndex
		/* CA Changes end */
		)
{
    /* + coverity 42182 */
    MacRetType  retval = MAC_FAILURE;
    /* - coverity 42182 */
    UInt8 *data_p = PNULL;

    /* CA Changes start */
    CellState cellState = CELL_INIT;
    InternalCellIndex ix = 0;
    /* CA Changes end */
    /* SPR 3224 START */
    RrcCellIndex cellIndex = 0;
    /* SPR 3224 END */
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
    InternalCellIndex cellId = 0; 
#endif
    data_p = msgBuf;
    LOG_MAC_MSG( RRC_PHY_DELETE_CELL_REQ_ID, LOGWARNING,
            MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            PHY_MODULE_ID,msgId, 
            DEFAULT_INT_VALUE,internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"PHY_DELETE_CELL_REQ received");
    data_p += API_RRC_HEADER_CELL_INDEX_OFFSET;
    cellIndex = macCommonGetRRCCellIndex(internalCellIndex);
    /* CA Changes start */
    if (LTE_FALSE == macCommonLookupIfValidCellIndex(cellIndex))
    {
        ALARM_MSG (MAC_MODULE_ID, RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cellIndex, internalCellIndex, 0,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"OAM_INVALID_MSG");
        /* + coverity 73136 */
        if( MAC_SEND_ERROR == 
                sendPhyCellRespToRRC(PHY_DELETE_CELL_CNF,
                    transactionId, MAC_FAILURE, cellIndex))
        {
            ALARM_MSG (MAC_MODULE_ID, 
                    SEND_MSG_FAILED_ALARM_ID,
                    MAJOR_ALARM);
        }
        return ;
        /* - coverity 73136 */
    }

    cellState = cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->cellState;  
    /* SPR 21412 Fix Start */
    /* If Delete Request is triggered for second cell, we need to process the 
       request at MAC layer as Cell is already stopped with stop request for Cell 0 */
    if((CELL_PHY_RUNNING == cellState) || 
            (cellState == CELL_WAITING_FOR_FIRST_SFI)
      )
        /* SPR 21412 Fix End */
    {
        if (MAC_FAILURE == sendStopReqToPhy(internalCellIndex))
/* SPR 21407 fix end */
        {

            LTE_MAC_UT_LOG(LOG_WARNING, CELL_CONF,"Error sending Stop request to PHY");
            if( MAC_SEND_ERROR == 
                    sendPhyCellRespToRRC(PHY_DELETE_CELL_CNF,
                        transactionId, MAC_FAILURE, cellIndex))
            {
                ALARM_MSG (MAC_MODULE_ID, 
                        SEND_MSG_FAILED_ALARM_ID,
                        MAJOR_ALARM);
            }
            return ;
        }
        /* + Critical section changes */

        if (IS_CA_ENABLED())
        {
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
            semWait(&cellSyncSem_g);
#endif 
            /* + SPR_10941 */
            cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->cellState  = CELL_WAITING_FOR_PHY_STOP_AFTER_DELETE_REQ;
            /* - SPR_10941 */

#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
            if ( ( cellElSyncTracker[!internalCellIndex] == STRATEGY_SYNC) &&
                    ( cellElSyncTracker[internalCellIndex] == FALSE_SYNC))
            {
                CELL_STRATEGY_COMP_IND_FOR_OTHER_CELLS(internalCellIndex)
            }
            cellElSyncTracker[internalCellIndex] = INVALID_SYNC;

            if( macParams_g.lowestRunningCellIndex == internalCellIndex )
            {
                macParams_g.lowestRunningCellIndex = INVALID_CELL_INDEX;

                for(cellId = 0; cellId < cellSpecificParams_g.numOfCells; cellId++)
                {
                    /* + SPR_11660 */   
                    if (CHECK_CELL_STATE(cellId))
                        /* - SPR_11660 */   
                    {
                        macParams_g.lowestRunningCellIndex = cellId;
                        break;
                    }
                }
            }
            semPost(&cellSyncSem_g);
#endif 
        }
        else
        {
            cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->cellState  = CELL_WAITING_FOR_PHY_STOP_AFTER_DELETE_REQ;
        }
        /* If the active cell tick is getting down, then chk if another cell
         * Up or not. If available update the tick */
        if (internalCellIndex == layer2CommonGetActiveCellTick())
        {
            for (ix=0; ix<MAX_NUM_CELL; ix++)
            {
                if ((cellSpecificParams_g.cellConfigAndInitParams_p[ix]) &&
                        ((CELL_PHY_RUNNING == 
                          cellSpecificParams_g.cellConfigAndInitParams_p[ix]->cellState)||
                         (CELL_PHY_RUNNING_CONFIG_RECVD == 
                          cellSpecificParams_g.cellConfigAndInitParams_p[ix]->cellState)))
                {
                    layer2CommonSetActiveCellTick(ix);
                    cellIndexMac_g = ix;
                    break;
                }
            }
            /* If no active cell found, set tick to invalid value */
            if (MAX_NUM_CELL == ix)
            {
                layer2CommonSetActiveCellTick (INVALID_CELL_INDEX);
                cellIndexMac_g = 0;
            }
        }
    }
    /*SPR 3266 Fix*/
    else
    {
        retval = MAC_SUCCESS;
        /* Review comment fix start RJ29 */
        /* + SPR_10508_10509_10847_11145 */
        if (CELL_WAIT_FOR_PHY_START == cellState)
        {
            cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->cellState  = CELL_PHY_STOP;
        }
        else if  (CELL_PHY_CONFIG >= cellState) 
            /* - SPR_10508_10509_10847_11145 */
        {
            cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->cellState  = CELL_PHY_INIT;
        }  

        LOG_MAC_MSG(RRC_PHY_DELETE_CELL_REQ_ID, LOGERROR, MAC_L1_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), PHY_MODULE_ID, msgId, cellIndex,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE, 
                DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "PHY_DELETE_CELL received Invalid");

        if( MAC_SEND_ERROR == 
                sendPhyCellRespToRRC(PHY_DELETE_CELL_CNF,
                    transactionId, retval, cellIndex))
            /* Review comment fix end RJ29 */
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
        LOG_MAC_MSG( RRC_PHY_DELETE_CELL_REQ_ID, LOGINFO, MAC_RRC_INF, 
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), PHY_MODULE_ID, msgId, cellIndex,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE,
                DEFAULT_FLOAT_VALUE, FUNCTION_NAME, 
                "sendPhyCellRespToRRC");
    }
    /*SPR 3266 Fix*/
    /* CA Changes end */
}

/****************************************************************************
 * Function Name  : processRRCPhyCellStopReq 
 * Inputs         : msgId - API Id received from RRC
 *                  msgLen - Incoming API length
 *                  msgBuf - Incoming message buffer
 *                  transactionId - Transaction Id of the incoming message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the PHY_CELL_STOP_REQ 
 *                  received from RRC and sends the response to RRC.
 ****************************************************************************/
STATIC  void processRRCPhyCellStopReq (UInt16 msgId, 
        /* +- SPR 17777 */
        UInt8 *msgBuf, UInt16 transactionId
        /* CA Changes start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *data_p = PNULL;

    /* SPR 3224 START */
    RrcCellIndex cellIndex = 0;
    /* SPR 3224 END */
    /* CA Changes start */
    InternalCellIndex ix=0;
    CellState cellState = CELL_INIT;
    MacRetType retValue = MAC_SUCCESS;
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
    InternalCellIndex  cellId = 0;
#endif
    /* CA Changes start */
    data_p = msgBuf;
    LOG_MAC_MSG( RRC_PHY_CELL_STOP_REQ_ID, LOGWARNING, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), PHY_MODULE_ID, msgId, internalCellIndex,
            DEFAULT_INT_VALUE, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE,
            DEFAULT_FLOAT_VALUE, FUNCTION_NAME, 
            "PHY_CELL_STOP_REQ received");
    data_p += API_RRC_HEADER_CELL_INDEX_OFFSET;
    cellIndex = macCommonGetRRCCellIndex(internalCellIndex);  
    /* CA Changes start */
    if (LTE_FALSE == macCommonLookupIfValidCellIndex(cellIndex))
    {
        ALARM_MSG (MAC_MODULE_ID, RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), cellIndex, internalCellIndex, 0,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"OAM_INVALID_MSG");
        return ;
    }

    cellState = 
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellState;
    /* PHY STOP.request shall be send only when PHY is running */
    /* SPR 21412 Fix Start */
    /* If Delete Request is triggered for second cell, we need to process the 
       request at MAC layer as Cell is already Stopped with Stop request for Cell 0 */
    if(CELL_PHY_RUNNING == cellState
            /* Dual Cell delete/setup start */
      )
        /* SPR 21412 Fix End */
    {
        //cell_state_changes
        /* SPR 21407 fix start */
        if (MAC_FAILURE == sendStopReqToPhy(internalCellIndex))
            /* SPR 21407 fix end */
        {
            LTE_MAC_UT_LOG(LOG_WARNING, CELL_CONF,"Error sending Stop request to PHY");
            if( MAC_SEND_ERROR == 
                    sendPhyCellRespToRRC(PHY_CELL_STOP_CNF,
                        transactionId, MAC_FAILURE, cellIndex))
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                        MAJOR_ALARM);
            }
            return ;
        }
        /* Coverity 60948 Fix Start */
        /* SPR 21412 Fix End */
        /* SPR 21407 fix end */
        /* Coverity 60948 Fix End */

        /* + Critical section changes */
        if (IS_CA_ENABLED())
        { 
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
            semWait(&cellSyncSem_g);
#endif 
            /* + SPR_10941 */
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellState = 
                CELL_WAITING_FOR_PHY_STOP_AFTER_STOP_REQ;

            /* - SPR_10941 */
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
            if (( cellElSyncTracker[!internalCellIndex] == STRATEGY_SYNC) &&
                    ( cellElSyncTracker[internalCellIndex] == FALSE_SYNC))
            {
                CELL_STRATEGY_COMP_IND_FOR_OTHER_CELLS(internalCellIndex)
            }
            cellElSyncTracker[internalCellIndex] = INVALID_SYNC;

            if( macParams_g.lowestRunningCellIndex == internalCellIndex )
            {
                macParams_g.lowestRunningCellIndex = INVALID_CELL_INDEX;

                for(cellId = 0; cellId < cellSpecificParams_g.numOfCells; cellId++)
                {
                    /* + SPR_11660 */   
                    if (CHECK_CELL_STATE(cellId))
                        /* - SPR_11660 */
                    {
                        macParams_g.lowestRunningCellIndex = cellId;
                        break;
                    }
                }
            }
            semPost(&cellSyncSem_g);
#endif  
        }
        else 
        {
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellState = 
                CELL_WAITING_FOR_PHY_STOP_AFTER_STOP_REQ;
        }

        /* If the active cell tick is getting down, then chk if another cell
         * Up or not. If available update the tick */
        if (internalCellIndex == layer2CommonGetActiveCellTick())
        {
            for (ix=0; ix<MAX_NUM_CELL; ix++)
            {
                if ((cellSpecificParams_g.cellConfigAndInitParams_p[ix]) &&
                        ((CELL_PHY_RUNNING == 
                          cellSpecificParams_g.cellConfigAndInitParams_p[ix]->cellState)||
                         (CELL_PHY_RUNNING_CONFIG_RECVD == 
                          cellSpecificParams_g.cellConfigAndInitParams_p[ix]->cellState)))
                {
                    layer2CommonSetActiveCellTick(ix);
                    cellIndexMac_g = ix;
                    break;
                }
            }
            /* If no active cell found, set tick to invalid value */
            if (MAX_NUM_CELL == ix)
            {
                layer2CommonSetActiveCellTick (INVALID_CELL_INDEX);
                cellIndexMac_g = 0;
            }
        }
        /* CA Changes end */
    }
    else  
    {
        if ( CELL_WAITING_FOR_PHY_CONFIG > cellState)
        {
            retValue = MAC_FAILURE;
        }

        if( MAC_SEND_ERROR == 
                sendPhyCellRespToRRC(PHY_CELL_STOP_CNF,
                    transactionId, retValue, cellIndex))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                    MAJOR_ALARM);
        }
        LOG_MAC_MSG(RRC_PHY_CELL_STOP_REQ_ID, LOGERROR,
                MAC_L1_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                PHY_MODULE_ID,msgId,
                internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PHY_CELL_STOP_REQ Received without Cell start");
        return ;
    }
}

/****************************************************************************
 * Function Name  : processRRCPhyCellStartReq 
 * Inputs         : msgId - API Id received from RRC
 *                  msgLen - Incoming API length
 *                  msgBuf - Incoming message buffer
 *                  transactionId - Transaction Id of the incoming message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the PHY_CELL_START_REQ 
 *                  received from RRC and sends the response to RRC.
 ****************************************************************************/
STATIC  void processRRCPhyCellStartReq( UInt16 msgId, 
        /* +- SPR 17777 */
        UInt8 *msgBuf, UInt16 transactionId
        /* CA Changes start */
        ,InternalCellIndex internalCellIndex
        /* CA changes end */
        )
{
    /* + Coverity 32757,42183 */ 
    MacRetType retval = MAC_FAILURE;
    /* - Coverity 32757,42183 */ 
    UInt8 *data_p = PNULL;

    /* SPR 3224 START */
    UInt8 cellIndex = 0;
    /* SPR 3224 END */
    data_p = msgBuf;
    LOG_MAC_MSG( RRC_PHY_CELL_START_REQ_ID, LOGWARNING, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), PHY_MODULE_ID, msgId, internalCellIndex,
            DEFAULT_INT_VALUE, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE,
            DEFAULT_FLOAT_VALUE, FUNCTION_NAME, 
            "PHY_CELL_START_REQ received");

    data_p += API_RRC_HEADER_CELL_INDEX_OFFSET;
    cellIndex = macCommonGetRRCCellIndex(internalCellIndex);  
    /* CA Changes start */
    if (LTE_FALSE == macCommonLookupIfValidCellIndex(cellIndex))
    {
        ALARM_MSG (MAC_MODULE_ID, RECV_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        LOG_MAC_MSG(RRC_MAC_MSG_CELL_INDEX_ERR, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), cellIndex, internalCellIndex, 0,
                DEFAULT_INT_VALUE, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE, 
                DEFAULT_FLOAT_VALUE, FUNCTION_NAME, "OAM_INVALID_MSG");
        /* + Coverity 72942 */
        retval =  MAC_FAILURE;
        if( MAC_SEND_ERROR == sendPhyCellRespToRRC( PHY_CELL_START_CNF,
                    transactionId, retval, cellIndex))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                    MAJOR_ALARM);
        }
        return;
        /* - Coverity 72942 */
    }

    if ((CELL_WAITING_FOR_PHY_CONFIG > cellSpecificParams_g.\
                cellConfigAndInitParams_p[internalCellIndex]->cellState)||
            (CELL_PHY_RUNNING ==  cellSpecificParams_g.\
             cellConfigAndInitParams_p[internalCellIndex]->cellState))
        /* CA Changes end */ 
    {
        retval = MAC_FAILURE;
    }
    else
    {
        retval = MAC_SUCCESS;
    }

    if( MAC_SEND_ERROR == sendPhyCellRespToRRC( PHY_CELL_START_CNF,
                transactionId, retval, cellIndex))
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                MAJOR_ALARM);
    }
    else
    {
        LOG_MAC_MSG(RRC_PHY_CELL_START_RES_ID, LOGINFO, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), PHY_MODULE_ID, msgId, cellIndex,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE,
                DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "sendPhyCellRespToRRC for Cell Config");
    }
}

/****************************************************************************
 * Function Name  : parseRRCCellConfigMsg 
 * Inputs         : msgId - API Id received from RRC
 *                  msgLen - Incoming API length
 *                  msgBuf - Incoming message buffer
 *                  destModuleId - Message to be sent to the module
 *                  transactionId - Transaction Id of the incoming message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse the Cell configuration messages
 *                  from RRC.
 ****************************************************************************/
/* CA Changes start */ 
STATIC  void parseRRCCellConfigMsg( UInt16 msgId, 
        UInt16 msgLen, UInt8 *msgBuf, UInt16 destModuleId, UInt16 transactionId,
        InternalCellIndex internalCellIndex)
    /* CA Changes end */ 
{
    UInt8 *data_p = PNULL;
    void *buf     = PNULL;
    if ( msgId == MAC_CONFIG_CELL_REQ)
    {
        LOG_MAC_MSG(MAC_CONFIG_CELL_REQ_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), destModuleId, msgId, msgLen,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE, 
                DEFAULT_FLOAT_VALUE, FUNCTION_NAME, 
                "MAC_CONFIG_CELL_REQ_RECVD");
        void *seg = PNULL;
        QSEGMENT segment1;
        seg = msgSegNext(msgBuf,0,&segment1);

        if (seg != PNULL)
        {
            data_p = segment1.base;
            buf = msgBuf;
        }
        else
        {
            lteWarning("MsgSegNext returned NULL pointer.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    msgId,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "MsgSegNext returned NULL pointer");
            /* Review comment fix end RJ13 */
            return;
        }
        /*SPR 2446 Fix Begins*/
        /* CA Changes start */ 
        parseZeroBufferRRCMsg( buf, data_p + RRC_MAC_API_HEADER_LEN,
                msgId, msgLen - RRC_MAC_API_HEADER_LEN, transactionId,internalCellIndex );
        /* CA Changes end */ 
        /*SPR 2446 Fix Ends*/
    }
    else
    {
        /* CA Changes start */
		if (
/*SPR 18132 fix start*/ 
#ifdef LTE_EMBMS_SUPPORTED
             ((msgId == MAC_AREA_CONFIG_REQUEST) ||
             (msgId == MAC_COUNTING_MSG) ||
             (msgId == MAC_RESET_SESSION_REQ))||
#endif
/*SPR 18132 fix end*/ 
            (CELL_PHY_CONFIG  < cellSpecificParams_g.\
				cellConfigAndInitParams_p[internalCellIndex]->cellState))
        {
            /* CA Changes end */ 
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "Msg ID [%d]  MsgLen [%d]", msgId, msgLen);
            /* check this API ID to specific API ID which contains data buffer */
            if ( msgId == MAC_PCCH_MSG_REQ || msgId == MAC_CCCH_MSG_REQ || 
                    msgId == MAC_BCCH_MSG_REQ || msgId == MAC_UE_CON_REJ_REQ )
            {
                void *seg = PNULL;
                QSEGMENT segment1;
                seg = msgSegNext(msgBuf,0,&segment1);

                if (seg != PNULL)
                {
                    data_p = segment1.base;
                    buf = msgBuf;
                }
                else
                {
                    lteWarning("MsgSegNext returned NULL pointer.\n");
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            msgId,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "MAC_PARSING_ERROR:MsgSegNext returned NULL pointer");
                    /* Review comment fix end RJ13 */
                    return;
                }
                /*SPR 2446 Fix Begins*/
                /* CA Changes start */  
                parseZeroBufferRRCMsg( buf, data_p + RRC_MAC_API_HEADER_LEN,
                        msgId, msgLen - RRC_MAC_API_HEADER_LEN, 
                        transactionId, internalCellIndex);
                /* CA Changes end */     
                /*SPR 2446 Fix Ends*/
            }
            else
            {
                LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                        "Msg ID [%d]  MsgLen [%d]", msgId, msgLen);

                /* CA Changes start */     
                macParseRRCMsg( msgBuf + RRC_MAC_API_HEADER_LEN, msgId,
                        msgLen - RRC_MAC_API_HEADER_LEN, transactionId, internalCellIndex);
                /* CA Changes end */     
            }
        }
        else if(msgId == MAC_DELETE_CELL_REQ)
        {
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "Msg ID [%d]  MsgLen [%d]", msgId, msgLen);
            /* CA Changes start */
            macParseRRCMsg( msgBuf + RRC_MAC_API_HEADER_LEN, msgId,
                    msgLen - RRC_MAC_API_HEADER_LEN, transactionId,internalCellIndex );
            /* CA Changes end */
        }
        /* Cell Start Stop Chg */
        else if(msgId == MAC_CELL_STOP_REQ)
        {
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "Msg ID [%d]  MsgLen [%d]", msgId, msgLen);
            /* CA Changes start */     
            macParseRRCMsg( msgBuf + RRC_MAC_API_HEADER_LEN, msgId,
                    msgLen - RRC_MAC_API_HEADER_LEN, transactionId,internalCellIndex);
            /* CA Changes end */     
        }
        /* Cell Start Stop Chg */
        else
        {
            lteWarning("Cell is not Configured");
            /* CA Changes start */
            LOG_MAC_MSG(RRC_MAC_INCORRECT_STATE_ID, LOGWARNING, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex), cellSpecificParams_g.\
                    cellConfigAndInitParams_p[internalCellIndex]->cellState, msgId, 
                    internalCellIndex,DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "OAM RRC INCORRECT STATE ");
            /* CA Changes end */
            return;	
        }
    }
}/* Cyclomatic Complexity changes - ends here */

/****************************************************************************
 * Function Name  : parseZeroBufferRRCMsg
 * Inputs         : zeroBuffer_p - Pointer to the buffer received ,
 *                  msg_p - poinetr that contains the start address of message 
 *                          to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  totalMsgLen - length of API message  
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent
 *                                  by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the RRC message and calls
 *                  the functions to parse the APIs of RRC interface.
 ****************************************************************************/
/*SPR 2446 Fix Begins*/
/* CA Changes start */ 
STATIC  void parseZeroBufferRRCMsg ( void *zeroBuffer_p,
		UInt8 *msg_p,
		UInt16 msgId,
		UInt16 totalMsgLen,
		UInt16 transactionId,
		InternalCellIndex internalCellIndex
		)
/* CA Changes end */ 
/*SPR 2446 Fix Ends*/
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,
            "msgId [%d] Total MsgLen [%d]", msgId, totalMsgLen );

	/* CA Changes start */
    CellAndInitParams *cellConfigAndInitParams_p =  cellSpecificParams_g.\
                                                    cellConfigAndInitParams_p[internalCellIndex];
	/* CA Changes end */
    UInt16 retval    = MAC_SUCCESS; /*for storing the return status */
    UInt16 remLen    = 0;
    SFNErrInd res    = {0};       
    UInt8 cellConfigReqFlag = 0;

    remLen = totalMsgLen;

    switch ( msgId )
    {
        /* For receiving T-CRNTI to be freed as a part of contention
         * resolution from RRC */
        case MAC_UE_CON_REJ_REQ:
        {
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "MAC_UE_CON_REJ_REQ");
            /* function that parses the message buffer and fill in
             * the structure */
            /* +- SPR 17777 */
            parseUEConRejReq(msg_p, zeroBuffer_p, totalMsgLen,
                    /* CA changes Start */
                    internalCellIndex
                    /* CA Changes end */
                    );
            break;
        }
        /* For receiving configuration details from RRC */
        case MAC_CONFIG_CELL_REQ:
        {   
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "MAC_CONFIG_CELL_REQ");
            /* variable of cell configuration request structure */
            ConfigCellReq configCellReq  = {0};
            /* variable of cell configuration response structure */
            ConfigCellRes configCellRes = {0};
            /* CA Changes start */
            /* SPR 21412 Fix Start */
            /* In case of CA and Dual Cell, During reconfiguration the Secondary Cell is already started and MAC is configured onwards. */
            if((cellConfigAndInitParams_p->cellState == CELL_PHY_CONFIG) 
              )
                /* SPR 21412 Fix End */
            {
                /* + SPR 10888 */
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->
                    explicitStartRequired = FALSE;
                /* - SPR 10888 */
                /* +- SPR 17777 */
                retval = parseConfigCellReq(
                        msg_p, totalMsgLen, &configCellReq,internalCellIndex);
            }
            else
            {
                retval = MAC_FAILURE;
            }
            if (MAC_SUCCESS == retval)
            {
                configCellRes.response = MAC_SUCCESS;
                /*CA Changes start  */
                initAfterCellConfig(internalCellIndex);
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->isCellConfiguredOnce = LTE_TRUE;
                /*CA Changes end  */
#ifdef UTFWK_SIMULATION
                phyCellConfigured_g = 1;
#endif
                /* Updation done for sending Cell Configuration Req to Pluggable Scheduler*/    
                /* Dual Cell delete/setup start */
                /* SPR 21412 Fix Start */
                // No need to send the Phy start in case of Second cell for Reconfiguration
                if ((FALSE == configCellReq.explicitStartRequired)
                   )
                    /* SPR 21412 Fix End */
                    /* Dual Cell delete/setup end */
                {
                    /* SPR 12285 Fix Start */
                    transactionId_g[internalCellIndex] = transactionId;
                    /* SPR 12285 Fix End */

                    /* Send start indication to PHY */
                    sendStartPhyInd(internalCellIndex);
#ifndef FLEXRAN
                    /* + SPR_10846 */
                    lteFD_SET(phyRxSockFD_g[internalCellIndex], &staticReadFds);
#endif
                    /* - SPR_10846 */
                    /* SPR 20410 start */
                    /* SPR 20410 end */
                } 
                /* + SPR_10009 */ 
                else
                {
                    configCellRes.response = MAC_SUCCESS;
                    configCellRes.transactionId = transactionId;
                    if(MAC_SEND_ERROR == 
                            sendMsgToRRC(MAC_CONFIG_CELL_CNF, &configCellRes, 
                                macCommonGetRRCCellIndex(internalCellIndex)))
                        /* CA Changes end */
                    {
                        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                                MAJOR_ALARM);
                    }
                }
                /* - SPR_10009 */ 
            }
            else
            {
                /* CA changes Start  */
                if (cellSpecificParams_g.numOfCells > MAX_NUM_CELL)
                {
                    configCellRes.errorType = MAC_RRC_ERROR_MAX_CELLS_CONFIGURED;
                }
                /* CA changes End */
                /*SPR 2262 changes start*/
                configCellRes.response = MAC_FAILURE;
                /*SPR 2262 changes stop*/

                LOG_MAC_MSG(MAC_CELL_CONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        cellConfigFailValues_g[internalCellIndex][0],cellConfigFailValues_g[internalCellIndex][1],
                        cellConfigFailValues_g[internalCellIndex][2],cellConfigFailValues_g[internalCellIndex][3],
                        cellConfigFailValues_g[internalCellIndex][4],
                        (UDouble32)cellConfigFailValues_g[internalCellIndex][5],
                        (UDouble32)cellConfigFailValues_g[internalCellIndex][6],
                        FUNCTION_NAME,"MAC_CELL_CONFIGURE_FAIL");
                /* Successful response is sent once PHY is successfully 
                 * started in case of implicit start */
                configCellRes.transactionId = transactionId;
                /* function that sends the confirmation message to RRC */
                if(MAC_SEND_ERROR == 
                        sendMsgToRRC(MAC_CONFIG_CELL_CNF, &configCellRes, 
                            macCommonGetRRCCellIndex(internalCellIndex)))
                    /* CA Changes end */
                {
                    ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                            MAJOR_ALARM);
                }
            }
            break;
        }

        /* for receiving the  paging details from RRC */
        case MAC_PCCH_MSG_REQ:
        {
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "MAC_PCCH_MSG_REQ");

					
			LOG_MAC_MSG(RRC_PCCH_INVALID_LEN_ID,LOGWARNING,MAC_RRC_INF,
					GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
					MAC_PCCH_MSG_REQ,totalMsgLen,PCCH_MSG_MIN_LEN,
					internalCellIndex,DEFAULT_INT_VALUE,
					DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
					FUNCTION_NAME,"RRC_PCCH_MSG_REQ");

                    
            if (totalMsgLen >= PCCH_MSG_MIN_LEN)
            {
                /* MAC function to process the Paging message received
                 * */
                /* CA Changes start */
                retval = recvPagingMessage(totalMsgLen,msg_p,internalCellIndex);
                /* CA Changes end */
                if (retval == MAC_SFN_ERROR)
                {
                    UInt32 sfn;
                    UInt32 sf;
                    getSFAndSFN(&sfn,&sf,internalCellIndex);
                    res.SFN = sfn;
                    res.SF = sf;
                    /* CA Changes start */
                    /* Review comment fix start RJ29 */
                    if(MAC_SEND_ERROR == sendMsgToRRC(MAC_SFN_ERR_IND,&res, 
                                macCommonGetRRCCellIndex(internalCellIndex)))
                        /* CA Changes end */
                        /* Review comment fix end RJ29 */
                    {
                        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
                    }

                }
            }
            else
            {
                lteWarning("Invalid Msglen for MAC_PCCH_MSG_REQ.\n");

                LOG_MAC_MSG(RRC_PCCH_INVALID_LEN_ID,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        MAC_PCCH_MSG_REQ,totalMsgLen,PCCH_MSG_MIN_LEN,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"RRC_PCCH_INVALID_LEN");

            }    
            break;

        }
        /* for receiving the common channel messages from RRC */
        case MAC_CCCH_MSG_REQ:
        {
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "MAC_CCCH_MSG_REQ");

					
			LOG_MAC_MSG(RRC_CCCH_LEN_ID,LOGWARNING,MAC_RRC_INF,
					GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
					MAC_CCCH_MSG_REQ,totalMsgLen,CCCH_MSG_LEN,
					internalCellIndex,DEFAULT_INT_VALUE,
					DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
					FUNCTION_NAME,"MAC_CCCH_MSG_REQ");


                    
            if (totalMsgLen >= CCCH_MSG_LEN)
            {
                /* MAC function to process the CCCH message received */
                retval = recvCCCHMessage(msg_p,zeroBuffer_p,
                        totalMsgLen, FALSE,internalCellIndex);
                /* SPR 2446 Fix Begins */
                if (retval == MAC_FAILURE)
                    /* SPR 2446 Fix Ends */
                {
                    lteWarning("Processing recvCCCHMessage failed.\n");

                    LOG_MAC_MSG(RRC_CCCH_SFN_ERR_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            MAC_CCCH_MSG_REQ,MAC_SFN_ERROR,DEFAULT_INT_VALUE,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"RRC_CCCH_SFN_ERR");

                }    

            }
            else
            {
                lteWarning("Invalid Msglen for MAC_CCCH_MSG_REQ.\n");

                LOG_MAC_MSG(RRC_CCCH_LEN_ID,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        MAC_CCCH_MSG_REQ,totalMsgLen,CCCH_MSG_LEN,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"CCCH_INVALID_LEN");

            }    
            break;
        }

        /* for receiving the broadcast messages from RRC  */
        case MAC_BCCH_MSG_REQ:
        {
            LTE_MAC_UT_LOG( LOG_INFO,PARSE_UTIL,
                    "MAC_BCCH_MSG_REQ");
            cellConfigReqFlag =0;
            if (totalMsgLen >= TAG_LEN) 
            {  
                /* CA Changes start */     
                /* MAC function to process the MIB message received */
                retval = parseAndStoreBroadcastMsg( &msg_p,
                        &remLen,
                        cellConfigReqFlag,
                        getSysFrameNumer(internalCellIndex),
                        internalCellIndex);
                /* CA Changes end */     
                if (retval == MAC_SFN_ERROR)
                {
                    UInt32 sfn;
                    UInt32 sf;
                    getSFAndSFN(&sfn,&sf,internalCellIndex);
                    res.SFN = sfn;
                    res.SF = sf;
                    /* Review comment fix start RJ29 */
                    /* CA Changes start */     
                    if(MAC_SEND_ERROR == sendMsgToRRC(MAC_SFN_ERR_IND,&res,
                                macCommonGetRRCCellIndex(internalCellIndex)))
                        /* CA Changes end */     
                        /* Review comment fix end RJ29 */
                    {
                        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
                    }
                }
            }
            else
            {
                lteWarning("Invalid Msglen for MAC_BCCH_MSG_REQ.\n");

                LOG_MAC_MSG(RRC_BCCH_INVALID_LEN_ID,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        MAC_BCCH_MSG_REQ,totalMsgLen,TAG_LEN,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"BCCH_INVALID_LEN");

            }    
            break;
        }            
    }/* end of switch */
    msgFree(zeroBuffer_p);
}/* end of readAndParseRRCMsg */

#ifdef QOS_SI_FWK_TEST
/****************************************************************************
 * Function Name  : init_arr_ue_context
 * Inputs         : filename
 *                  buffer
 *                  operation
 *                  new_msgLen
 *                  ueindex
 * Outputs        : None
 * Returns        : None
 * Description    : 
 ****************************************************************************/
UInt8 init_arr_ue_context(UChar8 *filename, UInt8 *buffer, UInt8 operation, UInt16 *new_msgLen, UInt16 ueindex)
{
    return;
}
#endif

/****************************************************************************
 * Function Name  : macParseRRCMsg
 * Inputs         : msg_p - poinetr that contains the start address of message
 *                  to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message  
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent
 *                                  by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 *            
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes the RRC message and calls
 *                  the functions to parse the APIs of RRC interface.
 ****************************************************************************/
/* CA Changes start */
 static void macParseRRCMsg( UInt8 *msg_p,
        UInt16 msgId,
        UInt16 msgLen,
        UInt16 transactionId,
        InternalCellIndex internalCellIndex
        )
/* CA Changes end */
{
#ifdef QOS_SI_FWK_TEST
    UInt8 filename[24] = {0};
    UInt8 *extension = ".txt";
    /* +- SPR 18268 */
    UInt16 ueindex;
    /* +- SPR 18268 */
    UInt8 buffer[1024];
    strCpy(filename, "ueInfo_QOS_");
#endif
    UInt16 retval     = MAC_SUCCESS; 

    LOG_UT(RRC_MAC_PARSE_MSG_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId,msgLen,transactionId,
            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"MAC_RRC_PARSE_MSG_ID");

    switch ( msgId)
    {
        /* For receiving the starting frame number from RRC */
        case MAC_SFN_REQ:
        {
            /* Cyclomatic Complexity changes - starts here */
            /* CA Changes start */
            parseMacSfnReq ( msg_p, msgId, msgLen, transactionId,internalCellIndex);
            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
        }
        break;

        /* For receiving reconfiguration information of cell specific
         * parameter from RRc */
        case MAC_RECONFIG_CELL_REQ:
        { 
            /* Cyclomatic Complexity changes - starts here */
            /* CA Changes start */
            /* +- SPR 17777 */
            parseMacReconfigCellReq ( msg_p, msgLen, 
                    transactionId,internalCellIndex );
            /* +- SPR 17777 */
            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        case MAC_DELETE_CELL_REQ:
        {
            /* SPR 23393 Changes Start */
            fprintf(stderr,"MAC CELL DELETE REQ RECEIVED FROM L3\n"); 
            /* SPR 23393 Changes End */
            /* Cyclomatic Complexity changes - starts here */ 
            /* CA Changes start */
            /* +- SPR 17777 */
            parseMacDeleteCellReq (
                    transactionId,internalCellIndex );
            /* +- SPR 17777 */
            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        /* Cell Start Stop Chg */
        case MAC_CELL_STOP_REQ:
        {
            /* SPR 23393 Changes Start */
            fprintf(stderr,"MAC CELL STOP REQ RECEIVED FROM L3\n");
            /* SPR 23393 Changes End */
            /* Cyclomatic Complexity changes - starts here */
            /* CA Changes start */
            /* +- SPR 17777 */
            parseMacCellStopReq ( msgId, 
                    transactionId,internalCellIndex);
            /* +- SPR 17777 */
            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        case MAC_CELL_START_REQ:
        {
            /* Cyclomatic Complexity changes - starts here */
            /* CA Changes start */
            /* +- SPR 17777 */
            (void)parseMacCellStartReq (
                    transactionId, internalCellIndex );
            /* +- SPR 17777 */
            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        /* Cell Start Stop Chg */

        /* Beginning of UE level messages */
        case MAC_CREATE_UE_ENTITY_REQ:
        {
            /* Cyclomatic Complexity changes - starts here */
            /* CA Changes start */
            parseMacCreateUEEntityReq ( msg_p, msgId, msgLen, 
                    transactionId, internalCellIndex);
            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        /* For receiving T-CRNTI to be freed as a part of contention
         * resolution from RRC */
        case MAC_DELETE_UE_ENTITY_REQ:
        {
            /* Cyclomatic Complexity changes - starts here */
            parseMacDeleteUEEntityReq ( msg_p, msgId, msgLen, 
                    transactionId, internalCellIndex );
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        case MAC_RECONFIGURE_UE_ENTITY_REQ:
        {
            parseMacReconfigureUEEntityReq ( msg_p, msgId, msgLen, 
                    transactionId, internalCellIndex );
        }
        break;
        case MAC_CHANGE_CRNTI_REQ:
        {
            parseMacChangeCrntiReq ( msg_p, msgId, msgLen, 
                    transactionId, internalCellIndex );
        }
        break;
        case MAC_RESET_UE_ENTITY_REQ:
        {
            parseMacResetUEEntityReq ( msg_p, msgId, msgLen, 
                    transactionId, internalCellIndex );
        }
        break;
        case MAC_HO_RACH_RESOURCE_REQ:
        {
            parseMacHORachResourceReq ( msg_p, msgId, msgLen, 
                    transactionId,internalCellIndex );
        }
        break;
        /* +- SPR 19066 */
        case MAC_HO_REL_RACH_RESOURCE_IND:
        {
            /* +- SPR 17777 */
            parseMacHORelRachResourceInd ( msg_p, msgId, msgLen, 
                    /*CA Changes start  */
                    internalCellIndex);
            /* +- SPR 17777 */
            /*CA Changes end  */
        }
        break;
        case MAC_RECONFIG_COMPLETE_IND:
        {
            UEReconfigCompInd ueReconfigCompInd = {0};
            retval = parseUEReconfigCompInd(msg_p,
                    msgLen,
                    &ueReconfigCompInd
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            if (MAC_SUCCESS == retval)
            {
                /*CA Changes start  */
                if(MAC_FAILURE == processUEReconfigCompInd(
                            &ueReconfigCompInd, internalCellIndex))
                    /*CA Changes end  */
                {
                    LOG_MAC_MSG(MAC_INAVLID_LEN_MSG_ID, LOGERROR, MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            MAC_RECONFIG_COMPLETE_IND,
                            msgLen, internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, "processUEReconfigCompInd FAILURE");
                }
            }
            break;
        }
#ifdef LTE_EMBMS_SUPPORTED
        case MAC_AREA_CONFIG_REQUEST: 
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC: MAC_AREA_CONFIG_REQUEST received\n");
                /*SPR 18282 fix*/
                parseMACAreaConfigReq(msg_p, msgLen, 
                          transactionId,internalCellIndex);
                break;
            }
        case MAC_COUNTING_MSG:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC: MAC_COUNTING_MSG received\n");
                /*SPR 18282 fix*/
                parseMACCountingMsg(msg_p, msgLen, 
                          transactionId,internalCellIndex);
                break;
            }
        case MAC_RESET_SESSION_REQ:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC: MAC_RESET_SESSION_REQ received\n");
                /*SPR 18282 fix*/
                parseAndProcessMACResetSessionReq(transactionId,internalCellIndex);
                break;
            }
#endif

        default:
        {
            LOG_MAC_MSG(RRC_MAC_INVALID_MSG_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,
                    DEFAULT_INT_VALUE,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PARSE_INVALID_MSG_ID");
            break;
        }
    } /* end of switch */
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
}/* end of macParseRRCMsg */

/******************************************************************************
 * Function Name  : parseMacSfnReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_SFN_REQ received from RRC.
 *****************************************************************************/
/* CA Changes start */
STATIC  void parseMacSfnReq( UInt8 *msg_p,
        UInt16  msgId, UInt16  msgLen, UInt16  transactionId,
        InternalCellIndex internalCellIndex )
/* CA Changes end */

{
    UInt32 sfn;
    UInt32 sf;
    SFNRes sfnRes = {0};
    /*SPR 3607 Fix Start*/
    UInt16 tag = 0;
    /*SPR 3607 Fix End*/
    /* CA Changes start */
    if(CELL_PHY_RUNNING == 
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellState)
        /* CA Changes end */
    {
        getSFAndSFN(&sfn,&sf,internalCellIndex);
        /* SIB8_Code Start */
        /* SIB8_Code_fix Start */
        sfnRes.sfn = sfn;
        sfnRes.sf  = sf;
        sfnRes.response = MAC_SUCCESS;
        sfnRes.timeStampFlag = 0;
        sfnRes.transactionId = transactionId;

        /* 
         *   function that sends the confirmation message to RRC
         */
        if(MAC_TIMESTAMP_INFO_RQST_TAG_LEN  == msgLen)
        {
            tag = LTE_GET_U16BIT(msg_p);
            if(TIMESTAMP_REQD_INFO == tag)
            {
                UInt16 tstagLen = 0;

                msg_p += TAG_FIELD_LEN;
                msgLen-= TAG_FIELD_LEN;

                tstagLen = LTE_GET_U16BIT(msg_p);

                if(MAC_TIMESTAMP_INFO_RQST_TAG_LEN != tstagLen)
                {
                    sfnRes.response = MAC_FAILURE;
                }

                msg_p += TAG_FIELD_LEN;
                msgLen-= TAG_FIELD_LEN;

                sfnRes.timeStampFlag = *msg_p;

                if(1 != sfnRes.timeStampFlag && 0 != sfnRes.timeStampFlag )
                {
                    sfnRes.response = MAC_FAILURE;
                }

                msg_p++;
                msgLen--;
            }
            else
            {
                sfnRes.response = MAC_FAILURE;
            }
        }
        /* SIB8_Code End */

        /* SIB8_Code_fix End */
        /* Review comment fix start RJ29 */
        /* CA Changes start */
        if(MAC_SEND_ERROR == sendMsgToRRC(MAC_SFN_CNF, &sfnRes,
                    macCommonGetRRCCellIndex(internalCellIndex) ))
            /* CA Changes end */
            /* Review comment fix end RJ29 */
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
    }
    else
    {
        lteWarning("MAC SFN REQ Recevied Invalid\n"); 
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                /* CA Changes start */
                msgId, /* CA Changes end */
                internalCellIndex,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid MAC SFN REQ Recevied");
        /* Review comment fix end RJ13 */
    }
}

/******************************************************************************
 * Function Name  : parseMacReconfigCellReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_RECONFIG_CELL_REQ received from RRC.
 *****************************************************************************/
/* CA Changes start */
STATIC  void parseMacReconfigCellReq( UInt8 *msg_p,
        /* +- SPR 17777 */
        UInt16  msgLen, UInt16  transactionId,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex )
/* CA Changes end */
{
    UInt16 retval     = MAC_SUCCESS; 
    ReconfigCellRes reconfigCellRes = {0}; 
    /* CA Changes start */
    CellState cellState =  cellSpecificParams_g.\
                           cellConfigAndInitParams_p[internalCellIndex]->cellState;

    if ( (CELL_WAIT_FOR_PHY_START == cellState) || 
            (CELL_PHY_RUNNING == cellState)) 
    {
        /* CA Changes start */
        retval = parseReconfigCellReq( msg_p, msgLen, internalCellIndex 
                );
    }
    else 
    {

        retval = MAC_FAILURE;
        LOG_MAC_MSG(MAC_CELL_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reConfigFailValues_g[internalCellIndex][0],reConfigFailValues_g[internalCellIndex][1],
                reConfigFailValues_g[internalCellIndex][2],reConfigFailValues_g[internalCellIndex][3],
                reConfigFailValues_g[internalCellIndex][4],
                (UDouble32)reConfigFailValues_g[internalCellIndex][5],
                (UDouble32)reConfigFailValues_g[internalCellIndex][6],
                FUNCTION_NAME,
                "MAC_CELL_RECONFIGURE received in wrong state");

    }

    /* CA Changes end */
    /* Variable for cell reconfiguration response structure */
    if (MAC_SUCCESS == retval)
    {
        /* Success log Removed */
        reconfigCellRes.response = retval;
        reconfigCellRes.transactionId = transactionId;    
        /* function that sends the confirmation message to RRC */
        /* Review comment fix start RJ29 */
        /* CA Changes start */
        if(MAC_SEND_ERROR == sendMsgToRRC(MAC_RECONFIG_CELL_CNF, 
                    &reconfigCellRes, macCommonGetRRCCellIndex(internalCellIndex)))
            /* CA Changes end */
            /* Review comment fix end RJ29 */
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                    MAJOR_ALARM);
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_CELL_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reConfigFailValues_g[internalCellIndex][0],reConfigFailValues_g[internalCellIndex][1],
                reConfigFailValues_g[internalCellIndex][2],reConfigFailValues_g[internalCellIndex][3],
                reConfigFailValues_g[internalCellIndex][4],
                (UDouble32)reConfigFailValues_g[internalCellIndex][5],
                (UDouble32)reConfigFailValues_g[internalCellIndex][6],
                FUNCTION_NAME,"MAC_CELL_RECONFIGURE Failed");
        reconfigCellRes.response = retval;
        reconfigCellRes.transactionId = transactionId;    
        if(MAC_SEND_ERROR == sendMsgToRRC(MAC_RECONFIG_CELL_CNF, 
                    &reconfigCellRes,macCommonGetRRCCellIndex(internalCellIndex) ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                    MAJOR_ALARM);
        }
    }
}

/******************************************************************************
 * Function Name  : parseMacDeleteCellReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_DELETE_CELL_REQ received from RRC.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
STATIC  void parseMacDeleteCellReq(
        UInt16  transactionId, InternalCellIndex internalCellIndex )
/* +- SPR 17777 */
/* CA Changes end */
{
    UInt16 retval     = MAC_FAILURE; 
    DeleteCellRes deleteCellRes = {0};

	/* CA Changes start */
    CellAndInitParams *cellConfigAndInitParams_p =  cellSpecificParams_g.\
                                                    cellConfigAndInitParams_p[internalCellIndex];
    /* Freeing MAC layer Memory Pools */
    if(((CELL_PHY_STOP == cellConfigAndInitParams_p->cellState) &&
                (MAC_SUCCESS == macDeleteReqFreeMemToPools(MAC_DELETE_CELL_REQ, internalCellIndex))) || 
            (CELL_WAITING_FOR_PHY_CONFIG > cellConfigAndInitParams_p->cellState) || 
            (CELL_WAIT_FOR_PHY_START == cellConfigAndInitParams_p->cellState))
        /* CA Changes end */
    {
        retval = MAC_SUCCESS;
    }

    /* Reseting MAC Layer setting */
    if (MAC_SUCCESS == retval)
    {
        deleteCellRes.response = MAC_SUCCESS;
        if ((CELL_PHY_STOP == cellConfigAndInitParams_p->cellState) ||
                (CELL_WAIT_FOR_PHY_START == cellConfigAndInitParams_p->cellState))
        {
            /* CA Changes start */
            cellConfigAndInitParams_p->cellState = CELL_PHY_INIT;
            /* CA Changes end */
        }
    }
    else
    {
        deleteCellRes.response = MAC_FAILURE;
    }
    deleteCellRes.transactionId = transactionId;

    /* MAC_DELETE_CELL_REQ response send to RRC */
    /* Review comment fix start RJ29 */
    /* CA Changes start */
    if(MAC_SEND_ERROR == sendMsgToRRC(MAC_DELETE_CELL_CNF, 
                &deleteCellRes, macCommonGetRRCCellIndex(internalCellIndex) ))
        /* CA Changes end */
        /* Review comment fix end RJ29 */
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, 
                MAJOR_ALARM);
    }
    /* + SPR_12546_12547 */
#if KPI_STATS
    /*  if all the cells in the system are deleted and periodic stats 
     *  are configured then send accumlative stats  to corresponding 
     *  modules.
     */
    checkAndSendKPIStats();
#endif
    /* - SPR_12546_12547 */ 
    /* SPR 14829 Fix Start */
    macResetStats(internalCellIndex);
    /* SPR 14829 Fix End */
}

/******************************************************************************
 * Function Name  : parseMacCellStopReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_CELL_STOP_REQ received from RRC.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
STATIC  void parseMacCellStopReq(UInt16  msgId,
        UInt16  transactionId,InternalCellIndex internalCellIndex )
/* +- SPR 17777 */
/* CA Changes end */
{
    /* CA Changes start */ 
    UInt16 retval     = MAC_FAILURE; 
    CellStopRes cellStopRes = {0};
    if((CELL_WAIT_FOR_PHY_START == cellSpecificParams_g.\
                cellConfigAndInitParams_p[internalCellIndex]->cellState) && 
            (MAC_SUCCESS == macStopReqFreeMemToPools(msgId, internalCellIndex)))
    {
        retval = MAC_SUCCESS;
    }
    /* CA Changes end */ 
    if (MAC_SUCCESS == retval)
    {
        cellStopRes.response = MAC_SUCCESS;
        /* + SPR 10888 */
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            explicitStartRequired = TRUE;
        /* - SPR 10888 */
        LOG_MAC_MSG(RRC_MAC_CELL_STOP_REQ_ID, LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reConfigFailValues_g[internalCellIndex][0],reConfigFailValues_g[internalCellIndex][1],
                reConfigFailValues_g[internalCellIndex][2],reConfigFailValues_g[internalCellIndex][3],
                reConfigFailValues_g[internalCellIndex][4],
                (UDouble32)reConfigFailValues_g[internalCellIndex][5],
                (UDouble32)reConfigFailValues_g[internalCellIndex][6],
                FUNCTION_NAME,"MAC_CELL_STOP Successful");
    }
    else
    {
        cellStopRes.response = MAC_FAILURE;
        /* CA Changes start */ 
        LOG_MAC_MSG(RRC_MAC_CELL_STOP_REQ_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reConfigFailValues_g[internalCellIndex][0],reConfigFailValues_g[internalCellIndex][1],
                reConfigFailValues_g[internalCellIndex][2],reConfigFailValues_g[internalCellIndex][3],
                reConfigFailValues_g[internalCellIndex][4],
                (UDouble32)reConfigFailValues_g[internalCellIndex][5],
                (UDouble32)reConfigFailValues_g[internalCellIndex][6], FUNCTION_NAME,
                "MAC_CELL_STOP Request Received with PHY Stop");
        /* CA Changes end */ 
    }

    cellStopRes.transactionId = transactionId;
    /* Review comment fix start RJ29 */
    /* CA Changes start */ 
    if(MAC_SEND_ERROR == sendMsgToRRC(MAC_CELL_STOP_CNF,
                &cellStopRes, macCommonGetRRCCellIndex(internalCellIndex)))
        /* CA Changes end */ 
        /* Review comment fix end RJ29 */
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                MAJOR_ALARM);
    }
    /* + SPR_12546_12547 */
#if KPI_STATS
    /*  if all the cells in the system are stopped and periodic stats 
     *  are configured then send accumlative stats  to corresponding 
     *  modules.
     */
    checkAndSendKPIStats();
#endif
    /* - SPR_12546_12547 */
    /* SPR 14829 Fix Start */
    macResetStats(internalCellIndex);
    /* SPR 14829 Fix End */
}

/******************************************************************************
 * Function Name  : parseMacCellStartReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_CELL_START_REQ received from RRC.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
STATIC  void  parseMacCellStartReq(
        UInt16  transactionId,InternalCellIndex internalCellIndex )
/* +- SPR 17777 */
{
    MacRetType retval     = MAC_FAILURE; 
    /* CA Changes end */
    CellStartRes cellStartRes = {0};
    /* CA Changes start */
            CellAndInitParams *cellConfigAndInitParams_p =  cellSpecificParams_g.\
                                                            cellConfigAndInitParams_p[internalCellIndex];
/* SPR 19288 change start */
#if defined(FLEXRAN)
/*SPR 21001 Changes start */
transactionId_g[internalCellIndex] = transactionId;
/*SPR 21001 Changes end */
#endif
/* SPR 19288 change end */

            if ((CELL_WAIT_FOR_PHY_START == cellConfigAndInitParams_p->cellState) && 
                    (MAC_SUCCESS == sendStartReqToPhy(internalCellIndex)))
            {
 #ifndef FLEXRAN           
                setFd( phyRxSockFD_g[internalCellIndex] );
 #endif
                retval = MAC_SUCCESS;
            }
            /* CA Changes end */
            if(MAC_SUCCESS != retval)
            {
                cellStartRes.response = MAC_FAILURE;
                cellStartRes.transactionId = transactionId;
                /* Review comment fix start RJ29 */
                /* CA Changes start */
                if( MAC_SEND_ERROR == sendMsgToRRC(MAC_CELL_START_CNF,
                            &cellStartRes, macCommonGetRRCCellIndex(internalCellIndex)))
                    /* CA Changes end */
                    /* Review comment fix end RJ29 */
                {
                    ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
                }               
            }
            else 
            {
/* SPR 19288 change start */
                    /* SPR 7787 fix start */
/*SPR 21001 Changes start */

#ifndef FLEXRAN
                    lteFD_SET(phyRxSockFD_g[internalCellIndex], &staticReadFds);
                    transactionId_g[internalCellIndex] = transactionId;	
		/* SPR 7787 fix end */
                    cellConfigAndInitParams_p->cellState =  CELL_WAITING_FOR_FIRST_SFI;
#endif
/*SPR 21001 Changes end */
/* SPR 19288 change end */
            }

}

/******************************************************************************
 * Function Name  : parseMacCreateUEEntityReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_CREATE_UE_ENTITY_REQ received from RRC.
 *****************************************************************************/
STATIC  void parseMacCreateUEEntityReq( UInt8 *msg_p, UInt16  msgId,
        UInt16  msgLen, UInt16  transactionId,
        InternalCellIndex internalCellIndex
        )
{
    UInt16 rrcUeIndex = 0;
    UInt16 retval     = MAC_SUCCESS; 
    UInt16 resp       = MAC_SUCCESS;
#ifdef QOS_SI_FWK_TEST
    UInt8 filename[24] = {0};
    UInt8 *extension = ".txt";
    /* +- SPR 18268 */
    UInt16 ueindex;
    /* +- SPR 18268 */
    UInt8 buffer[1024];
    strNCpy(filename, "ueInfo_QOS_",sizeof("ueInfo_QOS_"));
#endif
    /* variable for uplink UE structure */
    UeContextForUplink ulCreateUEEntityReq = {0};
    /* variable for downlink UE structure */
    UeContextForDownlink dlCreateUEEntityReq = {0};
    UEEntityCreateRes createUEEntityRes = {0};
    /* CA Changes start */
    CellConfigParams *cellParams_p =  cellSpecificParams_g.\
                                      cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;

    if ( cellParams_p->totalActiveUE < cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->initParams_p->\
            maxNumOfUeSupported)
        /* CA Changes end */
    {
#ifdef QOS_SI_FWK_TEST
        ueindex = LTE_GET_U16BIT(msg_p);
        /* +- SPR 18268 */
        UInt16 c = (ueindex + 48);
        /* +- SPR 18268 */
        strnCat(filename,&c,1);
        strnCat(filename,".txt",sizeof(".txt"));
        init_arr_ue_context(filename, msg_p, 1, &msgLen, ueindex);
#endif
        /* function that parses the message buffer and fills 
         * the structure */
        retval = parseCreateUEEntityReq( msg_p, msgLen, &ulCreateUEEntityReq,
                /* +- SPR 17777 */
                &dlCreateUEEntityReq,
                /* CA changes Start */
                internalCellIndex);
        /* CA Changes end */
        /* variable for create UE context response structure */
        if (retval == MAC_SUCCESS)
        {
            /*SPR 16855 Fix Start*/
            LP_RrcOamPendingReq rrcOamPendingReq_p =
                getMemFromPool(sizeof(RrcOamPendingReq),PNULL);

            if(PNULL == rrcOamPendingReq_p)
            {
                LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL,
                        L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__,
                        sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0,
                        __FILE__, __func__);
                ALARM_MSG( MAC_MODULE_ID,
                        MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
                createUEEntityRes.response = MAC_FAILURE;
            }
            else
            {
                rrcOamPendingReq_p->rrcUeIndex = dlCreateUEEntityReq.rrcUeIndex;
                rrcOamPendingReq_p->transactionId = transactionId;

                rrcOamPendingReq_p->dlCreateUEEntityReq = dlCreateUEEntityReq;
                rrcOamPendingReq_p->ulCreateUEEntityReq = ulCreateUEEntityReq;
                rrcOamPendingReq_p->response = retval;

                /* Call the state machine to wait for response
                 * from MAC (DL/UL) Thread */
                resp = MAC_SUCCESS;
                rrcStateMachineHandler( dlCreateUEEntityReq.ueIndex,
                        MAC_RRC_CREATE_UE_ENTITY_EV, rrcOamPendingReq_p, 
                        PNULL, PNULL, &resp, internalCellIndex);
                return;
            }
            /*SPR 16855 Fix End*/
        }
        else
        {
            resp = retval;

            LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    msgId,retval,msgLen,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"MAC_UE_CREATE_FAIL_ID");
        }
    }
    else
    {
        resp = MAC_MAX_ACTIVE_UE_REACHED_ERR;
        /* SPR 2229 changes start */
        /* SPR 16766 fix start */
        LOG_MAC_MSG( MAC_UE_CREATE_FAIL_ID, LOGWARNING, MAC_RRC_INF,
                getCurrentTick(), msgId, resp, msgLen,
                0,0, 0,0, __func__, "MaxActiveUEReached" );
        /* SPR 16766 fix end */
		rrcUeIndex = LTE_GET_U16BIT(msg_p);
        /* SPR 20684 fix start */
        dlCreateUEEntityReq.rrcUeIndex = rrcUeIndex;
        /* SPR 20684 fix end */
		/* SPR 4558 Fix Start */
		/* + Coverity 73170 */
		/* - Coverity 73170 */
		/* SPR 4558 Fix End */
		/* SPR 2229 changes end */
	}
	/*SPR 2262 changes start*/
	if (MAC_SUCCESS == resp)
	{
        /*SPR 16855 +-*/
    }
    else 
    {
        createUEEntityRes.response = MAC_FAILURE;
        /*SPR 2262 changes stop*/
    }

    createUEEntityRes.transactionId = transactionId;    
    /* Set the ue Index in response to the ueIndex received from RRC */
    dlCreateUEEntityReq.ueIndex = rrcUeIndex;
    /*function to send the confirmation message to RRC
     * */
    if(MAC_SEND_ERROR == sendToRRC( &dlCreateUEEntityReq, &ulCreateUEEntityReq,
                MAC_CREATE_UE_ENTITY_CNF, &createUEEntityRes
                /* CA changes Start */
                ,macCommonGetRRCCellIndex(internalCellIndex)
                /* CA changes End */
                /*SPR 4870 Changes Start*/ 
                ,PNULL,PNULL
                /*SPR 4870 Changes End*/ 
                ))
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
    }
    /* SPR 21484 fix start */
    if ((rrcUeIndex != INVALID_UE_ID) && (0 == setUeIdxInvalid(rrcUeIndex,UE_IDX_MAPPING_FOR_MAC)))
    {
        freeUeIdx(rrcUeIndex);
    }
    /* SPR 21484 fix end */
}

/******************************************************************************
 * Function Name  : parseMacDeleteUEEntityReq 
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_DELETE_UE_ENTITY_REQ received from RRC.
 *****************************************************************************/
STATIC  void parseMacDeleteUEEntityReq( UInt8 *msg_p, UInt16  msgId,
        UInt16  msgLen, UInt16  transactionId, InternalCellIndex internalCellIndex )
{
    UInt16 retval     = MAC_SUCCESS; 
    UInt16 resp       = MAC_SUCCESS;
    UInt16 ueIndex    = 0;

    UInt16 rrcMsgCnf = MAC_DELETE_UE_ENTITY_CNF;
    UEEntityDeleteRes deleteUEEntityRes = {0};
    /*variable for delete UE response structure*/
    if (msgLen == DELETE_UE_ENTITY_REQ_LEN)
    {
        deleteUEEntityRes.idx = LTE_GET_U16BIT(msg_p);
        /* SPR 4558 Fix Start */
        ueIndex = getUeIdxFromRrcUeIdx(deleteUEEntityRes.idx); 
        /* SPR 4558 Fix End */
        msg_p += 2; 
        /* CA changes Start */
        retval =( (validateUEIndex(ueIndex, internalCellIndex) ) && 
                (validateCellIndex(ueIndex,internalCellIndex)) );
        /* CA changes End */
        if (retval != MAC_SUCCESS)
        {
            lteWarning("Validation of ueIndex failed\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ueIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Validation of ueIndex failed");
            /* Review comment fix end RJ13 */
            /*SPR 2262 changes start*/
            resp = MAC_FAILURE;
            /*SPR 2262 changes stop*/
        }
        else
        {
            /*SPR 16855 Fix Start*/
            /* +- SPR 17777 */
            resp = deleteSplitOnUeEntity(ueIndex , transactionId,internalCellIndex ); 
            /* +- SPR 17777 */
            /*SPR 16855 Fix End*/
        }
    }
    else
    {
        /*SPR 2262 changes start*/
        resp = MAC_FAILURE;    
        /*SPR 2262 changes stop*/
    }

    LOG_MAC_MSG(RRC_DEL_UE_MSG_ID, LOGWARNING, MAC_RRC_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId, ueIndex, resp, internalCellIndex, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME, 
            "RRC_DEL_UE_MSG_ID");

    if (MAC_DELETION_PENDING != resp)
    {        
        deleteUEEntityRes.response = resp;    
        deleteUEEntityRes.transactionId = transactionId;    
        /* function that sends the confirmation message to RRC
        */
        if(MAC_SEND_ERROR == sendMsgToRRC(rrcMsgCnf, &deleteUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
    }
}

/******************************************************************************
 * Function Name  : parseMacReconfigureUEEntityReq
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_RECONFIGURE_UE_ENTITY_REQ received from RRC.
 *****************************************************************************/
STATIC  void parseMacReconfigureUEEntityReq( UInt8 *msg_p, 
        UInt16  msgId, UInt16  msgLen, UInt16  transactionId, 
        /* CA changes Start */
        InternalCellIndex internalCellIndex 
        /* CA changes End */
        )
{
    /*+COVERITY 5.3.0 - 32264*/
    UInt32 retval     = MAC_SUCCESS; 
    UInt32 resp       = MAC_SUCCESS;
    /*-COVERITY 5.3.0 - 32264*/
    /* Rel 5.3: Coverity 24640 Fix Start */
    /* variable for uplink UE structure */
    UeContextForUplink *ulCreateUEEntityReq_p = PNULL;
    /* variable for downlink UE structure */
    UeContextForDownlink *dlCreateUEEntityReq_p = PNULL;


    /* 
     ** Allocate the memory for UeContextForUplink and UeContextForDownlink
     ** for this function and should be freed in this function itself.
     */
    GET_MEM_FROM_POOL(UeContextForUplink, ulCreateUEEntityReq_p, sizeof(UeContextForUplink), PNULL);
    if (PNULL == ulCreateUEEntityReq_p)
    {
        return;
    }
    else
    {
        /*+COVERITY 5.3.0 - 55029*/
        memSet(ulCreateUEEntityReq_p,0,sizeof(UeContextForUplink));    
        /*-COVERITY 5.3.0 - 55029*/
    }
    GET_MEM_FROM_POOL(UeContextForDownlink, dlCreateUEEntityReq_p, sizeof(UeContextForDownlink), PNULL);
    if (PNULL == dlCreateUEEntityReq_p)
    {
        freeMemPool(ulCreateUEEntityReq_p);
        return;
    }
    else
    {
        /*+COVERITY 5.3.0 - 55028*/
        memSet(dlCreateUEEntityReq_p,0,sizeof(UeContextForDownlink));    
        /*-COVERITY 5.3.0 - 55028*/
    }
    /* Rel 5.3: Coverity 24640 Fix End */

    UEEntityReconfigRes reconfigUEEntityRes = {0};
#ifdef QOS_SI_FWK_TEST
    UInt8 filename[24] = {0};
    UInt8 *extension = ".txt";
    /* +- SPR 18268 */
    UInt16 ueindex;
    /* +- SPR 18268 */
    UInt8 buffer[1024];
    strNCpy(filename, "ueInfo_QOS_",sizeof("ueInfo_QOS_"));
    ueindex = LTE_GET_U16BIT(msg_p);
    /* +- SPR 18268 */
    UInt16 c = (ueindex + 48);
    /* +- SPR 18268 */
    strnCat(filename,&c,1);
    strnCat(filename,extension,sizeof(".txt"));
    init_arr_ue_context(filename, msg_p, 3, &msgLen, ueindex);
#endif
    reconfigUEEntityRes.spsCrnti = 0;
    DLReconfigUeReq *dlReconfigUeReq_p = PNULL;
    ULReconfigUeReq *ulReconfigUeReq_p = PNULL;
    RrcOamHiPrioQNode *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode *ulRrcOamHiPrioQNode_p = PNULL;
    dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
    ulRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
    /* coverity 530 CID 32741 */
    if(PNULL == ulRrcOamHiPrioQNode_p || PNULL == dlRrcOamHiPrioQNode_p)
    {
        /* Rel 5.3: Coverity 24640 Fix Start */
        freeMemPool(ulCreateUEEntityReq_p);
        freeMemPool(dlCreateUEEntityReq_p);
        /* Rel 5.3: Coverity 24640 Fix End */
        return ;
    }
    /* coverity 530 CID 32741 */
    dlRrcOamHiPrioQNode_p->rrcMsgId = msgId;
    ulRrcOamHiPrioQNode_p->rrcMsgId = msgId;
    dlRrcOamHiPrioQNode_p->eventId = MAC_HP_RECONFIG_UE_ENTITY_EV;
    ulRrcOamHiPrioQNode_p->eventId = MAC_HP_RECONFIG_UE_ENTITY_EV;
    dlReconfigUeReq_p = &dlRrcOamHiPrioQNode_p->rrcOamReqResp.dlReconfigUeReq;
    ulReconfigUeReq_p = &ulRrcOamHiPrioQNode_p->rrcOamReqResp.ulReconfigUeReq;

    /* function that parses the message buffer and fills
     * the structure */
    /* Rel 5.3: Coverity 24640 Fix Start */
    retval = parseReconfigureUEEntityReq( msg_p, msgLen, 
            ulCreateUEEntityReq_p, dlCreateUEEntityReq_p
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            /* Rel 5.3: Coverity 24640 Fix End */
            ,ulReconfigUeReq_p, dlReconfigUeReq_p
            );
    /* variable for reconfiguring UE context response structure */
    if (retval == MAC_SUCCESS)
    {
        /*SPR 16855 Fix Start*/
        LP_RrcOamPendingReq rrcOamPendingReq_p = 
            getMemFromPool(sizeof(RrcOamPendingReq),PNULL);

        if(PNULL == rrcOamPendingReq_p)
        {
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            /* Free memory for request nodes in case of failure case*/
            FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( dlRrcOamHiPrioQNode_p );
            FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( ulRrcOamHiPrioQNode_p );
            reconfigUEEntityRes.response = MAC_FAILURE;
            resp = retval;
        }
        else
        {
            /*coverity_530_55028,29*/
            memSet( rrcOamPendingReq_p, 0, sizeof(RrcOamPendingReq) );
            /*coverity_530_55028,29*/

            /* Save Parsed UE-Index */
            /* Rel 5.3: Coverity 24640 Fix Start */
            dlRrcOamHiPrioQNode_p->ueIndex = dlCreateUEEntityReq_p->ueIndex;
            ulRrcOamHiPrioQNode_p->ueIndex = dlCreateUEEntityReq_p->ueIndex;
            rrcOamPendingReq_p->transactionId = transactionId;
            rrcOamPendingReq_p->dlCreateUEEntityReq = *dlCreateUEEntityReq_p;
            rrcOamPendingReq_p->ulCreateUEEntityReq = *ulCreateUEEntityReq_p;
            /* Rel 5.3: Coverity 24640 Fix End */
            rrcOamPendingReq_p->response = retval;
            /* Coverity 42189 Fix Start*/
            rrcOamPendingReq_p->SFN = getSysFrameNumer(internalCellIndex);
            rrcOamPendingReq_p->SF = getSubFrameNumber(internalCellIndex);
            rrcOamPendingReq_p->gapPatternId = 0;
            /* Coverity 42189 Fix End */
            /*++coverity--530-42189*/
            rrcOamPendingReq_p->spsCrntiFlag = FALSE ;
            /*++coverity--530-42189*/

            /* Call the state machine to wait for response from MAC (DL/UL) 
             * Thread */
            resp = MAC_SUCCESS;
            rrcStateMachineHandler( dlCreateUEEntityReq_p->ueIndex, 
                    MAC_RRC_RECONFIG_UE_ENTITY_EV, rrcOamPendingReq_p, 
                    dlRrcOamHiPrioQNode_p, ulRrcOamHiPrioQNode_p, &resp, internalCellIndex);
            /* Rel 5.3: Coverity 24640 Fix Start */
            freeMemPool(ulCreateUEEntityReq_p);
            freeMemPool(dlCreateUEEntityReq_p);
            /* Rel 5.3: Coverity 24640 Fix End */
            return;
        }
        /*SPR 16855 Fix End*/
    }        
    else
    {
        resp = retval;
        /* Free memory for request nodes in case of failure case*/
        FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( dlRrcOamHiPrioQNode_p );
        FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( ulRrcOamHiPrioQNode_p );

        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                msgId,retval,msgLen,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
    }

    /*SPR 2262 changes start*/
    if (MAC_SUCCESS == resp)
    {
        reconfigUEEntityRes.response= MAC_SUCCESS; 
    }
    /*SPR 16855 +-*/
    else
    {
        reconfigUEEntityRes.response= MAC_FAILURE;
    }
    /* SPS_CHG */
    if((TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.enableSps) && (MAC_SUCCESS != resp))
    {
        reconfigUEEntityRes.spsCrnti = 0;    
    }
    /* SPS_CHG */
    /*SPR 2262 changes stop*/
    ueReconfigComplete = 0x55;
    reconfigUEEntityRes.transactionId = transactionId;
    /* function that sends the confirmation message to RRC
     * */
    if(MAC_SEND_ERROR == sendToRRC( dlCreateUEEntityReq_p, ulCreateUEEntityReq_p,
                MAC_RECONFIGURE_UE_ENTITY_CNF, &reconfigUEEntityRes
                /* CA changes Start */
                ,macCommonGetRRCCellIndex(internalCellIndex)
                /* CA changes End */
                ,PNULL,PNULL
                ) )
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
    }
    /* Rel 5.3: Coverity 24640 Fix Start */
    freeMemPool(ulCreateUEEntityReq_p);
    freeMemPool(dlCreateUEEntityReq_p);
    /* Rel 5.3: Coverity 24640 Fix End */
}

/******************************************************************************
 * Function Name  : parseMacChangeCrntiReq 
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_CHANGE_CRNTI_REQ received from RRC.
 *****************************************************************************/
STATIC  void parseMacChangeCrntiReq( UInt8 *msg_p, UInt16  msgId,
        UInt16  msgLen, UInt16  transactionId,InternalCellIndex internalCellIndex )
{
    UInt16 resp       = MAC_SUCCESS;
    ChangeCrntiRespInfo changeCrntiResp = {0};
    ChangeCrntiInfo   changeCrntiInfo = {0};


    if (MAC_CHANGE_CRNTI_REQ_LEN == msgLen)
    {
        /* Note : RRC sends ueIndex with 4-MSB set to UECC and rest 12bit contains UeIndex.
         * So we need to skip 4 MSB for ueIndex processing and send responce to RRC including 4-MSB */ 
        changeCrntiResp.ueIndex =  LTE_GET_U16BIT(msg_p);
        /* SPR 4558 Fix Start */
        changeCrntiInfo.ueIndex =  getUeIdxFromRrcUeIdx(changeCrntiResp.ueIndex);
        /* SPR 4558 Fix End */
        msg_p += 2;
        if (MAC_SUCCESS == validateUEIndex(changeCrntiInfo.ueIndex,
                    /* CA changes Start */
                    internalCellIndex
                    /* CA Changes end */
                    ))
        {
            changeCrntiInfo.oldCrnti = LTE_GET_U16BIT(msg_p);
            msg_p += 2;
            changeCrntiInfo.newCrnti = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            /* SPR 9385 changes start*/
            /* Calling function to reset UE entity, 
             * further handling of changing crnti will be done after reset.
             * Here, sending MAC_RESET_UE_ENTITY_REQ as msgId for handling
             * state machine for RESET UE */
            changeCrntiAndResetSplitUeEntity( changeCrntiInfo.ueIndex, 
                    MAC_RESET_UE_ENTITY_REQ, transactionId,&changeCrntiInfo,
                    internalCellIndex);
            return;
            /* SPR 9385 changes end*/
        }
        else
        {
            resp = MAC_INVALID_UE_ID;
            LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,changeCrntiResp.ueIndex,resp,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"MAC_INVALID_UE_ID");
        }
    }
    else
    {
        resp = MAC_SYNTAX_ERROR;
    }

    changeCrntiResp.resp = resp;
    changeCrntiResp.transactionId = transactionId;
    /* Send Msg to RRC */
    if ( MAC_SUCCESS != resp )
    {
        if(MAC_SEND_ERROR  ==
                sendMsgToRRC(MAC_CHANGE_CRNTI_CNF, &changeCrntiResp, 
                    /* CA changes Start */
                    macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ))
        {
            ALARM_MSG(MAC_MODULE_ID,
                    SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
        }
    }   
    /* SPR 11800 fix start */
}

/******************************************************************************
 * Function Name  : parseMacResetUEEntityReq 
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_RESET_UE_ENTITY_REQ received from RRC.
 *****************************************************************************/
STATIC  void parseMacResetUEEntityReq ( UInt8 *msg_p, UInt16 msgId, 
        UInt16 msgLen, UInt16 transactionId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    /*+COVERITY 5.3.0 - 32261*/
    UInt32 resp       = MAC_SUCCESS;
    /*-COVERITY 5.3.0 - 32261*/
    UInt16 ueIndex    = 0;
    UInt8 scellRelFlag = 0;

    UEEntityResetRes resetUEEntityRes = {0};
    /* CA changes Start */
    if ( (RESET_UE_ENTITY_REQ_LEN == msgLen) || (RESET_CA_UE_ENTITY_REQ_LEN == msgLen) )
    {
        /* CA changes End */
        /* Note : RRC sends ueIndex with 4-MSB set to UECC and rest 12bit contains UeIndex.
         * So we need to skip 4 MSB for ueIndex processing and send responce to RRC including 4-MSB */ 
        resetUEEntityRes.idx = LTE_GET_U16BIT(msg_p);
        /* SPR 4558 Fix Start */
        ueIndex = getUeIdxFromRrcUeIdx(resetUEEntityRes.idx);
        /* SPR 4558 Fix End */
        msg_p += 2;

        /* CA changes Start */
        if ( RESET_CA_UE_ENTITY_REQ_LEN == msgLen)
        {
            UInt16 tag = 0, tagLen = 0;
            tag = LTE_GET_U16BIT(msg_p);
            if ( SCELL_REL_FLAG == tag)
            {
                msg_p += U16BIT_LEN;
                tagLen = LTE_GET_U16BIT(msg_p);

                if((RESET_CA_UE_ENTITY_REQ_LEN-RESET_UE_ENTITY_REQ_LEN)!=tagLen)
                {
                    LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            LINE_NUMBER,ueIndex,RF_PARAMS,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,
                            "RESET_CA_UE_ENTITY_REQ_INVALID_LENGTH");
                    resp = MAC_SYNTAX_ERROR;
                }
                else
                {
                    msg_p += U16BIT_LEN;
                    scellRelFlag = *msg_p;
                    if ( (MAC_SUCCESS != validateUEIndex(ueIndex
                                    /* CA changes Start */
                                    , internalCellIndex) ||
                                /* CA Changes end */
                                (MAC_SUCCESS!=macValidateScellRel(scellRelFlag))))
                    {
                        resp = MAC_INVALID_UE_ID;
                        LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                msgId,ueIndex,resp,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,"RRC_RESET_UE_ENTITY_MSG_ID");
                    }
                    else
                    {
                        LOG_MAC_MSG(MAC_RESET_UE_ENTITY_REQ_ID,LOGINFO,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                ueIndex,
                                internalCellIndex, DEFAULT_INT_VALUE,
                                DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME, "MAC_RESET_UE_ENTITY_REQ Recived");

                        resp = resetSplitUeEntity( ueIndex, msgId, transactionId
                                ,scellRelFlag, internalCellIndex ); 
                    }

                }
            }
            else 
            {
                resp = MAC_SYNTAX_ERROR;
            }
        }
        /* CA changes End */

        else
        {
            if (MAC_SUCCESS != validateUEIndex(ueIndex
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ))
            {
                resp = MAC_INVALID_UE_ID;
                LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,ueIndex,resp,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"RRC_RESET_UE_ENTITY_MSG_ID");
            }
            else
            {
                /* Review comment fix start MAC_RESET_1 */
                LOG_MAC_MSG(MAC_RESET_UE_ENTITY_REQ_ID,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),ueIndex,
                        internalCellIndex, DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_RESET_UE_ENTITY_REQ Recived");
                /* Review comment fix end MAC_RESET_1 */
                resp = resetSplitUeEntity( ueIndex, msgId, transactionId,
                        scellRelFlag, internalCellIndex ); 
            }
        }
    }
    else 
    {
        resp = MAC_SYNTAX_ERROR;
    }

    if (MAC_RESET_PENDING != resp)
    {
        resetUEEntityRes.response = resp;
        resetUEEntityRes.transactionId = transactionId;
        /* Review comment fix start MAC_RESET_2 */
        LOG_MAC_MSG(MAC_RESET_UE_ENTITY_FAILURE_CNF,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),ueIndex,transactionId, 
                resp, 
                internalCellIndex, DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_RESET_UE_ENTITY_FAILURE_CNF");
        /* Review comment fix end MAC_RESET_2 */
        /* function that sends the confirmation message to  RRC
        */
        if( MAC_SEND_ERROR == sendMsgToRRC( MAC_RESET_UE_ENTITY_CNF,
                    &resetUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ) )
        {
            ALARM_MSG(MAC_MODULE_ID,
                    SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
        }
    }
}

/******************************************************************************
 * Function Name  : parseMacHORachResourceReq 
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_HO_RACH_RESOURCE_REQ received from RRC.
 *****************************************************************************/
STATIC  void parseMacHORachResourceReq( UInt8 *msg_p, UInt16 msgId,
        UInt16 msgLen, UInt16 transactionId, InternalCellIndex internalCellIndex )
{
    UInt16 resp       = MAC_SUCCESS;

	/*SPR 3607 Fix Start*/
	UInt16 tag = 0;
	UInt16 hoTypeFlag = 0;
	/*SPR 3607 Fix End*/
	HORachResourceRespInfo hoRachResourceResp = {0};
    /* SPR 21483  fix start */
    /* code removed */
    /* variable rachResourceInfo declaration is removed */
    /* SPR 21483 fix end */

    RRCRachHOInterfaceNode *rrcRachHOInterfaceNode_p = PNULL;

    /* SPR 21484 fix start */    
    UInt16 UeIndex  = INVALID_UE_ID; 
    /* SPR 21484 fix end */

	if (MAC_HO_RACH_RESOURCE_REQ_LEN == msgLen)
	{
        /* SPR 21484 fix start */ 
        /* UeIndex declaration moved outside if clause */
        UeIndex = LTE_GET_U16BIT(msg_p);
		hoRachResourceResp.ueIndex = UeIndex;        
        /* SPR 21484 fix end */ 
		/* Note : RRC sends ueIndex with 4-MSB set to UECC and rest 12bit contains UeIndex.
		 * So we need to skip 4 MSB for ueIndex processing and send responce to RRC including 4-MSB */
		/* SPR 4558 Fix Start */
		/* SPR 4849 Fix Start */
		UInt16 tmpUeIndex = getUeIdxFromRrcUeIdx(UeIndex);
		/* SPR 4558 Fix End */
		if (INVALID_UE_ID == tmpUeIndex)
		{
			UeIndex = allocateUeIdxFromRrcUeIdx(UeIndex);
			/* SPR 4864 fix start */
			if (MAX_UE_SUPPORTED > UeIndex) 
			{
				setUeIdxValid(UeIndex, UE_IDX_MAPPING_FOR_MAC);
			}
			/* SPR 4864 fix end */
		}
		/* SPR 4849 Fix End */
		if (MAC_SUCCESS != validateUEIndex(UeIndex
					/* CA changes Start */
					, internalCellIndex
					/* CA Changes end */
					))
		{
			resp = MAC_INVALID_UE_ID;
			LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGWARNING,MAC_RRC_INF,
					GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,
					UeIndex,
					resp,internalCellIndex,DEFAULT_INT_VALUE,
					DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
					FUNCTION_NAME,"Invalid Ue Idx In HORachResReq");
		}
		else
		{
            /*SPR 16855 Fix Start*/
            do
            {
                RachInterfaceQueueNode *rachMgrRrcOamHiPrioQNode_p = PNULL;
                GET_MEM_FROM_POOL(RRCRachHOInterfaceNode,
                        rrcRachHOInterfaceNode_p,
                        sizeof(RRCRachHOInterfaceNode),
                        PNULL);
                /* + Coverity 24466 */
                if( PNULL == rrcRachHOInterfaceNode_p )
                {
                    resp = MAC_FAILURE;
                    break;
                }
                /* - Coverity 24466 */
                rrcRachHOInterfaceNode_p->ueIndex = UeIndex;
                rachMgrRrcOamHiPrioQNode_p = (RachInterfaceQueueNode *)getInitializedRefPointer(
                        RACH_MGRQ);
                /* coverity 530 CID 32740 */
                if( PNULL == rachMgrRrcOamHiPrioQNode_p )
                    /* coverity 530 CID 32740 */
                {
                    /* Free allocated memory */
                    freeMemPool( rrcRachHOInterfaceNode_p );
                    rrcRachHOInterfaceNode_p = PNULL;
                    resp = MAC_FAILURE;
                    break;
                }
                rachMgrRrcOamHiPrioQNode_p->ueIndex = UeIndex;
                rachMgrRrcOamHiPrioQNode_p->msgType = HO_RACH_REQ;
                rachMgrRrcOamHiPrioQNode_p->rachInterface_p = rrcRachHOInterfaceNode_p;
                rachMgrRrcOamHiPrioQNode_p->eventId = MAC_HP_HO_RACH_RESOURCE_EV;

                LP_RrcOamPendingReq rrcOamPendingReq_p = 
                    getMemFromPool(sizeof(RrcOamPendingReq),PNULL);

                if(PNULL == rrcOamPendingReq_p)
                {
                    LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                            L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                            sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
                            __FILE__, __func__);
                    ALARM_MSG( MAC_MODULE_ID, 
                            MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
                    /* Free allocated memories */
                    freeMemPool( rrcRachHOInterfaceNode_p );                    
                    rrcRachHOInterfaceNode_p = PNULL;
                    freeMemPool( rachMgrRrcOamHiPrioQNode_p );
                    rachMgrRrcOamHiPrioQNode_p = PNULL;	
                    resp = MAC_FAILURE;
                    break;
                }
                /* + Coverity 40418 */
                memSet( rrcOamPendingReq_p, 0, sizeof(RrcOamPendingReq) );
                rrcOamPendingReq_p->rrcUeIndex = 
                    getRrcUeIdxFromUeIdx(UeIndex);
                rrcOamPendingReq_p->response = MAC_SUCCESS;
                /* - Coverity 40418 */
                rrcOamPendingReq_p->transactionId = transactionId;
                /* Call the state machine to wait for response from MAC
                 * (DL/UL) Thread */
                resp = MAC_SUCCESS;
                rrcStateMachineHandler( UeIndex, 
                        MAC_RRC_HO_RACH_RESOURCE_EV, rrcOamPendingReq_p, 
                        PNULL, rachMgrRrcOamHiPrioQNode_p, &resp, internalCellIndex);
                return;
            }while( 0 );
        }
        /*SPR 16855 Fix End*/
        if (MAC_SUCCESS == resp)
        {
        }
        else
        {
            LOG_MAC_MSG(RRC_HO_RACH_RESOURCE_REQ_MSG_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,
                    UeIndex,resp,
                    hoRachResourceResp.tcrnti,
                    hoRachResourceResp.preambleIdx,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"CONN_HANDOVER_ENTITY_FAILURE");

            /* SPR 21483 fix start */
            /* Code Removed */
            /* As Preamble is not allocated yet so no need to allocate memory */
            /* SPR 21483 Fix end */
		}
	}
	/* SPR 3607 Fix Start*/
	else if (MAC_HO_RACH_RESOURCE_OPT_LEN == msgLen)
	{
        /* SPR 21484 fix start */ 
        /* UeIndex declaration moved outside if clause */
        UeIndex = LTE_GET_U16BIT(msg_p);
		hoRachResourceResp.ueIndex = UeIndex;
        /* SPR 21484 fix end  */ 
		/* SPR 4558 Fix Start */
		UeIndex = getUeIdxFromRrcUeIdx(UeIndex); 
		/* SPR 4558 Fix End */
		msg_p+=2;
		tag = LTE_GET_U16BIT(msg_p);
		msg_p += 2;
		/*  tagLen = LTE_GET_U16BIT(msg_p);TDD Warning Fix */
		msg_p += 2;
		if(tag == INTRA_ENB_HO_REQ)
		{
			hoTypeFlag = (UInt8)*msg_p++;
		}
		else
		{
			resp = MAC_SYNTAX_ERROR;
            /* SPR 21484 fix start */
            /* return statement removed */
            /* SPR 21484 fix end */
		}
        /* SPR 21484 fix start */
        if(MAC_SYNTAX_ERROR != resp)
        {
		if (MAC_SUCCESS != validateUEIndex(UeIndex
					/* CA changes Start */
					,internalCellIndex
					/* CA Changes end */
					))
		{
			resp = MAC_INVALID_UE_ID;
			LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGWARNING,MAC_RRC_INF,
					GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,
					UeIndex,
					resp,internalCellIndex,DEFAULT_INT_VALUE,
					DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
					FUNCTION_NAME,"Invalid Ue Idx In HORachResReq");
		}
		else if (INTRA_ENB_HO_REQUESTED == hoTypeFlag)
		{
			/* SPR 8379 changes start */
            /*SPR 16855 Fix Start*/
			do
			{
				RachInterfaceQueueNode *rachMgrRrcOamHiPrioQNode_p = PNULL;
				GET_MEM_FROM_POOL(RRCRachHOInterfaceNode,
						rrcRachHOInterfaceNode_p,
						sizeof(RRCRachHOInterfaceNode),
						PNULL);
				if( PNULL == rrcRachHOInterfaceNode_p )
				{
					resp = MAC_FAILURE;
					break;
				}
				rrcRachHOInterfaceNode_p->ueIndex = UeIndex;
				rachMgrRrcOamHiPrioQNode_p = (RachInterfaceQueueNode *)getInitializedRefPointer(
						RACH_MGRQ);
				if( PNULL == rachMgrRrcOamHiPrioQNode_p )
				{
					/* Free allocated memory */
					freeMemPool( rrcRachHOInterfaceNode_p );
					resp = MAC_FAILURE;
					break;
				}
				rachMgrRrcOamHiPrioQNode_p->ueIndex = UeIndex;
				rachMgrRrcOamHiPrioQNode_p->msgType = INTRA_HO_RACH_REQ;
				rachMgrRrcOamHiPrioQNode_p->rachInterface_p = rrcRachHOInterfaceNode_p;
				rachMgrRrcOamHiPrioQNode_p->eventId = MAC_HP_INTRA_HO_RACH_RESOURCE_EV;

				LP_RrcOamPendingReq rrcOamPendingReq_p = 
					getMemFromPool(sizeof(RrcOamPendingReq),PNULL);

				if(PNULL == rrcOamPendingReq_p)
				{
					LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
							L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
							sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
							__FILE__, __func__);
					ALARM_MSG( MAC_MODULE_ID, 
							MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
					/* Free allocated memories */
					freeMemPool( rrcRachHOInterfaceNode_p );                    
                    rrcRachHOInterfaceNode_p = PNULL;	
                    freeMemPool( rachMgrRrcOamHiPrioQNode_p );
                    rachMgrRrcOamHiPrioQNode_p = PNULL;	
					resp = MAC_FAILURE;
					break;
				}
				memSet( rrcOamPendingReq_p, 0, sizeof(RrcOamPendingReq) );
				rrcOamPendingReq_p->rrcUeIndex = 
					getRrcUeIdxFromUeIdx(UeIndex);
				rrcOamPendingReq_p->response = MAC_SUCCESS;
				rrcOamPendingReq_p->transactionId = transactionId;
				/* Call the state machine to wait for response from MAC
				 * (DL/UL) Thread */
				resp = MAC_SUCCESS;
				rrcStateMachineHandler( UeIndex, 
						MAC_RRC_HO_RACH_RESOURCE_EV, rrcOamPendingReq_p, 
						PNULL, rachMgrRrcOamHiPrioQNode_p, &resp, internalCellIndex);
				return;
			}while( 0 );
            /*SPR 16855 Fix End*/
		}
		else
		{
			resp = MAC_SYNTAX_ERROR;
		}
	}
        /* SPR 21484 fix end */
    }
	/* SPR 3607 Fix End*/
	else
	{
		resp = MAC_SYNTAX_ERROR;
	}
	hoRachResourceResp.transactionId = transactionId;
	hoRachResourceResp.resp = resp;
	/* Send Msg to RRC */
	if(MAC_SEND_ERROR  ==
			sendMsgToRRC(MAC_HO_RACH_RESOURCE_RESP,
				&hoRachResourceResp
				/* CA changes Start */
				,macCommonGetRRCCellIndex(internalCellIndex)
				/* CA Changes end */
				))
	{
		ALARM_MSG(MAC_MODULE_ID,
				SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
	}
    /* SPR 21484 fix start */
    if ((UeIndex != INVALID_UE_ID) && (0 == setUeIdxInvalid(UeIndex,UE_IDX_MAPPING_FOR_MAC)))
    {
        freeUeIdx(UeIndex);
    }
    /* SPR 21484 fix end */
}

/* +- SPR 19066 */

/* SPR 16583 fix start */
/******************************************************************************
 * Function Name  : processHoRelRachResourceInd 
 * Inputs         : ueIndex
 *                  crnti
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the message for HP thread and passes
 *                  to state machine for MAC_HO_REL_RACH_RESOURCE_IND received
 *                  from RRC.
 *****************************************************************************/
void processHoRelRachResourceInd( UInt16 ueIndex, UInt16 crnti,InternalCellIndex internalCellIndex )
{
    MacRetType resp = MAC_SUCCESS;
    RRCRachInterfaceNode *rrcRachInterfaceNode_p = PNULL;

    /* This procedure is done in HP/LP thread because in some HO failure scenarios
     * it is possible that HO RACH REQ is in progress and HO RACH REL REQ is 
     * received from L3 in between leading to issue */
    do
    {
        RachInterfaceQueueNode *rachMgrRrcOamHiPrioQNode_p = PNULL;
        GET_MEM_FROM_POOL(RRCRachInterfaceNode,
                rrcRachInterfaceNode_p,
                sizeof(RRCRachInterfaceNode), PNULL);
        if( PNULL == rrcRachInterfaceNode_p )
        {
            break;
        }
        rrcRachInterfaceNode_p->ueIndex = ueIndex;
        rrcRachInterfaceNode_p->rnti = crnti;
        rachMgrRrcOamHiPrioQNode_p = (RachInterfaceQueueNode *)getInitializedRefPointer(
                RACH_MGRQ);
        if( PNULL == rachMgrRrcOamHiPrioQNode_p )
        {
            /* Free allocated memory */
            freeMemPool( rrcRachInterfaceNode_p );
            rrcRachInterfaceNode_p = PNULL;
            break;
        }
        rachMgrRrcOamHiPrioQNode_p->ueIndex = ueIndex;
        rachMgrRrcOamHiPrioQNode_p->msgType = HO_RACH_REL_IND;
        rachMgrRrcOamHiPrioQNode_p->rachInterface_p = rrcRachInterfaceNode_p;
        rachMgrRrcOamHiPrioQNode_p->eventId = MAC_HP_HO_REL_RACH_RESOURCE_EV;

        LP_RrcOamPendingReq rrcOamPendingReq_p = 
            getMemFromPool(sizeof(RrcOamPendingReq),PNULL);

        if(PNULL == rrcOamPendingReq_p)
        {
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, getCurrentTick(), __LINE__, 
                    sizeof(RrcOamPendingReq), 0,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            /* Free allocated memories */
            freeMemPool( rrcRachInterfaceNode_p );                    
            rrcRachInterfaceNode_p = PNULL;
            freeMemPool( rachMgrRrcOamHiPrioQNode_p );
            rachMgrRrcOamHiPrioQNode_p = PNULL;
            break;
        }
        memSet( rrcOamPendingReq_p, 0, sizeof(RrcOamPendingReq) );

        rrcOamPendingReq_p->response = MAC_SUCCESS;
        /* Call the state machine to wait for response from MAC
         * (DL/UL) Thread */
        rrcStateMachineHandler( ueIndex, 
                MAC_RRC_HO_REL_RACH_RESOURCE_EV, rrcOamPendingReq_p, 
                PNULL, rachMgrRrcOamHiPrioQNode_p, &resp,internalCellIndex);
        return;
    }while( 0 );
}
/* SPR 16583 fix end */
/******************************************************************************
 * Function Name  : parseMacHORelRachResourceInd 
 * Inputs         : msg_p - Incoming message pointer to be parsed.
 *                  msgId  - unique id that identifies an API
 *                  msgLen - length of API message
 *                  transactionId - random id generated which should be same for 
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function parse and processes the API 
 *                  MAC_HO_REL_RACH_RESOURCE_IND received from RRC.
 *****************************************************************************/
STATIC  void parseMacHORelRachResourceInd( UInt8 *msg_p, UInt16 msgId,
        /* +- SPR 17777 */
        UInt16 msgLen
        /* +- SPR 17777 */
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    UInt16 ueIndex    = 0;
    UInt16 crnti = 0;
    /* CA Changes start */
    InitParams *initParams_p = cellSpecificParams_g.\
                               cellConfigAndInitParams_p[internalCellIndex]->initParams_p;
    /* CA Changes end */
    if (msgLen >= MAC_HO_REL_RACH_RESOURCE_IND_MIN_LEN)
    {
        ueIndex = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        /* SPR 4558 Fix Start */
        ueIndex = getUeIdxFromRrcUeIdx(ueIndex);
        /* SPR 4558 Fix End */
        if (MAC_SUCCESS == ((validateUEIndex(ueIndex
                            /* CA changes Start */
                            ,internalCellIndex
                            /* CA Changes end */
                            )) && (validateCellIndex(ueIndex ,internalCellIndex))))
        {
            if ((msgLen - MAC_HO_REL_RACH_RESOURCE_IND_MIN_LEN) ==
                    MAC_HO_REL_RACH_RES_IND_CRNTI_TAG_LEN)
            {
                if (CRNTI_INFO == LTE_GET_U16BIT(msg_p))
                {
                    msg_p += 2;
                    if (LTE_GET_U16BIT(msg_p) ==
                            MAC_HO_REL_RACH_RES_IND_CRNTI_TAG_LEN)
                    {
                        msg_p += 2;
                        crnti = LTE_GET_U16BIT(msg_p);
                        if ( (crnti < initParams_p->lowerRNTIBound) || 
                                (crnti > initParams_p->upperRNTIBound) )
                        {
                            LOG_MAC_MSG( RRC_HO_INVALID_CRNTI, LOGWARNING, 
                                    MAC_RRC_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), 
                                    msgId,ueIndex, crnti, initParams_p->lowerRNTIBound,
                                    initParams_p->upperRNTIBound, DEFAULT_FLOAT_VALUE,
                                    DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                                    "INVALID_CRNTI");
                        }
                        else
                        {
                            /* SPR 16583 fix start */
                            processHoRelRachResourceInd( ueIndex, crnti,internalCellIndex);
                            /* SPR 16583 fix end */

                            LOG_MAC_MSG(RRC_HO_REL_RACH_RESOURCE_IND,
                                    LOGWARNING,MAC_RRC_INF,
                                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,ueIndex,
                                    MAC_SUCCESS,
                                    crnti,internalCellIndex,
                                    DEFAULT_FLOAT_VALUE,
                                    DEFAULT_FLOAT_VALUE,
                                    FUNCTION_NAME,
                                    "RRC_HO_REL_RACH_RESOURCE_IND");
                        }
                    }
                }
            }
            else
            {

                /* SPR 16583 fix start */
                processHoRelRachResourceInd( ueIndex, INVALID_CRNTI,internalCellIndex);
                /* SPR 16583 fix end */
                LOG_MAC_MSG(RRC_HO_REL_RACH_RESOURCE_IND,LOGWARNING,
                        MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,ueIndex,MAC_SUCCESS,
                        crnti,internalCellIndex,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "RRC_HO_REL_RACH_RESOURCE_IND");
            }
        }
        else
        {
            LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGDEBUG,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,ueIndex,
                    MAC_INVALID_UE_ID,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"InvalidUEId in HO Rach Rel Ind");
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_INAVLID_LEN_MSG_ID, LOGERROR, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId, msgLen, internalCellIndex,
                DEFAULT_INT_VALUE, DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "REL_RESOURCE_IND_INVALID_MSG_LEN");
    }
}

/****************************************************************************
 * Function Name  : parseUEConRejReq
 * Inputs         : current_p,
 *                  zeroBuff_p,
 *                  totalMsgLen - length of API message,
 *                  transactionId - random id generated which should be same for
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC for configuration.
 ****************************************************************************/
STATIC  MacRetType parseUEConRejReq( UInt8 *current_p,
        void * zeroBuff_p,
        UInt16 totalMsgLen,
        /* +- SPR 17777 */
        /* CA changes Start */
        InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    RNTIInfo *rntiInfo_p = PNULL;
    UInt16   tcrnti = 0;
    /* Rel 5.3: Coverity 32239 Fix Start */
    MacRetType retval = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32239 Fix End */

	//fix bug that cause crash
#if 0
	LOG_MAC_MSG(RRC_UE_CONREJ_MSG_ID,LOGWARNING,MAC_RRC_INF,
			GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
			tcrnti,rntiInfo_p->rntiFlag,rntiInfo_p->index,
			internalCellIndex,DEFAULT_INT_VALUE,
			DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
			FUNCTION_NAME,"UE_CONREJ_MSG");
#else
	LOG_MAC_MSG(RRC_UE_CONREJ_MSG_ID,LOGWARNING,MAC_RRC_INF,
			GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
			tcrnti,0,0,
			internalCellIndex,DEFAULT_INT_VALUE,
			DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
			FUNCTION_NAME,"UE_CONREJ_MSG");
#endif

    if ( totalMsgLen < UE_CON_REJ_REQ_LEN )
    {
        lteWarning("Mandatory Fileds Missing in UE_CON_REJ_REQ.\n");

        LOG_MAC_MSG(RRC_UE_CONREJ_INVALID_LEN_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_UE_CON_REJ_REQ,totalMsgLen,UE_CON_REJ_REQ_LEN,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"UE_CONREJ_INVALID_LEN");


        return MAC_FAILURE;
    }

    tcrnti = LTE_GET_U16BIT(current_p);

    retval = recvCCCHMessage(current_p, 
            zeroBuff_p, 
            totalMsgLen,
            TRUE,
            internalCellIndex);

    if (MAC_SUCCESS == retval)
    {
        /*CA Changes start  */
        rntiInfo_p = getUeIdxFromRNTIMap(tcrnti, internalCellIndex);
        /*CA Changes end  */
        /* SPR#706 Changes Start */
        if(rntiInfo_p == PNULL)
        {
            LTE_MAC_UT_LOG(LOG_WARNING,PARSE_UTIL," Can't resolve Context For %d crnti",tcrnti);
            return MAC_FAILURE;
        }
        /* SPR#706 Changes End */ 
#if 0
        /*If the falg is TCRNTI put entry with flag as TCRNTI
         *If the falg is CRNTI UE conf Mgr will put entry when 
         *delete UE request received
         */
        if (TCRNTI == rntiInfo_p->rntiFlag)
        {
            /* MAC function to process UE-CON-REJ data */

            LOG_MAC_MSG(RRC_UE_CONREJ_MSG_ID,LOGDEBUG,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tcrnti,rntiInfo_p->rntiFlag,rntiInfo_p->index,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"UE_CONREJ_MSG");


        }
#endif
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return retval;
}

/****************************************************************************
 * Function Name  : parseReconfigCellReq
 * Inputs         : msg_p - pointer that address of data read from socket,
 *                  totalMsgLen - length of API message,
 *                  internalCellIndex - cell index used at MAC
 *                  transactionId - random id generated which should be same for
 *                                  request sent by RRC layer and response sent by MAC layer.
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC for configuration.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType parseReconfigCellReq ( UInt8 *msg_p,
		UInt16 totalMsgLen,
		InternalCellIndex internalCellIndex
		)
/* CA Changes end*/
{
    UInt16 sfn    = 0;
    UInt8  sf     = 0;
    UInt16 remLen = 0;
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
/*Coverity Id 116262 Fix Start*/
/*Coverity Id 116262 Fix Stop*/

#ifdef LOG_PRINT_ENABLED
    reConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = NO_FAIL;
#endif        

    remLen = totalMsgLen;

    /* Populate the target SFN/SF */    

    if ( totalMsgLen >= RECONFIG_CELL_MIN_LEN )
    {
        sfn = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        sf = (UInt8)*msg_p;
        msg_p += 1;
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_MANDATORY_RECONFIG_CELL_REQ_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                sfn,
                sf,
                internalCellIndex,
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_MANDATORY_RECONFIG_CELL_REQ_PARAM");
        /* Review comment fix end SYNC_LOSS_1*/


        remLen -= RECONFIG_CELL_MIN_LEN;
    }
    else
    {
        remLen -= RECONFIG_CELL_MIN_LEN;
        lteWarning("Mandatory fields Misssing\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                totalMsgLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory fields Misssing ");
        /* Review comment fix end RJ13 */

#ifdef LOG_PRINT_ENABLED
        reConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_TOTAL_MSG_LEN;
        reConfigFailValues_g[internalCellIndex][1] = totalMsgLen;
        reConfigFailValues_g[internalCellIndex][2] = RECONFIG_CELL_MIN_LEN;
#endif
        return MAC_FAILURE;
    }

    tag = LTE_GET_U16BIT(msg_p);

    /* CA Changes start */
    if (MAC_SUCCESS != parseCellReconfigDciInfo (tag, tagLen, &remLen, &msg_p,
                internalCellIndex))
        /* CA Changes end */
    {
        return MAC_FAILURE;
    }

    /* All the mandatory parameters should be added before this while loop
       and all the optional TLVs should be added in this while loop as a new
       switch case */
#ifdef LTE_EMBMS_SUPPORTED           
    resetEmbmsParsingInfo(internalCellIndex);       
#endif    
    while(remLen > 0)
    {    
        tag =  LTE_GET_U16BIT(msg_p);
        if ((tag != MIB_MSG_INFO) && (tag != SIBTYPE1_MSG_INFO) && (tag != SI_MSG_INFO))
        {
            msg_p += 2;
            tagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;
            remLen -= TAG_LEN;
        }

        /* CA Changes start */
        /* Cyclomatic Complexity changes - starts here */
        if (MAC_SUCCESS != parseCellReconfigOptionalParams (tag, tagLen, 
                    sfn, sf, &remLen, &msg_p, 
/*Coverity Id 116262 Fix Start*/
/*Coverity Id 116262 Fix Stop*/
            internalCellIndex))
            /* CA Changes end */
        {
            return MAC_FAILURE;
        }
        /* Cyclomatic Complexity changes - ends here */
    }
 #ifdef LTE_EMBMS_SUPPORTED
    if(MAC_FAILURE == verifyAreaRequestAndDelete(internalCellIndex))
    {
        return MAC_FAILURE;
    }
/*SPR 18567 fix start*/      
    if(MAC_NO_AREA_CHANGE == verifyAreaChangeRequest(internalCellIndex))
    {
        return MAC_SUCCESS;
    }
/*SPR 18567 fix end*/      
    processEmbmsConfiguration(internalCellIndex);
#if LTE_EMBMS_UESIM_TESTING        
    sendSIB13InfoToUESIM(internalCellIndex);
#endif        
#endif    
 

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCellReconfigOptionalParams 
 * Inputs         : tag - Stores the tag information,
 *                  tagLen - Tag length,
 *                  sfn - System Frame number,
 *                  sf - Sub Frame number,
 *                  remLen_p - Pointer to remaining length of API message,
 *                  message_p - Pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Cell Rconfig Optional parameters
 *                  received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType parseCellReconfigOptionalParams( UInt16 tag,
        UInt16 tagLen, UInt16 sfn, UInt8 sf, UInt16 *remLen_p, UInt8 **message_p,
/*Coverity Id 116262 Fix Start*/
/*Coverity Id 116262 Fix Stop*/
        InternalCellIndex internalCellIndex)
/* CA Changes end */
{
    UInt8  *msg_p   = PNULL;
    UInt16 remLen = *remLen_p;
    /* Coverity 116279 fix start */
    MacRetType retval = MAC_SUCCESS;
    /* Coverity 116279 fix end */
    /*+-SPR 16417 Changes*/
	/* CA Changes start */
#ifdef LTE_EMBMS_SUPPORTED    
    UInt8 isEmbmsParsingFailed=FALSE;
#endif    
    CellState cellState =  cellSpecificParams_g.\
        cellConfigAndInitParams_p[internalCellIndex]->cellState;
	CellConfigParams *cellParams_p =  cellSpecificParams_g.\
        cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
	/* CA Changes end */
    msg_p = *message_p;

    switch(tag)
    {   
        case MIB_MSG_INFO:
        case SIBTYPE1_MSG_INFO:
        case SI_MSG_INFO:
        {
            /* SPR 15145 Changes Starts */
            /*+SPR 3416*/ 

            /* Cov_116394_Fix_Start */
            /* CA Changes start */
            retval = (MacRetType)parseAndStoreBroadcastMsg(&msg_p,&remLen,FALSE,
                    sfn,
                    /*Coverity Id 116262 Fix Start*/
                   internalCellIndex);
            /* CA Changes end */
            /* Cov_116394_Fix_End */
            /*-SPR 3416*/ 
            /* SPR 15145 Changes Ends */ 
            if (MAC_SUCCESS != retval)
            {
                lteWarning(" Process and Store Broadcast" 
                        " Message Failed ");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        retval,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Process and Store Broadcast Message Failed ");
                /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
                cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = 
                    INVALID_BCCH_VAL;
                cellConfigFailValues_g[internalCellIndex][1] = retval;
#endif
                return MAC_FAILURE;
            }
            /* +- SPR 15145 */
        }
        break;

        /* +- SPR 19066 */

        case CONTENTION_FREE_RACH_TIMER_INFO:    
        /* Cyclomatic Complexity changes - starts here */
        /* Cyclomatic_complexity_changes_start */
        retval = parseContentionFreeRachTimerInfo (tagLen,
                sfn, 
                sf,
                &remLen,
                &msg_p,
                internalCellIndex,
                cellState);
        /* Cyclomatic_complexity_changes_end */
        /* Cyclomatic Complexity changes - ends here */

        break;

        case PUCCH_CQI_SINR_THRESHOLD_INFO:
        {
            /* Cyclomatic_complexity_changes_start */
            retval = parsePucchCqiSinrThresholdInfo (tagLen, 
                    &remLen, &msg_p
                    /* CA Changes start */
                    ,internalCellIndex 
                    /* CA Changes end */
                    );
            /* Cyclomatic_complexity_changes_end */

            break;
        }
        case UL_SYNC_LOSS_TIMER_INFO:
        {
            /* Cyclomatic_complexity_changes_start */
            retval = parseULSyncLossTimerInfo (tagLen, 
                    &remLen, &msg_p
                    /* CA Changes start */
                    , internalCellIndex 
                    /* CA Changes end */
                    );
            /* Cyclomatic_complexity_changes_end */
            break;
        }

        case MOD_PERIOD_INFO:
        {
            /* Ignore the Mod period IE */
            /* SPR 3216 START */
            msg_p += 4;
            remLen -= 4;
            /* SPR 3216 END */
        }
        break;

        case SFN_GAP_INFO:    
        {
            /* Cyclomatic_complexity_changes_start */
            retval = parseSfnGapInfo(cellState,
                    cellParams_p,
                    &remLen,
                    &msg_p,
                    internalCellIndex);
            /* Cyclomatic_complexity_changes_end */

        }
        break;

        /*CLPC Change Begin*/
        case PDSCH_CONFIG_COMMON_INFO:
        {    /* CA Changes start */
            /* Cyclomatic_complexity_changes_start */
            retval = checkAndparsePdschConfigCommonInfo (tagLen, sfn, 
                    sf, &remLen, &msg_p,internalCellIndex);
            /* Cyclomatic_complexity_changes_end */
            /* CA Changes end */
            break;
        }

        case DOWNLINK_POWER_CONTROL_COMMON:
        {
            /* CA Changes start */
            /* Cyclomatic_complexity_changes_start */
            retval = checkAndparseDLPowerCtrlCommonInfo (tagLen, sfn, 
                    sf, &remLen, &msg_p,internalCellIndex);
            /* Cyclomatic_complexity_changes_end */
            /* CA Changes end */
            break;
        }

        case UPLINK_POWER_CONTROL_COMMON:
        {
            /* CA Changes start */
            /* Cyclomatic_complexity_changes_start */
            retval = checkAndparseULPowerCtrlCommonInfo (tagLen, sfn, 
                    sf, &remLen, &msg_p, internalCellIndex);
            /* Cyclomatic_complexity_changes_end */
            /* CA Changes end */
        }
        break;
        /*SPR 3600 Start*/
        case PUSCH_CONFIG_COMMON:
        {
            /* Cyclomatic_complexity_changes_start */
            retval = parsePuschConfigCommonInfo(tagLen,
                    sfn,
                    sf,
                    &remLen,
                    &msg_p,
                    internalCellIndex);
            /* Cyclomatic_complexity_changes_end */
        }
        break;
        /*SPR 3600 End*/
        case NGAP_VALUE:
        {
            /* CA Changes start */
            /* Cyclomatic_complexity_changes_start */
            retval = parseNGapValue (tagLen, &remLen, 
                    &msg_p,internalCellIndex);
            /* Cyclomatic_complexity_changes_end */
            /* CA Changes end */
        }
        break;
        /*CLPC Change Ends*/
        /* + PRS_CHANGES */
        case PRS_CONFIG_INFO:
        {
            /*Checking if all the mandatory parameters are present*/
            if ((remLen >=  PRS_CONFIG_INFO_MIN_LEN - TAG_LEN) &&
                    ((tagLen >= PRS_CONFIG_INFO_MIN_LEN ) &&
                     (tagLen  <= PRS_CONFIG_INFO_MAX_LEN) ))
            {
                /* CA Changes start */
                PRSParseConfigInfo *prsParseConfigInfo_p  =
                    &(reconfigMacCell_g[internalCellIndex].prsParseConfigInfo); 
                /* CA Changes end */

                prsParseConfigInfo_p->isPRSConfigured = *msg_p++;
                /* Review comment fix start SYNC_LOSS_1*/
                LOG_MAC_MSG(MAC_PRS_CONFIG_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        prsParseConfigInfo_p->isPRSConfigured,
                        internalCellIndex, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_PRS_CONFIG_INFO_PARAM:ReconfigCellReq");
                /* Review comment fix end SYNC_LOSS_1*/
                if ((PRS_RELEASE != prsParseConfigInfo_p->isPRSConfigured) 
                        && (PRS_SETUP != prsParseConfigInfo_p->isPRSConfigured))
                {
                    return MAC_FAILURE;
                }
                else if (PRS_SETUP ==  prsParseConfigInfo_p->isPRSConfigured)
                {
                    retval = parsePRSConfigInfo(msg_p, prsParseConfigInfo_p, 
                            tagLen,cellParams_p->dlAvailableRBs,TRUE
                            /* CA changes Start */
                            ,internalCellIndex
                            /* CA Changes end */
                            );
                    if(MAC_FAILURE == retval)
                    {
                        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID, LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                LINE_NUMBER, DEFAULT_INT_VALUE, PRS_CONFIG_INFO,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "PRS_CONFIG_INFO");
                        return MAC_FAILURE;
                    }

                    /* CA Changes start */
                    if (cellParams_p->prsConfigInfo.isPRSConfigured)
                        /* CA Changes end */
                    {
                        reconfigureParsePRSConfig(prsParseConfigInfo_p, internalCellIndex);  
                    }

                }

                prsParseConfigInfo_p->updateFlag = TRUE;
                /* CA Changes start */
                reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
                /* CA Changes end */
                /*Updating the remLen*/
                remLen -= (tagLen - TAG_LEN);
            }
            else
            {
                /* Remaining Length is less than required or Taglen is wrong*/
                return MAC_FAILURE;
            }
            break;
        }
        /* - PRS_CHANGES */
#ifdef LTE_EMBMS_SUPPORTED
        case EMBMS_CONFIG_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC: EMBMS_CONFIG_INFO Tag received cellIndex:%u\n",internalCellIndex);
				if (remLen >= EMBMS_CONFIG_INFO_LEN - TAG_LEN)
                {
                    retval = parseEMBMSConfigInfo(&msg_p,
                                      &(cellParams_p->eMbmsTransPower),
                                      &remLen);
                    if(MAC_FAILURE == retval)
                    {
                        isEmbmsParsingFailed = TRUE;

					    LOG_MSG(MAC_TAG_PARSE_FAILURE_ID, LOGWARNING,MAC_RRC_INF,
								GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
								LINE_NUMBER, DEFAULT_INT_VALUE, EMBMS_CONFIG_INFO,
								internalCellIndex,DEFAULT_INT_VALUE,
								DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
								FUNCTION_NAME,
								"EMBMS_CONFIG_INFO");

                    }
                }
                else
                {
                    // Remainig Length is less than required or Taglen is wrong
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                EMBMS_CONFIG_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }

            }
            break;
        case SIB13_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:SIB13_INFO Tag received cellIndex:%u\n",internalCellIndex);
                retval = parseSIB13Info(tagLen,
                                        &remLen,
                                        &msg_p,
                                        &(eMBMSCreateAreaReq_g[internalCellIndex].sib13Info));

                if(MAC_FAILURE == retval)
                {
                    isEmbmsParsingFailed = TRUE;
                }

            }
            break;
        case EMBMS_SIB2_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:EMBMS_SIB2_INFO Tag received cellIndex:%u\n",internalCellIndex);
                /*CID 106977*/
                if(tagLen >= EMBMS_SIB2_INFO_LEN)
                /*CID 106977*/
                {
                    retval = parseSIB2Info(&msg_p,
                                           &remLen,
                                           &(eMBMSCreateAreaReq_g[internalCellIndex].sib2Info));

                    if(MAC_FAILURE == retval)
                    {
                        isEmbmsParsingFailed = TRUE;
                    }
                    else
                    {
			/*SPR 18809 fix start*/
			if(eMBMSCreateAreaReq_g[internalCellIndex].sib2Info.noOfCsaPattern)
			{
				retval = getEmbmsValidSfFromCSAPattern(internalCellIndex,
						eMBMSCreateAreaReq_g[internalCellIndex].sib2Info.noOfCsaPattern,
						eMBMSCreateAreaReq_g[internalCellIndex].sib2Info.csaPatternList); 
			}
			if (retval == MAC_SUCCESS)
			{
			    embmsConfigParams_g[internalCellIndex].sib2UpdateFlag = TRUE;
			    getSib2Occasion(internalCellIndex);
			}
                    }
			/*SPR 18809 fix end*/

                }
                else
                {
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                EMBMS_SIB2_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }

            }
            break;
        case MAC_CREATE_MBMS_AREA_ENTITY_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:MAC_CREATE_MBMS_AREA_ENTITY_INFO Tag received cellIndex:%u\n",internalCellIndex);
				if ((remLen >= CREATE_MBMS_AREA_INFO_LEN - TAG_LEN) && 
						(tagLen > CREATE_MBMS_AREA_INFO_LEN ))
                {
                   retval = parseCreateMBMSAreaReq(&msg_p,
                                    &(eMBMSCreateAreaReq_g[internalCellIndex].embmsAreaEntity),
                                    /* SPR 18089 FIX START */
                                    tagLen - TAG_LEN,
                                    /* SPR 18089 FIX END */
                                    internalCellIndex);
                  
                   if(MAC_FAILURE == retval)
                   {
                       isEmbmsParsingFailed = TRUE;
                        /*SPR 18197 fix*/
#ifdef LTE_EMBMS_UESIM_TESTING
                       sib13AreaInfo_g[internalCellIndex][CREATE_AREA_INFO_PTR].buff_p = PNULL;
#endif
                   }
                   else
                   {
                       remLen -= (tagLen - TAG_LEN);
                       eMBMSCreateAreaReceived_g[internalCellIndex]=TRUE;
                   } 
                }
                else
                {
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                CREATE_MBMS_AREA_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }
            }
            break;
        case MAC_DELETE_MBMS_AREA_ENTITY_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:MAC_DELETE_MBMS_AREA_ENTITY_INFO Tag received cellIndex:%u\n",internalCellIndex);

                if((remLen >= DELETE_MBMS_AREA_INFO_LEN - TAG_LEN) &&
                    (tagLen >= DELETE_MBMS_AREA_INFO_LEN ))
                {
                    retval = parseDeleteMBMSAreaReq(&msg_p,
                                                    tagLen,
                                                    &eMBMSDeleteAreaReq_g[internalCellIndex],
                                                    &remLen,
                                                    internalCellIndex
                                                    );
                    if(MAC_FAILURE == retval)
                    {
                        isEmbmsParsingFailed = TRUE;
                        /*SPR 18197 fix*/
#ifdef LTE_EMBMS_UESIM_TESTING
                        sib13AreaInfo_g[internalCellIndex][DELETE_AREA_INFO_PTR].buff_p = PNULL;
#endif
                    }
                    else
                    {
                       eMBMSDeleteAreaReceived_g[internalCellIndex]=TRUE;
                    }    
                }
                else
                {
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                DELETE_MBMS_AREA_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }
            }
            break;
#endif
        default:
        /*Invalid tag received which is not expected in this API*/
        lteWarning("Invalid Tag value in MAC_RECONFIG_CELL_REQ received\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag value in MAC_RECONFIG_CELL_REQ received");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    /* Cyclomatic_complexity_changes_start */
    if (MAC_SUCCESS == retval)
    {
        *remLen_p = remLen;
        *message_p = msg_p;
#ifdef LTE_EMBMS_SUPPORTED
        embmsConfigParams_g[internalCellIndex].isParsingFailed = FALSE;
#endif
    }
    else
    {
#ifdef LTE_EMBMS_SUPPORTED
        embmsConfigParams_g[internalCellIndex].isParsingFailed = isEmbmsParsingFailed;
#endif
        return MAC_FAILURE;
        /* Do nothing */
    }
    /* Cyclomatic_complexity_changes_end */

    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name  : parseCellReconfigDciInfo
 * Inputs         : tag - Stores the tag information,
 *                  tagLen - Tag length,
 *                  remLen_p - Pointer to remaining length of API message,
 *                  message_p - Pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the DCI information received in 
 *                  MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType parseCellReconfigDciInfo(
        UInt16 tag, UInt16 tagLen, UInt16 *remLen_p, UInt8 **message_p,
        InternalCellIndex internalCellIndex)
    /* CA Changes end */
{
    UInt8  *msg_p   = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *message_p;
    /* CA Changes start */
    CellConfigParams *cellParams_p =  cellSpecificParams_g.\
                                      cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */

    if(DCI_FORMAT_FOR_SI_MSG == tag)
    {
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        remLen -= TAG_LEN;

        if(5 != tagLen)
        {
            LTE_MAC_UT_LOG(LOG_WARNING,BCCH_MGR,
                    "[%s]: Invalid Tag Length for DCI_FORMAT_FOR_SI_MSG \n",__func__);
            return MAC_FAILURE;
        }
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_DCI_FORMAT_FOR_SI_MSG_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                *msg_p,
                internalCellIndex,
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_DCI_FORMAT_FOR_SI_MSG_PARAM");
        /* Review comment fix end SYNC_LOSS_1*/

        if(SI_MSG_DCI_FORMAT_1A == *msg_p)
        {
            cellParams_p->dciFormatForCommonChnlMsg = DCI_FORMAT_1A;
        }
        else if(SI_MSG_DCI_FORMAT_1C == *msg_p)
        {
            if (RAT_LOCALIZED == macParams_g.siSchedulingRATPolicy)
            {
                LTE_MAC_UT_LOG(LOG_WARNING,BCCH_MGR,
                        "[%s]: DCI FORMAT 1C will not support RAT Localized policy\n",__func__);

                return MAC_FAILURE;
            }
            cellParams_p->dciFormatForCommonChnlMsg = DCI_FORMAT_1C;
        }
        else
        {
            return MAC_FAILURE;
        }
        /* Review comment fix start SYNC_LOSS_2*/
        LOG_MAC_MSG(MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET3,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                DEFAULT_INT_VALUE, 
                cellParams_p->dciFormatForCommonChnlMsg, 
                internalCellIndex, 
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET3");
        /* Review comment fix end SYNC_LOSS_2*/

        msg_p += 1;
        remLen -= 1;
        tag = LTE_GET_U16BIT(msg_p);
    }

    if(RBS_FOR_DCI_1A == tag)
    {
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);

        msg_p += 2;
        tagLen -= 4;
        /*Coverity 73056 Fix Start*/
        if(tagLen > remLen)
        {
            return MAC_FAILURE;
        }
        /*Coverity 73056 Fix End*/
        remLen -= TAG_LEN;

        /* +- SPR 17777 */
        if(DCI_1A_CH_RB_MAP_LEN != fillRBSelectionTableforDCIFormat1A(&msg_p, 
                    tagLen,cellParams_p))
            /* +- SPR 17777 */
        {
            LTE_MAC_UT_LOG(LOG_WARNING,BCCH_MGR,
                    "[%s]: DCI FORMAT 1A with invalid RB's \n",__func__);
            return MAC_FAILURE;
        }
        remLen -= DCI_1A_CH_RB_MAP_LEN;
        tag = LTE_GET_U16BIT(msg_p);
    }

    if(RBS_FOR_DCI_1C == tag)
    {
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);

        msg_p += 2;
        tagLen -= 4;

        remLen -= TAG_LEN;
        /*Coverity 72904 Fix Start*/
        if(tagLen > remLen)
        {
            return MAC_FAILURE;
        }
        /*Coverity 72904 Fix End*/

        if(DCI_1C_CH_RB_MAP_LEN != fillRBSelectionTableforDCIFormat1C(&msg_p,
                    tagLen,cellParams_p))
        {
            LTE_MAC_UT_LOG(LOG_WARNING,BCCH_MGR,
                    "[%s]: DCI FORMAT 1C with invalid RB's \n",__func__);
            return MAC_FAILURE;
        }

        remLen -= DCI_1C_CH_RB_MAP_LEN;
    }
    *remLen_p = remLen;
    *message_p = msg_p;

    return MAC_SUCCESS;
}

 /*+- SPR 19066 */

/****************************************************************************
 * Function Name  : parseContentionFreeRachTimerInfo
 * Inputs         : tagLen - Tag length,
 *                  sfn - System Frame number,
 *                  sf - Sub Frame number,
 *                  remLen - Remaining length of API message,
 *                  msg_p - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 *                  cellState - current state of cell
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Contention Free Rach Timer Info
 *                  received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType parseContentionFreeRachTimerInfo (
        UInt16 tagLen, UInt16 sfn, UInt8 sf, UInt16 *remLen_p, UInt8  **msg_p,
        InternalCellIndex internalCellIndex, CellState cellState)
{
    UInt16 contnFreeRachTimer = 0;
    ContFreeRachTimeVal *contFreeRachTimer_p = PNULL;

    if ((*remLen_p >=CONTENTION_FREE_RACH_TIMER_REM_LEN)
            &&(CONTENTION_FREE_RACH_TIMER_TAG_MIN_LEN == tagLen)) 
    {
        /* Cell Start Stop Chg */
        if ((CELL_WAIT_FOR_PHY_START == cellState) ||
                (CELL_WAITING_FOR_FIRST_SFI == cellState))
        {
            contnFreeRachTimer = LTE_GET_U16BIT(*msg_p);

            if ((MAC_MIN_CFR_TIMER_VAL > contnFreeRachTimer)||
                    (MAC_MAX_CFR_TIMER_VAL <contnFreeRachTimer))
            {
                return MAC_FAILURE;
            }
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                cellParams_p->contnFreeRachTimer = contnFreeRachTimer;
        }
        else 
        {
            /* Cell Start Stop Chg */
            contnFreeRachTimer = LTE_GET_U16BIT(*msg_p);

            if ((MAC_MIN_CFR_TIMER_VAL > contnFreeRachTimer)||
                    (MAC_MAX_CFR_TIMER_VAL <contnFreeRachTimer))
            {
                return MAC_FAILURE;
            }
            contFreeRachTimer_p = &reconfigMacCell_g[internalCellIndex].contFreeRachTimer;
            contFreeRachTimer_p->targetSfn = sfn;
            contFreeRachTimer_p->targetSf  = sf;
            contFreeRachTimer_p->contFreeRachTimer = contnFreeRachTimer;
            contFreeRachTimer_p->updateFlag = TRUE;
            reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
        }
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_CONTENTION_FREE_RACH_TIMER_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                contnFreeRachTimer,
                internalCellIndex,
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_CONTENTION_FREE_RACH_TIMER_INFO_PARAM");
        /* Review comment fix end SYNC_LOSS_1*/
    }
    else
    {
        return MAC_FAILURE;
    }

    /* Cyclomatic_complexity_changes_start */
    *msg_p += 2;
    *remLen_p -= CONTENTION_FREE_RACH_TIMER_REM_LEN;
    /* Cyclomatic_complexity_changes_end */

    return MAC_SUCCESS;
}
/* CA Changes end */
/****************************************************************************
 * Function Name  : parsePucchCqiSinrThresholdInfo 
 * Inputs         : tagLen - Tag length,
 *                  remLen - Remaining length of API message,
 *                  msg_p - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PUCCH CQI SINR Threshold Info
 *                  received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
STATIC  MacRetType parsePucchCqiSinrThresholdInfo (
        UInt16 tagLen, UInt16 *remLen, UInt8  **msg_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
#ifdef LOG_PRINT_ENABLED
    /*SPR_3061_FIX*/
    UInt8 pucchCQISINRThreshold = 0;
#endif
    /*SPR_3061_FIX*/
    if ((*remLen >=PUCCH_CQI_SINR_THRESHOLD_REM_LEN)
            &&(PUCCH_CQI_SINR_THRESHOLD_MIN_LEN == tagLen)) 
    {
#ifdef LOG_PRINT_ENABLED
        /*SPR_3061_FIX*/
        pucchCQISINRThreshold = *(*msg_p);
#endif
        /* SPR 12813 Change start */
        (*msg_p) += PUCCH_CQI_SINR_THRESHOLD_REM_LEN ;
        /* SPR 12813 Change end */
        *remLen -= PUCCH_CQI_SINR_THRESHOLD_REM_LEN;
        /* Review comment fix start SYNC_LOSS_1*/
#ifdef LOG_PRINT_ENABLED
        LOG_MAC_MSG(MAC_FREQUENCY_SELECTIVE_ENABLE_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                pucchCQISINRThreshold,
                DEFAULT_INT_VALUE, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_FREQUENCY_SELECTIVE_ENABLE_PARAM:ReconfigCellReq");
#endif
        /* Review comment fix end SYNC_LOSS_1*/
    }
    else
    {
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseULSyncLossTimerInfo 
 * Inputs         : tagLen - Tag length,
 *                  remLen - Remaining length of API message,
 *                  msgBuf - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UL Sync Loss Timer information
 *                  received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
STATIC  MacRetType parseULSyncLossTimerInfo (
        UInt16 tagLen, UInt16 *remLen, UInt8  **msgBuf
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf;
    UInt16 ulSyncLossTimer = 0;

    if ((*remLen >=UL_SYNC_LOSS_TIMER_INFO_REM_LEN)
            &&(UL_SYNC_LOSS_TIMER_INFO_MIN_LEN == tagLen)) 
    {
        ulSyncLossTimer = LTE_GET_U16BIT(msg_p);
        msg_p += UL_SYNC_LOSS_TIMER_INFO_REM_LEN ;
        *remLen -= UL_SYNC_LOSS_TIMER_INFO_REM_LEN;

        *msgBuf = msg_p;
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_UL_SYNC_LOSS_TIMER_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulSyncLossTimer,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_UL_SYNC_LOSS_TIMER_INFO_PARAM:ReconfigCellReq");
        /* Review comment fix end SYNC_LOSS_1*/

        if (ulSyncLossTimer > MAX_UL_SYNC_LOSS_TIMER)
        {
            return MAC_FAILURE;
        }
    }
    else
    {
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : checkAndparsePdschConfigCommonInfo
 * Inputs         : tagLen - Tag length,
 *                  sfn - System Frame number,
 *                  sf - Sub Frame number,
 *                  remLen - Remaining length of API message,
 *                  msg_p - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function checks and parse the PDSCH Config common 
 *                  information received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType checkAndparsePdschConfigCommonInfo (
        UInt16 tagLen, UInt16 sfn, UInt8  sf, UInt16 *remLen, UInt8  **msg_p,
        InternalCellIndex internalCellIndex)
    /* CA Changes end */
{
    /* + Coverity 32760 */ 
    MacRetType retval = MAC_SUCCESS;    
    /* - Coverity 32760 */ 

    if((*remLen >= PDSCH_CONFIG_COMMON_INFO_PARAM_LENGTH) &&
            (PDSCH_CONFIG_COMMON_INFO_TAG_MIN_LEN == tagLen))
    {
        ConfigCellReq configCellReq;
        retval =  parsePdschConfigCommonInfo(*msg_p,
                &configCellReq
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                ); 

        if (MAC_SUCCESS == retval)
        {
            /* CA Changes start */
            PDSCHReConfigCommonInfo *reconfig_p =
                &(reconfigMacCell_g[internalCellIndex].reconfigPdschConfigCommonInfo);
            /* CA Changes end */
            reconfig_p->targetSfn = sfn;
            reconfig_p->targetSf = sf;
            reconfig_p->referenceSigPower =
                configCellReq.pdschConfigCommonInfo.referenceSigPower;
            reconfig_p->pB = configCellReq.pdschConfigCommonInfo.pB;
            reconfig_p->updateFlag = TRUE;
            /* CA Changes start */
            reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
            /* CA Changes end */

            LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    LINE_NUMBER,DEFAULT_INT_VALUE,PDSCH_CONFIG_COMMON_INFO,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "PDSCH_CONFIG_COMMON_INFO.");
        }
        else
        {
            LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID, LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    LINE_NUMBER, DEFAULT_INT_VALUE, PDSCH_CONFIG_COMMON_INFO,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "PDSCH_CONFIG_COMMON_INFO.");
            return retval;
        }
    }
    else
    {
        return MAC_FAILURE;
    }

    /* Cyclomatic_complexity_changes_start */
    *remLen -= (tagLen - TAG_LEN);
    /*Increment the msg Pointer to point to the next tag*/
    *msg_p += (tagLen - TAG_LEN);
    /* Cyclomatic_complexity_changes_end */

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : checkAndparseDLPowerCtrlCommonInfo 
 * Inputs         : tagLen - Tag length,
 *                  sfn - System Frame number,
 *                  sf - Sub Frame number,
 *                  remLen - Remaining length of API message,
 *                  msg_p - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function checks and parse the DL Power control common 
 *                  information received in MAC_RECONFIG_CELL_REQ.
 ******************************************************************************/
/* CA Changes start */
STATIC  MacRetType checkAndparseDLPowerCtrlCommonInfo( UInt16 tagLen, 
        UInt16 sfn, UInt8  sf, UInt16 *remLen, UInt8  **msg_p,
        InternalCellIndex internalCellIndex)
/* CA Changes end */
{
    /* + Coverity 32760 */ 
    MacRetType retval = MAC_SUCCESS;    
    /* - Coverity 32760 */ 

    if((*remLen >= DOWNLINK_POWER_CONTROL_COMMON_PARAM_LENGTH) && (
                DOWNLINK_POWER_CONTROL_COMMON_TAG_MIN_LEN == tagLen))
    {
        ConfigCellReq configCellReq;
        retval = parseCommonDLPowerControlInfo(*msg_p,
                &configCellReq
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                );
        if (MAC_SUCCESS == retval)
        {
            /* CA Changes start */
            ReconfigCommonDLPControlInfoMac *reconfig_p =
                &(reconfigMacCell_g[internalCellIndex].reconfigCommonDLPControlInfoMac);
            /* CA Changes end */
            reconfig_p->targetSfn = sfn;
            reconfig_p->targetSf = sf;
            reconfig_p->pcfichPowerOffset =
                configCellReq.commonDLPowerControlInfo.pcfichPowerOffset;
            reconfig_p->phichPowerOffset =
                configCellReq.commonDLPowerControlInfo.phichPowerOffset;
            reconfig_p->pdcchPowerOffset =
                configCellReq.commonDLPowerControlInfo.pdcchPowerOffset;
            reconfig_p->pbchTransmissionPower =
                configCellReq.commonDLPowerControlInfo.pbchTransmissionPower;
            reconfig_p->pchTransmissionPower =
                configCellReq.commonDLPowerControlInfo.pchTransmissionPower;
            reconfig_p->updateFlag = TRUE;
            /* CA Changes start */
            reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
            /* CA Changes end */

            LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    LINE_NUMBER,DEFAULT_INT_VALUE,DOWNLINK_POWER_CONTROL_COMMON,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "DOWNLINK_POWER_CONTROL_COMMON.");
        }
        else
        {
            LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID, LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    LINE_NUMBER, DEFAULT_INT_VALUE, DOWNLINK_POWER_CONTROL_COMMON,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "DOWNLINK_POWER_CONTROL_COMMON.");
            return retval;
        }
    }
    else
    {
        return MAC_FAILURE;
    }

    /* Cyclomatic_complexity_changes_start */
    *remLen -= (tagLen - TAG_LEN);
    /*Increment the msg Pointer to point to the next tag*/
    *msg_p += (tagLen - TAG_LEN);
    /* Cyclomatic_complexity_changes_end */

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : checkAndparseULPowerCtrlCommonInfo 
 * Inputs         : tagLen - Tag length,
 *                  sfn - System Frame number,
 *                  sf - Sub Frame number,
 *                  remLen - Remaining length of API message,
 *                  msg_p - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function checks and parse the UL Power control common 
 *                  information received in MAC_RECONFIG_CELL_REQ.
 ******************************************************************************/
/* CA Changes start */
STATIC  MacRetType checkAndparseULPowerCtrlCommonInfo( UInt16 tagLen, 
        UInt16 sfn, UInt8  sf, UInt16 *remLen, UInt8  **msg_p,
        InternalCellIndex internalCellIndex)
/* CA Changes end */
{
    if((*remLen >= UPLINK_POWER_CONTROL_COMMON_PARAM_LENGTH) &&
            (UPLINK_POWER_CONTROL_COMMON_TAG_MIN_LEN == tagLen))
    {
        SInt8 p0NominalValue;
        UInt8 alpha;

        p0NominalValue = *(*msg_p)++;
        if((p0NominalValue < MIN_P0_NOMINAL_PUSCH_VALUE)||
                (p0NominalValue > MAX_P0_NOMINAL_PUSCH_VALUE))
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    DEFAULT_INT_VALUE,p0NominalValue ,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "UPLINK_POWER_CONTROL_COMMON_P0NOMINAL_VALUE");

            return MAC_FAILURE;
        }
        alpha = *(*msg_p)++;
        if((alpha > MAX_ALPHA_VALUE))
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    DEFAULT_INT_VALUE,alpha ,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "UPLINK_POWER_CONTROL_COMMON_ALPHA");

            return MAC_FAILURE;
        }
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_UPLINK_POWER_CONTROL_COMMON_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                p0NominalValue,
                alpha,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_UPLINK_POWER_CONTROL_COMMON_PARAM:ReconfigCellReq");
        /* Review comment fix end SYNC_LOSS_1*/

        // Possible values of alpha received lies between 0 to 7
        // Convert alpha into actual alpha values i.e. 
        // 0,4,5,6,7,8,9,10 for 0.0, 0.4, 0.5, 0.6, 
        // 0.7, 0.8, 0.9, 1
        if (alpha != 0)
        {
            alpha = alpha+3;
        }

        /* CA Changes start */
        ReconfigCommonULPowerControlInfo *reconfig_p = 
            &(reconfigMacCell_g[internalCellIndex].reconfigCommonULPowerControlInfo);
        /* CA Changes end */
        reconfig_p->targetSfn = sfn;
        reconfig_p->targetSf = sf;
        reconfig_p->p0NominalPuschValue = p0NominalValue;
        reconfig_p->alpha = alpha;
        reconfig_p->updateFlag = TRUE;
        /* CA Changes start */
        reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
        /* CA Changes end */
    }
    else
    {
        return MAC_FAILURE;
    }

    /* Cyclomatic_complexity_changes_start */
    *remLen -= (tagLen - TAG_LEN);
    /* Cyclomatic_complexity_changes_end */

    return MAC_SUCCESS;
}
/* Cyclomatic_complexity_changes_end */

/******************************************************************************
 * Function Name  : parseNGapValue 
 * Inputs         : tagLen - Tag length,
 *                  remLen - Remaining length of API message,
 *                  msg_p - pointer that address of data read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the NGAP value received in 
 *                  MAC_RECONFIG_CELL_REQ.
 ******************************************************************************/
/* CA Changes start */
STATIC  MacRetType parseNGapValue( UInt16 tagLen, UInt16 *remLen, 
        UInt8  **msg_p,InternalCellIndex internalCellIndex)
/* CA Changes end */
{
    /* + coverity 32768 */
    NGapType nGapValue = NGAP1;  
    /* - coverity 32768 */
    if ((*remLen >= NGAP_TAG_REM_LENGTH) && (NGAP_TAG_LEN_VALUE == tagLen)) 
    {
        /* + coverity 32764 */
        nGapValue = (NGapType) *(*msg_p);
        /* - coverity 32764 */
        /* SPR 12813 Changes Start */
        (*msg_p) += NGAP_TAG_REM_LENGTH;
        /* SPR 12813 Changes end */
        *remLen -= NGAP_TAG_REM_LENGTH;
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_NGAP_VALUE_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                nGapValue,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_NGAP_VALUE_PARAM:ReconfigCellReq");
        /* Review comment fix end SYNC_LOSS_1*/
        /* CA Changes start */
        if ((nGapValue > NGAP2)|| ((nGapValue == NGAP2) && (cellSpecificParams_g.\
                        cellConfigAndInitParams_p[internalCellIndex]->cellParams_p->\
                        dlAvailableRBs <= 50)))
        {	

            return MAC_FAILURE;
        }
        /* GAP_VALUE_FIX_START */
        reconfigMacCell_g[internalCellIndex].gapValue = (nGapValue == NGAP1)?GAP_VALUE_ONE:GAP_VALUE_TWO;
        reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
        /* CA Changes end */
        /* GAP_VALUE_FIX_END */ 
    }
    else
    {
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}

/*--coverity-530 CID 52747 */
#ifdef MAC_AUT_TEST
/*--coverity-530 CID 52747 */
/****************************************************************************
 * Function Name  : validateRACHConfigInfo 
 * Inputs         : raResponseWindowSize,
 *                  contentionResolutionTimer,
 *                  prachConfigurationIndex,
 *                  prachFrequencyOffset
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates SFN And SF parameters and return the 
 *                  result of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateRACHConfigInfo( UInt32 raResponseWindowSize,
        UInt32 contentionResolutionTimer,
        UInt32 prachConfigurationIndex,
        UInt32 prachFrequencyOffset
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ( raResponseWindowSize > RA_RESPONSE_WINDOW_SIZE_1 &&
            raResponseWindowSize < RA_RESPONSE_WINDOW_SIZE_11 &&
            raResponseWindowSize != RA_RESPONSE_WINDOW_SIZE_9)
    {
        if ((contentionResolutionTimer == CONTENTION_RESOLUTION_TIMER_MIN || 
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 2) ||
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 3) ||
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 4) ||
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 5) ||
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 6) ||
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 7) ||
                    contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 8) )) 
        {    
            if  ( ((prachConfigurationIndex <= MAC_MAX_PRACH_CONFIGURATION_INDEX) &&
                        (prachFrequencyOffset <= MAC_MAX_PRACH_FREQUENCY_OFFSET)))
            {
                return MAC_SUCCESS;
            }
            else
            {
                return MAC_FAILURE;
            }
        }
        else
        {
            return MAC_FAILURE;
        }
    }    
    else
    {
        return MAC_FAILURE;
    }
    return MAC_SUCCESS; 
}
#endif
/****************************************************************************
 * Function Name  : parseConfigCellReq
 * Inputs         :
 *                  msg_p - pointer to the buffer received from the socket,
 *                  totalMsgLen - total length of API message,
 *                  configCellReq - ponter to structure 
 *                                  passed to fill the configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC for configuration.
 ****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
STATIC  MacRetType parseConfigCellReq (
        UInt8 *msg_p,
        UInt16 totalMsgLen,
        ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex
        )
/* CA Changes end */
{   
    /* + Coverity 32760 */ 
    MacRetType retval = MAC_SUCCESS;    
    /* - Coverity 32760 */ 
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
    UInt16 remLen = 0;
    UInt16 sfn    = 0;
    UInt16 n1PUCCH_AN               = 0;
    UInt8 cellConfigReqFlag         = 0;
    UInt8 raResponseWindowSize      = 0;
    UInt8 preambleInitialReceivedTargetPower = 0;
    UInt8 contentionResolutionTimer = 0;
    UInt8 maxHARQMsg3Tx             = 0;
    UInt8 prachConfigurationIndex   = 0;
    UInt8 prachFrequencyOffset      = 0;
    UInt8 deltaPUCCH_Shift          = 0;
    UInt8 nRB_CQI                   = 0;
    UInt8 nCS_AN                    = 0;
    UInt32 numContnBasedPreambles    = 0;
    UInt32 preambleGroupAConfigFlag  = 0;
    UInt32 numOfPreamblesInGroupA    = 0;
    UInt32 messageSizeGroupA      = 0;
    /** ETWS **/
    DCIFormat dciFormat = MAX_NUM_DCI_FORMAT; 
    /* CA Changes start */
    CellConfigParams *cellParams_p =  cellSpecificParams_g.cellConfigAndInitParams_p\
                                      [internalCellIndex]->cellParams_p;   
    InitParams *initParams_p = cellSpecificParams_g.cellConfigAndInitParams_p\
                               [internalCellIndex]->initParams_p;
    /* CA Changes end */
    /*+- SPR 19066 */
    configCellReq_p->contnFreeRachTimer = MAC_MIN_CFR_TIMER_VAL;
    /*Dynamic Pdcch Changes Start*/
    configCellReq_p->isDynamicPdcchDisabled = 0;
    /*Dynamic Pdcch Changes End*/
    /* + PRS_CHANGES */
    configCellReq_p->prsParseConfigInfo.isPRSConfigured = 0;
    configCellReq_p->prsParseConfigInfo.bitsTobeRead = 0;


#ifdef LOG_PRINT_ENABLED
    cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = NO_FAIL;
#endif
    remLen = totalMsgLen;
    /* check if mandatory fields are present */
    if(totalMsgLen >= CONFIG_CELL_REQ_MIN_LEN)
    {
        /* Cyclomatic Complexity changes - starts here */
        /* Validate the Cell Config parameters */
        if (MAC_SUCCESS != validateConfigCellParams (&msg_p, configCellReq_p, cellParams_p,
                    initParams_p
                    /* CA Changes start */
                    , internalCellIndex 
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }
        /* Cyclomatic Complexity changes - ends here */
        /* ETWS */
        /* + Coverity 32762 */
        dciFormat = (DCIFormat) *msg_p++;
        /* - Coverity 32762 */
        /* CA Changes start */
        if(SI_MSG_DCI_FORMAT_1A == dciFormat)
        {
            cellParams_p->dciFormatForCommonChnlMsg = DCI_FORMAT_1A;
        }
        else if(SI_MSG_DCI_FORMAT_1C == dciFormat)
        {
            if (RAT_LOCALIZED == macParams_g.siSchedulingRATPolicy)
            {
                LTE_MAC_UT_LOG(LOG_WARNING,BCCH_MGR,
                        "[%s]: DCI FORMAT 1C will not support RAT Localized policy\n",__func__);
                return MAC_FAILURE;
            }
            cellParams_p->dciFormatForCommonChnlMsg = DCI_FORMAT_1C;
        }
        /* CA Changes end */
        else
        {
            return MAC_FAILURE;
        }
        remLen -= MANDATORY_LEN_OF_CELL_CONFIG;

#ifdef TDD_CONFIG
        /* Cyclomatic Complexity changes - starts here */
        /* Validate the TDD Cell Config parameters */
        if (MAC_SUCCESS != validateTddConfigCellParams (&msg_p, &remLen, 
                    configCellReq_p,
                    internalCellIndex))
        {
            return MAC_FAILURE;
        }
        /* Cyclomatic Complexity changes - ends here */
#endif
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        if (RACH_CONFIG_INFO != tag)
        {
            lteWarning("Invalid RACH TAG ");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tag,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid RACH TAG");
            /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
            cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_TAG;
            cellConfigFailValues_g[internalCellIndex][1] = tag;
            cellConfigFailValues_g[internalCellIndex][2] = RACH_CONFIG_INFO;
#endif
            return MAC_FAILURE;
        }

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        if (!((RACH_CONFIG_LEN == tagLen) || 
                    (RACH_CONFIG_WITH_PREAMBLE_GROUPA_CONFIG_LEN == tagLen)))
        {
            return MAC_FAILURE;
        }

        raResponseWindowSize      = *msg_p++;
        contentionResolutionTimer = *msg_p++;
        maxHARQMsg3Tx             = *msg_p++;
        prachConfigurationIndex   = *msg_p++;
        prachFrequencyOffset      = *msg_p++;
        numContnBasedPreambles    = *msg_p++;
        preambleInitialReceivedTargetPower = *msg_p++;
        /* Review comment fix start SYNC_LOSS_2*/
        LOG_MAC_MSG(MAC_RACH_CONFIG_INFO_PARAM_SET1,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                raResponseWindowSize,
                contentionResolutionTimer, 
                maxHARQMsg3Tx, 
                prachConfigurationIndex,
                prachFrequencyOffset, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_RACH_CONFIG_INFO_PARAM_SET1");
        LOG_MAC_MSG(MAC_RACH_CONFIG_INFO_PARAM_SET2,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                numContnBasedPreambles,
                preambleInitialReceivedTargetPower, 
                internalCellIndex, 
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_RACH_CONFIG_INFO_PARAM_SET2");
        /* Review comment fix end SYNC_LOSS_2*/
        /*+ Coverity fix 85803*/
#ifdef TDD_CONFIG
        /*Coverity 87603 Fix Start*/
        if(prachConfigurationIndex >= MAX_PRACH_CONFIGURATION_INDEX)
            /*Coverity 87603 Fix End*/
        {
            LOG_MAC_MSG(MAC_PRACH_RES_ALLOC,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "MAC_RACH_CONFIG_PARSING_ERROR:Invalid prachConfigurationIndex");

            return MAC_FAILURE;
        }
#endif
        /*- Coverity fix 85803*/

        if(preambleInitialReceivedTargetPower > MAX_PREAMBLE_INIT_RX_TARGET_POW)
        {
            return MAC_FAILURE;
        }
        if ((MAC_MIN_COUNT_OF_CONTENTION_BASED_RA_PREAMBLES >
                    numContnBasedPreambles) || 
                (MAC_MAX_NUM_OF_RA_PREAMBLES <
                 numContnBasedPreambles))
        {
            LOG_MAC_MSG(INVALID_RACH_CONFIG,LOGWARNING,MAC_RRC_INF, 
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    numContnBasedPreambles,
                    numOfPreamblesInGroupA,
                    messageSizeGroupA,
                    LINE_NUMBER,
                    internalCellIndex,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE, 
                    FUNCTION_NAME,"INVALID_NUM_CONTN_BASED_PREAMBLE");
            return MAC_FAILURE;
        }

#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][1] = raResponseWindowSize;
        cellConfigFailValues_g[internalCellIndex][2] = contentionResolutionTimer;
        cellConfigFailValues_g[internalCellIndex][3] = maxHARQMsg3Tx;
        cellConfigFailValues_g[internalCellIndex][4] = prachConfigurationIndex;
        cellConfigFailValues_g[internalCellIndex][5] = prachFrequencyOffset;
        cellConfigFailValues_g[internalCellIndex][6] = maxHARQMsg3Tx;
#endif
        if ( raResponseWindowSize > RA_RESPONSE_WINDOW_SIZE_1 &&
                raResponseWindowSize < RA_RESPONSE_WINDOW_SIZE_11 &&
                raResponseWindowSize != RA_RESPONSE_WINDOW_SIZE_9)
        {
            if ((contentionResolutionTimer == CONTENTION_RESOLUTION_TIMER_MIN ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 2) ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 3) ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 4) ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 5) ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 6) ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 7) ||
                        contentionResolutionTimer == (CONTENTION_RESOLUTION_TIMER_MIN * 8) ))
            {
                /* SPR 1566 changes start */
                if (maxHARQMsg3Tx >= MIN_HARQ_TRANSMISSION && 
                        maxHARQMsg3Tx <= MAX_HARQ_TRANSMISSION) 
                    /* SPR 1566 changes start */
                {
                    /* +- SPR 17777 */
                    if( MAC_FAILURE == validatePrachConfigIdx(
                                prachConfigurationIndex, prachFrequencyOffset,
                                configCellReq_p
                                /* +- SPR 17777 */
                                ) )
                        /* +- SPR 17777 */
                    {
#ifdef LOG_PRINT_ENABLED
                        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PRACH_CFG_FREQ_INDEX;
#endif                          
                        return MAC_FAILURE;
                    }
                }
                else
                {
                    lteWarning("Invalid maxHARQMsg3Tx=%d",maxHARQMsg3Tx);
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            maxHARQMsg3Tx,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid maxHARQMsg3Tx");
                    /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
                    cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_MSG3_MAX_HARQ_TRANS;
#endif                      
                    return MAC_FAILURE;
                }
            }  
            else
            {
                lteWarning("Invalid contentionResolutionTimer=%d",\
                        contentionResolutionTimer);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        contentionResolutionTimer,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid contentionResolutionTimer");
                /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
                cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_CONTENTION_RES_TIMER_VAL;
#endif                 
                return MAC_FAILURE;
            }
        }
        else
        {    
            lteWarning("Invalid raResponseWindowSize=%d",raResponseWindowSize);
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    raResponseWindowSize,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid raResponseWindowSize");
            /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
            cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_RARES_WINDOW_SIZE;
#endif              
            return MAC_FAILURE;
        }
        /* Cyclomatic Complexity changes - starts here */
        if (MAC_SUCCESS != parseCellRachPreambleConfig (tagLen, 
                    numContnBasedPreambles, &msg_p, &remLen,
                    &numOfPreamblesInGroupA, &messageSizeGroupA,
                    &preambleGroupAConfigFlag
                    /* CA Changes start */
                    ,internalCellIndex 
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }	

        /* PHICH_CONFIG_INFO and PUCCH_CONFIG_INFO */
        if (MAC_SUCCESS != validatePhichAndPucchConfigCellInfo (&msg_p, 
                    &remLen, &n1PUCCH_AN, &deltaPUCCH_Shift,
                    &nRB_CQI, &nCS_AN, configCellReq_p
                    /* CA Changes start */
                    ,internalCellIndex 
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }
        /* Cyclomatic Complexity changes - ends here */
    }
    else
    {
        lteWarning("Mandatory Fields Missing\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                totalMsgLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory Fields Missing ");
        /* Review comment fix end RJ13 */

#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_TOTAL_MSG_LEN;
        cellConfigFailValues_g[internalCellIndex][1] = totalMsgLen;
        cellConfigFailValues_g[internalCellIndex][2] = CONFIG_CELL_REQ_MIN_LEN;
#endif
        return MAC_FAILURE;
    }
    if (remLen < TAG_LEN)
    {
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_TAG_LEN;
        cellConfigFailValues_g[internalCellIndex][1] = remLen;
#endif
        return MAC_FAILURE;
    }

    /* Cyclomatic Complexity changes - starts here */
    /* Parse RB Selection Table and Broadcast message info */
    /* CA Changes start */
    if (MAC_SUCCESS != parseRBSelectionAndBroadcastMsgParams (&msg_p, 
                /* +- SPR 17777 */
                &remLen,cellParams_p,
                /* +- SPR 17777 */
                internalCellIndex 
                ))
        /* CA Changes end */
    {
        return MAC_FAILURE;
    }

    /* Validate the SRS and PDSCH Config parameters */
    if (MAC_SUCCESS != validateSrsAndPdschConfigCellParams (&msg_p, 
                &remLen, configCellReq_p
                /* CA Changes start */
                ,internalCellIndex 
                /* CA Changes end */
                ))
    {
        return MAC_FAILURE;
    }

    /* Validate Power Control and PUSCH Config parameters */
    if (MAC_SUCCESS != validatePowerCtrlAndPuschConfigCellParams (&msg_p, 
                &remLen, configCellReq_p
                /* CA Changes start */
                , internalCellIndex 
                /* CA Changes end */
                ))
    {
        return MAC_FAILURE;
    }

    /*All the mandatory parameters should be added before this while loop
      and all the optional TLVs should be added in this while loop as a new
      switch case*/
    /* CA Changes start */
    if (MAC_SUCCESS != parseOptionalCellConfigParams (msg_p, 
                remLen, configCellReq_p,
            internalCellIndex))
        /* CA Changes end */
    {
        return MAC_FAILURE;
    }
    /* Cyclomatic Complexity changes - ends here */

    cellConfigReqFlag = TRUE;
    /* MAC function to process the cell configuration
       data */
    /* SS_S2 */
    /* CA Changes start */
    retval = processCellConfig(configCellReq_p,internalCellIndex);    
    /* CA Changes end */
    if (retval != MAC_SUCCESS)
    {
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = CELL_CONFIG_REQUEST_FAIL;
        cellConfigFailValues_g[internalCellIndex][1] = retval;
#endif

        return MAC_FAILURE;
    }
    /* SS_S2 */
    /*process the RACH data */

#ifdef LOG_PRINT_ENABLED
    cellConfigFailValues_g[internalCellIndex][1] = raResponseWindowSize;
    cellConfigFailValues_g[internalCellIndex][2] = contentionResolutionTimer;
    cellConfigFailValues_g[internalCellIndex][3] = maxHARQMsg3Tx;
    cellConfigFailValues_g[internalCellIndex][4] = prachConfigurationIndex;
    cellConfigFailValues_g[internalCellIndex][5] = prachFrequencyOffset;
    cellConfigFailValues_g[internalCellIndex][6] = maxHARQMsg3Tx;
#endif
    /* CA Changes start */
	LOG_MAC_INFO (MAC_RRC_INF, 
			/*+- SPR 19066 */
			"CONFIG_CELL_PARAMETER_VALUES[%u]",internalCellIndex);
    retval =
        updateRACHConfigInfo(sfn, cellConfigReqFlag, raResponseWindowSize,
                contentionResolutionTimer,prachConfigurationIndex,
                prachFrequencyOffset,numContnBasedPreambles,
                preambleGroupAConfigFlag,
                numOfPreamblesInGroupA,messageSizeGroupA, 
                preambleInitialReceivedTargetPower,
                maxHARQMsg3Tx,
                &(cellParams_p->rachConfigInfo),
                internalCellIndex);
    /* CA Changes end */
    if (retval != MAC_SUCCESS)
    {
        lteWarning("MAC_FAILURE for updateRACHConfigInfo");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                retval,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "MAC_FAILURE for updateRACHConfigInfo ");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = RACH_CONFIG_FAIL;
#endif

        return MAC_FAILURE;
    }
#ifdef TDD_CONFIG
    initTddConfigInfo(cellParams_p->subFrameAssign, 
            cellParams_p->splSubFramePatterns,
            internalCellIndex);
#endif
    initTokenPeriodicityArray(internalCellIndex);
    /* MAC function to process PUCCH data */
    updatePUCCHConfig(deltaPUCCH_Shift, nRB_CQI, nCS_AN, n1PUCCH_AN,internalCellIndex);

    /* Review comment fix start GG15 */
    /*Funtion for Initializing CFI Value*/
    /* CA Changes start */  
    calculateCFIValue(internalCellIndex);
    /* CA Changes end */  
    /*Funtion for finding number of PHICH Group*/
    calculatePHICHGroup(internalCellIndex);
    /*Funtion for Calculating Max Number of CCEs*/
    calculateMaxCCE(internalCellIndex);
    /* TDD Config 0 Changes Start */    
    if (MAC_FAILURE == calculateMaxPucchRegion(internalCellIndex))
    {
        return MAC_FAILURE;
    }
    /* TDD Config 0 Changes End */    

    /* Review comment fix end GG15 */
    /* function to process MIB SIB and SIdata */
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatePrachConfigIdx
 * Inputs         : prachConfigurationIndex,
 *                  prachFrequencyOffset
 *                  configCellReq - ponter to structure passed to fill the
 *                                  configuration details needed by MAC
 *                  internalCellIndex - cell index of L2
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates the PRACH Config Index based on
 *                  configurations as per 36.211
 ****************************************************************************/
STATIC  MacRetType validatePrachConfigIdx(
        UInt8 prachConfigurationIndex, UInt8 prachFrequencyOffset,
        /* +- SPR 17777 */
        ConfigCellReq *configCellReq_p
        /* +- SPR 17777 */
        )
/* +- SPR 17777 */
{
#ifdef TDD_CONFIG
    PreambleFormat preambleFrmt =
        /* +- SPR 17777 */
        preambleFormatFrmPrachConfigIndex( prachConfigurationIndex);
    /* +- SPR 17777 */
#endif
    if(
#ifdef FDD_CONFIG
            ( MAC_INVALID_PRACH_CONFIGURATION_INDEX_30 == prachConfigurationIndex ||
              MAC_INVALID_PRACH_CONFIGURATION_INDEX_46 == prachConfigurationIndex ||
              MAC_INVALID_PRACH_CONFIGURATION_INDEX_60 == prachConfigurationIndex ||
              MAC_INVALID_PRACH_CONFIGURATION_INDEX_61 == prachConfigurationIndex ||
              MAC_INVALID_PRACH_CONFIGURATION_INDEX_62 == prachConfigurationIndex ||
              prachConfigurationIndex > MAC_MAX_PRACH_CONFIGURATION_INDEX )
#elif TDD_CONFIG
            /* Return failure if Preamble format is 4 and Special SF is
             * not 5, 6, 7 and 8 */
            ( ( PREAMBLE_FORMAT_4 == preambleFrmt) && (
                                                       MAC_TDD_SPECIAL_SUBFRAME_4 >=
                                                       configCellReq_p->splSubFramePatterns ) ) ||
            ( FALSE == isPrachConfigValid( prachConfigurationIndex,
                                           configCellReq_p->subFrameAssign) ) ||
            ( prachConfigurationIndex > MAC_MAX_PRACH_CONFIGURATION_INDEX_FOR_TDD )
            /* SPR 11489 fix start */
            /*|| ( MAC_FAILURE == validateFraWrtResBlks(
              configCellReq_p->ulResBlocks,
              configCellReq_p->subFrameAssign, prachConfigurationIndex,
              prachFrequencyOffset ) ) */
            /* SPR 11489 fix end */
#endif
            || ( prachFrequencyOffset >
                    (configCellReq_p->ulResBlocks - MAC_MIN_RESOURCE_BLOCKS))
                )
                {
                    LOG_MAC_MSG(MAC_PARSING_ERROR, LOGERROR, MAC_RRC_INF,
                            getCurrentTick(), prachFrequencyOffset,
                            prachConfigurationIndex, __LINE__,
#ifdef TDD_CONFIG
                            preambleFrmt,
                            configCellReq_p->splSubFramePatterns,
#elif FDD_CONFIG
                            0 ,0,
#endif
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,
                            "InvalidPrachConfigIdx");
                    return MAC_FAILURE;
                }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validateConfigCellParams 
 * Inputs         : msgBuf - Incoming message buffer,
 *                  configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                   cellParams_p - pointer to cell specific params structure
 *                   initParams_p - pointer to init-cell specific params 
 *                                 structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates the  Cell Config parameters
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType validateConfigCellParams( UInt8 **msgBuf,
        ConfigCellReq *configCellReq_p,
        CellConfigParams *cellParams_p,
        InitParams *initParams_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )  
/* CA Changes end */
{
    UInt8 *msg_p = PNULL;
    UInt8 i;

    msg_p = *msgBuf;

    configCellReq_p->duplexingMode = *msg_p++;
    /*HD FDD Changes Start*/
    /* Validation of duplexing mode */
    if (configCellReq_p->duplexingMode != MAC_TDD &&
            configCellReq_p->duplexingMode != MAC_FDD &&
            configCellReq_p->duplexingMode != MAC_HD_FDD )
        /*HD FDD Changes End*/
    {
        lteWarning("Invalid Duplexing Mode = %d",
                configCellReq_p->duplexingMode);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->duplexingMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Duplexing Mode");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_CELL_MODE;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->duplexingMode;
#endif
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    configCellReq_p->dlResBlocks = *msg_p++;
    configCellReq_p->ulResBlocks = *msg_p++;

    /* validation of resource blocks */
    if ((configCellReq_p->dlResBlocks < MAC_MIN_RESOURCE_BLOCKS) ||
            (configCellReq_p->dlResBlocks > MAC_MAX_RESOURCE_BLOCKS))
    {
        lteWarning("INVALID CONFIG DL RBS Parameters=%d",
                configCellReq_p->dlResBlocks);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->dlResBlocks,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CONFIG DL RBS ");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_DL_RES_BLOCKS;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->dlResBlocks;
#endif
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    else if ((configCellReq_p->ulResBlocks < MAC_MIN_RESOURCE_BLOCKS) ||
            (configCellReq_p->ulResBlocks > MAC_MAX_RESOURCE_BLOCKS))
    {
        lteWarning("INVALID CONFIG UL RBS Parameters=%d",
                configCellReq_p->ulResBlocks);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->ulResBlocks,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CONFIG UL RBS");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_UL_RES_BLOCKS;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->ulResBlocks;
#endif
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    /* Get the DL Bandwidth */
    /* CA Changes start*/
    /* +- SPR 17777 */
    getDlBandwidthCellConfigReq (configCellReq_p);
    /* +- SPR 17777 */

    /*L2_FIX_33_start*/
    /* Update Table for maximum Bits possible in a TB, per TTI, number of layers  etc. */
    macUpdateUECategoryTable (internalCellIndex);
    /*L2_FIX_33_end*/

    /*Dynamic Pdcch Changes Start*/
    for(i = 0; i< RES_BIT_MAP_ARRAY_SIZE; i++)
        cellParams_p->NumOfOverLappingRbsInfo[i] = NumOfOverLappingRbsArrayInfo_g[configCellReq_p->dlBandwidth][i];
    for(i = 0; i < MAX_NUM_OVERLAPPING_RB ; i++)
        cellParams_p->centralSixRbsInfo[i] = centralSixRbsArrayInfo_g[configCellReq_p->dlBandwidth][i];
    /*Dynamic Pdcch Changes End*/
    /* CA Changes end */
    configCellReq_p->maxHarqRetrans = *msg_p++;
    /* validation of harq profile */
    if (( configCellReq_p->maxHarqRetrans < MAC_MIN_HARQ_RETRANSMISSIONS)
            ||(configCellReq_p->maxHarqRetrans > MAC_MAX_HARQ_RETRANSMISSIONS))
    {
        lteWarning("INVALID MAX HARQ RETRANS Parameters=%d",
                configCellReq_p->maxHarqRetrans);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->maxHarqRetrans,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid MAX HARQ RETRANS");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_HARQ_RETRANSMISSIONS;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->maxHarqRetrans;
#endif
        return MAC_FAILURE;
    }

    configCellReq_p->numOfTxAntennas = *msg_p++;
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET1,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->duplexingMode,
            configCellReq_p->dlResBlocks, 
            configCellReq_p->ulResBlocks, 
            configCellReq_p->maxHarqRetrans,
            configCellReq_p->numOfTxAntennas, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET1");
    /* Review comment fix end SYNC_LOSS_2*/

    /* validation of number of Antennas */
    if (MAC_FAILURE == validateNumOfTxAntennas( 
                configCellReq_p->numOfTxAntennas ) )
    {
        lteWarning("INVALID number of Antennas Parameters=%d",
                configCellReq_p->numOfTxAntennas);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->numOfTxAntennas,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid number of Antennas");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_TX_ANTENNA;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->numOfTxAntennas;
#endif
        return MAC_FAILURE;
    }
    /* 4x2 MIMO SPR 7262 changes - */

    configCellReq_p->ulCyclicLenthPrefix = *msg_p++;
    /* validation of ul cyclic prefix */
    if (configCellReq_p->ulCyclicLenthPrefix != len1 &&
            configCellReq_p->ulCyclicLenthPrefix != len2)
    {
        lteWarning("INVALID ul cyclic prefix Parameters=%d",
                configCellReq_p->ulCyclicLenthPrefix);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->ulCyclicLenthPrefix,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid ul cyclic prefix");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_CYCLIC_PREFIX_LEN;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->ulCyclicLenthPrefix;
#endif
        return MAC_FAILURE;
    }    
    configCellReq_p->startRARntiRange= *msg_p++;

    configCellReq_p->endRARntiRange= *msg_p++;
    /* Validation for RA -RNTI Range */
    /* CA Changes start */
    if ((configCellReq_p->startRARntiRange >=  initParams_p->upperRNTIBound)
            || (configCellReq_p->startRARntiRange >= configCellReq_p->endRARntiRange))
    {
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_START_RNTI;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->startRARntiRange;
#endif
        return MAC_FAILURE;
    }
    if (( configCellReq_p->endRARntiRange > initParams_p->upperRNTIBound) 
            || (configCellReq_p->endRARntiRange <= configCellReq_p->startRARntiRange))
    {
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_END_RNTI;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->endRARntiRange;
#endif
        return MAC_FAILURE;
    }
    /* CA Changes end */
    configCellReq_p->modificationPeriod = LTE_GET_U32BIT(msg_p);
    msg_p += SIZEOF_UINT32;

    /* Modification Period and SFn GAp is added to makse code
     * compliant with LTE_L3_API_Rel_2_0_2_Rev_3.2 document.
     * These changes are made during merging for MAC TDD with FRWK.
     */ 

    /* Vaildation check for modification Period */
    if (configCellReq_p->modificationPeriod > MAC_MAX_MOD_PERIOD ||
            configCellReq_p->modificationPeriod % 64 != 0)
    {
        lteWarning("Invalid Modification Period [%d]",
                configCellReq_p->modificationPeriod);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->modificationPeriod,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Modification Period");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_MOD_PERIOD;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->modificationPeriod;
#endif
        return MAC_FAILURE;
    }

    configCellReq_p->sfnGap = *msg_p++;
    /* Validation Check for SFN Gap */
    if (configCellReq_p->sfnGap != MAC_SFN_GAP_1 &&
            configCellReq_p->sfnGap != MAC_SFN_GAP_2 &&
            configCellReq_p->sfnGap != (MAC_SFN_GAP_2 * 2) &&
            configCellReq_p->sfnGap != (MAC_SFN_GAP_2 * 4) &&
            configCellReq_p->sfnGap != (MAC_SFN_GAP_2 * 8) &&
            configCellReq_p->sfnGap != (MAC_SFN_GAP_2 * 16))
    {
        lteWarning("Invalid SFN GAP = %d",configCellReq_p->sfnGap);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->sfnGap,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid SFN GAP");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_SFN_GAP;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->sfnGap;
#endif
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET2,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->ulCyclicLenthPrefix,
            configCellReq_p->startRARntiRange, 
            configCellReq_p->endRARntiRange, 
            configCellReq_p->modificationPeriod,
            configCellReq_p->sfnGap, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET2");
    /* Review comment fix end SYNC_LOSS_2*/

    configCellReq_p->nB = *msg_p++;
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET3,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->nB,
            DEFAULT_INT_VALUE, 
            internalCellIndex, 
            DEFAULT_INT_VALUE,
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET3");
    /* Review comment fix end SYNC_LOSS_2*/
    /* Validation Check for nB */
    if (configCellReq_p->nB > MAX_NB_VALUE) 
    {
        lteWarning("Invalid nB = %d",configCellReq_p->nB);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->nB,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid nB");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_NB_VALUE;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->nB;
#endif
        return MAC_FAILURE;
    }

    /* SPR 19309 + */
    configCellReq_p->cfi = *msg_p++;
    /* Validation Check for cfi */
    if (((configCellReq_p->cfi < MIN_POSSIBLE_CFI_VALUE) || (configCellReq_p->cfi > MAX_POSSIBLE_CFI_VALUE )) ||
            /* As per 36.211, CFI value can be 2,3,4 for 1.4 MHz BW and 1,2,3 for other BW */
            ((DL_RES_BLKS_6RBS == configCellReq_p->dlResBlocks) && (MIN_POSSIBLE_CFI_VALUE == configCellReq_p->cfi)) ||
            ((DL_RES_BLKS_6RBS != configCellReq_p->dlResBlocks) && (MAX_POSSIBLE_CFI_VALUE == configCellReq_p->cfi)) 
       )
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid value received for configCellReq_p->cfi[%u]" 
                "or configCellReq_p->dlResBlocks[%u] for internalCellIndex[%u] from cfg",
                configCellReq_p->cfi,configCellReq_p->dlResBlocks,internalCellIndex);
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_CFI_VALUE;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->cfi;
#endif
        return MAC_FAILURE;
    }
    /* SPR 19309 - */
    /* SPR 19310 + */

    configCellReq_p->numEUL =  LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    configCellReq_p->sizeEUL =  LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    LOG_MAC_INFO(MAC_RRC_INF,"MAC_MANDATORY_CONFIG_CELL_REQ_PARAM_SET3: cfi[%u] numEUL[%u] sizeEUL[%u] internalCellIndex[%u]",
            configCellReq_p->cfi, configCellReq_p->numEUL,configCellReq_p->sizeEUL,internalCellIndex);
    /* Validation Check for numEUL and sizeEUL not required as its range is 0-65535 */
    /* SPR 19310 - */
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : getDlBandwidthCellConfigReq
 * Inputs         : configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                   cellParams_p - pointer to cell specific params structure
 * Outputs        : None
 * Returns        : None
 * Description    : This function sets the DL Bandwidth in Cell Config 
 *                  Request structure.
 ****************************************************************************/
/* CA Changes start */
STATIC  void getDlBandwidthCellConfigReq( 
        ConfigCellReq *configCellReq_p)
/* +- SPR 17777 */
{
    switch(configCellReq_p->dlResBlocks)
    {
        case DL_RES_BLKS_6RBS:
        {
            configCellReq_p->dlBandwidth = DL_BW_1DOT4_MHZ;
            break;
        }
        case DL_RES_BLKS_15RBS:
        {
            configCellReq_p->dlBandwidth = DL_BW_3_MHZ;
            /*Dynamic Pdcch Changes Start*/
            getCountofOverLapRB = calNumOfRbFromBitmapfor3Mhz; 
            /*Dynamic Pdcch Changes End*/
            break;
        }
        case DL_RES_BLKS_25RBS:
        {
            configCellReq_p->dlBandwidth = DL_BW_5_MHZ;
            /*Dynamic Pdcch Changes Start*/
            getCountofOverLapRB = calNumOfRbFromBitmapfor5Mhz; 
            /*Dynamic Pdcch Changes End*/
            break;
        }
        case DL_RES_BLKS_50RBS:
        {
            configCellReq_p->dlBandwidth = DL_BW_10_MHZ;
            /*Dynamic Pdcch Changes Start*/
            getCountofOverLapRB = calNumOfRbFromBitmapfor10Mhz; 
            /*Dynamic Pdcch Changes End*/
            break;
        }
        case DL_RES_BLKS_75RBS:
        {
            configCellReq_p->dlBandwidth = DL_BW_15_MHZ;
            /*Dynamic Pdcch Changes Start*/
            getCountofOverLapRB = calNumOfRbFromBitmapfor20And15Mhz; 
            /*Dynamic Pdcch Changes End*/
            break;
        }
        case DL_RES_BLKS_100RBS:
        {
            configCellReq_p->dlBandwidth = DL_BW_20_MHZ;
            /*Dynamic Pdcch Changes Start*/
            getCountofOverLapRB = calNumOfRbFromBitmapfor20And15Mhz; 
            /*Dynamic Pdcch Changes End*/
            break;
        }
    }
}

/* CA Changes end */
#ifdef TDD_CONFIG
/****************************************************************************
 * Function Name  : validateTddConfigCellParams 
 * Inputs         : msgBuf - Incoming message buffer,
 *                  remLen_p - Remaining length of the incoming message,
 *                  configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates the  TDD Cell Config parameters
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType validateTddConfigCellParams( UInt8 **msgBuf,
        UInt16 *remLen_p, ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex)
{
    UInt16 tag    = 0;
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;
    /* CA TDD Changes Start */
    UInt16 index = 0; /* Loop variable for internalCellIndex */
    CellState cellState;
    /* CA TDD Changes End */

    msg_p = *msgBuf;

    tag = LTE_GET_U16BIT(msg_p);
    msg_p += SIZEOF_UINT16;
    if (TDD_CONFIG_INFO != tag)
    {
        lteWarning("Invalid TDD_CONFIG_INFO tag");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid TDD_CONFIG_INFO tag");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    msg_p += 2;
    remLen  -= TAG_LEN;

    if (remLen < TDD_CONFIG_LEN)
    {
        lteWarning("Remaining length is less than TDD_CONFIG_LEN");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining length is less than TDD_CONFIG_LEN");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    configCellReq_p->subFrameAssign = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    /*
     * Range check for subFrameAssign
     */
    if ( (configCellReq_p->subFrameAssign > MAC_TDD_MAX_SUBFRAME_ASSIGN) || 
            (configCellReq_p->subFrameAssign == UL_DL_CONFIG_5 && IS_CA_ENABLED()))
    {
        lteWarning("Invalid subFrameAssign = %d", 
                configCellReq_p->subFrameAssign);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->subFrameAssign,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid subFrameAssign");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    configCellReq_p->splSubFramePatterns = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    /*
     * Range check for splSubFramePatterns
     */
    if (configCellReq_p->splSubFramePatterns > MAC_TDD_MAX_SPECIAL_SUBFRAME)
    {
        lteWarning("Invalid splSubFramePatterns = %d",\
                configCellReq_p->splSubFramePatterns);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->splSubFramePatterns,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid splSubFramePatterns");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* CA TDD Changes Start */
    if (IS_CA_ENABLED())
    {
        for (index = 0; index < macParams_g.numCellsConfigured; ++index)
        {
            if (internalCellIndex == index)
            {
                continue;
            }
            else
            {
                cellState = cellSpecificParams_g.cellConfigAndInitParams_p[index]->cellState;
                /* to validate the TDD configuration is same for both cells */
                if(
/* SPR 18708 Fix Start */
/* SPR 18708 Fix End*/
                        ((cellState >= CELL_WAIT_FOR_PHY_START && 
                          cellState < CELL_WAITING_FOR_PHY_STOP_AFTER_DELETE_REQ) || 
                         (cellState > CELL_PHY_STOP && cellState < CELL_CTRL_MAX_ST)))
                {
                    if ((configCellReq_p->subFrameAssign != 
                                cellSpecificParams_g.cellConfigAndInitParams_p
                                [index]->cellParams_p->subFrameAssign) ||
                            (configCellReq_p->splSubFramePatterns != 
                             cellSpecificParams_g.cellConfigAndInitParams_p
                             [index]->cellParams_p->splSubFramePatterns))
                    {
                        LOG_MAC_MSG(MAC_VALIDATE_TDD_CONFIG_CA_ENABLED_CELLS,LOGERROR,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                internalCellIndex, 
                                configCellReq_p->subFrameAssign,
                                configCellReq_p->splSubFramePatterns,
                                index, 
                                cellSpecificParams_g.cellConfigAndInitParams_p\
                                [index]->cellParams_p->subFrameAssign, 
                                cellSpecificParams_g.cellConfigAndInitParams_p\
                                [index]->cellParams_p->splSubFramePatterns, 
                                DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME, 
                                "MAC_VALIDATE_TDD_CONFIG_CA_ENABLED_CELLS:"\
                                "Different values for subFrameAssign and "\
                                "splSubFramePatterns received"\
                                "for P-Cell and S-Cell");
                        return MAC_FAILURE;
                    }
                }
                else
                {
                    continue;
                }
            }
        }/* loop end here */
    }
    /* CA TDD Changes End */
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_TDD_CONFIG_INFO_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->subFrameAssign,
            configCellReq_p->splSubFramePatterns, 
            internalCellIndex, 
            DEFAULT_INT_VALUE,
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_TDD_CONFIG_INFO_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}
#endif

/****************************************************************************
 * Function Name  : parseCellRachPreambleConfig
 * Inputs         : tagLen - length of tag,
 *                  numContnBasedPreambles - number of CONTN Based Preambles,
 *                  msgBuf - Incoming message buffer,
 *                  remLen_p - Remaining length of the incoming message,
 *                  numOfPreamblesInGroupA_p - address of number of preambles in Group A,
 *                  messageSizeGroupA_p - message size of Group A,
 *                  preambleGroupAConfigFlag_p - preamble configuration flag
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the RACH Preamble Group Config params
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType parseCellRachPreambleConfig( UInt16 tagLen,
        UInt32 numContnBasedPreambles, UInt8 **msgBuf, UInt16 *remLen_p,
        UInt32 *numOfPreamblesInGroupA_p, UInt32 *messageSizeGroupA_p,
        UInt32 *preambleGroupAConfigFlag_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt16 tag    = 0;
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    if(RACH_CONFIG_WITH_PREAMBLE_GROUPA_CONFIG_LEN == tagLen)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        if (PREAMBLE_GROUP_A_CONFIG != tag)
        {
            lteWarning("Invalid RACH TAG ");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tag,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid RACH TAG");
            /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
            cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_TAG;
            cellConfigFailValues_g[internalCellIndex][1] = tag;
            cellConfigFailValues_g[internalCellIndex][2] = PREAMBLE_GROUP_A_CONFIG;
#endif
            return MAC_FAILURE;
        }

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        if (PREAMBLE_GROUP_A_CONFIG_LEN != tagLen)
        {
            return MAC_FAILURE;
        }
        *numOfPreamblesInGroupA_p  = *msg_p++;
        *messageSizeGroupA_p      = LTE_GET_U16BIT(msg_p);
        /* Review comment fix start SYNC_LOSS_2*/
        LOG_MAC_MSG(MAC_PREAMBLE_GROUP_A_CONFIG_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                *numOfPreamblesInGroupA_p,
                *messageSizeGroupA_p, 
                internalCellIndex, 
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_PREAMBLE_GROUP_A_CONFIG_PARAM");
        /* Review comment fix end SYNC_LOSS_2*/
        msg_p += 2;

        if ((MAC_MIN_COUNT_OF_CONTENTION_BASED_RA_PREAMBLES >
                    *numOfPreamblesInGroupA_p) || 
                (MAC_MAX_COUNT_OF_CONTENTION_BASED_GROUPA_PREAMBLES <
                 *numOfPreamblesInGroupA_p))
        {
            LOG_MAC_MSG(INVALID_RACH_CONFIG,LOGWARNING,MAC_RRC_INF, 
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    numContnBasedPreambles,
                    *numOfPreamblesInGroupA_p,
                    *messageSizeGroupA_p,
                    LINE_NUMBER,
                    internalCellIndex,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE, 
                    FUNCTION_NAME,"INVALID_NUM_GROUPA_PREAMBLE");
            return MAC_FAILURE;
        }    

        if (!((PREAMBLE_GROUPA_MSG_SIZE_B56 == *messageSizeGroupA_p) ||
                    (PREAMBLE_GROUPA_MSG_SIZE_B144 == *messageSizeGroupA_p) ||
                    (PREAMBLE_GROUPA_MSG_SIZE_B208 == *messageSizeGroupA_p) ||
                    (PREAMBLE_GROUPA_MSG_SIZE_B256 == *messageSizeGroupA_p)) ) 
        {
            LOG_MAC_MSG(INVALID_RACH_CONFIG,LOGWARNING,MAC_RRC_INF, 
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    numContnBasedPreambles,
                    *numOfPreamblesInGroupA_p,
                    *messageSizeGroupA_p,
                    LINE_NUMBER,
                    internalCellIndex,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE, 
                    FUNCTION_NAME,"INVALID_GROUPA_MSG_SIZE");
            return MAC_FAILURE;
        }
        *preambleGroupAConfigFlag_p = 1;
        remLen -= RACH_CONFIG_WITH_PREAMBLE_GROUPA_CONFIG_LEN;
        if (remLen < TAG_LEN)
        {
#ifdef LOG_PRINT_ENABLED
            cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_REM_LEN_TWO;
            cellConfigFailValues_g[internalCellIndex][1] = remLen;
            cellConfigFailValues_g[internalCellIndex][2] = TAG_LEN;
#endif
            return MAC_FAILURE;
        }
    }
    else if(RACH_CONFIG_LEN == tagLen)
    {    
        remLen -= RACH_CONFIG_LEN;
        if (remLen < TAG_LEN)
        {
            lteWarning("Remaining Length is less than tag len for "\
                    "PHICH CONFIG INFO");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Remaining Length is less than \
                    tag len for PHICH CONFIG INFO");
            /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
            cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_REM_LEN_TWO;
            cellConfigFailValues_g[internalCellIndex][1] = remLen;
            cellConfigFailValues_g[internalCellIndex][2] = TAG_LEN;
#endif
            return MAC_FAILURE;
        }
    }
    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatePhichAndPucchConfigCellInfo 
 * Inputs         : msgBuf - Incoming message buffer,
 *                  remLen_p - Remaining length of the incoming message,
 *                  n1PUCCH_AN_p,
 *                  deltaPUCCH_Shift_p,
 *                  nRB_CQI_p,
 *                  nCS_AN_p,
 *                  configCellReq_p - ponter to structure passed to fill the 
 *                                    configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates the PHICH and PUCCH Config params
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType validatePhichAndPucchConfigCellInfo( UInt8 **msgBuf,
        UInt16 *remLen_p, UInt16 *n1PUCCH_AN_p, UInt8 *deltaPUCCH_Shift_p,
        UInt8 *nRB_CQI_p, UInt8 *nCS_AN_p, ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt16 tag    = 0;
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if (PHICH_CONFIG_INFO != tag)
    {
        lteWarning("INVALID PHICH TAG");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "INVALID PHICH TAG");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PHICH_TAG;
        cellConfigFailValues_g[internalCellIndex][1] = tag;
        cellConfigFailValues_g[internalCellIndex][2] = PHICH_CONFIG_INFO;
#endif
        return MAC_FAILURE;
    }
    msg_p += 2;

    remLen -= TAG_LEN;
    if (remLen < PHICH_CONFIG_LEN)
    {
        lteWarning("Remaining Length is less than PHICH_CONFIG_LEN");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length \
                is less than PHICH_CONFIG_LEN");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PHICH_CONFIG_LEN;
        cellConfigFailValues_g[internalCellIndex][1] = remLen;
        cellConfigFailValues_g[internalCellIndex][2] = PHICH_CONFIG_LEN;
#endif
        return MAC_FAILURE;
    }

    configCellReq_p->phichDuration = *msg_p++;
    if (configCellReq_p->phichDuration != PHICH_DURATION_0 && 
            configCellReq_p->phichDuration != PHICH_DURATION_1)
    {
        lteWarning("Invalid PHICH DURATION PARAMETER = %d",configCellReq_p->phichDuration);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->phichDuration,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid PHICH DURATION PARAMETER");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PHICH_DURATION;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->phichDuration;
#endif
        return MAC_FAILURE;
    }
    configCellReq_p->phichResource = *msg_p++;
    if (configCellReq_p->phichResource != PHICH_RESOURCE_0 &&
            configCellReq_p->phichResource != PHICH_RESOURCE_1 &&
            configCellReq_p->phichResource != PHICH_RESOURCE_2 && 
            configCellReq_p->phichResource != PHICH_RESOURCE_3)
    {
        lteWarning("Invalid PHICH RESOURCE PARAMETER = %d",configCellReq_p->phichResource);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->phichResource,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid PHICH RESOURCE PARAMETER");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PHICH_RESOURCE;
        cellConfigFailValues_g[internalCellIndex][1] = configCellReq_p->phichResource;
#endif
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_PHICH_CONFIG_INFO_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->phichDuration,
            configCellReq_p->phichResource, 
            internalCellIndex, 
            DEFAULT_INT_VALUE,
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_PHICH_CONFIG_INFO_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/
    remLen -= PHICH_CONFIG_LEN;

    /* PUCCH CONFIG INFO */
    if (remLen < TAG_LEN)
    {
        lteWarning("Remaining Length is less than tag len for PUCCH CONFIG INFO");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length is less than\
                tag len for PUCCH CONFIG INFO");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_REM_LEN_THREE;
        cellConfigFailValues_g[internalCellIndex][1] = remLen;
        cellConfigFailValues_g[internalCellIndex][2] = TAG_LEN;
#endif
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (PUCCH_CONFIG_INFO != tag)
    {
        lteWarning("Invalid tag for PUCCH CONFIG INFO");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tag for PUCCH CONFIG INFO");
        /* Review comment fix end RJ13 */

#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PUCCH_CONFIG;
        cellConfigFailValues_g[internalCellIndex][1] = tag;
        cellConfigFailValues_g[internalCellIndex][2] = PUCCH_CONFIG_INFO;
#endif
        return MAC_FAILURE;
    }
    msg_p += 2;

    remLen -= TAG_LEN;
    if (remLen < PUCCH_CONFIG_LEN)
    {
        lteWarning("Remaining Length is less than  PUCCH CONFIG LEN");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length is \
                less than  PUCCH CONFIG LEN");
        /* Review comment fix end RJ13 */

#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PUCCH_CONFIG_LEN;
        cellConfigFailValues_g[internalCellIndex][1] = remLen;
        cellConfigFailValues_g[internalCellIndex][2] = PUCCH_CONFIG_LEN;
#endif
        return MAC_FAILURE;
    }
    *deltaPUCCH_Shift_p = *msg_p++;
    if ( *deltaPUCCH_Shift_p != Ds1 && *deltaPUCCH_Shift_p != Ds2 &&
            *deltaPUCCH_Shift_p != Ds3 )
    {
        lteWarning("Invalid deltaPUCCH_Shift = %d",*deltaPUCCH_Shift_p);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                *deltaPUCCH_Shift_p,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid deltaPUCCH_Shift");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PUCCH_DELTA_SHIFT;
        cellConfigFailValues_g[internalCellIndex][1] = *deltaPUCCH_Shift_p;
#endif
        return MAC_FAILURE;
    }    

    *nRB_CQI_p = *msg_p++;
    if (*nRB_CQI_p > MAC_MAX_NRB_CQI)
    {
        lteWarning("Invalid nRB_CQI= %d",*nRB_CQI_p);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                *nRB_CQI_p,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid nRB_CQI");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PUCCH_nRB_CQI;
        cellConfigFailValues_g[internalCellIndex][1] = *nRB_CQI_p;
#endif
        return MAC_FAILURE;
    }
    *nCS_AN_p = *msg_p++;
    if (*nCS_AN_p > MAC_MAX_NCS_AN)
    {
        lteWarning("Invalid nCS_ANI= %d",*nCS_AN_p);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                *nCS_AN_p,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid nCS_ANI");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PUCCH_nCS_AN;
        cellConfigFailValues_g[internalCellIndex][1] = *nCS_AN_p;
#endif
        return MAC_FAILURE;
    }
    *n1PUCCH_AN_p = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if (*n1PUCCH_AN_p > MAC_MAX_N1_PUCCH_AN)
    {
        lteWarning("Invalid n1PUCCH_AN = %d",*n1PUCCH_AN_p);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                *n1PUCCH_AN_p,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid n1PUCCH_AN");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_PUCCH_n1PUCCH_AN;
        cellConfigFailValues_g[internalCellIndex][1] = *n1PUCCH_AN_p;
#endif
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_PUCCH_CONFIG_INFO_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            *deltaPUCCH_Shift_p,
            *nRB_CQI_p,
            *nCS_AN_p,
            *n1PUCCH_AN_p, 
            internalCellIndex, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_PUCCH_CONFIG_INFO_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/
    remLen -= PUCCH_CONFIG_LEN;

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseRBSelectionAndBroadcastMsgParams 
 * Inputs         : msgBuf - Incoming message buffer,
 *                  remLen_p - Remaining length of the incoming message,
 *                  configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                  cellParams_p - pointer to cell specific params structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the RB Selection table and Broadcast
 *                  message parameters and updates in the Cell config request 
 *                  structure.
 ****************************************************************************/
/* CA Changes start */
STATIC  MacRetType parseRBSelectionAndBroadcastMsgParams(
        /* +- SPR 17777 */
        UInt8 **msgBuf, UInt16 *remLen_p,
        /* +- SPR 17777 */
        CellConfigParams *cellParams_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt32 retval = MAC_SUCCESS;    
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    /*
     * Fill all RBSelectionTableDCI1A_g and RBSelectionTableDCI1C_g
     * by defaultFillRB selection function table 1A and 1C.
     * In case of RBS_FOR_DCI_1A will be avalable then RBSelectionTableDCI1A_g
     * will be filled by RB's given by L3.
     * In case of RBS_FOR_DCI_1C will be avalable then RBSelectionTableDCI1C_g
     * will be filled by RB's given by L3.
     */
    tag = LTE_GET_U16BIT(msg_p);

    if(RBS_FOR_DCI_1A == tag)
    {
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        tagLen -= 4;
        remLen -= TAG_LEN;
        /* CA Changes start */
        if(DCI_1A_CH_RB_MAP_LEN != fillRBSelectionTableforDCIFormat1A(&msg_p, 
                    tagLen,cellParams_p ) )
            /* +- SPR 17777 */
        {
            return MAC_FAILURE;
        }
        remLen -= DCI_1A_CH_RB_MAP_LEN;
        tag = LTE_GET_U16BIT(msg_p);
    }
    else
    {
        defaultFillRBSelectionTableForDCI1A(cellParams_p);
    }

    if(RBS_FOR_DCI_1C == tag)
    {
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        tagLen -= 4;
        remLen -= TAG_LEN;

        if(DCI_1C_CH_RB_MAP_LEN != fillRBSelectionTableforDCIFormat1C(&msg_p,
                    tagLen,cellParams_p))
        {
            return MAC_FAILURE;
        }

        remLen -= DCI_1C_CH_RB_MAP_LEN;
        tag = LTE_GET_U16BIT(msg_p);
    }
    else
    {
        defaultFillRBSelectionTableForDCI1C(cellParams_p);
    }

    /* Broadcast Msg */
    retval = parseAndStoreBroadcastMsg(&msg_p,&remLen, TRUE, 
            getSysFrameNumer(internalCellIndex),
            internalCellIndex);
    /* CA Changes end */
    if (MAC_SUCCESS != retval)
    {
        lteWarning(" Process and Store Broadcast Message Failed ");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                retval,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Process and Store Broadcast Message Failed");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_BCCH_VAL;
        cellConfigFailValues_g[internalCellIndex][1] = retval;
#endif
        return MAC_FAILURE;
    }
    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/* CA Changes end */
/****************************************************************************
 * Function Name  : validateSrsAndPdschConfigCellParams
 * Inputs         : msgBuf - Incoming message buffer,
 *                  remLen_p - Remaining length of the incoming message,
 *                  configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates the SRS and PDSCH Config params
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType validateSrsAndPdschConfigCellParams( UInt8 **msgBuf,
        UInt16 *remLen_p, ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt32 retval = MAC_SUCCESS;    
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    /* Parse the SRS Common configuration from RRC buffer
       Parsing of SRS_COMMON_CONFIG starts 
       */
    tag = LTE_GET_U16BIT(msg_p); 
    if (SRS_COMMON_CONFIG == tag)
    {
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        retval = parseSRSCommonConfigInfo(msg_p, tagLen, configCellReq_p
                /* CA Changes start */
                , internalCellIndex 
                /* CA Changes end */
                );
        if (MAC_FAILURE == retval)
        {
            /* lteWarning logs shall appear from inside parseSRSCommonConfigInfo
             * so only returning FAILURE */
#ifdef LOG_PRINT_ENABLED
            cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] =INVALID_SRS_VAL;
            cellConfigFailValues_g[internalCellIndex][1] = retval;
#endif
            return MAC_FAILURE;
        }
        /* increament the msg pointer to end of SRS Common config */
        msg_p += (tagLen - 2*sizeof(UInt16));
        remLen -= tagLen;
    }
    else
    {
        lteWarning("Mandatory Fields for common SRS config missing\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory Fields for common SRS config missing");
        /* Review comment fix end RJ13 */
#ifdef LOG_PRINT_ENABLED
        cellConfigFailValues_g[internalCellIndex][FAIL_TYPE_OFFSET] = INVALID_SRS_TAG;
        cellConfigFailValues_g[internalCellIndex][1] = tag;
        cellConfigFailValues_g[internalCellIndex][2] = SRS_COMMON_CONFIG ;
#endif
        return MAC_FAILURE;
    }

    /* parsePdschConfigCommonInfo Begin*/
    tag = LTE_GET_U16BIT(msg_p);
    if(PDSCH_CONFIG_COMMON_INFO != tag)
    {
        lteWarning("Invalid Tag for PDSCH_CONFIG_COMMON_INFO\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag for PDSCH_CONFIG_COMMON_INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    msg_p += 2;
    tagLen = LTE_GET_U16BIT(msg_p);
    remLen -= TAG_LEN;
    /*Checking if all the mandatory parameters are present*/
    if(remLen < PDSCH_CONFIG_COMMON_INFO_PARAM_LENGTH)
    {
        lteWarning("Remaining Length is less than PDSCH_CONFIG_COMMON_INFO_PARAM_LENGTH\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length is less than \
                PDSCH_CONFIG_COMMON_INFO_PARAM_LENGTH");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    /* increment pointer to point to start of the parameters */
    msg_p += 2; 
    retval = parsePdschConfigCommonInfo(msg_p, configCellReq_p
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if(MAC_FAILURE == retval)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PDSCH_CONFIG_COMMON_INFO");
        return MAC_FAILURE;
    }
    /*Updating the remLen*/
    remLen -= PDSCH_CONFIG_COMMON_INFO_PARAM_LENGTH;
    /* increament the msg pointer to end of PDSCH_CONFIG_COMMON_INFO */
    msg_p += (tagLen - 2*sizeof(UInt16));
    /* parsePdschConfigCommonInfo End*/

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatePowerCtrlAndPuschConfigCellParams 
 * Inputs         : msgBuf - Incoming message buffer,
 *                  remLen_p - Remaining length of the incoming message,
 *                  configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates Power Control and PUSCH Config 
 *                  params and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType validatePowerCtrlAndPuschConfigCellParams(
        UInt8 **msgBuf, UInt16 *remLen_p, ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt32 retval = MAC_SUCCESS;    
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    /* DOWNLINK_POWER_CONTROL_COMMON Begin*/
    tag = LTE_GET_U16BIT(msg_p);
    if(DOWNLINK_POWER_CONTROL_COMMON != tag)
    {
        lteWarning("Invalid Tag for DOWNLINK_POWER_CONTROL_COMMON\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag for DOWNLINK_POWER_CONTROL_COMMON");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    msg_p += 2;

    tagLen = LTE_GET_U16BIT(msg_p);
    remLen -= TAG_LEN;
    /*Checking if all the mandatory parameters are present*/
    if(remLen < DOWNLINK_POWER_CONTROL_COMMON_PARAM_LENGTH)
    {
        lteWarning("Remaining Length is less than DOWNLINK_POWER_CONTROL_COMMON_PARAM_LENGTH\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length is less than \
                DOWNLINK_POWER_CONTROL_COMMON_PARAM_LENGTH");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    msg_p += 2;
    retval = parseCommonDLPowerControlInfo(msg_p, configCellReq_p
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if(MAC_FAILURE == retval)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "COMMON_DL_POWER_CONTROL_INFO.");

        return MAC_FAILURE;
    }

    /*Updating the remLen*/
    remLen -= DOWNLINK_POWER_CONTROL_COMMON_PARAM_LENGTH;
    /* increament the msg pointer to end of PDSCH_CONFIG_COMMON_INFO */
    msg_p += (tagLen - 2*sizeof(UInt16));
    /* DOWNLINK_POWER_CONTROL_COMMON End*/

    /*UPLINK_POWER_CONTROL_COMMON  Begin*/
    tag = LTE_GET_U16BIT(msg_p);
    if(UPLINK_POWER_CONTROL_COMMON != tag)
    {
        lteWarning("Invalid Tag for UPLINK_POWER_CONTROL_COMMON\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag for UPLINK_POWER_CONTROL_COMMON");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    msg_p += 2;
    tagLen = LTE_GET_U16BIT(msg_p);
    remLen -= TAG_LEN;
    /*Checking if all the mandatory parameters are present*/
    if(remLen < UPLINK_POWER_CONTROL_COMMON_PARAM_LENGTH)
    {
        lteWarning("Remaining Length is less than UPLINK_POWER_CONTROL_COMMON_PARAM_LENGTH\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length is less than \
                UPLINK_POWER_CONTROL_COMMON_PARAM_LENGTH");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    msg_p += 2;
    retval = parseCommonULPowerControlInfo(msg_p, configCellReq_p
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if(MAC_FAILURE == retval)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "COMMON_UL_POWER_CONTROL_INFO.");

        return MAC_FAILURE;
    }

    /*Updating the remLen*/
    remLen -= UPLINK_POWER_CONTROL_COMMON_PARAM_LENGTH;
    /* increament the msg pointer to end of PDSCH_CONFIG_COMMON_INFO */
    msg_p += (tagLen - 2*sizeof(UInt16));
    /*UPLINK_POWER_CONTROL_COMMON End*/

    /* initialize optional parameters with default values whereever required */ 
    /* Initailize power control enable structure */

    /*SPR 4026 Start*/
    /* Changing the default values of these parameters as disabled*/

    configCellReq_p->powerControlEnableInfo.harqBlerClpcPucchEnable = FALSE;
    configCellReq_p->powerControlEnableInfo.cqiSinrClpcPucchEnable = FALSE; 
    configCellReq_p->powerControlEnableInfo.clpcPuschEnable = FALSE; 
    configCellReq_p->powerControlEnableInfo.pdcchPowOrAggregationEnable = FALSE; 
    configCellReq_p->powerControlEnableInfo.clpcPuschfreqSelectiveEnable = FALSE; 
    /*SPR 4026 End*/

    /* Initializing TPC_RNTI_RANGE structure */
    configCellReq_p->tpcRntiRange.startTpcRntiPucch = INVALID_TPC_RNTI;
    configCellReq_p->tpcRntiRange.endTpcRntiPucch = INVALID_TPC_RNTI;
    configCellReq_p->tpcRntiRange.startTpcRntiPusch = INVALID_TPC_RNTI;
    configCellReq_p->tpcRntiRange.endTpcRntiPusch = INVALID_TPC_RNTI;

    /* Initializing SPS CRNTI Range */
    configCellReq_p->spsCommonCellInfo.startSpsCRnti = INVALID_SPS_CRNTI;
    configCellReq_p->spsCommonCellInfo.endSpsCRnti = INVALID_SPS_CRNTI;

    /*SPR 3600 Start*/
    /*PUSCH Config Common Begin*/
    tag = LTE_GET_U16BIT(msg_p);
    if(PUSCH_CONFIG_COMMON != tag)
    {
        lteWarning("Invalid Tag for PUSCH_CONFIG_COMMON\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag for PUSCH_CONFIG_COMMON");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    msg_p += 2;
    tagLen = LTE_GET_U16BIT(msg_p);
    remLen -= TAG_LEN;
    /*Checking if mandatory parameters are present*/
    if(remLen < PUSCH_CONFIG_COMMON_PARAM_LENGTH)
    {
        lteWarning("Remaining Length is less than PUSCH_CONFIG_COMMON_PARAM_LENGTH\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Remaining Length is less than \
                PUSCH_CONFIG_COMMON_PARAM_LENGTH");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    msg_p += 2;

    configCellReq_p->puschConfigCommonInfo.enable64QAM = *msg_p;
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_PUSCH_CONFIG_COMMON_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->puschConfigCommonInfo.enable64QAM,
            internalCellIndex, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_PUSCH_CONFIG_COMMON_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/

    msg_p += 1;
    /*Updating the remLen*/
    remLen -=  PUSCH_CONFIG_COMMON_PARAM_LENGTH;
    /*SPR 3600 End*/

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}


/****************************************************************************
 * Function Name  : parseOptionalCellConfigParams 
 * Inputs         : msg_p - Incoming message buffer,
 *                  remLen - Remaining length of the incoming message,
 *                  configCellReq - ponter to structure passed to fill the 
 *                                  configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the optional TLVs Cell Config params 
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType parseOptionalCellConfigParams( UInt8 *msg_p,
        UInt16 remLen, ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex)
{
    UInt32 retval = MAC_SUCCESS;    
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
    CellConfigParams *cellParams_p = cellSpecificParams_g.cellConfigAndInitParams_p
        [internalCellIndex]->cellParams_p; 
#ifdef LTE_EMBMS_SUPPORTED    
    UInt8 isEmbmsParsingFailed=FALSE;
#endif    
    /* CA Changes end */
#ifdef LTE_EMBMS_SUPPORTED           
    resetEmbmsParsingInfo(internalCellIndex);       
#endif    
    while (remLen > TAG_LEN)
    {
        tag = LTE_GET_U16BIT(msg_p); 
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        remLen -= TAG_LEN;
        switch (tag)
        {
            /* +- SPR 19066 */
            case CONTENTION_FREE_RACH_TIMER_INFO: 
            {
                /* Cyclomatic_complexity_changes_start */
                retval = parseCellContentionFreeRachTimerInfo (tag, 
                        tagLen, &remLen, &msg_p, 
                        configCellReq_p
                        /* CA Changes start */
                        ,internalCellIndex 
                        /* CA Changes end */
                        );
                /* Cyclomatic_complexity_changes_end */


            }
            break;
            case FREQUENCY_SELECTIVE_ENABLE:
            {
                /* Cyclomatic_complexity_changes_start */
                /* +- SPR 17777 */
                retval = parseCellFreqSelectiveEnableInfo (
                        &remLen, &msg_p, 
                        configCellReq_p
                        /* CA Changes start */
                        , internalCellIndex 
                        /* CA Changes end */
                        );
                /* Cyclomatic_complexity_changes_end */
            }
            break;
            /*SPR_3061_FIX*/
            case PUCCH_CQI_SINR_THRESHOLD_INFO:
            {  
                /* Cyclomatic_complexity_changes_start */
                retval = parseCellPucchCqiSinrInfo (tag, tagLen, 
                        &remLen, &msg_p, 
                        configCellReq_p
                        /* CA Changes start */
                        , internalCellIndex 
                        /* CA Changes end */
                        );
                /* Cyclomatic_complexity_changes_end */

                break;
            }
            case UL_SYNC_LOSS_TIMER_INFO:
            {
                /* Cyclomatic_complexity_changes_start */
                retval = parseCellULSyncLossTimerInfo (tag, tagLen, 
                        &remLen, &msg_p, 
                        configCellReq_p
                        /* CA Changes start */
                        , internalCellIndex 
                        /* CA Changes end */
                        );
                /* Cyclomatic_complexity_changes_end */
                break;
            }
            case NGAP_VALUE:
            {
                /* Cyclomatic_complexity_changes_start */
                /* CA Changes start */
                /* SPR 12813 Changes Start */
                retval = parseCellNGapValueInfo (tagLen, 
                        &remLen, &msg_p,cellParams_p,configCellReq_p,internalCellIndex);
                /* SPR 12813 Changes End */
                /* CA Changes end */
                /* Cyclomatic_complexity_changes_end */
                break;
            }
            /*SPR_3061_FIX*/
            case EXPLICIT_CELL_START_REQUIRED:
            {  
                /* Cyclomatic_complexity_changes_start */
                /* CA Changes start */
                retval = parseExplicitCellStartReqdInfo (
                        &remLen, &msg_p, configCellReq_p,internalCellIndex);
                /* CA Changes end */
                /* Cyclomatic_complexity_changes_end */
                break;
            }
            case POWER_CONTROL_ENABLE:
            {
                /*Checking if all the mandatory parameters are present*/
                if(remLen >= POWER_CONTROL_ENABLE_PARAM_LENGTH)
                {
                    retval = parsePowerControlEnablelInfo(msg_p, configCellReq_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            );
                    if(MAC_FAILURE == retval)
                    {
                        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                LINE_NUMBER,DEFAULT_INT_VALUE,POWER_CONTROL_ENABLE,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "POWER_CONTROL_ENABLE");
                        return MAC_FAILURE;
                    }
                    /*Updating the remLen*/                                                            
                    remLen -= (tagLen - TAG_LEN);
                    /* increament the msg pointer to end of
                     * PDSCH_CONFIG_COMMON_INFO */
                    msg_p += (tagLen - 2*sizeof(UInt16));
                }
                else
                {
                    /* Remaining Length is less than POWER_CONTROL_ENABLE_PARAM_LENGTH*/
                    return MAC_FAILURE;
                }
                break;
            }

            case TPC_RNTI_RANGE:
            {
                /*Checking if all the mandatory parameters are present*/
                if (remLen >= TPC_RNTI_PARAM_LENGTH)
                {
                    retval = parseTpcRntiRange(msg_p, configCellReq_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            );
                    if(MAC_FAILURE == retval)
                    {
                        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                LINE_NUMBER,DEFAULT_INT_VALUE,TPC_RNTI_RANGE,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "TPC_RNTI_RANGE.");

                        return MAC_FAILURE;
                    }
                    /*Updating the remLen*/
                    remLen -= TPC_RNTI_PARAM_LENGTH;
                    /* increament the msg pointer to end of
                     * PDSCH_CONFIG_COMMON_INFO */
                    msg_p += (tagLen - 2*sizeof(UInt16));
                }
                else
                {
                    /* Remaining Length is less than TPC_RNTI_PARAM_LENGTH*/
                    return MAC_FAILURE;
                }
                break;
            }
            /*Dynamic Pdcch Changes Start*/
            case DYNAMIC_PDCCH_INFO:
            {
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_DYNAMIC_PDCCH_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        *msg_p,
                        internalCellIndex, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_DYNAMIC_PDCCH_INFO_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/
                if ((remLen >= DYNAMIC_PDCCH_INFO_REM_LEN)
                        &&(tagLen == DYNAMIC_PDCCH_INFO_TAG_MIN_LEN)&&(*msg_p == 1))
                {    
                    configCellReq_p->isDynamicPdcchDisabled = *msg_p++;
                    remLen = remLen - 1;
                }
                else 
                {
                    return MAC_FAILURE;
                }
                break;
            }
            /*Dynamic Pdcch Changes End*/
            /*! \code
             * Added case for sps TAGS Received from L3
             * \endcode
             * */
            case SPS_CRNTI_RANGE:
            {
                /*Checking if all the mandatory parameters are present*/
                if (remLen >= SPS_RNTI_PARAM_LENGTH - TAG_LEN)
                {
                    retval = parseSpsRntiRange(msg_p, configCellReq_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            );
                    if(MAC_FAILURE == retval)
                    {
                        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                LINE_NUMBER,DEFAULT_INT_VALUE,SPS_CRNTI_RANGE,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_CRNTI_RANGE");

                        return MAC_FAILURE;
                    }
                    /*Updating the remLen*/
                    remLen -= (SPS_RNTI_PARAM_LENGTH - TAG_LEN);
                    /* increament the msg pointer to end SPS_CRNTI_RANGE */
                    msg_p += (tagLen - TAG_LEN);
                }
                else
                {
                    /* Remaining Length is less than SPS_RNTI_PARAM_LENGTH*/
                    return MAC_FAILURE;
                }
                break;
            }
            case PRS_CONFIG_INFO:
            {
                /*Checking if all the mandatory parameters are present*/
                if ((remLen >=  PRS_CONFIG_INFO_MIN_LEN - TAG_LEN) &&
                        ((tagLen >= PRS_CONFIG_INFO_MIN_LEN ) &&
                         (tagLen  <= PRS_CONFIG_INFO_MAX_LEN) ))
                {
                    PRSParseConfigInfo *prsParseConfigInfo_p =
                        &(configCellReq_p->prsParseConfigInfo);

                    prsParseConfigInfo_p->isPRSConfigured = *msg_p++;
                    /* Review comment fix start SYNC_LOSS_2*/
                    LOG_MAC_MSG(MAC_PRS_CONFIG_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            prsParseConfigInfo_p->isPRSConfigured,
                            internalCellIndex, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, "MAC_PRS_CONFIG_INFO_PARAM");
                    /* Review comment fix end SYNC_LOSS_2*/
                    if ( (PRS_RELEASE != prsParseConfigInfo_p->isPRSConfigured) &&
                            (PRS_SETUP != prsParseConfigInfo_p->isPRSConfigured))
                    {
                        return MAC_FAILURE;
                    }
                    else if ( PRS_SETUP == prsParseConfigInfo_p->isPRSConfigured)
                    {
                        retval = parsePRSConfigInfo(msg_p,prsParseConfigInfo_p,
                                tagLen,configCellReq_p->dlResBlocks,FALSE
                                /* CA changes Start */
                                , internalCellIndex
                                /* CA Changes end */
                                );
                        if(MAC_FAILURE == retval)
                        {
                            LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID, LOGWARNING,MAC_RRC_INF,
                                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                    LINE_NUMBER, DEFAULT_INT_VALUE, PRS_CONFIG_INFO,
                                    internalCellIndex,DEFAULT_INT_VALUE,
                                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                    FUNCTION_NAME,
                                    "PRS_CONFIG_INFO");

                            return MAC_FAILURE;
                        }

                    }
                    /*Updating the remLen*/
                    remLen -= (tagLen - TAG_LEN);
                }
                else
                {
                    /* Remaining Length is less than required or Taglen is wrong*/
                    return MAC_FAILURE;
                }

                break;
            }
#ifdef LTE_EMBMS_SUPPORTED
              case EMBMS_CONFIG_INFO:
                {
                    LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC: EMBMS_CONFIG_INFO Tag  received cellIndex:%u\n",internalCellIndex);
					if (remLen >= EMBMS_CONFIG_INFO_LEN - TAG_LEN)
                    {
                        retval = parseEMBMSConfigInfo(&msg_p,
                                &(cellParams_p->eMbmsTransPower),
                                &remLen);
                        if(MAC_FAILURE == retval)
                        {
                            isEmbmsParsingFailed = TRUE;

							LOG_MSG(MAC_TAG_PARSE_FAILURE_ID, LOGWARNING,MAC_RRC_INF,
									GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
									LINE_NUMBER, DEFAULT_INT_VALUE, EMBMS_CONFIG_INFO,
									internalCellIndex,DEFAULT_INT_VALUE,
									DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
									FUNCTION_NAME,
									"EMBMS_CONFIG_INFO");

                        }
                        remLen -= EMBMS_CONFIG_INFO_LEN - TAG_LEN ;
                    }
                    else
                    {
                        // Remainig Length is less than required or Taglen is wrong 
                        LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                    remLen,\
                                                    EMBMS_CONFIG_INFO_LEN - TAG_LEN);
                        return MAC_FAILURE;
                    }
                    /* CID 97623 fix*/
                    break;

                }
        case SIB13_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:SIB13_INFO Tag received cellIndex:%u\n",internalCellIndex);
                retval = parseSIB13Info(tagLen,
                                        &remLen,
                                        &msg_p,
                                        &(eMBMSCreateAreaReq_g[internalCellIndex].sib13Info));

                if(MAC_FAILURE == retval)
                {
                    isEmbmsParsingFailed = TRUE;
                }

            }
            break;
        case EMBMS_SIB2_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:EMBMS_SIB2_INFO Tag received cellIndex:%u\n",internalCellIndex);
                /*CID 106979*/
                if(tagLen >= EMBMS_SIB2_INFO_LEN)
                /*CID 106979*/
                {
                    retval = parseSIB2Info(&msg_p,
                                           &remLen,
                                           &(eMBMSCreateAreaReq_g[internalCellIndex].sib2Info));
			

                    if(MAC_FAILURE == retval)
                    {
                        isEmbmsParsingFailed = TRUE;
                    }
                    else
                    {
                           /*SPR 18809 fix start*/    
			if(eMBMSCreateAreaReq_g[internalCellIndex].sib2Info.noOfCsaPattern)
                        {

                        /* making csa nodes for SIB2*/ 
                            retval = getEmbmsValidSfFromCSAPattern(internalCellIndex,
    	                            eMBMSCreateAreaReq_g[internalCellIndex].sib2Info.noOfCsaPattern,
        	                    eMBMSCreateAreaReq_g[internalCellIndex].sib2Info.csaPatternList); 
			}
			if (retval == MAC_SUCCESS)
	   	   	{
			embmsConfigParams_g[internalCellIndex].sib2UpdateFlag = TRUE;
			getSib2Occasion(internalCellIndex);
			}
                       /*SPR 18809 fix start*/    
                    }

                }
                else
                {
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                EMBMS_SIB2_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }

            }
            break;
        case MAC_CREATE_MBMS_AREA_ENTITY_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:MAC_CREATE_MBMS_AREA_ENTITY_INFO Tag received cellIndex:%u\n",internalCellIndex);
				if ((remLen >= CREATE_MBMS_AREA_INFO_LEN - TAG_LEN) && 
						(tagLen > CREATE_MBMS_AREA_INFO_LEN ))
                {
                   retval = parseCreateMBMSAreaReq(&msg_p,
                                    &(eMBMSCreateAreaReq_g[internalCellIndex].embmsAreaEntity),
                                    tagLen-TAG_LEN,
                                    internalCellIndex);
                  
                   if(MAC_FAILURE == retval)
                   {
                       isEmbmsParsingFailed = TRUE;
                        /*SPR 18197 fix*/
#ifdef LTE_EMBMS_UESIM_TESTING
                        sib13AreaInfo_g[internalCellIndex][CREATE_AREA_INFO_PTR].buff_p = PNULL;
#endif
                   }
                   else
                   {
                       remLen -= (tagLen - TAG_LEN);

                       eMBMSCreateAreaReceived_g[internalCellIndex]=TRUE;
                   } 
                }
                else
                {
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                CREATE_MBMS_AREA_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }
            }
            break;
        case MAC_DELETE_MBMS_AREA_ENTITY_INFO:
            {
                LOG_MAC_INFO(L2_EMBMS_CAT,"RRC->MAC:MAC_DELETE_MBMS_AREA_ENTITY_INFO Tag received cellIndex:%u\n",internalCellIndex);

                if((remLen >= DELETE_MBMS_AREA_INFO_LEN - TAG_LEN) &&
                    (tagLen >= DELETE_MBMS_AREA_INFO_LEN ))
                {
                    retval = parseDeleteMBMSAreaReq(&msg_p,
                                                    tagLen,
                                                    &eMBMSDeleteAreaReq_g[internalCellIndex],
                                                    &remLen,
                                                    internalCellIndex
                                                    );
                    if(MAC_FAILURE == retval)
                    {
                        isEmbmsParsingFailed = TRUE;
                        /*SPR 18197 fix*/
#ifdef LTE_EMBMS_UESIM_TESTING
                        sib13AreaInfo_g[internalCellIndex][DELETE_AREA_INFO_PTR].buff_p = PNULL;
#endif
                    }
                    else
                    {
                       eMBMSDeleteAreaReceived_g[internalCellIndex]=TRUE;
                    }    
                }
                else
                {
                    LOG_MAC_ERROR(L2_EMBMS_CAT,"Parsing Failed: Failure due to incorrect length remLen:%u min expected len:%u\n",\
                                                remLen,\
                                                DELETE_MBMS_AREA_INFO_LEN - TAG_LEN);
                    retval = MAC_FAILURE;
                }
            }
            break;
#endif
            default:
            {
                LOG_MAC_MSG(MAC_INAVLID_TAG_MSG_ID, LOGWARNING, MAC_RRC_INF, 
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),tag,tagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"INVALID_TAG_ID");
                return MAC_FAILURE;
            }
        }

        if(retval == MAC_FAILURE)
        {
#ifdef LTE_EMBMS_SUPPORTED
        embmsConfigParams_g[internalCellIndex].isParsingFailed =isEmbmsParsingFailed;
#endif
            return MAC_FAILURE;
        }
		/* Cyclomatic_complexity_changes_end */
	}
#ifdef LTE_EMBMS_SUPPORTED
    if(MAC_FAILURE == verifyAreaRequestAndDelete(internalCellIndex))
    {
        return MAC_FAILURE;
    }
    processEmbmsConfiguration(internalCellIndex);
    embmsConfigParams_g[internalCellIndex].isParsingFailed = FALSE;
#endif    
#if (defined(LTE_EMBMS_SUPPORTED) && defined(LTE_EMBMS_UESIM_TESTING))        
    sendSIB13InfoToUESIM(internalCellIndex);
#endif        
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCellContentionFreeRachTimerInfo 
 * Inputs         : tag - tag field,
 *                  tagLen - length of tag,
 *                  remLen_p - Remaining length of the incoming message,
 *                  msgBuf - Incoming message buffer,
 *                  configCellReq_p - ponter to structure passed to fill the 
 *                                    configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Contention Free Rach Timer params 
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType parseCellContentionFreeRachTimerInfo( UInt16 tag,
        UInt16 tagLen, UInt16 *remLen_p, UInt8 **msgBuf,
        ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    if ((remLen >= CONTENTION_FREE_RACH_TIMER_REM_LEN)
            &&(tagLen == CONTENTION_FREE_RACH_TIMER_TAG_MIN_LEN) )
    {    
        configCellReq_p->contnFreeRachTimer = LTE_GET_U16BIT(msg_p);
		LOG_MAC_INFO(MAC_RRC_INF,
				 /*+- SPR 19066 */
				"CONTENTION_FREE_RACH_TIMER_INFO[%u]",tagLen);
        msg_p += 2;
        remLen -= CONTENTION_FREE_RACH_TIMER_REM_LEN;
        if ((configCellReq_p->contnFreeRachTimer < MAC_MIN_CFR_TIMER_VAL)||
                (configCellReq_p->contnFreeRachTimer > MAC_MAX_CFR_TIMER_VAL))
        {
			LOG_MAC_WARNING(MAC_RRC_INF,
					 /*+- SPR 19066 */
					"INVALID_CFR_TIMER[%u]",tagLen);
            return MAC_FAILURE;
        }
    }
    else
    {
		LOG_MAC_WARNING (MAC_RRC_INF,
                /*+- SPR 19066 */
				"Invalid tagLen for CFR Timer[%u]",tagLen);
        return MAC_FAILURE;
    }
    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCellFreqSelectiveEnableInfo 
 * Inputs          : 
 *                  remLen_p - Remaining length of the incoming message,
 *                  msgBuf - Incoming message buffer,
 *                  configCellReq_p - ponter to structure passed to fill the
 *                                    configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Freqeuncy Selective Enable params 
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
/* +- SPR 17777 */
STATIC  MacRetType parseCellFreqSelectiveEnableInfo(
        UInt16 *remLen_p, UInt8 **msgBuf, ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt32 retval = MAC_SUCCESS;    
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    if(remLen >= FREQ_SELECTIVE_MIN_TAG_LEN - TAG_LEN)
    {
        configCellReq_p->freqSelectiveSchUL = *msg_p++;
        retval = validateFreqSelectiveEnable(
                configCellReq_p->freqSelectiveSchUL);
        if(MAC_FAILURE == retval)
        {
            LOG_MAC_MSG(MAC_PARSE_CELL_CONFIGURE_ID,LOGWARNING,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    configCellReq_p->freqSelectiveSchUL,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"ulFreqSelectiveEnable");
            return MAC_FAILURE;
        }

        configCellReq_p->freqSelectiveSchDL = *msg_p++;
        retval = validateFreqSelectiveEnable(
                configCellReq_p->freqSelectiveSchDL);
        if(MAC_FAILURE == retval)
        {
            LOG_MAC_MSG(MAC_PARSE_CELL_CONFIGURE_ID,LOGWARNING,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    configCellReq_p->freqSelectiveSchDL,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"dlFreqSelectiveEnable");
            return MAC_FAILURE;
        }
    }
    else
    {
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_FREQUENCY_SELECTIVE_ENABLE_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->freqSelectiveSchUL,
            configCellReq_p->freqSelectiveSchDL, 
            internalCellIndex, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_FREQUENCY_SELECTIVE_ENABLE_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/
    remLen -= (FREQ_SELECTIVE_MIN_TAG_LEN - TAG_LEN);

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCellPucchCqiSinrInfo
 * Inputs         : tag - tag field,
 *                  tagLen - length of tag,
 *                  remLen_p - Remaining length of the incoming message,
 *                  msgBuf - Incoming message buffer,
 *                  configCellReq_p - ponter to structure passed to fill the 
 *                                    configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PUCCH CQI SINR Threshold params 
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType parseCellPucchCqiSinrInfo( UInt16 tag, UInt16 tagLen,
        UInt16 *remLen_p, UInt8 **msgBuf, ConfigCellReq *configCellReq_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    if ((remLen >=PUCCH_CQI_SINR_THRESHOLD_REM_LEN)
            &&(PUCCH_CQI_SINR_THRESHOLD_MIN_LEN == tagLen)) 
    {
        configCellReq_p->pucchCQISINRThreshold = *msg_p;

        msg_p += PUCCH_CQI_SINR_THRESHOLD_REM_LEN ;
        remLen -= PUCCH_CQI_SINR_THRESHOLD_REM_LEN;
        /* Review comment fix start SYNC_LOSS_2*/
        LOG_MAC_MSG(MAC_FREQUENCY_SELECTIVE_ENABLE_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->pucchCQISINRThreshold,
                DEFAULT_INT_VALUE, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_FREQUENCY_SELECTIVE_ENABLE_PARAM");
        /* Review comment fix end SYNC_LOSS_2*/
    }
    else
    {
		LOG_MAC_WARNING(MAC_RRC_INF,
                /*+- SPR 19066 */
				"Invalid tagLen[%u]",tagLen);
        return MAC_FAILURE;
    }

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCellULSyncLossTimerInfo 
 * Inputs         : tag - tag field,
 *                  tagLen - length of tag,
 *                  remLen_p - Remaining length of the incoming message,
 *                  msgBuf - Incoming message buffer,
 *                  configCellReq_p - ponter to structure passed to fill the 
 *                                    configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UL Sync Loss Timer information 
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
STATIC  MacRetType parseCellULSyncLossTimerInfo( UInt16 tag,
        UInt16 tagLen, UInt16 *remLen_p, UInt8 **msgBuf, 
        ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    if ((remLen >=UL_SYNC_LOSS_TIMER_INFO_REM_LEN)
            &&(UL_SYNC_LOSS_TIMER_INFO_MIN_LEN == tagLen)) 
    {
        configCellReq_p->ulSyncLossTimer = LTE_GET_U16BIT(msg_p);
        msg_p += UL_SYNC_LOSS_TIMER_INFO_REM_LEN ;
        remLen -= UL_SYNC_LOSS_TIMER_INFO_REM_LEN;
        if (configCellReq_p->ulSyncLossTimer > MAX_UL_SYNC_LOSS_TIMER)
        {
			LOG_MAC_WARNING(MAC_RRC_INF,
                     /* +- SPR 19066 */
					"SYNCLOSS_TIMER[%u]",tagLen);
            return MAC_FAILURE;
        }
        /* Review comment fix start SYNC_LOSS_2*/
        LOG_MAC_MSG(MAC_UL_SYNC_LOSS_TIMER_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->ulSyncLossTimer,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_UL_SYNC_LOSS_TIMER_INFO_PARAM");
        /* Review comment fix end SYNC_LOSS_2*/
    }
    else
    {
		LOG_MAC_WARNING(MAC_RRC_INF,
				/* +- SPR 19066 */
				"Invalid tagLen[%u]",tagLen);
        return MAC_FAILURE;
    }

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCellNGapValueInfo 
 * Inputs         : tagLen - Tag length 
 *                  remLen_p - Remaining length of the incoming message
 *                  msgBuf - Incoming message buffer
 *                  cellParams_p - pointer to cell specific params structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the NGAP value information 
 *                  and updates in the Cell config request structure.
 ****************************************************************************/
/* CA Changes start */
/* SPR 12813 Changes Start */
STATIC  MacRetType parseCellNGapValueInfo( UInt16 tagLen,
        UInt16 *remLen_p, UInt8 **msgBuf,CellConfigParams *cellParams_p,
        ConfigCellReq *configCellReq_p, InternalCellIndex internalCellIndex)
/* SPR 12813 Changes End */
/* CA Changes end */
{
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;
    /* + coverity 32768 */
    NGapType nGapValue = NGAP1;  
    /* - coverity 32768 */

    msg_p = *msgBuf;

    if ((remLen >= NGAP_TAG_REM_LENGTH) && (NGAP_TAG_LEN_VALUE == tagLen)) 
    {
        /* + coverity 32765 */
        nGapValue = (NGapType) *msg_p;
        /* - coverity 32765 */
        msg_p += NGAP_TAG_REM_LENGTH;
        remLen -= NGAP_TAG_REM_LENGTH;
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_NGAP_VALUE_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                nGapValue,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_NGAP_VALUE_PARAM");
        /* Review comment fix end SYNC_LOSS_1*/
        /* CA Changes start */
        /* SPR 12813 Changes Start */
        if ((nGapValue > NGAP2)|| ((nGapValue == NGAP2) && 
                    (configCellReq_p->dlResBlocks <= DL_RES_BLKS_50RBS)))
            /* SPR 12813 Changes End */
        {
            return MAC_FAILURE;
        }
        cellParams_p->gapValue = (nGapValue == NGAP1)?GAP_VALUE_ONE:GAP_VALUE_TWO;
        /* CA Changes end */
    }
    else
    {
        return MAC_FAILURE;
    }

    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseExplicitCellStartReqdInfo 
 * Inputs         : remLen_p - Remaining length of the incoming message
 *                  msgBuf - Incoming message buffer
 *                  configCellReq_p - ponter to structure passed to fill the 
 *                   configuration details needed by MAC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Explicit Cell Start required info
 *                  and updates in the Cell config request structure.
 *****************************************************************************/
STATIC  MacRetType parseExplicitCellStartReqdInfo( UInt16 *remLen_p,
        UInt8  **msgBuf, ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 remLen = *remLen_p;

    msg_p = *msgBuf;

    if(remLen >= (EXPLICIT_CELL_START_REQUIRED_TAG_LEN - TAG_LEN) )
    {
        if(0 == *msg_p++)
        {
            configCellReq_p->explicitStartRequired = TRUE;
        }
        if( TRUE != configCellReq_p->explicitStartRequired )
        {
            LOG_MAC_MSG(MAC_PARSE_CELL_CONFIGURE_ID,LOGWARNING,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    configCellReq_p->explicitStartRequired,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "MAC Config explicitStartRequired Error");
            return MAC_FAILURE;
        }
    }
    else
    {
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_EXPLICIT_CELL_START_REQUIRED_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->explicitStartRequired,
            internalCellIndex, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_EXPLICIT_CELL_START_REQUIRED_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/
    remLen -= (EXPLICIT_CELL_START_REQUIRED_TAG_LEN - TAG_LEN);
    /* CA changes start */

    cellSpecificParams_g.cellConfigAndInitParams_p\
        [internalCellIndex]->cellState = CELL_WAIT_FOR_PHY_START; 
    /* + SPR_10009 */ 
    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
        explicitStartRequired = TRUE;
    /* - SPR_10009 */ 
    /* CA changes end */
    *remLen_p = remLen;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatenumOfTxAntennas 
 * Inputs         : numOfTxAntennas - Number of Transmission Antennas 
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This function validates Number of Transmission Antennas
 *            parameters and return the result of validation to the 
 *            calling function.
 ****************************************************************************/
STATIC  MacRetType  validateNumOfTxAntennas( UInt8 numOfTxAntennas)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((numOfTxAntennas != NUM_OF_TX_ANTENNAS_1) && 
            (numOfTxAntennas != NUM_OF_TX_ANTENNAS_2) &&
            (numOfTxAntennas != NUM_OF_TX_ANTENNAS_4))
    {
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}    

/* Cyclomatic Complexity changes - ends here */
/*--coverity-530 CID 52747 */
#ifdef MAC_AUT_TEST
/*--coverity-530 CID 52747 */
/****************************************************************************
 * Function Name  : validateRBs
 * Inputs         : configCellReq_p - Structure pointer that contain DL/UL RB .
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This function validates resource blocks and allocation type 
 *                  and return response of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateRBs( ConfigCellReq *configCellReq_p,
        InternalCellIndex internalCellIndex)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    if ((configCellReq_p->dlResBlocks < MAC_MIN_RESOURCE_BLOCKS) ||
            (configCellReq_p->dlResBlocks > MAC_MAX_RESOURCE_BLOCKS))
    {
        lteWarning("INVALID CONFIG DL RBS Parameters ");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->dlResBlocks,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "INVALID CONFIG DL RBS Parameters");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    else if ((configCellReq_p->ulResBlocks < MAC_MIN_RESOURCE_BLOCKS) ||
            (configCellReq_p->ulResBlocks > MAC_MAX_RESOURCE_BLOCKS))
    {
        lteWarning("INVALID CONFIG UL RBS Parameters ");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->ulResBlocks,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "INVALID CONFIG UL RBS Parameters");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validateHarqParams
 * Inputs         : maxHarqRetrans - Max HARQ Retransmissions
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This function validates harq profile parameters and return the 
 *                  result of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateHarqParams ( UInt8 maxHarqRetrans)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    if ((maxHarqRetrans < MAC_MIN_HARQ_RETRANSMISSIONS)
            ||(maxHarqRetrans > MAC_MAX_HARQ_RETRANSMISSIONS))
    {
        return MAC_FAILURE;
    }    
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validateStartRARntiRange
 * Inputs         : startRARntiRange - Start RARNTI range
 *                  endRARntiRange - End RARNTI range
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This function validates start RARNTI range
 *                  parameters and return the result of validation to the
 *                  calling function.
 ****************************************************************************/
STATIC  MacRetType  validateStartRARntiRange( UInt8 startRARntiRange,
        UInt8 endRARntiRange,
        InternalCellIndex internalCellIndex
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((startRARntiRange < cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->lowerRNTIBound) || (startRARntiRange >=
                    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                    initParams_p->upperRNTIBound) || (startRARntiRange >= endRARntiRange)) 
    {
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
/*Rel 5.3: Coverity 52739 Fix Start */
/* Removed validateEndRARntiRange() */
/*Rel 5.3: Coverity 52739 Fix End */

/****************************************************************************
 * Function Name  : validatePhichDuration 
 * Inputs         : phichDuration - extended  or normal cyclic prefix.
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This function validates phichDuration
 *                  parameters and return the result of validation to the
 *                  calling function.
 ****************************************************************************/

STATIC  MacRetType  validatePhichDuration( UInt8 phichDuration )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if (phichDuration != PHICH_DURATION_0 && phichDuration != PHICH_DURATION_1)
    {
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatePhichResource
 * Inputs         : phichResource - Ng value
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This function validates phichResource Ng value
 *                  parameters and return the result of validation to the
 *                  calling function.
 ****************************************************************************/
STATIC  MacRetType  validatePhichResource( UInt8 phichResource )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if (phichResource != PHICH_RESOURCE_0 && phichResource != PHICH_RESOURCE_1 && 
            phichResource != PHICH_RESOURCE_2 && phichResource !=
            PHICH_RESOURCE_3)
    {
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
#endif
/* SRS_CHG */
/****************************************************************************
 * Function Name  : parseSRSCommonConfigInfo
 * Inputs         : message_p - message buffer as passed by RRC
 *                  tagLength - tag length of SRS_DEDICATED_CONFIG
 *                  configCellReq_p - pointer to Cell structure where
 *                  information is stored after buffer parsing   
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/ MAC_FAILURE 
 * Description    : This function parses the SRS Common Config Information
 *                  that is received from RRC at the time of cell configuration
 *                  and Cell re-configuration
 ****************************************************************************/
STATIC MacRetType  parseSRSCommonConfigInfo(UInt8 *message_p,
        UInt16 tagLength, ConfigCellReq *configCellReq_p
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt16 tag = 0;
    UInt16 tagLen = tagLength;
    UInt8  *msg_p = message_p;

    if (SRS_COMMON_CONFIG_MIN_TAG_LEN > tagLen || 
            SRS_COMMON_CONFIG_MAX_TAG_LEN < tagLen)
    {
        lteWarning("Invalid SRS Common config TagLen. Value = %d\n",
                tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid SRS Common config TagLen");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    configCellReq_p->srsConfigType = *msg_p++;
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_SRS_COMMON_CONFIG_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->srsConfigType,
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE,
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_SRS_COMMON_CONFIG_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/
    if (SRS_COMMON_CONFIG_TYPE_RELEASE != configCellReq_p->srsConfigType && 
            SRS_COMMON_CONFIG_TYPE_SETUP != configCellReq_p->srsConfigType)
    {
        lteWarning("Invalid srsConfigType. Value = %d\n",
                configCellReq_p->srsConfigType);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->srsConfigType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid srsConfigType");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    /* Parsing of SRS_COMMON_SETUP_INFO starts */
    if(SRS_COMMON_CONFIG_TYPE_SETUP == configCellReq_p->srsConfigType)
    {
        tag = LTE_GET_U16BIT(msg_p); 
        if (SRS_COMMON_SETUP_INFO == tag)
        {
            msg_p += 2;
            tagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;
            if (SRS_COMMON_SETUP_INFO_MIN_TAG_LEN > tagLen || 
                    SRS_COMMON_SETUP_INFO_MAX_TAG_LEN < tagLen)
            {
                lteWarning("Invalid SRS Common setup info TagLen. Value = "
                        "%d\n",tagLen);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Common setup info TagLen");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            configCellReq_p->srsCommonSetupInfo.srsBandwidthConfig = *msg_p++;
            if(SRS_COMMON_CONFIG_MAX_BW_CONFIG < configCellReq_p->
                    srsCommonSetupInfo.srsBandwidthConfig)
            {
                lteWarning("Invalid SRS Bandwidth Config Value = %d\n",
                        configCellReq_p->srsCommonSetupInfo.srsBandwidthConfig);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        configCellReq_p->srsCommonSetupInfo.srsBandwidthConfig,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Bandwidth Config");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            configCellReq_p->srsCommonSetupInfo.srsSubframeConfig = *msg_p++;
            if(SRS_COMMON_CONFIG_MAX_SUBFRAME_CONFIG < configCellReq_p->
                    srsCommonSetupInfo.srsSubframeConfig)
            {
                lteWarning("Invalid SRS Subframe Config Value = %d\n",
                        configCellReq_p->srsCommonSetupInfo.srsSubframeConfig);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        configCellReq_p->srsCommonSetupInfo.srsSubframeConfig,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Subframe Config");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            configCellReq_p->srsCommonSetupInfo.ackNackSRSSimultaneousTrans =
                *msg_p++;
            if (TRUE != configCellReq_p->srsCommonSetupInfo.
                    ackNackSRSSimultaneousTrans && 
                    FALSE != configCellReq_p->srsCommonSetupInfo.
                    ackNackSRSSimultaneousTrans)
            {
                lteWarning("Invalid Ack Nack SRS Smultaneous trans Value = %d "
                        "\n", configCellReq_p->srsCommonSetupInfo.
                        ackNackSRSSimultaneousTrans);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        configCellReq_p->srsCommonSetupInfo.ackNackSRSSimultaneousTrans,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid Ack Nack SRS Smultaneous trans");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
            /* Review comment fix start SYNC_LOSS_2*/
            LOG_MAC_MSG(MAC_SRS_COMMON_SETUP_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    configCellReq_p->srsCommonSetupInfo.srsBandwidthConfig,
                    configCellReq_p->srsCommonSetupInfo.srsSubframeConfig, 
                    configCellReq_p->srsCommonSetupInfo.ackNackSRSSimultaneousTrans, 
                    internalCellIndex,
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "MAC_SRS_COMMON_SETUP_INFO_PARAM");
            /* Review comment fix end SYNC_LOSS_2*/
#ifdef TDD_CONFIG
            /* Parsing of SRS_MAX_UPPTS starts */
            tag = LTE_GET_U16BIT(msg_p); 
            if (SRS_MAX_UPPTS == tag)
            {
                msg_p += 2;
                tagLen = LTE_GET_U16BIT(msg_p);
                msg_p += 2;
                if (SRS_DEDICATED_CONFIG_UPPTS_TAG_LEN != tagLen)
                {
                    lteWarning("Invalid SRS MAX UPPTS TagLen. Value = "
                            "%d\n",tagLen);
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            tagLen,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid SRS MAX UPPTS TagLen");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                configCellReq_p->srsCommonSetupInfo.srsMaxUpPts = *msg_p++;
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_SRS_MAX_UPPTS_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        configCellReq_p->srsCommonSetupInfo.srsMaxUpPts,
                        internalCellIndex,
                        DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_SRS_MAX_UPPTS_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/
            }
#endif
        }
        else
        {
            lteWarning("The srsCellConfigType received setup with no config \
                    parameters\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "The srsCellConfigType received setup\
                    with no config parameters");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseSRSDedicatedConfigInfo
 * Inputs         : message_pp - message buffer as passed by RRC
 *                  tagLen - tag length of SRS_DEDICATED_CONFIG
 *                  ulUEInfo_p - pointer to UE context for uplink where
 *                  information is stored after buffer parsing   
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/ MAC_FAILURE 
 * Description    : This function parses the SRS Dedicated Config Information
 *                  that is received from RRC in both Create UE config and at
 *                  the time of re config UE.
 ****************************************************************************/
STATIC MacRetType  parseSRSDedicatedConfigInfo(UInt8 **message_pp,
        UInt16 tagLength, UeContextForUplink *ulUEInfo_p 
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    UInt8   *msg_p = PNULL;
    UInt16  tag = 0;
    UInt16  tagLen = tagLength;

    msg_p = *message_pp;

    if (SRS_DEDICATED_CONFIG_MIN_TAG_LEN > tagLen ||
            SRS_DEDICATED_CONFIG_MAX_TAG_LEN < tagLen)
    {
        lteWarning("Invalid SRS Dedicated Config tag len. Value = %d\n",
                tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid SRS Dedicated Config tag len");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulUEInfo_p->srsConfigType = *msg_p++;
    if (SRS_DEDICATED_CONFIG_TYPE_RELEASE != ulUEInfo_p->srsConfigType && 
            SRS_DEDICATED_CONFIG_TYPE_SETUP != ulUEInfo_p->srsConfigType)
    {
        lteWarning("Invalid srsConfigType. Value = %d\n",
                ulUEInfo_p->srsConfigType);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->srsConfigType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid srsConfigType");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    if(tagLen - SRS_DEDICATED_CONFIG_MIN_TAG_LEN)
    {
        tag = LTE_GET_U16BIT(msg_p);
        if (SRS_DEDICATED_SETUP_INFO == tag)
        {
            msg_p += 2;
            tagLen = LTE_GET_U16BIT(msg_p); 
            msg_p += 2;

            if (SRS_DEDICATED_CONFIG_TAG_LEN != tagLen)
            {
                lteWarning("Invalid SRS Dedicated Config tag len. "
                        "Value = %d\n", tagLen);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Dedicated Config tag len");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.srsBandwidth = 
                *msg_p++;
            if (SRS_DEDICATED_CONFIG_MAX_BANDWIDTH < ulUEInfo_p->
                    srsDedicatedSetupInfo.srsBandwidth)
            {
                lteWarning("Invalid SRS Bandwidth. Value = %d\n", 
                        ulUEInfo_p->srsDedicatedSetupInfo.
                        srsBandwidth);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.srsBandwidth,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Bandwidth");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.srsHoppingBandwidth = 
                *msg_p++;
            if (SRS_DEDICATED_CONFIG_MAX_HOPPING_BANDWIDTH < ulUEInfo_p->
                    srsDedicatedSetupInfo.srsHoppingBandwidth)
            {
                lteWarning("Invalid SRS Hopping Bandwidth. "
                        "Value = %d\n", ulUEInfo_p->
                        srsDedicatedSetupInfo.srsHoppingBandwidth);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.srsHoppingBandwidth,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Hopping Bandwidth");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.freqDomainPos = *msg_p++;
            if (SRS_DEDICATED_CONFIG_MAX_FREQ_DOMAIN_POSITION < ulUEInfo_p->
                    srsDedicatedSetupInfo.freqDomainPos)
            {
                /* SRS_FDD */
                lteWarning("Invalid SRS Freq domain position. Value = %d\n", 
                        ulUEInfo_p->srsDedicatedSetupInfo.freqDomainPos); 
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.freqDomainPos,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Freq domain position");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.duration = *msg_p++;
            if (TRUE != ulUEInfo_p->srsDedicatedSetupInfo.duration 
                    && 
                    FALSE != ulUEInfo_p->srsDedicatedSetupInfo.duration)
            {
                lteWarning("Invalid Duration. Value = %d\n", 
                        ulUEInfo_p->srsDedicatedSetupInfo.duration);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.duration,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid Duration");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.srsConfigIndex = 
                LTE_GET_U16BIT(msg_p); 
            msg_p += 2;
            if (SRS_DEDICATED_CONFIG_MAX_SRS_CONFIG_INDEX < ulUEInfo_p->
                    srsDedicatedSetupInfo.srsConfigIndex)
            {
                lteWarning("Invalid SRS Config Index. Value = %d\n", 
                        ulUEInfo_p->srsDedicatedSetupInfo.
                        srsConfigIndex);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.srsConfigIndex,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Config Index");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.transmissionComb = 
                *msg_p++;
            if (SRS_DEDICATED_CONFIG_MAX_TRANSMISSION_COMB < ulUEInfo_p->
                    srsDedicatedSetupInfo.transmissionComb)
            {
                lteWarning("Invalid SRS Trans Comb. Value = %d\n", 
                        ulUEInfo_p->srsDedicatedSetupInfo.
                        transmissionComb);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.transmissionComb,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Trans Comb");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

            ulUEInfo_p->srsDedicatedSetupInfo.cyclicShift = 
                *msg_p++;
            if (SRS_DEDICATED_CONFIG_MAX_CYCLIC_SHIFT < ulUEInfo_p->
                    srsDedicatedSetupInfo.cyclicShift)
            {
                lteWarning("Invalid SRS Cyclic shift. Value = %d\n", 
                        ulUEInfo_p->srsDedicatedSetupInfo.
                        cyclicShift);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->srsDedicatedSetupInfo.cyclicShift,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid SRS Cyclic shift");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
        }
    }
    *message_pp = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCreateUEEntityReq
 * Inputs         : msg_p - pointer to the input buffer
 *                  msgLen - length of the API message received
 *                  ulCreateReq_p - pointer to uplink create UE structure
 *                  dlCreateReq_p - pointer to downlink create UE structure
 *                  transactionId - random id generated which should be same for
 *                                  request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to create a UE context.
 ****************************************************************************/
STATIC  MacRetType parseCreateUEEntityReq( UInt8 *msg_p,
        UInt16 msgLen,
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        /* +- SPR 17777 */
        /* CA changes Start */
        InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 retval = MAC_SUCCESS;    
    UInt16 tag             = 0;
    UInt16 tagLen          = 0;
    UInt16 addUEInfoTagLen = 0;
    UInt8 absLoopCount = 0;

#ifdef HD_FDD_CONFIG
    UInt8 hdFddFlag = FALSE;
#endif
    /* Initializing default value of user location type 
     * This will be used in case option tag USER_LOCATION_TYPE is 
     * not present in CREATE_UE_ENTITY Message*/
    ulCreateReq_p->userLocationType = CC_USER;
    dlCreateReq_p->userLocationType = CC_USER;
    /* ICIC changes end*/

    /*UL_MU_MIMO_CHG_START*/
    ulCreateReq_p->ulMUMIMOStatus = UL_MU_MIMO_DISABLED;
    /*UL_MU_MIMO_CHG_END*/

    ulCreateReq_p->cqiinfoflag  = FALSE;
    dlCreateReq_p->cqiInfoFlag  = FALSE;
    /* SPR 5084 changes starts */
    ulCreateReq_p->ueCategoryReqType = FALSE;
    dlCreateReq_p->ueCategoryReqType = FALSE;
    /* SPR 5084 changes ends */

    dlCreateReq_p->Rat1Support = FALSE;

    dlCreateReq_p->ueCategory  = 0;

    /* Handling of SR Setup */
    ulCreateReq_p->requestType  = INVALID_SR_REQ_TYPE;
    /* Handling of Periodic CQI Setup */
    ulCreateReq_p->cqiRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    /* + SPR 5953 Fix */ 
    dlCreateReq_p->cqiRequestType = INVALID_PERIODIC_CQI_REQ_TYPE; 
    /* - SPR 5953 Fix */ 
    ulCreateReq_p->numLogicalChannels = 0;
    dlCreateReq_p->dwlkLogicalChCount = 0;
    /* SPR 3879 FIX START */
    ulCreateReq_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;            
    /* SPR 3879 FIX END */
    ulCreateReq_p->puschConfigInfoFlag = FALSE;
    ulCreateReq_p->srsRequestType = FALSE; 
    /* + DRX_CHG */
    dlCreateReq_p->drxRequestType = FALSE;
    /* - DRX_CHG */
    /* +MEAS_GAP_CHG */
    dlCreateReq_p->measGapRequestType = FALSE;
    /* - MEAS _GAP_CHG */
    /*SPR_3061_FIX*/
    dlCreateReq_p->timeAlignmentTimer = TIME_ALIGNMENT_TIMER_INFINITY;
    /*SPR_3061_FIX*/
    /*Fix for __SPR_1988__ END*/
    /* + CQI_4.1 */ 
    ulCreateReq_p->cqiMode = INVALID_APERIODIC_CQI_MODE;
    /* + Coverity 55038 */
    dlCreateReq_p->cqiMode = CQI_MODE_INVALID;
    /* - Coverity 55038 */
    dlCreateReq_p->cqiIndication = INVALID_CQI_REPORTING_MODE;
    /* - CQI_4.1 */

    /* SPS_CHG */
    /* Initialize optional parameter with default values */
    dlCreateReq_p->isSpsDlInfoPresent = FALSE;
    dlCreateReq_p->spsDownlinkInfo.requestType = SPS_RELEASE;
    dlCreateReq_p->spsDownlinkInfo.spsDownlinkSetupInfo.\
        N1PucchAnPersistentListVal.numOfN1PucchAnPersistent = 0;
    dlCreateReq_p->spsDownlinkInfo.spsDownlinkSetupInfo.\
        isMaxSpsHarqRetxPresent = FALSE;
    dlCreateReq_p->spsDownlinkInfo.spsDownlinkSetupInfo.\
        isExplicitReleaseAfterPresent = FALSE;
    ulCreateReq_p->isSpsUlInfoPresent = FALSE;
    ulCreateReq_p->spsUplinkInfo.requestType = SPS_RELEASE;
    ulCreateReq_p->spsUplinkInfo.spsUplinkSetupInfo.\
        isP0TagPresent = FALSE;
    ulCreateReq_p->spsUplinkInfo.spsUplinkSetupInfo.\
        isTwoIntervalConfigPresent = FALSE;

    ulCreateReq_p->ttiBundlingEnabled = TTIB_DISABLED;

    /* SPS_CHG */ 

    /* SPR 5713 changes start */
    ulCreateReq_p->ueComplianceRelease = RELEASE_9;
    /* SPR 5713 changes end */

    /* HD FDD changes start */
#ifdef HD_FDD_CONFIG
    dlCreateReq_p->isHDFddFlag = hdFddFlag;
    ulCreateReq_p->isHDFddFlag = hdFddFlag;
#endif
    /* HD FDD changes end */

    /* +DYNAMIC_ICIC */
    ulCreateReq_p->phrGrant = 0;
    /* -DYNAMIC_ICIC */

    /* + TM7_8 Changes Start */
    dlCreateReq_p->pmiRiReportV920 = INVALID_PMI_RI_CONF_V920;
    ulCreateReq_p->pmiRiReportV920 = INVALID_PMI_RI_CONF_V920;
    dlCreateReq_p->pdschEpreToUeRsRatio = 0;
    /* SPR 21043 Start */
    ulCreateReq_p->cqiMaskV920 = INVALID_8_VAL;
    /* SPR 21043 End */

    ulCreateReq_p->cqiPMIConfigIndex_2 = MAC_MAX_CQI_PMI_CONFIG_INDEX + 1;
    ulCreateReq_p->riConfigIndex_2 = MAC_RI_CONFIG_INDEX_INVALID;

    for (absLoopCount=0; absLoopCount<MAX_CSI_MEASUREMENT_PATTERN; absLoopCount++)
    {
        ulCreateReq_p->csiMeasurementSubset1[absLoopCount] = 0;
        ulCreateReq_p->csiMeasurementSubset2[absLoopCount] = 0;
    }
    ulCreateReq_p->cqiConfigRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    dlCreateReq_p->cqiConfigRequestType = ulCreateReq_p->cqiRequestType;
    ulCreateReq_p->cqiSubsetConfigRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    dlCreateReq_p->cqiSubsetConfigRequestType = ulCreateReq_p->cqiSubsetConfigRequestType;
    ulCreateReq_p->userType= NON_VICTIM_UE;
    dlCreateReq_p->userType = NON_VICTIM_UE;
    ulCreateReq_p->userTypePresent = LTE_FALSE;
    dlCreateReq_p->userTypePresent = LTE_FALSE;
    /* - TM7_8 Changes End */

    /* check if mandatory fields are present 
       CREATE_UE_ENTITY_MIN_LEN 27  */
    if (  msgLen < CREATE_UE_ENTITY_MIN_LEN )
    {
        lteWarning("Mandatory fields missing in CREATE_UE_ENTITY.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                msgLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory fields missing in CREATE_UE_ENTITY");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    dlCreateReq_p->rrcUeIndex = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    dlCreateReq_p->ueIndex = getUeIdxFromRrcUeIdx(dlCreateReq_p->rrcUeIndex);
    if (INVALID_UE_ID == dlCreateReq_p->ueIndex)
    {
        dlCreateReq_p->ueIndex = allocateUeIdxFromRrcUeIdx(dlCreateReq_p->rrcUeIndex); //RANDOM UEID
        /* SPR 4864 fix start */
        if (MAX_UE_SUPPORTED > dlCreateReq_p->ueIndex) 
        {
            setUeIdxValid(dlCreateReq_p->ueIndex, UE_IDX_MAPPING_FOR_MAC);
        }
        /* SPR 4864 fix end */
        /* SPR 20872 Fix Start */
        else
        {
            /*Since assigned UEIndex is greater or equal to INVALID_UE_ID
             * (MAX_UE_SUPPORTED) we send failure to L3*/
            return MAC_FAILURE;
        }
        /* SPR 20872 Fix End*/
    }
    /* SPR 4849 Fix End */
    /* SPR 4558 Fix End */
    /* Cyclomatic Complexity changes - starts here */
    if (MAC_SUCCESS != validateAndParseCreateUEEntityParams (
                &msg_p, &addUEInfoTagLen,
                ulCreateReq_p, dlCreateReq_p
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ))
    {
        return MAC_FAILURE;
    }
    /* Cyclomatic Complexity changes - ends here */

    msgLen -= CREATE_UE_ENTITY_MIN_LEN;
    addUEInfoTagLen -= ADD_UE_MANDATORY_LENGTH;

    /* SPR 1372 fix */
    /* SPR 1372 fix */

    /* If Optional Parameter  SR / CQI Info is present then
       addUEInfoTagLen must be greater than zero */
    /* initialize optional parametere with default values */
    dlCreateReq_p->tpcPdcchConfigPucch.release = TRUE;
    dlCreateReq_p->tpcPdcchConfigPucch.tpcRnti = INVALID_TPC_RNTI;
    dlCreateReq_p->tpcPdcchConfigPucch.tpcBitMapIndex = INVALID_TPC_OFFSET;
    dlCreateReq_p->tpcPdcchConfigPucch.isConfiguredForDci3Or3A = DCI_FORMAT_3;
    ulCreateReq_p->tpcPdcchConfigPusch.release = TRUE;
    ulCreateReq_p->tpcPdcchConfigPusch.tpcRnti = INVALID_TPC_RNTI;
    ulCreateReq_p->tpcPdcchConfigPusch.tpcBitMapIndex = INVALID_TPC_OFFSET;
    ulCreateReq_p->tpcPdcchConfigPusch.isConfiguredForDci3Or3A = DCI_FORMAT_3;
    ulCreateReq_p->dedicatedULPowerControlInfo.p0UePusch = 0;
    ulCreateReq_p->dedicatedULPowerControlInfo.accumulationEnabled = FALSE;
    ulCreateReq_p->dedicatedULPowerControlInfo.deltaMcsEnabled = FALSE;

    /* CA changes Start */
    /* initialize optional parametere UE_CATEGORY_V1020/PUCCH/CA CONFIG Info 
     * with default values */
    macInitCAParams(ulCreateReq_p, dlCreateReq_p);
    /* CA changes End */


    /* Cyclomatic Complexity changes - starts here */
    if (MAC_SUCCESS != parseCreateUEReqParams( &msg_p, 
                &msgLen, addUEInfoTagLen, ulCreateReq_p, dlCreateReq_p 
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ))
    {
        return MAC_FAILURE;
    }

	LOG_MAC_MSG(RRC_CREATE_UE_ENTITY_ID,LOGWARNING,MAC_RRC_INF,
			GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
			dlCreateReq_p->rrcUeIndex,
			dlCreateReq_p->ueIndex,
			dlCreateReq_p->cRnti,
			DEFAULT_INT_VALUE, 
			DEFAULT_INT_VALUE, 
			DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
			FUNCTION_NAME, 
			"RRC_CREATE_UE_ENTITY");

    /* Cyclomatic Complexity changes - ends here */
    /* + TM7_8 Changes Start */
    if((TX_MODE_8 == dlCreateReq_p->transmissionMode) &&
            (TRUE != dlCreateReq_p->pmiRiReportV920))
    {
        /*L2_FIX_3_start*/
        ulCreateReq_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;
        /*L2_FIX_3_end*/
        lteWarning("PmiRiReport is not configured in TX mode 8. \n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->riConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "PmiRiReport is not configured in TX mode 8");
        /* Review comment fix end RJ13 */
    }
    /* - TM7_8 Changes End */
    /* CA changes Start */
    UInt8 index = 0;
    for (index = 0; index < (dlCreateReq_p->carrierAggrConfig.scellCount); index ++)
    {
        if((TX_MODE_8 == (dlCreateReq_p->carrierAggrConfig.scellInfo[index].transmissionMode)) &&
                (TRUE != dlCreateReq_p->carrierAggrConfig.scellInfo[index].cqiInfo.pmiRiReportV920))
        {
            ulCreateReq_p->carrierAggrConfig.scellInfo[index].cqiInfo.riConfigIndex 
                = MAC_RI_CONFIG_INDEX_INVALID;
            ulCreateReq_p->carrierAggrConfig.scellInfo[index].cqiInfo.riConfigIndexV1020 
                = MAC_RI_CONFIG_INDEX_INVALID;
            lteWarning("PmiRiReport is not configured in TX mode 8. \n");
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->riConfigIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "PmiRiReport is not configured in TX mode 8");
        }
    }
    /* CA changes End */

    /* to check if optional fields CREATE_LC_REQ tag are present */
    while ( msgLen > 0 )
    {
        /* TAG_LEN   4 */
        if ( msgLen < TAG_LEN )
        {
            lteWarning("Mac syntax error.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    msgLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Mac syntax length error");
            /* Review comment fix end RJ13 */
            /* + coverity 32222 */
            return MAC_SYNTAX_ERROR_VAL;
            /* - coverity 32222 */
        }

        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        if ( tag != CREATE_LC_REQ )
        {
            lteWarning("Wrong tag received.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tag,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Wrong tag received");
            /* Review comment fix end RJ13 */
            /* + coverity 32766 */
            return MAC_FAILURE;
            /* - coverity 32766 */
        }

        LTE_MAC_UT_LOG( LOG_INFO, PARSE_UTIL,
                "CREATE_LC_REQ ");

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        msgLen -= tagLen;

        if (tagLen < CREATE_LC_REQ_MIN_TAGLEN)
        {
            lteWarning("Mac syntax length error .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Mac syntax length error");
            /* Review comment fix end RJ13 */
            /* + coverity 32222 */
            return MAC_SYNTAX_ERROR_VAL;
            /* - coverity 32222 */
        }
        /* function to process the message buffer and fill the
         * structure to create an LC */
        retval =
            parseCreateLcReq( msg_p, tagLen, dlCreateReq_p, ulCreateReq_p
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    );

        if ( retval != MAC_SUCCESS )
        {
            lteWarning("Parsing create LC req failed.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    retval,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Parsing create LC req failed");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        msg_p += tagLen - 4;
        /* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
        tag = LTE_GET_U16BIT(msg_p);
        if (tag ==  UPLINK_RAT1_INFO)
        {
            msg_p += 2;

            tagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            msgLen -= tagLen;
            if (MAC_SUCCESS  != parseUEUplinkRAT1Info(&msg_p,tagLen, 
                        ulCreateReq_p,internalCellIndex))
            {   
                return MAC_FAILURE;
            }

            msg_p += tagLen - 4;
        }    
#endif
        /* SPR 21958 PUSCH RAT1 Support End */
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : validateAndParseCreateUEEntityParams 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  addUEInfoTagLen_p - Length of UE Info tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function validates and parse the Mandatory parameters
 *                  in Create UE Entity Request and fills in the structure 
 *                  needed by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType validateAndParseCreateUEEntityParams( UInt8 **msgBuf, 
        UInt16 *addUEInfoTagLen_p, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    UInt16 tag             = 0;
    UInt16 tagLen          = 0;
    UInt16 addUEInfoTagLen = *addUEInfoTagLen_p;
    UInt8 *msg_p           = PNULL;
    /*SPR_3061_FIX*/
    UInt16 timeAlignmentTimer = 0;
    /*SPR_3061_FIX*/
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    InitParams *initParams_p = cellSpecificParams_g.\
                               cellConfigAndInitParams_p[internalCellIndex]->initParams_p;
    /* CA Changes end */
    msg_p = *msgBuf;

    /* validation of ue index received from RRC*/
    /* SPR 15553 fix start */ 
    if ( (dlCreateReq_p->ueIndex >= MAX_UE_SUPPORTED))
    {
        /* SPR 15553 fix end */
        lteWarning("Invalid range for ue index.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->ueIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for ue index");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->ueIdx = dlCreateReq_p->ueIndex;

    /* Parse tag, it should be ADD_UE_INFO, else return failure */
    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( ADD_UE_INFO != tag )
    {
        lteWarning("Invalid ADD UE INFOTAG ID Recieved");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid ADD UE INFOTAG ID Recieved");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    } 
    tagLen = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( tagLen < ADD_UE_MANDATORY_LENGTH )
    {
        /* SPR 16766 fix start */
        LOG_MAC_MSG( MAC_PARSING_ERROR, LOGERROR, MAC_RRC_INF,
                getCurrentTick(), tagLen, 0,0,0,0, 0,0,
                __func__, "InvalidTagLen" ); 
        /* SPR 16766 fix end */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    addUEInfoTagLen = tagLen;

    /* Parse CRNTI and validate it */
    dlCreateReq_p->cRnti = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    /* CA changes start */
    if ((dlCreateReq_p->cRnti < initParams_p->lowerRNTIBound) ||
            (dlCreateReq_p->cRnti > initParams_p->upperRNTIBound))
        /* CA changes end */
    {
        lteWarning("Invalid range for cRnti.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->cRnti,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cRnti");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulCreateReq_p->cRnti = dlCreateReq_p->cRnti;

    /* Parse Priority and validate it */
    dlCreateReq_p->uePriority = *msg_p++;

    /*validation of ue priority value */
    if (dlCreateReq_p->uePriority > MAC_MAX_UEPRIORITY)
    {
        lteWarning("Invalid range for ue priority.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->uePriority,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for ue priority");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->uePriority =  dlCreateReq_p->uePriority; 

    /* Parse number of harq process and validate it */
    dlCreateReq_p->numHarqProcess = *msg_p++;
#ifdef TDD_CONFIG
	//ysl modified 0819: don't support dynamic max dl_num_harq_process anymore
	if (dlCreateReq_p->numHarqProcess != getMaxDLHarq(internalCellIndex))
	{
		lteWarning("max dl_num_harq_process from upper layer is %d, correct to %d!!!\n",
				dlCreateReq_p->numHarqProcess, getMaxDLHarq(internalCellIndex));
		dlCreateReq_p->numHarqProcess = getMaxDLHarq(internalCellIndex);
	}

    /* CA TDD Changes Start */
    if (dlCreateReq_p->numHarqProcess > getMaxDLHarq(internalCellIndex) ||
            dlCreateReq_p->numHarqProcess < MIN_DL_NUM_HARQ_PROC_VAL)
        /* CA TDD Changes End */
    {
        lteWarning("Invalid Number of Harq Process for ue .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->numHarqProcess,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Number of Harq Process for ue");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;

    }
#elif FDD_CONFIG
	//ysl modified 0819: don't support dynamic max dl_num_harq_process anymore
	if (dlCreateReq_p->numHarqProcess != 8)
	{
		lteWarning("max dl_num_harq_process from upper layer is %d, correct to %d!!!\n",
				dlCreateReq_p->numHarqProcess, 8);
		dlCreateReq_p->numHarqProcess = 8;
	}

    /*validation of ue Number of Harq Process value*/
    if (dlCreateReq_p->numHarqProcess < MAC_MIN_NUM_HARQ ||
            dlCreateReq_p->numHarqProcess > MAC_MAX_NUM_HARQ )
    {
        lteWarning("Invalid Number of Harq Process for ue .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->numHarqProcess,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Number of Harq Process for ue");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#endif    

    /* SPR 2063 start */
    dlCreateReq_p->mcsIndex = *msg_p++;
    if (MAC_SUCCESS != (resp = validateMcsIndex(dlCreateReq_p->mcsIndex
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ) ) )
    {
        return resp;
    }

    /* Cyclomatic_complexity_changes_start */
    getModSchemeFromMcsIndex(dlCreateReq_p->mcsIndex,
            &(dlCreateReq_p->modScheme));
    /* Cyclomatic_complexity_changes_end */

    /* SPR 2063 end */

    dlCreateReq_p->maxRB = *msg_p++;
    if ( ! dlCreateReq_p->maxRB )
    {
        lteWarning("Invalid MAX RB For Downlink [0]");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->maxRB,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid MAX RB For Downlink [0]");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* validation of maximum resource blocks for an UE in downlink*/
    resp = validateDlMaxRB (dlCreateReq_p->maxRB
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        dlCreateReq_p->maxRB = cellParams_p->dlAvailableRBs;
    }
    /* SPR 2063 start */
    ulCreateReq_p->mcsIndex = *msg_p++;
    if (MAC_SUCCESS != (resp = validateMcsIndex(ulCreateReq_p->mcsIndex
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ) ) )
    {
        return resp;
    }
    /*SPR 3600 Start*/
    /*Limit MCS index in UL if macEnable64QAM is FALSE or ueCategory is less than 5*/
    /*CA Changes start  */
    if((LTE_FALSE == cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellParams_p->macEnable64QAM) ||
            (ulCreateReq_p->ueCategory < UE_CATEGORY_5) ||
            (ulCreateReq_p->ueCategory == UE_CATEGORY_6) ||
            (ulCreateReq_p->ueCategory == UE_CATEGORY_7))
    {
        /* SPR 5003 Changes Start */
        if((ulCreateReq_p->mcsIndex) > 
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->initParams_p->maxMcs16QAM) 
            /* SPR 5003 Changes End */
            ulCreateReq_p->mcsIndex = 
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->initParams_p->maxMcs16QAM; 
        /* SPR 19136 Fix Start */
        if((ulCreateReq_p->ueCategory == UE_CATEGORY_1) &&  (ulCreateReq_p->mcsIndex > MCS_INDEX_64QAM_20))
        {
            ulCreateReq_p->mcsIndex = MCS_INDEX_64QAM_20; 
        }
        /* SPR 19136 Fix End */
    }
    /* Cyclomatic_complexity_changes_start */
    getUlModSchemeFromMcsIndex(ulCreateReq_p->mcsIndex, 
            &(ulCreateReq_p->modScheme), 
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellParams_p->macEnable64QAM,
            ulCreateReq_p->ueCategory);
    /* Cyclomatic_complexity_changes_end */
    /*CA Changes end  */
    /*SPR 3600 End*/
    /* SPR 2063 end */

    /* validation of transmission mode in downlink */
    /* + Coverity 55039 */
    dlCreateReq_p->transmissionMode = (TransmissonMode)*msg_p;
    msg_p++;
    /* - Coverity 55039 */
    dlCreateReq_p->rankIndicator = *msg_p++;

    /*L2_FIX_1_Start*/
    /* validation of transmission mode and Rank Indicator in downlink */
    if( MAC_SUCCESS != validateTransmissionModeAndLayer(dlCreateReq_p->transmissionMode,
                dlCreateReq_p->rankIndicator,internalCellIndex))
    {
        lteWarning("Invalid range for Rank Indicator:%d or Transmission mode:%d\n",
                dlCreateReq_p->rankIndicator, dlCreateReq_p->transmissionMode);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for transmission mode");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /*L2_FIX_1_End */

    /* + CL-MIMO LJA*/
    dlCreateReq_p->cbsrInfo.cbsrType = CBSR_INVALID;
    /* - CL-MIMO LJA*/
    dlCreateReq_p->precodingIndex = *msg_p++;

    /* validation of code book index in downlink*/
    if( MAC_SUCCESS != validatePrecodingIndex(dlCreateReq_p->precodingIndex, 
                internalCellIndex) )
    {
        lteWarning("Invalid range for precodingIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->precodingIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for precodingIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* SPR_1987 Start */
    ulCreateReq_p->maxUlHARQTx = *msg_p++;
    if(MAC_FAILURE == validateMaxUlHarqTx(ulCreateReq_p->maxUlHARQTx
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ))
    {
        lteWarning("Invalid value for max UL HARQ retransmission count .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->maxUlHARQTx,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for max UL HARQ retransmission count");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->maxUlHARQTx
        = convertMaxUlHarqEnumInVal(ulCreateReq_p->maxUlHARQTx);
    /* SPR_1987 End */

    /*Fix for __SPR_1988__ START*/
    timeAlignmentTimer = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if(MAC_FAILURE ==
            validateTimeAlignmentTimer(timeAlignmentTimer))
    {
        LOG_MAC_MSG(MAC_INVALID_TA_ULSYNC_TIMER_VAL, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),timeAlignmentTimer, dlCreateReq_p->timeAlignmentTimer,
                internalCellIndex,DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "INVALID_TIME_ALIGNMENT_TIMER_VAL");
        return MAC_FAILURE;
    }
    /*SPR_3061_FIX*/
    dlCreateReq_p->timeAlignmentTimer = 
        convertTATimerInMs(timeAlignmentTimer); 
    /*SPR_3061_FIX*/
    LOG_MAC_MSG(MAC_TIMEALIGNMENT_ULSYNC_TIMER_VAL, LOGINFO, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),timeAlignmentTimer, dlCreateReq_p->timeAlignmentTimer,
            internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "TIME_ALIGNMENT_TIMER_VAL");
    /*Fix for __SPR_1988__ END*/

    /*Parsing Mandatory Parameter pcMax*/
    ulCreateReq_p->pcMax = *msg_p++;
    /*Checking range for pcMax*/
    if( (MIN_PC_MAX > ulCreateReq_p->pcMax) || 
            (MAX_PC_MAX < ulCreateReq_p->pcMax) )
    {
        lteWarning("Invalid value for pcMax\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->pcMax,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for pcMax");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /*Parsing Mandatory Parameter p-a */
    dlCreateReq_p->pA = *msg_p++;

    if (dlCreateReq_p->pA > MAX_PA_VALUE)
    {
        lteWarning("Invalid value for p-a\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->pA,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for p-a");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulCreateReq_p->minUePower = MIN_PC_MAX;
    /*Power Control Change End*/

    *addUEInfoTagLen_p = addUEInfoTagLen;
    *msgBuf            = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEReqParams 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  msgLen_p - length of the API message received
 *                  addUEInfoTagLen - Length of UE Info tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the Optional parameters in Create UE
 *                  Entity Request and fills in the structure needed by MAC 
 *                  to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEReqParams( UInt8 **msgBuf, 
        UInt16 *msgLen_p, UInt16 addUEInfoTagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{


    /* + Coverity 32759 */
    MacRetType resp = MAC_SUCCESS;
    /* - Coverity 32759 */
    UInt16 tag             = 0;
    UInt16 tagLen          = 0;
    UInt16 msgLen          = *msgLen_p;
    UInt8 *msg_p           = PNULL;
    /* SPR 12240 Changes Start */
    UInt8 isCbsrTypeAlreadyRcvd = LTE_FALSE;
    /* SPR 12240 Changes End */
    UInt8 tempChoice = 0;
    /* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
    ulCreateReq_p->isUplinkRAT1Supported = FALSE;
#endif
    /* SPR 21958 PUSCH RAT1 Support End */

    msg_p = *msgBuf;

    while ( addUEInfoTagLen > 0)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        addUEInfoTagLen -= tagLen;

        msgLen -= tagLen;

        switch ( tag )
        {
            case SR_CONFIG_INFO:
            {
                UInt8 isContinueFlag = FALSE;
                resp = validateAndParseCreateSRConfigInfo(&msg_p, &msgLen, 
                        &tagLen, ulCreateReq_p, &isContinueFlag
                        /* CA changes Start */
                        ,internalCellIndex
                        /* CA Changes end */
                        );
                if (isContinueFlag == TRUE)
                {
                    continue;
                }
            }
            break;

            /* Rel9_upgrade_CR410 */
            case SR_PROHIBIT_TIMER_V920: 
            {
                resp = parseCreateUESRProhibitTimerV920 ( 
                        &msg_p, tagLen, ulCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            }
            break;
            /* Rel9_upgrade_CR410 */ 

            case CQI_INFO:
            {
                resp = parseCreateUECqiInfo( &msg_p, tagLen, ulCreateReq_p,
                        dlCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            }
            break;
#ifdef TDD_CONFIG
            case TDD_ACK_NACK_FEEDBACK_MODE_INFO:
            {
                /* SPR 19679: TDD HARQ Multiplexing Changes Start */
                resp = validateTddAckNackFeedbackMode( &msg_p,
                        tagLen,
                        ulCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                /* SPR 19679: TDD HARQ Multiplexing Changes End */
            }
            break;
#endif
            /* + CL-MIMO LJA*/    
            case CODEBOOK_SUBSET_RESTRICTION:
            {
                /* SPR 12240 Changes Start */
                isCbsrTypeAlreadyRcvd = LTE_TRUE;
                /* SPR 12240 Changes End */
                resp = parseCreateUECodebookSubsetRestriction( 
                        &msg_p, tagLen, dlCreateReq_p
                        /* CA changes Start */
                        ,internalCellIndex
                        /* CA Changes end */
                        );
            }
            break;

            case  DRX_CONFIG_INFO:
            {
                resp = parseCreateUEDRXConfigInfo( &msg_p, 
                        tagLen, dlCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            }
            break;

            case  MEAS_GAP_CONFIG_INFO:
            {
                resp = parseCreateUEMeasGapConfigInfo ( 
                        &msg_p, tagLen, dlCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            }
            break;

            case PUSCH_CONFIG_INFO:
            {
                resp = parseCreateUEPuschConfigInfo( 
                        &msg_p, tagLen, ulCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            }
            break; 

            case SRS_DEDICATED_CONFIG:
            {
                if(0 == msgLen)
                {
                    lteWarning("Msg Len passed 0 for parsing SRS Dedicated Info\n");
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            tagLen,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Msg Len passed 0 for parsing SRS Dedicated Info");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                resp = parseSRSDedicatedConfigInfo(&msg_p, tagLen, 
                        ulCreateReq_p
                        /* CA Changes start */
                        , internalCellIndex 
                        /* CA Changes end */
                        );
                if (MAC_FAILURE == resp )
                {
                    /* lteWarning logs shall appear from inside 
                       parseSRSDedicatedConfigInfo so only returning FAILURE */
                    return MAC_FAILURE;
                }
                ulCreateReq_p->srsRequestType = TRUE;
            }
            break;

            case AMBR_QOS_INFO:
            {
                /*CR 64 bit to 32 bit */
		/* SPR 22745 Fix Start */
            	dlCreateReq_p->dlAmbr = DIVIDE_BY_EIGHT(VALIDATE_RECEIVED_AMBR(LTE_GET_U32BIT(msg_p)));
                msg_p += SIZEOF_UINT32;

                dlCreateReq_p->dlAmbrPresent = TRUE;

                ulCreateReq_p->ulAmbr = DIVIDE_BY_EIGHT(VALIDATE_RECEIVED_AMBR(LTE_GET_U32BIT(msg_p)));
		/* SPR 22745 Fix End */
                msg_p += SIZEOF_UINT32;
                /*CR 64 bit to 32 bit */

                ulCreateReq_p->ulAmbrPresent = TRUE;
            }
            break;

            case CODEBOOK_SUBSET_RESTRICTION_V920:
            {
                /* SPR 12240 Changes Start */
                isCbsrTypeAlreadyRcvd = LTE_TRUE;
                parseCreateUECodebookSubsetRestrictionV920(
                        &msg_p, tagLen, dlCreateReq_p,
                        internalCellIndex);
                /* SPR 12240 Changes End */
            }
            break;

            case UPLINK_POWER_CONTROL_DEDICATED:
            {
                resp = parseCreateUEULPowerCtrlDedicated( &msg_p, 
                        tagLen, ulCreateReq_p, dlCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            case TPC_PDCCH_CONFIG_PUCCH:
            {
                resp = parseCreateUETpcPdcchConfigPucch( &msg_p, 
                        /* +- SPR 17777 */
                        tagLen,dlCreateReq_p
                        /* +- SPR 17777 */
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            case TPC_PDCCH_CONFIG_PUSCH:
            {
                resp = parseCreateUETpcPdcchConfigPusch( &msg_p, 
                        tagLen, ulCreateReq_p, dlCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            case UE_CAPABILITY_ADDITIONAL_PARAMETERS: 
            {
                resp = parseUECapAdditionalParams (&msg_p, tagLen, 
                        dlCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            }   
            break;

            case USER_LOCATION_TYPE:
            {
                resp = parseCreateUserLocationType( &msg_p, tagLen, 
                        ulCreateReq_p, dlCreateReq_p );
                break;
            }
            case UL_MU_MIMO_INFO:
            {
                resp = parseCreateUEULMuMimoInfo( &msg_p, tagLen, 
                        ulCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            /* In Case of TDD if this parameter is present then parse the parameter but
             * keep the isHDFDDFlag as FALSE */
            case RF_PARAMS:
            {
                /* +- SPR 17777 */
                resp = parseCreateRFParams( &msg_p, tagLen,
#ifdef HD_FDD_CONFIG
                        ulCreateReq_p,
#endif
                        /* +- SPR 17777 */
                        dlCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            case MIN_POWER_UE:
            {
                ulCreateReq_p->minUePower = *msg_p++;
                break;
            }
            case SPS_CONFIG:
            {  
                LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex), LINE_NUMBER, dlCreateReq_p->ueIndex,
                        SPS_CONFIG, internalCellIndex, DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, 
                        FUNCTION_NAME,
                        "SPS_CONFIG_TAG_RECEIVED_DURING_CONFIG");
                resp =  parseSpsConfigInfo( msg_p, tagLen, dlCreateReq_p,
                        ulCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                if( MAC_FAILURE == resp )
                {
                    LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            LINE_NUMBER,dlCreateReq_p->ueIndex,SPS_CONFIG,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,
                            "SPS_CONFIG_PARSE_FAILURE");
                    return MAC_FAILURE;
                }
                msg_p += (tagLen - TAG_LEN);
                break;
            }  
            /* SPR 5084 changes start*/
            case UE_CATEGORY:
            {
                resp = parseCreateUECategoryInfo( &msg_p, tagLen,
                        ulCreateReq_p, dlCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            /* SPR 5084 changes ends*/
            case PHR_TIMER_CONFIG:
            {
                resp = parseCreateUEPhrTimerConfig( &msg_p, tagLen,
                        ulCreateReq_p 
                        /* +- SPR 17777 */
                        );
                break;
            }
            /* SPR 5713 changes start */
            case UE_COMPLIANCE_RELEASE:
            {
                resp = parseCreateUEComplianceRelease( &msg_p, tagLen,
                        ulCreateReq_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            /* SPR 5713 changes end */
            /* + TM7_8 Changes Start */
            case PDSCH_EPRE_TO_UE_RS_RATIO:
            {
                if ( tagLen != PDSCH_EPRE_TO_UE_RS_RATIO_TAG_LEN )
                {  
                    lteWarning("Invalid Tag Length %d for PDSCH_EPRE_TO_UE_RS_RATIO\n"
                            ,tagLen);
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            tagLen,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid Tag Length for PDSCH_EPRE_TO_UE_RS_RATIO");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                dlCreateReq_p->pdschEpreToUeRsRatio = *msg_p++;
                if( ( dlCreateReq_p->pdschEpreToUeRsRatio > 3 ) || 
                        ( dlCreateReq_p->pdschEpreToUeRsRatio < -6 ) )
                {  
                    lteWarning("Invalid Tag value %d for PDSCH_EPRE_TO_UE_RS_RATIO\n"
                            ,dlCreateReq_p->pdschEpreToUeRsRatio);
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            dlCreateReq_p->pdschEpreToUeRsRatio,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid pdschEpreToUeRsRatio");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                break;
            }
            /* - TM7_8 Changes End */
            case TTI_BUNDLING_INFO :
            {
                if (TTI_BUNDLING_INFO_TAG_LEN != tagLen )
                {
                    lteWarning("Invalid Tag Length %d for TTI_BUNDLING_Info\n"
                            ,tagLen);
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            tagLen,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid Tag Length for TTI_BUNDLING_Info");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                /*SPR 21501 fix start*/
                ulCreateReq_p->ttiBundlingEnabled = *msg_p;

                if ((ulCreateReq_p->ttiBundlingEnabled  != TTIB_DISABLED) &&
                        (ulCreateReq_p->ttiBundlingEnabled != TTIB_ENABLED))
                {
                    lteWarning("Invalid Value for ttiBundling Info :%d \n",
                            ulCreateReq_p->ttiBundlingEnabled );
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            ulCreateReq_p->ttiBundlingEnabled,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid Value for ttiBundling Info");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                /*SPR 21501 fix end*/
                msg_p++;
                break;
            }

            /*CA changes start*/
            case UE_CATEGORY_V1020:
            {
                resp = macParseCreateUECategoryV1020Info( &msg_p, tagLen,
                        ulCreateReq_p, dlCreateReq_p,internalCellIndex);
                break;
            }

            case PUCCH_FORMAT_V1020:
            {
                resp = macParseCreatePUCCHFormatV1020( &msg_p, tagLen,
                        ulCreateReq_p, dlCreateReq_p,internalCellIndex
                        );
                break;
            }

            case CA_CONFIG:
            {
                resp = macParseCreateCAConfig( &msg_p, tagLen,
                        ulCreateReq_p, dlCreateReq_p,internalCellIndex );
                break;
            }
            /*CA changes end*/

            /* SPR 12240 Changes Start */
            /* For a Rel 10 UE , CBSR Tag will be V1020 one */
            case CODEBOOK_SUBSET_RESTRICTION_V1020:
            {
                if(LTE_TRUE == isCbsrTypeAlreadyRcvd)
                {
                    resp = MAC_FAILURE;
                }
                else
                {
                    resp = parseCreateUECodebookSubsetRestrictionV1020(
                            &msg_p, tagLen, dlCreateReq_p,
                            internalCellIndex
                            );
                }
                /* SPR 13027 Changes Start */
                break;
                /* SPR 13027 Changes End */
            }
            case DL_INTERFERENCE_INFO:
            {
                tempChoice = (UInt8)*msg_p;
                dlCreateReq_p->userType = (UserType)tempChoice;
                msg_p += 1;
                dlCreateReq_p->userTypePresent = TRUE;
                ulCreateReq_p->userType = dlCreateReq_p->userType;
                ulCreateReq_p->userTypePresent = TRUE;

                break;
            }
            /* SPR 12240 Changes End */
            default: 
            {
                lteWarning("Invalid Tag [%d] Identifer Recieved in Create UE Info",tag);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tag,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid Tag Recieved in Create UE Info");
                /* Review comment fix end RJ13 */
                resp = MAC_FAILURE;
            }
        }/* end of switch */
        if (resp != MAC_SUCCESS)
        {
            return resp;
        }
    }/* end of while loop */

    *msgLen_p = msgLen;
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : validateAndParseCreateSRConfigInfo
 * Inputs         : msgBuf - pointer to the input buffer
 *                  msgLen_p - length of the API message received
 *                  tagLen_p - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  isContinueFlag_p - Flag is continuing SR.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function vaildates and parse the SR Config info in 
 *                  Create UE Entity Request and fills in the structure needed 
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType validateAndParseCreateSRConfigInfo( UInt8 **msgBuf, 
        UInt16 *msgLen_p, UInt16 *tagLen_p, UeContextForUplink *ulCreateReq_p,
        UInt8 *isContinueFlag_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tagLen          = *tagLen_p;
    UInt16 msgLen          = *msgLen_p;
    UInt8 *msg_p           = PNULL;

    msg_p = *msgBuf;

    if ( tagLen != 5 && tagLen != 12 )
    {
        lteWarning("Invalid Tag Length for SR Info");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for SR Info");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulCreateReq_p->requestType = *msg_p++;

    if ((ulCreateReq_p->requestType != REQUEST_TYPE_0) &&
            (ulCreateReq_p->requestType != REQUEST_TYPE_1))
    {
        lteWarning("Invalid range for requestType .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->requestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for requestType");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    tagLen -= 5;
    if ( ulCreateReq_p->requestType == 0 )
    {
        /* Set the continue flag */
        *isContinueFlag_p = TRUE;
        *tagLen_p = tagLen;
        *msgLen_p = msgLen;
        *msgBuf = msg_p;
        return MAC_SUCCESS;
    }    
    if (MAC_SUCCESS != parseCreateUESRConfigInfo ( &msg_p, 
                &msgLen, tagLen, ulCreateReq_p 
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                ))
    {
        return MAC_FAILURE;
    }

    *tagLen_p = tagLen;
    *msgLen_p = msgLen;
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUESRConfigInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  msgLen_p - length of the API message received
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the SR Config information in Create UE
 *                  Entity Request and fills in the structure needed by MAC 
 *                  to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUESRConfigInfo( UInt8 **msgBuf, 
        UInt16 *msgLen_p, UInt16 tagLen, UeContextForUplink *ulCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt16 msgLen          = *msgLen_p;
    UInt8 *msg_p           = PNULL;

    msg_p = *msgBuf;

    if ( tagLen != 7)
    {
        lteWarning("Mac syntax error.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax length error");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( tag != SR_SETUP_INFO)
    {
        lteWarning("Invalid SR_SETUP_INFO Tag.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid SR_SETUP_INFO Tag");
        /* Review comment fix end RJ13 */
        /* + coverity 32766 */
        return MAC_FAILURE;
        /* - coverity 32766 */
    }
    tagLen = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( tagLen != SR_SETUP_INFO_LEN)
    {
        lteWarning("Mac syntax length error .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax length error");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->srPucchResourceIndex = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( ulCreateReq_p->srPucchResourceIndex > MAC_MAX_SRPUCCHRESOURCEINDEX )
    {
        lteWarning("Invalid range for srPucchResourceIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->srPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for srPucchResourceIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulCreateReq_p->srConfigurationIndex = *msg_p++;
    if (MAC_MAX_SRCONFIGURATIONINDEX < ulCreateReq_p->srConfigurationIndex)
    {
        lteWarning("Invalid range for srConfigurationIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->srConfigurationIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for srConfigurationIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    *msgLen_p = msgLen;
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUESRProhibitTimerV920 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the SR Prohibit Timer V920 info in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUESRProhibitTimerV920( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p           = PNULL;

    msg_p = *msgBuf;

    /* Get the SR Prohibit Timer v920 value from the message buffer */
    ulCreateReq_p->srProhibitTimerValv920 = *msg_p++;

    if (SR_PROHIBIT_TIMER_TAG_LEN != tagLen)
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SR_PROHIBIT_TIMER_V920_INVALID_TAGLEN");         
        return MAC_FAILURE;
    }

    if(MAC_MAX_SR_PROHIBIT_TIMER_VAL < ulCreateReq_p->srProhibitTimerValv920 )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,
                ulCreateReq_p->srProhibitTimerValv920,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                "SR_PROHIBIT_TIMER_V920_INVALID_VALUE");         
        return MAC_FAILURE;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUECqiConfigIndexV10Info 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the csiconfigindexv10 information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECqiConfigIndexV10Info( UInt8 **msgBuf,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt8 *msg_p           = PNULL;
    UInt16 cqiconfigindexTagLenV10   = 0;
    UInt16 cqiconfigindex2TagLenV10   = 0;
    UInt16 riconfigindexTagLenV10   = 0;
    msg_p = *msgBuf;

    msg_p += 2;

    /* cqi report v920 tag length*/
    cqiconfigindexTagLenV10 = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (CSI_CONFIG_INDEX_VR10_TAG_LENGTH > cqiconfigindexTagLenV10)
    {      
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,cqiconfigindexTagLenV10,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
        return MAC_FAILURE;
    }

    ulCreateReq_p->cqiConfigRequestType = *(msg_p);
    msg_p++;
    /* + SPR 5953 Fix */
    dlCreateReq_p->cqiConfigRequestType = ulCreateReq_p->cqiConfigRequestType;
    /* - SPR 5953 Fix */
    /*L2_FIX_8 */
    if ( ulCreateReq_p->cqiConfigRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    if ( ulCreateReq_p->cqiConfigRequestType )
    {
        tag = LTE_GET_U16BIT(msg_p);
        if (tag == CQI_PMI_CONFIGINDEX2_VR10)
        {
            msg_p += 2;
            cqiconfigindex2TagLenV10 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CQI_PMI_CONFIGINDEX2_VR10_TAG_LENGTH > cqiconfigindex2TagLenV10)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,cqiconfigindex2TagLenV10,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            ulCreateReq_p->cqiPMIConfigIndex_2 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            tag = LTE_GET_U16BIT(msg_p);
        }
        if (tag == RI_CONFIG_INDEX_INFO)
        {
            msg_p += 2;
            riconfigindexTagLenV10 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (RI_CONFIG_INDEX_INFO_LEN > riconfigindexTagLenV10)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,riconfigindexTagLenV10,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
                return MAC_FAILURE;
            }
            ulCreateReq_p->riConfigIndex_2 = LTE_GET_U16BIT(msg_p);;
            msg_p += 2;
        }

    }
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUECsiSubframePatternV10Info 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the csisubframepatternconfigv10 information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECsiSubframePatternV10Info( UInt8 **msgBuf,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt8 *msg_p           = PNULL;
    UInt16 csisubframepatternTagLen   = 0;
    UInt16 csimeasurementsubsetTagLen   = 0;
    UInt8 subsetIndexNum = 0;
    msg_p = *msgBuf;
    UInt8 ConfigRequestType = 0;
    CsiChoice choice = FDD_CONFIG_TYPE;
    UInt8 subsetPatternLength = 0;
    UInt8 tempChoice = 0;
    msg_p += 2;

    /* cqi report v920 tag length*/
    csisubframepatternTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (CSI_SUBFRAME_PATTERN_CONFIG_VR10_TAG_LENGTH  > csisubframepatternTagLen)
    {      
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,csisubframepatternTagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
        return MAC_FAILURE;
    }

    ConfigRequestType = *(msg_p);
    ulCreateReq_p->cqiSubsetConfigRequestType = ConfigRequestType;
    dlCreateReq_p->cqiSubsetConfigRequestType = ConfigRequestType;

    msg_p++;


    if ( ConfigRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    if ( ConfigRequestType )
    {
        tag = LTE_GET_U16BIT(msg_p);
        if(tag == CSI_MEASUREMENT_SUBSET_VR10)
        {
            msg_p += 2;
            csimeasurementsubsetTagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CSI_MEASUREMENT_SUBSET_VR10_TAG_LENGTH  > csimeasurementsubsetTagLen)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,csimeasurementsubsetTagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            tempChoice = (UInt8)*msg_p;
            choice = (CsiChoice) tempChoice;	  
            msg_p += 1;
#ifdef FDD_CONFIG

            if(FDD_CONFIG_TYPE== choice)
            {
                subsetPatternLength = 5;
            }
            else
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
#else
            if(TDD_CONFIG1_5 == choice)
            {
                subsetPatternLength = 3;
            }	
            else if(TDD_CONFIG0 == choice)
            {
                subsetPatternLength = 9;
            }	
            else if(TDD_CONFIG6 == choice)
            {
                subsetPatternLength = 8;
            }	
            else
            {

                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

#endif
            for(subsetIndexNum = 0;subsetIndexNum< subsetPatternLength; subsetIndexNum++)
            {
                ulCreateReq_p->csiMeasurementSubset1[subsetIndexNum] = *(msg_p);
                msg_p++;
            }
        }
        tag = LTE_GET_U16BIT(msg_p);


        if(tag == CSI_MEASUREMENT_SUBSET2_VR10)
        {
            msg_p += 2;
            csimeasurementsubsetTagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CSI_MEASUREMENT_SUBSET_VR10_TAG_LENGTH  > csimeasurementsubsetTagLen)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,csimeasurementsubsetTagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            tempChoice = (UInt8)*msg_p;
            choice = (CsiChoice) tempChoice;	  
            msg_p += 1;
#ifdef FDD_CONFIG

            if(FDD_CONFIG_TYPE== choice)
            {
                subsetPatternLength = 5;
            }
            else
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
#else
            if(TDD_CONFIG1_5 == choice)
            {
                subsetPatternLength = 3;
            }	
            else if(TDD_CONFIG0 == choice)
            {
                subsetPatternLength = 9;
            }	
            else if(TDD_CONFIG6 == choice)
            {
                subsetPatternLength = 8;
            }	
            else
            {

                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

#endif
            for(subsetIndexNum = 0;subsetIndexNum< subsetPatternLength; subsetIndexNum++)
            {
                ulCreateReq_p->csiMeasurementSubset2[subsetIndexNum] = *(msg_p);
                msg_p++;
            }
            tag = LTE_GET_U16BIT(msg_p);
        }
    }		 
    *msgBuf = msg_p;
    return MAC_SUCCESS;

}

/******************************************************************************
 * Function Name  : parseCreateUECqiInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the CQI information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECqiInfo( UInt8 **msgBuf, UInt16 tagLen,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    MacRetType resp = MAC_SUCCESS;
    UInt16 tag             = 0;
    UInt8 *msg_p           = PNULL;
    /* + CQI_4.1 */
    UInt8 periodicCQIEnabled = 0;
    UInt8 aperiodicCQIEnabled = 0;
    /* - CQI_4.1 */
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    msg_p = *msgBuf;

    ulCreateReq_p->cqiMode = INVALID_APERIODIC_CQI_MODE;
    /* to check if optional fields CQI tag are present */
    /* Rel9_upgrade_CR396 */
    /* + SPR_3212 */
    /* CA Changes Start - Max TagLen is increased by 6 because of addition of a new
     * tag CQI_APERIODIC_CONFIG_INFO */
    if ( tagLen > 93 || tagLen < 9 ) 
        /* CA changes End */
        /* + SPR_3212 */
        /* Rel9_upgrade_CR396 */
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_INFO_INVALID_TAGLEN");         
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);

    ulCreateReq_p->cqiinfoflag = TRUE;
    dlCreateReq_p->cqiInfoFlag = TRUE;

    if ( CQI_APERIODIC_INFO == tag )
    {
        if (8 > cellParams_p->dlAvailableRBs)
        {
            lteWarning("Aperiodic mode configured with DL "
                    "RBs are less than 8\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    cellParams_p->dlAvailableRBs,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Aperiodic mode configured \
                    with DL RBs are less than 8");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        aperiodicCQIEnabled = TRUE;
        /*skip the length of the CQI Aperiodic Info tag*/
        msg_p += 2;

        /* SS_S2 */
        /*Skip the length of aperiodic tag */
        msg_p += 2 ;
        /* get the aperiodic cqi mode */
        ulCreateReq_p->cqiMode = *msg_p;
        msg_p++;
        /* + Coverity 55040 */
        dlCreateReq_p->cqiMode = (CQIMode)ulCreateReq_p->cqiMode;
        /* - Coverity 55040 */
        /* + CQI_5.0 */
        /* This function validates the CQI mode for corresponding TM modes */
        if (MAC_FAILURE == 
                (validateAperiodicModeForTXMode(dlCreateReq_p->cqiMode,
                                                dlCreateReq_p->transmissionMode)))

        {
            lteWarning("TX mode [%d] is not compatible with CQI aperiodic mode [%d]\n",
                    dlCreateReq_p->transmissionMode,dlCreateReq_p->cqiMode);
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlCreateReq_p->cqiMode,
                    dlCreateReq_p->transmissionMode, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "TX mode is not compatible with CQI aperiodic mode");
            /* Review comment fix end RJ13 */

            return MAC_FAILURE;
        }       
        /* + CQI_5.0 */

        tag = LTE_GET_U16BIT(msg_p);
        /* CA changes Start */
        if (APERIODIC_CSI_TRIGGER_R10 == tag)
        {
            msg_p += U16BIT_LEN;
            tagLen =  LTE_GET_U16BIT(msg_p); 
            if ( tagLen != APERIODIC_CSI_TRIGGER_R10_TAG_LEN )
            {
                LOG_MAC_ERROR(MAC_RRC_INF,"Invalid Tag Length %u for"
                        " APERIODIC_CSI_TRIGGER_R10_TAG_LEN info\n"
                        ,tagLen);
                return MAC_SYNTAX_ERROR_VAL;

            }
            msg_p += U16BIT_LEN;
            ulCreateReq_p->trigger1r10 = *msg_p++; 
            ulCreateReq_p->trigger2r10 = *msg_p++; 
            resp = macValidateCsiTriggerR10 ( ulCreateReq_p->trigger1r10,ulCreateReq_p->trigger2r10);
            dlCreateReq_p->trigger1r10 = ulCreateReq_p->trigger1r10; 
            dlCreateReq_p->trigger2r10 = ulCreateReq_p->trigger2r10; 

            if ( resp != MAC_SUCCESS )
            {
                LOG_MAC_ERROR(MAC_RRC_INF," Invalid Aperiodic CQI Mode");
                return resp;
            }
            /* Periodic CQI Info is present */
            /* Rel9_upgrade_CR396 */
            tag = LTE_GET_U16BIT(msg_p);
            /*tagLen +6*/
        }
        /* CA changes End */
    }
    if ( CQI_PERIODIC_INFO == tag )
    {
        periodicCQIEnabled = TRUE;
        UInt32 cqiPeriodicTagLen = 0;
        msg_p += 2;

        /* cqi periodic tag length*/
        cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        ulCreateReq_p->cqiRequestType = *(msg_p);
        msg_p++;
        /* + SPR 5953 Fix */
        dlCreateReq_p->cqiRequestType = ulCreateReq_p->cqiRequestType;
        /* - SPR 5953 Fix */
        /*L2_FIX_8 */
        if ( ulCreateReq_p->cqiRequestType > SETUP)
        {
            lteWarning("Invalid CQI Request Type");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->cqiRequestType,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid CQI Request Type");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        if ( ulCreateReq_p->cqiRequestType )
        {
            if ( cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN)
            {
                lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        cqiPeriodicTagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
            tag = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if ( CQI_PMI_CONFIG_INDEX_INFO == tag)
            {
                /* Cyclomatic Complexity changes start */
                resp = parseCqiPeriodicPMIConfigIndex(&msg_p,ulCreateReq_p,dlCreateReq_p,
                        internalCellIndex);
                if ( resp != MAC_SUCCESS )
                {
                    return resp;
                }
                /* Cyclomatic Complexity changes end */
            }
            else if (CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)
            {
                resp = parseCqiPeriodicPMIConfigIndexV1020(&msg_p,ulCreateReq_p,dlCreateReq_p,
                        internalCellIndex);
                if ( resp != MAC_SUCCESS )
                {
                    return resp;
                }
            }
        }
        /* SPR 21043 Start */
        else
        {
            ulCreateReq_p->cqiMaskV920 = FALSE;
        }    
        /* SPR 21043 End */
        /* Rel9_upgrade_CR396 */
        tag = LTE_GET_U16BIT(msg_p);
    }
    /* + CQI_4.1 */
    if ( (periodicCQIEnabled == TRUE) && (aperiodicCQIEnabled == TRUE) )
    {
        dlCreateReq_p->cqiIndication = PERIODIC_APERIODIC_MODE;
    }    
    else if (periodicCQIEnabled == TRUE) 
    {
        dlCreateReq_p->cqiIndication = PERIODIC_CQI_REPORTING_MODE;
    }    
    else if  (aperiodicCQIEnabled == TRUE)
    {
        dlCreateReq_p->cqiIndication = APERIODIC_CQI_REPORTING_MODE;
    }    
    /* - CQI_4.1 */
    if (CQI_REPORT_CONFIG_V920 == tag) 
    {
        if (MAC_SUCCESS != parseCreateUECqiV920Info (&msg_p, 
                    ulCreateReq_p, dlCreateReq_p 
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }
        tag = LTE_GET_U16BIT(msg_p);
    }
    if (CSI_SUBFRAME_PATTERN_CONFIG_VR10 == tag) 
    {
        if (MAC_SUCCESS != parseCreateUECsiSubframePatternV10Info (&msg_p, 
                    ulCreateReq_p, dlCreateReq_p 
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }
    }
    /* Rel9_upgrade_CR396 */

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCqiPeriodicPMIConfigIndexV1020 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the PeriodicPMIConfig CQI information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCqiPeriodicPMIConfigIndexV1020( UInt8 **msg_p,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    UInt16 tag             = 0;
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    UInt16 tagLen = 0;
    cqiPeriodicTagLen = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;

    if ( cqiPeriodicTagLen < PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        /* L2_FIX_9_start */
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        return MAC_FAILURE;
        /* L2_FIX_9_End */
    }   
    ulCreateReq_p->cqiPMIConfigIndex = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;

    /* SPR 1583 Start */
#ifdef FDD_CONFIG
    if (ulCreateReq_p->cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX ||
            ulCreateReq_p->cqiPMIConfigIndex == MAC_MAX_CQI_PMI_CONFIG_INDEX_3_1_7  )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#elif TDD_CONFIG
    if (ulCreateReq_p->cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX_TDD )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#endif
    /* SPR 1583 End*/

    ulCreateReq_p->cqiPucchResourceIndex = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;
    if (ulCreateReq_p->cqiPucchResourceIndex > 
            MAC_MAX_CQI_PUCCH_RESOURCE_INDEX)
    {
        lteWarning("Invalid range for cqiPucchResourceIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulCreateReq_p->simultaneousACKNACKAndCQI = (**msg_p);
    if ((ulCreateReq_p->simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_0) &&
            (ulCreateReq_p->simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_1))
    {
        lteWarning("Invalid range for simultaneousACKNACKAndCQI .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->simultaneousACKNACKAndCQI,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for simultaneousACKNACKAndCQI");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    *msg_p += 1;
    /* + Coverity 55041 */
    ulCreateReq_p->cqiformatIndicatorPeriodic = (PeriodicFeedbackType)**msg_p;
    /* - Coverity 55041 */
    *msg_p += 1;

    /*L2_FIX_13_start*/
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodic(ulCreateReq_p->cqiformatIndicatorPeriodic))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n",
                ulCreateReq_p->cqiformatIndicatorPeriodic);

        return MAC_FAILURE;
    }
    /*L2_FIX_13_end*/

    tag = LTE_GET_U16BIT(*msg_p);
    /* SPR 2617 Start*/
    /*Check if Report FORMAT is SUBBAND*/
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        if (8 > cellParams_p->dlAvailableRBs)
        {
            lteWarning("Periodic Subband mode configured with DL "
                    "RBs are less than 8\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    cellParams_p->dlAvailableRBs,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Periodic Subband mode configured \
                    with DL RBs are less than 8");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        /* - CQI_4.1 */
        *msg_p += 2;
        tagLen = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        /*L2_FIX_4_start*/
        if (tagLen < CQI_FORMAT_PERIODIC_SUBBAND_K_LEN)
        {
            LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    MAC_CREATE_UE_ENTITY_REQ,tagLen, 0,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"MAC_UE_CREATE_FAIL");

            return MAC_FAILURE;
        }
        /*L2_FIX_4_end*/

        ulCreateReq_p->cqiformatIndicatorPeriodic_subband_k = **(msg_p);
        *msg_p += 1;

        /*L2_FIX_14_start*/
        if(MAC_SUCCESS != validateCqiformatIndicatorPeriodicSubbandK(ulCreateReq_p->cqiformatIndicatorPeriodic_subband_k))
        {
            lteWarning("Invalid range for cqiformatIndicatorPeriodic_subband_k:%d\n",
                    ulCreateReq_p->cqiformatIndicatorPeriodic_subband_k);

            return MAC_FAILURE;
        }
        /*L2_FIX_14_end*/
    }
    else
    {
        if(ulCreateReq_p->cqiformatIndicatorPeriodic)
        {
            LOG_MAC_ERROR(MAC_RRC_INF,"Invalid cqiformatIndicatorPeriodic %u : ",
                    ulCreateReq_p->cqiformatIndicatorPeriodic);
            return MAC_FAILURE;
        }
    }
    /* SPR 2617 End*/
    /*SS_S2*/
    tag = LTE_GET_U16BIT(*msg_p);
    if (RI_CONFIG_INDEX_INFO == tag)
    { 
        *msg_p += 2;
        tagLen = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        if(tagLen < RI_CONFIG_INDEX_INFO_LEN)
        {
            lteWarning("Invalid Length for riConfigIndex .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid Length for riConfigIndex");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }

        ulCreateReq_p->riConfigIndex = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        if (ulCreateReq_p->riConfigIndex > MAC_MAX_RI_CONFIG_INDEX)
        {
            lteWarning("Invalid range for riConfigIndex .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->riConfigIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid range for riConfigIndex");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }

        else if( TX_MODE_3 != dlCreateReq_p->transmissionMode &&
                TX_MODE_4 != dlCreateReq_p->transmissionMode &&                         
                /* SPR 7388 fix start */
                TX_MODE_5 != dlCreateReq_p->transmissionMode &&                        
                TX_MODE_6 != dlCreateReq_p->transmissionMode && 
                /* SPR 7388 fix end */
                TX_MODE_8 != dlCreateReq_p->transmissionMode )                          
        {
            /*L2_FIX_3_start*/
            ulCreateReq_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;
            /*L2_FIX_3_end*/
            lteWarning("riConfigIndex is configured in TX mode other than 3 and 4.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->riConfigIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "riConfigIndex is configured \
                    in TX mode other than 3 and 4");
            /* Review comment fix end RJ13 */
        }
    }
    tag = LTE_GET_U16BIT(*msg_p);

    if (CSI_CONFIG_INDEX_VR10 == tag) 
    {
        if (MAC_SUCCESS != parseCreateUECqiConfigIndexV10Info (msg_p, 
                    ulCreateReq_p, dlCreateReq_p 
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }
        tag = LTE_GET_U16BIT(*msg_p);
    }
    return resp;
}

/******************************************************************************
 * Function Name  : parseCqiPeriodicPMIConfigIndex 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the PeriodicPMIConfig CQI information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCqiPeriodicPMIConfigIndex( UInt8 **msg_p,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    UInt16 tag             = 0;
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    UInt16 tagLen = 0;
    cqiPeriodicTagLen = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;

    if ( cqiPeriodicTagLen < PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        /* L2_FIX_9_start */
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        return MAC_FAILURE;
        /* L2_FIX_9_End */
    }   
    ulCreateReq_p->cqiPMIConfigIndex = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;

    /* SPR 1583 Start */
#ifdef FDD_CONFIG
    if (ulCreateReq_p->cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX ||
            ulCreateReq_p->cqiPMIConfigIndex == MAC_MAX_CQI_PMI_CONFIG_INDEX_3_1_7  )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#elif TDD_CONFIG
    if (ulCreateReq_p->cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX_TDD )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#endif
    /* SPR 1583 End*/

    ulCreateReq_p->cqiPucchResourceIndex = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;
    if (ulCreateReq_p->cqiPucchResourceIndex > 
            MAC_MAX_CQI_PUCCH_RESOURCE_INDEX)
    {
        lteWarning("Invalid range for cqiPucchResourceIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulCreateReq_p->simultaneousACKNACKAndCQI = (**msg_p);
    if ((ulCreateReq_p->simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_0) &&
            (ulCreateReq_p->simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_1))
    {
        lteWarning("Invalid range for simultaneousACKNACKAndCQI .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->simultaneousACKNACKAndCQI,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for simultaneousACKNACKAndCQI");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    *msg_p += 1;
    /* + Coverity 55041 */
    ulCreateReq_p->cqiformatIndicatorPeriodic = (PeriodicFeedbackType)**msg_p;
    /* - Coverity 55041 */
    *msg_p += 1;

    /*L2_FIX_13_start*/
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodic(ulCreateReq_p->cqiformatIndicatorPeriodic))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n",
                ulCreateReq_p->cqiformatIndicatorPeriodic);

        return MAC_FAILURE;
    }
    /*L2_FIX_13_end*/

    tag = LTE_GET_U16BIT(*msg_p);
    /* SPR 2617 Start*/
    /*Check if Report FORMAT is SUBBAND*/
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        if (8 > cellParams_p->dlAvailableRBs)
        {
            lteWarning("Periodic Subband mode configured with DL "
                    "RBs are less than 8\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    cellParams_p->dlAvailableRBs,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Periodic Subband mode configured \
                    with DL RBs are less than 8");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        /* - CQI_4.1 */
        *msg_p += 2;
        tagLen = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        /*L2_FIX_4_start*/
        if (tagLen < CQI_FORMAT_PERIODIC_SUBBAND_K_LEN)
        {
            LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    MAC_CREATE_UE_ENTITY_REQ,tagLen, 0,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"MAC_UE_CREATE_FAIL");

            return MAC_FAILURE;
        }
        /*L2_FIX_4_end*/

        ulCreateReq_p->cqiformatIndicatorPeriodic_subband_k = **(msg_p);
        *msg_p += 1;

        /*L2_FIX_14_start*/
        if(MAC_SUCCESS != validateCqiformatIndicatorPeriodicSubbandK(ulCreateReq_p->cqiformatIndicatorPeriodic_subband_k))
        {
            lteWarning("Invalid range for cqiformatIndicatorPeriodic_subband_k:%d\n",
                    ulCreateReq_p->cqiformatIndicatorPeriodic_subband_k);

            return MAC_FAILURE;
        }
        /*L2_FIX_14_end*/
    }
    else
    {
        if(ulCreateReq_p->cqiformatIndicatorPeriodic)
        {
            LOG_MAC_ERROR(MAC_RRC_INF,"Wroung value in cqiformatIndicatorPeriodic : %u\n",
                    ulCreateReq_p->cqiformatIndicatorPeriodic);
            return MAC_FAILURE;
        }
    }
    /* SPR 2617 End*/
    /*SS_S2*/
    tag = LTE_GET_U16BIT(*msg_p);
    if (RI_CONFIG_INDEX_INFO == tag)
    { 
        *msg_p += 2;
        tagLen = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        if(tagLen < RI_CONFIG_INDEX_INFO_LEN)
        {
            lteWarning("Invalid Length for riConfigIndex .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid Length for riConfigIndex");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }

        ulCreateReq_p->riConfigIndex = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        if (ulCreateReq_p->riConfigIndex > MAC_MAX_RI_CONFIG_INDEX)
        {
            lteWarning("Invalid range for riConfigIndex .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->riConfigIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid range for riConfigIndex");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }

        else if( TX_MODE_3 != dlCreateReq_p->transmissionMode &&
                TX_MODE_4 != dlCreateReq_p->transmissionMode &&                         
                /* SPR 7388 fix start */
                TX_MODE_5 != dlCreateReq_p->transmissionMode &&                        
                TX_MODE_6 != dlCreateReq_p->transmissionMode && 
                /* SPR 7388 fix end */
                TX_MODE_8 != dlCreateReq_p->transmissionMode )                          
        {
            /*L2_FIX_3_start*/
            ulCreateReq_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;
            /*L2_FIX_3_end*/
            lteWarning("riConfigIndex is configured in TX mode other than 3 and 4.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->riConfigIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "riConfigIndex is configured \
                    in TX mode other than 3 and 4");
            /* Review comment fix end RJ13 */
        }
    }
    return resp;
}

/******************************************************************************
 * Function Name  : parseCreateUECqiV920Info 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the CQI V920 information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECqiV920Info( UInt8 **msgBuf,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt8 *msg_p           = PNULL;
    UInt16 cqiTagLenV920   = 0;
    msg_p = *msgBuf;

    msg_p += 2;

    /* cqi report v920 tag length*/
    cqiTagLenV920 = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (CQI_REPORT_V920_LEN > cqiTagLenV920)
    {      
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,cqiTagLenV920,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (CQI_MASK_V920 == tag)
    {
        msg_p += 2;

        ulCreateReq_p->cqiMaskV920 = *msg_p++;
        /** SPR 14459 Changes Start **/ 
        if ( ulCreateReq_p->cqiMaskV920 != FALSE )
            /** SPR 14459 Changes End **/ 
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->ueIdx,
                    ulCreateReq_p->cqiMaskV920,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                    DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                    "CQI_MASK_V920_INVALID_VALUE");         
            return MAC_FAILURE;
        }
        /** SPR 14459 Changes Start **/ 
        /* if cqiMaskV920 TAG is present and  cqiMaskV920 value is 0
         * then cqi mask should be set to TRUE */
        ulCreateReq_p->cqiMaskV920 = TRUE;
        /** SPR 14459 Changes End **/ 
        tag = LTE_GET_U16BIT(msg_p);
    }

    if (PMI_RI_REPORT_V920 == tag)
    {
        msg_p += 2;
        msg_p += 2;

        ulCreateReq_p->pmiRiReportV920 = *msg_p++;
        if (ulCreateReq_p->pmiRiReportV920 != TRUE && 
                ulCreateReq_p->pmiRiReportV920 != FALSE )
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->ueIdx,
                    ulCreateReq_p->pmiRiReportV920,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                    DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                    "PMI_RI_REPORT_V920_INVALID_VALUE");
            return MAC_FAILURE;
        }
        /* + TM7_8 Changes Start */
        dlCreateReq_p->pmiRiReportV920 = ulCreateReq_p->pmiRiReportV920;
        /* - TM7_8 Changes End */
    }
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUECodebookSubsetRestriction 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the Codebook subset restriction in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECodebookSubsetRestriction( 
        UInt8 **msgBuf, UInt16 tagLen, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p           = PNULL;
    /* + Coverity 55021 */
    /* code removed  */
    /* - Coverity 55021 */
    /* + CL-MIMO LJA*/
    UInt8  i               = 0;
    /* - CL-MIMO LJA*/

    msg_p = *msgBuf;

    if ( tagLen != 13 )
    {
        lteWarning("Invalid Tag Length for \
                codebookSubsetRestriction MAC_CREATE_UE_ENTITY_REQ\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                DEFAULT_INT_VALUE, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for \
                codebookSubsetRestriction MAC_CREATE_UE_ENTITY_REQ");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* Codebook subset restriction is supported for 
     *  transmission modes 3, 4, 5 and 6
     */ 
    if((3 == dlCreateReq_p->transmissionMode)||
            (4 == dlCreateReq_p->transmissionMode)||
            (5 == dlCreateReq_p->transmissionMode)||
            (6 == dlCreateReq_p->transmissionMode)
      )
    {
        /* + Coverity 32763 */ 
        dlCreateReq_p->cbsrInfo.cbsrType = (codebookSubsetRestrictionType) *msg_p++;
        /* - Coverity 32763 */ 

        for (i = 0; i < MAX_CBSR_SIZE; i++)
        {
            dlCreateReq_p->cbsrInfo.cbsrValue[i] = *msg_p++;
        }
        /* + Coverity 55021 */
        if (( validateCBSR( &dlCreateReq_p->cbsrInfo, 
                        (UInt8) dlCreateReq_p->transmissionMode, 
                        /* +- SPR 17777 */
                        internalCellIndex) != MAC_SUCCESS))
        {
            lteWarning("Atleast one bit should be 1 in \
                    cbsrValue in MAC_CREATE_UE_ENTITY_REQ\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlCreateReq_p->cbsrInfo.cbsrType,
                    internalCellIndex,
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Atleast one bit should be 1 in \
                    cbsrValue in MAC_CREATE_UE_ENTITY_REQ");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
            /* - Coverity 55021 */
        }
    }
    else
    {
        lteWarning("codebookSubsetRestriction received for \
                transmission mode other than 3,4,5,6 in \
                MAC_CREATE_UE_ENTITY_REQ\n");                                        
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlCreateReq_p->transmissionMode,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "codebookSubsetRestriction received for\
                    TM other than 3,4,5,6 in MAC_CREATE_UE_ENTITY_REQ");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEDRXConfigInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the DRX Config information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEDRXConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p           = PNULL;
    UInt16 resp   = MAC_SUCCESS;

    msg_p = *msgBuf;

    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,dlCreateReq_p->ueIndex,DRX_CONFIG_INFO,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "DRX_TAG_RECEIVED_DURING_CONFIG");

    resp =  parseDRXConfigInfo( &msg_p, tagLen, dlCreateReq_p 
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if( MAC_FAILURE == resp )
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,DRX_CONFIG_INFO,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "DRX_PARSE_FAIL_DURING_CONFIG.");

        return  MAC_FAILURE;
    }    
    dlCreateReq_p->drxRequestType = TRUE;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEMeasGapConfigInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the Meas Gap Config information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEMeasGapConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p  = PNULL;
    UInt16 resp   = MAC_SUCCESS;

    msg_p = *msgBuf;

    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,dlCreateReq_p->ueIndex,MEAS_GAP_CONFIG_INFO,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "MEASGAP_TAG_RECEIVED_DURING_CONFIG");

    resp =  parseMeasGapConfigInfo( &msg_p, tagLen, dlCreateReq_p 
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if( MAC_FAILURE == resp )
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,
                MEAS_GAP_CONFIG_INFO,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "MEASGAP_PARSE_FAIL_DURING_CONFIG.");

        return  MAC_FAILURE;
    }
    dlCreateReq_p->measGapRequestType = TRUE;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEPuschConfigInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the PUSCH Config information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEPuschConfigInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf;

    if ( tagLen != PUSCH_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for PUSCH Info\n",tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for PUSCH Info");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->betaOffsetAckIndex = *msg_p++;
    if ( ulCreateReq_p->betaOffsetAckIndex > 
            MAC_MAX_BETA_OFFSET_ACK_INDEX ) 
    {
        lteWarning("Invalid range for betaOffsetAckIndex [%d]\n",
                ulCreateReq_p->betaOffsetAckIndex);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->betaOffsetAckIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for betaOffsetAckIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->betaOffsetRiIndex = *msg_p++;
    if ( ulCreateReq_p->betaOffsetRiIndex > 
            MAC_MAX_BETA_OFFSET_RI_INDEX ) 
    {
        lteWarning("Invalid range for betaOffsetRiIndex [%d]\n",
                ulCreateReq_p->betaOffsetRiIndex);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->betaOffsetRiIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for betaOffsetRiIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->betaOffsetCQIIndex = *msg_p++;
    if ( ulCreateReq_p->betaOffsetCQIIndex > 
            MAC_MAX_BETA_OFFSET_CQI_INDEX ) 
    {
        lteWarning("Invalid range for betaOffsetCQIIndex [%d]\n",
                ulCreateReq_p->betaOffsetCQIIndex);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory fields missing in DL_LC_CREATE_REQ_LEN");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->puschConfigInfoFlag = TRUE;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEULPowerCtrlDedicated 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the UL Power Control dedicated info in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEULPowerCtrlDedicated( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p           = PNULL;
    UInt16 retval   = MAC_SUCCESS;
    DedicatedULPowerControlInfo* dedicatedULPowControlInfo_p = PNULL;

    msg_p = *msgBuf;

    if((tagLen - TAG_LEN) < ULP_CONTROL_DEDICATED_PARAM_LEN)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,UPLINK_POWER_CONTROL_DEDICATED,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "UPLINK_POWER_CONTROL_DEDICATED");

        return MAC_FAILURE;
    }
    dedicatedULPowControlInfo_p = &(ulCreateReq_p->dedicatedULPowerControlInfo);
    retval = parseDedicatedULPowerControlInfo(msg_p, 
            dedicatedULPowControlInfo_p
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );

    if(MAC_FAILURE == retval)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,ulCreateReq_p->ueIdx,UPLINK_POWER_CONTROL_DEDICATED,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "UPLINK_POWER_CONTROL_DEDICATED_PARSE_FAIL");

        return MAC_FAILURE;
    }
    /*Incrementing the msg pointer*/
    msg_p += ULP_CONTROL_DEDICATED_PARAM_LEN;

    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,ulCreateReq_p->ueIdx,UPLINK_POWER_CONTROL_DEDICATED,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "UPLINK_POWER_CONTROL_DEDICATED_PARSE_SUCCESS");

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUETpcPdcchConfigPucch 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the TPC PDCCH Config PUCCH info in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUETpcPdcchConfigPucch( UInt8 **msgBuf, 
        /* +- SPR 17777 */
        UInt16 tagLen,
        /* +- SPR 17777 */
        UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p           = PNULL;
    UInt16 retval   = MAC_SUCCESS;
    TpcPdcchConfig* tpcPdcchConf_p = PNULL;

    msg_p = *msgBuf;

    if((tagLen - TAG_LEN) < MIN_TPC_PDCCH_CONFIG_PARAM_LENGTH)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,TPC_PDCCH_CONFIG_PUCCH,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "TPC_PDCCH_CONFIG_PUCCH_INVALID_LENGTH");

        return MAC_FAILURE;
    }
    tpcPdcchConf_p = &(dlCreateReq_p->tpcPdcchConfigPucch);

    /* CLPC_REWORK CHG */
    tpcPdcchConf_p->release = *msg_p++;

    if((FALSE != tpcPdcchConf_p->release) && 
            (TRUE != tpcPdcchConf_p->release))
    {
        lteWarning("Invalid release. Value = %d\n",
                tpcPdcchConf_p->release);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tpcPdcchConf_p->release,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tpcPdcch release");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    if (!tpcPdcchConf_p->release)
    {
        retval = parseTpcPdcchConfig(msg_p,
                tagLen,
                tpcPdcchConf_p,
                FALSE,
                internalCellIndex);
    }
    /* CLPC_REWORK_CHG END */
    /* Incrementing the msg Pointer, Subtracting 1 cz for release it has been
       incremented already */
    msg_p += (tagLen - TAG_LEN - 1);

    if(MAC_FAILURE == retval)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,TPC_PDCCH_CONFIG_PUCCH,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "TPC_PDCCH_CONFIG_PUCCH_PARSE_FAILURE");
        return MAC_FAILURE;
    }
    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,dlCreateReq_p->ueIndex,TPC_PDCCH_CONFIG_PUCCH,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "TPC_PDCCH_CONFIG_PUCCH_PARSE_SUCCESS");

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUETpcPdcchConfigPusch 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the TPC PDCCH Config PUSCH info in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUETpcPdcchConfigPusch( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p                   = PNULL;
    UInt16 retval                  = MAC_SUCCESS;
    TpcPdcchConfig* tpcPdcchConf_p = PNULL;

    msg_p = *msgBuf;

    if((tagLen - TAG_LEN) < MIN_TPC_PDCCH_CONFIG_PARAM_LENGTH)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,TPC_PDCCH_CONFIG_PUSCH,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "TPC_PDCCH_CONFIG_PUSCH_INVALID_LENGTH");
        return MAC_FAILURE;
    }
    tpcPdcchConf_p = &(ulCreateReq_p->tpcPdcchConfigPusch);

    /* CLPC_REWORK CHG */
    tpcPdcchConf_p->release = *msg_p++;

    if((FALSE != tpcPdcchConf_p->release) && 
            (TRUE != tpcPdcchConf_p->release))
    {
        lteWarning("Invalid release. Value = %d\n",
                tpcPdcchConf_p->release);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tpcPdcchConf_p->release,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tpcPdcch release");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    if (!tpcPdcchConf_p->release)
    {
        retval = parseTpcPdcchConfig( msg_p, tagLen, tpcPdcchConf_p, TRUE 
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                );
    }
    /* CLPC_REWORK_CHG END */
    /*Incrementing the msg Pointer, Subtracting 1 cz for release it has been
      incremented already */
    msg_p += (tagLen - TAG_LEN - 1);

    if(MAC_FAILURE == retval)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,TPC_PDCCH_CONFIG_PUSCH,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "TPC_PDCCH_CONFIG_PUSCH_PARSE_FAILURE");
        return MAC_FAILURE;
    }
    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,dlCreateReq_p->ueIndex,TPC_PDCCH_CONFIG_PUCCH,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "TPC_PDCCH_CONFIG_PUCCH_PARSE_SUCCESS");

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUserLocationType 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the User Location Type info in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUserLocationType( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p )
{
    UInt8 userLocationType = CC_USER;

    if((tagLen - TAG_LEN) < USER_LOCATION_TYPE_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid USER_LOCATION_TYPE_LEN %u\n",(tagLen - TAG_LEN));
        return MAC_FAILURE;
    }

    userLocationType = *(*msgBuf)++;
    if(userLocationType >= MAX_USER_LOCATION)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid userLocationType :%u\n",userLocationType);
        return MAC_FAILURE;
    }
    dlCreateReq_p->userLocationType = userLocationType;
    ulCreateReq_p->userLocationType = userLocationType;

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEULMuMimoInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the UL MU MIMO information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEULMuMimoInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p                   = PNULL;
    UInt8 ulMUMIMOStatus = UL_MU_MIMO_DISABLED;
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    msg_p = *msgBuf;

    /*Checking the length of VALUE*/
    if(tagLen != (UL_MU_MIMO_TYPE_LEN + TAG_LEN))
    {
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid MU_MIMO Length");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    /*Retreiving the value*/
    ulMUMIMOStatus = *msg_p++;
    if(ulMUMIMOStatus > UL_MU_MIMO_ENABLED)
    {
        /*Invalid value received*/
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulMUMIMOStatus,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid ulMUMIMOStatus received");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    else if ( (NUM_OF_TX_ANTENNAS_1 == cellParams_p->\
                numOfTxAnteenas) && 
            (UL_MU_MIMO_ENABLED == ulMUMIMOStatus) )
    {
        lteWarning("Invalid config for mu mimo, no of antennas < 2\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cellParams_p->numOfTxAnteenas,
                internalCellIndex,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid config for mu mimo, no of antennas < 2");
        /* Review comment fix end RJ13 */
        ulMUMIMOStatus = UL_MU_MIMO_DISABLED;
    }
    ulCreateReq_p->ulMUMIMOStatus = ulMUMIMOStatus;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateRFParams 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the RF parameters in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateRFParams( UInt8 **msgBuf, UInt16 tagLen,
        /* +- SPR 17777 */
#ifdef HD_FDD_CONFIG
        UeContextForUplink *ulCreateReq_p,
#endif
        UeContextForDownlink *dlCreateReq_p 
        /* +- SPR 17777 */
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
#ifdef HD_FDD_CONFIG
    UInt8 hdFddFlag = FALSE;
#endif

    if(tagLen != RF_PARAMS_LEN)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlCreateReq_p->ueIndex,RF_PARAMS,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "RF_PARAMS_INVALID_LENGTH");
        return MAC_FAILURE;
    }
#ifdef HD_FDD_CONFIG
    /* SPR 12136 fix start */
    hdFddFlag = *(*msgBuf);
    /* SPR 12136 fix end */

    /* The flag should be either TRUE or FALSE */
    if((hdFddFlag!=TRUE) && (hdFddFlag!= FALSE))
    {
        LOG_MAC_MSG(MAC_HD_FDD_INVALID_FLAG,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),hdFddFlag,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "Invalid Flag received in Create UE");
        return MAC_FAILURE;
    }
    dlCreateReq_p->isHDFddFlag = hdFddFlag;
    ulCreateReq_p->isHDFddFlag = hdFddFlag;
#endif
    /* SPR 12136 fix start */
    (*msgBuf) += 1;
    /* SPR 12136 fix end */

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUECategoryInfo 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the UE Category information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECategoryInfo( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p    = PNULL;
    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    msg_p = *msgBuf;

    if ( tagLen != UE_CATEGORY_TAG_LEN )
    {  
        lteWarning("Invalid Tag Length %d for UE_CATEGORY  Info\n"
                ,tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for UE_CATEGORY");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    dlCreateReq_p->ueCategory = *msg_p++;
    ulCreateReq_p->ueCategory = dlCreateReq_p->ueCategory;
    resp = validateUeCategory(dlCreateReq_p->ueCategory 
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    /* Cyclomatic_complexity_changes_start */
    getUlModSchemeFromMcsIndex(ulCreateReq_p->mcsIndex, 
            &(ulCreateReq_p->modScheme), cellParams_p->macEnable64QAM, 
            ulCreateReq_p->ueCategory);
    /* Cyclomatic_complexity_changes_end */

    ulCreateReq_p->ueCategoryReqType = TRUE;
    dlCreateReq_p->ueCategoryReqType = TRUE;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEPhrTimerConfig 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the PHR Timer Config information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEPhrTimerConfig( UInt8 **msgBuf, 
        UInt16  tagLen, UeContextForUplink *ulCreateReq_p 
        /* +- SPR 17777 */
        )
{
    UInt8 *msg_p    = PNULL;
    UInt16 resp     = MAC_SUCCESS;
    UInt16 tag      = 0;

    msg_p = *msgBuf;

    if((tagLen - TAG_LEN) < PHR_TIMER_CONFIG_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid PHR_TIMER_CONFIG_LEN : %u\n",(tagLen - TAG_LEN)); 
        return MAC_FAILURE;
    }  

    if (1 == *msg_p++)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        if (tag != PHR_TIMER_INFO || (tagLen - TAG_LEN  != PHR_TIMER_INFO_LEN))
        {
            LOG_MAC_ERROR(MAC_RRC_INF,"Invalid tag %u or PHR_TIMER_INFO_LEN : %u\n",tag,(tagLen - TAG_LEN)); 
            return MAC_FAILURE;
        } 
        /* +- SPR 17777 */
        resp = parsePHRTimerConfig( &msg_p,ulCreateReq_p);
        /* +- SPR 17777 */
        if(MAC_FAILURE == resp)
        {
            return MAC_FAILURE;
        }
    }
    else
    {
        ulCreateReq_p->phrGrant = INVALID_PHR_GRANT;
        ulCreateReq_p->phrTimerCfg.periodicPHRTimer = 0;
        ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 0;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUEComplianceRelease 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the UE Compliance Release information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUEComplianceRelease( UInt8 **msgBuf, 
        UInt16 tagLen, UeContextForUplink   *ulCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p    = PNULL;

    msg_p = *msgBuf;

    if ( tagLen != UE_COMPLIANCE_RELEASE_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for \
                UE_COMPLIANCE_RELEASE\n",tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for UE_COMPLIANCE_RELEASE");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->ueComplianceRelease = *msg_p++;
    if((RELEASE_8 != 
                ulCreateReq_p->ueComplianceRelease) &&
            (RELEASE_9 != 
             ulCreateReq_p->ueComplianceRelease) && 
            (RELEASE_10 != 
             ulCreateReq_p->ueComplianceRelease) 
            ) 
    {
        lteWarning("Invalid release recd from L3.....Value=%d\n",
                ulCreateReq_p->ueComplianceRelease);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueComplianceRelease,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid release recd from L3");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseCreateLcReq
 * Inputs         : msg_p - pointer to the input buffer
 *                  origTagLen - length of the API message received
 *                  ulLCCreateReq_p - pointer to uplink create LC structure
 *                  dlLCCreateReq_p - pointer to downlink create LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to create a UE context.
 ****************************************************************************/
STATIC  MacRetType parseCreateLcReq ( UInt8 *msg_p,
        UInt16 origTagLen,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    UInt8 rlcMode = 0,lchId = 0;
    UInt16 tagLen = 0;
    UInt16 len = origTagLen;
    UInt16 tag; 

    /* decode the LC ID */
    lchId = *msg_p++;

    /* validation of logical channel id */
    resp = validateLchId(lchId
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {    
        return resp;
    }

    if (lchId == 1 || lchId == 2)
    {
        dlLCCreateReq_p->logicalChConfig[lchId].channelType = SRB;
        ulLCCreateReq_p->lcInfo[lchId].channelType = SRB;
    }

    rlcMode = *msg_p++;

    /* validation of rlc mode */
    resp = validateRlcMode(rlcMode, internalCellIndex);
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    len -= CREATE_LC_REQ_MIN_LEN;
    /* Atleast DL or UL tag should be present */
    if (len < TAG_LEN)
    {
        lteWarning("Atleast DL or UL tag should be present .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Atleast DL or UL tag should be present");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    while ( len > 0 )
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        len -= tagLen; 

        switch ( tag )
        {
            case UL_LC_CREATE_REQ:
            {
                /* Cyclomatic Complexity changes - starts here */
                if (MAC_SUCCESS != parseUlLcCreateReq (rlcMode, lchId, tag, tagLen, 
                            &msg_p, ulLCCreateReq_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            ))
                {
                    return MAC_FAILURE;
                }
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case DL_LC_CREATE_REQ:
            {
                /* Cyclomatic Complexity changes - starts here */
                if (MAC_SUCCESS != parseDlLcCreateReq (rlcMode, lchId, tag, 
                            tagLen, &msg_p, dlLCCreateReq_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            ))
                {
                    return MAC_FAILURE;
                }
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case QOS_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseCreateLcQosInfo (
                        tagLen, msg_p, dlLCCreateReq_p, ulLCCreateReq_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                if (MAC_SUCCESS != resp)
                {
                    return resp;
                }
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case ROHC_PROFILE:
            {
                /* Cyclomatic Complexity changes - starts here */
                if (MAC_SUCCESS != parseCreateLcRohcProfile (lchId,
                            tagLen, msg_p, dlLCCreateReq_p, ulLCCreateReq_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            ))
                {
                    return MAC_FAILURE;
                }
                /* Cyclomatic Complexity changes - ends here */
                msg_p += (tagLen - TAG_LEN);
            }
            break;
            /* SPS_CHG */

            default:
            {
                lteWarning("Invalid tag received for CREATE_LC_REQ\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tag,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid tag received for CREATE_LC_REQ");
                /* Review comment fix end RJ13 */
                /* + coverity 32217 */  
                return MAC_FAILURE;
                /* - coverity 32217 */  
            }
        }/*end of switch*/
    }/*end of while*/
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseUlLcCreateReq
 * Inputs         : rlcMode - Indicates the RLC Mode
 *                  lchId - stores the logical channel Id
 *                  tag - API message 
 *                  tagLen - length of the API message received
 *                  msg_p - Pointer to API message received
 *                  ulLCCreateReq_p - pointer to uplink create LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or Error code
 * Description    : This function parse the UL LC Create Request and fills 
 *                  in the structure needed by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseUlLcCreateReq( UInt8 rlcMode, UInt8 lchId,
        UInt16 tag, UInt16 tagLen, UInt8 **msg_p, 
        UeContextForUplink *ulLCCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 lchIdx = 0;
    if (tagLen < UL_LC_CREATE_REQ_LEN)
    {
        lteWarning("Mandatory fields missing in UL_LC_CREATE_REQ_LEN.\n");
        lteWarning("Received [%d] and Expected [%d]\n",tagLen,UL_LC_CREATE_REQ_LEN);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory fields missing in UL_LC_CREATE_REQ_LEN");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    lchIdx = ulLCCreateReq_p->numLogicalChannels;
    if (lchIdx >= MAC_MAX_LCHID)
    {
        lteWarning("Invalid LcId Received [%d] UL_LC_CREATE_REQ\n",lchId);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lchIdx,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid LcId Received in UL_LC_CREATE_REQ");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    ulLCCreateReq_p->lcInfo[lchIdx].lchId = lchId;
    if (lchId == 1 || lchId == 2)
    {
        ulLCCreateReq_p->lcInfo[lchIdx].channelType = SRB;
    }

    ulLCCreateReq_p->lcInfo[lchIdx].operationType = ADD;
    ulLCCreateReq_p->lcInfo[lchIdx].rlcMode       = rlcMode;
    ulLCCreateReq_p->lcInfo[lchIdx].lcGId         = *(*msg_p)++;   

    /*! \code
     * Initializing the ROHC Profile with NO-ROHC
     *\endcode
     */
    ulLCCreateReq_p->lcInfo[lchIdx].rohcProfile = ROHC_PROFILE_MAX_VALUE ;

#if defined(QOS_SI_FWK_TEST) || defined(UTFWK_SIMULATION)
    ulLCCreateReq_p->lcInfo[lchIdx].logicalChannelPriority = *(*msg_p)++;   
#endif 

    /* SPR 3608 changes start */
    ulLCCreateReq_p->lcInfo[lchIdx].uePSRReqFlag = FALSE;
    if(rlcMode == 2)/*AM Mode*/
    { 
        if(tagLen == UL_LC_CREATE_REQ_OPT_LEN)
        {
            tag = LTE_GET_U16BIT(*msg_p);
            *msg_p += 2;

            tagLen = LTE_GET_U16BIT(*msg_p);
            *msg_p += 2;

            if(tag == UE_PSR_REQ)
                ulLCCreateReq_p->lcInfo[lchIdx].uePSRReqFlag = *(*msg_p)++;
        }
    }
    /* SPR 3608 changes end */ 
    ulLCCreateReq_p->numLogicalChannels++;

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseDlLcCreateReq 
 * Inputs         : rlcMode - Indicates the RLC Mode
 *                  lchId - stores the logical channel Id
 *                  tag - API message 
 *                  tagLen - length of the API message received
 *                  msg_p - Pointer to API message received
 *                  dlLCCreateReq_p - pointer to downlink create LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or Error code
 * Description    : This function parse the DL LC Create Request and fills 
 *                  in the structure needed by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseDlLcCreateReq( UInt8 rlcMode, UInt8 lchId,
        UInt16 tag, UInt16 tagLen, UInt8 **msg_p, 
        UeContextForDownlink *dlLCCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 rlcSNFieldLength = 0;
    UInt8 lchIdx = 0;
    UInt8 AccumOptionaltagLen = 0;

    if (tagLen < DL_LC_CREATE_REQ_LEN)
    {
        lteWarning("Mandatory fields missing in DL_LC_CREATE_REQ_LEN.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory fields missing in DL_LC_CREATE_REQ_LEN");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    lchIdx = dlLCCreateReq_p->dwlkLogicalChCount;
    if (lchIdx >= MAC_MAX_LCHID)
    {
        lteWarning("Invalid LcId Received [%d] in DL_LC_CREATE_REQ\n",lchId);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lchIdx,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid LcId Received in DL_LC_CREATE_REQ");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    dlLCCreateReq_p->logicalChConfig[lchIdx].lchId         = lchId;
    dlLCCreateReq_p->logicalChConfig[lchIdx].operationType = ADD;
    dlLCCreateReq_p->logicalChConfig[lchIdx].rlcMode       = rlcMode;

    /*! \code
     * Initializing the ROHC Profile with NO-ROHC
     *\endcode
     */
    dlLCCreateReq_p->logicalChConfig[lchIdx].rohcProfile = ROHC_PROFILE_MAX_VALUE ;

    dlLCCreateReq_p->logicalChConfig[lchIdx].lchPriority = *(*msg_p)++; 
    if (MAC_SUCCESS !=  validateLchPriority( 
                dlLCCreateReq_p->logicalChConfig[lchIdx].lchPriority
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ))
    {    
        return MAC_FAILURE;
    }

    rlcSNFieldLength = *(*msg_p)++;

    if (rlcSNFieldLength != 5 && rlcSNFieldLength != 10)
    {
        lteWarning("Invalid rlcSNFieldLength set");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                rlcSNFieldLength,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid rlcSNFieldLength set");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    dlLCCreateReq_p->logicalChConfig[lchIdx].rlcSNFieldLength = rlcSNFieldLength;

    /* SPR 3608 changes start */
    dlLCCreateReq_p->logicalChConfig[lchIdx].enbPSRReqFlag = FALSE;

    /* SPR 12439 Start */
    if(tagLen > DL_LC_CREATE_REQ_LEN)
    {
        /* Here msg_p points to the start of Optional area. */
        while (AccumOptionaltagLen < tagLen - DL_LC_CREATE_REQ_LEN)
        {    
            tag = LTE_GET_U16BIT(*msg_p);
            switch (tag)
            { 
                case ENB_PSR_REQ:
                {
                    if(rlcMode == 2)/*AM Mode*/
                    { 
                        *msg_p += 2;
                        AccumOptionaltagLen += LTE_GET_U16BIT(*msg_p);
                        *msg_p += 2;

                        dlLCCreateReq_p->logicalChConfig[lchIdx].enbPSRReqFlag = *(*msg_p)++;
                    }
                }
                break;

                case CA_LC_BANDWIDTH_DIST_INFO:
                {
                    /* CA changes Start */
                    if(tag == CA_LC_BANDWIDTH_DIST_INFO)
                    {
                        if (QOS_GBR == dlLCCreateReq_p->logicalChConfig[lchIdx].channelType)
                        {
                            *msg_p += U16BIT_LEN;
                            AccumOptionaltagLen += LTE_GET_U16BIT(*msg_p);
                            *msg_p += U16BIT_LEN;

                            if (CA_LC_BANDWIDTH_DIST_INFO_TAG_LEN != AccumOptionaltagLen)
                            {
                                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                        rlcSNFieldLength,
                                        internalCellIndex, 
                                        __LINE__, 
                                        DEFAULT_INT_VALUE, 
                                        DEFAULT_INT_VALUE, 
                                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                        FUNCTION_NAME, 
                                        "Invalid CA_LC_BANDWIDTH_DIST_INFO len");
                                return MAC_FAILURE;
                            }
                            UInt8 index = 0, sumBandwidth = 0, bandWidthDistribution[MAX_SERVCELL] = {0};
                            /* Fetching Bandwidth distribution info from TLV  for a Psell and 
                               scell upto MAX_SERVCELL */
                            for (index = PCELL_SERV_CELL_IX; index < MAX_SERVCELL; index++)
                            {
                                bandWidthDistribution[index] = *(*msg_p);
                                *msg_p += 1;
                                if ( MAC_SUCCESS != (macValidateCALCBandwidthDistribution
                                            (bandWidthDistribution[index])) )
                                {
                                    lteWarning("Parsing DlLcCreateReq failed.\nInvalid CA LC\
                                            Bandwidth Distribution Info\n");
                                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                            AccumOptionaltagLen,
                                            DEFAULT_INT_VALUE, 
                                            __LINE__, 
                                            DEFAULT_INT_VALUE, 
                                            DEFAULT_INT_VALUE, 
                                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                            FUNCTION_NAME, 
                                            "bandWidthDistribution out of range");
                                    return MAC_FAILURE;
                                }
                                dlLCCreateReq_p->logicalChConfig[lchIdx].bandWidthDistribution
                                    [index] = bandWidthDistribution[index];
                                dlLCCreateReq_p->logicalChConfig[lchIdx].isBandWidthTagPresent 
                                    = TRUE;
                                sumBandwidth += bandWidthDistribution[index];
                            }
                            if (MAX_CA_LC_BANDWIDTH_DIST_VAL != sumBandwidth)
                            {
                                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                        AccumOptionaltagLen,
                                        internalCellIndex, 
                                        __LINE__, 
                                        DEFAULT_INT_VALUE, 
                                        DEFAULT_INT_VALUE, 
                                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                        FUNCTION_NAME, 
                                        "bandWidthDistribution enteries does"
                                        "not make a sum of 100");
                                return MAC_FAILURE;
                            }
                        }
                        else
                        {
                            lteWarning("CA_LC_BANDWIDTH_DIST_INFO cannot be received for NON-GBR\n");
                            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                    AccumOptionaltagLen,
                                    internalCellIndex, 
                                    __LINE__, 
                                    DEFAULT_INT_VALUE, 
                                    DEFAULT_INT_VALUE, 
                                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                    FUNCTION_NAME, 
                                    "CA_LC_BANDWIDTH_DIST_INFO cannot be received"
                                    "for NON-GBR");
                            return MAC_FAILURE;
                        }
                    }
                    /* CA changes End */

                }
                break;
            }
        }/* End of while*/

    }
    /* SPR 12439 End */
    /* SPR 3608 changes end */ 

    dlLCCreateReq_p->dwlkLogicalChCount++;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateLcQosInfo 
 * Inputs         : tagLen - length of the API message received
 *                  msg_p - Pointer to API message received
 *                  dlLCCreateReq_p - pointer to downlink create LC structure
 *                  ulLCCreateReq_p - pointer to uplink create LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or Error code
 * Description    : This function parse the Create LC Qos info.
 ******************************************************************************/
STATIC  MacRetType parseCreateLcQosInfo( UInt16 tagLen, UInt8 *msg_p,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* + Coverity 32759 */
    MacRetType resp = MAC_SUCCESS;
    /* - Coverity 32759 */
    LogicalChannelConfigInfo * dlLcInfo_p = PNULL;
    ulLogicalChannelInfo * ulLcInfo_p = PNULL;

    if( tagLen < QOS_INFO_MIN_LEN || !(dlLCCreateReq_p->dwlkLogicalChCount || 
                ulLCCreateReq_p->numLogicalChannels) )
    { 
        lteWarning("Mac syntax length error .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex,
                __LINE__, 
                ulLCCreateReq_p->numLogicalChannels, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax length error");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    if (dlLCCreateReq_p->dwlkLogicalChCount)
    {
        dlLcInfo_p = &dlLCCreateReq_p->logicalChConfig[
            dlLCCreateReq_p->dwlkLogicalChCount - 1];
    }
    if (ulLCCreateReq_p->numLogicalChannels)
    {
        ulLcInfo_p = &ulLCCreateReq_p->lcInfo[
            ulLCCreateReq_p->numLogicalChannels - 1];
    }

    /*SPR 4017 PH2 Start*/
    if(dlLcInfo_p && ulLcInfo_p)
    {
        resp = parseQosInfo( &msg_p, tagLen,
                /* SPR 2836 Fix Begin*/
                dlLcInfo_p, ulLcInfo_p
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                );
        /* SPR 2836 Fix End */
        if (resp != MAC_SUCCESS)
        {    
            lteWarning("Qos Parsing Failed .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    resp,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Qos Parsing Failed");
            /* Review comment fix end RJ13 */
            return resp;
        }
    }
    /*SPR 4017 PH2 End*/
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateLcRohcProfile
 * Inputs         : lchId - Stores logical channel ID
 *                  tagLen - length of the API message received
 *                  msg_p - Pointer to API message received
 *                  dlLCCreateReq_p - pointer to downlink create LC structure
 *                  ulLCCreateReq_p - pointer to uplink create LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or Error code
 * Description    : This function parse the Create LC ROHC profile.
 ******************************************************************************/
STATIC  MacRetType parseCreateLcRohcProfile( UInt8 lchId, UInt16 tagLen,
        UInt8 *msg_p, UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* + Coverity 32759 */
    MacRetType resp = MAC_SUCCESS;
    /* - Coverity 32759 */
    LogicalChannelConfigInfo * dlLcInfo_p = PNULL;
    ulLogicalChannelInfo * ulLcInfo_p = PNULL;

    if(!(dlLCCreateReq_p->dwlkLogicalChCount ||  
                ulLCCreateReq_p->numLogicalChannels) )
    { 
        lteWarning("Mac syntax length error .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlLCCreateReq_p->dwlkLogicalChCount,
                internalCellIndex,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax length error");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    if (dlLCCreateReq_p->dwlkLogicalChCount)
    {
        dlLcInfo_p = &dlLCCreateReq_p->logicalChConfig[
            dlLCCreateReq_p->dwlkLogicalChCount - 1];
    }
    if (ulLCCreateReq_p->numLogicalChannels)
    {
        ulLcInfo_p = &ulLCCreateReq_p->lcInfo[
            ulLCCreateReq_p->numLogicalChannels - 1];
    }

    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID, LOGDEBUG, MAC_RRC_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER, lchId, ROHC_PROFILE, internalCellIndex, 
            DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "ROHC_PROFILE_TAG_RECEIVED_DURING_CONFIG" );
    if(dlLcInfo_p && ulLcInfo_p)
    {
        resp =  parseRohcProfile( msg_p, tagLen, dlLcInfo_p, ulLcInfo_p 
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                );
    }
    else
    {
        resp = MAC_FAILURE;
    }
    if( MAC_FAILURE == resp )
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,lchId,ROHC_PROFILE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "ROHC_PROFILE_PARSE_FAILURE");
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigLcReq
 * Inputs         : msg_p - Pointer to API message received
 *                  reconfigLcReqTagLen - length of the API message received
 *                  dlLCReconfigReq_p - pointer to reconfigure downlink  LC structure
 *                  ulLCReconfigReq_p - pointer to reconfigure uplink  LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to reconfigure a UE context.
 ****************************************************************************/

STATIC  MacRetType parseReconfigLcReq( UInt8 *msg_p,
        UInt16 reconfigLcReqTagLen,
        UeContextForDownlink *dlLCReconfigReq_p,
        UeContextForUplink *ulLCReconfigReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    UInt8 lchId = 0;
    UInt8 lcIdx = 0;
    UInt16 tagLen = 0;
    UInt16 tag = 0;

    LogicalChannelConfigInfo * dlLcInfo_p = PNULL;
    ulLogicalChannelInfo * ulLcInfo_p = PNULL;

    lchId = *msg_p++;
    /* validation of logical channel id */
    resp = validateLchId(lchId
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }

    reconfigLcReqTagLen -= RECONFIG_LC_REQ_MIN_LEN;
    /* Atleast DL or UL tag should be present */
    if ( reconfigLcReqTagLen < TAG_LEN)
    {
        lteWarning("Atleast DL or UL tag should be present .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reconfigLcReqTagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Atleast DL or UL tag should be present");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    /* SPR# 2882 Changes Starts */
    else
    {
        ulLCReconfigReq_p->lcInfo[ulLCReconfigReq_p->numLogicalChannels].lchId = lchId;
        dlLCReconfigReq_p->logicalChConfig[dlLCReconfigReq_p->dwlkLogicalChCount].lchId = lchId;
        ulLCReconfigReq_p->numLogicalChannels++;
        dlLCReconfigReq_p->dwlkLogicalChCount++;
        /* SPS_CHG */
        /*!
         *\code
         * Initializing the isRohcProfilePresent Falg with FALSE value.
         *\endcode
         */
        dlLCReconfigReq_p->logicalChConfig[dlLCReconfigReq_p->dwlkLogicalChCount - 1].\
            isRohcProfilePresent = FALSE;
        ulLCReconfigReq_p->lcInfo[ulLCReconfigReq_p->numLogicalChannels - 1].\
            isRohcProfilePresent = FALSE;
        /* SPS_CHG */
    }
    /* SPR# 2882 Changes Ends */

    while ( reconfigLcReqTagLen > 0)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        reconfigLcReqTagLen -= tagLen;
        switch ( tag)
        {
            case UL_LC_RECONFIGURE_REQ:
            if (tagLen != UL_LC_RECONFIG_REQ_LEN)
            {
                lteWarning("Mandatory fields missing in UL_LC_RECONFIG_REQ_LEN.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Mandatory fields missing in UL_LC_RECONFIG_REQ_LEN");
                /* Review comment fix end RJ13 */
                /* + coverity 32211 */
                return MAC_FAILURE;
                /* - coverity 32211 */
            }
            lcIdx = ulLCReconfigReq_p->numLogicalChannels;
            if (lcIdx >= MAC_MAX_LCHID)
            {
                lteWarning("Maximum UL LC reached.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        lcIdx,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Maximum UL LC reached");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
            /* SPR 16157 start */
            ulLCReconfigReq_p->lcInfo[lcIdx -1].operationType = RECONFIGURE;
            /* SPR 16157 end */
            break;

            case DL_LC_RECONFIGURE_REQ:
            /* CA changes Start */
            if (tagLen < DL_LC_RECONFIG_REQ_LEN)
                /* CA changes End */
            {
                lteWarning("Mandatory fields missing in DL_LC_RECONFIG_REQ_LEN.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Mandatory fields missing in DL_LC_RECONFIG_REQ_LEN");
                /* Review comment fix end RJ13 */
                /* + coverity 32211 */
                return MAC_FAILURE;
                /* - coverity 32211 */
            }
            /* Cyclomatic Complexity changes start */
            resp = parseDLReconfigureLcReq(dlLCReconfigReq_p, tagLen, &msg_p,
                    internalCellIndex);  
            /* Cyclomatic Complexity changes end */
            break;

            /* Reconfigure Lc changes for Qos */
            case GBR_QOS_INFO:
            /*CA changes start*/
            /*KLOCWORK_FIX_START_45*/
            if(tagLen != GBR_INFO_LEN ||
                    /*KLOCWORK_FIX_END_45*/
                    /*CA changes End*/
                    !(dlLCReconfigReq_p->dwlkLogicalChCount 
                        || ulLCReconfigReq_p->numLogicalChannels))
            {
                lteWarning("Mac syntax length error .\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex,
                        __LINE__, 
                        ulLCReconfigReq_p->numLogicalChannels, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Mac syntax length error");
                /* Review comment fix end RJ13 */
                /* + coverity 32211 */
                return MAC_FAILURE;
                /* - coverity 32211 */
            }
            /* Cyclomatic Complexity changes start */
            /* +- SPR 17777 */
            resp = reconfigureLcChangesForQos(dlLCReconfigReq_p,
                    ulLCReconfigReq_p,&msg_p);
            /* +- SPR 17777 */
            /* Cyclomatic Complexity changes end */

            break;
            /* Reconfigure Lc changes for Qos */
            /* SPS_CHG */
            /*!
             *\code
             * Parsing the ROHC Profile Recived in RECONFIG_LC
             *\endcode
             */
            case ROHC_PROFILE:
            {
                if (dlLCReconfigReq_p->dwlkLogicalChCount)
                {
                    dlLcInfo_p = &dlLCReconfigReq_p->logicalChConfig[
                        dlLCReconfigReq_p->dwlkLogicalChCount - 1];
                    dlLCReconfigReq_p->logicalChConfig[dlLCReconfigReq_p->dwlkLogicalChCount - 1].
                        operationType = RECONFIGURE;
                }
                /*Klockwork fix start*/
                else
                {
                    /*Should not reach here due to check in top of the function*/
                }
                /*Klockwork fix end*/
                if (ulLCReconfigReq_p->numLogicalChannels)
                {
                    ulLcInfo_p = &ulLCReconfigReq_p->lcInfo[
                        ulLCReconfigReq_p->numLogicalChannels - 1];
                    ulLCReconfigReq_p->lcInfo[ulLCReconfigReq_p->numLogicalChannels - 1].
                        operationType = RECONFIGURE;
                }
                /*Klockwork fix start*/
                else
                {
                    /*Should not reach here due to check in top of the function*/
                }
                /*Klockwork fix end*/

                LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        LINE_NUMBER,lchId,ROHC_PROFILE,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "ROHC_PROFILE_TAG_RECEIVED_DURING_LC_RE_CONFIG.");
                resp =  parseRohcProfile(msg_p, 
                        tagLen,
                        dlLcInfo_p,
                        ulLcInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                if( MAC_FAILURE == resp )
                {
                    LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            LINE_NUMBER,lchId,ROHC_PROFILE,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,
                            "ROHC_PROFILE_PARSE_FAILURE");
                    return MAC_FAILURE;
                }
                dlLcInfo_p->isRohcProfilePresent = TRUE;
                ulLcInfo_p->isRohcProfilePresent = TRUE;
                msg_p += (tagLen - TAG_LEN);
            }
            break;
            /* SPS_CHG */

            default:
            lteWarning("Invalid tag received for RECONFIG_LC_REQ\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tag,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid tag received for RECONFIG_LC_REQ");
            /* Review comment fix end RJ13 */
            /* + coverity 32217 */
            return MAC_FAILURE;
            /* - coverity 32217 */
        }
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseDLReconfigureLcReq
 * Inputs         : dlLCReconfigReq_p - pointer to reconfigure downlink  LC structure
 *                  tagLen-  API length 
 *                  msg_p - Pointer to API message received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to reconfigure a UE context for DL
 ****************************************************************************/

STATIC  MacRetType parseDLReconfigureLcReq(UeContextForDownlink *dlLCReconfigReq_p,
        UInt16 tagLen,
        UInt8 **msg_p,
        InternalCellIndex internalCellIndex
        )
{

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    MacRetType resp = MAC_SUCCESS;
    UInt8 lcIdx = 0;
    UInt16 tag = 0;
    lcIdx = dlLCReconfigReq_p->dwlkLogicalChCount;
    if (lcIdx >= MAC_MAX_LCHID)
    {
        lteWarning("Maximum UL LC reached.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lcIdx,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Maximum UL LC reached");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;

    }
    /* SPR 16157 start */
    dlLCReconfigReq_p->logicalChConfig[lcIdx -1].operationType = RECONFIGURE;
    /* SPR 16157 end */
    /* CA changes Start */
    if(tagLen == (CA_LC_BANDWIDTH_DIST_INFO_TAG_LEN + DL_LC_RECONFIG_REQ_LEN))
    {
        UInt8 numBandwidthDist = 0, sumBandwidth = 0,
              bandWidthDistribution[MAX_SERVCELL] = {0};
        tag = LTE_GET_U16BIT(*msg_p);
        *msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(*msg_p);
        *msg_p += U16BIT_LEN;
        if ( CA_LC_BANDWIDTH_DIST_INFO == tag)
        {
            if (QOS_GBR == dlLCReconfigReq_p->logicalChConfig[lcIdx].channelType)
            {
                /* Fetching Bandwidth distribution info from TLV  for a Psell and 
                   scell upto MAX_SERVCELL */
                for (numBandwidthDist = PCELL_SERV_CELL_IX; numBandwidthDist < 
                        (MAX_SERVCELL); numBandwidthDist++)
                {
                    bandWidthDistribution[numBandwidthDist] = **msg_p;
                    *msg_p = *msg_p + 1;
                    resp = macValidateCALCBandwidthDistribution(
                            bandWidthDistribution[numBandwidthDist]);
                    if ( MAC_SUCCESS != resp )
                    {
                        lteWarning("Parsing ReconfigLcReq failed.\nInvalid" 
                                "CA LC Bandwidth Distribution Info\n");
                        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                tagLen,
                                DEFAULT_INT_VALUE, 
                                __LINE__, 
                                DEFAULT_INT_VALUE, 
                                DEFAULT_INT_VALUE, 
                                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME, 
                                "Invalid CA_LC_BANDWIDTH_DIST_INFO");
                        return MAC_FAILURE;
                    }
                    dlLCReconfigReq_p->logicalChConfig[lcIdx].
                        bandWidthDistribution[numBandwidthDist] = 
                        bandWidthDistribution[numBandwidthDist];
                    dlLCReconfigReq_p->logicalChConfig[lcIdx].
                        isBandWidthTagPresent = TRUE;
                    sumBandwidth += bandWidthDistribution[numBandwidthDist];
                }
                if (MAX_CA_LC_BANDWIDTH_DIST_VAL != sumBandwidth)
                {
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            tagLen,
                            DEFAULT_INT_VALUE, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "bandWidthDistribution enteries does"
                            "not make a sum of 100");
                    return MAC_FAILURE;
                }
            }
            else
            {
                lteWarning("CA_LC_BANDWIDTH_DIST_INFO cannot be received for NON-GBR\n");
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "CA_LC_BANDWIDTH_DIST_INFO cannot" 
                        "be received for NON-GBR");
                return MAC_FAILURE;
            }
        }
    }
    /* CA changes End */
    return resp;
}

/****************************************************************************
 * Function Name  : reconfigureLcChangesForQos
 * Inputs         : dlLCReconfigReq_p - pointer to reconfigure downlink  LC structure
 *                  ulLCReconfigReq_p - pointer to reconfigure uplink  LC structure
 *                  msg_p - Pointer to API message received
 *                  tagLen- length of API
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function Reconfigures LC request for QOS
 ****************************************************************************/
STATIC  MacRetType reconfigureLcChangesForQos( UeContextForDownlink *dlLCReconfigReq_p,
        UeContextForUplink *ulLCReconfigReq_p,
        UInt8 **msg_p
        /* +- SPR 17777 */
        )
{

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    MacRetType resp = MAC_SUCCESS;
    LogicalChannelConfigInfo * dlLcInfo_p = PNULL;
    ulLogicalChannelInfo * ulLcInfo_p = PNULL;
    if (dlLCReconfigReq_p->dwlkLogicalChCount)
    {
        dlLcInfo_p = &dlLCReconfigReq_p->logicalChConfig[
            dlLCReconfigReq_p->dwlkLogicalChCount - 1];

        /* SPR# 3815 Changes Starts*/
        dlLCReconfigReq_p->logicalChConfig[dlLCReconfigReq_p->dwlkLogicalChCount - 1].
            operationType = RECONFIGURE;
        /* SPR# 3815 Changes Ends*/
    }
    if (ulLCReconfigReq_p->numLogicalChannels)
    {
        ulLcInfo_p = &ulLCReconfigReq_p->lcInfo[
            ulLCReconfigReq_p->numLogicalChannels - 1];

        /* SPR# 3815 Changes Starts*/
        ulLCReconfigReq_p->lcInfo[ulLCReconfigReq_p->numLogicalChannels - 1].
            operationType = RECONFIGURE;
        /* SPR# 3815 Changes Ends*/
    }

    /* SPR  3444 changes start */
    parseGBRInfo(msg_p,
            /* SPR  3444 changes end */
            /* SPR 2836 Fix Begin */
            dlLcInfo_p,
            ulLcInfo_p);
    /* SPR 2836 Fix End */
    return resp;
}

/****************************************************************************
 * Function Name  : parseDeleteLcReq
 * Inputs         : msg_p - Pointer to API message received
 *                  deleteLcReqTagLen - length of the API message received
 *                  dlLCDeleteReq_p - pointer to delete downlink  LC structure
 *                  ulLCDeleteReq_p - pointer to delete uplink  LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to delete LC context in a UE context.
 ****************************************************************************/

STATIC  MacRetType parseDeleteLcReq( UInt8 *msg_p,
        UInt16 deleteLcReqTagLen,
        UeContextForDownlink *dlLCDeleteReq_p,
        UeContextForUplink *ulLCDeleteReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    UInt32 lchId  = 0;
    UInt32 lcType = 0;
    UInt32 lcIdx  = 0;
    /* Atleast DL or UL tag should be present */
    if ( deleteLcReqTagLen != DELETE_LC_REQ_LEN)
    {
        lteWarning("Atleast DL or UL tag should be present .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                deleteLcReqTagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Atleast DL or UL tag should be present");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    lchId = *msg_p++;
    /* validation of logical channel id */
    resp = validateLchId(lchId 
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    /* LC Types represent the operation for  
       1 - Only Downlink - DL_LC_INFO
       2 - Only uplink   - UL_LC_INFO
       3 - Both          - UL_DL_LC_INFO
       */
    lcType = *msg_p++;

    if ((lcType == ZERO) || (lcType > MAX_LC_TYPE))
    {
        lteWarning("Invalid Lc Type [%d]", lcType);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lcType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Lc Type");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    if ((UL_DL_LC_INFO == lcType) || (UL_LC_INFO == lcType))
    {
        lcIdx = ulLCDeleteReq_p->numLogicalChannels;
        if (lcIdx < MAC_MAX_LCHID)
        {
            ulLCDeleteReq_p->lcInfo[lcIdx].lchId = lchId;
            ulLCDeleteReq_p->lcInfo[lcIdx].operationType = DELETE;
            ulLCDeleteReq_p->numLogicalChannels++;    
        }
    }    
    if ((UL_DL_LC_INFO == lcType) || (DL_LC_INFO == lcType))
    {
        lcIdx = dlLCDeleteReq_p->dwlkLogicalChCount;
        if (lcIdx < MAC_MAX_LCHID)
        {
            dlLCDeleteReq_p->logicalChConfig[lcIdx].lchId = lchId;
            dlLCDeleteReq_p->logicalChConfig[lcIdx].operationType = DELETE;
            dlLCDeleteReq_p->dwlkLogicalChCount++;
        }
    }

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/* + coverity 52748 */
#ifdef MAC_AUT_TEST 
/****************************************************************************
 * Function Name  : validateRnti
 * Inputs         : tcRnti  - UE Identifier.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes ueId to validate and returns the result of
 *                  validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateRnti(UInt16 tcRnti
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{    
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((tcRnti < cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->lowerRNTIBound) ||
            (tcRnti >cellSpecificParams_g.cellConfigAndInitParams_p\
             [internalCellIndex]->initParams_p->upperRNTIBound))
    {
        lteWarning("Invalid range for cRnti.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tcRnti,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for tcRnti");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
#endif
/* + coverity 52748 */

/****************************************************************************
 * Function Name  : validateUEIndex
 * Inputs         : ueIndex  - UE Index which uniquely identifies UE.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes ueIndex to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateUEIndex(UInt32 ueIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    /* SPR 1767 changes start */ 
    if (ueIndex >= MAX_UE_SUPPORTED)
        /* SPR 1767 changes end */ 
    {
        lteWarning("Invalid range for ue index.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ueIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for ueIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    else
    {
        LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
        return MAC_SUCCESS;
    }
}

/* SPR_1987 Start */
/****************************************************************************
 * Function Name  : validateMaxUlHarqTx
 * Inputs         : maxUlHarqTx - max UL Harq Tx Enum value
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE.
 * Description    : This API takes Max UL Harq Tx Enum value to validate and
 *                  return result of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateMaxUlHarqTx(UInt8 maxUlHarqTx
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if(maxUlHarqTx < MAX_UL_HARQ_TX_VAL_IDX)
    {
        return MAC_SUCCESS;
    }
    /* Review comment fix start RJ13 */
    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            maxUlHarqTx,
            internalCellIndex, 
            __LINE__, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, 
            "Invalid range for maxUlHarqTx");
    /* Review comment fix end RJ13 */
    return MAC_FAILURE;
}

/****************************************************************************
 * Function Name  : convertMaxUlHarqEnumInVal
 * Inputs         : maxUlHarqTx  - max UL Harq Tx Enum value
 * Outputs        : None
 * Returns        : Converted value for max UL Harq Tx
 * Description    : This API takes maxUlHarqTx Enum value to convert it into
 *                  maxUlHarqTx mapped valueand return converted value to the
 *                  calling function.
 ****************************************************************************/
STATIC  UInt8 convertMaxUlHarqEnumInVal(UInt8 maxUlHarqTx)
{
    UInt8 maxUlHarqTxVal[MAX_UL_HARQ_TX_VAL_IDX] =
    {1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 20,
        24, 28};
    return (maxUlHarqTxVal[maxUlHarqTx]);
}
/* SPR_1987 End */

/*Fix for __SPR_1988__ START*/
/****************************************************************************
 * Function Name  : validateTimeAlignmentTimer
 * Inputs         : timeAlignmentTimer  - TimeAlignmentTimer value received
 *                                        from RRC.
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE.
 * Description    : This API takes TA Timer value to validate and returns the
 *                  result of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateTimeAlignmentTimer(UInt16 timeAlignmentTimer)
{
    if(timeAlignmentTimer < MAX_TIME_ALIGNMENT_TIMER_IDX)
    {
        return MAC_SUCCESS;
    }
    return MAC_FAILURE;
}

/****************************************************************************
 * Function Name  : convertTAIntoULSyncTimerVal
 * Inputs         : timeAlignmentTimer  - TimeAlignmentTimer value received
 *                                        from RRC.
 * Outputs        : None
 * Returns        : Converted value in ms for UL Sync Loss Timer
 * Description    : This API takes TA Timer value to convert it into
 *                  ulSyncTimer in ms and return the converted value to the
 *                  calling function.
 ****************************************************************************/
/* + coverity 52754 */
#ifdef MAC_AUT_TEST
STATIC  UInt16 convertTAIntoULSyncTimerVal(UInt16 timeAlignmentTimer)
{
    UInt16 taTimerVal[MAX_TIME_ALIGNMENT_TIMER_IDX] =
    {500, 750, 1280, 1920, 2560, 5120, 10240,
        UL_SYNC_TIMER_INFINITY};
    if(timeAlignmentTimer == (MAX_TIME_ALIGNMENT_TIMER_IDX - 1))
    {
        /*Return value is infinity, thus no need to add DELAY factor here*/
        return taTimerVal[timeAlignmentTimer];
    }
    else
    {
        return (taTimerVal[timeAlignmentTimer] + UL_SYNC_PDCCH_ORDER_DELAY);
    }
}
#endif
/* - coverity 52754 */
/*Fix for __SPR_1988__ END*/

/****************************************************************************
 * Function Name  : convertTATimerInMs
 * Inputs         : timeAlignmentTimer  - TimeAlignmentTimer value received
 *                                        from RRC.
 * Outputs        : None
 * Returns        : Converted value in ms for UL Sync Loss Timer
 * Description    : This API takes TA Timer value to convert it into
 *                  Time Alignment timer in ms and return the converted value 
 *                  to the calling function.
 ****************************************************************************/
STATIC  UInt16 convertTATimerInMs(UInt16 timeAlignmentTimer)
{
    UInt16 taTimerVal[MAX_TIME_ALIGNMENT_TIMER_IDX] =
    {500, 750, 1280, 1920, 2560, 5120, 10240,
        TIME_ALIGNMENT_TIMER_INFINITY};
    return taTimerVal[timeAlignmentTimer];
}

/*SPR_3061_FIX*/
/* + coverity 52751 */
#ifdef MAC_AUT_TEST 
/****************************************************************************
 * Function Name  : validateUePriority
 * Inputs         : uePriority- to indicate the priority among other UEs
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes uePriority to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateUePriority(UInt8 uePriority
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if (uePriority > MAC_MAX_UEPRIORITY)
    {
        lteWarning("Invalid range for ue priority.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                uePriority,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for ue priority");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
#endif
/* - coverity 52751 */

/****************************************************************************
 * Function Name  : validateueNumHarqProcess
 * Inputs         : numHarqProcess- to indicate the number of Harqprocess of UEs
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes numHarqProcess to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

/* + coverity 52753 */
#ifdef MAC_AUT_TEST
STATIC  MacRetType validateueNumHarqProcess(UInt8 numHarqProcess
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{ 
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if (numHarqProcess < MAC_MIN_NUM_HARQ || numHarqProcess > MAC_MAX_NUM_HARQ )
    {
        lteWarning("Invalid Number of Harq Process for ue .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                numHarqProcess,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Number of Harq Process for ue");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
#endif
/*  coverity 52753 */

/* SPR 2063 start */
/****************************************************************************
 * Function Name  : validateMcsIndex
 * Inputs         : mcsIndex - that tells the modulation and coding scheme used
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes mcsIndex to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateMcsIndex(UInt32 mcsIndex 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{ 
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    /* SPR  3444 changes start */
    if (MCS_INDEX_64QAM_28 >= mcsIndex)
        /* SPR  3444 changes end */
    {
        return MAC_SUCCESS;
    }    
    else
    {
        lteWarning("Invalid range for mcsIndex.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                mcsIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for mcsIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
}

/* SPR 2063 end */
/****************************************************************************
 * Function Name  : validateDlMaxRB
 * Inputs         : MaxRB - tells the maximum no of RBS a UE can have.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes MaxRB to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateDlMaxRB(UInt8 MaxRB
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ( MaxRB > cellParams_p->dlAvailableRBs ) 
    {
        lteWarning("MAX RB [%d ] of UE is more than the DL AvailableRBs [%d ]"
                ",hence setting the max RB = %d [ DL AvailableRBs] \n",
                MaxRB,cellParams_p->dlAvailableRBs,cellParams_p->dlAvailableRBs );
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MaxRB,
                internalCellIndex,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "MAX RB of UE is more than the DL AvailableRBs\
                ,hence setting the max RB = DL AvailableRBs");
        /* Review comment fix end RJ13 */
        /* SPR 2446 Fix Begin */
        return MAC_FAILURE;
        /* SPR 2446 Fix Ends */
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatehScheme
 * Inputs         : hScheme - the type of harq scheme used.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes hScheme to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

/* + coverity 52752 */
#ifdef MAC_AUT_TEST
STATIC  MacRetType validatehScheme(UInt8 hScheme
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if (hScheme != MAC_HSCHEME_VALUE)
    {
        lteWarning("Invalid range for hScheme.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                hScheme,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for hScheme");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
#endif
/* - coverity 52752 */

/****************************************************************************
 * Function Name  : validateTransmissionMode
 * Inputs         : transmissionMode - tells the mode of transmission .
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes transmissionMode to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateTransmissionMode(UInt8 transmissionMode
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((transmissionMode < MAC_MIN_TRANSMISSION_MODE) || 
            (transmissionMode > MAC_MAX_TRANSMISSION_MODE))
    {
        lteWarning("Invalid range for transmission mode.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for transmission mode");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#ifdef FAPI_4_0_COMPLIANCE
    /*Adding Checks*/
    if((transmissionMode == TX_MODE_8) &&
            (phyReleaseCapability_g == RELEASE_8))
    {


        LOG_MAC_MSG(MAC_INVALID_TRANSMISSION_MODE,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                transmissionMode,
                phyReleaseCapability_g, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "MAC_INVALID_TRANSMISSION_MODE:Transmission Mode Incompatible with PHY Release Capability");

        return MAC_FAILURE;

    }
    /*Adding Checks*/
#endif

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatesimultaneousACKNACKAndCQI  
 * Inputs         : simultaneousACKNACKAndCQI - value of ACK/NACK with CQI 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes simultaneousACKNACKAndCQI  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateSimultaneousACKNACKAndCQI(UInt8 simultaneousACKNACKAndCQI
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{ 
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_0) && 
            (simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_1))
    {
        lteWarning("Invalid range for simultaneousACKNACKAndCQI .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                simultaneousACKNACKAndCQI,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for simultaneousACKNACKAndCQI");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/* L2_FIX_13_start*/
/****************************************************************************
 * Function Name  : validateTransmissionModeAndLayer
 * Inputs         : transmissionMode - tells the mode of transmission .
 *                : numOfLayer -       tells the Number of layers.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes transmissionMode/ Num layers to validate and returns the
 *                  results of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateTransmissionModeAndLayer(UInt8 transmissionMode, UInt8 numOfLayer,
        InternalCellIndex internalCellIndex)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((transmissionMode < MAC_MIN_TRANSMISSION_MODE) ||
            (transmissionMode > MAC_MAX_TRANSMISSION_MODE))
    {
        lteWarning("Invalid range for transmission mode:%d.\n", transmissionMode);
        return MAC_FAILURE;
    }

    if ((numOfLayer != RANK_INDICATOR_1) &&
            (numOfLayer != RANK_INDICATOR_2) &&
            /*4x4 DL MIMO CHG START*/
            (numOfLayer != RANK_INDICATOR_3)&&
            (numOfLayer != RANK_INDICATOR_4))
        /*4x4 DL MIMO CHG END*/
    {
        lteWarning("Invalid range for rankIndicator:%d\n", numOfLayer);
        return MAC_FAILURE;
    }

    /* Maximum one layer possible with TM mode 1/2/5/6/7 */
    if ((transmissionMode == TX_MODE_1 ) || 
            (transmissionMode == TX_MODE_2 ) ||
            (transmissionMode == TX_MODE_6 ) || 
            (transmissionMode == TX_MODE_7 ))
    {
        if (numOfLayer != RANK_INDICATOR_1)
        {
            lteWarning("Invalid range for rankIndicator:%d for TM mode:%d\n",
                    numOfLayer, transmissionMode);
            /* Discussion required with RRM Team */        
            //   return MAC_FAILURE;
        }
    }
    /* Upto 4 layers possible with TM 3/4 */
#ifdef FAPI_4_0_COMPLIANCE
    /*Adding Checks*/
    if((transmissionMode == TX_MODE_8) &&
            (phyReleaseCapability_g == RELEASE_8))
    {

        LOG_MAC_MSG(MAC_INVALID_TRANSMISSION_MODE,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                transmissionMode,
                phyReleaseCapability_g, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "MAC_INVALID_TRANSMISSION_MODE:Transmission Mode Incompatible with PHY Release Capability");

        return MAC_FAILURE;

    }
    /*Adding Checks*/
#else
    (void)internalCellIndex;/*SPR 19565 warning fix*/
#endif

    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validateCqiformatIndicatorPeriodic
 * Inputs         : cqiformatIndicatorPeriodic - cqi format Indicator for Periodic 
 *                  subband/wideband
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes cqiformatIndicatorPeriodic  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateCqiformatIndicatorPeriodic (UInt8 cqiformatIndicatorPeriodic)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    if ((cqiformatIndicatorPeriodic != PERIODIC_WIDEBAND) &&
            (cqiformatIndicatorPeriodic != PERIODIC_SUBBAND))
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid range for cqiformatIndicatorPeriodic:%d\n", cqiformatIndicatorPeriodic);
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 *  * Function Name  : validateCqiformatIndicatorPeriodicSubbandK
 *  * Inputs         : cqiPeriodicSubbandK: cqi format Indicator for Periodic subband k
 *  * Outputs        : None
 *  * Returns        : MAC_SUCCESS or reason for failure.
 *  * Description    : This API takes cqiformatIndicatorPeriodic_subband_k  to validate and returns the result
 *  *                  of validation to the calling function.
 *  ***************************************************************************/
STATIC  MacRetType validateCqiformatIndicatorPeriodicSubbandK (UInt8 cqiPeriodicSubbandK)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    if ((cqiPeriodicSubbandK > MAC_MAX_SUBBAND_CQI_K) ||
            (cqiPeriodicSubbandK < MAC_MIN_SUBBAND_CQI_K ))
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid range for CQI format Indicator Periodic subband k:%d\n",
                cqiPeriodicSubbandK);
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}
/* L2_FIX_14_end*/

/****************************************************************************
 * Function Name  : validateSRRequestType 
 * Inputs         : requestType - 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes requestType  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateSRRequestType(UInt8 requestType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    if ((requestType != REQUEST_TYPE_0) && 
            (requestType != REQUEST_TYPE_1))
    {
        lteWarning("Invalid range for requestType .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                requestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for requestType");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatesrConfigurationIndex
 * Inputs         : srConfigurationIndex - 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes srConfigurationIndex  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateSrConfigurationIndex(UInt8 srConfigurationIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if (srConfigurationIndex > MAC_MAX_SRCONFIGURATIONINDEX)
    {
        lteWarning("Invalid range for srConfigurationIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                srConfigurationIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for srConfigurationIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/* SPR 903 Start*/
/****************************************************************************
 * Function Name  : validateUeCategory
 * Inputs         : ueCategory 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes ueCategory  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateUeCategory(UInt8 ueCategory
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if ( ueCategory > MAC_MAX_UE_CATEGORY ||
            ueCategory < MAC_MIN_UE_CATEGORY )
    {
        lteWarning("Invalid range for UeCategory .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ueCategory,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for UeCategory");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}
/* SPR 903 End*/

/****************************************************************************
 * Function Name  : validatesrPucchResourceIndex
 * Inputs         : srPucchResourceIndex 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes srPucchResourceIndex  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateSrPucchResourceIndex(UInt16 srPucchResourceIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if (srPucchResourceIndex > MAC_MAX_SRPUCCHRESOURCEINDEX)
    {
        lteWarning("Invalid range for srPucchResourceIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                srPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for srPucchResourceIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatecqimode
 * Inputs         : cqimode - any value among 12, 20, 22, 30, 31 
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API validates the Aperiodic CQI mode and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateCqiMode(UInt8 cqimode)
{
    if ((cqimode != CQI_MODE_1_2)&&
            (cqimode != CQI_MODE_2_0)&& 
            (cqimode != CQI_MODE_2_2)&& 
            (cqimode != CQI_MODE_3_0)&& 
            (cqimode != CQI_MODE_3_1))
    {
        lteWarning("Invalid CQI Aperiodic Mode:%d\n", cqimode);
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validatenumOfLayer
 * Inputs         : numOfLayer - Number of layer.Its value can be 1-4 
 *                  ueCategory
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes numOfLayer  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateNumOfLayer(UInt8 numOfLayer , 
        UInt8 ueCategory,
        /* CA changes Start */
        InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /*4x4 DL MIMO CHG START*/
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    /* SPR 11355 Fix Start */
    if(ueCategory == UE_CAT_5 || ueCategory == UE_CAT_8)
        /* SPR 11355 Fix End */
    {
        if(numOfLayer > MAX_NUM_OF_LAYER_4x4 ||
                numOfLayer < MIN_NUM_OF_LAYER )
        {
            lteWarning("Invalid range for numOfLayer .\n");
            return MAC_FAILURE;
        }
        if(numOfLayer >= RANK_INDICATOR_3 && cellParams_p->numOfTxAnteenas != 4)
        {
            lteWarning("Invalid range for Tx Antenna .\n");
            return MAC_FAILURE;
        } 
    }
    /*4x4 DL MIMO CHG END*/
    else
    {
        if (numOfLayer > MAX_NUM_OF_LAYER ||
                numOfLayer < MIN_NUM_OF_LAYER )
        {
            lteWarning("Invalid range for numOfLayer .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    numOfLayer,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid range for numOfLayer");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
    }
    return MAC_SUCCESS;
}


/* + coverity 52749 */
#ifdef MAC_AUT_TEST 
/****************************************************************************
 * Function Name  : validateServiceType
 * Inputs         : ServiceType - Service Type 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes ServiceType  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateServiceType(UInt8 ServiceType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if ((ServiceType != SERVICE_TYPE_1) && 
            (ServiceType != SERVICE_TYPE_2)&&
            (ServiceType != SERVICE_TYPE_3))
    {
        lteWarning("Invalid range for ServiceType .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ServiceType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for ServiceType");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}
#endif
/* - coverity 52749 */


/****************************************************************************
 * Function Name  : validatePrecodingIndex
 * Inputs         : precodingIndex - It specifies  precoding matrix index 
 to be used 
 internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes precodingIndex  to validate and 
 *                  returns the result of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validatePrecodingIndex(UInt8 precodingIndex,
        InternalCellIndex internalCellIndex)
{
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    if ( ((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_2) &&
                (precodingIndex > MAX_PRE_CODING_INDEX_ANT_2)) ||
            ((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_4) &&
             (precodingIndex > MAX_PRE_CODING_INDEX_ANT_4)) )
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid precodingIndex %u\n",precodingIndex);
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/*--coverity-530 CID 52747 */
#ifdef MAC_AUT_TEST
/*--coverity-530 CID 52747 */
/****************************************************************************
 * Function Name  : validateLcType
 * Inputs         : lcType - LC type 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes lcType  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateLcType(UInt8 lcType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* +COVERITY 10044 */
    /* Rel 5.3: Coverity 32239 Fix Start */
    MacRetType retval = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32239 Fix End */
    if ((lcType != LC_TYPE_1) || 
            (lcType != LC_TYPE_2))
    {
        lteWarning("Invalid range for lcType .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lcType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for lcType");
        /* Review comment fix end RJ13 */
        retval = MAC_FAILURE;
    }
    return retval;
    /* -COVERITY 10044 */
}
#endif
/****************************************************************************
 * Function Name  : validateRlcMode
 * Inputs         : rlcMode - Indicates the type of rlc mode ie
 *                  0- TM,
 *                  1 -UM, 
 *                  2 - AM
 *                  internalCellIndex - cell index used at MAC
 * 
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes rlcMode  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateRlcMode(UInt8 rlcMode
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if (rlcMode <= MAX_RLC_MODE)
    {
        return MAC_SUCCESS;
    }
    else
    {
        lteWarning("Invalid range for rlcMode .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                rlcMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for rlcMode");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

}


/****************************************************************************
 * Function Name  : validateLchId
 * Inputs         : lchId - Logical channel id.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes lchId  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateLchId(UInt8 lchId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if (lchId > MAC_MAX_LCHID)
    {
        lteWarning("Invalid range for lchId .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lchId,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for lchId");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : validateLchPriority
 * Inputs         : lchPriority - Logical channel priority  
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes lchPriority  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateLchPriority(UInt8 lchPriority
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if ((lchPriority < MAC_MIN_LCHPRIORITY) || 
            (lchPriority > MAC_MAX_LCHPRIORITY))
    {
        lteWarning("Invalid range for lchPriority .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lchPriority,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for lchPriority");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/*--coverity-530 CID 52747 */
#ifdef MAC_AUT_TEST
/*--coverity-530 CID 52747 */
/****************************************************************************
 * Function Name  : validateLcGId
 * Inputs         : lcGId - Logical channel group Id of the LC.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes lchGId  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateLcGId(UInt8 lcGId
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if (lcGId > MAC_MAX_LCGID)
    {
        lteWarning("Invalid range for lcGId .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lcGId,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for lcGId");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}


/* + coverity 52750 */
/****************************************************************************
 * Function Name  : validateTransportChType
 * Inputs         : transportChType - 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes transportChType  to validate and returns the 
 *                  result of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateTransportChType(UInt8 transportChType
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* +COVERITY 10045 */
    /* Rel 5.3: Coverity 32239 Fix Start */
    MacRetType retval = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32239 Fix End */
    if ((transportChType != TRANSPORT_CH_TYPE_0) || 
            (transportChType != TRANSPORT_CH_TYPE_1))
    {
        lteWarning("Invalid range for transportChType .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                transportChType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for transportChType");
        /* Review comment fix end RJ13 */
        retval = MAC_FAILURE;
    }
    return retval;
    /* -COVERITY 10045 */
}
#endif
/* - coverity 52750 */

/****************************************************************************
 * Function Name  : validatecqiPMIConfigIndex
 * Inputs         : cqiPMIConfigIndex - Specifies the CQI/PMI periodicity 
 *                  and configuration index. 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes cqiPMIConfigIndex  to validate and returns 
 *                  the result of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateCqiPMIConfigIndex(UInt32 cqiPMIConfigIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* SPR 1583 Start */
#ifdef FDD_CONFIG
    if (cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX ||
            cqiPMIConfigIndex == MAC_MAX_CQI_PMI_CONFIG_INDEX_3_1_7  )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#elif TDD_CONFIG
    if (cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX_TDD )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
#endif
    /* SPR 1583 End*/

    return MAC_SUCCESS;
}
#if 0  
#endif


/****************************************************************************
 * Function Name  : validatecqiPucchResourceIndex
 * Inputs         : cqiPucchResourceIndex - Specifies the pucch resources for 
 periodic CQI on uplink.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes cqiPucchResourceIndex  to validate and 
 returns the result  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateCqiPucchResourceIndex(UInt32 cqiPucchResourceIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* + Coverity 54526 */
    if (cqiPucchResourceIndex > MAC_MAX_CQI_PUCCH_RESOURCE_INDEX)
    {
        lteWarning("Invalid range for cqiPucchResourceIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
    /* - Coverity 54526 */
}

/****************************************************************************
 * Function Name  : validateriConfigIndex
 * Inputs         : riConfigIndex - Specifies the RI configuration index. 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes riConfigIndex  to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateRiConfigIndex(UInt32 riConfigIndex
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    /* + Coverity 54525 */
    if (riConfigIndex > MAC_MAX_RI_CONFIG_INDEX)
    {
        lteWarning("Invalid range for riConfigIndex .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                riConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for riConfigIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
    /* - Coverity 54525 */
}

/* CA changes Start */
/****************************************************************************
 * Function Name  : prepareMacRrcApiHeader
 * Inputs         : msgBuf - Buffer to be filled
 *                  msgId - Msg Type to be send to RRC
 *                  msgLength - Length of the message inclusing header 
 *                  cellId - OAM configured cell index 
 * Outputs        : None
 * Returns        : None
 * Description    : This API takes the msgId & buffer to be filled by msg
 *                  header as input to be sent to RRC.
 ****************************************************************************/
 void prepareMacRrcApiHeader( 
        UInt8 *msgBuf_p, 
        UInt16 msgId,
        UInt16 msgLength, 
        RrcCellIndex cellId)
{
    /* transaction Id to be filled later */
    UInt16 current = API_HEADER_SOURCEID_OFFSET;

    LTE_SET_U16BIT(msgBuf_p + current, MAC_MODULE_ID);
    current += U16BIT_LEN;
    LTE_SET_U16BIT(msgBuf_p + current, RRC_MODULE_ID);
    current += U16BIT_LEN;
    LTE_SET_U16BIT(msgBuf_p + current, msgId);
    current += U16BIT_LEN;
    LTE_SET_U16BIT(msgBuf_p + current, msgLength);
    current += U16BIT_LEN;
    msgBuf_p[current] = cellId;

    return;
}
/* CA changes End */

/****************************************************************************
 * Function Name  : sendToRRC
 * Inputs         : dlUEInfo - pointer to the Downlink Ue context
 *                  ulUEInfo - pointer to the uplink Ue context
 *                  msgId - Msg Type to be send to RRC
 *                : data_p - pointer to the Data to be send
 *                  cellIndex - cell id sent by RRC
 *                  ulReconfigUeResp_p - Pointer to the Uplink 
 *                  UE Resp filled at reconfigure
 *                  dlReconfigUeResp_p - Pointer to the Downlink 
 *                  UE Resp filled at reconfigure
 * Outputs        : None
 * Returns        : None
 * Description    : This API takes the msgId & data to be send as input,
 *                  prepares the message and send it to RRC
 ****************************************************************************/
 SInt32 sendToRRC( UeContextForDownlink *dlUEInfo,
        UeContextForUplink *ulUEInfo,
		/* Coverity 530 CID 36230 */
        UInt32 msgId,
		/* Coverity 530 CID 36230 */
        void *data_p
		/* CA changes Start */
        ,RrcCellIndex cellIndex
		/* CA Changes End */
        ,ULReconfigUeResp *ulReconfigUeResp_p
        ,DLReconfigUeResp *dlReconfigUeResp_p
        )
{
	/* CA changes Start */
    InternalCellIndex internalCellIndex = INVALID_CELL_INDEX;
	/* CA Changes end */
    SInt32 retval = 0;
    UInt16 current_p = 0;
    UInt8 *msgBuf = PNULL; 
    UInt8 *resp_p = PNULL; 
    UInt8 wrongMsgId = FALSE;

	/* CA changes Start */
    internalCellIndex = macCommonGetInternalCellIndex(cellIndex);
    if (MAX_INTERNAL_CELL_INDEX < internalCellIndex)
    {
        return MAC_SEND_ERROR;    
    }
	/* CA Changes end */

    GET_MEM_FROM_POOL(UInt8,msgBuf,MAX_DATA_SIZE,PNULL);
	/*+COVERITY 5.3.0 - 32108*/
    if ( PNULL == msgBuf )
    {
        return MAC_SEND_ERROR;    
    }
	/*-COVERITY 5.3.0 - 32108*/
	/* SPR 11109 Fix start */ 
    memSet(msgBuf, 0, MAX_DATA_SIZE);
	/* SPR 11109 Fix end */ 

    resp_p = msgBuf;

    current_p = RRC_MAC_API_HEADER_LEN;
    switch ( msgId) 
    {
        case MAC_CREATE_UE_ENTITY_CNF:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacCreateUeEntityCnf (msgId, resp_p, data_p, 
                    &current_p, dlUEInfo, ulUEInfo
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;
        }
        case MAC_RECONFIGURE_UE_ENTITY_CNF:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacReconfigUeEntityCnf (msgId, resp_p, data_p, 
                    &current_p, dlUEInfo, ulUEInfo
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    ,ulReconfigUeResp_p
                    ,dlReconfigUeResp_p
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;
        }
        case MAC_UE_ENTITY_POWER_HEADROOM_IND:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacUeEntityPowerHeadroomInd (msgId, resp_p, data_p, 
                    &current_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end  */
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;
        }
        case MAC_CCCH_MSG_IND:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacCcchMsgInd( msgId, resp_p, data_p, 
                    &current_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end  */
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;
        }

        default:
        {
            wrongMsgId = TRUE;
            lteWarning("Incorrect msgId provided\n");

            LOG_MAC_MSG(MAC_SENDTO_INVALID_MSG_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    msgId,internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"SENDTO_INVALID_MSG_ID");

            break;
        }
    }

    prepareMacRrcApiHeader( resp_p, msgId, current_p, cellIndex);

    /* Send msg to RRC Layer */
    if (FALSE == wrongMsgId)
    {
        {
		/* SPR 5599 changes start (ZIP ID 129073) */
            retval = sendMacMsgToRRC( msgBuf, current_p, 0,
                    internalCellIndex );
            if (retval == -1)
            {
                LOG_MAC_ERROR( MAC_RRC_INF, "Unable to send message to RRC! "
                        "Length[%u] cellId[%u]", current_p, internalCellIndex );
            }
            else
            {
                LOG_UT(MAC_RES_MSG_ID,LOGDEBUG,MAC_OAM_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        msgId, MAC_MODULE_ID, RRC_MODULE_ID,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"MAC_RES_MSG_ID");
            }
		/* SPR 5599 changes end (ZIP ID 129073) */
        }
    }
    freeMemPool(msgBuf);
    return retval;
}

/****************************************************************************
 * Function Name  : prepareMacCreateUeEntityCnf 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                : msgBuf - Msg buffer to be sent to RRC 
 *                : data_p - pointer to the Data to be send
 *                : current_p_p - pointer to current_p index
 *                : dlUEInfo - pointer to the DL UE context
 *                : ulUEInfo - pointer to the UL UE context
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the response for 
 *                  MAC_CREATE_UE_ENTITY_REQ to be sent to RRC.
 ****************************************************************************/
STATIC  void prepareMacCreateUeEntityCnf( UInt16 msgId, UInt8 *msgBuf,
        void  *data_p, UInt16 *current_p_p, UeContextForDownlink *dlUEInfo,
        UeContextForUplink *ulUEInfo, InternalCellIndex internalCellIndex )
{
    /* + coverity 111603 */
    UInt16 ueIndex = dlUEInfo->rrcUeIndex;
    /* - coverity 111603 */
    UInt16 current_p = *current_p_p;

    /* Insert transactionId received for create request */
    LTE_SET_U16BIT(msgBuf, ((UEEntityCreateRes *)data_p)->transactionId);
    /* Insert ueIndex and response Code */
    LTE_SET_U16BIT(msgBuf + current_p, ueIndex);
    current_p += IDX_SIZE;

    LTE_SET_U16BIT(msgBuf + current_p, ((UEEntityCreateRes *)data_p)->response ); 
    current_p += 2;
    /* If responseCode is MAC_PARTIAL_SUCCESS, fill the LCs which failed in
     * config */
    LOG_MAC_MSG(MAC_UE_CREATE_CNF,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId,ueIndex,
            ((UEEntityCreateRes *)data_p)->response,
            dlUEInfo->cRnti,internalCellIndex,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"MAC_UE_CREATE_CNF");

    if (MAC_PARTIAL_SUCCESS == ((UEEntityCreateRes *)data_p)->response)
    {
        prepareLCErrorResponse(dlUEInfo,ulUEInfo, msgBuf,&current_p
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ,PNULL,PNULL
                );
    }
    /*! \code
     *   If SPS_CONFIG is Received then 
     *   Prepraring the MAC_UE_CREATE_CNF buffer with SPS Crnti
     * \endcode
     * */
    {
    if(TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
            [internalCellIndex]->initParams_p->spsSysWideParam.enableSps)
    {
        if ((((UEEntityCreateRes *)data_p)->spsCrnti))
        {  
            LTE_SET_U16BIT(msgBuf + current_p,SPS_CRNTI_INFO);
            current_p += U16BIT_LEN;
            LTE_SET_U16BIT(msgBuf + current_p,SPS_CRNTI_INFO_TAG_LENGTH);
            current_p += U16BIT_LEN;
            LTE_SET_U16BIT(msgBuf + current_p,((UEEntityCreateRes *)data_p)->spsCrnti);
            current_p += U16BIT_LEN;
        }
        LTE_MAC_UPDATE_SPS_CONFIG_RESP_STATS(LTE_TRUE,ueIndex,(((UEEntityCreateRes *)data_p)->spsCrnti));
    }
    }
    /* SPS_CHG */

    *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : prepareMacReconfigUeEntityCnf
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  msgBuf - Msg buffer to be sent to RRC 
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - pointer to current_p index
 *                  dlUEInfo - pointer to the DL UE context
 *                  ulUEInfo - pointer to the UL UE context
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeResp_p - Pointer to the Uplink 
 *                  UE Resp filled at reconfigure
 *                  dlReconfigUeResp_p - Pointer to the Downlink 
 *                  UE Resp filled at reconfigure
 * Outputs        : None
 * Returns        : None
 * Variables      :
 * Description    : This function prepares the response for 
 *                  MAC_RECONFIGURE_UE_ENTITY_REQ to be sent to RRC.
 ****************************************************************************/
STATIC  void prepareMacReconfigUeEntityCnf( UInt16 msgId, UInt8 *msgBuf,
        void *data_p, UInt16 *current_p_p, UeContextForDownlink *dlUEInfo,
        UeContextForUplink   *ulUEInfo
        ,InternalCellIndex internalCellIndex
        ,ULReconfigUeResp *ulReconfigUeResp_p, 
        DLReconfigUeResp *dlReconfigUeResp_p
        )
{
    /* + coverity 111603 */
    UInt16 ueIndex = dlUEInfo->rrcUeIndex;
    /* - coverity 111603 */
    UInt16 current_p = *current_p_p;

    /* Fill transactionId, ueIndex, response Code. If responseCode is
     *  MAC_PARTIAL_SUCCESS, add lcError structure after that 
     */
    LTE_SET_U16BIT(msgBuf, ((UEEntityReconfigRes *)data_p)->transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, ueIndex);
    current_p += IDX_SIZE;

    LTE_SET_U16BIT(msgBuf + current_p, (((UEEntityReconfigRes *)data_p)->response) );
    current_p += 2;

    LOG_MAC_MSG(MAC_UE_RECONFIGURE_CNF,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId,ueIndex,
            ((UEEntityCreateRes *)data_p)->response,
            dlUEInfo->cRnti,internalCellIndex,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"UE_RECONFIGURE_CNF");


    if ((MAC_PARTIAL_SUCCESS == ((UEEntityReconfigRes *)data_p)->response)||
            (MAC_SUCCESS == ((UEEntityReconfigRes *)data_p)->response))
    {
        prepareLCErrorResponse(dlUEInfo, ulUEInfo, msgBuf, &current_p
                , internalCellIndex
                ,ulReconfigUeResp_p,dlReconfigUeResp_p
                );
    }
    /*! \code
     *   If SPS_CONFIG is Received then 
     *   Prepraring the MAC_UE_RECONFIG_CNF buffer with SPS Crnti
     * \endcode
     * */
    if(TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
            [internalCellIndex]->initParams_p->spsSysWideParam.enableSps)
    {
        if ((((UEEntityCreateRes *)data_p)->spsCrnti))
        {  
            LTE_SET_U16BIT(msgBuf + current_p,SPS_CRNTI_INFO);
            current_p += U16BIT_LEN;
            LTE_SET_U16BIT(msgBuf + current_p,SPS_CRNTI_INFO_TAG_LENGTH);
            current_p += U16BIT_LEN;
            LTE_SET_U16BIT(msgBuf + current_p,((UEEntityCreateRes *)data_p)->spsCrnti);
            current_p += U16BIT_LEN;
        }
        LTE_MAC_UPDATE_SPS_CONFIG_RESP_STATS(LTE_TRUE,ueIndex,(((UEEntityCreateRes *)data_p)->spsCrnti));
    }
    /* SPS_CHG */

    *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : prepareMacUeEntityPowerHeadroomInd 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                : msgBuf - Msg buffer to be sent to RRC 
 *                : data_p - pointer to the Data to be send
 *                : current_p_p - pointer to current_p index
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Variables      :
 * Description    : This function prepares the  
 *                  MAC_UE_ENTITY_POWER_HEADROOM_IND to be sent to RRC.
 ****************************************************************************/
STATIC  void prepareMacUeEntityPowerHeadroomInd( UInt16 msgId,
        UInt8 *msgBuf, void *data_p, UInt16 *current_p_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 current_p = *current_p_p;
    UInt16 crnti = 0;
    UInt16 transactionId = 0xFFFF;

    LTE_SET_U16BIT(msgBuf, transactionId);            
    LTE_SET_U16BIT(msgBuf + current_p,((powerHeadroomInfo *)data_p)->ueIdx );
    current_p += IDX_SIZE;
    if (ulUECtxInfoArr_g[((powerHeadroomInfo
                    *)data_p)->ueIdx].ulUEContext_p->crnti)
    {
        crnti = ulUECtxInfoArr_g[((powerHeadroomInfo
                    *)data_p)->ueIdx].ulUEContext_p->crnti;
    }      
    LTE_SET_U16BIT(msgBuf + current_p, crnti);
    current_p += UEID_SIZE;

    LTE_SET_U16BIT(msgBuf + current_p, ((powerHeadroomInfo *)data_p)->powerHeadroom );
    current_p += PWR_HR_SIZE;

    LOG_MAC_MSG(MAC_UE_POWER_HEADROOM_IND,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId,INVALID_UE_ID,
            ((powerHeadroomInfo *)data_p)->powerHeadroom,
            /* SPR 2137 Start*/      
            crnti, internalCellIndex,
            /* SPR 2137 End*/      
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"UE_POWER_HEADROOM");

    *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : prepareMacCcchMsgInd
 * Inputs         : msgId - Msg Type to be send to RRC
 *                : msgBuf - Msg buffer to be sent to RRC 
 *                : data_p - pointer to the Data to be send
 *                : current_p_p - pointer to current_p index
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Variables      :
 * Description    : This function prepares the  
 *                  MAC_CCCH_MSG_IND to be sent to RRC.
 ****************************************************************************/
STATIC  void prepareMacCcchMsgInd( UInt16 msgId, UInt8  *msgBuf,
        void *data_p, UInt16 *current_p_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{

    UInt16 current_p = *current_p_p;
    UInt8 *databuffer_p = PNULL;
    QSEGMENT segment = {0};
    /* +coverity_10211 */
    void *ptr = PNULL;
    /* -coverity_10211 */

    LTE_SET_U16BIT(msgBuf, ((ConfigCellRes *)data_p)->transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, ((rrcInfoData *)data_p)->rnti );
    current_p += UEID_SIZE;
    /*CLPC Change Begin*/
    LTE_SET_U16BIT(msgBuf + current_p, ((rrcInfoData *)data_p)->timingAdvance);
    current_p += 2;
    LTE_SET_U16BIT(msgBuf + current_p, ((rrcInfoData *)data_p)->sinr);
    current_p ++;

    /*CLPC Change End*/
    databuffer_p = ((rrcInfoData *)data_p)->buffer_p;

    ptr = msgSegNext(((rrcInfoData *)data_p)->buffer_p , 0, &segment);
    if (PNULL == ptr)
    {
        ltePanic("MsgSegNext() returned NULL");
    }
    /*SPR 1768 -Start*/
    else
    {
        /*SPR 1768 -End*/
        databuffer_p = segment.base;
    }
    memCpy(&msgBuf[current_p], databuffer_p,
            ((rrcInfoData *)data_p)->dataLen);            
    current_p += ((rrcInfoData *)data_p)->dataLen;

    LOG_MAC_MSG(MAC_RRC_CCCH_MSG_IND,LOGWARNING,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId,((rrcInfoData *)data_p)->dataLen,
            ((rrcInfoData *)data_p)->rnti,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"MAC_RRC_CCCH_MSG_IND");

    *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : sendRLFIndToRRC 
 * Inputs         : ueIndex - Is the index of UE for which RLF Indication need
 *                  to be send
 *                  rlfCause - CAuse of radio link failure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API takes the ueIndex as input,
 *                  prepares the message and send RLF Indication and cause to RRC
 ****************************************************************************/
void sendRLFIndToRRC(UInt16 ueIndex, UInt8 rlfCause
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    RLFInfo rlfCauseInd = {0};
    rlfCauseInd.ueIndex = ueIndex;
    rlfCauseInd.rlfCause = rlfCause; 
    if(MAC_SEND_ERROR  ==
            sendMsgToRRC(MAC_RLF_IND, &rlfCauseInd
                /* CA changes Start */
                ,macCommonGetRRCCellIndex(internalCellIndex)
                /* CA Changes end */
                ))
    {
        ALARM_MSG(MAC_MODULE_ID,
                SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
    }

}
/*SPR_3065_FIX*/
/****************************************************************************
 * Function Name  : sendSyncIndToRRC 
 * Inputs         : ueIndex - Is the index of UE for which SYNC
 *                  Indication need to be send
 *                  rnti 
 *                  syncStatus- Id of indication which need to be sent
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This API takes the ueIndex, rnti, indId as input
 *                  prepares the message and send Indication to RRC
 ****************************************************************************/
void sendSyncIndToRRC(UInt16 ueIndex, UInt16 rnti, SyncIndId syncStatus
        /* CA Changes start */
        , InternalCellIndex internalCellIndex 
        /* CA Changes end */
        )
{
    SyncIndInfo syncInd = {0};
    syncInd.ueIndex = dlUECtxInfoArr_g[ueIndex].dlUEContext_p->rrcUeIndex;
    syncInd.rnti = rnti;
    syncInd.syncStatus = syncStatus; 
    if(MAC_SEND_ERROR  ==
            sendMsgToRRC(MAC_UE_SYNC_STATUS_IND, &syncInd, 
                macCommonGetRRCCellIndex(internalCellIndex )))
    {
        ALARM_MSG(MAC_MODULE_ID,
                SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
    }
    /* Review comment fix start SYNC_LOSS_3*/        
    else
    {
        LOG_MAC_MSG(MAC_SENT_SYNC_IND_TO_RRC_ID,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),syncInd.ueIndex,syncInd.rnti, 
                syncInd.syncStatus, 
                internalCellIndex, DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "");

    }
    /* Review comment fix end SYNC_LOSS_3*/        
}
/****************************************************************************
 * Function Name  : sendMsgToRRC
 * Inputs         : msgId - Msg Type to be send to RRC
 *                : data_p - pointer to the Data to be send
 *                : cellIndex - Cell Id sent by RRC
 * Outputs        : None
 * Returns        : None
 * Description    : This API takes the msgId & data to be send as input,
 *                  prepares the message and send it to RRC
 ****************************************************************************/
/* Coverity 530 CID 36229 */
SInt32 sendMsgToRRC( UInt32 msgId,
		/* Coverity 530 CID 36229 */
        void *data_p,
		/* CA Changes start */
		RrcCellIndex cellIndex)
		/* CA Changes end */
{
	/* CA changes Start */
    InternalCellIndex internalCellIndex;
    internalCellIndex = macCommonGetInternalCellIndex(cellIndex);
	/* CA Changes end */
    LTE_MAC_UT_LOG(LOG_INFO,"RRC Interface","Function %s Entry %d\n",
            __func__, msgId);
    UInt16 current_p = 0;
    UInt8 *msgBuf = PNULL;
    UInt8 wrongMsgId = FALSE;
    SInt32 retval = 0;
    GET_MEM_FROM_POOL(UInt8,msgBuf,MAX_DATA_SIZE,PNULL);

	/*+COVERITY 5.3.0 - 32107*/
    if ( PNULL == msgBuf )
    {
        return MAC_SEND_ERROR;    
    }
	/*-COVERITY 5.3.0 - 32107*/
    UInt8 *resp_p = &msgBuf[0];

    /* SPR 11109 Fix start */
    memSet(msgBuf,0,MAX_DATA_SIZE);
    /* SPR 11109 Fix end */

    current_p = RRC_MAC_API_HEADER_LEN;
    UInt16 transactionId = 0;
    switch ( msgId ) 
    {
        case MAC_DELETE_UE_ENTITY_CNF:
        {
			/* Cyclomatic Complexity changes - starts here */
            prepareMacDeleteUEEntityCnf (msgId, data_p, &current_p,
                    &resp_p
					/* CA changes Start */
                    , internalCellIndex
					/* CA Changes end */
                    );
			/* Cyclomatic Complexity changes - ends here */
        }
        break;

        case MAC_CONFIG_CELL_CNF:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacConfigCellCnf (msgId, data_p, &current_p,
                    &resp_p
						/* CA changes Start */
                    , internalCellIndex
						/* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }      
        break;

        case MAC_SFN_ERR_IND:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacSfnErrInd (msgId, data_p, &current_p,
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }          
        break;

        case MAC_RECONFIG_CELL_CNF:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacReconfigCellCnf (msgId, data_p, &current_p,
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }
        break;
        case MAC_DELETE_CELL_CNF:
        {
            LTE_SET_U16BIT( resp_p, ((DeleteCellRes *)data_p)->transactionId);
            LOG_MAC_MSG(MAC_CELL_DELETE_CNF,LOGINFO,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    msgId, ((DeleteCellRes *)data_p)->response,
                    ((DeleteCellRes *)data_p)->transactionId,
                    internalCellIndex, DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "MAC_CELL_DELETE_CNF RespSentToRRC");
        }
        break;
        /* Cell Start Stop Chg */
        case MAC_CELL_STOP_CNF:
        {
            LTE_SET_U16BIT( resp_p, ((CellStopRes *)data_p)->transactionId);
            LOG_MAC_MSG(RRC_MAC_CELL_STOP_RES_ID, LOGINFO, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    msgId, ((CellStopRes *)data_p)->response,
                    ((DeleteCellRes *)data_p)->transactionId,
                    internalCellIndex, DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "MAC_CELL_STOP_CNF RespSentToRRC");
        }
        break;
        case MAC_CELL_START_CNF:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacCellStartCnf (msgId, data_p, &current_p,
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
				/* Cyclomatic Complexity changes - ends here */
        }
        break;
        /* Cell Start Stop Chg */
        case MAC_SFN_CNF:
        {
				/* Cyclomatic Complexity changes - starts here */
                /* +- SPR 17777 */
            prepareMacSfnCnf (data_p, &current_p,
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }          
        break;

        case MAC_CHANGE_CRNTI_CNF:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacChangeCrntiCnf (msgId, data_p, &current_p,
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }
        break;

        case MAC_HO_RACH_RESOURCE_RESP:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacHORachResourceResp (msgId, data_p, &current_p,
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }
        break;  

        /* +- SPR 19066 */

        case MAC_RLF_IND:
        {
            /* Cyclomatic Complexity changes - starts here */
            prepareMacRlfInd (msgId, data_p, &current_p,
                    &resp_p
                    ,transactionId
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
        }
        break;

        case MAC_RESET_UE_ENTITY_CNF:
        { 
            /* Cyclomatic Complexity changes - starts here */
            prepareMacResetUEEntityCnf (msgId, data_p, &current_p, 
                    &resp_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ); 
				/* Cyclomatic Complexity changes - ends here */
        }
        break;
			/*SPR_3065_FIX*/
        case MAC_UE_SYNC_STATUS_IND:
        {
				/* Cyclomatic Complexity changes - starts here */
                /* +- SPR 17777 */
            prepareMacUESyncStatusInd (data_p, &current_p,
                    &resp_p
                    ,transactionId
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;
        }
        /*SPR_3065_FIX*/
#ifdef LTE_EMBMS_SUPPORTED
        case MAC_AREA_CONFIG_CNF :
            {
                prepareMacAreaConfigCnf(data_p, &current_p,&msgBuf);
 
                break; 
            }
        case MAC_COUNTING_MSG_CNF :
            {
                prepareMacCountingMsgCnf(data_p, &current_p,&msgBuf);
                break;
            }
        case MAC_MCCH_IND :
            {
                prepareMacMcchInd(data_p, &current_p, &msgBuf);
                break;
            }
        /*SPR 18074 Fix Start */
        case MAC_RESET_SESSION_CNF:
            {
                prepareMacResetMsgCnf(data_p, &current_p, &msgBuf);
                break;
            }    
        /*SPR 18074 Fix End */
#endif

        default:
        wrongMsgId = TRUE;
        lteWarning("Incorrect msgId provided\n");
        LOG_MAC_MSG(MAC_SENDMSGTO_INVALID_MSG_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                msgId,internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"SENDTO_INVALID_MSG_ID");
        break;
    }
    /* Fill buffer header to RRC */
    prepareMacRrcApiHeader( resp_p, msgId, current_p, cellIndex);

    /* Send msg to RRC Layer */
    if (FALSE == wrongMsgId)
    {
        {
            /* SPR 5599 changes start (ZIP ID 129073) */
            retval = sendMacMsgToRRC(msgBuf, current_p, 0,
                    internalCellIndex);
            if (retval == -1)
            {
                LOG_MAC_ERROR( MAC_RRC_INF, "Unable to send message to RRC! "
                        "Length[%u] cellId[%u]", current_p, internalCellIndex );
            }
            else
            {
                LOG_UT(MAC_RES_MSG_ID,LOGDEBUG,MAC_OAM_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        msgId, MAC_MODULE_ID, RRC_MODULE_ID,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"MAC_RES_MSG_ID");
            }
		/* SPR 5599 changes end (ZIP ID 129073) */
        }
        //RDTSC_AND_CLOCK_END_SOCKET;
    }
    /*Coverity_31228 Fix */
    freeMemPool(msgBuf);
    /*Coverity_31228 Fix */
    return retval;
}

/* Cyclomatic Complexity changes - starts here */
/******************************************************************************
 * Function Name  : prepareMacDeleteUEEntityCnf
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_DELETE_UE_ENTITY_CNF to be
 *                  sent to RRC
 ******************************************************************************/
STATIC  void prepareMacDeleteUEEntityCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf   = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;
    /*  fill transaction Id for delete resonse */
    LTE_SET_U16BIT(msgBuf, ((UEEntityDeleteRes *)data_p)->transactionId);
    /* Fill ueIndex and responseCode */
    LTE_SET_U16BIT(msgBuf + current_p, ((UEEntityDeleteRes *)data_p)->idx);
    current_p += IDX_SIZE;
    LTE_SET_U16BIT(msgBuf + current_p, ((UEEntityDeleteRes *)data_p)->response);
    current_p += 2;

    /*REL10_CR_CHANGES_START*/
    UInt8 loopIdx = 0;
    if (MAC_SUCCESS == ((UEEntityDeleteRes *)data_p)->response)
    { 
        for ( loopIdx = 0; loopIdx < MAX_NUMBER_OF_LOGICAL_CHANNEL; loopIdx++)     
        {  
            /* SPR_7614_FIX_START*/
            if (MAC_ACTIVE_LC == ((UEEntityDeleteRes *)data_p)->deleteLCStatus[loopIdx])
                /*SPR_7614_FIX_END*/    
            {
                LTE_SET_U16BIT(msgBuf + current_p, DELETE_LC_STATUS);
                current_p += TAG_SIZE;
                LTE_SET_U16BIT(msgBuf + current_p, DELETE_LC_STATUS_TAG_LEN);
                current_p += TAG_SIZE;
                /* Fill lchId */
                msgBuf[current_p] = loopIdx;
                current_p++;
                msgBuf[current_p] = ((UEEntityDeleteRes *)data_p)->deleteLCStatus[loopIdx];
                current_p++;
            }   
        }
    }  
    /*REL10_CR_CHANGES_END*/
    /* SPR 4558 Fix Start */ 
    /* SPR 4864 fix start */
    /* SPR 4915 Fix Start */
    UInt16 mappedUeId = getUeIdxFromRrcUeIdx(((UEEntityDeleteRes *)data_p)->idx);
    if ((mappedUeId != INVALID_UE_ID) && (0 == setUeIdxInvalid(mappedUeId,UE_IDX_MAPPING_FOR_MAC)))
    {
        freeUeIdx(mappedUeId); 
    }
    /* SPR 4915 Fix End */
    /* SPR 4864 fix end */
    /* SPR 4558 Fix End */
    LOG_MAC_MSG(MAC_DELETE_UE_CNF,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId,((UEEntityDeleteRes *)data_p)->idx,
            ((UEEntityDeleteRes *)data_p)->response,
            ((UEEntityDeleteRes *)data_p)->transactionId,
            internalCellIndex,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"MAC_DELETE_UE_CNF RespSentTORRC");
    *current_p_p = current_p;
}

/******************************************************************************
 * Function Name  : prepareMacConfigCellCnf 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p - Pointer indicating current position
 *                  msg_pp - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_CONFIG_CELL_CNF to be
 *                  sent to RRC
 ******************************************************************************/
STATIC  void prepareMacConfigCellCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p,
        UInt8  **msg_pp
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf_p   = PNULL;
    msgBuf_p = *msg_pp;
    UInt16 current = *current_p;
    LTE_SET_U16BIT(msgBuf_p, ((ConfigCellRes *)data_p)->transactionId);
    LTE_SET_U16BIT(msgBuf_p + current, ((ConfigCellRes *)data_p)->response);
#ifdef LTE_EMBMS_SUPPORTED

    if(embmsConfigParams_g[internalCellIndex].isParsingFailed)
    {
        ((ConfigCellRes *)data_p)->errorType = INVALID_EMBMS_AREA_PARAM;
        // Reset Value
        embmsConfigParams_g[internalCellIndex].isParsingFailed = FALSE; 
    }
#endif 

    current += 2;
    if (MAC_SUCCESS != (((ConfigCellRes *)data_p)->response))
    {
        LTE_SET_U16BIT(msgBuf_p + current, CELL_CONFIG_ERROR);
        current += 2;
        LTE_SET_U16BIT(msgBuf_p + current, CELL_CONFIG_ERROR_LEN);
        current += 2;
        /* CA changes Start */
        *(msgBuf_p + current) = ((ConfigCellRes *)data_p)->errorType;
        current ++ ;
        /* CA changes End */
    }
    LOG_MAC_MSG(MAC_CELL_CONFIG_CNF,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId, (((ConfigCellRes *)data_p)->response),
            (((ConfigCellRes *)data_p)->transactionId),
            internalCellIndex, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_CELL_CONFIG_CNF RespSentToRRC");

    *current_p = current;
}

/******************************************************************************
 * Function Name  : prepareMacSfnErrInd 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_SFN_ERR_IND to be
 *                  sent to RRC
 ******************************************************************************/
STATIC  void prepareMacSfnErrInd ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf   = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;

    LTE_SET_U16BIT(msgBuf, ((SFNErrInd *)data_p)->transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, ((SFNErrInd *)data_p)->SFN);
    current_p += 2;
    /* L3-L2 API Chg */
    /*msgBuf[current_p] = ((SFNErrInd *)data_p)->SF & 0x00FF;
      current_p++;   */
    /* L3-L2 API Chg */

    LOG_MAC_MSG(MAC_ERR_SFN_IND,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId, ((SFNErrInd *)data_p)->transactionId,
            ((SFNErrInd *)data_p)->SFN,
            internalCellIndex, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_ERR_SFN_IND");

    *current_p_p = current_p;
}

/******************************************************************************
 * Function Name  : prepareMacReconfigCellCnf 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_RECONFIG_CELL_CNF to be
 *                  sent to RRC
 ******************************************************************************/
STATIC  void prepareMacReconfigCellCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf  = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;
    LTE_SET_U16BIT(msgBuf, ((ReconfigCellRes *)data_p)->transactionId); 
    LTE_SET_U16BIT(msgBuf + current_p, ((ReconfigCellRes *)data_p)->response );
    current_p += 2;
#ifdef LTE_EMBMS_SUPPORTED

    if(embmsConfigParams_g[internalCellIndex].isParsingFailed)
    {
        ((ReconfigCellRes *)data_p)->errorType = INVALID_EMBMS_AREA_PARAM;
        // Reset Value
        embmsConfigParams_g[internalCellIndex].isParsingFailed = FALSE; 
    }
#endif 

    if (MAC_SUCCESS != (((ReconfigCellRes *)data_p)->response))
    {
        LTE_SET_U16BIT(msgBuf + current_p, CELL_CONFIG_ERROR);
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p, CELL_CONFIG_ERROR_LEN);
        current_p += 2;
        /* CA changes Start */
        *(msgBuf + current_p) = ((ReconfigCellRes *)data_p)->errorType;
        current_p ++ ;
        /* CA changes End */
    }

    LOG_MAC_MSG(MAC_CELL_RECONFIG_CNF,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId, ((ReconfigCellRes *)data_p)->response,
            ((ReconfigCellRes *)data_p)->transactionId,
            internalCellIndex, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_CELL_RECONFIG_CNF RespSentToRRC");
    *current_p_p = current_p;
}

/******************************************************************************
 * Function Name  : prepareMacCellStartCnf 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_CELL_START_CNF to be
 *                  sent to RRC
 ******************************************************************************/
STATIC  void prepareMacCellStartCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 response;
    UInt8  *msgBuf   = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;

    LTE_SET_U16BIT(msgBuf, ((CellStartRes *)data_p)->transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, 
            ((CellStartRes *)data_p)->response);
    current_p += 2;
    response = ((CellStartRes *)data_p)->response;
    if (MAC_SUCCESS == response)
    {
        LTE_SET_U16BIT(msgBuf + current_p, SFN_INFO );
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p, MAC_SFN_INFO_LEN);
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p, 
                ((CellStartRes *)data_p)->sfn);
        current_p += 2;
    }
    LOG_MAC_MSG(RRC_MAC_CELL_START_RES_ID, LOGINFO, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            msgId, ((CellStartRes *)data_p)->response,
            /* + SPR_10009 */ 
            ((CellStartRes *)data_p)->transactionId,
            /* - SPR_10009 */ 
            internalCellIndex, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_CELL_START_CNF RespSentToRRC");
    *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : prepareMacSfnCnf
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p- Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_SFN_CNF message to be sent
 *                  to RRC
 ****************************************************************************/
/* +- SPR 17777 */
STATIC  void prepareMacSfnCnf (
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 response;
    UInt8  *msgBuf   = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;
    /* +- SPR 17777 */
    LTE_SET_U16BIT(msgBuf, ((SFNRes*)data_p)->transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, (((SFNRes*)data_p)->response));
    current_p += 2;
    response = ((SFNRes*)data_p)->response;
    if (MAC_SUCCESS == response)
    {
        LTE_SET_U16BIT(msgBuf + current_p, SFN_INFO );
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p, MAC_SFN_INFO_LEN);
        current_p += 2;
        /* SPR FIX 851 Start */
        LTE_SET_U16BIT(msgBuf + current_p, ((SFNRes*)data_p)->sfn );
        /* SPR FIX 851 End */
        current_p += 2;

        /* SIB8_Code Start */
        /*
         * Enccoding SF value into MAC_SF_INFO buffer
         */ 
        LTE_SET_U16BIT(msgBuf + current_p, SF_INFO );
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p, MAC_SF_INFO_LEN);
        current_p += 2;
        *(msgBuf + current_p)  = ((SFNRes *)data_p)->sf;
        current_p++;

        /*
         * Getting Current Time Stamp and coverting in Micro  
         * Secs and encoding into MAC_TIMESTAMP_INFO buffer
         */ 
        /* SIB8_Code_phase2 Start */
        /* SIB8_Code_fix Start */
        if(1 == ((SFNRes *)data_p)->timeStampFlag)
        {
            long currentTimeStampinNanoSecs  = 0; 
            long long currentTimeStampInSecs = 0; 
            struct timespec currentTimeStamp = {0};

            clock_gettime_real_time(&currentTimeStamp);

            currentTimeStampInSecs =  currentTimeStamp.tv_sec; 
            currentTimeStampinNanoSecs =  currentTimeStamp.tv_nsec ; 
            /* SIB8_Code_fix2 Start */
            LTE_SET_U16BIT(msgBuf + current_p, MAC_TIMESTAMP_INFO);
            current_p += 2;
            LTE_SET_U16BIT(msgBuf + current_p, MAC_TIMESTAMP_INFO_LEN);
            current_p += 2;
            LTE_SET_U64BIT(msgBuf + current_p, currentTimeStampInSecs );
            current_p += 8;
            LTE_SET_U32BIT(msgBuf + current_p, currentTimeStampinNanoSecs);
            current_p += 4;

            /* SIB8_Code_fix2 End */
        }
        /* SIB8_Code_fix End */
        /* SIB8_Code_phase2 End*/

        /* SIB8_Code End */
        /* L3-L2 API Chg */
        /* msgBuf[current_p] = ((SFNRes*)data_p)->sf & 0x00FF;
           current_p++; */
        /* L3-L2 API Chg */
    }

    LOG_UT(MAC_SYSFRAME_CNF,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            0, (((SFNRes*)data_p)->response),
            ((SFNRes*)data_p)->sfn,
            ((SFNRes*)data_p)->transactionId,
            DEFAULT_INT_VALUE, DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_SYSFRAME_CNF");
    /* Coverity 96706 Fix Start*/
    LTE_GCC_UNUSED_PARAM(internalCellIndex)
        /* Coverity 96706 Fix End*/

        *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : prepareMacChangeCrntiCnf 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p- Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_CHANGE_CRNTI_CNF message 
 *                  to be sent to RRC
 ****************************************************************************/
STATIC  void prepareMacChangeCrntiCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf   = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;

    LTE_SET_U16BIT(msgBuf, (((ChangeCrntiRespInfo *)data_p)->
                transactionId));
    LTE_SET_U16BIT(msgBuf + current_p,(((ChangeCrntiRespInfo *)data_p)->
                ueIndex));
    current_p += 2;
    LTE_SET_U16BIT(msgBuf + current_p,(((ChangeCrntiRespInfo *)data_p)->
                resp));
    current_p += 2;
    LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,
            ((ChangeCrntiRespInfo*)data_p)->ueIndex,
            ((ChangeCrntiRespInfo*)data_p)->resp,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_CHANGE_CRNTI_CNF");

    *current_p_p = current_p;
}

/******************************************************************************
 * Function Name  : prepareMacHORachResourceResp
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_HO_RACH_RESOURCE_RESP to be 
 *                  sent to RRC
 ******************************************************************************/
STATIC  void prepareMacHORachResourceResp ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf   = PNULL;
    UInt16 current_p = *current_p_p;
    msgBuf = *msg_p;

    LTE_SET_U16BIT(msgBuf, (((HORachResourceRespInfo
                        *)data_p)->transactionId));
    LTE_SET_U16BIT(msgBuf + current_p,
            (((HORachResourceRespInfo *)data_p)->ueIndex));
    current_p += 2;
    LTE_SET_U16BIT(msgBuf + current_p,
            (((HORachResourceRespInfo *)data_p)->resp));
    current_p += 2;
    if (MAC_SUCCESS == ((HORachResourceRespInfo *)data_p)->resp)
    {
        LTE_SET_U16BIT(msgBuf + current_p,CRNTI_INFO);
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p,CRNTI_INFO_LEN);
        current_p += 2;
        LTE_SET_U16BIT(msgBuf + current_p,
                ((HORachResourceRespInfo *)data_p)->tcrnti);
        current_p += 2;
        LOG_MAC_MSG(MAC_HO_RACH_RESOURCE_RESP_MSG_ID,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,
                ((HORachResourceRespInfo *)data_p)->ueIndex,
                ((HORachResourceRespInfo *)data_p)->resp,
                CRNTI_INFO, CRNTI_INFO_LEN, 
                DEFAULT_FLOAT_VALUE, 
                DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_HO_RACH_RESOURCE_RESP");

        if (INVALID_PREAMBLE_IDX != ((HORachResourceRespInfo
                        *)data_p)->preambleIdx)
        {
            LTE_SET_U16BIT(msgBuf + current_p,PREAMBLE_INFO);
            current_p += 2;
            LTE_SET_U16BIT(msgBuf + current_p,PREAMBLE_INFO_LEN);
            current_p += 2;
            msgBuf[current_p] = (((HORachResourceRespInfo
                            *)data_p)->preambleIdx);
            current_p++;
            msgBuf[current_p] = (((HORachResourceRespInfo
                            *)data_p)->prachMaskIdx);
            current_p++;
            LOG_MAC_MSG(MAC_HO_RACH_RESOURCE_RESP_PREAMBLE_INFO, LOGINFO, 
                    MAC_RRC_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), PREAMBLE_INFO, 
                    PREAMBLE_INFO_LEN, 
                    ((HORachResourceRespInfo*)data_p)->preambleIdx,
                    ((HORachResourceRespInfo*)data_p)->prachMaskIdx,
                    internalCellIndex, 
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "RACH_RESOURCE_RESP_PREAMBLE_INFO");
        }
    }
    *current_p_p = current_p;
}

/* +- SPR 19066 */

/******************************************************************************
 * Function Name  : prepareMacRlfInd 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  transactionId - Message transaction Id
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_RLF_IND to be sent to RRC.
 ******************************************************************************/
STATIC  void prepareMacRlfInd ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p,
        /* + Coverity_31952 */
        UInt16  transactionId
        /* - Coverity_31952 */
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf  = PNULL;
    msgBuf = *msg_p;
    UInt16 current_p = *current_p_p;



    LTE_SET_U16BIT(msgBuf, transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, ((RLFInfo *)data_p)->ueIndex);
    current_p += 2;
    LTE_SET_U16BIT(msgBuf + current_p, ((RLFInfo *)data_p)->rlfCause);
    current_p += 2;
    LOG_MAC_MSG(MAC_RLF_IND_MSG_ID,LOGWARNING,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), msgId,((RLFInfo *)data_p)->ueIndex,
            ((RLFInfo *)data_p)->rlfCause,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_RLF_IND");

    *current_p_p = current_p;
}

/******************************************************************************
 * Function Name  : prepareMacResetUEEntityCnf 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_RESET_UE_ENTITY_CNF to be 
 *                  sent to RRC.
 ******************************************************************************/
STATIC  void prepareMacResetUEEntityCnf ( UInt16 msgId,
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msgBuf  = PNULL;
    msgBuf = *msg_p;
    UInt16 current_p = *current_p_p;



    LTE_SET_U16BIT(msgBuf, 
            (((UEEntityResetRes *)data_p)->transactionId));
    LTE_SET_U16BIT(msgBuf + current_p,
            (((UEEntityResetRes *)data_p)->idx));
    current_p += 2;
    LTE_SET_U16BIT(msgBuf + current_p,
            (((UEEntityResetRes *)data_p)->response));
    current_p += 2;
    LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),msgId,((UEEntityResetRes *)data_p)->
            idx,((UEEntityResetRes *)data_p)->response,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"MAC_RESET_UE_ENTITY_CNF");

    *current_p_p = current_p;
}

/******************************************************************************
 * Function Name  : prepareMacUESyncStatusInd 
 * Inputs         : msgId - Msg Type to be send to RRC
 *                  data_p - pointer to the Data to be send
 *                  current_p_p - Pointer indicating current position
 *                  msg_p - Pointer to message buffer to be sent to RRC
 *                  transactionId - Message transaction Id
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares the MAC_UE_SYNC_STATUS_IND to be 
 *                  sent to RRC.
 ******************************************************************************/
/* +- SPR 17777 */
STATIC  void prepareMacUESyncStatusInd (
        void   *data_p,
        UInt16 *current_p_p,
        UInt8  **msg_p,
        /* + Coverity_31954 */
        UInt16  transactionId
        /* - Coverity_31954 */
        )
{
    UInt8  *msgBuf  = PNULL;
    msgBuf = *msg_p;
    UInt16 current_p = *current_p_p;

    LTE_SET_U16BIT(msgBuf, transactionId);
    LTE_SET_U16BIT(msgBuf + current_p, ((SyncIndInfo*)data_p)->ueIndex);
    current_p += 2;
    LTE_SET_U16BIT(msgBuf + current_p, ((SyncIndInfo*)data_p)->rnti);
    current_p += 2;
    *(msgBuf + current_p) = (UInt8)((SyncIndInfo*)data_p)->syncStatus;
    current_p += 1;

    *current_p_p = current_p;
}


/* Cyclomatic Complexity changes - ends here */
/****************************************************************************
 * Function Name  : prepareLCErrorResponse
 * Inputs         : dwlkUEInfo_p - Ptr to a DL UE Info structure
 *                  uplkUEInfo_p - Ptr to a UL UE Info structure
 *                  msgBuff - Ptr to a buffer to be send to RRC
 *                  current_p_p - Ptr to current_p idx
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeResp_p - Pointer to the Uplink 
 *                  UE Resp filled at reconfigure
 *                  dlReconfigUeResp_p - Pointer to the Downlink 
 *                  UE Resp filled at reconfigure
 * Outputs        : None
 * Returns        : None
 * Description    : This API takes pointer to the msg to be send and prepare
 *                  LC Error TLV in case of MAC_PARTIAL_SUCCESS.
 ****************************************************************************/
STATIC  void prepareLCErrorResponse( UeContextForDownlink  *dwlkUEInfo_p,
        UeContextForUplink *uplkUEInfo_p,
        UInt8 *msgBuff, 
        UInt16 *current_p_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeResp *ulReconfigUeResp_p
        ,DLReconfigUeResp *dlReconfigUeResp_p
        )
{
    LCConfigResp lcResp[MAX_NUMBER_OF_LOGICAL_CHANNEL];
    UInt8 i = 0;
    /* SPR 4870 fix start*/
    /* +- SPR 18268 */
    UInt16 ueIndex = 0; 
    /* +- SPR 18268 */
    ULUEContextInfo   *uLUEContextInfo_p  = PNULL;
    DLUEContext       *dlUEContext_p = PNULL;
    /* Review comment fix start  RJ15 */
    for ( i = 0; i<MAX_NUMBER_OF_LOGICAL_CHANNEL; i++)
        /* Review comment fix end  RJ15 */
    {
        lcResp[i].status = 0;
        lcResp[i].opCode = 0;
    }    
    /* SPR 4870 fix end*/
    /* Cyclomatic Complexity changes - starts here */
    getFailedLcs (dwlkUEInfo_p, uplkUEInfo_p, lcResp
            ,ulReconfigUeResp_p
            ,dlReconfigUeResp_p
            ); 
    /* Cyclomatic Complexity changes - ends here */

    /* SPR 4870 fix start*/
    ueIndex = uplkUEInfo_p->ueIdx; 
    uLUEContextInfo_p = &ulUECtxInfoArr_g[ueIndex];
    dlUEContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    /* SPR 4870 fix end*/

    /* Cyclomatic Complexity changes - starts here */
    setLCErrorResponse (dlUEContext_p, uLUEContextInfo_p, msgBuff, 
            lcResp, current_p_p
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    /* Cyclomatic Complexity changes - ends here */
}

/****************************************************************************
 * Function Name  : getFailedLcs 
 * Inputs         : dwlkUEInfo_p - Ptr to a DL UE Info structure
 *                  uplkUEInfo_p - Ptr to a UL UE Info structure
 *                  ulReconfigUeResp_p - Pointer to the Uplink 
 *                  UE Resp filled at reconfigure
 *                  dlReconfigUeResp_p - Pointer to the Downlink 
 *                  UE Resp filled at reconfigure
 * Outputs        : lcResp_p - Failed LC list
 * Returns        : None
 * Variables      :
 * Description    : This function gets the Failed LCs in both Uplink and
 *                  downlink.
 ****************************************************************************/
STATIC  void getFailedLcs( UeContextForDownlink  *dwlkUEInfo_p,
        UeContextForUplink *uplkUEInfo_p, LCConfigResp *lcResp_p
        ,ULReconfigUeResp *ulReconfigUeResp_p, 
        DLReconfigUeResp *dlReconfigUeResp_p
        ) 
{
    UInt8 i = 0, lcId = 0;
    /*SPR 4870 Changes Start*/
    if((PNULL == ulReconfigUeResp_p) ||(PNULL == dlReconfigUeResp_p))
    {
        /* Get the DL LCs for which failure response to be send */
        for ( i = 0; i < dwlkUEInfo_p->dwlkLogicalChCount; i++)
        {
            lcId = dwlkUEInfo_p->logicalChConfig[i].lchId;
            lcResp_p[lcId].opCode =
                (UInt8 )dwlkUEInfo_p->logicalChConfig[i].operationType;
            if (MAC_SUCCESS != dwlkUEInfo_p->logicalChConfig[i].result)
            {
                lcResp_p[lcId].status |= DL_LC_INFO;
                lcResp_p[lcId].result = 
                    dwlkUEInfo_p->logicalChConfig[i].result;
            }    
        }
        /* Get the UL LCs for which failure response to be send */
        for ( i = 0; i < uplkUEInfo_p->numLogicalChannels; i++)
        {
            lcId = uplkUEInfo_p->lcInfo[i].lchId;
            lcResp_p[lcId].opCode =
                (UInt8)uplkUEInfo_p->lcInfo[i].operationType;
            if (MAC_SUCCESS != uplkUEInfo_p->lcInfo[i].result)
            {
                lcResp_p[lcId].status |= UL_LC_INFO;
                lcResp_p[lcId].result =
                    uplkUEInfo_p->lcInfo[i].result;
            }    
        }
    }
    /*SPR 16855 +-*/
    else
    {
        /* Get the DL LCs for which failure response to be send */
        /* Coverity 61997 and SPR 9583 fix start*/
        for ( i = 0; ( ( i < dlReconfigUeResp_p->dlReconfigLcResp.lcCount ) &&
                    ( i < (MAX_NUMBER_OF_LOGICAL_CHANNEL - 1)) ); i++)
            /* Coverity 61997 and SPR 9583 fix end*/
        {
            lcId = dlReconfigUeResp_p->dlReconfigLcResp.logicalChConfig[i].lchId;
            lcResp_p[lcId].opCode =
                (UInt8 )dlReconfigUeResp_p->dlReconfigLcResp.logicalChConfig[i].operationType;
            if (MAC_SUCCESS != dlReconfigUeResp_p->dlReconfigLcResp.logicalChConfig[i].result)
            {
                lcResp_p[lcId].status |= DL_LC_INFO;
                lcResp_p[lcId].result = 
                    dlReconfigUeResp_p->dlReconfigLcResp.logicalChConfig[i].result;
            }    
        }
        /* Get the UL LCs for which failure response to be send */
        /*SPR 9583 fix start*/
        for ( i = 0; ( ( i < ulReconfigUeResp_p->ulReconfigLcResp.numLogicalChannels )
                    && ( i < MAX_NUMBER_OF_LOGICAL_CHANNEL ) ) ; i++)
            /*SPR 9583 fix end*/
        {
            lcId = ulReconfigUeResp_p->ulReconfigLcResp.lcInfo[i].lchId;
            lcResp_p[lcId].opCode =
                (UInt8)ulReconfigUeResp_p->ulReconfigLcResp.lcInfo[i].operationType;

            if (MAC_SUCCESS != ulReconfigUeResp_p->ulReconfigLcResp.lcInfo[i].result)
            {
                lcResp_p[lcId].status |= UL_LC_INFO;
                lcResp_p[lcId].result =
                    ulReconfigUeResp_p->ulReconfigLcResp.lcInfo[i].result;
            }    
        }
    }
    /*SPR 16855 +-*/
    /*SPR 4870 Changes End*/ 
}

/****************************************************************************
 * Function Name  : setLCErrorResponse
 * Inputs         : dlUEContext_p - Ptr to a DL UE context
 *                  uLUEContextInfo_p - Ptr to a UL UE context
 *                  msgBuff - Ptr to a buffer to be send to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : lcResp_p and current_p_p
 * Returns        : None
 * Description    : This function sets the error response for Failed LCs.
 ****************************************************************************/
STATIC  void setLCErrorResponse( DLUEContext *dlUEContext_p,
        ULUEContextInfo *uLUEContextInfo_p, UInt8 *msgBuff, 
        LCConfigResp *lcResp_p, UInt16 *current_p_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ) 
{
    UInt8 i = 0;
    UInt16 len = 0, lenIdx = 0, tag = 0, tagLen = 0;
    UInt8 lcStatus = MAC_INACTIVE_LC;
    UInt16 current_p = *current_p_p;
    /* Insert Error codes for failed LCs */
    for ( i = 0; i<MAX_NUMBER_OF_LOGICAL_CHANNEL; i++)
    {
        LOG_MAC_MSG(MAC_UE_LC_ERR_RESPONSE,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                lcResp_p[i].status,lcResp_p[i].opCode,
                lcResp_p[i].result, 
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_LC_ERR_RESPONSE");

        if (lcResp_p[i].status > 0)
        {
            /*Coverity Fix 66932, typecasted the passed parameter */ 
            tag = checkForOpCode((LCOperationType)(lcResp_p[i].opCode));
            if (tag == INVALID_SCELL_OPERATION_TYPE)
            { 
                continue;
            }

            LTE_SET_U16BIT(msgBuff + current_p, tag);
            current_p += TAG_SIZE;

            lenIdx = current_p;
            current_p += LENGTH_SIZE;
            /* Fill lchId for which request fail */
            msgBuff[current_p] = i;
            current_p++;
            /* This will give the reason why this LC config request fails */
            LTE_SET_U16BIT(msgBuff + current_p, lcResp_p[i].result);
            current_p += 2;

            len += (LENGTH_SIZE + TAG_SIZE + 3);      
            if (DELETE_LC_ERROR == tag)
            {
                msgBuff[current_p] = lcResp_p[i].status;
                current_p++;
                len++;
            }
            else
            {
                if ((UL_DL_LC_INFO == lcResp_p[i].status) ||
                        (UL_LC_INFO == lcResp_p[i].status)) 
                {
                    tag = UL_LC_CONFIG_RESP;
                    LTE_SET_U16BIT(msgBuff + current_p, tag);
                    current_p += TAG_SIZE;

                    tagLen = UL_LC_RESP_LENGTH;
                    LTE_SET_U16BIT(msgBuff + current_p,tagLen); 
                    current_p += LENGTH_SIZE;
                    len += (LENGTH_SIZE + TAG_SIZE);
                }    
                if ((UL_DL_LC_INFO == lcResp_p[i].status) ||
                        (DL_LC_INFO == lcResp_p[i].status))
                {
                    tag = DL_LC_CONFIG_RESP;
                    LTE_SET_U16BIT(msgBuff + current_p, tag);
                    current_p += TAG_SIZE;

                    tagLen = DL_LC_RESP_LENGTH;
                    LTE_SET_U16BIT(msgBuff + current_p,tagLen); 
                    current_p += LENGTH_SIZE;
                    len += (TAG_SIZE + LENGTH_SIZE);
                }  
            }    
            LTE_SET_U16BIT(msgBuff + lenIdx, len);
            /* SPR 4870 fix start*/
        }
        else if (lcResp_p[i].opCode == DELETE)
        {
            /* SPR 4870 fix start*/
            /* SPR 4870 fix start*/
            if((0 != uLUEContextInfo_p->ulUEContext_p->bsrNet
                        [uLUEContextInfo_p->ulUEContext_p->lcInfo[i].lcGId]) ||
                    (0 != dlUEContext_p->logicalChannel[i].queueLoad))
            {
                lcStatus = MAC_ACTIVE_LC;
            }
            /*SPR 22343 Start*/
            /* Setting the LCG-ID of the LC to be deleted as Invalid value because at the time when we recreate this LC the LCGID is checked again and if it is not invalid then LC is not  
             * created*/
            if(0 == uLUEContextInfo_p->ulUEContext_p->ulLCGInfo[uLUEContextInfo_p->ulUEContext_p->lcInfo[i].lcGId].numLC)
            {
                uLUEContextInfo_p->ulUEContext_p->bsrNet[uLUEContextInfo_p->ulUEContext_p->lcInfo[i].lcGId] = 0;
            }
            uLUEContextInfo_p->ulUEContext_p->lcInfo[i].lcGId= LCGID_INVALID_VALUE;
            /*SPR 22343 End*/
            LTE_SET_U16BIT(msgBuff + current_p, DELETE_LC_STATUS);
            current_p += TAG_SIZE;
            LTE_SET_U16BIT(msgBuff + current_p, DELETE_LC_STATUS_TAG_LEN);
            current_p += TAG_SIZE;
            /* Fill lchId */
            msgBuff[current_p] = i;
            current_p++;
            msgBuff[current_p] = lcStatus;
            current_p++;
        }
        /* SPR 4870 fix end*/
    }
    *current_p_p = current_p;
}

/****************************************************************************
 * Function Name  : parseReconfigureUEEntityReq
 * Inputs         : msg_p - Pointer to the data received from RRC
 *                  totalMsgLen - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC SUCCESS or Reason for Failure
 * Description    : This API takes pointer to the msg received as input, parse
 *                  the message and prepare DL & UL structures for UE context
 *                  reconfiguration at MAC Layer (inc UE Info & LCs).
 *****************************************************************************/

STATIC  MacRetType parseReconfigureUEEntityReq( UInt8 *msg_p,
        UInt16 totalMsgLen,
        UeContextForUplink *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq *ulReconfigUeReq_p
        ,DLReconfigUeReq *dlReconfigUeReq_p
        )
{
    UInt16 tag    = 0;
    UInt16 tagLen = 0;
    UInt16 resp   = MAC_SUCCESS;
    UInt16 remLen = totalMsgLen;
    UInt8 absLoopCount = 0;

    /* SPR 2454 changes start */
    /*Setting Invalid value */
    /*cyclomatic fix start*/
    prepareReconfigDLULUEContext(ulUEInfo_p,dlUEInfo_p);
    /*cyclomatic fix end*/ 
    /*EICIC +*/
    ulUEInfo_p->cqiPMIConfigIndex_2 = MAC_MAX_CQI_PMI_CONFIG_INDEX + 1;
    ulUEInfo_p->riConfigIndex_2 = MAC_RI_CONFIG_INDEX_INVALID;
    for (absLoopCount=0; absLoopCount<MAX_CSI_MEASUREMENT_PATTERN; absLoopCount++)
    {
        ulUEInfo_p->csiMeasurementSubset1[absLoopCount] = 0;
        ulUEInfo_p->csiMeasurementSubset2[absLoopCount] = 0;
    }
    ulUEInfo_p->cqiConfigRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    dlUEInfo_p->cqiConfigRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    ulUEInfo_p->cqiSubsetConfigRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    dlUEInfo_p->cqiSubsetConfigRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    ulUEInfo_p->userType= NON_VICTIM_UE;
    dlUEInfo_p->userType = NON_VICTIM_UE;
    ulUEInfo_p->userTypePresent = LTE_FALSE;
    dlUEInfo_p->userTypePresent = LTE_FALSE;
    /*EICIC -*/
    if (totalMsgLen < RECONFIG_UE_ENTITY_MIN_LEN)
    {
        /*--coverity-530-54311*/
        return MAC_SYNTAX_ERROR_VAL;
        /*--coverity-530-54311*/
    }

    /* Parse ueIndex and validate it */
    /*SPR 10178 Fix Start*/
    dlUEInfo_p->rrcUeIndex = LTE_GET_U16BIT(msg_p);
    /* SPR 10178 Fix End*/
    dlUEInfo_p->ueIndex = getUeIdxFromRrcUeIdx(dlUEInfo_p->rrcUeIndex);
    msg_p += 2;
    ulUEInfo_p->ueIdx = dlUEInfo_p->ueIndex;

    remLen -= RECONFIG_UE_ENTITY_MIN_LEN;

    /*SPR 4017 Fix Start*/
    /* CA changes Start */
    if ( (dlUEInfo_p->ueIndex >= MAX_UE_SUPPORTED) || (MAC_FAILURE == validateCellIndex(dlUEInfo_p->ueIndex,internalCellIndex)) )
        /* CA changes End */
        /*SPR 4017 Fix End*/
    {
        lteWarning("Invalid range for ue index.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->ueIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for ue index");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    if (remLen < TAG_LEN)
    {
        lteWarning(
                "Atleast one optional tag should be present for RECONFIG_UE_ENTITY Req .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Atleast one optional tag should be present\
                for RECONFIG_UE_ENTITY Req");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    /* initialize optional parametere with default values */
    dlUEInfo_p->tpcPdcchConfigPucch.tpcRnti = INVALID_TPC_RNTI;
    dlUEInfo_p->tpcPdcchConfigPucch.tpcBitMapIndex = INVALID_TPC_OFFSET;
    dlUEInfo_p->tpcPdcchConfigPucch.isConfiguredForDci3Or3A = DCI_FORMAT_3;
    ulUEInfo_p->tpcPdcchConfigPusch.tpcRnti = INVALID_TPC_RNTI;
    ulUEInfo_p->tpcPdcchConfigPusch.tpcBitMapIndex = INVALID_TPC_OFFSET;
    ulUEInfo_p->tpcPdcchConfigPusch.isConfiguredForDci3Or3A = DCI_FORMAT_3;
    ulUEInfo_p->isDedicatedULPowerControlInfoPresent = FALSE;
    dlUEInfo_p->isPAPresent = FALSE;
    dlUEInfo_p->isTpcPdcchConfigPucchPresent = FALSE;
    ulUEInfo_p->isTpcPdcchConfigPuschPresent = FALSE;
    ulReconfigUeReq_p->ueReconfigMsgTlvCount = 0;
    dlReconfigUeReq_p->ueIndex = dlUEInfo_p->ueIndex; 
    ulReconfigUeReq_p->ueIndex = dlUEInfo_p->ueIndex; 
    /* SPS_CHG */
    /* Initialize optional parameter with default values */
    dlUEInfo_p->isSpsDlInfoPresent = FALSE;
    dlUEInfo_p->spsDownlinkInfo.requestType = SPS_RELEASE;
    dlUEInfo_p->spsDownlinkInfo.spsDownlinkSetupInfo.\
        N1PucchAnPersistentListVal.numOfN1PucchAnPersistent = 0; 
    dlUEInfo_p->spsDownlinkInfo.spsDownlinkSetupInfo.\
        isMaxSpsHarqRetxPresent = FALSE;
    dlUEInfo_p->spsDownlinkInfo.spsDownlinkSetupInfo.\
        isExplicitReleaseAfterPresent = FALSE;
    ulUEInfo_p->isSpsUlInfoPresent = FALSE;
    ulUEInfo_p->spsUplinkInfo.requestType = SPS_RELEASE;
    ulUEInfo_p->spsUplinkInfo.spsUplinkSetupInfo.\
        isP0TagPresent = FALSE;
    ulUEInfo_p->spsUplinkInfo.spsUplinkSetupInfo.\
        isTwoIntervalConfigPresent = FALSE;
    /* SPS_CHG */

    /* CA changes Start */
    /* If Optional Parameter  UE_CATEGORY_V1020/PUCCH/CA CONFIG Info is present then
       addUEInfoTagLen must be greater than zero */
    /* initialize optional parametere with default values */
    macInitCAParams(ulUEInfo_p, dlUEInfo_p);
    /* CA changes End */
    UInt8 lcInfoFlagPresent = 0;

    /* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
    ulUEInfo_p->isUplinkRAT1Supported = FALSE;
#endif
    /* SPR 21958 PUSCH RAT1 Support End */
    while (remLen > 0)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        remLen -= tagLen;

        switch ( tag )
        {
            case CREATE_LC_REQ:
            if(!lcInfoFlagPresent)
            {
                dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    DL_RECONFIG_CONFIGURE_LC_REQ;
                dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
                ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    UL_RECONFIG_CONFIGURE_LC_REQ;

                ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
                lcInfoFlagPresent = 1;

            }

            resp =
                parseCreateLcReq( msg_p, tagLen, dlUEInfo_p, ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            /* L2_FIX_6_Start */
            if (resp != MAC_SUCCESS)
            {
                LOG_MAC_MSG(RRC_MAC_LC_INFO,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),tagLen,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"PARSE_CREATE_LC_REQ_FAIL");

                /*--coverity-530-54311*/
                return MAC_SYNTAX_ERROR_VAL;
                /*--coverity-530-54311*/
            }
            /* L2_FIX_6_End */

            msg_p += tagLen -4;
            break;

            case RECONFIGURE_LC_REQ:
            if(!lcInfoFlagPresent)
            {
                dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    DL_RECONFIG_CONFIGURE_LC_REQ;
                dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
                lcInfoFlagPresent = 1;
                ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    UL_RECONFIG_CONFIGURE_LC_REQ;

                ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

            }
            resp =
                parseReconfigLcReq( msg_p, tagLen, dlUEInfo_p, ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
            /* L2_FIX_6_Start */
            if (resp != MAC_SUCCESS)
            {
                LOG_MAC_MSG(RRC_MAC_LC_INFO,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),tagLen,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"PARSE_RECONFIG_LC_REQ_FAIL");

                /*--coverity-530-54311*/
                return MAC_SYNTAX_ERROR_VAL;
                /*--coverity-530-54311*/
            }
            /* L2_FIX_6_End */

            msg_p += tagLen - 4;
            break;

            case DELETE_LC_REQ:
            if(!lcInfoFlagPresent)
            {
                dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    DL_RECONFIG_CONFIGURE_LC_REQ;
                dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
                lcInfoFlagPresent = 1;
                ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    UL_RECONFIG_CONFIGURE_LC_REQ;
                ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

            }

            resp = parseDeleteLcReq( msg_p, tagLen, dlUEInfo_p, ulUEInfo_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* L2_FIX_6_Start */
            if (resp != MAC_SUCCESS)
            {
                LOG_MAC_MSG(RRC_MAC_LC_INFO,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),tagLen,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"PARSE_DELETE_LC_REQ_FAIL");

                /*--coverity-530-54311*/
                return MAC_SYNTAX_ERROR_VAL;
                /*--coverity-530-54311*/
            }
            /* L2_FIX_6_End */

            msg_p += tagLen - 4;
            break;             

            case RECONFIG_UE_INFO:
            /* + CL-MIMO LJA*/
            resp = parseReconfigUEInfo( dlUEInfo_p, msg_p, tagLen, ulUEInfo_p
                    , dlUECtxInfoArr_g[dlUEInfo_p->ueIndex].dlUEContext_p->dlMIMOInfo.transmissionMode
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    ,dlReconfigUeReq_p 
                    ,ulReconfigUeReq_p
                    );

            /* L2_FIX_6_Start */
            if (resp != MAC_SUCCESS)
            {
                LOG_MAC_MSG(RRC_MAC_LC_INFO,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),tagLen,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"PARSE_RECONFIG_UE_INFO_FAIL");

                /*--coverity-530-54311*/
                return MAC_SYNTAX_ERROR_VAL;
                /*--coverity-530-54311*/
            }
            /* L2_FIX_6_End */

            /* SPR 2458 Changes Start */
            if (INVALID_TX_MODE != dlUEInfo_p->transmissionMode)
            {
                if ((TX_MODE_3 != dlUEInfo_p->transmissionMode) &&
                        (TX_MODE_4 != dlUEInfo_p->transmissionMode) &&
                        /* + TM7_8 Changes Start */
                        (TX_MODE_8 != dlUEInfo_p->transmissionMode))
                    /* - TM7_8 Changes End */
                {
                    /*L2_FIX_3_start*/
                    ulUEInfo_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;
                    /*L2_FIX_3_end*/
                    lteWarning("riConfigIndex is configured in TX mode "
                            "other than 3 and 4.\n");
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            dlUEInfo_p->transmissionMode,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "riConfigIndex is configured in\
                            TX mode other than 3 and 4");
                    /* Review comment fix end RJ13 */
                }
            }
            /* SPR 2458 Changes End */

            /* - CL-MIMO LJA*/
            msg_p += tagLen -4;
            break;
	    /* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
	    case UPLINK_RAT1_INFO:
	    {
		    resp = parseUEUplinkRAT1Info(&msg_p, tagLen, 
				    ulUEInfo_p,
				    internalCellIndex
				    );
		    if (resp != MAC_SUCCESS)
		    {
			    return MAC_SYNTAX_ERROR_VAL;
		    }
		    break; 
	    }
#endif
	    /* SPR 21958 PUSCH RAT1 Support End */
            default:
            lteWarning("Invalid Tag received from RRC Layer\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tag,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid Tag received from RRC Layer");
            /* Review comment fix end RJ13 */
            break;
        }
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigUEInfo
 * Inputs         : tagLen - length of the API message received.
 *                  msg_p -  pointer to message to be parsed
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  currentTransmissionMode - current configured transmission mode 
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC SUCCESS or Reason for Failure
 * Description    : This API takes pointer to the msg received as input, parse
 *                  the message and prepare DL & UL structures for UE context
 *                  reconfiguration at MAC Layer (inc UE Info & LCs).
 *****************************************************************************/

STATIC  UInt16 parseReconfigUEInfo( UeContextForDownlink *dlUEInfo_p,
        UInt8 *msg_p,
        UInt16 tagLen,
        UeContextForUplink *ulUEInfo_p
        /* + CL-MIMO LJA*/
        , UInt8 currentTransmissionMode
        /* - CL-MIMO LJA*/
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        )
{
    UInt16 tag = 0;
    UInt16 len = 0;
    UInt16 resp = MAC_SUCCESS;
    /* + SPR_3366 */       
    ulUEInfo_p->cqiMode = 0;
    /* - SPR_3366 */       
    UInt8 tempChoice = 0; 

    /* HD FDD changes start */
#ifdef HD_FDD_CONFIG
    /* set to invalid value for checking if RF-Params received or not */
    dlUEInfo_p->isHDFddFlag = HD_FDD_FLAG_INVALID;
    ulUEInfo_p->isHDFddFlag = HD_FDD_FLAG_INVALID;
#endif
    /* HD FDD changes end */

    if (tagLen < RECONFIG_UE_INFO_MIN_LEN)
    {
        return MAC_SYNTAX_ERROR;
    }    
    tagLen -= RECONFIG_UE_INFO_MIN_LEN;

    /* UE_CAPAB_ADD_PARAM Start */
    dlUEInfo_p->Rat1Support = FALSE;
    /* UE_CAPAB_ADD_PARAM End */

    /* + TM7_8 Changes Start */
    dlUEInfo_p->pmiRiReportV920 = INVALID_PMI_RI_CONF_V920;
    ulUEInfo_p->pmiRiReportV920 = INVALID_PMI_RI_CONF_V920;
    dlUEInfo_p->pdschEpreToUeRsRatio = 0;
    /* SPR 21043 Start */
    ulUEInfo_p->cqiMaskV920 = INVALID_8_VAL;
    /* SPR 21043 End */
    /* - TM7_8 Changes End */
    while ( tagLen > 0 )
    {
        if (tagLen < TAG_LEN)
        {
            lteWarning("No optional tag present in ReconfigUEInfo.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "No optional tag present in ReconfigUEInfo");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        /* Parse Tag and validate it */
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        len = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        /* Coverity 73426 Fix Start */
        if(tagLen < len)
        {
            return MAC_FAILURE;
        }
        /* Coverity 73426 Fix End */

        tagLen -= len; 

        switch ( tag )
        {
            case CQI_INFO:
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigCqiInfo(&msg_p, len, tagLen, 
                    dlUEInfo_p, ulUEInfo_p,internalCellIndex
                    ,dlReconfigUeReq_p
                    ,ulReconfigUeReq_p
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;

            case DL_MAX_RB_INFO:
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigDLMaxRBInfo(&msg_p, len, 
                    dlUEInfo_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ,dlReconfigUeReq_p
                    );
            /* Cyclomatic Complexity changes - ends here */
            break; 
            case TX_MODE_INFO:
            dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                DL_RECONFIG_TRANS_MODE_INFO;
            dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigTXModeInfo (&msg_p, len,
                    dlUEInfo_p 
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;

            /* + CL-MIMO LJA*/
            case CODEBOOK_SUBSET_RESTRICTION:
            dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                DL_RECONFIG_CODEBOOK_SUBSET_RESTRICTION_INFO;
            dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseRecfgCodebookSubRestriction(&msg_p, len, 
                        dlUEInfo_p, currentTransmissionMode
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                /* Cyclomatic Complexity changes - ends here */
            }
            break;
            /* - CL-MIMO LJA*/

            /* SPR 12240 Changes Start */
            /* For a Rel 10 UE , CBSR Tag will be V1020 one */
            case CODEBOOK_SUBSET_RESTRICTION_V1020:
            dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                DL_RECONFIG_CODEBOOK_SUBSET_RESTRICTION_INFO;
            dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
            {
                resp = parseRecfgCodebookSubRestrictionV1020(&msg_p, len, 
                        dlUEInfo_p, currentTransmissionMode
                        , internalCellIndex
                        );
            }
            /* SPR 12240 Changes End */
            break;
            case NUM_OF_LAYER_INFO:
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigNumOfLayerInfo(&msg_p, len, 
                    dlUEInfo_p
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    ,dlReconfigUeReq_p
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;

            case CODEBOOK_INDEX_INFO:
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigCodebookIndexInfo(&msg_p, len, 
                    dlUEInfo_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ,dlReconfigUeReq_p
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;

            case SR_CONFIG_INFO:
            {
                LTE_MAC_UT_LOG( LOG_INFO, PARSE_UTIL, "SR_CONFIG_INFO ");
                /* Cyclomatic Complexity changes - starts here */
                UInt8 isContinueFlag = FALSE;
                resp = parseReconfigSRConfigInfo(&msg_p, &len, 
                        ulUEInfo_p, &isContinueFlag
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,ulReconfigUeReq_p
                        );
                if (isContinueFlag == TRUE)
                {
                    continue;
                }
                /* Cyclomatic Complexity changes - ends here */
            }
            break;

            /* Rel9_upgrade_CR410 */
            case SR_PROHIBIT_TIMER_V920:
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigSRProhibitTimerV920Info(&msg_p, len, 
                    ulUEInfo_p
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            /* Cyclomatic Complexity changes - ends here */

            break;
            /* Rel9_upgrade_CR410 */ 

            /* SPR 903 Start*/
            case UE_CATEGORY:
            /* Cyclomatic Complexity changes - starts here */
            resp = parseReconfigUECategoryInfo(&msg_p, len, tagLen, 
                    dlUEInfo_p,
                    ulUEInfo_p,
                    internalCellIndex
                    ,dlReconfigUeReq_p
                    ,ulReconfigUeReq_p
                    );
            /* Cyclomatic Complexity changes - ends here */
            break;
            /* SPR 903 End*/

            case SRS_DEDICATED_CONFIG:
            resp = parseSRSDedicatedConfigInfo(&msg_p, len, ulUEInfo_p
                    /* CA Changes start */
                    , internalCellIndex 
                    /* CA Changes end */
                    );
            /* SPR 10244 Fix Start */
            if(MAC_SUCCESS == resp)
            { 
                ulUEInfo_p->srsRequestType = TRUE;
            }
            /* SPR 10244 Fix End */

            break;

            /* Rel9_upgrade_CR396 */
            /* SPR 12240 Changes Start */
            case CODEBOOK_SUBSET_RESTRICTION_V920:
            {
                dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    DL_RECONFIG_CODEBOOK_SUBSET_RESTRICTION_INFO;
                dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
                resp = parseRecfgCodebookSubRestrictionV920(&msg_p, len, 
                        dlUEInfo_p, currentTransmissionMode
                        , internalCellIndex
                        );
                break;
                /* Rel9_upgrade_CR396 */
                /* SPR 12240 Changes End */
            }
            /* + DRX_CHG */
            case  DRX_CONFIG_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigDrxConfigInfo(&msg_p, len, 
                        dlUEInfo_p
                        /* CA changes Start */
                        ,internalCellIndex
                        /* CA Changes end */
                        ,dlReconfigUeReq_p
                        );
                /* Cyclomatic Complexity changes - ends here */
            }
            break;
            /*- DRX_CHG */

            /* + MEAS_GAP_CHG */
            case  MEAS_GAP_CONFIG_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigMeasGapConfigInfo(&msg_p, len, 
                        dlUEInfo_p
                        /* CA changes Start */
                        ,internalCellIndex
                        /* CA Changes end */
                        ,dlReconfigUeReq_p
                        );
                /* Cyclomatic Complexity changes - ends here */
            }
            break;
            /*Fix for __SPR_1988__ START*/    
            case TIME_ALIGNMENT_TIMER_INFO:    
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigTimerAlignTimerInfo(&msg_p, len, tag, 
                        dlUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,dlReconfigUeReq_p
                        );
                /* Cyclomatic Complexity changes - ends here */
            }
            break;
            /*Fix for __SPR_1988__ END*/
            case AMBR_QOS_INFO:
            dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                DL_RECONFIG_AMBR_QOS_INFO;
            dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
            ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=UL_RECONFIG_AMBR_QOS_INFO;
            ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

            /*CR 64 bit to 32 bit */
	    /* SPR 22745 Fix Start */
            dlUEInfo_p->dlAmbr = DIVIDE_BY_EIGHT(VALIDATE_RECEIVED_AMBR(LTE_GET_U32BIT(msg_p)));
            msg_p += SIZEOF_UINT32;

            dlUEInfo_p->dlAmbrPresent = TRUE;

            ulUEInfo_p->ulAmbr = DIVIDE_BY_EIGHT(VALIDATE_RECEIVED_AMBR(LTE_GET_U32BIT(msg_p)));
	    /* SPR 22745 Fix End */
            msg_p += SIZEOF_UINT32;
            /*CR 64 bit to 32 bit */

            ulUEInfo_p->ulAmbrPresent = TRUE;

            break;

            /*Added for Power Control - CLPC_CHG*/
            case PDSCH_CONFIG_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigPdcshConfigInfo(&msg_p, len, 
                        dlUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,dlReconfigUeReq_p
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case P0_UE_PUSCH:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigP0UEPusch(&msg_p, len, 
                        ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,ulReconfigUeReq_p
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case TPC_PDCCH_CONFIG_PUCCH:
            {
                dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    DL_RECONFIG_TPC_PDCCH_CONFIG_PUCCH;
                dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigTPCPdcchConfigPucch (&msg_p, len, 
                        dlUEInfo_p
                        /* CA changes Start */
                        ,internalCellIndex
                        /* CA Changes end */
                        /* +- SPR 17777 */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case TPC_PDCCH_CONFIG_PUSCH:
            {
                ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=UL_RECONFIG_TPC_PDCCH_CONFIG_PUSCH;
                ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigTPCPdcchConfigPusch (&msg_p, len, 
                        ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        /* +- SPR 17777 */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /* UE_CAPAB_ADD_PARAM Start */
            case UE_CAPABILITY_ADDITIONAL_PARAMETERS: 
            {
                LTE_MAC_UT_LOG( LOG_INFO, PARSE_UTIL,"UE_CAPABILITY_ADDITIONAL_PARAMETERS");
                /* Cyclomatic Complexity changes - starts here */
                resp = parseUECapAdditionalParams (&msg_p, len, 
                        dlUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /* UE_CAPAB_ADD_PARAM End*/
            /*HD FDD Changes Start*/
            /* This is not done for FDD as in case some RRC sends this then L2
             * should not misbehave and silently discards the TAG without using HD */
            case RF_PARAMS:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigRFParams (&msg_p, len, 
                        dlUEInfo_p,
                        /* +- SPR 17777 */
                        /* CA changes Start */
                        internalCellIndex
                        /* CA Changes end */
#ifdef HD_FDD_CONFIG
                        ,ulUEInfo_p
                        ,dlReconfigUeReq_p
                        ,ulReconfigUeReq_p
#endif
                        /* +- SPR 17777 */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /*HD FDD Changes End*/

            /* SPS_CHG */
            case  SPS_CONFIG:
            {  
                resp =  parseSpsConfigInfo(msg_p, 
                        len,
                        dlUEInfo_p,
                        ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );

                msg_p += (len - TAG_LEN);
                break;
            }  

            case PHR_TIMER_CONFIG:
            {
                /* Cyclomatic Complexity changes - starts here */
                /* +- SPR 17777 */
                resp = parseReconfigPHRTimerConfig (&msg_p,
                        ulUEInfo_p
                        );
                /* Cyclomatic Complexity changes - ends here */

                break;
            }
            /* SPS_CHG */ 

            /* SPR 5713 changes start */
            case UE_COMPLIANCE_RELEASE:
            {
                /* Cyclomatic Complexity changes - starts here */
                resp = parseReconfigUEComplianceRel(&msg_p, len, tagLen, 
                        ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /* SPR 5713 changes end */
            /* TTIB_Code Start */                    
            case TTI_BUNDLING_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                /* +- SPR 17777 */
                resp = parseReconfigTTIBundlingInfo(&msg_p, len
                        /*SPR21501 fix start*/
                        ,ulUEInfo_p
                        ,ulReconfigUeReq_p
                        /*SPR21501 fix end*/
                        , internalCellIndex
                        /* +- SPR 17777 */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /* TTIB_Code End */
            /* + TM7_8 Changes Start */
            case PDSCH_EPRE_TO_UE_RS_RATIO:
            {
                resp = parseReconfigPdschEpreToUeRsRatio(&msg_p, len,
                        dlUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        );
                break;
            }
            /* - TM7_8 Changes End */
            /*REL10_CR_CHANGES_START*/
            case MAX_UL_HARQ_TX_INFO:
            {
                resp = parseReconfigMaxUlHarqTxInfo(&msg_p, len,ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,ulReconfigUeReq_p
                        );
                break;
            }
            case PC_MAX_INFO:
            {
                resp = parseReconfigPcMaxInfo(&msg_p, len,ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,ulReconfigUeReq_p
                        );
                break;
            }
            case PUSCH_CONFIG_INFO:
            {
                resp = parseReconfigPuschConfigInfo(&msg_p, len, ulUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ,ulReconfigUeReq_p
                        );
                break;
            }
            /*REL10_CR_CHANGES_END*/

            /*CA changes start*/
            case UE_CATEGORY_V1020:
            {
                resp = macParseReconfigUECategoryV1020Info( &msg_p, len,
                        dlUEInfo_p,
                        ulUEInfo_p,
                        internalCellIndex
                        ,dlReconfigUeReq_p
                        ,ulReconfigUeReq_p
                        );
                break;
            }

            case PUCCH_FORMAT_V1020:
            {
                resp = macParseReconfigPUCCHFormatV1020Info( &msg_p, len,
                        dlUEInfo_p,
                        ulUEInfo_p,
                        internalCellIndex
                        ,dlReconfigUeReq_p
                        ,ulReconfigUeReq_p
                        );
                break;
            }

            case CA_CONFIG:
            {
                resp = macParseReconfigCAConfigInfo( &msg_p, len,
                        dlUEInfo_p,
                        ulUEInfo_p,
                        internalCellIndex
                        ,dlReconfigUeReq_p
                        ,ulReconfigUeReq_p
                        );
                break;
            }
            case DL_INTERFERENCE_INFO:
            {
                dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
                    DL_RECONFIG_INTERFERENCE_INFO;	
                tempChoice = (UInt8)*msg_p;
                dlUEInfo_p->userType = (UserType)tempChoice;
                msg_p += 1;
                dlUEInfo_p->userTypePresent = TRUE;
                ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=UL_RECONFIG_INTERFERENCE_INFO;
                ulUEInfo_p->userType = dlUEInfo_p->userType;
                ulUEInfo_p->userTypePresent = TRUE;

                dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
                ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

                break;
            }
            /*CA changes end*/
            /* SPR 23402 Changes Start */
            /* MOCN Changes Start */
            case OPERATOR_ID_INFO:
                if (OPERATOR_ID_INFO_TAG_LEN != len)
                {     
                    lteWarning("Invalid Tag Length %d for OPERATOR_ID_INFO\n"
                            ,tagLen);
                    LOG_MAC_ERROR( MAC_RRC_INF, "Invalid Tag Length for OPERATOR_ID_INFO");
                    return MAC_FAILURE;
                }
                    /* SES-493 fix starts */
                if ((mocnOperatorParams_g.numOfOperator > 0) &&
                    (*msg_p >= mocnOperatorParams_g.numOfOperator ))
                {
                    /* SES-493 fix ends */
                    lteWarning("Invalid operator ID %d for OPERATOR_ID_INFO\n"
                            ,*msg_p);
                    LOG_MAC_ERROR( MAC_RRC_INF, "Invalid operator ID  for OPERATOR_ID_INFO");
                    return MAC_SYNTAX_ERROR_VAL;
                }
                else
                {    
                    dlUEInfo_p->operatorId = *msg_p;
                    ulUEInfo_p->operatorId = dlUEInfo_p->operatorId;
                    /* SES-493 fix starts */
                    msg_p += 1;
                    /* SES-493 fix ends */
                    /* SPR 23499 Fix Start */
                    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount] = UL_RECONFIG_OPERATOR_ID_INFO;
                    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
                    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]= DL_RECONFIG_OPERATOR_ID_INFO;
                    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
                    /* SPR 23499 Fix End */
                }    
            break;
            /* MOCN Changes End */
            /* SPR 23402 Changes End */
            default:
            {
                lteWarning("Incorrect Tag [%u]received in RECONFIGURE_UE_INFO\n",tag);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tag,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Incorrect Tag received in RECONFIGURE_UE_INFO");
                /* Review comment fix end RJ13 */
                resp = MAC_SYNTAX_ERROR;                    
            }
        }/* end of switch */        
        if (resp != MAC_SUCCESS)
        {
            return resp; 
        }
    }
    return MAC_SUCCESS;
}


/******************************************************************************
 * Function Name  : parseReconfigUECqiConfigIndexV10Info 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the csiconfigindexv10 information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseReconfigUECqiConfigIndexV10Info( UInt8 **msgBuf,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt8 *msg_p           = PNULL;
    UInt16 cqiconfigindexTagLenV10   = 0;
    UInt16 cqiconfigindex2TagLenV10   = 0;
    UInt16 riconfigindexTagLenV10   = 0;
    msg_p = *msgBuf;

    msg_p += 2;

    /* cqi report v920 tag length*/
    cqiconfigindexTagLenV10 = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (CSI_CONFIG_INDEX_VR10_TAG_LENGTH > cqiconfigindexTagLenV10)
    {      
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,cqiconfigindexTagLenV10,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
        return MAC_FAILURE;
    }

    ulCreateReq_p->cqiConfigRequestType = *(msg_p);
    msg_p++;
    /* + SPR 5953 Fix */
    dlCreateReq_p->cqiConfigRequestType = ulCreateReq_p->cqiRequestType;
    /* - SPR 5953 Fix */
    /*L2_FIX_8 */
    if ( ulCreateReq_p->cqiConfigRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    if ( ulCreateReq_p->cqiConfigRequestType )
    {
        tag = LTE_GET_U16BIT(msg_p);
        if (tag == CQI_PMI_CONFIGINDEX2_VR10 )
        {
            msg_p += 2;
            cqiconfigindex2TagLenV10 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CQI_PMI_CONFIGINDEX2_VR10_TAG_LENGTH > cqiconfigindex2TagLenV10)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,cqiconfigindex2TagLenV10,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            ulCreateReq_p->cqiPMIConfigIndex_2 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            tag = LTE_GET_U16BIT(msg_p);
        }
        if (tag == RI_CONFIG_INDEX_INFO)
        {
            msg_p += 2;
            riconfigindexTagLenV10 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (RI_CONFIG_INDEX_INFO_LEN> riconfigindexTagLenV10)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,riconfigindexTagLenV10,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
                return MAC_FAILURE;
            }
            ulCreateReq_p->riConfigIndex_2 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;
        }

    }
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseReconfigUECsiSubframePatternV10Info 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the csisubframepatternconfigv10 information in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseReconfigUECsiSubframePatternV10Info( UInt8 **msgBuf,
        UeContextForUplink *ulCreateReq_p, UeContextForDownlink *dlCreateReq_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt8 *msg_p           = PNULL;
    UInt16 csisubframepatternTagLen   = 0;
    UInt16 csimeasurementsubsetTagLen   = 0;
    UInt8 subsetIndexNum = 0;
    msg_p = *msgBuf;
    UInt8 ConfigRequestType = 0;
    /* EICIC_Coverity CID 69390 Start */
    CsiChoice choice = FDD_CONFIG_TYPE;
    /* EICIC_Coverity CID 69390 End */
    UInt8 subsetPatternLength = 0;
    /* EICIC_Coverity CID 69391 Start */
    UInt8 tempChoice = 0;
    /* EICIC_Coverity CID 69391 End */
    msg_p += 2;

    /* cqi report v920 tag length*/
    csisubframepatternTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if (CSI_SUBFRAME_PATTERN_CONFIG_VR10_TAG_LENGTH  > csisubframepatternTagLen)
    {      
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,csisubframepatternTagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
        return MAC_FAILURE;
    }

    ConfigRequestType = *(msg_p);
    ulCreateReq_p->cqiSubsetConfigRequestType = ConfigRequestType;
    dlCreateReq_p->cqiSubsetConfigRequestType = ConfigRequestType;

    msg_p++;


    if ( ConfigRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    if ( ConfigRequestType )
    {
        tag = LTE_GET_U16BIT(msg_p);
        if(tag == CSI_MEASUREMENT_SUBSET_VR10)
        {
            msg_p += 2;
            csimeasurementsubsetTagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CSI_MEASUREMENT_SUBSET_VR10_TAG_LENGTH  > csimeasurementsubsetTagLen)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,csimeasurementsubsetTagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            tempChoice = (UInt8)*msg_p;
            choice = (CsiChoice) tempChoice;	  
            msg_p += 1;
#ifdef FDD_CONFIG

            if(FDD_CONFIG_TYPE== choice)
            {
                subsetPatternLength = 5;
            }
            else
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
#else
            if(TDD_CONFIG1_5 == choice)
            {
                subsetPatternLength = 3;
            }	
            else if(TDD_CONFIG0 == choice)
            {
                subsetPatternLength = 9;
            }	
            else if(TDD_CONFIG6 == choice)
            {
                subsetPatternLength = 8;
            }	
            else
            {

                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

#endif
            for(subsetIndexNum = 0;subsetIndexNum< subsetPatternLength; subsetIndexNum++)
            {
                ulCreateReq_p->csiMeasurementSubset1[subsetIndexNum] = *(msg_p);
                msg_p++;
            }
        }
        tag = LTE_GET_U16BIT(msg_p);


        if(tag == CSI_MEASUREMENT_SUBSET2_VR10)
        {
            msg_p += 2;
            csimeasurementsubsetTagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CSI_MEASUREMENT_SUBSET_VR10_TAG_LENGTH  > csimeasurementsubsetTagLen)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulCreateReq_p->ueIdx,csimeasurementsubsetTagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            /* EICIC_Coverity CID 69391 Start */
            tempChoice = (UInt8)*msg_p;  
            choice = (CsiChoice)tempChoice;
            /* EICIC_Coverity CID 69391 End */	  
            msg_p += 1;
#ifdef FDD_CONFIG

            if(FDD_CONFIG_TYPE== choice)
            {
                subsetPatternLength = 5;
            }
            else
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
#else
            if(TDD_CONFIG1_5 == choice)
            {
                subsetPatternLength = 3;
            }	
            else if(TDD_CONFIG0 == choice)
            {
                subsetPatternLength = 9;
            }	
            else if(TDD_CONFIG6 == choice)
            {
                subsetPatternLength = 8;
            }	
            else
            {

                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        choice,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid choice");

                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }

#endif
            for(subsetIndexNum = 0;subsetIndexNum< subsetPatternLength; subsetIndexNum++)
            {
                ulCreateReq_p->csiMeasurementSubset2[subsetIndexNum] = *(msg_p);
                msg_p++;
            }
            tag = LTE_GET_U16BIT(msg_p);
        }
    }		 
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}
/* Cyclomatic Complexity changes - starts here */
/****************************************************************************
 * Function Name  : parseReconfigCqiInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  tagLen - length of the specific tag.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the CQI information 
 *                  and updates the DL & UL structures for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigCqiInfo (UInt8 **msgBuf, 
        UInt16               len,
        UInt16               tagLen, 
        UeContextForDownlink *dlUEInfo_p, 
        UeContextForUplink   *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        )
{
    UInt16 tag = 0;
    /* + Coverity 32755, 32750, 32206 */ 
    MacRetType resp = MAC_SUCCESS;
    /* - Coverity 32755, 32750, 32206 */ 
    UInt8 *msg_p = PNULL;
    UInt8 periodicCQIEnabled = 0;
    UInt8 aperiodicCQIEnabled = 0;

    msg_p = *msgBuf;
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */

    ULCQIReqInfo *ulCqiReqInfo_p = 
        &ulReconfigUeReq_p->rrcInfpucchConfigReqInfo.ulCqiReqInfo;
    /* Rel 5.3: Coverity 32240 Fix Start */
    ulCqiReqInfo_p->cqiConfigMsg = UL_RECONFIG_NO_CQI_MSG;
    /* Rel 5.3: Coverity 32240 Fix End */
    /*+COVERITY 5.3.0 - 32241*/
    ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = UL_RECONFIG_NO_CQI_SUBBAND_RI_MSG;
    /*-COVERITY 5.3.0 - 32241*/

    /* + Coverity 55042 */
    dlUEInfo_p->cqiMode = CQI_MODE_INVALID;
    /* - Coverity 55042 */
    /*SS_S2*/
    /* to check if optional fields CQI tag are present */
    /*                if ( len != 4  && len != 9
                      && len !=14 && len != 25 )
                      {
                      lteWarning("CQI INFO TAG Len Invalid [%d]", tagLen);
                      return MAC_FAILURE;
                      }
                      */
    do 
    {
        /* Rel9_upgrade_CR396 */
        /* + SPR_3212 */
        /* CA Changes Start - Max TagLen is increased by 6 because of addition of a new
         * tag CQI_APERIODIC_CONFIG_INFO */
        /* SPR 12554 Fix Start */
        if ( len > 93 || len < 4 )
            /* SPR 12554 Fix End */
            /* CA changes End */
            /* - SPR_3212 */
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulUEInfo_p->ueIdx,tagLen,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "CQI_INFO_INVALID_TAGLEN");         
            /* Rel9_upgrade_CR396 */
            return MAC_FAILURE;
        }



        ulUEInfo_p->cqiinfoflag = TRUE;
        dlUEInfo_p->cqiInfoFlag = TRUE;
        /* + coverity 32767 */
        ulReconfigUeReq_p->rrcInfpucchConfigReqInfo.pucchConfigMsg = 
            (ULReconfigPucchMsgType) (ulReconfigUeReq_p->rrcInfpucchConfigReqInfo.pucchConfigMsg | UL_RECONFIG_CQI_IND); 
        /* - coverity 32767 */
        /* SPR 12554 Fix Start */
        dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
            DL_RECONFIG_CQI_INFO;
        dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
        /* + Coverity 32761 */
        ulCqiReqInfo_p->cqiConfigMsg = 
            (ULReconfigCQIType) (ulCqiReqInfo_p->cqiConfigMsg | UL_RECONFIG_CQI_APERIODIC_IND); 
        /* - Coverity 32761 */
        /* No need to proceed furthur because CQI INFO has been come for APERIODIC CQI RELEASE only*/
        if(len == 4)
        {
            break;
        }    
        /* SPR 12554 Fix End */
        tag = LTE_GET_U16BIT(msg_p);

        if ( CQI_APERIODIC_INFO == tag )
        {
            /* Bandwidth Fix */
            if (8 > cellParams_p->dlAvailableRBs)
            {
                lteWarning("Aperiodic mode configured with DL "
                        "RBs are less than 8\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        cellParams_p->dlAvailableRBs,
                        internalCellIndex,
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Aperiodic mode configured with DL\
                        RBs are less than 8");
                /* Review comment fix end RJ13 */
                return MAC_FAILURE;
            }
            /* Bandwidth Fix */
            /* SPR 12554 Fix Start */
            /* Code moved to common place */
            /* SPR 12554 Fix End */

            /* skip CQI_APERIODIC_INFO tag */
            msg_p += 2;
            /* - CQI_4.1 */
            /*skip the length of the CQI Aperiodic Info tag*/
            msg_p += 2;

            ulUEInfo_p->cqiMode = *msg_p++;

            resp = validateCqiMode (ulUEInfo_p->cqiMode);
            if (resp != MAC_SUCCESS)
            {
                lteWarning(" Invalid Aperiodic CQI Mode:%d\n", ulUEInfo_p->cqiMode);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->cqiMode,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid Aperiodic CQI Mode");
                /* Review comment fix end RJ13 */
                return resp;
            }

            /* + Coverity 55043 */
            dlUEInfo_p->cqiMode = (CQIMode) ulUEInfo_p->cqiMode;
            /* - Coverity 55043 */
            /* + CQI_4.1 */
            aperiodicCQIEnabled = TRUE;
            /* - CQI_4.1 */

            tag = LTE_GET_U16BIT(msg_p);
            if (APERIODIC_CSI_TRIGGER_R10 == tag)
            {
                msg_p += U16BIT_LEN;
                tagLen =  LTE_GET_U16BIT(msg_p); 
                if ( tagLen != APERIODIC_CSI_TRIGGER_R10_TAG_LEN )
                {
                    lteWarning("Invalid Tag Length %u for"
                            " APERIODIC_CSI_TRIGGER_R10_TAG_LEN info\n"
                            ,tagLen);
                    return MAC_SYNTAX_ERROR_VAL;

                }
                msg_p += U16BIT_LEN;
                ulUEInfo_p->trigger1r10 = *msg_p++; 
                ulUEInfo_p->trigger2r10 = *msg_p++; 
                resp = macValidateCsiTriggerR10 ( ulUEInfo_p->trigger1r10,ulUEInfo_p->trigger2r10);
                dlUEInfo_p->trigger1r10 = ulUEInfo_p->trigger1r10; 
                dlUEInfo_p->trigger2r10 = ulUEInfo_p->trigger2r10; 

                if ( resp != MAC_SUCCESS )
                {
                    lteWarning(" Invalid Aperiodic CQI Mode");
                    return resp;
                }
                /* if Periodic CQI Info is present */
                tag = LTE_GET_U16BIT(msg_p);

                /*tagLen +6*/
            }
        }
        if ( CQI_PERIODIC_INFO == tag )
        {
            /* Cyclomatic Complexity change start*/
            resp = parsePeriodicReconfigCqiInfo(&periodicCQIEnabled,
                    &msg_p,ulUEInfo_p,dlUEInfo_p,internalCellIndex,len,
                    tagLen
                    /* +- SPR 17777 */
                    ,ulCqiReqInfo_p
                    );

            if ( resp != MAC_SUCCESS )
            {
                return resp;
            }

            /* Cyclomatic Complexity changes end*/
            /* Rel9_upgrade_CR396 */
            tag = LTE_GET_U16BIT(msg_p);
        }
        /* + CQI_4.1 */
        if ( (periodicCQIEnabled == TRUE) && (aperiodicCQIEnabled == TRUE) )
        {
            dlUEInfo_p->cqiIndication = PERIODIC_APERIODIC_MODE;
            ulCqiReqInfo_p->cqiConfigMsg = 
                (ULReconfigCQIType) (ulCqiReqInfo_p->cqiConfigMsg |
                        UL_RECONFIG_CQI_PERIODIC_APERIODIC_IND); 
        }    
        else if (periodicCQIEnabled == TRUE) 
        {
            dlUEInfo_p->cqiIndication = PERIODIC_CQI_REPORTING_MODE;
        }    
        else if  (aperiodicCQIEnabled == TRUE)
        {
            dlUEInfo_p->cqiIndication = APERIODIC_CQI_REPORTING_MODE;
        }    
        /* - CQI_4.1 */
        if (CQI_REPORT_CONFIG_V920 == tag) 
        {
            /* Cyclomatic Complexity changes - starts here */
            /* +- SPR 17777 */
            if (MAC_SUCCESS != parseReconfigUECqiV920Info (&msg_p, 
                        ulUEInfo_p,dlUEInfo_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ))
            {
                return MAC_FAILURE;
            }
            /* Cyclomatic Complexity changes - ends here */
        }
        /*EICIC*/
        tag = LTE_GET_U16BIT(msg_p);

        if (CSI_SUBFRAME_PATTERN_CONFIG_VR10 == tag) 
        {
            if (MAC_SUCCESS != parseReconfigUECsiSubframePatternV10Info (&msg_p, 
                        ulUEInfo_p, dlUEInfo_p 
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA Changes end */
                        ))
            {
                return MAC_FAILURE;
            }
        }
        /*EICIC*/
        /* Rel9_upgrade_CR396 */
    } while (0);

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parsePeriodicReconfigCqiInfo 
 * Inputs         : periodicCQIEnabled
 *                  msg_p - Pointer to the incoming message
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  len    - length of the API message received.
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 *                  ulCqiReqInfo_p- Pointer to uplinkCqi request info
 * Outputs        : modifies periodicCQIEnabled
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the periodic CQI information 
 *                  and updates the DL & UL structures for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parsePeriodicReconfigCqiInfo (UInt8 *periodicCQIEnabled,
        UInt8 **msg_p, 
        UeContextForUplink   *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p, 
        /* CA changes Start */
        InternalCellIndex internalCellIndex,
        /* CA Changes end */
        UInt16               len,
        UInt16               tagLen
        /* +- SPR 17777 */
        ,ULCQIReqInfo        *ulCqiReqInfo_p 
        )
{
    UInt16 tag = 0;
    MacRetType resp = MAC_SUCCESS;
    ulCqiReqInfo_p->cqiConfigMsg = 
        (ULReconfigCQIType) (ulCqiReqInfo_p->cqiConfigMsg | UL_RECONFIG_CQI_PERIODIC_IND); 
    /* SPR 12554 Fix Start */
    /* Code moved to common place */
    /* SPR 12554 Fix End */


    UInt32 cqiPeriodicTagLen = 0;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* + CQI_4.1 */
    *periodicCQIEnabled = TRUE;
    /* - CQI_4.1 */
    /* skip the CQI_PERIODIC_INFO tag */
    *msg_p += 2;

    /* cqi periodic tag length*/
    cqiPeriodicTagLen = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;

    ulUEInfo_p->cqiRequestType = **(msg_p);
    *msg_p = *msg_p + 1;
    /* + SPR 5953 Fix */
    dlUEInfo_p->cqiRequestType = ulUEInfo_p->cqiRequestType;
    /* - SPR 5953 Fix */
    /*L2_FIX_8 */
    if ( ulUEInfo_p->cqiRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    if ( ulUEInfo_p->cqiRequestType )
    {
        if ( cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN)
        {
            lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    len,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
            /* Review comment fix end RJ13 */
        }
        tag = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;

        if ( CQI_PMI_CONFIG_INDEX_INFO == tag)
        {
            cqiPeriodicTagLen = LTE_GET_U16BIT(*msg_p);
            *msg_p += 2;

            if ( cqiPeriodicTagLen <  PERIODIC_CQI_LEN )
            {
                lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");

                /* L2_FIX_9_start */
                LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
                /* L2_FIX_9_End */

                return MAC_FAILURE;
            }
            ulUEInfo_p->cqiPMIConfigIndex = LTE_GET_U16BIT(*msg_p);
            *msg_p += 2;

            resp = validateCqiPMIConfigIndex( ulUEInfo_p->cqiPMIConfigIndex
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    );
            if (resp != MAC_SUCCESS)
            {
                return resp;
            }
            ulUEInfo_p->cqiPucchResourceIndex = LTE_GET_U16BIT(*msg_p);
            *msg_p += 2;

            resp = validateCqiPucchResourceIndex( ulUEInfo_p->cqiPucchResourceIndex
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    );
            if (resp != MAC_SUCCESS)
            {
                return resp;
            }
            /*SS_S2*/
            ulUEInfo_p->simultaneousACKNACKAndCQI = **msg_p;
            *msg_p += 1;
            resp = validateSimultaneousACKNACKAndCQI(
                    ulUEInfo_p->simultaneousACKNACKAndCQI
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
            if ( resp != MAC_SUCCESS )
            {
                return resp;
            }
            /* + Coverity 55044 */
            ulUEInfo_p->cqiformatIndicatorPeriodic = (PeriodicFeedbackType)**msg_p;
            *msg_p += 1;
            /* - Coverity 55044 */

            /*L2_FIX_13_start*/
            resp = validateCqiformatIndicatorPeriodic (ulUEInfo_p->cqiformatIndicatorPeriodic);
            if ( resp != MAC_SUCCESS )
            {
                lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n", 
                        ulUEInfo_p->cqiformatIndicatorPeriodic);
                return resp;
            }
            /*L2_FIX_13_end*/

            tag = LTE_GET_U16BIT(*msg_p);
            /* SPR 2617 Start*/
            /*Check if Report FORMAT is SUBBAND*/
            if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
            {
                /* + Coverity 32754 */
                ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
                    (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg | UL_RECONFIG_CQI_PERIODIC_SUBBAND_IND); 
                /* - Coverity 32754 */
                /*SS_S2*/
                /* + CQI_4.1 */
                if (8 > cellParams_p->dlAvailableRBs)
                {
                    lteWarning("Periodic Subband mode configured with DL "
                            "RBs are less than 8\n");
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            cellParams_p->dlAvailableRBs,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Periodic Subband mode configured \
                            with DL RBs are less than 8");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }
                /* - CQI_4.1 */
                *msg_p += 2;
                len = LTE_GET_U16BIT(*msg_p);
                *msg_p += 2;
                /*L2_FIX_4_start*/
                if ( len < CQI_FORMAT_PERIODIC_SUBBAND_K_LEN )
                {
                    LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            MAC_CREATE_UE_ENTITY_REQ,tagLen, 0,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");

                    return MAC_FAILURE;
                }
                /*L2_FIX_4_end*/

                ulUEInfo_p->cqiformatIndicatorPeriodic_subband_k = **msg_p;
                *msg_p += 1;

                /*L2_FIX_14_start*/
                resp = validateCqiformatIndicatorPeriodicSubbandK (ulUEInfo_p->cqiformatIndicatorPeriodic_subband_k);
                if ( resp != MAC_SUCCESS )
                {
                    lteWarning("Invalid range for cqiformatIndicatorPeriodic_subband_k:%d\n",
                            ulUEInfo_p->cqiformatIndicatorPeriodic_subband_k);
                    return resp;
                }
                /*L2_FIX_14_end*/
            }
            else
            {
                if(1 == ulUEInfo_p->cqiformatIndicatorPeriodic)
                {
                    return MAC_FAILURE;
                }
            }
            /* SPR 2617 End*/
            /*SS_S2*/
            tag = LTE_GET_U16BIT(*msg_p);
            /* SPR 1595 changes start */
            if (RI_CONFIG_INDEX_INFO == tag)
            {    
                /* + Coverity 32754 */ 
                ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
                    (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg | UL_RECONFIG_CQI_PERIODIC_RI_IND); 
                /* - Coverity 32754 */ 
                *msg_p += 2;
                len = LTE_GET_U16BIT(*msg_p);
                *msg_p += 2;
                /*SPR_4944_fix Start*/
                if(len < RI_CONFIG_INDEX_INFO_LEN)
                    /*SPR_4944_fix End */
                {
                    lteWarning("Invalid Length for riConfigIndex .\n");
                    /* Review comment fix start RJ13 */
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            len,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Invalid Length for riConfigIndex");
                    /* Review comment fix end RJ13 */
                    return MAC_FAILURE;
                }

                ulUEInfo_p->riConfigIndex = LTE_GET_U16BIT(*msg_p);
                *msg_p += 2;
                resp = validateRiConfigIndex(ulUEInfo_p->riConfigIndex,
                        /* CA changes Start */
                        internalCellIndex
                        /* CA Changes end */
                        );
                if (resp != MAC_SUCCESS)
                {
                    return resp;
                }
            }
            /* SPR 1595 changes end */

        }
        /*EICIC +*/
        else  if( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)
        {
            /*Complexity Start*/
            resp =  eicicParsePeriodicReconfigCqiInfo(msg_p,
                    ulUEInfo_p,
                    dlUEInfo_p,
                    internalCellIndex,
                    ulCqiReqInfo_p,
                    tagLen,
                    cellParams_p);
            /*Complexity End*/

        }

    }
    /* SPR 21043 Start */
    else
    {
        ulUEInfo_p->cqiMaskV920 = FALSE;
    }    
    /* SPR 21043 End */


    /*EICIC -*/
    return resp;
}

/*Complexity Start*/
/****************************************************************************
 * Function Name  : eicicParsePeriodicReconfigCqiInfo
 * Inputs         : msg_p - Pointer to the incoming message
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  taglen    - length of the API message received.
 cellParams_p- Pointer to CellConfig Parameters
 *                  ulCqiReqInfo_p- Pointer to uplinkCqi request info
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the periodic CQI information for EICIC 
 *                  and updates the DL & UL structures for UE context
 *                  reconfiguration at MAC .
 *****************************************************************************/
MacRetType eicicParsePeriodicReconfigCqiInfo( UInt8 **msg_p,
        UeContextForUplink *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p,
        UInt16 tagLen,
        CellConfigParams *cellParams_p
        )
{
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    UInt16 len;	
    UInt16 tag = 0;
    cqiPeriodicTagLen = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;
    if ( cqiPeriodicTagLen <  PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        /* L2_FIX_9_start */
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        /* L2_FIX_9_End */
        return MAC_FAILURE;
    }
    ulUEInfo_p->cqiPMIConfigIndex = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;
    resp = validateCqiPMIConfigIndex( ulUEInfo_p->cqiPMIConfigIndex
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    ulUEInfo_p->cqiPucchResourceIndex = LTE_GET_U16BIT(*msg_p);
    *msg_p += 2;
    resp = validateCqiPucchResourceIndex( ulUEInfo_p->cqiPucchResourceIndex
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    /*SS_S2*/
    ulUEInfo_p->simultaneousACKNACKAndCQI = **msg_p;
    *msg_p += 1;
    resp = validateSimultaneousACKNACKAndCQI(
            ulUEInfo_p->simultaneousACKNACKAndCQI
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if ( resp != MAC_SUCCESS )
    {
        return resp;
    }
    /* + Coverity 55044 */
    ulUEInfo_p->cqiformatIndicatorPeriodic = (PeriodicFeedbackType)**msg_p;
    *msg_p += 1;
    /* - Coverity 55044 */

    /*L2_FIX_13_start*/
    resp = validateCqiformatIndicatorPeriodic (ulUEInfo_p->cqiformatIndicatorPeriodic);
    if ( resp != MAC_SUCCESS )
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n", 
                ulUEInfo_p->cqiformatIndicatorPeriodic);
        return resp;
    }
    /*L2_FIX_13_end*/

    tag = LTE_GET_U16BIT(*msg_p);
    /* SPR 2617 Start*/
    /*Check if Report FORMAT is SUBBAND*/
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        /* + Coverity 32754 */
        ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
            (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg | UL_RECONFIG_CQI_PERIODIC_SUBBAND_IND); 
        /* - Coverity 32754 */
        /*SS_S2*/
        /* + CQI_4.1 */
        if (8 > cellParams_p->dlAvailableRBs)
        {
            lteWarning("Periodic Subband mode configured with DL "
                    "RBs are less than 8\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    cellParams_p->dlAvailableRBs,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Periodic Subband mode configured \
                    with DL RBs are less than 8");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
        /* - CQI_4.1 */
        *msg_p += 2;
        len = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        /*L2_FIX_4_start*/
        if ( len < CQI_FORMAT_PERIODIC_SUBBAND_K_LEN )
        {
            LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    MAC_CREATE_UE_ENTITY_REQ,tagLen, 0,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");

            return MAC_FAILURE;
        }
        /*L2_FIX_4_end*/

        ulUEInfo_p->cqiformatIndicatorPeriodic_subband_k = **msg_p;
        *msg_p += 1;

        /*L2_FIX_14_start*/
        resp = validateCqiformatIndicatorPeriodicSubbandK (ulUEInfo_p->cqiformatIndicatorPeriodic_subband_k);
        if ( resp != MAC_SUCCESS )
        {
            lteWarning("Invalid range for cqiformatIndicatorPeriodic_subband_k:%d\n",
                    ulUEInfo_p->cqiformatIndicatorPeriodic_subband_k);
            return resp;
        }
        /*L2_FIX_14_end*/
    }
    else
    {
        if(1 == ulUEInfo_p->cqiformatIndicatorPeriodic)
        {
            return MAC_FAILURE;
        }
    }
    /* SPR 2617 End*/
    /*SS_S2*/
    tag = LTE_GET_U16BIT(*msg_p);
    /* SPR 1595 changes start */
    if (RI_CONFIG_INDEX_INFO == tag)
    {    
        /* + Coverity 32754 */ 
        ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
            (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg | UL_RECONFIG_CQI_PERIODIC_RI_IND); 
        /* - Coverity 32754 */ 
        *msg_p += 2;
        len = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        /*SPR_4944_fix Start*/
        if(len < RI_CONFIG_INDEX_INFO_LEN)
            /*SPR_4944_fix End */
        {
            lteWarning("Invalid Length for riConfigIndex .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    len,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid Length for riConfigIndex");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }

        ulUEInfo_p->riConfigIndex = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;
        resp = validateRiConfigIndex(ulUEInfo_p->riConfigIndex,
                /* CA changes Start */
                internalCellIndex
                /* CA Changes end */
                );
        if (resp != MAC_SUCCESS)
        {
            return resp;
        }
    }
    /* SPR 1595 changes end */
    tag = LTE_GET_U16BIT(*msg_p);
    if (CSI_CONFIG_INDEX_VR10 == tag) 
    {
        if (MAC_SUCCESS != parseReconfigUECqiConfigIndexV10Info (msg_p, 
                    ulUEInfo_p, dlUEInfo_p 
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    ))
        {
            return MAC_FAILURE;
        }
    }
    return resp;
}
/*Complexity End*/
/******************************************************************************
 * Function Name  : parseReconfigUECqiV920Info 
 * Inputs         : tagLen - Length of the tag
 *                  msgBuf - pointer to the input buffer
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the CQI V920 information in 
 *                  Reconfig UE Entity Request and updates the UL UE context.
 ******************************************************************************/
STATIC  MacRetType parseReconfigUECqiV920Info (  
        /* +- SPR 17777 */
        UInt8                **msgBuf,
        UeContextForUplink   *ulUEInfo_p,
        UeContextForDownlink  *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag             = 0;
    UInt16 cqiTagLenV920   = 0;
    UInt8 *msg_p           = PNULL;

    msg_p = *msgBuf;

    /* skip CQI_REPORT_CONFIG_V920 tag */
    msg_p += 2; 

    /* cqi report v920 tag length*/
    cqiTagLenV920 = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if ( CQI_REPORT_V920_LEN > cqiTagLenV920 )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ueIdx,cqiTagLenV920,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");  
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);

    if (CQI_MASK_V920 == tag)
    {
        /* SPR 3203 3226 Start */
        /* skip CQI_MASK_V920 tag */
        msg_p += 2;

        //Skip the tag length
        /* SPR 3203 3226 End */
        msg_p += 2;
        ulUEInfo_p->cqiMaskV920 = *msg_p++;

        /** SPR 14459 Changes Start **/ 
        if ( ulUEInfo_p->cqiMaskV920 != FALSE )
            /** SPR 14459 Changes End **/ 
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulUEInfo_p->ueIdx,ulUEInfo_p->cqiMaskV920,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                    DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                    "CQI_MASK_V920_INVALID_VALUE");         
            return MAC_FAILURE;
        }
        /** SPR 14459 Changes Start **/ 
        /* if cqiMaskV920 TAG is present cqiMaskV920 value is 0
         * then cqi mask should be set to TRUE */
        ulUEInfo_p->cqiMaskV920 = TRUE;
        /** SPR 14459 Changes End **/ 
        tag = LTE_GET_U16BIT(msg_p);
    }

    if (PMI_RI_REPORT_V920 == tag)
    {
        /* SPR 3203 3226 Start */
        /* skip PMI_RI_REPORT_V920 tag */
        msg_p += 2;
        //Skip the tag length
        /* SPR 3203 3226 End */
        msg_p += 2;
        ulUEInfo_p->pmiRiReportV920 = *msg_p++;
        if (ulUEInfo_p->pmiRiReportV920 != TRUE && 
                ulUEInfo_p->pmiRiReportV920 != FALSE )
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulUEInfo_p->ueIdx,ulUEInfo_p->pmiRiReportV920,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                    DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                    "PMI_RI_REPORT_V920_INVALID_VALUE");     
            return MAC_FAILURE;
        }
        /* + TM7_8 Changes Start */
        dlUEInfo_p->pmiRiReportV920 = ulUEInfo_p->pmiRiReportV920;
        /* - TM7_8 Changes End */
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigDLMaxRBInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the DL Max RB information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigDLMaxRBInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_MAX_RB_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    if (len != DL_MAX_RB_INFO_LEN)
    {
        lteWarning(
                "Minimum length require not present for DL_MAX_RB_INFO_LEN\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Minimum length require not present for DL_MAX_RB_INFO_LEN");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }    
    dlUEInfo_p->maxRB = *(*msgBuf)++;
    if (MAC_SUCCESS != 
            validateDlMaxRB(dlUEInfo_p->maxRB
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ))
    {
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }    

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigTXModeInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the API message
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the TX Mode information and updates 
 *                  the DL structure for UE context reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigTXModeInfo (UInt8 **msgBuf, 
        UInt8                len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf;

    if (len != TX_MODE_INFO_LEN)
    {
        lteWarning(
                "Minimum length require not present for TX_MODE_INFO_LEN\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Minimum length require not present for TX_MODE_INFO_LEN");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }    
    /* + Coverity 55045 */
    dlUEInfo_p->transmissionMode = (TransmissonMode)*msg_p;
    msg_p++;
    /* - Coverity 55045 */
    if (MAC_SUCCESS != 
            validateTransmissionMode(dlUEInfo_p->transmissionMode
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                ))
    {
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid transmissionMode");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    /* + CL-MIMO LJA*/
    if((1 == dlUEInfo_p->transmissionMode) ||
            (2 == dlUEInfo_p->transmissionMode)||
            (7 == dlUEInfo_p->transmissionMode)) 
    {
        /*CodebookSubsetRestriction is only valid for transmission modes 3,4,5 
         *and 6, hence initializing codebookSubsetRestriction as INVALID.
         */
        dlUEInfo_p->cbsrInfo.cbsrType = CBSR_INVALID;
    }
    /* - CL-MIMO LJA*/
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseRecfgCodebookSubRestriction 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the API message 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  currentTransmissionMode - current configured transmission 
 *                  internalCellIndex - cell index used at MAC
 *                  mode 
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the codebook subset restriction 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseRecfgCodebookSubRestriction (UInt8 **msgBuf, 
        UInt8                len,
        UeContextForDownlink *dlUEInfo_p, 
        UInt8                currentTransmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p = PNULL;
    /* + CL-MIMO LJA*/
    UInt8 i = 0;
    /* - CL-MIMO LJA*/

    msg_p = *msgBuf;

    if ( len != 13 )
    {
        lteWarning("Invalid Tag Length for codebookSubsetRestriction\
                in MAC_RECONFIGURE_UE_ENTITY_REQ \n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for codebookSubsetRestriction\
                in MAC_RECONFIGURE_UE_ENTITY_REQ");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    if((    (INVALID_TRANS_MODE == dlUEInfo_p->transmissionMode) && 
                (
                 (3 == currentTransmissionMode)||
                 (4 == currentTransmissionMode)||
                 (5 == currentTransmissionMode)||
                 (6 == currentTransmissionMode)
                )
       ) ||
            (3 == dlUEInfo_p->transmissionMode)||
            (4 == dlUEInfo_p->transmissionMode)||
            (5 == dlUEInfo_p->transmissionMode)||
            (6 == dlUEInfo_p->transmissionMode))
    {
        /* Reconfiguration of CBSR without changing transmission mode
         * or by reconfiguring the transmission mode
         */
        LTE_MAC_UT_LOG( LOG_INFO, \
                PARSE_UTIL,\
                "codebookSubsetRestriction Received in \
                MAC_RECONFIGURE_UE_ENTITY_REQ\n");                         

            /* + Coverity 32758 */ 
            dlUEInfo_p->cbsrInfo.cbsrType = (codebookSubsetRestrictionType) *msg_p++;
        /* + Coverity 32758 */ 

        for (i = 0; i < MAX_CBSR_SIZE; i++)
        {
            dlUEInfo_p->cbsrInfo.cbsrValue[i] = *msg_p++;
        }

        if((INVALID_TRANS_MODE == dlUEInfo_p->transmissionMode) &&
                (
                 (3 == currentTransmissionMode)||
                 (4 == currentTransmissionMode)||
                 (5 == currentTransmissionMode)||
                 (6 == currentTransmissionMode)
                )
          )
        {
            /*--coverity--530--54185*/
            if(MAC_SUCCESS != validateCBSR(&(dlUEInfo_p->cbsrInfo),currentTransmissionMode,
                        /* +- SPR 17777 */
                        internalCellIndex)
              )
                /*--coverity--530--54185*/
            {
                lteWarning("Atleast one bit should be 1 in \
                        cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEInfo_p->cbsrInfo.cbsrType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Atleast one bit should be 1 in \
                        cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ");
                /* Review comment fix end RJ13 */
                /* + coverity 32217 */
                return MAC_FAILURE;
                /* - coverity 32217 */
            }
        }
        else
        {
            /*--coverity--530--54185*/
            if(MAC_SUCCESS != validateCBSR(&(dlUEInfo_p->cbsrInfo), dlUEInfo_p->transmissionMode,
                        /* +- SPR 17777 */
                        internalCellIndex)
              )
                /*--coverity--530--54185*/
            {
                lteWarning("Atleast one bit should be 1 in \
                        cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEInfo_p->cbsrInfo.cbsrType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Atleast one bit should be 1 in \
                        cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ");
                /* Review comment fix end RJ13 */
                /* + coverity 32217 */
                return MAC_FAILURE;
                /* - coverity 32217 */
            }
        }
    }
    else
    {
        lteWarning("codebookSubsetRestriction received for \
                transmission mode other than 3,4,5,6 in \
                MAC_RECONFIGURE_UE_ENTITY_REQ\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "codebookSubsetRestriction received for TM \
                other than 3,4,5,6 in MAC_RECONFIGURE_UE_ENTITY_REQ");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigNumOfLayerInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Number of Layer information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigNumOfLayerInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p 
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_NUM_OF_LAYERS_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    if (len != NUM_OF_LAYER_INFO_LEN)
    {
        lteWarning(
                "Minimum length require not present for NUM_OF_LAYER_INFO\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Minimum length require not present for NUM_OF_LAYER_INFO");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }    

    /* + CL-MIMO LJA*/
    dlUEInfo_p->rankIndicator = *(*msgBuf)++;
    /* - CL-MIMO LJA*/

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigCodebookIndexInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Codebook index information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigCodebookIndexInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_CODEBOOK_INDEX_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    if (len != CODEBOOK_INDEX_INFO_LEN)
    {
        lteWarning(
                "Minimum length require not present for CODEBOOK_INDEX_INFO\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Minimum length require not present for CODEBOOK_INDEX_INFO");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }    
    dlUEInfo_p->precodingIndex = *(*msgBuf)++;
    if (MAC_SUCCESS != 
            validatePrecodingIndex(dlUEInfo_p->precodingIndex
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                ))
    {
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigSRConfigInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len_p    - length of the API message received.
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  isContinueFlag_p
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the SR Config information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigSRConfigInfo (UInt8 **msgBuf, 
        UInt16             *len_p,
        UeContextForUplink *ulUEInfo_p,
        UInt8              *isContinueFlag_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        )
{
    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    UInt16 tag = 0;
    UInt8 *msg_p = PNULL;
    UInt16 len = *len_p; 

    msg_p = *msgBuf;

    if ( len != 5 && len != 12 )
    {
        lteWarning("Invalid Tag Length for SR Info");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for SR Info");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    ulUEInfo_p->requestType = *msg_p++;

    resp = validateSRRequestType( ulUEInfo_p->requestType
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    if ( resp != MAC_SUCCESS )
    {
        return resp;
    }
    len -= 5;
    /* + coverity 32769 */
    ulReconfigUeReq_p->rrcInfpucchConfigReqInfo.pucchConfigMsg = 
        (ULReconfigPucchMsgType) (ulReconfigUeReq_p->rrcInfpucchConfigReqInfo.pucchConfigMsg | UL_RECONFIG_SR_IND); 
    /* - coverity 32769 */

    if ( ulUEInfo_p->requestType == 0 )
    {
        /* Set the continue flag */
        *isContinueFlag_p = TRUE;
        *len_p = len;
        *msgBuf = msg_p;
        return MAC_SUCCESS;
    }
    if ( len != 7)
    {
        lteWarning("Mac syntax error.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax error");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( tag != SR_SETUP_INFO)
    {
        lteWarning("Invalid SR_SETUP_INFO Tag.\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid SR_SETUP_INFO Tag");
        /* Review comment fix end RJ13 */
        /* + coverity 32766 */
        return MAC_FAILURE;
        /* - coverity 32766 */
    }
    len = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if ( len != SR_SETUP_INFO_LEN)
    {
        lteWarning("Mac syntax length error .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac SR_SETUP_INFO_LEN length error");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->srPucchResourceIndex = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    resp = validateSrPucchResourceIndex(
            ulUEInfo_p->srPucchResourceIndex
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }

    ulUEInfo_p->srConfigurationIndex =  *msg_p++;

    resp = validateSrConfigurationIndex(
            ulUEInfo_p->srConfigurationIndex 
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }

    *len_p = len;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigSRProhibitTimerV920Info 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the SR Prohibit Timer V920 information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigSRProhibitTimerV920Info (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if (SR_PROHIBIT_TIMER_TAG_LEN != len)
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ueIdx,len,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SR_PROHIBIT_TIMER_V920_INVALID_TAGLEN");         
        return MAC_FAILURE;
    }

    ulUEInfo_p->srProhibitTimerValv920 = *(*msgBuf)++;
    if (MAC_MAX_SR_PROHIBIT_TIMER_VAL < 
            ulUEInfo_p->srProhibitTimerValv920)
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ueIdx,
                ulUEInfo_p->srProhibitTimerValv920,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                "SR_PROHIBIT_TIMER_V920_INVALID_VALUE");         
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigUECategoryInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  tagLen     - 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UE Category information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigUECategoryInfo (UInt8 **msgBuf, 
        UInt16               len,
        UInt16               tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        )
{
    /* Rel 5.3: Coverity 32227 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32227 Fix End */
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_UE_CATEGORY;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=UL_RECONFIG_UE_CATEGORY;
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

    if ( len != UE_CATEGORY_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for UE_CATEGORY  Info\n"
                ,tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for UE_CATEGORY  Info");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    dlUEInfo_p->ueCategory = *(*msgBuf)++;
    /* ULA_CHG */
    ulUEInfo_p->ueCategory = dlUEInfo_p->ueCategory;
    /* ULA_CHG */
    resp = validateUeCategory(dlUEInfo_p->ueCategory
            /* CA changes Start */
            , internalCellIndex
            /* CA Changes end */
            );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    /* 4X4 DL MIMO CHG START */
    if (MAC_SUCCESS !=
            validateNumOfLayer(dlUEInfo_p->rankIndicator,dlUEInfo_p->ueCategory,
                internalCellIndex))
    {     /* Coverity 55812  */   
        return MAC_SYNTAX_ERROR_VAL;
        /* Coverity 55812  */      
    }
    /* 4X4 DL MIMO CHG END */
    /*SPR 3600 Start*/
    /* Cyclomatic_complexity_changes_start */
    getUlModSchemeFromMcsIndex(ulUEInfo_p->mcsIndex, \
            &(ulUEInfo_p->modScheme), cellParams_p->macEnable64QAM, ulUEInfo_p->ueCategory);
    /* Cyclomatic_complexity_changes_end */
    /*SPR 3600 End*/

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigDrxConfigInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the DRX Config information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigDrxConfigInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    UInt16 resp = MAC_SUCCESS;
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf; 

    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_DRX_CONFIG_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,dlUEInfo_p->ueIndex,DRX_CONFIG_INFO,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "DRX_TAG_RECEIVED_DURING_RECONFIG");

    resp =  parseDRXConfigInfo(&msg_p, /* REL_3.0_INTEG_CHG */
            len,
            dlUEInfo_p
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );
    if( MAC_FAILURE == resp )
    {    
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlUEInfo_p->ueIndex,
                DRX_CONFIG_INFO,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "DRX_PARSE_FAIL_DURING_RECONFIG.");

        return  MAC_FAILURE;
    }
    dlUEInfo_p->drxRequestType = TRUE;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigMeasGapConfigInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Meas Gap Config information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigMeasGapConfigInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    UInt16 resp = MAC_SUCCESS;
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf; 

    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_MEAS_GAP_CONFIG_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    LOG_MAC_MSG(MAC_TAG_RECEIVED_ID,LOGDEBUG,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            LINE_NUMBER,dlUEInfo_p->ueIndex,MEAS_GAP_CONFIG_INFO,
            internalCellIndex,DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,
            "MEASGAP_TAG_RECEIVED_DURING_RECONFIG");

    resp =  parseMeasGapConfigInfo(&msg_p, /* REL_3.0_INTEG_CHG */
            len,
            dlUEInfo_p
            /* CA changes Start */
            ,internalCellIndex
            /* CA Changes end */
            );             
    if( MAC_FAILURE == resp )
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlUEInfo_p->ueIndex,
                MEAS_GAP_CONFIG_INFO,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "MEASGAP_PARSE_FAIL_DURING_RECONFIG");
        return  MAC_FAILURE;
    }
    dlUEInfo_p->measGapRequestType = TRUE;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigTimerAlignTimerInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  tag - tag of incoming message
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the Timer Alignment Timer information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigTimerAlignTimerInfo (UInt8 **msgBuf, 
        UInt16               len,
        UInt16               tag,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf; 

    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_TIME_ALIGNMENT_TIMER_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    UInt16 timeAlignmentTimer = 0;
    if(len != TIME_ALIGNMENT_TIMER_INFO_LEN)
    {
        LOG_MAC_MSG(MAC_INAVLID_TAG_MSG_ID, LOGWARNING, MAC_RRC_INF, 
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),tag,len,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_TAG_LEN");
        return MAC_FAILURE;
    }
    timeAlignmentTimer = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    if(MAC_FAILURE ==
            validateTimeAlignmentTimer(timeAlignmentTimer))
    {
        LOG_MAC_MSG(MAC_INVALID_TA_ULSYNC_TIMER_VAL, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),timeAlignmentTimer, dlUEInfo_p->timeAlignmentTimer,
                internalCellIndex,DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "INVALID_TIME_ALIGNMENT_TIMER_VAL");
        return MAC_FAILURE;
    }
    /*SPR_3061_FIX*/
    /*Cov 87049 +*/
    dlUEInfo_p->timeAlignmentTimer = 
        convertTATimerInMs(timeAlignmentTimer); 

    LOG_MAC_MSG(MAC_TIMEALIGNMENT_ULSYNC_TIMER_VAL, LOGINFO, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),timeAlignmentTimer, dlUEInfo_p->timeAlignmentTimer,
            internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "TIME_ALIGNMENT_TIMER_VAL");

    /*SPR_3061_FIX*/
    /*Cov 87049 -*/
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigPdcshConfigInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PDSCH Config information 
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigPdcshConfigInfo (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,DLReconfigUeReq     *dlReconfigUeReq_p
        )
{
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_PDSCH_CONFIG_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
    if(len != (PDSCH_CONFIG_INFO_PARAM_LENGTH + TAG_LEN))
    {
        return MAC_FAILURE;
    }
    dlUEInfo_p->isPAPresent = TRUE;
    dlUEInfo_p->pA = *(*msgBuf)++;
    if(MAX_PA_VALUE < dlUEInfo_p->pA)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE,PDSCH_CONFIG_INFO,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PDSCH_CONFIG_INFO.");
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigP0UEPusch 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len    - length of the API message received.
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the P0 UE PUSCH information 
 *                  and updates the UL structure for UE context
 *                  reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigP0UEPusch (UInt8 **msgBuf, 
        UInt16               len,
        UeContextForUplink   *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        )
{
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=UL_RECONFIG_P0_UE_PUSCH;
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
    if(len != P0_UE_PUSCH_LEN)
    {
        return MAC_FAILURE;
    }
    ulUEInfo_p->isDedicatedULPowerControlInfoPresent = TRUE;
    ulUEInfo_p->dedicatedULPowerControlInfo.p0UePusch = *(*msgBuf)++;
    if((MIN_P0_UE_PUSCH_VALUE > 
                ulUEInfo_p->dedicatedULPowerControlInfo.p0UePusch)||
            (MAX_P0_UE_PUSCH_VALUE <
             ulUEInfo_p->dedicatedULPowerControlInfo.p0UePusch))
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE,P0_UE_PUSCH,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "P0_UE_PUSCH.");
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigTPCPdcchConfigPucch 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API buffer 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the TPC PDCCH Config PUCCH and updates 
 *                  the DL structure for UE context reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigTPCPdcchConfigPucch (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForDownlink *dlUEInfo_p,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        )
{
    /* Rel 5.3: Coverity 32237 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32237 Fix End */
    UInt8 *msg_p = PNULL;

    /*CLPC_CHG*/
    TpcPdcchConfig* tpcPdcchConf_p = PNULL;
    /*CLPC_CHG*/

    msg_p = *msgBuf;

    /*Checking if tagLen is minimum len
     * of TPC_PDCCH_CONFIG_PUCCH*/
    if(len < TPC_PDCCH_CONFIG_LENGTH)
    {
        return MAC_FAILURE;
    }
    dlUEInfo_p->isTpcPdcchConfigPucchPresent = TRUE;
    tpcPdcchConf_p = &(dlUEInfo_p->tpcPdcchConfigPucch);

    /* CLPC_REWORK CHG*/
    tpcPdcchConf_p->release = *msg_p++;
    if((FALSE != tpcPdcchConf_p->release) &&
            (TRUE != tpcPdcchConf_p->release))
    {
        lteWarning("Invalid release.Value =%d\n",
                tpcPdcchConf_p->release);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tpcPdcchConf_p->release,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tpcPdcch release");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    if(!tpcPdcchConf_p->release)
    {
        resp = parseTpcPdcchConfig(msg_p,
                len,
                tpcPdcchConf_p,
                FALSE,
                internalCellIndex);
    }
    /*Incrementing the Length of msg_p to next TAG*/
    /* SPR 3154 START */
    msg_p += (len - TAG_LEN - 1);
    /* SPR 3154 END */
    /* CLPC_REWORK_CHG END*/

    *msgBuf = msg_p;
    return resp;
}

/****************************************************************************
 * Function Name  : parseReconfigTPCPdcchConfigPusch 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API buffer 
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the TPC PDCCH Config PUSCH and updates 
 *                  the UL structure for UE context reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigTPCPdcchConfigPusch (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        )
{
    /* Rel 5.3: Coverity 32237 Fix Start */
    MacRetType resp = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32237 Fix End */
    UInt8 *msg_p = PNULL;

    /*CLPC_CHG*/
    TpcPdcchConfig* tpcPdcchConf_p = PNULL;
    /*CLPC_CHG*/

    msg_p = *msgBuf;

    /*Checking if tagLen is minimum len
     * of TPC_PDCCH_CONFIG_PUCCH*/
    if(len < TPC_PDCCH_CONFIG_LENGTH)
    {
        return MAC_FAILURE;
    }
    ulUEInfo_p->isTpcPdcchConfigPuschPresent = TRUE;
    tpcPdcchConf_p = &(ulUEInfo_p->tpcPdcchConfigPusch);

    /* CLPC_REWORK CHG*/
    tpcPdcchConf_p->release = *msg_p++;
    if((FALSE != tpcPdcchConf_p->release) &&
            (TRUE != tpcPdcchConf_p->release))
    {
        lteWarning("Invalid release.Value=%d\n",
                tpcPdcchConf_p->release);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tpcPdcchConf_p->release,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tpcPdcch release");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    if(!tpcPdcchConf_p->release)
    {
        resp = parseTpcPdcchConfig(msg_p,
                len,
                tpcPdcchConf_p,
                TRUE,
                internalCellIndex);
    }
    /*Incrementing the Length of msg_p to next TAG*/
    /* SPR 3154 START */
    msg_p += (len - TAG_LEN - 1);
    /* SPR 3154 END */
    /* CLPC_REWORK_CHG END*/

    *msgBuf = msg_p;
    return resp;
}

/****************************************************************************
 * Function Name  : parseUECapAdditionalParams 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API buffer 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse UE Capability additional parameters
 *                  and updates DL structure for UE context at MAC.
 *****************************************************************************/
STATIC  MacRetType parseUECapAdditionalParams (UInt8 **msgBuf, 
        UInt16                len,
        UeContextForDownlink *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if ( UE_CAPABILITY_TAG_LENGTH != len )
    {
        lteWarning ("Invalid Tag Length for UE_CAPABILITY_ADDITIONAL_PARAMETERS INFO");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for UE_CAPABILITY_ADDITIONAL_PARAMETERS INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    dlUEInfo_p->Rat1Support = *(*msgBuf)++;

    /* SPR 18709 Fix Start*/
    if((dlUEInfo_p->Rat1Support!=TRUE) && (dlUEInfo_p->Rat1Support!= FALSE))
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->Rat1Support,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid RAT1 Support Value");
        return MAC_FAILURE;
    }
    /* SPR 18709 Fix End*/

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigRFParams 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API buffer 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - Pointer to downlink UE Reconfigure Request
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse RF PARAMS and updates 
 *                  the UL and DL structure for UE context reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigRFParams (UInt8 **msgBuf, 
        UInt16                len,
        UeContextForDownlink  *dlUEInfo_p,
        /* +- SPR 17777 */
        /* CA changes Start */
        InternalCellIndex internalCellIndex
        /* CA Changes end */
#ifdef HD_FDD_CONFIG
        ,UeContextForUplink    *ulUEInfo_p
        ,DLReconfigUeReq   *dlReconfigUeReq_p
        ,ULReconfigUeReq   *ulReconfigUeReq_p
#endif
        /* +- SPR 17777 */
        )
{
    /*HD FDD Changes Start*/
#ifdef HD_FDD_CONFIG
    UInt8 hdFddFlag = FALSE;
#endif
    /*HD FDD Changes End*/
    if(len != RF_PARAMS_LEN)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,dlUEInfo_p->ueIndex,RF_PARAMS,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "RF_PARAMS_INVALID_LENGTH");
        return MAC_FAILURE;
    }
#ifdef HD_FDD_CONFIG
    hdFddFlag = *(*msgBuf)++;
    /* The flag should be either TRUE or FALSE */
    if((hdFddFlag!=TRUE) && (hdFddFlag!= FALSE))
    {
        LOG_MAC_MSG(MAC_HD_FDD_INVALID_FLAG,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),hdFddFlag,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "Invalid Flag received in reconfig UE");
        return MAC_FAILURE;
    }
    dlUEInfo_p->isHDFddFlag = hdFddFlag;
    ulUEInfo_p->isHDFddFlag = hdFddFlag;

    /* In case of UL/DL running different, store the received HDFDD flag which
     * will be updated in other operations for both UL and DL UE Context */
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount]=UL_RECONFIG_RF_PARAMS;
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=DL_RECONFIG_RF_PARAMS;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;
#else
    /* SPR_10112_FIX_START */
    (*msgBuf) += 1;
    /* SPR_10112_FIX_END */
#endif

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigPHRTimerConfig 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  tagLen - Tag Length 
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PHT Timer config and updates 
 *                  the UL structure for UE context reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigPHRTimerConfig (UInt8 **msgBuf, 
        /* +- SPR 17777 */
        UeContextForUplink *ulUEInfo_p
        )
{
    UInt16 tag = 0;
    UInt16 resp = MAC_SUCCESS;
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf;

    if (1 == *msg_p++)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        msg_p += 2;

        if (tag != PHR_TIMER_INFO)
        {
            return MAC_FAILURE;
        } 
        resp = parsePHRTimerConfig(&msg_p,
                /* +- SPR 17777 */
                ulUEInfo_p);
        if(MAC_FAILURE == resp)
        {
            return MAC_FAILURE;
        }
    }
    else
    {
        ulUEInfo_p->phrGrant = INVALID_PHR_GRANT;
        ulUEInfo_p->phrTimerCfg.periodicPHRTimer = 0;
        ulUEInfo_p->phrTimerCfg.prohibitPHRTimer = 0;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseReconfigUEComplianceRel 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UE Compliance Release config and 
 *                  updates the UL structure for UE context reconfiguration 
 *                  at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigUEComplianceRel (UInt8 **msgBuf, 
        UInt16             len,
        UInt16             tagLen,
        UeContextForUplink *ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if ( len != UE_COMPLIANCE_RELEASE_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for \
                UE_COMPLIANCE_RELEASE\n",tagLen);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                tagLen, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for UE_COMPLIANCE_RELEASE");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->ueComplianceRelease = *(*msgBuf)++;
    if((RELEASE_8 != ulUEInfo_p->ueComplianceRelease) &&
            (RELEASE_9 != ulUEInfo_p->ueComplianceRelease) &&
            (RELEASE_10 != ulUEInfo_p->ueComplianceRelease) 
     ) 
    {
        lteWarning("Invalid release recd from L3.....Value=%d\n",
                ulUEInfo_p->ueComplianceRelease);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ueComplianceRelease,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid release recd from L3");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name  : parseReconfigTTIBundlingInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the TTIBundling Info and 
 *                  updates the UL structure for UE context reconfiguration 
 *                  at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigTTIBundlingInfo (UInt8 **msgBuf, 
        /* +- SPR 17777 */
        UInt16             len
        /*SPR21501 fix start*/
        ,UeContextForUplink *ulUEInfo_p
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        /*SPR21501 fix end*/
        ,InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        )
{
    if (TTI_BUNDLING_INFO_TAG_LEN != len )
    {
        lteWarning("Invalid Tag Length %d for TTI_BUNDLING_Info\n"
                ,len);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for TTI_BUNDLING_Info");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* TTIB_Code Start */                    

    /*SPR21501 fix start*/
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount] = UL_RECONFIG_TTI_BUNDLING;
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

    ulUEInfo_p->ttiBundlingEnabled  = *(*msgBuf)++;

    if ((ulUEInfo_p->ttiBundlingEnabled  != TTIB_DISABLED) &&
            (ulUEInfo_p->ttiBundlingEnabled  != TTIB_ENABLED))
    {
        lteWarning("Invalid value for ttiBundling  %d.\n"
                ,ulUEInfo_p->ttiBundlingEnabled );
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ttiBundlingEnabled,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for ttiBundling");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* TTIB_Code End */
    /*SPR21501 fix end*/

    return MAC_SUCCESS;
    /* TTIB_Code End */                    
}

/****************************************************************************
 * Function Name  : parseReconfigPdschEpreToUeRsRatio 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PDSCH EPRE/RS pwer of  ratio Info and 
 *                  updates the DL structure for UE context reconfiguration 
 *                  at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigPdschEpreToUeRsRatio (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForDownlink  *dlUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    if ( len != PDSCH_EPRE_TO_UE_RS_RATIO_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for PDSCH_EPRE_TO_UE_RS_RATIO\n"
                ,len);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for PDSCH_EPRE_TO_UE_RS_RATIO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    dlUEInfo_p->pdschEpreToUeRsRatio = *(*msgBuf)++;
    if((dlUEInfo_p->pdschEpreToUeRsRatio > 3)||(dlUEInfo_p->pdschEpreToUeRsRatio < -6))
    {
        lteWarning("Invalid Tag value %d for PDSCH_EPRE_TO_UE_RS_RATIO\n"
                ,dlUEInfo_p->pdschEpreToUeRsRatio);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->pdschEpreToUeRsRatio,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag value for PDSCH_EPRE_TO_UE_RS_RATIO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;

}

/*REL10_CR_CHANGES_START*/
/****************************************************************************
 * Function Name  : parseReconfigMaxUlHarqTxInfo
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UL HARQ TX Info and 
 *                  updates the UL structure for UE context reconfiguration 
 *                  at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigMaxUlHarqTxInfo (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink * ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        )

{
    /*Cov 87047 +*/
    if( len != MAX_UL_HARQ_TX_INFO_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for MAX_UL_HARQ_TX_INFO\n"
                ,len);
        /* Review comment fix start RJ13 */
        LOG_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "MAC_PARSING_ERROR:Invalid Tag Length for MAX_UL_HARQ_TX_INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->maxUlHARQTx = *(*msgBuf)++;
    if(MAC_SUCCESS != validateMaxUlHarqTx(ulUEInfo_p->maxUlHARQTx
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                ))
    {
        lteWarning("Invalid value for max UL HARQ retransmission count .\n");
        /* Review comment fix start RJ13 */
        LOG_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->maxUlHARQTx,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "MAC_PARSING_ERROR:Invalid value for max UL HARQ retransmission count");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->maxUlHARQTx
        = convertMaxUlHarqEnumInVal(ulUEInfo_p->maxUlHARQTx);

    /* + Coverity 54153 */
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount] = UL_RECONFIG_MAX_UL_HARQ_TX_INFO;
    /* - Coverity 54153 */
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

    return MAC_SUCCESS;
    /*Cov 87047 - */
}

/****************************************************************************
 * Function Name  : parseReconfigPcMaxInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PC MAX Info and 
 *                  updates the UL structure for UE context reconfiguration 
 *                  at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigPcMaxInfo (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink * ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        )
{
    if ( len != PC_MAX_INFO_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for PC_MAX_INFO\n"
                ,len);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for PC_MAX_INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->pcMax = *(*msgBuf)++;
    /*Checking range for pcMax*/
    if((MIN_PC_MAX > ulUEInfo_p->pcMax)||
            (MAX_PC_MAX < ulUEInfo_p->pcMax))
    {
        lteWarning("Invalid value for pcMax\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->pcMax,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for pcMax");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    /* + coverity 54154 */
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount] = UL_RECONFIG_PC_MAX_INFO;
    /* - coverity 54154 */
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
    return MAC_SUCCESS;

}

/****************************************************************************
 * Function Name  : parseReconfigPuschConfigInfo 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 *                  internalCellIndex - cell index used at MAC
 *                  ulReconfigUeReq_p - Pointer to uplink UE Reconfigure Request
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the PUSCH Configuration Info and 
 *                  updates the UL structure for UE context reconfiguration 
 *                  at MAC.
 *****************************************************************************/
STATIC  MacRetType parseReconfigPuschConfigInfo (UInt8 **msgBuf, 
        UInt16             len,
        UeContextForUplink * ulUEInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        ,ULReconfigUeReq   *ulReconfigUeReq_p
        )
{
    if( len != PUSCH_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for PUSCH Info\n",len);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for PUSCH Info");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->betaOffsetAckIndex = *(*msgBuf)++;
    if (ulUEInfo_p->betaOffsetAckIndex >
            MAC_MAX_BETA_OFFSET_ACK_INDEX )
    {
        lteWarning("Invalid range for betaOffsetAckIndex [%d]\n",
                ulUEInfo_p->betaOffsetAckIndex);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->betaOffsetAckIndex,
                internalCellIndex ,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for betaOffsetAckIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->betaOffsetRiIndex = *(*msgBuf)++;
    if (ulUEInfo_p->betaOffsetRiIndex >
            MAC_MAX_BETA_OFFSET_RI_INDEX )
    {
        lteWarning("Invalid range for betaOffsetRiIndex [%d]\n",
                ulUEInfo_p->betaOffsetRiIndex);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF, 
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->betaOffsetRiIndex,
                internalCellIndex,  
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for betaOffsetRiIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->betaOffsetCQIIndex = *(*msgBuf)++;
    if (ulUEInfo_p->betaOffsetCQIIndex >
            MAC_MAX_BETA_OFFSET_CQI_INDEX )
    {
        lteWarning("Invalid range for betaOffsetCQIIndex [%d]\n",
                ulUEInfo_p->betaOffsetCQIIndex);
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->betaOffsetCQIIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for betaOffsetCQIIndex");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulUEInfo_p->puschConfigInfoFlag = TRUE;
    /* + Coverity 54155 */
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->ueReconfigMsgTlvCount] = UL_RECONFIG_PUSCH_CONFIG_INFO;
    /* - Coverity 54155 */
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;
    return MAC_SUCCESS;

}
/*REL10_CR_CHANGES_END*/

/* Cyclomatic Complexity changes - ends here */
/*SPR 21653 changes start*/
/*code removed*/
/*SPR 21653 changes end*/

/****************************************************************************
 * Function Name  : initAfterCellConfig
 * Inputs         : internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : The functions called from this function are the ones which
 *                  have dependency on successful cell configuration.
 *****************************************************************************/
/*CA Changes start*/
STATIC  void initAfterCellConfig(InternalCellIndex internalCellIndex)
{
    InitParams *initParams_p = cellSpecificParams_g.\
                               cellConfigAndInitParams_p[internalCellIndex]->initParams_p;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
/* + SPR 22954 fix*/
/* - SPR 22954 fix*/
    /*Funtion for initializing Resource Allocation Information*/
    initDlResInfo(internalCellIndex);
/*SPR 21653 changes start*/
/*code removed*/
/*SPR 21653 changes end*/
    /*init function call to initialise the PDCCH manager */ 
    initPDCCH(internalCellIndex);

    initPUCCH(internalCellIndex);

    /* SPR# 4813 Changes Starts */
    /*QOS_RB_RESTICTION_CHANGE*/
    initDlQosRbRestriction(internalCellIndex);
    initUlQosRbRestriction(internalCellIndex);
    /*QOS_RB_RESTICTION_CHANGE*/
    /* SPR# 4813 Changes Ends */
    /*init function call to initialise the RNTI pool and UE specific search space*/
    /*call this function after initPDCCH()*/
    /* + Coverity  24508 */
    if(MAC_FAILURE == initRNTIPoolTbl(initParams_p->maxNumOfUeSupported,
                internalCellIndex))
    {
        LOG_MAC_MSG(L2_GET_MEMFROMPOOL_FAIL_ID,LOGERROR,MAC_RACH,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__,
                sizeof(FreeRNTIPoolNode), internalCellIndex,0,0,
                0.0,0.0,__FILE__,__func__);
    }

    /* - Coverity  24508 */

    /* init function call to initialize the tpc rnti context, queues for power
       control of PUCCH and PUSCH */
    initTpcRntiContextForPusch(internalCellIndex);
    initTpcRntiContextForPucch(internalCellIndex);

    /* init function call to initialise the CCCH manager */
    initCCCHMgr(internalCellIndex);

    initCQI(internalCellIndex);
#ifdef PERF_STATS
    initPerfStatsPdcchPdschInfo(internalCellIndex);
#endif

    /* SPS_CHG */
    /*!
     * \code
     * If cellConfig_g is configred with SPS Crnti
     *    - Initializing the SpsCrnti MAP 
     * Initialize initSpsTTIContextMap.
     * \endcode
     * */
    /* Dynamic PDCCH + 5117 changes starts*/
    calculateMCSRBForCodeRateUECategory(internalCellIndex);
    /* Dynamic PDCCH + 5117 changes ends*/
    /*SPR 8451 Changes Start*/
#ifdef ULCODERATE_PLUGIN
    calculateUlMCSRBForCodeRateUECategory(internalCellIndex);
#endif
    /*SPR 8451 Changes End*/
    if(TRUE == initParams_p->spsSysWideParam.enableSps)
    {
        if(((cellParams_p->spsCommonCellInfo.startSpsCRnti >= MIN_SPS_RNTI_VALUE) && 
                    (cellParams_p->spsCommonCellInfo.startSpsCRnti <= MAX_SPS_RNTI_VALUE)) && 
                ((cellParams_p->spsCommonCellInfo.endSpsCRnti >= MIN_SPS_RNTI_VALUE) && 
                 (cellParams_p->spsCommonCellInfo.endSpsCRnti <= MAX_SPS_RNTI_VALUE)))
        {
            initializeSpsCrntiMap(
                    cellParams_p->spsCommonCellInfo.startSpsCRnti,
                    cellParams_p->spsCommonCellInfo.endSpsCRnti
                    /* CA changes Start */
                    ,internalCellIndex
                    /* CA Changes end */
                    );
        }
        initDLSpsTTIContextMap(MAX_SPS_INTERVAL,internalCellIndex);
        /* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
        initULSpsTTIContextMap(MAX_SPS_INTERVAL,internalCellIndex);
#elif TDD_CONFIG
        initULSpsTTIContextMap(MAX_UL_SPS_INTERVAL,internalCellIndex);
#endif
        /* - SPS_TDD_Changes */
    }

    /* SPS_CHG */
}
/*spr 13127 fix start*/
/*****************************************************************************
 * Function Name  : macDeleteScellCtxt
 * Inputs         : Internal cell index
 * w
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    :Deallocates the memory pointed by data nodes in MAC
 *                    This function is called at cell delete  of ue's scell,
 *                    or cell stop/delete of UE's PCELL
 *****************************************************************************/
void macDeleteScellCtxt(DLUEContext *ueDLContext_p, InternalCellIndex internalCellIndex)
{
    UInt8 index = 0;
    for (index = MAX_NUM_PCELL; index <= MAX_NUM_SCELL; index++)
    {
        if ( (ueDLContext_p->dlUeScellContext_p[index] != PNULL) && 
                (ueDLContext_p->dlUeScellContext_p[index]->internalCellIndex == internalCellIndex) )
        {
            /* Mem-Leak Changes Start */
            /* Free the Timer Nodes from S-Cell context */
            scellStateMngrFreeAllUeScellTimerNode(ueDLContext_p->ueIndex, index);
            /* Mem-Leak Changes End */
            if (MAC_FAILURE == macDeleteScellMACDLHarqEntity(ueDLContext_p,
                        index, internalCellIndex))
            {
                LOG_MAC_MSG(MAC_UEHARQCONTEXT_NOT_FOUND_ID,
                        LOGERROR,
                        MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ueDLContext_p->ueIndex,
                        LINE_NUMBER,
                        DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "MAC_UEHARQCONTEXT_NOT_FOUND for Scell");
                return;
            }

            if(PNULL != ueDLContext_p->dlUeScellContext_p[index]->ScelldlCQIInfo.
                    subBandReportInfo_p)
            {
                freeMemPool(ueDLContext_p->dlUeScellContext_p[index]->\
                        ScelldlCQIInfo.subBandReportInfo_p);
                ueDLContext_p->dlUeScellContext_p[index]->ScelldlCQIInfo.\
                    subBandReportInfo_p = PNULL;
            }
            freeMemPool(ueDLContext_p->dlUeScellContext_p[index]);
            ueDLContext_p->dlUeScellContext_p[index] = PNULL;
            /* CA changes Start */
            deleteUlUeScellContext(ulUECtxInfoArr_g[ueDLContext_p->ueIndex].ulUEContext_p);
            /* CA changes End */
        }
    }
}
/*spr 13127 fix end*/

/*****************************************************************************
 * Function Name  : macStopReqFreeMemToPools
 * Inputs         : Internal cell index
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    :Deallocates the memory pointed by data nodes in MAC
 *                    This function is called at cell stop
 *****************************************************************************/
MacRetType macStopReqFreeMemToPools(UInt16 msgId, InternalCellIndex internalCellIndex)
{
    /* SPR 12283 Fix Start */
    cleanUpUEContext(msgId, internalCellIndex );
    /* SPR 12283 Fix End */
    /* +- SPR 17777 */

    cleanupPDCCH(internalCellIndex);

    cleanupPUCCH(internalCellIndex);

    cleanupDLSchedulerStrategy(internalCellIndex);

    cleanupULSchedulerStrategy(internalCellIndex);

    cleanupPCCHMgr(internalCellIndex);

    cleanupRACHMgr(internalCellIndex);
    cleanupRNTIPoolTbl(internalCellIndex);
    cleanupCCCHMgr(internalCellIndex);
    cleanupCQI(internalCellIndex);
    /* Mem Leak Changes Start */
    cleanupTimingAdvanceMgr(internalCellIndex);
    /* Mem Leak Changes End */
    /* + SPS_TDD_Changes */
    /* +- SPR 18613 */
    /* - SPS_TDD_Changes */
    cleanupSRSMgr(internalCellIndex);
    /* +- SPR 17777 */
    cleanupUEConfMgr(internalCellIndex);
    cleanupUlSchUciRachContainer(internalCellIndex);

    cleanupPRSMgr(cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellParams_p->prsConfigInfo.dlPRSMapIndex, internalCellIndex);

    cleanupMacRRMInterface(internalCellIndex);

    /* - SPR_10891 */
    cleanupTpcRntiContextForPucch(internalCellIndex);
    cleanupTpcRntiContextForPusch(internalCellIndex);
    /* Rel 5.3.1: Memory related changes end*/

    /* +- SPR 17777 */
    /* Remove the entries from pending queue */
    rrcMsgFreePendingQueue(internalCellIndex);
    /* Reset the state machine with L3 interface */
    rrcMsgResetStateMachine(internalCellIndex);
    /* Free the request message buffer to HP Thread */
    rrcFreeReqBuffer(internalCellIndex);

    /* SPR 22578 fix start*/
    /* SPR 22578 fix end*/

    return MAC_SUCCESS;
}

/*****************************************************************************
 * Function Name  : macDeleteReqFreeMemToPools
 * Inputs         : msgId
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : deallocates the memory data node in CirQueue also DeInit CirQueue
 *                    This function is called at cell delete.
 *****************************************************************************/
MacRetType macDeleteReqFreeMemToPools(UInt16 msgId,
        InternalCellIndex internalCellIndex)
{
    /* delete the node datas in Queues, same function as called at cell stop */
    macStopReqFreeMemToPools(msgId, internalCellIndex);

    /* Delete the memory allocated for Queues/globals */
    deInitDlResInfo(internalCellIndex);

    /* DeInit the CirQueues */
    deInitPDCCH(internalCellIndex);

    deInitPUCCH(internalCellIndex);

    deInitCCCHMgr(internalCellIndex);

    deInitCQI(internalCellIndex);

    deInitPCCHMgr(internalCellIndex);

    deInitRNTIPoolTbl(internalCellIndex);

    /* Rel 5.3.1: Memory related changes start*/
    /*cleanup memory taken for contention free rach*/
    cleanpContentionFreeRACHPool(internalCellIndex);
    deInitTokenPeriodicityArray(internalCellIndex);
    deInitTpcRntiContextForPusch(internalCellIndex);
    deInitTpcRntiContextForPucch(internalCellIndex);
    /* Rel 5.3.1: Memory related changes end*/

    deInitSRSMgr(internalCellIndex);

    cleanupBCCHMgr(internalCellIndex);
    /*SPR 11109 fix start */
    deInitUlResInfo (internalCellIndex);
    /*SPR 11109 fix end */

    /* +- SPR 18613 */
    if(TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
            [internalCellIndex]->initParams_p->spsSysWideParam.enableSps)
    {
        /*<!-CSR 51542 CHANGE START-!>*/
        deInitAfterCellDeleteDL(MAX_SPS_INTERVAL, internalCellIndex);
        /* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
        deInitAfterCellDeleteUL(MAX_SPS_INTERVAL, internalCellIndex);
#elif TDD_CONFIG
        deInitAfterCellDeleteUL(MAX_UL_SPS_INTERVAL, internalCellIndex);
#endif
    }
    /* +- SPR 18613 */
    /* - SPS_TDD_Changes */
    /*<!-CSR 51542 CHANGE END-!>*/
#ifdef LTE_EMBMS_SUPPORTED
    sendCleanUpRequestToSync(internalCellIndex);
    cleanUpEmbmsData(internalCellIndex);
#endif
    /* SPR 22578 fix start*/
    /* SPR 22578 fix end*/
    return MAC_SUCCESS;
}
/* CA Changes end */

/* + CL-MIMO LJA*/
/****************************************************************************
 * Function Name  : validateCBSR
 * Inputs         : cbsrInfo - cbsrInfo received from RRC 
 *                  TnsmissionMode -ransmission mode configured
 *                  rankIndicator - RI value
 *                  internalCellIndex - cell index used at MAC
 * Outputs       : Whether codebookSubsetRestriction is correctly applied or not
 * Returns       : Succes or failure
 * Description  : This function checks whether at least one of the relevant bits of cbsrValue is 
 *                      one or not. For TM3, MSB two bits are checked. For TM4, MSB 6 bits are checked.
 *                      Reference 36.331.
 *****************************************************************************/
STATIC  MacRetType validateCBSR( 
        codebookSubsetRestrictionInfo *cbsrInfo, 
        UInt8 transmissionMode,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex)
{
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    /* According to Table 7.2-1b of 36.213 */
    if (TX_MODE_3 == transmissionMode)
    {   /*4x4 DL MIMO CHG START*/
        /* Any 1 of the first 4 bit of CBSR denoting rank 1/2/3/4 should be set to 1 for 4x4 MIMO */
        /* Any 1 bit of the first 2 bit of CBSR denoting rank 3/4 should be set to 1 for 4x2 MIMO */
        /* The next 2 bit denotes rank 1/2, atleast one of those 2 bit should be set */
        /* SPR 12240 Changes Start */
        if((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_4 ) &&
                (0 == (cbsrInfo->cbsrValue[0]&0xF0)))
        {
            return MAC_FAILURE;
        }
        /*4x4 DL MIMO CHG END*/
        /* SPR 12240 Changes End */
        else if( (cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_2 )&& \
                (0 == (cbsrInfo->cbsrValue[0]&0xC0)) )
        {
            /*At least 1 of MSB two bits is not 1, so returning failure*/
            return MAC_FAILURE;
        }
    }
    else if((TX_MODE_4 == transmissionMode))
    {    
        /*4x4 DL MIMO CHG START*/
        /* SPR 12240 Changes Start */
        /* Any 1 bit of the first 8 bytes in CBSR for 4x4 MIMO should always set to 1 */
        /* Any 1 bit of the last 4 bytes in CBSR for 4x2 MIMO should always set to 1 */
        /* the last 4 bytes denotes the rank 1 and 2 related PMI support, so 
         * atleast one bit indicating PMI support should be set */
        if((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_4) &&
                ((0 == cbsrInfo->cbsrValue[0])&&(0 == cbsrInfo->cbsrValue[1])&&
                 (0 == cbsrInfo->cbsrValue[2])&&(0 == cbsrInfo->cbsrValue[3])&&
                 (0 == cbsrInfo->cbsrValue[4])&&(0 == cbsrInfo->cbsrValue[5])&&
                 (0 == cbsrInfo->cbsrValue[6])&&(0 == cbsrInfo->cbsrValue[7])))
        {
            return MAC_FAILURE;
        } 
        /* SPR 12240 Changes End */
        /*4x4 DL MIMO CHG END*/
        else if((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_2 )&& 
                (0 == (cbsrInfo->cbsrValue[0]&0xFC)))
        {
            /*At least 1 of last six bits is not 1, so returning failure*/
            return MAC_FAILURE;
        }
    }
    /* + TM6_5.2 */
    else if(TX_MODE_6 == transmissionMode)
    {
        if((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_2 )&& \
                (0 == (cbsrInfo->cbsrValue[0]&0xF0)))
        {
            return MAC_FAILURE;
        }
        /* As TM6 mode supports single layer transmission, all 16 bits in CBSR can be set */
        else if( (cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_4)&&
                ((0x00 == (cbsrInfo->cbsrValue[0])) &&
                 (0x00 == (cbsrInfo->cbsrValue[1]))) )
        {
            return MAC_FAILURE;
        }
    }
    /* SPR 12240 Changes Start */
    else if(TX_MODE_8 == transmissionMode)
    {
        if((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_2) && 
                (0 == (cbsrInfo->cbsrValue[0]&0xFC)))
        {
            /*At least 1 of last six bits is not 1, so returning failure*/
            return MAC_FAILURE;
        }
        else if((cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_4) && 
                ((0 == (cbsrInfo->cbsrValue[0]))&&(0 == (cbsrInfo->cbsrValue[1]))&&
                 (0 == (cbsrInfo->cbsrValue[2]))&&(0 == (cbsrInfo->cbsrValue[3]))))
        {
            return MAC_FAILURE;
        }
    }
    /* SPR 12240 Changes End */
    /* - TM6_5.2 */
    return MAC_SUCCESS;
}
/* - CL-MIMO LJA*/

/* + DRX_CHG */
/****************************************************************************
 *  Function Name : parseDRXConfigInfo 
 *  Inputs        : *message_pp - Pointer to the data received from RRC
 *                  tagLength - tag length of the DRX_CONFIG_INFO
 *                  *dlCreateRequest_p - Pointer to UE context for downlink 
 *                                      where information is stored after 
 *                                      buffer parsing
 *                  internalCellIndex - cell index used at MAC
 *  Outputs       : Parsed parameters get stored
 *  Returns       : MacRetType
 *  Description   : This function check for the parameters from the RRC and 
 *                      stored in the UeContextForDownlink structure
 *
 ******************************************************************************/

STATIC  MacRetType parseDRXConfigInfo(UInt8 **message_pp, /* REL_3.0_INTEG_CHG */
        UInt16 tagLength,       
        UeContextForDownlink *dlCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{ 

    UInt16 tag = 0;
    UInt8  *msg_p = *message_pp;
    UInt16 tagLen = tagLength;
    UInt16 remLength = tagLength;
    UInt8  drxOnDurationTimerIndex = 0;  
    UInt8  drxInactivityTimerIndex = 0;
    UInt8  drxRetransmissionTimerIndex  = 0;
    UInt8  shortDRXCycleIndex = 0;
    UInt8  longDRXCycleIndex = 0;
    UInt8  drxShortCycleTimer = 0;
    UInt8  drxOnDurationTimer = 0;
    UInt16 longDRXCycle = 0;
    UInt16 shortDRXCycle = 0;
    UInt16 drxStartOffset = 0;
    dlCreateRequest_p->drxConfig.isDRXShortCycleConfigured = FALSE;   
    /*START : DRX_MAC_CE*/
    UInt16 drxMacCeTimer  = 0;
    UInt16 drxMacCeCmdThreshold = 0;
    /*END   : DRX_MAC_CE*/

    if ( DRX_CONFIG_TAG_MIN_VALUE  > tagLen || 
            DRX_CONFIG_TAG_MAX_VALUE < tagLen )
    {        
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "DRX_CONFIG_INFO_INVALID_TAGLEN");         

        return MAC_FAILURE;
    } 

    dlCreateRequest_p->drxConfigType = *msg_p;       
    if ( SETUP != dlCreateRequest_p->drxConfigType &&
            RELEASE != dlCreateRequest_p->drxConfigType )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateRequest_p->ueIndex,dlCreateRequest_p->drxConfigType,
                internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "DRX_INVALID_CONFIG_TYPE_RECEIVED");  

        return MAC_FAILURE;
    }        
    msg_p++;

    /* If DRXConfigType is SETUP then only DRX will be configured */ 
    if ( SETUP == dlCreateRequest_p->drxConfigType )
    {

        /* subtracting 5 from remaining Length  because of the 2 bytes of tag, 
         * 2 bytes of tagLength of DRX_CONFIG_INFO tag  and 1 byte of 
         * drxConfigType 
         */ 
        remLength -= 5;

        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;
        if ( DRX_SETUP_CONFIG_INFO == tag ) 
        {
            tagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;
            if ( DRX_SETUP_CONFIG_TAG_MIN_VALUE > tagLen || 
                    DRX_SETUP_CONFIG_TAG_MAX_VALUE  < tagLen )
            {                
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "DRX_SETUP_INVALID_TAGLEN_RECEIVED"); 

                return MAC_FAILURE;          
            }

            drxOnDurationTimerIndex = *msg_p;
            msg_p++;

            if ( MAX_DRX_ONDURATION_TIMER_VALUE < drxOnDurationTimerIndex ) 
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,drxOnDurationTimerIndex, 
                        internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "DRX_INVALID_ONDURATION_TIMER_VALUE"); 

                return MAC_FAILURE;
            }
            dlCreateRequest_p->drxConfig.drxOnDurationTimerIndex = 
                drxOnDurationTimerIndex;

            dlCreateRequest_p->drxConfig.drxOnDurationTimer =
                drxOnDurationTimerConfig_g[drxOnDurationTimerIndex];
            drxOnDurationTimer =  
                drxOnDurationTimerConfig_g[drxOnDurationTimerIndex];

            drxInactivityTimerIndex  = *msg_p;
            msg_p++;

            if ( MAX_DRX_INACTIVITY_TIMER_VALUE < drxInactivityTimerIndex )
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,drxInactivityTimerIndex ,
                        internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "DRX_INVALID_INACTIVITY_TIMER_VALUE"); 

                return MAC_FAILURE;
            }
            dlCreateRequest_p->drxConfig.drxInactivityTimerIndex =
                drxInactivityTimerIndex;
            dlCreateRequest_p->drxConfig.drxInactivityTimer =
                drxInactivityTimerConfig_g[drxInactivityTimerIndex];

            drxRetransmissionTimerIndex  =*msg_p;
            msg_p++;           

            if ( MAX_DRX_RETRANSMISSION_TIMER_VALUE <
                    drxRetransmissionTimerIndex ) 
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,drxRetransmissionTimerIndex,
                        internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "DRX_INVALID_RETRANSMISSION_TIMER");

                return MAC_FAILURE;
            } 
            dlCreateRequest_p->drxConfig.drxRetransmissionTimer =
                drxRetransmissionTimerConfig_g[drxRetransmissionTimerIndex];

            longDRXCycleIndex = *msg_p;
            msg_p++;

            if ( MAX_DRX_LONG_CYCLE_TIMER_VALUE < longDRXCycleIndex )
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,longDRXCycleIndex ,
                        internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "DRX_INVALID_LONGCYCLE_TIMER_VALUE"); 

                return MAC_FAILURE;
            }   
            dlCreateRequest_p->drxConfig.longDRXCycleIndex = longDRXCycleIndex;

            dlCreateRequest_p->drxConfig.longDRXCycle =
                drxLongCycleTimerConfig_g[longDRXCycleIndex];

            longDRXCycle = drxLongCycleTimerConfig_g[longDRXCycleIndex];

            drxStartOffset = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if ( longDRXCycle <= drxStartOffset )
            {               
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,drxStartOffset,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "DRX_INVALID_START_OFFSET_VALUE"); 

                return MAC_FAILURE;
            }
            dlCreateRequest_p->drxConfig.drxStartOffset = drxStartOffset;

            /* Subtracting 10 from remaining length because of 1 byte each for 
             * drxOnDurationTimer,drxInactivityTimer,drxRetransmissionTimer,
             * longCycleTimer and 2 byte each for DRX_SETUP_CONFIG_INFO tag ,
             * DRX_SETUP_CONFIG_INFO tagLength and drxStartOffset. 
             */

            remLength -= 10;
            /*START : DRX_MAC_CE*/    
            while(remLength)
            {
                /*END   : DRX_MAC_CE*/    
                tag = LTE_GET_U16BIT(msg_p);

                if ( SHORT_DRX_CONFIG == tag )
                {
                    msg_p += 2;
                    tagLen = LTE_GET_U16BIT(msg_p);
                    msg_p += 2;
                    remLength -= tagLen;

                    if ( DRX_SHORT_CONFIG_TAG_VALUE  != tagLen )
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SHORT_DRX_INVALID_TAGLEN_RECEIVED");

                        return MAC_FAILURE;
                    }

                    dlCreateRequest_p->drxConfig.isDRXShortCycleConfigured = TRUE;                   
                    shortDRXCycleIndex = *msg_p; 
                    msg_p++;       

                    if ( MAX_DRX_SHORT_CYCLE_TIMER_VALUE < shortDRXCycleIndex )
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,shortDRXCycleIndex,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                                "DRX_INVALID_SHORTCYCLE_TIMER_VALUE"); 

                        return MAC_FAILURE;
                    }
                    dlCreateRequest_p->drxConfig.shortDRXCycleIndex = 
                        shortDRXCycleIndex ;

                    dlCreateRequest_p->drxConfig.shortDRXCycle = 
                        drxShortCycleTimerConfig_g[shortDRXCycleIndex];
                    shortDRXCycle =  drxShortCycleTimerConfig_g[shortDRXCycleIndex];

                    drxShortCycleTimer = *msg_p;
                    msg_p++;
                    if ( ( DRX_SHORT_CYCLE_MIN_VALUE  > drxShortCycleTimer ) ||
                            ( DRX_SHORT_CYCLE_MAX_VALUE  < drxShortCycleTimer ) )
                    {            
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,drxShortCycleTimer,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                                "DRX_INVALID_SHORT_CYCLE_VALUE"); 

                        return MAC_FAILURE;
                    }
                    dlCreateRequest_p->drxConfig.drxShortCycleTimer =
                        drxShortCycleTimer;

                    if ( drxOnDurationTimer > shortDRXCycle )
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,drxOnDurationTimer,
                                internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "DRX_ONDURAION_TIMER_VALUE_MORE");

                        return MAC_FAILURE;
                    } 

                    if ( 0 != longDRXCycle % shortDRXCycle )
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,longDRXCycle,
                                internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "INVALID_CONFIGURATION");

                        return MAC_FAILURE;
                    }

                    /*START : DRX_MAC_CE*/    
                }else if (DRX_MAC_CE_CMD_TRIGGER_INFO == tag)
                {
                    msg_p += 2;
                    tagLen = LTE_GET_U16BIT(msg_p);
                    msg_p += 2;
                    /*Reducing the remLength with the tagLen received.*/
                    remLength -= tagLen;
                    if (DRX_MAC_CE_INFO_TAG_VALUE != tagLen)
                    {
                        /*Log_Msg*/
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "DRX_MAC_CE_CMD_TRIGGER_INFO_INVALID_TAGLEN_RECEIVED");
                        return MAC_FAILURE;
                    }
                    /*When this Tag is recieved then only 
                     *DRX_MAC_CE_CMD is considered as configured*/
                    dlCreateRequest_p->drxConfig.isdrxMacCeCmdConfigured = TRUE;
                    drxMacCeTimer = LTE_GET_U16BIT(msg_p);
                    msg_p += 2;
                    if(drxMacCeTimer < DRX_MAC_CE_TIMER_MIN_VALUE 
                            || drxMacCeTimer > DRX_MAC_CE_TIMER_MAX_VALUE)
                    {
                        /*Log_Msg*/
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,drxMacCeTimer,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                                "DRX_INVALID_MAC_CE_CMD_TIMER_VALUE"); 
                        return MAC_FAILURE;
                    }
                    dlCreateRequest_p->drxConfig.drxMacCeTimer = drxMacCeTimer;
                    drxMacCeCmdThreshold = LTE_GET_U16BIT(msg_p);
                    msg_p += 2;
                    if(drxMacCeCmdThreshold < DRX_MAC_CE_THRESH_MIN_VALUE 
                            || drxMacCeCmdThreshold > DRX_MAC_CE_THRESH_MAX_VALUE)
                    {
                        /*Log_Msg*/
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,drxMacCeCmdThreshold,
                                internalCellIndex,DEFAULT_INT_VALUE,
                                DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                                "DRX_INVALID_MAC_CE_THRESHOLD_VALUE"); 
                        return MAC_FAILURE;
                    }
                    dlCreateRequest_p->drxConfig.drxMacCeCmdThreshold = drxMacCeCmdThreshold;
                }
            }
            /*END   : DRX_MAC_CE*/    

            if ( drxOnDurationTimer > longDRXCycle )
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,drxOnDurationTimer,
                        internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "DRX_ONDURAION_TIMER_VALUE_MORE");

                return MAC_FAILURE;
            }

        }  
        else 
        {
            LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    LINE_NUMBER,dlCreateRequest_p->ueIndex,
                    DRX_SETUP_CONFIG_INFO,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "DRX_SETUP_CONFIG_NOT_RECIEVED");

            return MAC_FAILURE;
        }

    }

    *message_pp = msg_p; /* REL_3.0_INTEG_CHG */
    return MAC_SUCCESS;

}
/* - DRX_CHG */

/* + MEAS_GAP_CHG */
/****************************************************************************
 * Function Name : parseMeasGapConfigInfo
 * Inputs        : *message_pp - Pointer to the data received from RRC
 *                 tagLength - tag length of the MEAS_GAP_CONFIG_INFO
 *                 *dlCreateReq_p - Pointer to UE context for downlink 
 *                                  where information is stored after 
 *                                  buffer parsing.
 *                  internalCellIndex - cell index used at MAC
 * Outputs       : Parsed parameters get stored
 * Returns       : MacRetType
 * Description   : This function check for the parameters from the RRC and
 *                 stored in the UeContextForDownlink structure
 *
 *****************************************************************************/

STATIC  MacRetType parseMeasGapConfigInfo(UInt8 **message_pp, /* REL_3.0_INTEG_CHG */
        UInt16 tagLength,
        UeContextForDownlink *dlCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt16 tag    =  0;
    UInt8 *msg_p  =  *message_pp;
    UInt16 tagLen =  tagLength;
    UInt8 gapPatternId = 0;
    UInt8 gapOffset = 0;

    if ( MEAS_GAP_CONFIG_TAG_MIN_VALUE   > tagLen || 
            MEAS_GAP_CONFIG_TAG_MAX_VALUE < tagLen )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "MEAS_GAP_CONFIG_INVALID_TAGLEN");  

        return MAC_FAILURE;
    }

    dlCreateRequest_p->measGapConfigType = *msg_p;
    msg_p++;

    if ( SETUP != dlCreateRequest_p->measGapConfigType && 
            RELEASE != dlCreateRequest_p->measGapConfigType )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateRequest_p->ueIndex,
                dlCreateRequest_p->measGapConfigType,
                internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "MEAS_GAP_INVALID_CONFIG_TYPE");  

        return MAC_FAILURE;
    }

    if  ( SETUP == dlCreateRequest_p->measGapConfigType )
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += 2;

        if ( MEAS_GAP_SETUP_CONFIG_INFO == tag )
        {
            tagLen = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if ( MEAS_GAP_SETUP_TAG_VALUE  != tagLen )
            {                   
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,tagLen,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "MEAS_GAP_SETUP_INVALID_TAGLEN");  

                return MAC_FAILURE;
            }

            gapPatternId = *msg_p;
            msg_p ++;
            if ( (GP0 != gapPatternId) && (GP1 != gapPatternId) 
#ifdef ENDC_ENABLED
				/*Meas_Gap_Changes_Start*/
            	&& (GP11_R15 < gapPatternId)
            	/*Meas_Gap_Changes_End*/
#endif
            	)
            { 
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,gapPatternId,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "MEAS_GAP_INVALID_GAP_PATTERNID");  

                return MAC_FAILURE;

            }
            dlCreateRequest_p->measGapConfig.gapPatternId = gapPatternId;

            gapOffset = *msg_p;
            msg_p++;

            if((GP0 ==gapPatternId  && (gapOffset >
                            (MEASUREMENT_GAP_PERIODICITY_40 - 1))) ||
                    (GP1 == gapPatternId  && (gapOffset >
                                              (MEASUREMENT_GAP_PERIODICITY_80 - 1))))
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,gapOffset,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "MEAS_GAP_INVALID_GAP_OFFSET");  

                return MAC_FAILURE;
            }
#ifdef ENDC_ENABLED
			/*Meas_Gap_Changes_Start*/
			else if((GP4_R15 <= gapPatternId && GP11_R15 >= gapPatternId) 
				&&  (gapOffset > (MEASUREMENT_GAP_PERIODICITY_160 -1)))
			{
    			LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateRequest_p->ueIndex,gapOffset,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "MEAS_GAP_INVALID_GAP_OFFSET");  

                return MAC_FAILURE;

			}
			/*Meas_Gap_Changes_End*/
#endif
            dlCreateRequest_p->measGapConfig.gapOffset = gapOffset;
        }

        else 
        {
            LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    LINE_NUMBER,dlCreateRequest_p->ueIndex,
                    MEAS_GAP_SETUP_CONFIG_INFO,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "MEAS_SETUP_CONFIG_NOT_RECIEVED");

            return MAC_FAILURE;

        }
    }

    *message_pp = msg_p;  
    return MAC_SUCCESS;
}                               
/* -  MEAS_GAP_CHG */

/* FREQ_SELECTIVE CHG */
/****************************************************************************
 * Function Name  : validateFreqSelectiveEnable
 * Inputs         : freqSelective parameter
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE.
 * Description    : This API takes freqSelective value to validate and
 *                  return result of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType validateFreqSelectiveEnable(UInt8 freqSelective)
{
    /* Validation Check for frequency selective scheduling */
    if (freqSelective != FREQUENCY_SELECTIVE_ON &&
            freqSelective != FREQUENCY_SELECTIVE_OFF)
    {
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;
}
/* FREQ_SELECTIVE CHG */
/* ULA_CHG */
/****************************************************************************
 * Function Name  : parseQosInfo
 * Inputs         : msg_p - Buffer Received from RRC
 *                  origTagLen - length of the API message received
 *                  dlLcInfo_p - pointer to downlink create LC structure
 *                  ulLcInfo_p - pointer to uplink create LC structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  QoS structure needed by MAC for scheduling.
 ****************************************************************************/
STATIC  MacRetType parseQosInfo ( UInt8 **msg_p,
        UInt16 origTagLen,
        LogicalChannelConfigInfo* dlLcInfo_p,
        ulLogicalChannelInfo* ulLcInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    UInt16 tagLen = 0;
    UInt16 len = origTagLen;
    UInt16 tag; 
    UInt32 bearerType = 0;
    UInt8  qci = 0;

    if(len < QOS_INFO_MIN_LEN)
    {
        lteWarning("Mac syntax length error .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax length error");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }
    /*Decode QoS Info*/
    /*SPR 2834 Fix Begins*/
    bearerType = *(*msg_p)++;
    /*SPR 2834 Fix Ends*/
    ulLcInfo_p->channelType = bearerType;
    dlLcInfo_p->channelType = bearerType;

    qci = *(*msg_p)++;
    if(QOS_QCI_MIN_VAL > qci || QOS_QCI_MAX_VAL < qci)
    {
        lteWarning("Mac syntax qci val error .\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                qci,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mac syntax qci val error");
        /* Review comment fix end RJ13 */
        /* + coverity 32222 */
        return MAC_SYNTAX_ERROR_VAL;
        /* - coverity 32222 */
    }

    ulLcInfo_p->QCI = qci;
    dlLcInfo_p->QCI = qci;
    /*SPR 2834 Fix Begins*/
    len -= QOS_INFO_MIN_LEN; /* tag and taglen, bearer type, qci */
    /*SPR 2834 Fix Ends*/

    if(len > 0)
    {
        if(len < GBR_INFO_LEN)
        {
            lteWarning("Mac syntax length error .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    len,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Mac syntax length error");
            /* Review comment fix end RJ13 */
            /* + coverity 32222 */
            return MAC_SYNTAX_ERROR_VAL;
            /* + coverity 32222 */
        }
        /*Decode GBR Info*/
        tag = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;

        if(tag != GBR_QOS_INFO)
        {
            lteWarning("Wrong tag received.\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tag,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Wrong tag received");
            /* Review comment fix end RJ13 */
            /* + coverity 32766 */
            return MAC_FAILURE;
            /* - coverity 32766 */
        }

        tagLen = LTE_GET_U16BIT(*msg_p);
        *msg_p += 2;

        if(tagLen != GBR_INFO_LEN)
        {
            lteWarning("Mac syntax length error .\n");
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Mac syntax length error");
            /* Review comment fix end RJ13 */
            /* + coverity 32222 */
            return MAC_SYNTAX_ERROR_VAL;
            /* - coverity 32222 */
        }

        len -= tagLen;
        /* SPR  3444 changes start */
        parseGBRInfo(msg_p,dlLcInfo_p,ulLcInfo_p);
        /* SPR  3444 changes end */
    }
    return MAC_SUCCESS;

}



/****************************************************************************
 * Function Name  : parseGBRInfo
 * Inputs         : msg_p - Buffer Received from RRC
 *                  dlLcInfo_p - pointer to downlink create LC structure
 *                  ulLcInfo_p - pointer to uplink create LC structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills  the
 *                  GBR info in  structure needed by MAC for scheduling.
 ****************************************************************************/
/* SPR  3444 changes start */
static  void parseGBRInfo ( UInt8 **msg_p,
        /* SPR  3444 changes end */
        LogicalChannelConfigInfo* dlLcInfo_p,
        ulLogicalChannelInfo* ulLcInfo_p)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );

    UInt32 dlMBR = 0;
    UInt32 ulMBR = 0;
    UInt32 dlGBR = 0;
    UInt32 ulGBR = 0;

    /*CR 64 bit to 32 bit */
    dlMBR = LTE_GET_U32BIT(*msg_p);
    *msg_p += SIZEOF_UINT32;

    ulMBR = LTE_GET_U32BIT(*msg_p);
    *msg_p += SIZEOF_UINT32;

    dlGBR = DIVIDE_BY_EIGHT(LTE_GET_U32BIT(*msg_p));
    *msg_p += SIZEOF_UINT32;

    ulGBR = DIVIDE_BY_EIGHT(LTE_GET_U32BIT(*msg_p));
    *msg_p += SIZEOF_UINT32;
    /*CR 64 bit to 32 bit */
    if (PNULL != dlLcInfo_p)
    {
        dlLcInfo_p->MBR = dlMBR;
        dlLcInfo_p->GBR = dlGBR;
    }
    if (PNULL != ulLcInfo_p)
    {
        ulLcInfo_p->MBR = ulMBR;
        ulLcInfo_p->GBR = ulGBR;
    }
}

/****************************************************************************
 * Function Name  : macChangeCrntiReq 
 * Inputs         : changeCrntiInfo- is a variable of structure ChangeCrntiInfo
 *                  which contains the old crnti and new crnti values
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function update the oldCrnti with the NewCrnti
 *****************************************************************************/
STATIC MacRetType macChangeCrntiReq(ChangeCrntiInfo changeCrntiInfo
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    DLUEContext*  dlUeContext_p = PNULL;
    ULUEContext*  ulUeContext_p = PNULL;
    /* Rel 5.3: Coverity 32237 Fix Start */
    MacRetType resp = MAC_FAILURE;
    /* Rel 5.3: Coverity 32237 Fix End */
    RNTIInfo *oldRntiInfo_p = PNULL;
    RNTIInfo *newRntiInfo_p = PNULL;
    TempCRNTICtxNode* tempCRNTICtxNode_p = 
        &tempCrntiCtx_gp[internalCellIndex]->tempCRNTICtxArray[0]; 

    /*CA Changes start  */
    oldRntiInfo_p = getUeIdxFromRNTIMap(changeCrntiInfo.oldCrnti, internalCellIndex);
    newRntiInfo_p = getUeIdxFromRNTIMap(changeCrntiInfo.newCrnti, internalCellIndex);
    /*CA Changes end  */
    /* SPR 16400 Start */
    if ( ( newRntiInfo_p ) && 
            ( newRntiInfo_p->index >= MAX_UE_SUPPORTED ) )
    {
        return resp;
    }
    /* SPR 16400 End */

    /* SPR 2365 start */
    /* + SPR_17858_122_CHANGES */
    if((PNULL == oldRntiInfo_p) || (PNULL == newRntiInfo_p)|| (newRntiInfo_p->rntiFlag == FREERNTI ))
    {
        /* - SPR_17858_122_CHANGES */
        if(PNULL == oldRntiInfo_p)
        {
            LOG_MAC_MSG(RRC_CHANGE_CRNTI_INVALID_PARAM,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),changeCrntiInfo.ueIndex,resp,
                    changeCrntiInfo.oldCrnti,changeCrntiInfo.newCrnti,
                    internalCellIndex,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"Invalid Old CRNTI");
        }
        else if(PNULL == newRntiInfo_p)
        {
            LOG_MAC_MSG(RRC_CHANGE_CRNTI_INVALID_PARAM,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),changeCrntiInfo.ueIndex,resp,
                    changeCrntiInfo.oldCrnti,changeCrntiInfo.newCrnti,
                    internalCellIndex,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"Invalid New CRNTI");

        }
    }
    else if(PNULL ==
            tempCRNTICtxNode_p[newRntiInfo_p->index].tempCRNTICtx_p)
    {
        LOG_MAC_MSG(RRC_CHANGE_CRNTI_INVALID_PARAM,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),changeCrntiInfo.ueIndex,resp,
                changeCrntiInfo.oldCrnti,changeCrntiInfo.newCrnti,
                internalCellIndex,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"NoTemp Context for NEW CRNTI");
    }
    /* SPR 2365 end */
    else
    {    
        dlUeContext_p = 
            (dlUECtxInfoArr_g[changeCrntiInfo.ueIndex]).dlUEContext_p;
        ulUeContext_p = 
            (ulUECtxInfoArr_g[changeCrntiInfo.ueIndex]).ulUEContext_p;
        if ((PNULL == dlUeContext_p) || (PNULL == ulUeContext_p))
        {
            LOG_MAC_MSG(RRC_INVALID_CONTEXT_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),changeCrntiInfo.ueIndex,  
                    DEFAULT_INT_VALUE,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"INVALID_UE_CONTEXT");
        }
        else if((dlUeContext_p->crnti == changeCrntiInfo.oldCrnti) && 
                (ulUeContext_p->crnti == changeCrntiInfo.oldCrnti))
        {
            dlUeContext_p->crnti = changeCrntiInfo.newCrnti;
            ulUeContext_p->crnti = changeCrntiInfo.newCrnti;
            resp = MAC_SUCCESS;
        }
    }
    return resp;
}

/* +- SPR 19066 */

/*Added For Power Control*/
/****************************************************************************
 * Function Name  : parseTpcRntiRange 
 * Inputs         : message_p      : Pointer to the buffer containing the 
 *                                   values of the TPC_RNTI_RANGE API
 *                  configCellReq_p: Pointer to the ConfigCellReq structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  from RRC at the time of cell configuration and populate 
 *                  the ConfigCellReq's TpcRntiRange member
 *****************************************************************************/
MacRetType parseTpcRntiRange(UInt8 *message_p, 
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msg_p = message_p;
    /* Rel 5.3: Coverity 32238 and 32228 Fix Start */
    MacRetType retVal = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32238 and 32228 Fix End */

    configCellReq_p->tpcRntiRange.startTpcRntiPucch = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    configCellReq_p->tpcRntiRange.endTpcRntiPucch = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    /* +- SPR 17777 */
    retVal = validateTpcRntiRange(configCellReq_p->tpcRntiRange.startTpcRntiPucch,
            configCellReq_p->tpcRntiRange.endTpcRntiPucch,internalCellIndex);
    /* +- SPR 17777 */
    if(MAC_SUCCESS == retVal)
    {
        retVal = MAC_SUCCESS;
    }
    else
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->tpcRntiRange.startTpcRntiPucch,
                configCellReq_p->tpcRntiRange.endTpcRntiPucch,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_TPC_RNTI_PUCCH_RANGE_PARAM");
        retVal = MAC_FAILURE;
        return retVal;
    }

    configCellReq_p->tpcRntiRange.startTpcRntiPusch = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    configCellReq_p->tpcRntiRange.endTpcRntiPusch = LTE_GET_U16BIT(msg_p);
    msg_p += 2;

    /* +- SPR 17777 */
    retVal = validateTpcRntiRange(configCellReq_p->tpcRntiRange.startTpcRntiPusch,
            configCellReq_p->tpcRntiRange.endTpcRntiPusch,internalCellIndex);
    /* +- SPR 17777 */
    if(MAC_SUCCESS == retVal)
    {
        if((configCellReq_p->tpcRntiRange.endTpcRntiPusch < 
                    configCellReq_p->tpcRntiRange.startTpcRntiPucch) ||
                (configCellReq_p->tpcRntiRange.startTpcRntiPusch > 
                 configCellReq_p->tpcRntiRange.endTpcRntiPucch))
        {
            retVal = MAC_SUCCESS;
        }
        else
        {
            retVal = MAC_FAILURE;
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->tpcRntiRange.startTpcRntiPusch,
                configCellReq_p->tpcRntiRange.endTpcRntiPusch,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_TPC_RNTI_PUSCH_RANGE_PARAM");
        retVal = MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_TPC_RNTI_RANGE_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->tpcRntiRange.startTpcRntiPucch,
            configCellReq_p->tpcRntiRange.endTpcRntiPucch,
            configCellReq_p->tpcRntiRange.startTpcRntiPusch,
            configCellReq_p->tpcRntiRange.endTpcRntiPusch,
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_TPC_RNTI_RANGE_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/


    return retVal;
}

/****************************************************************************
 * Function Name  : validateTpcRntiRange
 * Inputs         : startTpcRnti   : Start value of Tpc Rnti
 *                  endTpcRnti     : End value of Tpc Rnti
 *                  configCellReq_p: Pointer to the ConfigCellReq structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will validate the TpcRnti Ranges for pucch or
 *                  Pusch. The Tpc Rnti Range should not overlap with Ra Rnti
 *                  Range
 *****************************************************************************/
/* CA changes Start */
MacRetType validateTpcRntiRange(UInt16 startTpcRnti,
        UInt16 endTpcRnti,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex)
/* CA changes end */
{
    /* Rel 5.3: Coverity 32238 Fix Start */
    MacRetType retVal = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32238 Fix End */

    /*Start TPC RNTI should be less than End TPC RNTI*/
    if(startTpcRnti <= endTpcRnti)
    {
        /*Start and End TPC RNTI should be within the range*/
        if(((startTpcRnti >= MIN_TPC_RNTI_VALUE) && 
                    (startTpcRnti <= MAX_TPC_RNTI_VALUE)) && 
                ((endTpcRnti >= MIN_TPC_RNTI_VALUE) && 
                 (endTpcRnti <= MAX_TPC_RNTI_VALUE)))
        {
            /* CA changes Start */
            /*TPC RNTI should not overlap with RA RNTI range*/
            if((startTpcRnti > cellSpecificParams_g.cellConfigAndInitParams_p\
                        [internalCellIndex]->initParams_p->upperRNTIBound) ||
                    (endTpcRnti < cellSpecificParams_g.cellConfigAndInitParams_p\
                     [internalCellIndex]->initParams_p->lowerRNTIBound))
                /* CA changes end */
            {
                retVal = MAC_SUCCESS;
            }
            else
            {
                retVal = MAC_FAILURE;
            }
        }
        else
        {
            retVal = MAC_FAILURE;
        }
    }
    else
    {
        retVal = MAC_FAILURE;
    }

    return retVal;
}

/****************************************************************************
 * Function Name  : parsePdschConfigCommonInfo 
 * Inputs         : message_p      : Pointer to the buffer containing the 
 *                                   values of the PDSCH_CONFIG_COMMON_INFO API
 *                  configCellReq_p: Pointer to the ConfigCellReq structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  from RRC at the time of cell configuration and populate 
 *                  the ConfigCellReq's PDSCHConfigCommonInfo member
 *****************************************************************************/
MacRetType parsePdschConfigCommonInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8  *msg_p = message_p;

    configCellReq_p->pdschConfigCommonInfo.referenceSigPower = *msg_p++;
    /*Checking the range of the referenceSigPower*/
    /*CLPC_REWORK_CHG*/
    if((MIN_REFERENCE_SIGNAL_POWER_VALUE > configCellReq_p->pdschConfigCommonInfo.referenceSigPower)||
            (MAX_REFERENCE_SIGNAL_POWER_VALUE < configCellReq_p->pdschConfigCommonInfo.referenceSigPower))
        /*CLPC_REWORK_CHG*/
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->pdschConfigCommonInfo.referenceSigPower,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_REFERENCE_SIGNAL_POWER_PARAM");
        return MAC_FAILURE;
    }
    /*Checking the range of pB*/
    configCellReq_p->pdschConfigCommonInfo.pB = *msg_p++;
    if((MAX_PB_VALUE < configCellReq_p->pdschConfigCommonInfo.pB))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->pdschConfigCommonInfo.pB,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PB_PARAM");
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_PDSCH_CONFIG_COMMON_INFO_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->pdschConfigCommonInfo.referenceSigPower,
            configCellReq_p->pdschConfigCommonInfo.pB,
            internalCellIndex, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_PDSCH_CONFIG_COMMON_INFO_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/

    return MAC_SUCCESS;
}


/****************************************************************************
 * Function Name  : parseCommonDLPowerControlInfo 
 * Inputs         : message_p      : Pointer to the buffer containing the 
 *                                   values of the DOWNLINK_POWER_CONTROL_COMMON API
 *                  configCellReq_p: Pointer to the ConfigCellReq structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  from RRC at the time of cell configuration and populate 
 *                  the ConfigCellReq.s CommonDLPowerControlInfo member
 *****************************************************************************/
MacRetType parseCommonDLPowerControlInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = message_p;

    configCellReq_p->commonDLPowerControlInfo.pcfichPowerOffset = LTE_GET_U16BIT(msg_p);
    /*Checking the range of the pcfichPowerOffset*/
    if((MAX_TRANS_POWER_OFFSET < configCellReq_p->commonDLPowerControlInfo.pcfichPowerOffset))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), DEFAULT_INT_VALUE,
                configCellReq_p->commonDLPowerControlInfo.pcfichPowerOffset,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PCFICH_POWER_OFFSET_PARAM");
        return MAC_FAILURE;
    }

    msg_p += 2;
    configCellReq_p->commonDLPowerControlInfo.phichPowerOffset = LTE_GET_U16BIT(msg_p);
    /*Checking the range of the phichPowerOffset*/
    if((MAX_TRANS_POWER_OFFSET < configCellReq_p->commonDLPowerControlInfo.phichPowerOffset))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), DEFAULT_INT_VALUE,
                configCellReq_p->commonDLPowerControlInfo.phichPowerOffset,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PHICH_POWER_OFFSET_PARAM");
        return MAC_FAILURE;
    }

    msg_p += 2;
    configCellReq_p->commonDLPowerControlInfo.pdcchPowerOffset = LTE_GET_U16BIT(msg_p);
    /*Checking the range of the pdcchPowerOffset*/
    if((MAX_TRANS_POWER_OFFSET < configCellReq_p->commonDLPowerControlInfo.pdcchPowerOffset))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->commonDLPowerControlInfo.pdcchPowerOffset,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PDCCH_POWER_OFFSET_PARAM");
        return MAC_FAILURE;
    }

    msg_p += 2;
    configCellReq_p->commonDLPowerControlInfo.pbchTransmissionPower = LTE_GET_U16BIT(msg_p);
    /*Checking the range of the pbchTransmissionPower*/
    if((MAX_TRANS_POWER_OFFSET < configCellReq_p->commonDLPowerControlInfo.pbchTransmissionPower))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->commonDLPowerControlInfo.pbchTransmissionPower,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PBCH_TRANS_POWER_PARAM");
        return MAC_FAILURE;
    }

    msg_p += 2;
    configCellReq_p->commonDLPowerControlInfo.pchTransmissionPower = LTE_GET_U16BIT(msg_p);
    /*Checking the range of the pchTransmissionPower*/
    if((MAX_TRANS_POWER_OFFSET < configCellReq_p->commonDLPowerControlInfo.pchTransmissionPower))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->commonDLPowerControlInfo.pchTransmissionPower,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PCH_TRANS_POWER_PARAM");
        return MAC_FAILURE;
    }

    msg_p += 2;
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_DOWNLINK_POWER_CONTROL_COMMON_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->commonDLPowerControlInfo.pcfichPowerOffset,
            configCellReq_p->commonDLPowerControlInfo.phichPowerOffset,
            configCellReq_p->commonDLPowerControlInfo.pdcchPowerOffset,
            configCellReq_p->commonDLPowerControlInfo.pchTransmissionPower, 
            internalCellIndex, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_DOWNLINK_POWER_CONTROL_COMMON_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/

    return MAC_SUCCESS;
}


/****************************************************************************
 * Function Name  : parseCommonULPowerControlInfo 
 * Inputs         : message_p      : Pointer to the buffer containing values 
 *                                   of the UPLINK_POWER_CONTROL_COMMON API
 *                  configCellReq_p: Pointer to the ConfigCellReq structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  from RRC at the time of cell configuration and populate 
 *                  the ConfigCellReq.s CommonULPowerControlInfo member
 *****************************************************************************/
MacRetType parseCommonULPowerControlInfo(UInt8 *message_p,
        ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = message_p;

    configCellReq_p->commonULPowerControlInfo.p0NominalPUSCH = *msg_p++;
    /*Checking the range of the p0NominalPUSCH*/
    if((MIN_P0_NOMINAL_PUSCH_VALUE > configCellReq_p->commonULPowerControlInfo.p0NominalPUSCH) ||
            (MAX_P0_NOMINAL_PUSCH_VALUE < configCellReq_p->commonULPowerControlInfo.p0NominalPUSCH))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), DEFAULT_INT_VALUE,
                configCellReq_p->commonULPowerControlInfo.p0NominalPUSCH,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_P0_NOMINAL_PUSCH_PARAM");
        return MAC_FAILURE;

    }
    configCellReq_p->commonULPowerControlInfo.alpha = *msg_p++;
    /*Checking the range of the alpha*/
    if((MAX_ALPHA_VALUE < configCellReq_p->commonULPowerControlInfo.alpha))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->commonULPowerControlInfo.alpha,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_ALPHA_PARAM");
        return MAC_FAILURE;

    }

    // Possible values of alpha received lies between 0 to 7
    // Convert alpha into actual alpha values i.e. 
    // 0,4,5,6,7,8,9,10 for 0.0, 0.4, 0.5, 0.6, 
    // 0.7, 0.8, 0.9, 1
    if (configCellReq_p->commonULPowerControlInfo.alpha != 0)
    {
        configCellReq_p->commonULPowerControlInfo.alpha = 
            configCellReq_p->commonULPowerControlInfo.alpha +3;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_UPLINK_POWER_CONTROL_COMMON_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->commonULPowerControlInfo.p0NominalPUSCH,
            configCellReq_p->commonULPowerControlInfo.alpha,
            internalCellIndex, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_UPLINK_POWER_CONTROL_COMMON_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/

    return MAC_SUCCESS;
}


/****************************************************************************
 * Function Name  : parseDedicatedULPowerControlInfo 
 * Inputs         : message_p      : Pointer to the buffer containing the 
 *                                   values of the UPLINK_POWER_CONTROL_DEDICATED API
 *                  ulPowCtrlInfo  : Pointer to the UL PWR CTRL info structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  at the time of creation of UE Context and parse the 
 *                  DedicatedULPowerControlInfo. It then populates 
 *                  UeContextForUplink's DedicatedULPowerControlInfo.
 *****************************************************************************/
MacRetType parseDedicatedULPowerControlInfo(UInt8 *message_p,
        DedicatedULPowerControlInfo* ulPowCtrlInfo
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = message_p;

    ulPowCtrlInfo->p0UePusch = *msg_p++;
    /*Checking the range of the p0UePusch.*/
    if((MIN_P0_UE_PUSCH_VALUE > ulPowCtrlInfo->p0UePusch) || 
            (MAX_P0_UE_PUSCH_VALUE < ulPowCtrlInfo->p0UePusch))
    {

        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                ulPowCtrlInfo->p0UePusch,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_P0_UE_PUSCH_PARAM");
        return MAC_FAILURE;
    }

    ulPowCtrlInfo->deltaMcsEnabled =*msg_p++;
    /*Checking the range of the deltaMcsEnabled.*/
    if((FALSE != ulPowCtrlInfo->deltaMcsEnabled) && 
            (TRUE != ulPowCtrlInfo->deltaMcsEnabled))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                ulPowCtrlInfo->deltaMcsEnabled,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_MCS_ENABLED_PARAM");
        return MAC_FAILURE;
    }

    ulPowCtrlInfo->accumulationEnabled = *msg_p++;
    /*Checking the range of the accumulationEnabled.*/
    if((FALSE != ulPowCtrlInfo->accumulationEnabled) && 
            (TRUE != ulPowCtrlInfo->accumulationEnabled))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                ulPowCtrlInfo->accumulationEnabled,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_ACCUMULATION_ENABLED_PARAM");
        return MAC_FAILURE;
    }

    return MAC_SUCCESS;

}


/****************************************************************************
 * Function Name  : parseTpcPdcchConfig 
 * Inputs         : message_p - Pointer to the buffer containing the 
 *                                   values of the TPC_PDCCH_CONFIG API
 *                  paramLength - Length of API message recivied
 *                  tpcPdcchConf - Pointer to the TPC PDCCH Configuration structure
 *                  isTpcForPusch - Flag weahter its TPC for PUSCH
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  at the time of creation of UE Context and parse the 
 *                  TpcPdcchConfig. It then populates UeContextForUplink's 
 *                  tpcPdcchConfigPucch/ tpcPdcchConfigPusch.
 *****************************************************************************/
MacRetType parseTpcPdcchConfig(UInt8 *message_p,
        UInt16 paramLength,
        TpcPdcchConfig* tpcPdcchConf,
        UInt8 isTpcForPusch,
        InternalCellIndex internalCellIndex) /*0-Pucch 1-Pusch*/
{
    /* UInt16 tagLength = 0; TDD Warning Fix */
    UInt16 tag = 0;
    UInt8 *msg_p = message_p;
    UInt8 remLen = paramLength;

    remLen = remLen - TAG_LEN;
    /*Subtracting the length of parameter release*/
    remLen = remLen - 1; 
    tag = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    /* tagLength = LTE_GET_U16BIT(msg_p); TDD Warning Fix */
    msg_p += 2;

    if(tag != TPC_RNTI_INFO)
    {
        lteWarning("Invalid tag TPC_PDCCH_INFO\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tag,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tag TPC_PDCCH_INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    remLen = remLen - TAG_LEN;
    if(remLen < TPC_RNTI_INFO_PARAM_LENGTH)
    {
        lteWarning("Mandatory Parameters are missing in TPC_PDCCH_INFO\n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                remLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Mandatory Parameters are missing in TPC_PDCCH_INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    tpcPdcchConf->tpcRnti = LTE_GET_U16BIT(msg_p);
    msg_p += 2;
    if(isTpcForPusch == FALSE)
    {
        if((tpcPdcchConf->tpcRnti < 
                    cellParams_p->tpcRntiRange.startTpcRntiPucch)||
                (tpcPdcchConf->tpcRnti > 
                 cellParams_p->tpcRntiRange.endTpcRntiPucch))
        {
            lteWarning("Invalid tpcRnti . Value = %d\n",
                    tpcPdcchConf->tpcRnti);
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tpcPdcchConf->tpcRnti,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid tpcRnti");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
    }
    else
    {
        if((tpcPdcchConf->tpcRnti > 
                    cellParams_p->tpcRntiRange.endTpcRntiPusch)||
                (tpcPdcchConf->tpcRnti < 
                 cellParams_p->tpcRntiRange.startTpcRntiPusch))
        {
            lteWarning("Invalid tpcRnti . Value = %d\n",
                    tpcPdcchConf->tpcRnti);
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tpcPdcchConf->tpcRnti,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid tpcRnti");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
    }

    tpcPdcchConf->tpcBitMapIndex = *msg_p++;
    /* + Coverity 55046 */
    tpcPdcchConf->isConfiguredForDci3Or3A = (DCIFormat)*msg_p;
    msg_p++;
    /* - Coverity 55046 */
    /*DCI Format FIX*/
    if(tpcPdcchConf->isConfiguredForDci3Or3A == MAC_RRC_DCI_FORMAT_3)
    {
        tpcPdcchConf->isConfiguredForDci3Or3A = DCI_FORMAT_3;
    }
    else if(tpcPdcchConf->isConfiguredForDci3Or3A == MAC_RRC_DCI_FORMAT_3A)
    {
        tpcPdcchConf->isConfiguredForDci3Or3A = DCI_FORMAT_3A;
    }
    /*DCI Format FIX*/
    LOG_MAC_MSG(MAC_UE_CREATE_SUCCESS_ID,LOGINFO,
            MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            tpcPdcchConf->tpcBitMapIndex,tpcPdcchConf->tpcRnti,
            tpcPdcchConf->isConfiguredForDci3Or3A,
            isTpcForPusch,internalCellIndex,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"PARSE_TPC_PDCCH_CONFIG");

    /* validate the tpcBitMapIndex received based on the isConfiguredForDci3Or3A*/
    if (tpcPdcchConf->isConfiguredForDci3Or3A == DCI_FORMAT_3)
    {
        if ((tpcPdcchConf->tpcBitMapIndex < MIN_TPC_INDEX_VALUE_DCI3) ||
                (tpcPdcchConf->tpcBitMapIndex > MAX_TPC_INDEX_VALUE_DCI3))
        {
            lteWarning("Invalid tpcBitMapIndex. Value = %d\n",
                    tpcPdcchConf->tpcBitMapIndex);
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tpcPdcchConf->tpcBitMapIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid tpcBitMapIndex received");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
    }
    else if (tpcPdcchConf->isConfiguredForDci3Or3A == DCI_FORMAT_3A)
    {
        if ((tpcPdcchConf->tpcBitMapIndex < MIN_TPC_INDEX_VALUE_DCI3A) ||
                (tpcPdcchConf->tpcBitMapIndex > MAX_TPC_INDEX_VALUE_DCI3A))
        {
            lteWarning("Invalid tpcBitMapIndex. Value = %d\n",
                    tpcPdcchConf->tpcBitMapIndex);
            /* Review comment fix start RJ13 */
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tpcPdcchConf->tpcBitMapIndex,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid tpcBitMapIndex");
            /* Review comment fix end RJ13 */
            return MAC_FAILURE;
        }
    }
    else
    {
        lteWarning("Invalid DCI Format. Neither DCI3 nor DCI3A received \n");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                DEFAULT_INT_VALUE,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid DCI Format. Neither DCI3 nor DCI3A received");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }

    return MAC_SUCCESS; 
}

/****************************************************************************
 * Function Name  : parsePowerControlEnablelInfo 
 * Inputs         : message_p - Pointer to the buffer containing the 
 *                                   values of the POWER_CONTROL_ENABLE API
 *                  configCellReq_p - Pointer to the ConfigCellReq structure
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received 
 *                  from RRC at the time of cell configuration and populate 
 *                  the ConfigCellReq.s powerControlEnableInfo member
 *****************************************************************************/
MacRetType parsePowerControlEnablelInfo(UInt8 *message_p, ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = message_p;

    configCellReq_p->powerControlEnableInfo.harqBlerClpcPucchEnable = *msg_p++;
    /*Checking the range of the harqBlerClpcPucchEnable.*/
    if((FALSE != configCellReq_p->powerControlEnableInfo.harqBlerClpcPucchEnable) && 
            (TRUE != configCellReq_p->powerControlEnableInfo.harqBlerClpcPucchEnable))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->powerControlEnableInfo.harqBlerClpcPucchEnable,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_HARQ_BLER_PUCCH_ENABLE_PARAM");

        return MAC_FAILURE;
    }

    configCellReq_p->powerControlEnableInfo.cqiSinrClpcPucchEnable = *msg_p++;
    /*Checking the range of the cqiSinrClpcPucchEnable*/
    if((FALSE != configCellReq_p->powerControlEnableInfo.cqiSinrClpcPucchEnable) && 
            (TRUE != configCellReq_p->powerControlEnableInfo.cqiSinrClpcPucchEnable ))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->powerControlEnableInfo.cqiSinrClpcPucchEnable,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_CQI_SINR_PUCCH_ENABLE_PARAM");
        return MAC_FAILURE;
    }

    configCellReq_p->powerControlEnableInfo.clpcPuschEnable = *msg_p++;
    /*Checking the range of the clpcPuschEnable*/
    if((FALSE != configCellReq_p->powerControlEnableInfo.clpcPuschEnable) &&
            (TRUE != configCellReq_p->powerControlEnableInfo.clpcPuschEnable))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->powerControlEnableInfo.clpcPuschEnable,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_CLPC_PUSCH_ENABLE_PARAM");

        return MAC_FAILURE;
    }

    configCellReq_p->powerControlEnableInfo.pdcchPowOrAggregationEnable = *msg_p++;
    /*Checking the range of the pdcchPowOrAggregationEnable*/
    if((FALSE != configCellReq_p->powerControlEnableInfo.pdcchPowOrAggregationEnable) &&
            (TRUE != configCellReq_p->powerControlEnableInfo.pdcchPowOrAggregationEnable))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->powerControlEnableInfo.pdcchPowOrAggregationEnable,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_POWER_AGGREGATION_ENABLER_PARAM");
        return MAC_FAILURE;
    }

    configCellReq_p->powerControlEnableInfo.clpcPuschfreqSelectiveEnable = *msg_p++;
    /*Checking the range of the clpcPuschfreqSelectiveEnable*/
    if((FALSE != configCellReq_p->powerControlEnableInfo.clpcPuschfreqSelectiveEnable) &&
            (TRUE != configCellReq_p->powerControlEnableInfo.clpcPuschfreqSelectiveEnable))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                configCellReq_p->powerControlEnableInfo.clpcPuschfreqSelectiveEnable,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PUSCH_FREQ_SEL_ENABLE_PARAM");
        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_POWER_CONTROL_ENABLE_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->powerControlEnableInfo.harqBlerClpcPucchEnable,
            configCellReq_p->powerControlEnableInfo.cqiSinrClpcPucchEnable, 
            configCellReq_p->powerControlEnableInfo.clpcPuschEnable, 
            configCellReq_p->powerControlEnableInfo.pdcchPowOrAggregationEnable, 
            configCellReq_p->powerControlEnableInfo.clpcPuschfreqSelectiveEnable, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_POWER_CONTROL_ENABLE_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/

    return MAC_SUCCESS;

}
/*SPR 16855 +-*/
/****************************************************************************
 * Function Name  : dlCreateUeReqHPHandler  
 * Inputs         : dlRrcOamQNodeReq_p - Pointer to UL RRC OAM request
 *                  queue node
 *                  dlRrcOamQNodeResp_p - Pointer to UL RRC OAM response 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : This function process/update the CREATE UE Request
 ****************************************************************************/
UInt32 dlCreateUeReqHPHandler(RrcOamHiPrioQNode *dlRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *dlRrcOamQNodeResp_p
        ,InternalCellIndex internalCellIndex)
{
    UInt32 dlBitMapValue = 0;
    DLUEContextInfo * ueDLContextInfo_p = PNULL;
    ULUEContextInfo * ueULContextInfo_p = PNULL;
    DLUEContext *dlUEContext_p = PNULL;
    ULUEContext *ulUEContext_p = PNULL;
    DLCreateUeReq  *dlCreateUeReqNode_p = PNULL;
    DLCreateUeResp *dlCreateUeRespNode_p = PNULL;
    DRXConfigInfo *drxConfigNode_p = PNULL;
    UInt8 cqiMaskV920 = 0;

    dlCreateUeReqNode_p = &dlRrcOamQNodeReq_p->rrcOamReqResp.dlCreateUeReq;
    dlCreateUeRespNode_p = &dlRrcOamQNodeResp_p->rrcOamReqResp.dlCreateUeResp;
    dlCreateUeRespNode_p->ueIndex = dlCreateUeReqNode_p->ueIndex; 
    ueDLContextInfo_p   = &dlUECtxInfoArr_g[dlCreateUeReqNode_p->ueIndex];
    dlUEContext_p =ueDLContextInfo_p->dlUEContext_p;
    ueULContextInfo_p = &ulUECtxInfoArr_g[dlCreateUeReqNode_p->ueIndex];
    ulUEContext_p = ueULContextInfo_p->ulUEContext_p;
    drxConfigNode_p = &dlCreateUeReqNode_p->drxConfigInfo; 
    cqiMaskV920 = dlCreateUeReqNode_p->drxConfigInfo.cqiMaskV920;

    dlBitMapValue = dlCreateUeReqNode_p->createUEMsg;
    /* Initialize DRX  TTIs for SPS */
    memSet(dlUEContext_p->spsDlInfo.ueDrxTTI, 
            DRX_STATE_INVALID, MAX_SPS_INTERVAL );
    memSet(ulUEContext_p->spsUlInfo.ueDrxTTI, 
            DRX_STATE_INVALID, MAX_SPS_INTERVAL );
    switch(dlBitMapValue)
    {
        case RRC_CONFIGURE_MEAS_GAP_80MS_MAP:
        {
            /*CA Changes start  */
            measGap80msInfo_gp[internalCellIndex]->activeIndex =
                dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap;
            measGap80msInfo_gp[internalCellIndex]->passiveIndex = 
                dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap ^ 0x01;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE :\n AT HP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_80MS_MAP \n"\
                    "Active Index for MeasGap 80ms Map = %d \n"\
                    "Passive Index for MeasGap 80ms Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    measGap80msInfo_gp[internalCellIndex]->activeIndex,
                    measGap80msInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_MEAS_GAP_40MS_MAP:
        {
            /*CA Changes start  */
            measGap40msInfo_gp[internalCellIndex]->activeIndex = 
                dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap;
            measGap40msInfo_gp[internalCellIndex]->passiveIndex = 
                /*CA Changes end  */
                dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap ^ 0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_40MS_MAP \n"\
                    "Active Index for MeasGap 40ms Map = %d \n"\
                    "Passive Index for MeasGap 40ms Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    measGap40msInfo_gp[internalCellIndex]->activeIndex,
                    measGap40msInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_DRX_MAP:
        {
            /* SPR 21043 Start */
            processDRXConfig(drxConfigNode_p,dlUEContext_p, ulUEContext_p,
                    internalCellIndex);
            if (cqiMaskV920 != INVALID_8_VAL)
            {    
                ulUEContext_p->ulDrxContext.cqiMask = cqiMaskV920;
            }
            /* SPR 21043 End */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]  For Create UE:"\
                    "\n RRC_CONFIGURE_DRX_MAP \n"\
                    "At HP Side \n DRX Config Type = %d \n"\
                    "isDRXShortCycleConfigured = %d \n"\
                    "drxOnDurationTimerIndex = %d \n"\
                    "drxInactivityTimerIndex = %d \n"\
                    "shortDRXCycleIndex = %d \n longDRXCycleIndex = %d\n"\
                    "drxOnDurationTimer = %d\n drxRetransmissionTimer= %d\n"\
                    "drxShortCycleTimer = %d\n drxInactivityTimer = %d\n"\
                    "shortDRXCycle = %d\n longDRXCycle = %d\n"\
                    "drxStartOffset = %d\n CQI Mask = %d\n", 
                    __func__,drxConfigNode_p->drxConfigType,
                    drxConfigNode_p->drxConfig.isDRXShortCycleConfigured,
                    drxConfigNode_p->drxConfig.drxOnDurationTimerIndex,
                    drxConfigNode_p->drxConfig.drxInactivityTimerIndex,
                    drxConfigNode_p->drxConfig.shortDRXCycleIndex,
                    drxConfigNode_p->drxConfig.longDRXCycleIndex,
                    drxConfigNode_p->drxConfig.drxOnDurationTimer,
                    drxConfigNode_p->drxConfig.drxRetransmissionTimer,
                    drxConfigNode_p->drxConfig.drxShortCycleTimer,
                    drxConfigNode_p->drxConfig.drxInactivityTimer,
                    drxConfigNode_p->drxConfig.shortDRXCycle,
                    drxConfigNode_p->drxConfig.longDRXCycle,
                    drxConfigNode_p->drxConfig.drxStartOffset,
                    cqiMaskV920
                        );
        }

        break;
        case RRC_CONFIGURE_DRX_MEAS_GAP_80MS_MAP:
        {
            /*CA Changes start  */
            measGap80msInfo_gp[internalCellIndex]->activeIndex =
                dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap;
            measGap80msInfo_gp[internalCellIndex]->passiveIndex = 
                dlCreateUeReqNode_p->activeIndexFor80MsMeasGapMap ^ 0x01;
            /* SPR 21043 Start */
            processDRXConfig(drxConfigNode_p,dlUEContext_p, ulUEContext_p,
                    internalCellIndex);
            if (cqiMaskV920 != INVALID_8_VAL)
            {    
                ulUEContext_p->ulDrxContext.cqiMask = cqiMaskV920;
            }
            /* SPR 21043 End */
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]  For Create UE: "\
                    "\n At HP Side \n"\
                    "\n RRC_CONFIGURE_DRX_MEAS_GAP_80MS_MAP \n"\
                    "Active Index for MeasGap 80ms Map = %d \n"\
                    "Passive Index for MeasGap 80ms Map = %d \n"\
                    "DRX Config Type = %d \n"\
                    "isDRXShortCycleConfigured = %d \n"\
                    "drxOnDurationTimerIndex = %d \n"\
                    "drxInactivityTimerIndex = %d \n"\
                    "shortDRXCycleIndex = %d \n longDRXCycleIndex = %d\n"\
                    "drxOnDurationTimer = %d\n drxRetransmissionTimer= %d\n"\
                    "drxShortCycleTimer = %d\n drxInactivityTimer = %d\n"\
                    "shortDRXCycle = %d\n longDRXCycle = %d\n"\
                    "drxStartOffset = %d\n CQI Mask = %d\n", 
                    __func__,
                    /*CA Changes start  */
                    measGap80msInfo_gp[internalCellIndex]->activeIndex,
                    measGap80msInfo_gp[internalCellIndex]->passiveIndex,
                    /*CA Changes end  */
                    drxConfigNode_p->drxConfigType,
                    drxConfigNode_p->drxConfig.isDRXShortCycleConfigured,
                    drxConfigNode_p->drxConfig.drxOnDurationTimerIndex,
                    drxConfigNode_p->drxConfig.drxInactivityTimerIndex,
                    drxConfigNode_p->drxConfig.shortDRXCycleIndex,
                    drxConfigNode_p->drxConfig.longDRXCycleIndex,
                    drxConfigNode_p->drxConfig.drxOnDurationTimer,
                    drxConfigNode_p->drxConfig.drxRetransmissionTimer,
                    drxConfigNode_p->drxConfig.drxShortCycleTimer,
                    drxConfigNode_p->drxConfig.drxInactivityTimer,
                    drxConfigNode_p->drxConfig.shortDRXCycle,
                    drxConfigNode_p->drxConfig.longDRXCycle,
                    drxConfigNode_p->drxConfig.drxStartOffset,
                    cqiMaskV920
                        );
        }
        break;
        case RRC_CONFIGURE_DRX_MEAS_GAP_40MS_MAP:
        {
            /*CA Changes start  */
            measGap40msInfo_gp[internalCellIndex]->activeIndex = 
                dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap;
            measGap40msInfo_gp[internalCellIndex]->passiveIndex = 
                dlCreateUeReqNode_p->activeIndexFor40MsMeasGapMap ^ 0x01;
            /* SPR 21043 Start */
            processDRXConfig(drxConfigNode_p,dlUEContext_p, ulUEContext_p,
                    internalCellIndex);
            if (cqiMaskV920 != INVALID_8_VAL)
            {    
                ulUEContext_p->ulDrxContext.cqiMask = cqiMaskV920;
            }
            /* SPR 21043 End */
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]  For Create UE:"\
                    "\n At HP Side \n"\
                    "\n RRC_CONFIGURE_DRX_MEAS_GAP_40MS_MAP \n"\
                    "Active Index for MeasGap 40ms Map = %d \n"\
                    "Passive Index for MeasGap 40ms Map = %d \n"\
                    "DRX Config Type = %d \n"\
                    "isDRXShortCycleConfigured = %d \n"\
                    "drxOnDurationTimerIndex = %d \n"\
                    "drxInactivityTimerIndex = %d \n"
                    "shortDRXCycleIndex = %d \n longDRXCycleIndex = %d\n"\
                    "drxOnDurationTimer = %d\n drxRetransmissionTimer= %d\n"
                    "drxShortCycleTimer = %d\n drxInactivityTimer = %d\n"\
                    "shortDRXCycle = %d\n longDRXCycle = %d\n"\
                    "drxStartOffset = %d\n CQI Mask = %d\n", 
                    __func__,
                    /*CA Changes start  */
                    measGap40msInfo_gp[internalCellIndex]->activeIndex,
                    measGap40msInfo_gp[internalCellIndex]->passiveIndex,
                    /*CA Changes end  */
                    drxConfigNode_p->drxConfigType,
                    drxConfigNode_p->drxConfig.isDRXShortCycleConfigured,
                    drxConfigNode_p->drxConfig.drxOnDurationTimerIndex,
                    drxConfigNode_p->drxConfig.drxInactivityTimerIndex,
                    drxConfigNode_p->drxConfig.shortDRXCycleIndex,
                    drxConfigNode_p->drxConfig.longDRXCycleIndex,
                    drxConfigNode_p->drxConfig.drxOnDurationTimer,
                    drxConfigNode_p->drxConfig.drxRetransmissionTimer,
                    drxConfigNode_p->drxConfig.drxShortCycleTimer,
                    drxConfigNode_p->drxConfig.drxInactivityTimer,
                    drxConfigNode_p->drxConfig.shortDRXCycle,
                    drxConfigNode_p->drxConfig.longDRXCycle,
                    drxConfigNode_p->drxConfig.drxStartOffset,
                    cqiMaskV920
                        );
        }
        break;
#ifdef ENDC_ENABLED
		/*Meas_Gap_Changes_Start*/
        case RRC_CONFIGURE_MEAS_GAP_20MS_MAP:
        {
            measGap20msInfo_gp[internalCellIndex]->activeIndex =
                dlCreateUeReqNode_p->activeIndexFor20MsMeasGapMap;
            measGap20msInfo_gp[internalCellIndex]->passiveIndex = 
                dlCreateUeReqNode_p->activeIndexFor20MsMeasGapMap ^ 0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE :\n AT HP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_20MS_MAP \n"\
                    "Active Index for MeasGap 20ms Map = %d \n"\
                    "Passive Index for MeasGap 20ms Map = %d \n",
                    __func__,
                    measGap20msInfo_gp[internalCellIndex]->activeIndex,
                    measGap20msInfo_gp[internalCellIndex]->passiveIndex
                    );
        }
        break;
        case RRC_CONFIGURE_MEAS_GAP_160MS_MAP:
        {
            measGap160msInfo_gp[internalCellIndex]->activeIndex =
                dlCreateUeReqNode_p->activeIndexFor160MsMeasGapMap;
            measGap160msInfo_gp[internalCellIndex]->passiveIndex = 
                dlCreateUeReqNode_p->activeIndexFor160MsMeasGapMap ^ 0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE :\n AT HP Side \n"\
                    "RRC_CONFIGURE_MEAS_GAP_160MS_MAP \n"\
                    "Active Index for MeasGap 160ms Map = %d \n"\
                    "Passive Index for MeasGap 160ms Map = %d \n",
                    __func__,
                    measGap160msInfo_gp[internalCellIndex]->activeIndex,
                    measGap160msInfo_gp[internalCellIndex]->passiveIndex
                    );
        }
        break;
        /*Meas_Gap_Changes_End*/
#endif
        default:
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid dlBitMapValue %u UE %u\n",
                dlBitMapValue,dlCreateUeReqNode_p->ueIndex);
        break;
    }
    {
    if(DL_QOS_BASED_SCHEDULING == cellSpecificParams_g.cellConfigAndInitParams_p
            [internalCellIndex]->initParams_p->dlSchdConfig.dlSchedulerStrategy)
    {
        qosProcessTknBktAlgoForUeAdd(dlCreateUeReqNode_p->ueIndex, internalCellIndex);
    }
    }

    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name  : dlDeleteUeReqHPHandler 
 * Inputs         : dlRrcOamQNodeReq_p - Pointer to UL RRC OAM request
 *                  queue node
 *                  dlRrcOamQNodeResp_p - Pointer to UL RRC OAM response 
 *                  queue node
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None 
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : This function process/update the DELETE UE Request
 ****************************************************************************/
UInt32 dlDeleteUeReqHPHandler(RrcOamHiPrioQNode *dlRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *dlRrcOamQNodeResp_p, 
        InternalCellIndex internalCellIndex )
{
    UInt16 ueIndex  = 0;
    LTE_GCC_UNUSED_PARAM(dlRrcOamQNodeResp_p)
        /* SPR 13492 Changes Start */
#ifdef KPI_STATS
        UInt32 activeIndexForMacStats = 0;
    UInt8 qci                     = INVALID_QCI;
    UInt8 ueCountFlag             = FALSE;
#endif
    /* SPR 13492 Changes End */
    dlRrcOamDeleteUeQNodeReq_p[internalCellIndex] = dlRrcOamQNodeReq_p;
    ueIndex = dlRrcOamQNodeReq_p->rrcOamReqResp.dlDeleteUeReq.ueIndex;  
    dlUECtxInfoArr_g[ueIndex].pendingDeleteFlag = TRUE;
    /* SPR 15408 Fix Start */
    DLUEContext *ueDLContext_p = PNULL;
    /* SPR 19288 changes start */
    /* SPR 13952 Changes Start */
    InitParams *initParams_p = cellSpecificParams_g.\
                               cellConfigAndInitParams_p[internalCellIndex]->initParams_p;
    /* SPR 13952 Changes End */
    /* SPR 19288 changes end */
    ueDLContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    if(ueDLContext_p)
    {
        /* SPR 19288 changes start */
        /* SPR 13952 Changes Start */
        {
        if(DL_QOS_BASED_SCHEDULING == initParams_p->dlSchdConfig.dlSchedulerStrategy)
        {
            /* SPR 16583 fix start */
            if(!ueDLContext_p->tcrntiFlag)
            {
                deleteDLUELogicalChannel(ueDLContext_p,1,internalCellIndex);
                deleteDLUELogicalChannel(ueDLContext_p,2,internalCellIndex);
            }
            /* SPR 16583 fix end */
            while(ueDLContext_p->gbrLcCount)
            {
                deleteDLUELogicalChannel(ueDLContext_p, ueDLContext_p->gbrLcInfo[0], internalCellIndex);

            }

            while(ueDLContext_p->nonGbrLcCount)
            {
                deleteDLUELogicalChannel(ueDLContext_p, ueDLContext_p->nonGbrLcInfo[0],internalCellIndex);

            }
        }
		}
        /* SPR 13952 Changes End */
        /* SPR 19288 changes end */
        /* SPR 16916 FIX START */
#ifdef KPI_STATS    
        updateNumOfActiveUeDlOnUeDelete(ueDLContext_p->ueIndex,internalCellIndex);/*coverity 108601 +-*/
#endif
        /* SPR 16916 FIX END */
        if (ueDLContext_p->dlUENonZeroQueueLoadAndHarqList_p)
        {
            /* SPR 17777 */
            deleteEntryFromUENonZeroQueueLoadAndHarqList(
                    ueDLContext_p,internalCellIndex);
            /* SPR 17777 */
        }
        ueDLContext_p->dlUENonZeroQueueLoadAndHarqList_p = PNULL;
/* SPR 22275 Fix + */
        /*+ Dyn UEs To Be SchPerTTI +*/ /*+ Potential Fix..*/
        if(ueDLContext_p->isUEConsideredForTotalActiveUeDL)
        {
            totalActiveUEsDL_g[internalCellIndex]--;
            ueDLContext_p->isUEConsideredForTotalActiveUeDL = FALSE;
        }
        /*- Dyn UEs To Be SchPerTTI -*/ /*- Potential Fix..*/
/* SPR 22275 Fix - */
    }
    /* SPR 15408 Fix End */
    /* SPR 13492 Changes Start */
#ifdef KPI_STATS
    activeIndexForMacStats = (gMacStats.
            pStats->lteCommonKPIStats[internalCellIndex].activeIndexForMacStats);

    for (qci = 0; qci < MAX_QCI ; ++qci)
    {
        if(TRUE == dlUECtxInfoArr_g[ueIndex].inSessionTimePerQCIFlag[qci])
        {
            if (FALSE == ueCountFlag)
            {
                gMacStats.pStats->lteCommonKPIStats[internalCellIndex].
                    lteMacKPIStats[activeIndexForMacStats].totalSessionTimeUE++;
                ueCountFlag = TRUE;
            }
            gMacStats.pStats->lteCommonKPIStats[internalCellIndex].
                lteMacKPIStats[activeIndexForMacStats].totalSessionTimePerQCI[qci]++;
            /* set flag to FALSE to avoid incerementing counter on LP thread */
            dlUECtxInfoArr_g[ueIndex].inSessionTimePerQCIFlag[qci] = FALSE;
        }
    }
#endif
    /* SPR 13492 Changes End */

    return MAC_REQ_MSG_IN_USE;
}
/****************************************************************************
 * Function Name  : dlCreateReconfigLC 
 * Inputs         : dlReconfigUeReq_p - Pointer for Downlink UE context 
 *                  Reconfiguration Request
 *                  dlUEContext_p - Pointer for Downlink UE context 
 *                  to be updated
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None 
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : Creates or Updates the LC info in the downlink UE Context
 ****************************************************************************/
MacRetType dlCreateReconfigLC(DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p 
        ,InternalCellIndex internalCellIndex
        )
{
    LogicalChannelConfigInfo *logicalChConfig_p = PNULL;
    UInt32 logicalChCount = 0;
    UInt8 tempLogicalChID = 0;

    /* Rel 5.3: Coverity 32232 Fix Start */
    LCOperationType lcOperationType = ADD;
    /* Rel 5.3: Coverity 32232 Fix End */

    /* + coverity 32226 */
    /* SPR 7050 Fix Start */
    MacRetType logChConfigResp = MAC_SUCCESS;
    /* SPR 7050 Fix End */
    /* - coverity 32226 */
    UInt32 n = 0;
    UInt32 returnType = MAC_SUCCESS;
    logicalChConfig_p = &(dlReconfigUeReq_p->dlReconfigLcReq.logicalChConfig[0]);
    logicalChCount = dlReconfigUeReq_p->dlReconfigLcReq.lcCount;

    /* Reconfiguring the Logical Channel Structures 
       and setting the rest as INVALID_LCID 255 */
    for (n = 0; n < logicalChCount; n++)
    {
        tempLogicalChID = logicalChConfig_p[n].lchId;
        lcOperationType = logicalChConfig_p[n].operationType;
        if ( ADD == lcOperationType )
        {
            if (INVALID_LCID != dlUEContext_p->
                    logicalChannel[tempLogicalChID].logicalChannelId )

            {
                lteWarning ("Logical Channel already added.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tempLogicalChID,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Logical Channel already added");
                /* Review comment fix end RJ13 */
                logicalChConfig_p[n].result = MAC_RRC_LOG_CH_EXISTS;
                /* + coverity 32226 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32226 */
                continue;

            }
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,
                    "Adding a new logical channel. \n");

            returnType = addMACDLLogicalChannel(dlUEContext_p,1,
                    &logicalChConfig_p[n],internalCellIndex);

            /* Coverity_73449 Fix Start */
            if( MAC_FAILURE== returnType)
            {
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
            }
            /* Coverity_73449 Fix End */

        }
        else if ( RECONFIGURE == lcOperationType )
        {
            if ( INVALID_LCID == dlUEContext_p->
                    logicalChannel[tempLogicalChID].
                    logicalChannelId)
            {
                lteWarning ("Trying to reconfigure a Logical Channel \
                        that does not exists.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tempLogicalChID,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Trying to reconfigure a Logical Channel that does not exists");
                /* Review comment fix end RJ13 */
                /* + coverity 32226 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32226 */
                logicalChConfig_p[n].result = MAC_RRC_LOG_CH_NOT_EXISTS;
                continue;
            }

            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,
                    "Reconfiguring a logical channel. \n");
            returnType = reconfigureMACDLLogicalChannel( dlUEContext_p,
                    &logicalChConfig_p[n],internalCellIndex);
            if( MAC_FAILURE == returnType)
            {
                /* + coverity 32226 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32226 */
            }
        }
        else if ( DELETE == lcOperationType)
        {
            if ( INVALID_LCID == dlUEContext_p->
                    logicalChannel[tempLogicalChID].
                    logicalChannelId)
            {
                lteWarning ("Trying to delete a Logical Channel that \
                        does not exists.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tempLogicalChID,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Trying to delete a Logical Channel that does not exists");
                /* Review comment fix end RJ13 */
                /* + coverity 32226 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32226 */
                logicalChConfig_p[n].result = MAC_RRC_LOG_CH_NOT_EXISTS;
                continue;
            }
            deleteDLUELogicalChannel(dlUEContext_p, tempLogicalChID, internalCellIndex);

            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,
                    "Deleting a logical channel.\n");
            logicalChConfig_p[n].result = MAC_SUCCESS;
        }
        else
        {
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,
                    "Invalid operation to be performed.\n");
            continue;
        }
    }

    LTE_MAC_UT_LOG(LOG_INFO,PARSE_UTIL,"[%s] Exit. ",__func__);

    return logChConfigResp;
}

/****************************************************************************
 * Function Name  : dlReconfigUeReqHPHandler 
 * Inputs         : dlRrcOamQNodeReq_p - Pointer to UL RRC OAM request
 *                  queue node
 *                  dlRrcOamQNodeResp_p - Pointer to UL RRC OAM response 
 *                  queue node
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : This function process/update the RECONFIG UE Request
 ****************************************************************************/
UInt32 dlReconfigUeReqHPHandler(RrcOamHiPrioQNode *dlRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *dlRrcOamQNodeResp_p,
        InternalCellIndex internalCellIndex)
{
    DLReconfigUeReq *dlReconfigUeReq_p = &dlRrcOamQNodeReq_p->rrcOamReqResp.dlReconfigUeReq;
    DLReconfigUeResp *dlReconfigUeResp_p = &dlRrcOamQNodeResp_p->rrcOamReqResp.dlReconfigUeResp;
    UInt16 ueIndex = dlReconfigUeReq_p->ueIndex;
    DLUEContext *dlUEContext_p = PNULL;
    dlUEContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    ULUEContext *ulUEContext_p = PNULL;
    ulUEContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    UInt8 cqiMaskV920 = 0;
    UInt8 tlvIndex;
    UInt32 tlvType = 0;
    UInt32 returnType = MAC_SUCCESS;
    UInt8 lcCount = 0;
    /* + CQI_5.0 */
    DLCQIInfo *dlCQIInfo_p = PNULL;
    /* - CQI_5.0 */
    DRXConfigInfo *drxConfigNode_p;
    /* EICIC +*/
    UserType oldUeType;
    UserType  newUeType;
    DLSchedulerStrategyConfig  *dlSchdConfig_p = &(cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->initParams_p->dlSchdConfig);

    /* EICIC -*/
    drxConfigNode_p = &dlReconfigUeReq_p->drxConfigInfo;
    cqiMaskV920 = dlReconfigUeReq_p->drxConfigInfo.cqiMaskV920;
    dlReconfigUeResp_p->ueIndex = ueIndex;
    /* + CQI_5.0 */
    dlCQIInfo_p = & dlUEContext_p->dlCQIInfo;
    dlCQIInfo_p->isSubBandReportAvailable  = FALSE;
    dlCQIInfo_p->isWideBandReportAvailable = FALSE;
    dlCQIInfo_p->modulationSchemeCodeWordOne = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    dlCQIInfo_p->modulationSchemeCodeWordTwo = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    dlCQIInfo_p->currentDLBLERForCW0 = TARGET_DL_BLER_VALUE;
    dlCQIInfo_p->currentDLBLERForCW1 = TARGET_DL_BLER_VALUE;
    /* SPR 13571 fix start */
    dlCQIInfo_p->prevDlBlerCalculatedForCW0 = TARGET_DL_BLER_VALUE;
    dlCQIInfo_p->prevDlBlerCalculatedForCW1 = TARGET_DL_BLER_VALUE;
    /* SPR 13571 fix end */
    /* ICIC changes start */
    updateDLBlerCW0(dlUEContext_p->ueIndex,TARGET_DL_BLER_VALUE, internalCellIndex);
    updateDLBlerCW1(dlUEContext_p->ueIndex,TARGET_DL_BLER_VALUE, internalCellIndex);
    /* ICIC changes end */
    /*+EICIC */
    updateDLBlerCW0_2(dlUEContext_p->ueIndex,TARGET_DL_BLER_VALUE, internalCellIndex);
    updateDLBlerCW1_2(dlUEContext_p->ueIndex,TARGET_DL_BLER_VALUE, internalCellIndex); 
    /*-EICIC */
    dlCQIInfo_p->previousDLBLERForCW0 = 0;
    dlCQIInfo_p->previousDLBLERForCW1 = 0;
    dlCQIInfo_p->dlBlerCalculatedCounterForCW0 = 0;
    dlCQIInfo_p->dlBlerCalculatedCounterForCW1 = 0;
    /*EICIC*/
    dlCQIInfo_p->currentDLBLERForCW0_2 = TARGET_DL_BLER_VALUE;
    dlCQIInfo_p->currentDLBLERForCW1_2 = TARGET_DL_BLER_VALUE;
    dlCQIInfo_p->previousDLBLERForCW0_2 = 0;
    dlCQIInfo_p->previousDLBLERForCW1_2 = 0;
    dlCQIInfo_p->dlBlerCalculatedCounterForCW0_2 = 0;
    dlCQIInfo_p->dlBlerCalculatedCounterForCW1_2 = 0;	
    dlCQIInfo_p->prevDlBlerCalculatedForCW0_2 = TARGET_DL_BLER_VALUE;
    dlCQIInfo_p->prevDlBlerCalculatedForCW1_2 = TARGET_DL_BLER_VALUE;
    dlCQIInfo_p->cqiCorrectionFactorForCW0_2 = 0;
    dlCQIInfo_p->cqiCorrectionFactorForCW1_2 = 0;
    dlCQIInfo_p->modulationSchemeCodeWordOne_2 = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    dlCQIInfo_p->modulationSchemeCodeWordTwo_2 = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    dlCQIInfo_p->isSubBandReportAvailable_2  = FALSE;
    dlCQIInfo_p->isWideBandReportAvailable_2 = FALSE;
    dlCQIInfo_p->reportReceivedTTI_2 = 0;
    dlCQIInfo_p->latestAperiodicReportRcvd_2 = TRUE;
    /*EICIC*/
    dlCQIInfo_p->aperiodicCqiRequestTTI = GET_CURRENT_TICK_FOR_CELL(internalCellIndex);
    dlCQIInfo_p->reportReceivedTTI = 0;
    dlCQIInfo_p->cqiCorrectionFactorForCW0 = 0;
    dlCQIInfo_p->cqiCorrectionFactorForCW1 = 0;
    dlCQIInfo_p->latestAperiodicReportRcvd = TRUE;
    /* - CQI_5.0 */

    for (tlvIndex = 0; tlvIndex < dlReconfigUeReq_p->ueReconfigMsgTlvCount ; tlvIndex++)
    {
        tlvType = dlReconfigUeReq_p->ueReconfigTlvRecieved[tlvIndex];
        switch(tlvType)
        {
            case DL_RECONFIG_CQI_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                if( MAC_FAILURE == processAndUpdateDLReconfigCqiInfo( ueIndex,
                            /* SPR 9427 changes start */
                            dlCQIInfo_p, dlReconfigUeReq_p, dlUEContext_p, ulUEContext_p
                            /* SPR 9427 changes end */
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            ) )
                {
                    return MAC_FAILURE;
                }
                /* Cyclomatic Complexity changes - ends here */
                break;   
            }
            case DL_RECONFIG_MAX_RB_INFO:
            {
                dlUEContext_p->maxNbOfRBs = dlReconfigUeReq_p->dlMaxRBInfo.dlMaxRB;
                LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] Maximum number of RBs At HP side = %d \n",__func__,
                        dlUEContext_p->maxNbOfRBs);
                break;
            }
            case DL_RECONFIG_TRANS_MODE_INFO:
            {
                /* + coverity 54150 */ 
                dlUEContext_p->dlMIMOInfo.transmissionMode = 
                    (TransmissonMode) dlReconfigUeReq_p->transMode.transMode;
                /* - coverity 54150 */ 

                /* + CQI_5.0 */
                if ( (TX_MODE_1 == dlUEContext_p->dlMIMOInfo.transmissionMode) ||
                        (TX_MODE_2 == dlUEContext_p->dlMIMOInfo.transmissionMode) ||
                        /* + TM6_5.2 */
                        (TX_MODE_6 == dlUEContext_p->dlMIMOInfo.transmissionMode) ||
                        /* - TM6_5.2 */
                        /* + TM7_8 Changes Start */
                        (TX_MODE_7 == dlUEContext_p->dlMIMOInfo.transmissionMode))
                    /* - TM7_8 Changes End */
                {
                    ulUEContext_p->pucchConfigInfo.ueReportedRI = RANK_INDICATOR_1;
                }

                /* - CQI_5.0 */
                break;
            }
            case DL_RECONFIG_CODEBOOK_SUBSET_RESTRICTION_INFO:
            {
                if(dlReconfigUeReq_p->cbsrInfo.cbsrType != CBSR_INVALID)
                {    
                    dlUEContext_p->dlMIMOInfo.cbsrInfo = 
                        dlReconfigUeReq_p->cbsrInfo;
                }
                break;
            }
            case DL_RECONFIG_NUM_OF_LAYERS_INFO:
            {
                /* SPR 8175 changes start */
                dlUEContext_p->dlMIMOInfo.dlRi = 
                    ulUEContext_p->pucchConfigInfo.ueReportedRI = 
                    ulUEContext_p->pucchConfigInfo.ueReportedPeriodicRI =  
                    dlReconfigUeReq_p->numOfLayersInfo.numOfLayers;
                /* SPR 8175 changes end */

                break;
            }
            case DL_RECONFIG_CODEBOOK_INDEX_INFO:
            {
                dlUEContext_p->dlMIMOInfo.precodingIndex = 
                    dlReconfigUeReq_p->codeBookIndexInfo.codeBookIndex;
                dlCQIInfo_p->wideBandPMIIndex =
                    dlReconfigUeReq_p->codeBookIndexInfo.codeBookIndex;

                break;
            }
            case DL_RECONFIG_UE_CATEGORY:
            {
                dlUEContext_p->ueCategory =
                    dlReconfigUeReq_p->ueCategoryInfo.ueCategory;
                dlUEContext_p->maxTBSize =
                    dlReconfigUeReq_p->ueCategoryInfo.maxTBSize;
                dlUEContext_p->maxSISOTBSize =
                    dlReconfigUeReq_p->ueCategoryInfo.maxSISOTBSize;
                dlUEContext_p->maxMIMOTBSize = 
                    dlReconfigUeReq_p->ueCategoryInfo.maxMIMOTBSize;
                /*Soft Buffer Changes Start*/
                dlUEContext_p->permissibleTBSize = dlReconfigUeReq_p->ueCategoryInfo.permissibleTBSize;
                dlUEContext_p->maxPermissibleTBSize = dlReconfigUeReq_p->ueCategoryInfo.maxPermissibleTBSize;
                /*Soft Buffer Changes End*/
                LTE_MAC_UPDATE_UE_COMMON_INFO_UE_INFO_STAT_UE_CATEGORY(
                        dlUEContext_p->ueIndex,
                        dlUEContext_p->ueCategory);
                break;
            }
            case DL_RECONFIG_DRX_CONFIG_INFO:
            {
                /* SPR 21043 Start */
                processDRXReConfig(drxConfigNode_p, 
                        dlUEContext_p, ulUEContext_p,
                        internalCellIndex);
                /* SPR 21043 End */

                if( SETUP == dlUEContext_p->drxConfigType)
                {
                    /* SPR 21043 Start */
                    if (cqiMaskV920 != INVALID_8_VAL)
                    {    
                        ulUEContext_p->ulDrxContext.cqiMask = cqiMaskV920;
                    }
                    /* SPR 21043 End */
                }
                else
                {
                    ulUEContext_p->ulDrxContext.cqiMask = 0;
                }
                break;
            }
            case DL_RECONFIG_MEAS_GAP_CONFIG_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                processAndUpdateDLRecfgMeasGapConfig ( dlReconfigUeReq_p,
                        dlUEContext_p, ulUEContext_p,internalCellIndex);
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case DL_RECONFIG_TIME_ALIGNMENT_TIMER_INFO:
            {
                dlUEContext_p->timeAlignmentTimer = 
                    dlReconfigUeReq_p->timeAlignmentTimerInfo.ulSyncTimer;
                /* + SPR_3939 */
                dlUEContext_p->syncTimerDelta =  
                    dlReconfigUeReq_p->timeAlignmentTimerInfo.syncTimerDelta;
                /* - SPR_3939 */
                break;
            }
            case DL_RECONFIG_PDSCH_CONFIG_INFO:
            {
                dlUEContext_p->pA = 
                    dlReconfigUeReq_p->pdschConfigInfo.dlPdschTransPower;
                LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] Pdsch Trans Power"\
                        "At HP Side = %d \n",
                        __func__, dlUEContext_p->pA);
                break;
            }
            case DL_RECONFIG_TPC_PDCCH_CONFIG_PUCCH:
            {
                returnType =  reconfigureTpcPdcchConfigInfoForPucch(
                        dlReconfigUeReq_p->tpcPDCCHConfigPUCCHInfo.release,
                        dlReconfigUeReq_p->tpcPDCCHConfigPUCCHInfo.tpcRnti,
                        dlReconfigUeReq_p->tpcPDCCHConfigPUCCHInfo.tpcIndex,
                        dlReconfigUeReq_p->tpcPDCCHConfigPUCCHInfo.isConfiguredForDci3Or3A,
                        dlUEContext_p, internalCellIndex);
                break;
            }
            case DL_RECONFIG_AMBR_QOS_INFO:
            {
                dlUEContext_p->dlAmbrInfo = dlReconfigUeReq_p->dlAmbrInfo;
                dlQosUpdateTknTableForLcPriority(
                        dlUEContext_p->dlAmbrInfo.lcTknTable,
                        dlUEContext_p->dlAmbrInfo.AMBR,
                        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]\
                        ->initParams_p->dlSchdConfig.dlTokenPeriodicity
                        );
                break;
            }
            case DL_RECONFIG_CONFIGURE_LC_REQ:
            {
                returnType = dlCreateReconfigLC(dlReconfigUeReq_p, dlUEContext_p,internalCellIndex);

                /* SPR 7050 Fix Start */
                if (MAC_SUCCESS == returnType)
                {
                    /* SPR 6626 changes start */
                    dlReconfigUeResp_p->dlReconfigLcResp.lcCount = dlReconfigUeReq_p->dlReconfigLcReq.lcCount;
                    /* SPR 6626 changes end */

                    for(lcCount =0 ; lcCount < dlReconfigUeResp_p->dlReconfigLcResp.lcCount; lcCount++)
                    {
                        dlReconfigUeResp_p->dlReconfigLcResp.logicalChConfig[lcCount] =
                            dlReconfigUeReq_p->dlReconfigLcReq.logicalChConfig[lcCount]; 
                    }
                }
                /* SPR 7050 Fix End */
                break;
            }
            /** HD FDD Changes **/
#ifdef HD_FDD_CONFIG
            case DL_RECONFIG_RF_PARAMS:
            {
                /* Cyclomatic Complexity changes - starts here */
                processAndUpdateDLReconfigRFParams ( dlReconfigUeReq_p, 
                        dlUEContext_p, internalCellIndex); 
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
#endif
            case DL_RECONFIG_SPS_PARAMS:
            {
                /* Cyclomatic Complexity changes - starts here */
                if (MAC_SUCCESS != processAndUpdateDLReconfigSPSParams ( 
                            ueIndex,
                            dlReconfigUeReq_p, 
                            dlUEContext_p
                            /* CA changes Start */
                            ,internalCellIndex
                            /* CA Changes end */
                            ))
                {
                    return MAC_FAILURE;
                }
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /* CA changes Start */
            case DL_RECONFIG_UE_CATEGORY_V1020:
            {
                LTE_MAC_UPDATE_UE_COMMON_INFO_UE_INFO_STAT_UE_CATEGORY(
                        dlUEContext_p->ueIndex,
                        dlUEContext_p->ueCategoryV1020);
                dlUEContext_p->ueCategoryV1020 =
                    dlReconfigUeReq_p->ueCategoryInfov1020.ueCategoryV1020;
                dlUEContext_p->maxTBSize =
                    dlReconfigUeReq_p->ueCategoryInfov1020.maxTBSize;
                dlUEContext_p->maxSISOTBSize =
                    dlReconfigUeReq_p->ueCategoryInfov1020.maxSISOTBSize;
                dlUEContext_p->maxMIMOTBSize = 
                    dlReconfigUeReq_p->ueCategoryInfov1020.maxMIMOTBSize;
                dlUEContext_p->permissibleTBSize = 
                    dlReconfigUeReq_p->ueCategoryInfov1020.permissibleTBSize;
                dlUEContext_p->maxPermissibleTBSize = 
                    dlReconfigUeReq_p->ueCategoryInfov1020.maxPermissibleTBSize;
                break;
            }
            case DL_RECONFIG_PUCCH_CONFIG_INFO_V1020:
            {
                macProcessAndUpdateDLReconfigPucchInfoV1020 (dlUEContext_p,
                        dlReconfigUeReq_p);
                break;
            }
            case DL_RECONFIG_CA_CONFIG_INFO:
            {
                if( MAC_FAILURE == macProcessAndUpdateDLReconfigCAConfig ( 
                            dlReconfigUeReq_p,dlUEContext_p,internalCellIndex))
                {
                    return MAC_FAILURE;
                }
                break;
            }
            case DL_RECONFIG_INTERFERENCE_INFO:
            {

                oldUeType = dlUEContext_p->userType;
                newUeType = dlReconfigUeReq_p->interferenceConfigDL.userType;

                dlUEContext_p->userType= dlReconfigUeReq_p->interferenceConfigDL.userType;

                if (oldUeType != newUeType)
                {
                    if (DL_QOS_BASED_SCHEDULING == dlSchdConfig_p->dlSchedulerStrategy)
                    {
                        macReconfigureDlUeLCTree(internalCellIndex, dlUEContext_p);
                        macReconfigureDlUeGBR(internalCellIndex, dlUEContext_p);
                    }
                }

                break;
            }
            /* CA Changes end */
            /* SPR 23402 Changes Start */
            /* MOCN Changes Start */
            case  DL_RECONFIG_OPERATOR_ID_INFO:
            {
                dlUEContext_p->operatorId = dlReconfigUeReq_p->operatorId;
                break;
            }
            /* MOCN Changes End */
            /* SPR 23402 Changes End */
            default:
            {
                lteWarning ("Invalid TLV Type %d received\n", tlvType);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tlvType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid TLV Type received");
                /* Review comment fix end RJ13 */
                break;
            }
        }
    }

    /* SPR 7050 Fix Start */
    /* Code removed */
    /* SPR 7050 Fix Start */
    return returnType;
}

/****************************************************************************
 * Function Name  : processAndUpdateDLReconfigCqiInfo 
 * Inputs         : ueIndex - Stores UE index
 *                  dlCQIInfo_p - Pointer to DL CQI Info
 *                  dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 *                  ulUEContext_p - Pointer to UL UE Context
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC SUCCESS or Reason For failure 
 * Description    : This function process and updates DL Reconfig CQI Info
 ****************************************************************************/
STATIC  MacRetType processAndUpdateDLReconfigCqiInfo( UInt16 ueIndex,
        DLCQIInfo *dlCQIInfo_p, DLReconfigUeReq *dlReconfigUeReq_p, 
        DLUEContext *dlUEContext_p,
        /* SPR 9427 changes start */
        ULUEContext *ulUEContext_p
        /* SPR 9427 changes end */
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 cqiValue = 0;   
    /* + CQI_5.0 */
    SubBandReportInfo tempSubbandReportInfo;
    memSet(&tempSubbandReportInfo,0,sizeof(SubBandReportInfo));

    /* SPR 9427 changes start */
    /* SPR 15909 fix start */
    tickType_t currentTick = GET_CURRENT_TICK_FOR_CELL(internalCellIndex);
    /* SPR 15909 fix end */

    if( ((APERIODIC_CQI_REPORTING_MODE != 
                    dlCQIInfo_p->cqiTypeIndicator) &&
                (PERIODIC_APERIODIC_MODE != 
                 dlCQIInfo_p->cqiTypeIndicator)) &&
            ((APERIODIC_CQI_REPORTING_MODE == 
              dlReconfigUeReq_p->dlCqiConfigInfo.cqiTypeIndicator) ||
             (PERIODIC_APERIODIC_MODE == 
              dlReconfigUeReq_p->dlCqiConfigInfo.cqiTypeIndicator)) )  
    {    
        ulUEContext_p->aperiodicCQIToBeRequested = TRUE;
        ulUEContext_p->aperiodicCqiRequestTTI = currentTick;
        dlCQIInfo_p->aperiodicCqiRequestTTI = currentTick;
    }
    /* SPR 9427 changes end */
    dlCQIInfo_p->cqiTypeIndicator = 
        dlReconfigUeReq_p->dlCqiConfigInfo.cqiTypeIndicator;
    dlUEContext_p->isSubbandPMIAvailable = FALSE;
    dlUEContext_p->aperiodicMode12Rcvd = FALSE;
    dlCQIInfo_p->cqiMode = dlReconfigUeReq_p->dlCqiConfigInfo.cqiMode;    
    /* SPR 6452 changes start */
    dlCQIInfo_p->modulationSchemeCodeWordOne = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    dlCQIInfo_p->modulationSchemeCodeWordTwo = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    /* SPR 6452 changes end */
    cqiValue = getCQIFromMCS(dlCQIInfo_p->mcsIndexCodeWordOne);

    dlCQIInfo_p->widebandCQICodeWordOne =
        dlCQIInfo_p->widebandCQICodeWordTwo =
        dlCQIInfo_p->initialCqiValue = cqiValue;
    /* SPR 14083 fix start */
    dlCQIInfo_p->previousTimeAveragedWBCQICW0 =
        dlCQIInfo_p->previousTimeAveragedWBCQICW1 = cqiValue;
    dlCQIInfo_p->previousTimeAveragedWBCQICW0_2 =
        dlCQIInfo_p->previousTimeAveragedWBCQICW1_2 = cqiValue;
    dlCQIInfo_p->widebandCQICodeWordOne_2 =
        dlCQIInfo_p->widebandCQICodeWordTwo_2 = cqiValue;
    dlCQIInfo_p->modulationSchemeCodeWordOne_2 = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    dlCQIInfo_p->modulationSchemeCodeWordTwo_2 = 
        dlReconfigUeReq_p->dlCqiConfigInfo.modScheme;
    /* SPR 14083 fix end */
    /* ICIC changes start */
    updateDLSINRCW0(ueIndex,cqiValue, internalCellIndex);
    updateDLSINRCW1(ueIndex,cqiValue, internalCellIndex);
    /* ICIC changes end */

    if (PNULL == dlCQIInfo_p->subBandReportInfo_p)
    {
        GET_MEM_FROM_POOL(SubBandReportInfo,
                dlCQIInfo_p->subBandReportInfo_p,
                sizeof(SubBandReportInfo),PNULL);

        /* + coverity 24465 */
        if ( PNULL == dlCQIInfo_p->subBandReportInfo_p )
        {
            /*CRITICAL! Memory error*/
            LOG_MAC_MSG(L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, L2_SYS_FAIL,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(SubBandReportInfo), internalCellIndex,0, 0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG(MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID, 
                    CRITICAL_ALARM);
            return MAC_FAILURE;
        }
        *(dlCQIInfo_p->subBandReportInfo_p) = tempSubbandReportInfo ;
        /* SPR 6452 changes start */
        dlCQIInfo_p->isSubBandReportAvailable = FALSE;
        /* SPR 6452 changes end */

        /* SPR 9427 changes start */
        UInt8 counter =  MAX_SUBBANDS;
        if (dlReconfigUeReq_p->transMode.transMode == TX_MODE_3 ||
                dlReconfigUeReq_p->transMode.transMode == TX_MODE_4)
        {
            while(counter--)
            {    
                dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].cqiIndexCW1 =  
                    dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].cqiIndexCW2 = cqiValue;

                dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].mcsIndexCW1 =
                    dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].mcsIndexCW2 = 
                    dlCQIInfo_p->mcsIndexCodeWordOne;

                dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].previousTimeAveragedSBCQICW0 =  
                    dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].previousTimeAveragedSBCQICW1 = 
                    cqiValue;
            }

            initSpatialRAT0RAT1Bitmaps(cqiValue,
                    &dlCQIInfo_p->subBandReportInfo_p->
                    cqiInfo.cqiInfoSpatialMul,
                    internalCellIndex);

        }
        else if (dlReconfigUeReq_p->transMode.transMode == TX_MODE_1 ||
                dlReconfigUeReq_p->transMode.transMode == TX_MODE_2)
        {   

            while(counter--)
            {    
                dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].cqiIndexCW1 = cqiValue; 

                dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].mcsIndexCW1 =
                    dlCQIInfo_p->mcsIndexCodeWordOne;

                dlCQIInfo_p->subBandReportInfo_p->
                    subBandToCQInfo[counter].previousTimeAveragedSBCQICW0 =  
                    cqiValue;
            }

            initNonSpatialRAT0RAT1Bitmaps(cqiValue,
                    &dlCQIInfo_p->subBandReportInfo_p->
                    cqiInfo.cqiInfoNonSpatialMul,
                    internalCellIndex);

        }

        initNumOfSBperBWpart(dlCQIInfo_p,internalCellIndex);
        /* SPR 9427 changes end */

    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : processAndUpdateDLRecfgMeasGapConfig 
 * Inputs         : dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 *                  ulUEContext_p - Pointer to UL UE Context
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig Measurement
 *                  Gap Config
 ****************************************************************************/
STATIC  void processAndUpdateDLRecfgMeasGapConfig(
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        ULUEContext *ulUEContext_p,InternalCellIndex internalCellIndex)
{
    dlUEContext_p->measGapConfigType = 
        dlReconfigUeReq_p->rrcMeasGapConfig.dlMeasGapConfig.measGapConfigType; 
    dlUEContext_p->measGapContext =
        dlReconfigUeReq_p->rrcMeasGapConfig.dlMeasGapConfig.measGapContextDL;
    ulUEContext_p->measGapConfigType = 
        dlReconfigUeReq_p->rrcMeasGapConfig.ulMeasGapConfig.measGapConfigType; 
    ulUEContext_p->measGapContext =
        dlReconfigUeReq_p->rrcMeasGapConfig.ulMeasGapConfig.measGapContextUL;
    /* SPR 17944 Start */
    /* 40ms and 80ms indexes are switched alwayas (though needed when meas-gap
     * reconfiguration is needed from 40 to 80 or vice versa) regardless of their
     * patterns being used in a particular configuration. */

    /*CA Changes start  */
    measGap80msInfo_gp[internalCellIndex]->activeIndex =
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor80MsMeasGapMap;
    measGap80msInfo_gp[internalCellIndex]->passiveIndex = 
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor80MsMeasGapMap ^ 0x01;
    measGap40msInfo_gp[internalCellIndex]->activeIndex =
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor40MsMeasGapMap;
    measGap40msInfo_gp[internalCellIndex]->passiveIndex = 
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor40MsMeasGapMap ^ 0x01;
#ifdef ENDC_ENABLED
		/*Meas_Gap_Changes_Start*/
    measGap20msInfo_gp[internalCellIndex]->activeIndex =
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor20MsMeasGapMap;
    measGap20msInfo_gp[internalCellIndex]->passiveIndex = 
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor20MsMeasGapMap ^ 0x01;
    measGap160msInfo_gp[internalCellIndex]->activeIndex =
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor160MsMeasGapMap;
    measGap160msInfo_gp[internalCellIndex]->passiveIndex = 
        dlReconfigUeReq_p->rrcMeasGapConfig.activeIndexFor160MsMeasGapMap ^ 0x01;
        /*Meas_Gap_Changes_End*/
#endif
    /*CA Changes end  */
    /* SPR 17944 End */
    /* + SPS_TDD_Changes */
    checkMeasGapAndSendUEForSPSDeactDL(dlUEContext_p, internalCellIndex); 
    checkMeasGapAndSendUEForSPSDeactUL(ulUEContext_p, internalCellIndex); 
    /* - SPS_TDD_Changes */
}

#ifdef HD_FDD_CONFIG
/******************************************************************************
 * Function Name  : processAndUpdateDLReconfigRFParams 
 * Inputs         : dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig RF Parameters
 * ****************************************************************************/
STATIC  void processAndUpdateDLReconfigRFParams( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        InternalCellIndex internalCellIndex)
{
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    if((TRUE==dlReconfigUeReq_p->rfParams))
    {
        /** if ue is being made HD from either earlier type HD or FD **/
        /*Already RF_PARAMS (HD FDD UE Support) is not received in previous config/reconfig*/
        if(FALSE == dlUEContext_p->isHDFddFlag)
        {
            dlUEContext_p->isHDFddFlag = TRUE;
            LOG_MAC_MSG(MAC_HD_FDD_CONFIG_SWITCH,LOGINFO,MAC_UL_Strategy,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),dlUEContext_p->ueIndex,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "UE changed from FDD->HD FDD");
            if(MAC_HD_FDD != cellParams_p->duplexingMode)
            {
                LOG_MAC_MSG(MAC_HD_FDD_CELL_NOT_SUPPORTED,LOGFATAL,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),dlUEContext_p->ueIndex,
                        cellParams_p->duplexingMode,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "Cell not supported for HD-FDD");
            }
        }
    }
    else if((TRUE==dlUEContext_p->isHDFddFlag) && (FALSE==dlReconfigUeReq_p->rfParams))
    {
        /** ue is being confirgured from HD to FD, so delete from the HD list **/
        LOG_MAC_MSG(MAC_HD_FDD_CONFIG_SWITCH,LOGINFO,MAC_UL_Strategy,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),dlUEContext_p->ueIndex,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "UE changed from HD FDD->FDD");
        /* SPR 11940 start */        
        deleteUeFromHdFddContext(dlUEContext_p, internalCellIndex);
        /* SPR 11940 end */        
        dlUEContext_p->isHDFddFlag = FALSE;
    }
}
#endif

/******************************************************************************
 * Function Name  : processAndUpdateDLReconfigSPSParams 
 * Inputs         : ueIndex - Stores UE index
 *                  dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function process and updates DL Reconfig SPS 
 *                  Parameters
 * ****************************************************************************/
STATIC  MacRetType processAndUpdateDLReconfigSPSParams( UInt16 ueIndex,
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p
        /* CA changes Start */
        , InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 index          = 0;
    RNTIInfo *rntiInfo_p = PNULL;
#ifdef LOG_PRINT_ENABLED
    UInt32 state         = 0;
#endif
    /* SPR 20456 start */
    /* code removed */

    if( dlReconfigUeReq_p->spsDlInfo.requestType == dlUEContext_p->spsDlInfo.requestType)
        /* SPR 20456 stop */
    {
        /* do nothing */
    }
    else
    {
        dlUEContext_p->spsDlInfo.requestType = dlReconfigUeReq_p->spsDlInfo.requestType;                   
        if(dlReconfigUeReq_p->spsDlInfo.requestType == SPS_RELEASE)    
        {
            /*! \code
             * Deallocate SPS CRNTI only if UL SPS Config is release
             *\endcode
             */
            if (PNULL == ulUECtxInfoArr_g[ueIndex].ulUEContext_p || 
                    SPS_RELEASE == ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.requestType)
            {
                deAllocateSpsCrnti(dlUEContext_p->spsDlInfo.SpsCrnti,internalCellIndex);
                /* Reset the SPS Crnti in DL UE Context */
                dlUEContext_p->spsDlInfo.SpsCrnti = 0;
                if (PNULL != ulUECtxInfoArr_g[ueIndex].ulUEContext_p)
                {
                    ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.SpsCrnti = 0;
                }
            }
#ifdef LOG_PRINT_ENABLED
            state = dlUEContext_p->spsDlInfo.spsState;
#endif
            /* Call state machine for setting state to SPS_IDLE  */
            if( MAC_FAILURE == dlStateMachine[dlUEContext_p->spsDlInfo.\
                    spsState][SPS_CONFIG_RECVD]( 
                        dlUEContext_p->ueIndex,
                        dlUEContext_p->spsDlInfo.spsState,
                        SPS_CONFIG_RECVD, dlUEContext_p, PNULL, 
                        /* + SPS_TDD_Changes*/ 
#ifdef FDD_CONFIG 
                        PHY_DL_DELAY
#else
                        DL_ADVANCE_TICK
#endif
                        /* - SPS_TDD_Changes*/
                        ,internalCellIndex ) )
            {
                LOG_MAC_MSG( MAC_DL_SPS_CURR_STATE, LOGDEBUG, MAC_DL_SPS_STRATEGY,
                        getCurrentTick(), __LINE__, dlUEContext_p->ueIndex, state, SPS_CONFIG_RECVD, 
                        dlUEContext_p->spsDlInfo.spsState, 0,0, __func__, "DlStateMachine");
                return MAC_FAILURE;
            }

            LOG_MAC_MSG( MAC_DL_SPS_CURR_STATE, LOGDEBUG, MAC_DL_SPS_STRATEGY,
                    getCurrentTick(), __LINE__, dlUEContext_p->ueIndex, state, SPS_CONFIG_RECVD, 
                    dlUEContext_p->spsDlInfo.spsState, 0,0, __func__, "DlStateMachine");

            freeMemPool( dlUEContext_p->spsDlInfo.spsDlSetupInfo_p );
            dlUEContext_p->spsDlInfo.spsDlSetupInfo_p = PNULL;
            dlUEContext_p->spsDlInfo.spsState = INVALID_STATE;
        }

        if(dlReconfigUeReq_p->spsDlInfo.requestType == SPS_SETUP)
        {
            if((PNULL != ulUECtxInfoArr_g[ueIndex].ulUEContext_p) &&
                    (SPS_SETUP == ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.requestType))
            {
                dlUEContext_p->spsDlInfo.SpsCrnti = 
                    ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.SpsCrnti;
                /*CA Changes start  */
                rntiInfo_p = getUeIdxFromRNTIMap(dlUEContext_p->spsDlInfo.SpsCrnti, internalCellIndex);
                /*CA Changes end  */
                if (PNULL == rntiInfo_p)
                {
                    LOG_MAC_MSG( MAC_UE_ID_RNTI_MAP, LOGWARNING, MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                            dlUEContext_p->spsDlInfo.SpsCrnti, 
                            dlUEContext_p->crnti,
                            dlUEContext_p->ueIndex, internalCellIndex, 0,0, __func__, "" );
                    return MAC_FAILURE;
                }
                rntiInfo_p->rntiFlag = SPS_RNTI;
                rntiInfo_p->index    = dlUEContext_p->ueIndex;
                dlUEContext_p->spsUeSearchSpaceInfo_p = (&rntiInfo_p->ueSearchSpaceInfo_p[internalCellIndex][0]);
            }
            else
            {
                UInt16  spsCrnti = allocateSpsCrnti(internalCellIndex);
                if( MAC_FAILURE == spsCrnti )
                {
                    return MAC_FAILURE;
                }
                else
                {
                    dlUEContext_p->spsDlInfo.SpsCrnti = spsCrnti;
                    /* Assigning SPS Crnti in UL Context */
                    if(PNULL != ulUECtxInfoArr_g[ueIndex].ulUEContext_p)
                    {
                        ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.SpsCrnti = spsCrnti;
                    }
                    /*CA Changes start  */
                    rntiInfo_p = getUeIdxFromRNTIMap(dlUEContext_p->spsDlInfo.SpsCrnti, internalCellIndex);
                    /*CA Changes end  */
                    if (PNULL == rntiInfo_p)
                    {
                        LOG_MAC_MSG( MAC_UE_ID_RNTI_MAP, LOGWARNING, MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, spsCrnti, 
                                dlUEContext_p->crnti,
                                dlUEContext_p->ueIndex, internalCellIndex, 0,0, __func__, "" );
                        return MAC_FAILURE;
                    }
                    rntiInfo_p->rntiFlag = SPS_RNTI;
                    rntiInfo_p->index    = dlUEContext_p->ueIndex;
                    dlUEContext_p->spsUeSearchSpaceInfo_p = (&rntiInfo_p->ueSearchSpaceInfo_p[internalCellIndex][0]);
                }
            }

            GET_MEM_FROM_POOL(SpsDlSetupInfo,
                    dlUEContext_p->spsDlInfo.spsDlSetupInfo_p,
                    sizeof (SpsDlSetupInfo),PNULL);
            if (dlUEContext_p->spsDlInfo.spsDlSetupInfo_p == PNULL)
            {
                /*CRITICAL! Memory error*/
                LOG_MAC_MSG(L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, L2_SYS_FAIL,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, sizeof(SpsDlSetupInfo), internalCellIndex,0,
                        0, 0,0, __FILE__, __func__);
                ALARM_MSG(MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID, 
                        CRITICAL_ALARM);
                return MAC_FAILURE;
            }

            dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->semiPersistentSchedIntervalDL =  
                dlReconfigUeReq_p->spsDlInfo.semiPersistentSchedIntervalDL;

            dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->numberOfConfSpsProcesses = 
                dlReconfigUeReq_p->spsDlInfo.numberOfConfSpsProcesses;

            /* If maxSpsHarqRetx not received then 
             * intitialize with default value
             */

            dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->maxSpsHarqRetx = 
                dlReconfigUeReq_p->spsDlInfo.maxSpsHarqRetx;

            /* If explicitReleaseAfter not received then 
             * intitialize with default value
             */

            dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->explicitReleaseAfter =
                dlReconfigUeReq_p->spsDlInfo.explicitReleaseAfter;

            /* Initializing the Optional parameter 
             * N1PucchAnPersistent in UE Context 
             */
            if (0 == dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->
                    N1PucchAnPersistentListVal. numOfN1PucchAnPersistent &&
                    0 == dlReconfigUeReq_p->spsDlInfo.
                    N1PucchAnPersistentListVal.numOfN1PucchAnPersistent)
            {
                for (index = 0; index < MAX_N1_PUCCH_AN_PERSISTENT; index++)
                {
                    dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->
                        N1PucchAnPersistentListVal.N1PucchAnPersistent[index] = 0;
                }
            }
            else
            {
                dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->N1PucchAnPersistentListVal.
                    numOfN1PucchAnPersistent = dlReconfigUeReq_p->spsDlInfo.
                    N1PucchAnPersistentListVal.numOfN1PucchAnPersistent;

                while(index < dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->
                        N1PucchAnPersistentListVal.numOfN1PucchAnPersistent)
                { 
                    dlUEContext_p->spsDlInfo.spsDlSetupInfo_p->
                        N1PucchAnPersistentListVal.N1PucchAnPersistent[index] = 
                        dlReconfigUeReq_p->spsDlInfo.
                        N1PucchAnPersistentListVal.N1PucchAnPersistent[index];
                    index++;
                }
            }    
        }
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : dlResetUeReqHPHandler 
 * Inputs         : dlRrcOamQNodeReq_p - Pointer of Downlink UE context 
 Reset Request
 *                : dlRrcOamQNodeResp_p - Pointer of downlink UE context
 Reset  response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : Reset flag will be set in the UE Context 
 ****************************************************************************/
UInt32 dlResetUeReqHPHandler(RrcOamHiPrioQNode *dlRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *dlRrcOamQNodeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{

    LTE_GCC_UNUSED_PARAM(dlRrcOamQNodeResp_p)
        UInt16 ueIndex  = 0;
    ueIndex = dlRrcOamQNodeReq_p->rrcOamReqResp.dlResetUeReq.ueIndex;
    dlUECtxInfoArr_g[ueIndex].pendingDeleteFlag = dlRrcOamQNodeReq_p->rrcOamReqResp.dlResetUeReq.pendingDeleteFlag;
    /* CA changes start */
    dlUECtxInfoArr_g[ueIndex].scellRelFlag = dlRrcOamQNodeReq_p->rrcOamReqResp.dlResetUeReq.scellRelFlag;
    /* CA changes end */
    /* Remove sleep MAC RESET changes start*/ 
    if(TRUE == dlRrcOamQNodeReq_p->rrcOamReqResp.dlResetUeReq.pendingDeleteFlag)
    {
        /* SPR 19288 changes start */
        /* SPR 13952 Changes Start */
        void                    *dlEligibleLcNodeVoid_p = PNULL;
        DLQosStrategyLCNode     *dlEligibleLcNode_p     = PNULL;
        DLUEContext *dlUeCtx_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
        /* SPR 4953 Start */
        /* Review comment fix start MAC_RESET_7 */
        /* SPR 10617 changes start */
        dlEligibleLcNodeVoid_p =
            listPopNode(&dlUeCtx_p->dlEligibleLcList);
        /* SPR 10617 changes end */
        /* Review comment fix end MAC_RESET_7 */

        while(PNULL != dlEligibleLcNodeVoid_p)
        {
            DL_QOS_GET_BASE_ADDRESS_FROM_ELIGIBLE_LC_ANCHOR(
                    dlEligibleLcNodeVoid_p, dlEligibleLcNode_p);

            dlEligibleLcNode_p->isPresentInEligibleList = FALSE;

            /* Delete th strategy Node From the tree */
            dlQosDeleteEntryFromPrioritisedLcTree
                /*CA Changes start  */
                (dlEligibleLcNode_p, internalCellIndex,getCurrentTick());
            /*CA Changes end  */

            /* Get Next LC Node */
            /* Review comment fix start MAC_RESET_7 */
            /* SPR 10617 changes start */
            dlEligibleLcNodeVoid_p =
                listPopNode(&dlUeCtx_p->dlEligibleLcList);
            /* SPR 10617 changes end */
            /* Review comment fix end MAC_RESET_7 */
        }
        /* SPR 4953 End */
        /* SPR 13952 Changes End */
        /* SPR 19288 changes end */
        /* SPR 19288 changes end */
        return MAC_PENDING_RESET;
    }
    else
    {

        /* SPR 9385 changes start*/
        DLHARQEntity  *dlHarqContext_p = PNULL;
        DLHARQProcess *dlHarqProcess_p     = PNULL;
        /*cov 97152 +-*/
        /* + SPR 17571 */
        DLUEContext *dlUeCtx_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
        if( PNULL != dlUeCtx_p )  
        {    
            /* Reset the TCRNTI Flag in case re-establishment is triggered at
               target instead of reconfigurationComplete */
            dlUeCtx_p->tcrntiFlag = FALSE;
            dlHarqContext_p =  dlUeCtx_p->dlHarqContext_p;
            /* - SPR 17571 */

            if(dlHarqContext_p)
            {
                UInt8 count = 0;
                for (count = 0; count < MAX_HARQ_PROCESS_NB ; count++)            
                {
                    dlHarqProcess_p = &dlHarqContext_p->harqProcess[count];
                    if(dlHarqProcess_p)
                    {
                        if(INVALID_HARQ_ID != dlHarqProcess_p->harqProcessId && 
                                HARQ_PROCESS_FREE != dlHarqProcess_p->harqStatus)
                        {
                            freeDLHarqProcess(dlUECtxInfoArr_g[ueIndex].dlUEContext_p,
                                    dlHarqProcess_p,internalCellIndex);
                        }
                    } 
                }
            }
        }
        /* SPR 9385 changes end*/
        return MAC_SUCCESS;
    }
    /* Remove sleep MAC RESET changes end*/
}
/****************************************************************************
 * Function Name  : ulCreateUeReqHPHandler 
 * Inputs         : ulRrcOamQNodeReq_p - Pointer to UL RRC OAM request
 *                  queue node
 *                  ulRrcOamQNodeResp_p - Pointer to UL RRC OAM response 
 *                  queue node
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : This function process/update the create  UE Request
 ****************************************************************************/
UInt32 ulCreateUeReqHPHandler(RrcOamHiPrioQNode *ulRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *ulRrcOamQNodeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    UInt32 ulBitMapValue = 0;
    ULCreateUeReq  *ulCreateUeReqNode_p  = PNULL;
    ULCreateUeResp *ulCreateUeRespNode_p = PNULL;
    ulCreateUeReqNode_p = &ulRrcOamQNodeReq_p->rrcOamReqResp.ulCreateUeReq;
    ulBitMapValue = ulCreateUeReqNode_p->createUEMsg;
    ulCreateUeRespNode_p = &ulRrcOamQNodeResp_p->rrcOamReqResp.ulCreateUeResp;
    ulCreateUeRespNode_p->ueIndex = ulCreateUeReqNode_p->ueIndex; 

    switch(ulBitMapValue)
    {
        case RRC_CONFIGURE_SHORT_SR_MAP:
        {
            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex = 
                /*CA Changes end  */
                ulCreateUeReqNode_p->activeIndexForShortSRMap ^0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_SHORT_SR_MAP \n "\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Passive Index for SHORT SR Map  = %d \n",
                    __func__,
                    /*CA Changes start  */
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_PUCCH_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForPUCCHMap;
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex = 
                /*CA Changes end  */
                ulCreateUeReqNode_p->activeIndexForPUCCHMap ^0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] "\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_PUCCH_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Passive Index for PUCCH Map  = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SR_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForPUCCHMap;
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex =
                ulCreateUeReqNode_p->activeIndexForPUCCHMap ^0x01;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRMap ^0x01;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SR_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Passive Index for PUCCH Map = %d \n"\
                    "passive Index for SHORT SR Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_SHORT_SRS_MAP:
        {
            /*CA Changes start  */
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRSMap;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                /*CA Changes end  */
                ulCreateUeReqNode_p->activeIndexForShortSRSMap ^0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_SHORT_SRS_MAP \n "\
                    "Active Index for SHORT SRS Map = %d \n"\
                    "Passive Index for SHORT SRS Map  = %d \n",
                    __func__,
                    /*CA Changes start  */
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_SHORT_SR_SHORT_SRS_MAP:
        {
            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRMap;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap ^0x01;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRSMap;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRSMap ^0x01;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_SHORT_SR_SHORT_SRS_MAP \n "\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for SHORT SRS Map = %d \n"\
                    "Passive Index for SHORT SR Map = %d \n"\
                    "Passive Index for SHORT SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SRS_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForPUCCHMap;
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForPUCCHMap ^0x01;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRSMap;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRSMap ^0x01;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SRS Map = %d \n"\
                    "Passive Index for PUCCH Map = %d \n"\
                    "Passive Index for SHORT SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SR_SHORT_SRS_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForPUCCHMap;
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForPUCCHMap ^0x01;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRMap;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRMap ^0x01;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRSMap;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForShortSRSMap ^0x01;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SR_SHORT_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for SHORT SRS Map = %d \n"\
                    "Passive Index for PUCCH Map = %d \n"\
                    "Passive Index for SHORT SR Map = %d \n"\
                    "Passive Index for SHORT SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex,
                    shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_LONG_SRS_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForLongSRSMap;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                ulCreateUeReqNode_p->activeIndexForLongSRSMap ^0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_LONG_SRS_MAP \n "\
                    "Active Index for LONG SRS Map = %d \n"\
                    "Passive Index for LONG SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_SHORT_SR_LONG_SRS_MAP:
        {
            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap ^0x01;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForLongSRSMap;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForLongSRSMap ^0x01;
            /*CA Changes end  */
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_SHORT_SR_LONG_SRS_MAP \n "\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for LONG SRS Map = %d \n"\
                    "Passive Index for SHORT SR Map = %d \n"\
                    "PAssive Index for LONG SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_PUCCH_LONG_SRS_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForPUCCHMap;
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForPUCCHMap ^0x01;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForLongSRSMap;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex =  
                /*CA Changes end  */
                ulCreateUeReqNode_p->activeIndexForLongSRSMap ^0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_PUCCH_LONG_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for LONG SRS Map = %d \n"\
                    "Passive Index for PUCCH Map  = %d \n"\
                    "Passive Index for LONG SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;
        case RRC_CONFIGURE_PUCCH_SHORT_SR_LONG_SRS_MAP:
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForPUCCHMap;
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex = 
                ulCreateUeReqNode_p->activeIndexForPUCCHMap ^0x01;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap;
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex =
                ulCreateUeReqNode_p->activeIndexForShortSRMap ^0x01;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex = 
                ulCreateUeReqNode_p->activeIndexForLongSRSMap;
            longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex =  
                /*CA Changes end  */
                ulCreateUeReqNode_p->activeIndexForLongSRSMap ^0x01;
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s]"\
                    "For Create UE:\n AT HP Side \n"\
                    "RRC_CONFIGURE_PUCCH_SHORT_SR_LONG_SRS_MAP \n "\
                    "Active Index for PUCCH Map = %d \n"\
                    "Active Index for SHORT SR Map = %d \n"\
                    "Active Index for LONG SRS Map = %d \n"\
                    "Passive Index for PUCCH Map  = %d \n"\
                    "Passive Index for SHORT SR Map = %d \n"\
                    "Passive Index for LONG SRS Map = %d \n",
                    __func__,
                    /*CA Changes start  */
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex,
                    longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex
                    /*CA Changes end  */
                    );
        }
        break;

    }
    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name  : ulDeleteUeReqHPHandler 
 * Inputs         : ulRrcOamQNodeReq_p - Pointer of uplink UE context Request
 *                  ulRrcOamQNodeResp_p- Pointer of uplink UE context Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC SUCCESS/MAC FAILURE 
 * Description    : This function process/update deletion UE Request
 ****************************************************************************/
UInt32 ulDeleteUeReqHPHandler(RrcOamHiPrioQNode *ulRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *ulRrcOamQNodeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    LTE_GCC_UNUSED_PARAM(ulRrcOamQNodeResp_p)
        UInt16 ueIndex = 0;
    /* CA changes Start */
    ulRrcOamDeleteUeQNodeReq_p[internalCellIndex] = ulRrcOamQNodeReq_p;
    /* CA changes End */
    /* SPR 13492 Changes Start */
#ifdef KPI_STATS
    UInt32 activeIndexForMacStats = 0;
    UInt8 qci                     = INVALID_QCI;
    UInt8 ueCountFlag             = FALSE;
#endif
    /* SPR 13492 Changes End */
    ueIndex = ulRrcOamQNodeReq_p->rrcOamReqResp.ulDeleteUeReq.ueIndex;  
    ulUECtxInfoArr_g[ueIndex].pendingDeleteFlag = TRUE;
    /* SPR 15408 Fix Start */
    /* SPR 19288 changes start */
    /* SPR 19288 changes start */
    /* SPR 13952 Changes Start */
    InitParams *initParams_p = cellSpecificParams_g.\
                               cellConfigAndInitParams_p[internalCellIndex]->initParams_p;
    UInt8 lcCount = 0;
    /* SPR 13952 Changes End */
    /* SPR 19288 changes end */
    ULUEContext *ueULContext_p = PNULL;
    ueULContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    if(ueULContext_p)
    {
        /* SPR 19288 changes start */
        /* SPR 13952 Changes Start */
        {
        if(UL_QOS_SCHEDULING == initParams_p->ulSchdConfig.ulSchedulerStrategy)
        {
            lcCount = 1;
            while((lcCount < MAX_LCID) && (ueULContext_p->numLogicalChannels))
            {
                if(255 != ueULContext_p->lcInfo[lcCount].lchId)
                {
                    /*CA Changes start  */
                    deleteULUELogicalChannel(ueULContext_p, ueULContext_p->lcInfo[lcCount].lchId, internalCellIndex);
                    /*CA Changes end  */
                }
                lcCount++;
            }
        }
        }
        /* SPR 13952 Changes End */
        /* SPR 19288 changes end */
        /* SPR 16916 FIX START */
#ifdef KPI_STATS
        updateNumOfActiveUeUlOnUeDelete(ueULContext_p->ueIndex,internalCellIndex);
#endif
        /* SPR 16916 FIX END */
/* SPR 22275 Fix + */
        if(PNULL != ueULContext_p->nonZeroBsrList_p)
        {
        deleteEntryFromNonZeroBSRList(ueULContext_p,ueULContext_p->nonZeroBsrList_p,internalCellIndex);
        }
        /* SPR 22275 Fix - */
        ueULContext_p->nonZeroBsrList_p = PNULL;
    }
    /* SPR 15408 Fix End */
    /* SPR 13492 Changes Start */
#ifdef KPI_STATS
    activeIndexForMacStats = (gMacStats.
            pStats->lteCommonKPIStats[internalCellIndex].activeIndexForMacStats);

    for (qci = 0; qci < MAX_QCI ; ++qci)
    {
        if(TRUE == ulUECtxInfoArr_g[ueIndex].inSessionTimePerQCIFlag[qci])
        {
            if (FALSE == ueCountFlag)
            {
                gMacStats.pStats->lteCommonKPIStats[internalCellIndex].
                    lteMacKPIStats[activeIndexForMacStats].totalSessionTimeUE++;
                ueCountFlag = TRUE;
            }
            gMacStats.pStats->lteCommonKPIStats[internalCellIndex].
                lteMacKPIStats[activeIndexForMacStats].totalSessionTimePerQCI[qci]++;

            /* set flag to FALSE to avoid incerementing counter on LP thread */
            ulUECtxInfoArr_g[ueIndex].inSessionTimePerQCIFlag[qci] = FALSE;
        }
    }
#endif
    /* SPR 13492 Changes End */
    return MAC_REQ_MSG_IN_USE;
}
/****************************************************************************
 * Function Name  : populateShortSRInfo 
 * Inputs         : pucchConfig_p - Pointer to update SR configuration
 *                  srConfigInfo_p - Pointer of SR Configuration received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCESS
 * Description    : This function Updates the short SR information 
 *                  in PUCCH context of UE.
 ****************************************************************************/
UInt32 populateShortSRInfo( PucchConfig *pucchConfig_p,SRConfigInfo *srConfigInfo_p
        /* CA changes Start */
        , InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    ULReconfigSRMsgType ulReconfigSrMsg = srConfigInfo_p->ulReconfigSrMsg;
    if(UL_RECONFIG_SR_MAP_MSG == ulReconfigSrMsg)
    {
        pucchConfig_p->srPeriodicity = srConfigInfo_p->srPeriodicity;

        pucchConfig_p->srOffset = srConfigInfo_p->srOffset;

        pucchConfig_p->srPUCCHRBIndex = srConfigInfo_p->srPUCCHRBIndex;

        pucchConfig_p->srProhibitTimerValv920 = srConfigInfo_p->srProhibitTimerValv920;
        /* PUCCH TDD ADAPTATION CHANGES Start */        
        pucchConfig_p->pucchShortSRNodeHead_p[
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex]=
            srConfigInfo_p->headShortSRNode_p;
        /* PUCCH TDD ADAPTATION CHANGES End */        
    }
    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name  : populateLongSRInfo 
 * Inputs         : pucchConfig_p - Pointer to update SR configuration
 *                  srConfigInfo_p - Pointer of SR Configuration received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCESS
 * Description    : This function Updates the Long SR information 
 *                  in PUCCH context of UE.
 ****************************************************************************/
/* +- SPR 17777 */
UInt32 populateLongSRInfo( PucchConfig *pucchConfig_p,SRConfigInfo *srConfigInfo_p
#ifdef TDD_CONFIG
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
#endif
        )
/* +- SPR 17777 */
{
    ULReconfigSRMsgType ulReconfigSrMsg = srConfigInfo_p->ulReconfigSrMsg;
    if(UL_RECONFIG_SR_MAP_MSG == ulReconfigSrMsg)
    {
        pucchConfig_p->srPeriodicity = srConfigInfo_p->srPeriodicity;

        pucchConfig_p->srOffset = srConfigInfo_p->srOffset;

        pucchConfig_p->srPUCCHRBIndex = srConfigInfo_p->srPUCCHRBIndex;

        pucchConfig_p->srProhibitTimerValv920 = srConfigInfo_p->srProhibitTimerValv920;
        /* PUCCH TDD ADAPTATION CHANGES Start */        
#ifdef TDD_CONFIG
        pucchConfig_p->maxSrWrapAround[
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
            srConfigInfo_p->maxSrWrapAround;
        /*CA Changes end  */
#endif
        /* PUCCH TDD ADAPTATION CHANGES End */        
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : populateCqiAperiodicInfo 
 * Inputs         : pucchConfig_p - Pointer to update PUCCH configuration
 *                  cqiAperiodicInfo_p - Pointer of CQI Aperiodic Info received
 * Outputs        : None
 * Returns        : MAC_SUCESS
 * Description    : This function Updates the Aperiodic CQI information 
 *                  in PUCCH context of UE.
 ****************************************************************************/
UInt32 populateCqiAperiodicInfo( PucchConfig *pucchConfig_p,ULCQIAperiodicInfo *cqiAperiodicInfo_p)
{
    pucchConfig_p->cqiPmiRiInfoAperiodic.cqiMode =
        cqiAperiodicInfo_p->cqiAperiodicMode;
    /* CA changes Start */
    pucchConfig_p->trigger1r10 = cqiAperiodicInfo_p->trigger1r10;
    pucchConfig_p->trigger2r10 = cqiAperiodicInfo_p->trigger2r10;
    /* CA changes End */
    return MAC_SUCCESS;
}

/* +- SPR 17777 */

/****************************************************************************
 * Function Name  : populateCqiPeriodicInfo 
 * Inputs         : pucchConfig_p - Pointer to update PUCCH configuration
 *                  cqiPeriodicReqInfo_p - Pointer of CQI periodic Info received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCESS
 * Description    : This function Updates the periodic CQI information 
 *                  in PUCCH context of UE.
 ****************************************************************************/
UInt32 populateCqiPeriodicInfo( PucchConfig *pucchConfig_p,ULCQIPeriodicReqInfo *cqiPeriodicReqInfo_p
        /* CA changes Start */
        , InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{

    RIConfigIndexInfo *riConfigIndexInfo_p = &(cqiPeriodicReqInfo_p->riConfigIndexInfo);

    ULReconfigCQIRIMsgType reconfigCQIRIRetValue = 
        cqiPeriodicReqInfo_p->cqiRiReconfigMsg;

    if (CQI_MAP_RECONFIGURE_IND & reconfigCQIRIRetValue)
    {    
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate CQI parameters\n" ,__func__);
        pucchConfig_p->cqiPmiConfigIndex = cqiPeriodicReqInfo_p->cqiPmiConfigIndex;
        pucchConfig_p->cqiPeriodicity = cqiPeriodicReqInfo_p->cqiPeriodicity;

        pucchConfig_p->cqiOffset = cqiPeriodicReqInfo_p->cqiOffset;
        pucchConfig_p->maxCQIWrapAround[
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
            /*CA Changes end  */
            cqiPeriodicReqInfo_p->maxCQIWrapAround;
        if( PERIODIC_FEEDBACK_SUBBAND ==
                pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType )
        {
            pucchConfig_p->maxWbCQIWrapAround[
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
                /*CA Changes end  */
                cqiPeriodicReqInfo_p->maxWbCQIWrapAround;
        }
        pucchConfig_p->cqiPUCCHRBIndex = cqiPeriodicReqInfo_p->cqiPUCCHRBIndex;

    }

    if(RI_MAP_RECONFIGURE_IND & reconfigCQIRIRetValue)
    {
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate RI parameters\n" ,__func__);

        pucchConfig_p->riConfigIndex = riConfigIndexInfo_p->riConfigIndex;

        pucchConfig_p->riPeriodicity = riConfigIndexInfo_p->riPeriodicity;
        pucchConfig_p->riOffset = riConfigIndexInfo_p->riOffset;
        pucchConfig_p->maxRIWrapAround[
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] =
            /*CA Changes end  */
            riConfigIndexInfo_p->maxRIWrapAround ;
    }
    if (CQI_MAP_RECONFIGURE_IND2 & reconfigCQIRIRetValue)
    {    
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate CQI parameters\n" ,__func__);
        pucchConfig_p->cqiPmiConfigIndex_2 = cqiPeriodicReqInfo_p->cqiPmiConfigIndex_2;
        pucchConfig_p->cqiPeriodicity_2 = cqiPeriodicReqInfo_p->cqiPeriodicity_2;
        pucchConfig_p->cqiOffset_2 = cqiPeriodicReqInfo_p->cqiOffset_2;
        pucchConfig_p->maxCQIWrapAround2[
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
            /*CA Changes end  */
            cqiPeriodicReqInfo_p->maxCQIWrapAround2;
        if( PERIODIC_FEEDBACK_SUBBAND ==
                pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType )
        {
            pucchConfig_p->maxWbCQIWrapAround2[
                /*CA Changes start  */
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
                /*CA Changes end  */
                cqiPeriodicReqInfo_p->maxWbCQIWrapAround2;
        }

    }

    if(RI_MAP_RECONFIGURE_IND2 & reconfigCQIRIRetValue)
    {
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate RI parameters\n" ,__func__);

        pucchConfig_p->riConfigIndex_2 = riConfigIndexInfo_p->riConfigIndex_2;

        pucchConfig_p->riPeriodicity_2 = riConfigIndexInfo_p->riPeriodicity_2;
        pucchConfig_p->riOffset_2 = riConfigIndexInfo_p->riOffset_2;
        pucchConfig_p->maxRIWrapAround2[
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] =
            /*CA Changes end  */
            riConfigIndexInfo_p->maxRIWrapAround2 ;

    }
    if((CQI_RESOURCE_INDEX_RECONFIGURE_IND & reconfigCQIRIRetValue) ||
            (RI_RESOURCE_INDEX_RECONFIGURE_IND & reconfigCQIRIRetValue) ||
            (CQI_RESOURCE_INDEX_RECONFIGURE_IND2 & reconfigCQIRIRetValue) ||
            (RI_RESOURCE_INDEX_RECONFIGURE_IND2 & reconfigCQIRIRetValue) )
    {
        pucchConfig_p->cqiPUCCHRBIndex = cqiPeriodicReqInfo_p->cqiPUCCHRBIndex;
    }

    /* Default configuration parameters for Periodic CQI 
     * are always over written whenever 
     * reconfiguration message is recieved */ 

    if(CQI_DEFAULT_PARAMETERS_IND & reconfigCQIRIRetValue)
    {
        /* Rel 5.3: Coverity 32224 Fix Start */
        pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType = (PeriodicFeedbackType)cqiPeriodicReqInfo_p->periodicFeedBackType;
        /* Rel 5.3: Coverity 32224 Fix End */
        /* Rel 5.3: Coverity 32225 Fix Start */
        pucchConfig_p->cqiPmiRiInfo.periodicRepMode = (PeriodicReportingModes)cqiPeriodicReqInfo_p->periodicRepMode;
        /* Rel 5.3: Coverity 32225 Fix End */
        pucchConfig_p->cqiPmiRiInfo.widebandPeriodicity  = cqiPeriodicReqInfo_p->widebandPeriodicity;
        pucchConfig_p->simultaneousAckNackAndCQI = cqiPeriodicReqInfo_p->simultaneousAckNackAndCQI;
    }
    switch(cqiPeriodicReqInfo_p->cqiPeriodicMsg)
    {
        case UL_RECONFIG_CQI_SUBBAND_K_MSG:
        pucchConfig_p->cqiPmiRiInfo.k = cqiPeriodicReqInfo_p->cqiFormatPeriodicSubbandK.subbandCQI_k;
        break;
        case UL_RECONFIG_CQI_SUBBAND_RI_MSG:
        pucchConfig_p->cqiPmiRiInfo.k = cqiPeriodicReqInfo_p->cqiFormatPeriodicSubbandK.subbandCQI_k;
        break;
        default: break;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : populateCQIInfo 
 * Inputs         : pucchConfig_p - Pointer to update PUCCH configuration
 *                  ulCqiReqInfo_p - Pointer of uplink CQI Info received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCESS
 * Description    : This function calls the appropriate function based on cqi Config
 ****************************************************************************/
UInt32 populateCQIInfo( PucchConfig *pucchConfig_p,ULCQIReqInfo *ulCqiReqInfo_p
        /* CA changes Start */
        , InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    switch(ulCqiReqInfo_p->cqiConfigMsg)
    {
        case UL_RECONFIG_CQI_APERIODIC_MSG:
        populateCqiAperiodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiAperiodicInfo);
        break;
        case UL_RECONFIG_CQI_PERIODIC_MSG:
        populateCqiPeriodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiPeriodicReqInfo
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                );
        break;
        case UL_RECONFIG_CQI_PERIODIC_APERIODIC_MSG:
        populateCqiPeriodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiPeriodicReqInfo
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                );
        populateCqiAperiodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiAperiodicInfo);
        break;
        default:
        break;
    }

    return MAC_SUCCESS;
}


/*****************************************************************************
 * Function Name  : ulReconfigUeReqHPHandler 
 * Inputs         : ulRrcOamQNodeReq_p - Pointer to UL RRC OAM request
 *                  queue node
 *                  ulRrcOamQNodeResp_p - Pointer to UL RRC OAM response 
 *                  queue node
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function processes and updates UL Reconfig UE Request
 *****************************************************************************/
UInt32 ulReconfigUeReqHPHandler(RrcOamHiPrioQNode *ulRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *ulRrcOamQNodeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    ULReconfigUeReq *ulReconfigUeReq_p = &ulRrcOamQNodeReq_p->rrcOamReqResp.ulReconfigUeReq;
    ULReconfigUeResp *ulReconfigUeResp_p = &ulRrcOamQNodeResp_p->rrcOamReqResp.ulReconfigUeResp;
    UInt16 ueIndex = ulReconfigUeReq_p->ueIndex;
    ULUEContext *ulUEContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    UInt8 tlvIndex;
    UInt32 returnType ;
    ulReconfigUeResp_p->ueIndex = ueIndex;
    UInt32 tlvType = 0;
    /* EICIC +*/
    UserType oldUeType;
    UserType newUeType;
    ULSchedulerStrategyConfig *ulSchdConfig_p = & cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->initParams_p->ulSchdConfig;
    /* EICIC -*/
    /* + CQI_5.0 */
    ulUEContext_p->periodicCQIDroppedCounter = 0;
    ulUEContext_p->lastTriggeredAperiodicTTI = 0;

    /* SPR 15333 changes start */ 
    /* In ulReconfigUeReqHPHandler() there is no need to initialize  
       ulUEContext_p->aperiodicCqiRequestTTI and ulUEContext_p->aperiodicCQIToBeRequested.
       So need to comment these two initializations. */
    /* SPR 15333 changes end */
    /* - CQI_5.0 */
    /*HD FDD Changes Start*/
#ifdef HD_FDD_CONFIG
    UInt8 isUeSwitchFromFDToHD = FALSE;
#endif
    /*HD FDD Changes End*/
    for (tlvIndex = 0; tlvIndex < ulReconfigUeReq_p->ueReconfigMsgTlvCount ; tlvIndex++)
    {
        tlvType = ulReconfigUeReq_p->ueReconfigTlvRecieved[tlvIndex];
        switch(tlvType)
        {
            case UL_RECONFIG_PUCCH_CONFIG_INFO:
            {
                /* Cyclomatic Complexity changes - starts here */
                processAndUpdateULReconfigPucchInfo (ueIndex, ulUEContext_p, 
                        ulReconfigUeReq_p, ulReconfigUeResp_p,
                        internalCellIndex);
                /* Cyclomatic Complexity changes - ends here */

                break;
            }
            case UL_RECONFIG_UE_CATEGORY:
            {
                ulUEContext_p->ueCategory = ulReconfigUeReq_p->ueCategoryInfo.ueCategory;
                ulUEContext_p->maxTBSize = ulReconfigUeReq_p->ueCategoryInfo.maxTBSize;
                break;
            }
            case UL_RECONFIG_SRS_DEDICATED_CONFIG:
            {
                /* Cyclomatic Complexity changes - starts here */
                processAndUpdateULReconfigSRSConfig (ulUEContext_p, 
                        ulReconfigUeReq_p, ulReconfigUeResp_p
                        /* CA changes Start */
                        , internalCellIndex
                        /* CA changes End */
                        );
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            case UL_RECONFIG_P0_UE_PUSCH:
            {
                ulUEContext_p->dedicatedULPowerControlInfo.p0UePusch = 
                    ulReconfigUeReq_p->p0UePuschInfo.p0UePusch;

                ulUEContext_p->prevPowerCorrectionForPusch =
                    ulReconfigUeReq_p->p0UePuschInfo.prevPowerCorrectionForPusch;

                ulUEContext_p->currPowerCorrectionForPusch =
                    ulReconfigUeReq_p->p0UePuschInfo.currPowerCorrectionForPusch;

                ulUEContext_p->powerControlPuschTPCValue=
                    ulReconfigUeReq_p->p0UePuschInfo.powerControlPuschTPCValue;

                break;
            }
            case UL_RECONFIG_TPC_PDCCH_CONFIG_PUSCH:
            {
                returnType = reconfigureTpcPdcchConfigInfoForPusch(
                        ulReconfigUeReq_p->tpcPDCCHConfigPUSCHInfo.release,
                        ulReconfigUeReq_p->tpcPDCCHConfigPUSCHInfo.tpcRnti,
                        ulReconfigUeReq_p->tpcPDCCHConfigPUSCHInfo.tpcIndex,
                        ulReconfigUeReq_p->tpcPDCCHConfigPUSCHInfo.isConfiguredForDci3Or3A,
                        ulUEContext_p,
                        internalCellIndex);
                if (returnType ==  MAC_FAILURE)
                {
                    return returnType;
                }            
                break;
            }
            case UL_RECONFIG_CONFIGURE_LC_REQ:
            {                
                if(MAC_SUCCESS == ulConfigureLcInfo(ulReconfigUeReq_p,
                            ulUEContext_p
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            ))
                {
                    UInt8 lcCount = 0;
                    ulReconfigUeResp_p->ulReconfigLcResp.numLogicalChannels = \
                                                                              ulReconfigUeReq_p->ulReconfigLcReq.numLogicalChannels;
                    for(lcCount = 0; lcCount < ulReconfigUeReq_p->ulReconfigLcReq.numLogicalChannels; lcCount++)
                    {
                        ulReconfigUeResp_p->ulReconfigLcResp.lcInfo[lcCount] =
                            ulReconfigUeReq_p->ulReconfigLcReq.lcInfo[lcCount]; 
                    }
                }
                break;
            }
            /** HD FDD Changes start **/
#ifdef HD_FDD_CONFIG
            case UL_RECONFIG_RF_PARAMS:
            {
                if( (TRUE==ulReconfigUeReq_p->rfParams) )
                {
                    /** if ue is being made HD from either earlier type HD or FD
                     ** UE is already added in global list via DL operation **/
                    if(FALSE == ulUEContext_p->isHDFddFlag)
                    {
                        isUeSwitchFromFDToHD = TRUE;
                    }
                }
                else if((TRUE==ulUEContext_p->isHDFddFlag) && (FALSE==ulReconfigUeReq_p->rfParams))
                {
                    /** ue is being confirgured from HD to FD
                     ** UE is already deleted in global list via DL operation **/
                    ulUEContext_p->isHDFddFlag = FALSE;
                }
                break;
            }
#endif
            /** HD FDD Changes end **/

            case UL_RECONFIG_SPS_PARAMS:
            {
                /* Cyclomatic Complexity changes - starts here */
                if (MAC_SUCCESS != processAndUpdateULReconfigSPSParams (ulUEContext_p, 
                            ulReconfigUeReq_p,internalCellIndex))
                {
                    return MAC_FAILURE;
                }
                /* Cyclomatic Complexity changes - ends here */
                break;
            }
            /*SPR 21501 fix start*/
            case UL_RECONFIG_TTI_BUNDLING:
            {
                if ( (ulUEContext_p->ttiBundlingEnabled != ulReconfigUeReq_p->ttiBundlingEnabled )
                        &&(ulUEContext_p->spsUlInfo.spsState == SPS_ACTIVATED))
                {
                    /* Add a node to SPS Deactivation Queue */
                    triggerSpsExplicitRelease(ulUEContext_p,TTI_BUNDLING_CONFIG_CHANGED
                            /* CA changes Start */
                            , internalCellIndex
                            /* CA Changes end */
                            );                
                }
                ulUEContext_p->ttiBundlingEnabled = ulReconfigUeReq_p->ttiBundlingEnabled ;
                LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] In HP (UL_RECONFIG_TTI_BUNDLING) ttiBundling = %d \n",
                        __func__,ulUEContext_p->ttiBundlingEnabled);

                break;
            }
            /*SPR 21501 fix end*/
            /*REL10_CR_CHANGES_START*/
            /* + Coverity 54153 */
            case UL_RECONFIG_MAX_UL_HARQ_TX_INFO:
            /* - Coverity 54153 */
            {
                ulUEContext_p->maxUlHARQTx = ulReconfigUeReq_p->maxUlHARQTx;
                break;
            }
            /* + coverity 54154 */
            case UL_RECONFIG_PC_MAX_INFO:
            /* - coverity 54154 */
            {
                ulUEContext_p->pcMax = ulReconfigUeReq_p->pcMax;
                break;
            }
            /* + coverity 54155 */            
            case  UL_RECONFIG_PUSCH_CONFIG_INFO:
            /* - coverity 54155 */            
            {
                ulUEContext_p->puschConfigInfo =  ulReconfigUeReq_p->puschConfigInfo;
                break;
            }
            /*REL10_CR_CHANGES_END*/
            /* CA changes Start */
            case UL_RECONFIG_UE_CATEGORY_V1020:
            {
                ulUEContext_p->ueCategoryV1020 = ulReconfigUeReq_p->
                    ueCategoryInfov1020.ueCategoryV1020;
                ulUEContext_p->maxTBSize = ulReconfigUeReq_p->
                    ueCategoryInfov1020.maxTBSize;
                break;
            }
            case UL_RECONFIG_PUCCH_CONFIG_INFO_V1020:
            {
                macProcessAndUpdateULReconfigPucchInfoV1020 (ulUEContext_p, 
                        ulReconfigUeReq_p);
                break;
            }
            case UL_RECONFIG_CA_CONFIG_INFO:
            {
                /* +- SPR 17777 */
                if( MAC_FAILURE == macProcessAndUpdateULReconfigCAConfig (
#ifdef HD_FDD_CONFIG
                            ueIndex,
#endif
                            /* +- SPR 17777 */
                            ulReconfigUeReq_p, ulUEContext_p,
                            ulReconfigUeResp_p, internalCellIndex))
                {
                    return MAC_FAILURE;
                }
                break;
            }
            case UL_RECONFIG_INTERFERENCE_INFO:
            {

                oldUeType = ulUEContext_p->userType;
                newUeType = ulReconfigUeReq_p->interferenceConfigUL.userType;

                ulUEContext_p->userType= ulReconfigUeReq_p->interferenceConfigUL.userType;

                if (oldUeType != newUeType)
                {
                    if (UL_QOS_SCHEDULING == ulSchdConfig_p->ulSchedulerStrategy)
                    {
                        macReconfigureUlUeLCTree(internalCellIndex, ulUEContext_p);
                        macReconfigureUlUeGBR(internalCellIndex, ulUEContext_p);
                    }
                }

                break;
            }
            /* CA changes End */
            /* SPR 23402 Changes Start */
            /* MOCN Changes Start */
            case  UL_RECONFIG_OPERATOR_ID_INFO:
            {
                ulUEContext_p->operatorId =  ulReconfigUeReq_p->operatorId;
                break;
            }
            /* MOCN Changes End */
            /* SPR 23402 Changes End */
            default:
            {
                lteWarning ("Invalid TLV Type %d received\n", tlvType);
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tlvType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid TLV Type received");
                /* Review comment fix end RJ13 */
                break;
            }
        }
    }

    /** HD FDD Changes start **/
#ifdef HD_FDD_CONFIG
    if (isUeSwitchFromFDToHD == TRUE)
    {
        ulUEContext_p->isHDFddFlag = TRUE;
        hdFddCtxConfigReconfigUpdate(ulUEContext_p->ueIndex);
        /* SPR 11940 start*/        
        hdFddCtxReconfigUpdateReports(ulUEContext_p, internalCellIndex);
        /* SPR 11940 end*/        
    }
#endif
    /** HD FDD Changes end **/
    if(ulReconfigUeReq_p->ulAmbr)
    {
        ulUEContext_p->ulAmbrInfo.AMBR = ulReconfigUeReq_p->ulAmbr;
        /* Cyclomatic Complexity changes - starts here */
        if( MAC_SUCCESS != processAndUpdateULReconfigAmbrInfo (ulUEContext_p) )
        {
            return MAC_FAILURE;
        }
        /* Cyclomatic Complexity changes - ends here */
    }

    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : processAndUpdateULReconfigPucchInfo
 * Inputs         : ueIndex - Stores UE index
 *                  ulUEContext_p - Pointer to UL UE Context
 *                  ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 *                  ulReconfigUeResp_p - Pointer to UL Reconfig UE Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes and updates the UL Reconfig PUCCH
 *                  Config information
 *****************************************************************************/
STATIC  void processAndUpdateULReconfigPucchInfo( UInt16 ueIndex, 
        ULUEContext *ulUEContext_p, ULReconfigUeReq *ulReconfigUeReq_p,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex)
{
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    RRCInfPUCCHConfigResInfo *rrcInfpucchConfigResInfo_p = 
        &ulReconfigUeResp_p->rrcInfpucchConfigResInfo;
    RRCInfPUCCHConfigReqInfo *rrcInfpucchConfigReqInfo_p = 
        &ulReconfigUeReq_p->rrcInfpucchConfigReqInfo;
    ULCQIResInfo *ulCQIResInfo_p = &rrcInfpucchConfigResInfo_p->ulCqiResInfo;
    ULCQIReqInfo *ulCQIReqInfo_p = &rrcInfpucchConfigReqInfo_p->ulCqiReqInfo;
    PucchConfig *pucchConfig_p = &ulUEContext_p->pucchConfigInfo;
    SRConfigInfo *srConfigInfo_p = &rrcInfpucchConfigReqInfo_p->srConfigInfo;

    rrcInfpucchConfigResInfo_p->switchActiveToPassiveFlag =
        rrcInfpucchConfigReqInfo_p->switchPassiveToActiveFlag;

    rrcInfpucchConfigResInfo_p->pucchConfigMsg =
        rrcInfpucchConfigReqInfo_p->pucchConfigMsg;

    /* CA changes start */
    if ( (FALSE != rrcInfpucchConfigReqInfo_p->ulCqiReqInfo.cqiAperiodicInfo.trigger1r10)
            && (FALSE != rrcInfpucchConfigReqInfo_p->ulCqiReqInfo.cqiAperiodicInfo.trigger2r10))
    {
        ulUEContext_p->trigger1r10 = rrcInfpucchConfigReqInfo_p->ulCqiReqInfo.cqiAperiodicInfo.trigger1r10;
        ulUEContext_p->trigger2r10 = rrcInfpucchConfigReqInfo_p->ulCqiReqInfo.cqiAperiodicInfo.trigger2r10;
    }
    /* CA changes end */

    /* SR Configuration */
    if(rrcInfpucchConfigReqInfo_p->pucchConfigMsg & UL_RECONFIG_SR_IND)
    {
        rrcInfpucchConfigResInfo_p->ulReconfigSrMsg = 
            srConfigInfo_p->ulReconfigSrMsg;
        rrcInfpucchConfigResInfo_p->mapReconfigSrMsg = 
            srConfigInfo_p->mapReconfigSrMsg;

        if(( UL_RECONFIG_ADD_SHORT_SR_NODE & srConfigInfo_p->mapReconfigSrMsg ) ||
                (UL_RECONFIG_DELETE_SHORT_SR_NODE & srConfigInfo_p->mapReconfigSrMsg ))
        {
            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForShortSRMap;

            populateShortSRInfo(pucchConfig_p,
                    &rrcInfpucchConfigReqInfo_p->srConfigInfo
                    ,internalCellIndex);

            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForShortSRMap ^ 0x01;
            /* SPR 16143 fix start */
            LOG_MAC_MSG( MAC_HP_THREAD_PROCESS_RRC_MSG, LOGINFO, MAC_RRC_INF,
                    getCurrentTick(), __LINE__, ueIndex, 
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex,
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex,
                    0, 
                    0,0, __func__, "ShortSRNode" );
            /* SPR 16143 fix end */
        }

        if(( UL_RECONFIG_ADD_LONG_SR_NODE & srConfigInfo_p->mapReconfigSrMsg ) ||
                ( UL_RECONFIG_DELETE_LONG_SR_NODE & srConfigInfo_p->mapReconfigSrMsg ))
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap;

            populateLongSRInfo(pucchConfig_p,
                    &rrcInfpucchConfigReqInfo_p->srConfigInfo
                    /* +- SPR 17777 */
#ifdef TDD_CONFIG
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
#endif
                    );
            /* +- SPR 17777 */

            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap ^ 0x01;
            /* SPR 16143 fix start */
            LOG_MAC_MSG( MAC_HP_THREAD_PROCESS_RRC_MSG, LOGINFO, MAC_RRC_INF,
                    getCurrentTick(), __LINE__, ueIndex, 
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                    0, 
                    0,0, __func__, "LongSRNode" );
            /* SPR 16143 fix end */
        }

        if( UL_RECONFIG_UPDATE_LONG_SR_NODE & srConfigInfo_p->mapReconfigSrMsg )
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap;

            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap ^ 0x01;

            pucchConfig_p->srPUCCHRBIndex = srConfigInfo_p->srPUCCHRBIndex;
            /* SPR 16143 fix start */
            LOG_MAC_MSG( MAC_HP_THREAD_PROCESS_RRC_MSG, LOGINFO, MAC_RRC_INF,
                    getCurrentTick(), __LINE__, ueIndex, 
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex, 
                    longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex, 
                    0, 
                    0,0, __func__, "LongSRNode" );
            /* SPR 16143 fix end */
        }

        if( UL_RECONFIG_UPDATE_SHORT_SR_NODE & srConfigInfo_p->mapReconfigSrMsg )
        {
            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForShortSRMap;

            /*CA Changes start  */
            shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForShortSRMap ^ 0x01;

            pucchConfig_p->srPUCCHRBIndex = srConfigInfo_p->srPUCCHRBIndex;
            /* SPR 16143 fix start */
            LOG_MAC_MSG( MAC_HP_THREAD_PROCESS_RRC_MSG, LOGINFO, MAC_RRC_INF,
                    getCurrentTick(), __LINE__, ueIndex, 
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex, 
                    shortPeriodicSRMapShortInfo_gp[internalCellIndex]->passiveIndex, 
                    0, 
                    0,0, __func__, "ShortSrNode" );
            /* SPR 16143 fix end */
        }
    }

#ifdef HD_FDD_CONFIG
    if((TRUE==ulUEContext_p->isHDFddFlag))
    {
        /* The SR half duplex map not updated in above conditions because there may be
         * deletion and updation and will take unnecessary 2 operations */
        /* If SRS periodicity is short */
        if (SHORT_SR_PERIODICITY > pucchConfig_p->srPeriodicity)
        {
            /* if current map is NULL, means the reports are deleted */
            /* PUCCH TDD ADAPTATION CHANGES Start */        
            if (!(pucchConfig_p->pucchNodesForSR[shortPeriodicSRMapShortInfo_gp[internalCellIndex]->activeIndex].count))
                /* PUCCH TDD ADAPTATION CHANGES End */        
            {
                /* Reset all the SR parameters in static map */
                HD_UE_RESET_REPORT_INFO(ueIndex, HD_UE_STATIC_MAP_SR);
            }
            else
            {
                /* Reconfig all the SR parameters in static map */
                updateHDFddSemiStaticMap(ueIndex, HD_UE_STATIC_MAP_SR);
            }
        }
        else /* long SR */
        {
            /* if current map is NULL, means the reports are deleted */
            /* PUCCH TDD ADAPTATION CHANGES Start */        
            if (!(pucchConfig_p->pucchNodesForSR[longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex].count))
                /* PUCCH TDD ADAPTATION CHANGES End */        
            {
                /* Reset all the SR parameters in static map */
                HD_UE_RESET_REPORT_INFO(ueIndex, HD_UE_STATIC_MAP_SR);
            }
            else
            {
                /* Reconfig all the SR parameters in static map */
                updateHDFddSemiStaticMap(ueIndex, HD_UE_STATIC_MAP_SR);
            }
        }
    }
#endif

    /* CQI Configuration */
    if(rrcInfpucchConfigReqInfo_p->pucchConfigMsg & UL_RECONFIG_CQI_IND)
    {
        if(0 != rrcInfpucchConfigReqInfo_p->switchPassiveToActiveFlag ) 
        {
            /*CA Changes start  */
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap;

            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap ^ 0x01;
        }
        rrcInfpucchConfigResInfo_p->ulReconfigCqiRiMsg = 
            ulCQIReqInfo_p->cqiPeriodicReqInfo.cqiRiReconfigMsg;

        ulCQIResInfo_p->cqiConfigMsg = ulCQIReqInfo_p->cqiConfigMsg;

        ulCQIResInfo_p->cqiPeriodicResInfo.cqiPeriodicMsg =
            ulCQIReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg;

        populateCQIInfo( pucchConfig_p, 
                &rrcInfpucchConfigReqInfo_p->ulCqiReqInfo 
                /* CA changes Start */
                , internalCellIndex
                /* CA Changes end */
                );

        if(PERIODIC_FEEDBACK_SUBBAND == 
                pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType &&
                FREQUENCY_SELECTIVE_ON == cellParams_p->freqSelectiveSchDL)
        {
            initBandwidthPart(ulUEContext_p,internalCellIndex);
        }   
        /* SPR 16143 fix start  */
        LOG_MAC_MSG( MAC_HP_THREAD_PROCESS_RRC_MSG, LOGINFO, MAC_RRC_INF,
                getCurrentTick(), __LINE__, ueIndex, 
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex,
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex,
                0,
                0,0, __func__, "CqiNode" );
        /* SPR 16143 fix end */
    }
    /** HD FDD Changes **/
#ifdef HD_FDD_CONFIG
    if((TRUE==ulUEContext_p->isHDFddFlag))
    {
        /* if current map is NULL, means the reports are deleted 
         * checking only CQI map not RI as both are deleted at the same time */
        /* PUCCH TDD ADAPTATION CHANGES Start */        
        if (!(pucchConfig_p->pucchNodesForCqi[longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex].count))
            /* PUCCH TDD ADAPTATION CHANGES End */        
        {
            /* Reset all the CQI/PMI/RI parameters in static map */
            HD_UE_RESET_REPORT_INFO(ueIndex, HD_UE_STATIC_MAP_CQI_PMI);
            HD_UE_RESET_REPORT_INFO(ueIndex, HD_UE_STATIC_MAP_RI);
        }
        else
        {
            /* Reconfig all the CQI/PMI/RI parameters in static map */
            updateHDFddSemiStaticMap(ueIndex, HD_UE_STATIC_MAP_CQI_PMI);
            updateHDFddSemiStaticMap(ueIndex, HD_UE_STATIC_MAP_RI);
        }
    }
#endif
}

/******************************************************************************
 * Function Name  : processAndUpdateULReconfigSRSConfig 
 * Inputs         : ulUEContext_p - Pointer to UL UE Context
 *                  ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 *                  ulReconfigUeResp_p - Pointer to UL Reconfig UE Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes and updates the UL Reconfig SRS
 *                  Dedicated config information
 *****************************************************************************/
STATIC  void processAndUpdateULReconfigSRSConfig( 
        ULUEContext *ulUEContext_p, ULReconfigUeReq  *ulReconfigUeReq_p,
        ULReconfigUeResp *ulReconfigUeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    ULSRSDedicatedConfigReqInfo *ulSRSDedicatedConfigReqInfo_p = 
        &ulReconfigUeReq_p->ulSRSDedicatedConfigReqInfo;
    ULSRSDedicatedConfigResInfo *ulSRSDedicatedConfigResInfo_p =
        &ulReconfigUeResp_p->ulSRSDedicatedConfigResInfo;

    ulSRSDedicatedConfigResInfo_p->switchActiveToPassiveSRSFlag = 
        ulSRSDedicatedConfigReqInfo_p->switchPassiveToActiveSRSFlag;

    ulSRSDedicatedConfigResInfo_p->mapReconfigMsg = 
        ulSRSDedicatedConfigReqInfo_p->mapReconfigMsg;

    ulUEContext_p->srsConfigInfo.srsConfigType = 
        ulSRSDedicatedConfigReqInfo_p->srsConfigType;

    ulUEContext_p->srsConfigInfo.srsPeriodicity =
        ulSRSDedicatedConfigReqInfo_p->srsPeriodicity;

    ulUEContext_p->srsConfigInfo.srsSubFrameOffset = 
        ulSRSDedicatedConfigReqInfo_p->srsOffset;

    ulUEContext_p->srsConfigInfo.srsDedicatedSetupInfo = 
        ulSRSDedicatedConfigReqInfo_p->srsDedicatedSetupInfo;

    if(TRUE == ulSRSDedicatedConfigReqInfo_p->switchPassiveToActiveSRSFlag)
    {   
        if( UL_RECONFIG_DELETE_SHORT_SRS_NODE & ulSRSDedicatedConfigReqInfo_p->mapReconfigMsg )
        {
            /*CA Changes start  */
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex = 
                ulSRSDedicatedConfigReqInfo_p->activeIndexForShortSRSMap ;
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->activeIndexForShortSRSMap ^ 0x01;
            /*CA Changes start  */
            ulUEContext_p->srsConfigInfo.srsReportHeadNode_p[shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex]=
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->srsReportHeadNode_p;
        }
        if( UL_RECONFIG_DELETE_LONG_SRS_NODE & ulSRSDedicatedConfigReqInfo_p->mapReconfigMsg )
        {
            /*CA Changes start  */
            longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex = 
                ulSRSDedicatedConfigReqInfo_p->activeIndexForLongSRSMap ;

            longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex = 
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->activeIndexForLongSRSMap ^ 0x01;

            /*CA Changes start  */
            ulUEContext_p->srsConfigInfo.srsReportHeadNode_p[longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex]=
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->srsReportHeadNode_p; 
        }
        if( UL_RECONFIG_ADD_SHORT_SRS_NODE & ulSRSDedicatedConfigReqInfo_p->mapReconfigMsg )
        {
            /*CA Changes start  */
            shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex =
                ulSRSDedicatedConfigReqInfo_p->activeIndexForShortSRSMap;

            shortPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->activeIndexForShortSRSMap ^ 0x01;
            /*CA Changes start  */
            ulUEContext_p->srsConfigInfo.srsReportHeadNode_p[shortPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex]=
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->srsReportHeadNode_p;
        }

        if( UL_RECONFIG_ADD_LONG_SRS_NODE & ulSRSDedicatedConfigReqInfo_p->mapReconfigMsg )
        {
            /*CA Changes start  */
            longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex =
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->activeIndexForLongSRSMap;

            /*CA Changes start  */
            ulUEContext_p->srsConfigInfo.srsReportHeadNode_p[longPeriodicSRSMapInfo_gp[internalCellIndex]->activeIndex]=
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->srsReportHeadNode_p; 

            /*CA Changes start  */
            longPeriodicSRSMapInfo_gp[internalCellIndex]->passiveIndex =
                /*CA Changes end  */
                ulSRSDedicatedConfigReqInfo_p->activeIndexForLongSRSMap ^ 0x01;
        }
    }

#ifdef HD_FDD_CONFIG
    /* This is updated for the case when DL/UL split is set.
     * In case of non DL/UL split it is called from low priority handler
     * Handles both setup and release */
    if((TRUE==ulUEContext_p->isHDFddFlag))
    {
        updateHDFddSemiStaticMapSRS(
                ulUEContext_p->ueIndex,
                ulUEContext_p->srsConfigInfo.srsPeriodicity,
                /* +- SPR 17777 */
                ulSRSDedicatedConfigReqInfo_p->srsDedicatedSetupInfo.duration,
                ulUEContext_p->srsConfigInfo.srsConfigType);
    }
#endif
}

/******************************************************************************
 * Function Name  : processAndUpdateULReconfigSPSParams 
 * Inputs         : ulUEContext_p - Pointer to UL UE Context
 *                  ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 *                  ulReconfigUeResp_p - Pointer to UL Reconfig UE Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function processes and updates the UL Reconfig SPS
 *                  parameters
 *****************************************************************************/
STATIC  MacRetType processAndUpdateULReconfigSPSParams(
        ULUEContext *ulUEContext_p, ULReconfigUeReq *ulReconfigUeReq_p,
        InternalCellIndex internalCellIndex)
{
    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    LP_SpsUlInfo  spsUlInfo_p = &ulUEContext_p->spsUlInfo;
    RNTIInfo *rntiInfo_p        = PNULL;

    /* SPR 20456 start */
    if( ulReconfigUeReq_p->spsUlInfo.requestType == spsUlInfo_p->requestType )
    {
        /* do nothing */
    }    
    else
    {    
        spsUlInfo_p->requestType = ulReconfigUeReq_p->spsUlInfo.requestType ;

        if(ulReconfigUeReq_p->spsUlInfo.requestType == SPS_RELEASE)
            /* SPR 20456 stop */    
        {
            /*! \code
             * If spsDownlinkInfo.requestType == SPS_RELEASE
             *   -Deallocate the SpsCrnti.
             *   -Update the SPS State. 
             *   -Free the Memory of spsUlSetupInfo_p.
             * \endcode
             * */ 
            /* SPS RNTI DE Allocation only if DL SPS Config is release */
            if (PNULL == dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p || 
                    SPS_RELEASE == dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p->spsDlInfo.requestType)
            {
                deAllocateSpsCrnti(spsUlInfo_p->SpsCrnti, internalCellIndex);
                /* Reset the SPS Crnti in DL/UL UE Context */
                spsUlInfo_p->SpsCrnti = 0;
                if (PNULL != dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p)
                {
                    dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p->spsDlInfo.SpsCrnti = 0;
                }
            }
            /*CA Changes start  */
            ulSpsPendingDeleteHandling(ulUEContext_p, internalCellIndex);
            /*CA Changes end  */
            spsUlInfo_p->spsState = INVALID_STATE;
        }
        /* SPR 20456 code deleted */    
    }  
    /*! \code
     * IF Sps Req type is setup
     *    - Save the sps crnti in Ue context
     *    -Populating the SPS Info in UE Context recived from L3 
     * \endcode
     * */
    if(PNULL != dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p && 
            SPS_SETUP == dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p->spsDlInfo.requestType )
    {
        spsUlInfo_p->SpsCrnti = dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p->
            spsDlInfo.SpsCrnti;
        /*CA Changes start  */
        rntiInfo_p = getUeIdxFromRNTIMap( spsUlInfo_p->SpsCrnti, internalCellIndex);
        /*CA Changes end  */
        if (PNULL == rntiInfo_p)
        {
            LOG_MAC_MSG( MAC_UE_ID_RNTI_MAP, LOGWARNING, MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, spsUlInfo_p->SpsCrnti, 
                    ulUEContext_p->crnti, ulUEContext_p->ueIndex, internalCellIndex, 
                    0,0, __func__, "" );
            return MAC_FAILURE;
        }
        rntiInfo_p->rntiFlag = SPS_RNTI;
        rntiInfo_p->index    = ulUEContext_p->ueIndex;
        ulUEContext_p->spsUeSearchSpaceInfo_p = (&rntiInfo_p->ueSearchSpaceInfo_p[internalCellIndex][0]);
    }
    else
    {
        UInt16  spsCrnti = allocateSpsCrnti(internalCellIndex);
        if( MAC_FAILURE == spsCrnti )
        {
            return MAC_FAILURE;
        }
        else
        {
            spsUlInfo_p->SpsCrnti = spsCrnti;
            /* Allocate Sps Crnti in DL Context */
            if(PNULL != dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p) 
            {
                dlUECtxInfoArr_g[ulUEContext_p->ueIndex].dlUEContext_p->
                    spsDlInfo.SpsCrnti = spsCrnti;
            }
            /*CA Changes start  */
            rntiInfo_p = getUeIdxFromRNTIMap( spsUlInfo_p->SpsCrnti, internalCellIndex );
            /*CA Changes end  */
            if (PNULL == rntiInfo_p)
            {
                LOG_MAC_MSG( MAC_UE_ID_RNTI_MAP, LOGWARNING, MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, spsCrnti, 
                        ulUEContext_p->crnti, ulUEContext_p->ueIndex, internalCellIndex,
                        0,0, __func__, "" );
                return MAC_FAILURE;
            }
            rntiInfo_p->rntiFlag = SPS_RNTI;
            rntiInfo_p->index    = ulUEContext_p->ueIndex;
            ulUEContext_p->spsUeSearchSpaceInfo_p = (&rntiInfo_p->ueSearchSpaceInfo_p[internalCellIndex][0]);
        }
    }

    GET_MEM_FROM_POOL( spsUlSetupInfo, spsUlInfo_p->spsUlSetupInfo_p,
            sizeof (spsUlSetupInfo),PNULL);
    if (spsUlInfo_p->spsUlSetupInfo_p == PNULL)
    {
        return MAC_FAILURE;
    }
    else
    {
        spsUlInfo_p->spsUlSetupInfo_p->semiPersistentSchedIntervalUL = 
            ulReconfigUeReq_p->spsUlInfo.semiPersistentSchedIntervalUL ;
        spsUlInfo_p->spsUlSetupInfo_p->implicitReleaseAfter =
            ulReconfigUeReq_p->spsUlInfo.implicitReleaseAfter ;

        if(TRUE == ulReconfigUeReq_p->spsUlInfo.isP0TagPresent)
        {
            spsUlInfo_p->spsUlSetupInfo_p->isP0TagPresent = TRUE;
            spsUlInfo_p->spsUlSetupInfo_p->p0PersistentInfo.
                p0NominalPuschPersistent = ulReconfigUeReq_p->spsUlInfo.
                p0PersistentInfo.p0NominalPuschPersistent;
            spsUlInfo_p->spsUlSetupInfo_p->p0PersistentInfo.
                p0UePuschPersistent = ulReconfigUeReq_p->spsUlInfo.
                p0PersistentInfo.p0UePuschPersistent;
        }
        else
        {
            /*Assigning the Normal values */
            spsUlInfo_p->spsUlSetupInfo_p->p0PersistentInfo.
                p0NominalPuschPersistent = cellParams_p-> \
                commonULPowerControlInfo.p0NominalPUSCH;
            spsUlInfo_p->spsUlSetupInfo_p->p0PersistentInfo.
                p0UePuschPersistent = ulUEContext_p->
                dedicatedULPowerControlInfo.p0UePusch;
        }
        if(TRUE == ulReconfigUeReq_p->spsUlInfo.isTwoIntervalConfigPresent)
        {
            spsUlInfo_p->spsUlSetupInfo_p->isTwoIntervalConfigPresent = TRUE;
            spsUlInfo_p->spsUlSetupInfo_p->twoIntervalsConfig = 
                ulReconfigUeReq_p->spsUlInfo.twoIntervalsConfig;
        }
        /* + SPS_TDD_Changes */
        else
        {
            spsUlInfo_p->spsUlSetupInfo_p->isTwoIntervalConfigPresent = FALSE;
            spsUlInfo_p->spsUlSetupInfo_p->twoIntervalsConfig = 0;
        }
        /* - SPS_TDD_Changes */
    }
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : processAndUpdateULReconfigAmbrInfo 
 * Inputs         : ulUEContext_p - Pointer to UL UE Context
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function processes and updates the UL Reconfig AMBR
 *                  information
 *****************************************************************************/
STATIC  MacRetType processAndUpdateULReconfigAmbrInfo(
        ULUEContext *ulUEContext_p)
{
    /* CA changes Start */
    InternalCellIndex internalCellIndex;
    internalCellIndex = ulUEContext_p->internalCellIndex;

    ULSchedulerStrategyConfig *ulSchdConfig_p  =  & cellSpecificParams_g.\
                                                  cellConfigAndInitParams_p[internalCellIndex]-> \
                                                  initParams_p->ulSchdConfig;
    /* CA Changes end */
    ULQosStrategyLCNode *ulQosStrategyLCNode_p            = PNULL;
    /* TDD Config 0 Changes Start */
#ifdef TDD_CONFIG
    UInt8 index = 0;
#endif
    /* TDD Config 0 Changes End */

    /*update token rate for UL AMBR*/
    ulQosCalcNonGbrLCTknValue(&ulUEContext_p->ulAmbrInfo, internalCellIndex);

    /*Update the Stkn(t) with the token rate*/
    ulUEContext_p->ulAmbrInfo.scheduledToken[0] = 0;

    /*calculate ambr token priority*/
    ulUEContext_p->ulAmbrInfo.ambrTokenPriority = 5 ;

    /* SPR 11081 changes start */
    ulUEContext_p->ulAmbrInfo.qciPriority =
        ulQosGetQciPriority(macParams_g.qosQciInfo[ulUEContext_p->ulAmbrInfo.minQci - 1].priority);
    /* SPR 11081 changes end */

    ulQosUpdateQloadTableForLcPriority(
            ulUEContext_p->ulAmbrInfo.lcQlTable,
            ulUEContext_p->ulAmbrInfo.AMBR,
            ulUEContext_p->ulAmbrInfo.maxPdb);

    ulQosUpdatePdbTableForLcPriority(
            ulUEContext_p->ulAmbrInfo.lcPdbTable,
            ulUEContext_p->ulAmbrInfo.minPdb);

    /*update ambr token priority table*/
    ulQosUpdateTknTableForLcPriority(ulUEContext_p->ulAmbrInfo.lcTknTable,
            /*CA Changes start  */
            ulUEContext_p->ulAmbrInfo.AMBR, internalCellIndex);
    /*CA Changes end  */

    /*Calculate AMBR bucket depth*/
    ulUEContext_p->ulAmbrInfo.ambrTokenDepth =
        ulSchdConfig_p->ambrBktFactor * ulUEContext_p->ulAmbrInfo.ambrTokenRate;

    /* Calculate bucket limit(minimum tokens to present in bucket) */
    ulUEContext_p->ulAmbrInfo.ambrTokenLimit =
        ulSchdConfig_p->ambrTokenLimitFactor *
        ulUEContext_p->ulAmbrInfo.ambrTokenRate;

    /* SPR 5226 start */
    if(ulSchdConfig_p->ulSchedulerStrategy == UL_QOS_SCHEDULING)
    {
        /* SPR 5226 end */
        if (PNULL == ulUEContext_p->ulAmbrInfo.ulQosStrategyLCNode_p)
        {
            /*create strategy lc node of type ULQosStrategyLCNode for ambr*/
            GET_MEM_FROM_POOL(ULQosStrategyLCNode,
                    ulQosStrategyLCNode_p,
                    sizeof(ULQosStrategyLCNode),
                    PNULL);
            /* + Coverity 24470 */
            if( PNULL == ulQosStrategyLCNode_p )
            {
                /*CRITICAL! Memory error*/
                LOG_MAC_MSG(L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, L2_SYS_FAIL,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                        sizeof(ULQosStrategyLCNode), internalCellIndex,0, 0, 0,0, 
                        __FILE__, __func__);
                ALARM_MSG(MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID, 
                        CRITICAL_ALARM);
                return MAC_FAILURE;
            }
            /* - Coverity 24470 */

            /*FILLING ulQosStrategyLCNode_p PARAMS*/
            ulQosStrategyLCNode_p->lcgId          = 0;
            /* TDD Config 0 Changes Start */
#ifdef TDD_CONFIG
            for (index = 0; index < MAX_UL_SUBFRAME_GRANT; index++)
            {
                ulQosStrategyLCNode_p->scheduledBytes[index] = 0;
            }
#else
            ulQosStrategyLCNode_p->scheduledBytes = 0;
#endif
            /* TDD Config 0 Changes End */
            ulQosStrategyLCNode_p->totLCWght      = 0;
            ulQosStrategyLCNode_p->channelType    = NON_GBR;
            ulQosStrategyLCNode_p->ueId           = ulUEContext_p->ueIndex;

            /*STORE UL STRATEGY NODE IN AMBR INFO*/
            ulUEContext_p->ulAmbrInfo.ulQosStrategyLCNode_p = ulQosStrategyLCNode_p;

            /*Storing the back refernce pointer for UL AMBR Info in Strategic LC node*/
            ulQosStrategyLCNode_p->ulAmbrInfo_p = &ulUEContext_p->ulAmbrInfo;
            ulQosStrategyLCNode_p->lcInfo_p     = PNULL;
            /* SPR# 3110 Changes Starts*/
            ulQosStrategyLCNode_p->isLCScheduled = FALSE;
            /* SPR# 3110 Changes Ends*/
        }
        ulUEContext_p->ulAmbrInfo.ulQosStrategyLCNode_p->lchId =
            ulUEContext_p->ulAmbrInfo.lcId;
        ulUEContext_p->ulAmbrInfo.ulQosStrategyLCNode_p->lcgId =
            ulUEContext_p->ulAmbrInfo.lcgId;
        /* SPR 5226 start */
    }  
    /* SPR 5226 end */
    return MAC_SUCCESS;
}

/*****************************************************************************
 * Function Name  : ulResetUeReqHPHandler 
 * Inputs         : ulRrcOamQNodeReq_p - Pointer to UL RRC OAM request
 *                  queue node
 *                  ulRrcOamQNodeResp_p - Pointer to UL RRC OAM response 
 *                  queue node
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function processes and updates UL Reset UE Request
 *****************************************************************************/
UInt32 ulResetUeReqHPHandler(RrcOamHiPrioQNode *ulRrcOamQNodeReq_p,
        RrcOamHiPrioQNode *ulRrcOamQNodeResp_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    LTE_GCC_UNUSED_PARAM(ulRrcOamQNodeResp_p)
        UInt16 ueIndex = 0;
    ueIndex = ulRrcOamQNodeReq_p->rrcOamReqResp.ulResetUeReq.ueIndex;
    ulUECtxInfoArr_g[ueIndex].pendingDeleteFlag = ulRrcOamQNodeReq_p->rrcOamReqResp.ulResetUeReq.pendingDeleteFlag;
    /* CA changes start */
    ulUECtxInfoArr_g[ueIndex].scellRelFlag = ulRrcOamQNodeReq_p->rrcOamReqResp.ulResetUeReq.scellRelFlag;
    /* CA changes end */
    /* Remove sleep MAC RESET changes start*/ 
    if(TRUE == ulRrcOamQNodeReq_p->rrcOamReqResp.ulResetUeReq.pendingDeleteFlag)
    {
        return MAC_PENDING_RESET;
    }
    else
    {
        /* SPR 10802 [BUG 872] FIX START */
        UInt8 hpId = 0;
        ULHarqInfo* ulHarqProcess_p = PNULL;
        /* SPR 12809 fix start */
        ULUEContext *ulUEContext_p = 
            ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
        ulHarqProcess_p = &(ulUEContext_p->ulresInfo[0]);
        /* SPR 12809 fix end */
        if( PNULL != ulHarqProcess_p)   
        {
            for (hpId = 0; hpId < MAX_HARQ_PROCESS_NB ; hpId++)            
            {
                if((HARQ_PROCESS_FREE != ulHarqProcess_p[hpId].harqStatus))
                {
                    /* SPR 16916 FIX START */
#ifdef KPI_STATS
                    freeULHarqProcess(&(ulHarqProcess_p[hpId]),ueIndex,internalCellIndex);
#else
                    /* +- SPR 17777 */
                    LTE_GCC_UNUSED_PARAM(internalCellIndex)
                        /* +- SPR 17777 */
                        freeULHarqProcess(&(ulHarqProcess_p[hpId]));
#endif
                    /* SPR 16916 FIX END */
                    /* SPR 12809 fix start */
#ifdef FDD_CONFIG                    
                    updateTTIHarqMap( hpId, ulHarqProcess_p,
                            ulUEContext_p->ttiHarqMap);
#endif
                    /* SPR 12809 fix end */
                }
            }
        }   
        /* SPR 10802 [BUG 872] FIX END */
        return MAC_SUCCESS;
    }
    /* Remove sleep MAC RESET changes end*/ 
}
/*****************************************************************************
 * Function Name  : ulConfigureLcInfo 
 * Inputs         : ulReconfigLcReq_p - Pointer to UL Reconfigure Request
 *                  ueContext_p - Pointer to UL UE COntext to update LC info
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function processes and updates UL LC info.
 *****************************************************************************/
STATIC MacRetType ulConfigureLcInfo(ULReconfigUeReq *ulReconfigLcReq_p, ULUEContext *ueContext_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    ulLogicalChannelInfo* logicalChConfig_p = PNULL;
    UInt32 logicalChCount = 0;
    UInt32 n = 0;
    UInt8 tempLogicalChID = 0;
    /* Rel 5.3: Coverity 32231 Fix Start */
    LCOperationType  lcOperationType = ADD;
    /* Rel 5.3: Coverity 32231 Fix End */

    /* + coverity 32236 */
    MacRetType logChConfigResp = MAC_SUCCESS;
    /* - coverity 32236 */
    UInt32 returnType      = MAC_SUCCESS;

    logicalChConfig_p = ulReconfigLcReq_p->ulReconfigLcReq.lcInfo;
    logicalChCount = ulReconfigLcReq_p->ulReconfigLcReq.numLogicalChannels;
    /* Reconfiguring the Logical Channel Structures */
    for (n = 0; n < logicalChCount; n++)
    {
        tempLogicalChID = logicalChConfig_p[n].lchId;
        lcOperationType = logicalChConfig_p[n].operationType;
        if (ADD == lcOperationType)
        {
            if(ueContext_p->lcInfo[tempLogicalChID].lcGId != 
                    LCGID_INVALID_VALUE)
            {
                lteWarning ("Logical Channel already added.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ueContext_p->lcInfo[tempLogicalChID].lcGId,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Logical Channel already added");
                /* Review comment fix end RJ13 */
                /* + coverity 32236 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32236 */
                logicalChConfig_p[n].result = MAC_RRC_LOG_CH_EXISTS;
                continue;
            }
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,
                    "Adding a new logical channel. \n");
            returnType = addULUELogicalChannel(ueContext_p, 1, &logicalChConfig_p[n],
                    internalCellIndex);

            /* Coverity_73394 Fix Start */
            if( MAC_FAILURE== returnType)
            {
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
            }
            /* Coverity_73394 Fix End */
        }
        else if (RECONFIGURE == lcOperationType)
        {
            if (LCGID_INVALID_VALUE == ueContext_p->
                    lcInfo[tempLogicalChID].lcGId)
            {
                lteWarning ("Trying to reconfigure a Logical Channel \
                        that does not exists.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ueContext_p->lcInfo[tempLogicalChID].lcGId,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Trying to delete a Logical Channel that does not exists");
                /* Review comment fix end RJ13 */
                logicalChConfig_p[n].result = MAC_RRC_LOG_CH_NOT_EXISTS;
                /* + coverity 32236 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32236 */
                continue;
            }

            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"Reconfiguring a logical channel. \n");
            returnType = reconfigULUELogicalChannel(ueContext_p,&logicalChConfig_p[n]
                    /*CA Changes start  */
                    ,internalCellIndex);
            /*CA Changes end  */
            if (MAC_FAILURE == returnType)
            {
                /* + coverity 32236 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32236 */
            }
        }
        else if (DELETE == lcOperationType)
        {
            if (ueContext_p->lcInfo[tempLogicalChID].lcGId == 
                    LCGID_INVALID_VALUE)
            {
                lteWarning ("Trying to delete a Logical Channel that \
                        does not exists.\n");
                /* Review comment fix start RJ13 */
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ueContext_p->lcInfo[tempLogicalChID].lcGId,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Trying to delete a Logical Channel that does not exists");
                /* Review comment fix end RJ13 */
                logicalChConfig_p[n].result = MAC_RRC_LOG_CH_NOT_EXISTS;
                /* + coverity 32236 */
                logChConfigResp = MAC_LOG_CH_ERROR_VAL;
                /* - coverity 32236 */

                continue;
            }
            /*CA Changes start  */
            deleteULUELogicalChannel( ueContext_p , tempLogicalChID,internalCellIndex);
            /*CA Changes end  */
            logicalChConfig_p[n].result = MAC_SUCCESS;
        }
        else
        {
            LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"Invalid operation to be performed.\n");
            continue;
        }
    }

    return logChConfigResp;

}

/*SPR 16855 +-*/


/* + CQI_5.0 */

/****************************************************************************
 * Function Name  : validateAperiodicModeForTXMode 
 * Inputs         : aperiodicCqiMode - configured Aperiodic Mode
 *                  transmissionMode - configured transmission mode
 *                    
 * Output         : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function will validate the aperiodic CQI mode against 
 *                  transmission mode. If transmission mode is Closed loop MIMO 
 *                  and  aperiodic mode 20/ aperiodic 30 is configured then
 *                  return failure or if transmission mode is SISO/ transmit
 *                  diversity/Open loop MIMO and aperiodic 12/aperiodic 22/
 *                  aperiodic 31 is configured then return failure.
 *****************************************************************************/
MacRetType validateAperiodicModeForTXMode(UInt8 aperiodicCQIMode,
        UInt8 transmissionMode)
{

    switch (transmissionMode)
    {
        case TX_MODE_1:
        case TX_MODE_2:
        case TX_MODE_3:
        /* + TM7_8 Changes Start */
        case TX_MODE_7:     
        /* - TM7_8 Changes End */
        if( (CQI_MODE_1_2 ==  aperiodicCQIMode) || 
                (CQI_MODE_2_2 == aperiodicCQIMode) ||
                (CQI_MODE_3_1 == aperiodicCQIMode) )
        {
            return MAC_FAILURE;
        }    
        break;

        case TX_MODE_4:
        /* + TM6_5.2 */
        case TX_MODE_6:
        /* - TM6_5.2 */
        if( (CQI_MODE_2_0 == aperiodicCQIMode) || (CQI_MODE_3_0 == aperiodicCQIMode) )
        {
            return MAC_FAILURE;
        }    
        break;     
        /* + TM7_8 Changes Start */
        case TX_MODE_8:
        /* CQI Mode for TM8  depends upon PmiRiConfig,
         * so its validation will take place at createUE */
        break;
        /* - TM7_8 Changes End */

        default:
        lteWarning("Unsupported/Invalid transmissionMode:%d\n", transmissionMode);
        return MAC_FAILURE;
        break;
    }

    return MAC_SUCCESS;

}    

/* - CQI_5.0 */
/****************************************************************************
 * Function Name  : deleteSplitOnUeEntity
 * Inputs         : ueIndex , msgId,transactionId
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC SUCCESS or reason for failure
 * Description    : This function sends the Delete UE indication to DL/UL threads
 *****************************************************************************/
/* +- SPR 17777 */
UInt16 deleteSplitOnUeEntity( UInt16 ueIndex ,
        UInt16 transactionId, InternalCellIndex internalCellIndex )
    /* +- SPR 17777 */
{
    UInt16 resp       = MAC_SUCCESS;
    /*SPR 16855 +-*/
    LP_RrcOamPendingReq rrcOamPendingReq_p = 
        getMemFromPool(sizeof(RrcOamPendingReq),PNULL);

    if(PNULL == rrcOamPendingReq_p)
    {
        LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
                __FILE__, __func__);
        ALARM_MSG( MAC_MODULE_ID, 
                MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
        resp = MAC_FAILURE;
    }
    else
    {
        /* + Coverity 40417 */
        memSet( rrcOamPendingReq_p, 0, sizeof(RrcOamPendingReq) );
        rrcOamPendingReq_p->rrcUeIndex = getRrcUeIdxFromUeIdx(ueIndex);
        rrcOamPendingReq_p->response = MAC_SUCCESS;
        /* - Coverity 40417 */
        rrcOamPendingReq_p->transactionId = transactionId;
        /* Call the state machine to wait for response 
         * from MAC (DL/UL) Thread */
        resp = MAC_SUCCESS;
        rrcStateMachineHandler( ueIndex, MAC_RRC_DELETE_UE_ENTITY_EV,
                rrcOamPendingReq_p, PNULL, PNULL, &resp, internalCellIndex);

        /* Set response code to Pending Deletion so that response to 
         * L3 is not sent */
        resp = MAC_DELETION_PENDING;
    }
    /*SPR 16855 +-*/
    return resp;
}

/****************************************************************************
 * Function Name  : resetSplitUeEntity
 * Inputs         : ueIndex , msgId,transactionId, scellRelFlag
 *                  internalCellIndex - cell index used at MAC
 * Output         : None
 * Returns        : MAC_SUCESS or MAC_FAILURE
 * Description    : This function sends the Reset UE indication to DL/UL threads
 *****************************************************************************/
UInt16 resetSplitUeEntity( UInt16 ueIndex , UInt16 msgId, 
        UInt16 transactionId,
        UInt8 scellRelFlag,
        InternalCellIndex internalCellIndex )
{
    UInt16 resp       = MAC_SUCCESS;
    /*SPR 16855 +-*/
    DLResetUeReq       *dlResetUeReq_p       = PNULL;
    ULResetUeReq       *ulResetUeReq_p       = PNULL;
    RrcOamHiPrioQNode  *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode  *ulRrcOamHiPrioQNode_p = PNULL;
    LP_RrcOamPendingReq rrcOamPendingReq_p    = PNULL;

    do
    {
        dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
        /* + Coverity 32140 */
        if( PNULL == dlRrcOamHiPrioQNode_p )
        {
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamHiPrioQNode), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            resp = MAC_FAILURE;
            break;
        }
        /* - Coverity 32140 */
        ulRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
        /* + Coverity 32140 */
        if( PNULL == ulRrcOamHiPrioQNode_p )
        {
            freeMemPool( dlRrcOamHiPrioQNode_p );
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamHiPrioQNode), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            resp = MAC_FAILURE;
            break;
        }
        /* - Coverity 32140 */
        dlRrcOamHiPrioQNode_p->rrcMsgId = msgId;
        ulRrcOamHiPrioQNode_p->rrcMsgId = msgId;

        dlRrcOamHiPrioQNode_p->ueIndex = ueIndex;
        ulRrcOamHiPrioQNode_p->ueIndex = ueIndex;

        dlRrcOamHiPrioQNode_p->eventId = MAC_HP_RESET_UE_BEFORE_HARQ_RESET_ENTITY_EV;
        ulRrcOamHiPrioQNode_p->eventId = MAC_HP_RESET_UE_BEFORE_HARQ_RESET_ENTITY_EV;

        dlResetUeReq_p  = &dlRrcOamHiPrioQNode_p->rrcOamReqResp.dlResetUeReq;
        ulResetUeReq_p  = &ulRrcOamHiPrioQNode_p->rrcOamReqResp.ulResetUeReq;
        dlResetUeReq_p->ueIndex = ueIndex;
        ulResetUeReq_p->ueIndex = ueIndex;

        /* CA changes start */
        dlResetUeReq_p->scellRelFlag = scellRelFlag;
        ulResetUeReq_p->scellRelFlag = scellRelFlag;
        /* CA changes end */

        dlResetUeReq_p->pendingDeleteFlag = TRUE;
        ulResetUeReq_p->pendingDeleteFlag = TRUE;

        rrcOamPendingReq_p = getMemFromPool(sizeof(RrcOamPendingReq),PNULL);
        if(PNULL == rrcOamPendingReq_p)
        {
            freeMemPool( dlRrcOamHiPrioQNode_p );
            freeMemPool( ulRrcOamHiPrioQNode_p );
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            resp = MAC_FAILURE;
        }
        else
        {
            /* + Coverity 40419 */
            memSet(rrcOamPendingReq_p,0,sizeof(RrcOamPendingReq));
            /* - Coverity 40419 */
        }
    }while (0 );

    if ( MAC_SUCCESS == resp )
    {
        rrcOamPendingReq_p->transactionId = transactionId;
        rrcOamPendingReq_p->rrcUeIndex  = getRrcUeIdxFromUeIdx(ueIndex);
        /* + Coverity 40419 */
        rrcOamPendingReq_p->response = MAC_SUCCESS;
        rrcOamPendingReq_p->SF = 0;
        rrcOamPendingReq_p->SFN = 0;
        /* - Coverity 40419 */
        /* Coverity 40419 Fix Start*/
        rrcOamPendingReq_p->deleteDLUEBitMap = 0;
        rrcOamPendingReq_p->deleteULUEBitMap = 0;
        /* Coverity 40419 Fix End */
        /*++coverity--530-40419 */
        rrcOamPendingReq_p->spsCrntiFlag = FALSE;
        rrcOamPendingReq_p->gapPatternId = FALSE;
        /*++coverity--530-40419 */

        /* SPR 9385 changes start*/
        rrcOamPendingReq_p->respMsgId = MAC_RESET_UE_ENTITY_CNF;
        /* SPR 9385 changes end*/
        /* CA_Phase3_Re-estab_changes start */
        rrcOamPendingReq_p->dlscellRelFlag = LTE_TRUE;
        /* CA_Phase3_Re-estab_changes end */

        /* Call the state machine to wait for response 
         * from MAC (DL/UL) Thread */
        resp = MAC_SUCCESS;
        rrcStateMachineHandler( ueIndex, 
                MAC_RRC_RESET_REQ_EV,
                rrcOamPendingReq_p, dlRrcOamHiPrioQNode_p, 
                ulRrcOamHiPrioQNode_p, &resp, internalCellIndex);
        resp = MAC_RESET_PENDING;
    }
    /*SPR 16855 +-*/
    return resp;
}

/* SPR 9385 changes start*/
/****************************************************************************
 * Function Name  : changeCrntiAndResetSplitUeEntity
 * Inputs         : ueIndex , msgId,transactionId,changeCrntiInfo_p
 *                  internalCellIndex
 * Output         : None
 * Returns        : None
 * Description    : This function will reset UE entity when MAC_CHANGE_CRNTI_REQ 
 *                  is triggered.
 * *****************************************************************************/
void changeCrntiAndResetSplitUeEntity( UInt16 ueIndex , UInt16 msgId, 
        UInt16 transactionId,ChangeCrntiInfo *changeCrntiInfo_p,
        InternalCellIndex internalCellIndex)
{
    UInt16 resp       = MAC_SUCCESS;
    /*SPR 16855 +-*/
    DLResetUeReq       *dlResetUeReq_p       = PNULL;
    ULResetUeReq       *ulResetUeReq_p       = PNULL;
    RrcOamHiPrioQNode  *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode  *ulRrcOamHiPrioQNode_p = PNULL;
    LP_RrcOamPendingReq rrcOamPendingReq_p    = PNULL;

    do
    {
        dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
        if( PNULL == dlRrcOamHiPrioQNode_p )
        {
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamHiPrioQNode), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            resp = MAC_FAILURE;
            break;
        }
        ulRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
        if( PNULL == ulRrcOamHiPrioQNode_p )
        {
            freeMemPool( dlRrcOamHiPrioQNode_p );
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamHiPrioQNode), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            resp = MAC_FAILURE;
            break;
        }

        dlRrcOamHiPrioQNode_p->rrcMsgId = msgId;
        ulRrcOamHiPrioQNode_p->rrcMsgId = msgId;

        dlRrcOamHiPrioQNode_p->ueIndex = ueIndex;
        ulRrcOamHiPrioQNode_p->ueIndex = ueIndex;

        dlRrcOamHiPrioQNode_p->eventId = MAC_HP_RESET_UE_BEFORE_HARQ_RESET_ENTITY_EV;
        ulRrcOamHiPrioQNode_p->eventId = MAC_HP_RESET_UE_BEFORE_HARQ_RESET_ENTITY_EV;

        dlResetUeReq_p  = &dlRrcOamHiPrioQNode_p->rrcOamReqResp.dlResetUeReq;
        ulResetUeReq_p  = &ulRrcOamHiPrioQNode_p->rrcOamReqResp.ulResetUeReq;
        dlResetUeReq_p->ueIndex = ueIndex;
        ulResetUeReq_p->ueIndex = ueIndex;

        /* CA_Phase3_Re-estab_changes start */
        /* Acc. to CA arch doc Sec. 22.1,SCell context shall be released at MAC
         * layer during Re-establishment scenario */
        dlResetUeReq_p->scellRelFlag = LTE_TRUE;
        ulResetUeReq_p->scellRelFlag = LTE_TRUE;
        /* CA_Phase3_Re-estab_changes end */
        dlResetUeReq_p->pendingDeleteFlag = TRUE;
        ulResetUeReq_p->pendingDeleteFlag = TRUE;

        rrcOamPendingReq_p = getMemFromPool(sizeof(RrcOamPendingReq),PNULL);
        if(PNULL == rrcOamPendingReq_p)
        {
            freeMemPool( dlRrcOamHiPrioQNode_p );
            freeMemPool( ulRrcOamHiPrioQNode_p );
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            resp = MAC_FAILURE;
        }
        else
        {
            memSet(rrcOamPendingReq_p,0,sizeof(RrcOamPendingReq));
        }
    }while (0 );

    if ( MAC_SUCCESS == resp )
    {
        rrcOamPendingReq_p->transactionId = transactionId;
        /*SPR 12103 fix start, removed MULTI_SECTOR flag*/ 
        /*rrcOamPendingReq_p->rrcUeIndex  contains internal ueIndex and not RRC ueIndex*/  
        rrcOamPendingReq_p->rrcUeIndex  = ueIndex;
        /*SPR 12103 fix end*/ 
        rrcOamPendingReq_p->response = MAC_SUCCESS;
        rrcOamPendingReq_p->SF = 0;
        rrcOamPendingReq_p->SFN = 0;
        rrcOamPendingReq_p->deleteDLUEBitMap = 0;
        rrcOamPendingReq_p->deleteULUEBitMap = 0;
        rrcOamPendingReq_p->spsCrntiFlag = FALSE;
        rrcOamPendingReq_p->gapPatternId = FALSE;

        rrcOamPendingReq_p->changeCrntiInfo.ueIndex = changeCrntiInfo_p->ueIndex;
        rrcOamPendingReq_p->changeCrntiInfo.oldCrnti = changeCrntiInfo_p->oldCrnti;
        rrcOamPendingReq_p->changeCrntiInfo.newCrnti = changeCrntiInfo_p->newCrnti;
        rrcOamPendingReq_p->respMsgId = MAC_CHANGE_CRNTI_CNF;
        /* CA_Phase3_Re-estab_changes start */
        rrcOamPendingReq_p->dlscellRelFlag = LTE_TRUE;
        /* CA_Phase3_Re-estab_changes end */

        /** SPR 12320 Changes Start **/
        if(rrcOamPendingReq_p->dlscellRelFlag)
        {
            UeCellInfo  ueCellInfo = {0};
            UInt8 servCellIndex = 0;
            DLUESCellContext   * dlUeScellContext_p = PNULL;
            /** SPR 12320 Fix : START **/
            PucchConfig        * tempSCellPucchConfigInfo_p = PNULL;
            ULUESCellContext   * ulUeScellContext_p = PNULL;
            ULUEContext * ueULContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
            /** SPR 12320 Fix : END **/
            DLUEContext * ueDLContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;

            if(ueDLContext_p)
            {
                for(servCellIndex = START_SCELL_INDEX; servCellIndex <= ueDLContext_p->\
                        scellCount ;servCellIndex++)
                {
                    ueCellInfo.isPCell = 0;
                    ueCellInfo.sCellInternalCellIndex = 0;
                    ueCellInfo.sCellIndex = servCellIndex;
                    dlUeScellContext_p = ueDLContext_p->\
                                         dlUeScellContext_p[servCellIndex];

                    /** SPR 12320 Fix : START **/
                    ulUeScellContext_p = ueULContext_p->\
                                         ulUeScellContext_p[servCellIndex];

                    if (PNULL != ulUeScellContext_p)
                    {
                        tempSCellPucchConfigInfo_p = 
                            &(ulUeScellContext_p->scellpucchConfigInfo); 
                    }

                    if(PNULL != dlUeScellContext_p)
                    { 
                        deleteSCellPucchNodesForUE( tempSCellPucchConfigInfo_p, WIDEBAND_CQI_REPORT,
                                &ueCellInfo, internalCellIndex, ueIndex);
                        deleteSCellPucchNodesForUE( tempSCellPucchConfigInfo_p, CQI_REPORT ,
                                &ueCellInfo, internalCellIndex,ueIndex);
                        deleteSCellPucchNodesForUE( tempSCellPucchConfigInfo_p, RI_REPORT ,
                                &ueCellInfo, internalCellIndex,ueIndex);

                    }
                    /** SPR 12320 Fix : END **/
                }
            }
        }
        /** SPR 12320 Changes End **/

        /* Call the state machine to wait for response 
         * from MAC (DL/UL) Thread */
        resp = MAC_SUCCESS;
        rrcStateMachineHandler( ueIndex, 
                MAC_RRC_RESET_REQ_EV,
                rrcOamPendingReq_p, dlRrcOamHiPrioQNode_p, 
                ulRrcOamHiPrioQNode_p, &resp, internalCellIndex);
    }
    else
    {
        /* send msg to RRC with resp as FAILURE */
        ChangeCrntiRespInfo changeCrntiResp = {0};
        /*SPR 12103 fix, updating RRC ueIndex in the resp structure*/
        changeCrntiResp.ueIndex = getRrcUeIdxFromUeIdx(ueIndex);
        changeCrntiResp.resp = resp;
        changeCrntiResp.transactionId = transactionId;

        if(MAC_SEND_ERROR  ==
                sendMsgToRRC(MAC_CHANGE_CRNTI_CNF, &changeCrntiResp,
                    macCommonGetRRCCellIndex(internalCellIndex)))
        {
            ALARM_MSG(MAC_MODULE_ID,
                    SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
        }
    }
    /*SPR 16855 +-*/
}
/* SPR 9385 changes end*/
#ifdef PERF_STATS
/****************************************************************************
 * Function Name  : initPerfStatsPdcchPdschInfo 
 * Inputs         : internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function will update sum of the global variables used
 *                  for the calculation of total number of RE used in DL. 
 *****************************************************************************/
/* CA Changes start */
void initPerfStatsPdcchPdschInfo(InternalCellIndex internalCellIndex)
{
    UInt32 overlapCsrREsWithMib = 0;
    UInt8 numOfTxAnteenas = 0;
    /* As of now internalCellIndex = 0 is used.
     * After CA perf stats design this will be changed.
     */
    internalCellIndex = 0;
    numOfTxAnteenas = cellSpecificParams_g.\
                      cellConfigAndInitParams_p[internalCellIndex]->cellParams_p->numOfTxAnteenas;  

    if (NUM_OF_TX_ANTENNAS_1 == numOfTxAnteenas)
    {
        csrREsExcludingFirstSymbol_g[internalCellIndex] = 6;
        overlapCsrREsWithMib = 4;
    }
    else if(NUM_OF_TX_ANTENNAS_2 == numOfTxAnteenas)
    {
        csrREsExcludingFirstSymbol_g[internalCellIndex] = 12;
        overlapCsrREsWithMib = 8;
    }
    else if (NUM_OF_TX_ANTENNAS_4 == numOfTxAnteenas)
    {
        csrREsExcludingFirstSymbol_g[internalCellIndex] = 24;
        overlapCsrREsWithMib = 16;
    }
    /* CA Changes end */
    /* + PERF_CA GBL */
    /* RE calculated below include unused REs but exclude CSR (12*4)*/
    reUsedForMibPerPRB_g[internalCellIndex] = 48 - overlapCsrREsWithMib;
    /* RE calculated below includes unused REs (12*2)*/
    reUsedForPssSssPerPRB_g[internalCellIndex] = 24;
    /* - PERF_CA GBL */
}
#endif
/* SPS_CHG */
/*****************************************************************************
 *Function Name  : parseSpsRntiRange
 *Inputs         : message_p - Pointer to the buffer containing the
 *                              values of the SPS_RNTI_RANGE
 *                 configCellReq_p- Pointer to the ConfigCellReq structure
 *                 internalCellIndex - cell index used at MAC
 *Outputs        : None
 *Returns        : MAC_SUCCESS or MAC_FAILURE
 *Description    : This method will parse the passed buffer that is received
 from RRC at the time of cell configuration and populate
 the ConfigCellReq.spsCommonCellInfo member
 *****************************************************************************/
STATIC MacRetType parseSpsRntiRange(UInt8 *message_p, ConfigCellReq *configCellReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = message_p;

    configCellReq_p->spsCommonCellInfo.startSpsCRnti = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    configCellReq_p->spsCommonCellInfo.endSpsCRnti = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    /*Checking the range of the startSpsCRnti.*/
    if (MAC_FAILURE == validateSpsRntiRange(
                configCellReq_p->spsCommonCellInfo.startSpsCRnti,
                configCellReq_p->spsCommonCellInfo.endSpsCRnti,
                configCellReq_p
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                ))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                configCellReq_p->spsCommonCellInfo.startSpsCRnti,
                configCellReq_p->spsCommonCellInfo.endSpsCRnti,
                internalCellIndex,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_START_SPS_CRNTI_RANGE_PARAM");

        return MAC_FAILURE;
    }
    /* Review comment fix start SYNC_LOSS_2*/
    LOG_MAC_MSG(MAC_SPS_CRNTI_RANGE_PARAM,LOGINFO,MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            configCellReq_p->spsCommonCellInfo.startSpsCRnti,
            configCellReq_p->spsCommonCellInfo.endSpsCRnti, 
            DEFAULT_INT_VALUE, 
            internalCellIndex, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, "MAC_SPS_CRNTI_RANGE_PARAM");
    /* Review comment fix end SYNC_LOSS_2*/
    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name    : validateSpsRntiRange
 * Inputs           : startSpsRnti - Start value of Sps Rnti
 *                    endSpsRnti - End value of Sps Rnti
 *                    configCellReq_p - Pointer to the ConfigCellReq structure.
 *                    internalCellIndex - cell index used at MAC
 * Outputs          : None
 * Returns          : MAC_SUCCESS or MAC_FAILURE
 * Description      : This method will validate the Sps Rnti Ranges .
 *                    The Sps Rnti Range should not overlap with Ra Rnti,
 *                    and Tpc Rnti Range
 *****************************************************************************/
/* CA changes Start */
STATIC MacRetType validateSpsRntiRange(UInt16 startSpsRnti,
        UInt16 endSpsRnti,
        ConfigCellReq *configCellReq_p
        ,InternalCellIndex internalCellIndex)
    /* CA changes end */
{
    //sps c-rnti should not overlap with C-rnti, ra-ranti, tpc-pucch-rnti and tpc-pusch-rnti
    /* Rel 5.3: Coverity 32238 Fix Start */
    MacRetType retVal = MAC_SUCCESS;
    /* Rel 5.3: Coverity 32238 Fix End */
#ifdef UTFWK_SIMULATION
    configCellReq_p->tpcRntiRange.startTpcRntiPucch  = 201;
    configCellReq_p->tpcRntiRange.endTpcRntiPucch    = 220;
    configCellReq_p->tpcRntiRange.startTpcRntiPusch  = 221;
    configCellReq_p->tpcRntiRange.endTpcRntiPusch    = 240;
#endif
    /*Start SPS RNTI should be less than End SPS RNTI*/
    if(startSpsRnti <= endSpsRnti)
    {
        /*Start and End SPS RNTI should be within the range*/
        if(((startSpsRnti >= MIN_SPS_RNTI_VALUE) && 
                    (startSpsRnti <= MAX_SPS_RNTI_VALUE)) && 
                ((endSpsRnti >= MIN_SPS_RNTI_VALUE) && 
                 (endSpsRnti <= MAX_SPS_RNTI_VALUE)))
        {
            /*SPS RNTI should not overlap with CRNTI range*/
            if((startSpsRnti > cellSpecificParams_g.
                        cellConfigAndInitParams_p[internalCellIndex]->initParams_p->\
                        upperRNTIBound) ||
                    (endSpsRnti < cellSpecificParams_g.cellConfigAndInitParams_p\
                     [internalCellIndex]->initParams_p->lowerRNTIBound))
            {
                retVal = MAC_SUCCESS;
            }
            else
            {
                return MAC_FAILURE;
            }
            /*SPS RNTI should not overlap with RA RNTI range*/
            if((startSpsRnti >  configCellReq_p->endRARntiRange) ||
                    (endSpsRnti < configCellReq_p->startRARntiRange))
            {
                retVal = MAC_SUCCESS;
            }
            else
            {
                return MAC_FAILURE;
            }
            /* SPS RNTI should not overlap within tpc PUCCH  rnti */
            if ((startSpsRnti > configCellReq_p->tpcRntiRange.endTpcRntiPucch) || 
                    (endSpsRnti < configCellReq_p->tpcRntiRange.startTpcRntiPucch))
            {
                retVal = MAC_SUCCESS;
            }
            else
            {
                return MAC_FAILURE;
            }
            /* SPS RNTI should not overlap within tpc PUSCH rnti */
            if ((startSpsRnti > configCellReq_p->tpcRntiRange.endTpcRntiPusch) || 
                    (endSpsRnti < configCellReq_p->tpcRntiRange.startTpcRntiPusch))
            {
                retVal = MAC_SUCCESS;
            }
            else
            {
                return MAC_FAILURE;
            }
        }
        else
        {
            retVal = MAC_FAILURE;
        }
    }
    else
    {
        retVal = MAC_FAILURE;
    }

    return retVal;
}
/****************************************************************************
 * Function Name   : parseSpsConfigInfo
 * Inputs          : message_p - Pointer to the data received from RRC
 *                   tagLen - tag length of the SPS_CONFIG
 *                   dlCreateRequest_p - Pointer to UE context for downlink
 *                   ulCreateRequest_p - Pointer to UE context for uplink
 *                   internalCellIndex - cell index used at MAC
 * Returns         : MacRetType
 * Description     : This function check for the parameters from the RRC and 
 *                     stored in the UeContextForDownlink structure
 *****************************************************************************/
STATIC  MacRetType parseSpsConfigInfo(
        UInt8 *message_p,
        UInt16 tagLength,       
        UeContextForDownlink *dlCreateRequest_p,
        UeContextForUplink *ulCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{ 
    UInt8  index     = 0;
    UInt8 *msg_p     = message_p;
    UInt16 tag       = 0;
    UInt16 tagLen    = tagLength;
    UInt16 count     = TAG_LEN;

    spsDlInfo *spsDownlinkInfo_p = \
                                   &(dlCreateRequest_p->spsDownlinkInfo);
    spsUlInfo *spsUplinkInfo_p = \
                                 &(ulCreateRequest_p->spsUplinkInfo);
    spsDownlinkInfo_p->spsDownlinkSetupInfo.\
        N1PucchAnPersistentListVal.numOfN1PucchAnPersistent = 0;

    if ( SPS_CONFIG_TAG_MIN_VALUE  > tagLen || 
            SPS_CONFIG_TAG_MAX_VALUE < tagLen )
    {        
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SPS_CONFIG_INFO_INVALID_TAGLEN");         

        return MAC_FAILURE;
    }
    if(tagLength > SPS_CONFIG_TAG_MIN_VALUE)
    {
        while(count < tagLength)
        {
            tag =  LTE_GET_U16BIT(msg_p);
            msg_p += U16BIT_LEN;
            count += U16BIT_LEN;
            tagLen = LTE_GET_U16BIT(msg_p);
            msg_p += U16BIT_LEN;
            count += U16BIT_LEN;

            switch(tag)
            {
                case SPS_DL_INFO :
                {
                    if (SPS_DL_INFO_TAG_MIN_VALUE  > tagLen || 
                            SPS_DL_INFO_TAG_MAX_VALUE < tagLen )
                    {         
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_DL_INFO_INVALID_TAGLEN");         
                        return MAC_FAILURE;
                    }
                    spsDownlinkInfo_p->requestType = *msg_p++;
                    count++;
                    if (spsDownlinkInfo_p->requestType > SPS_SETUP)
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,
                                LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,spsDownlinkInfo_p->requestType,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_SPS_DL_INFO_REQUEST_TYPE_INVALID");  
                        return MAC_FAILURE;
                    }
                    /* setting the isSpsDlInfoPresent falg true */
                    dlCreateRequest_p->isSpsDlInfoPresent = TRUE;
                }
                break;
                /*SPR 6861 Fix start*/
                case MAC_SPS_DL_SETUP_INFO :
                /*SPR 6861 Fix end*/
                {
                    /* Cyclomatic Complexity changes - starts here */
                    if (MAC_SUCCESS != parseSPSDLSetupInfo (tagLen, &msg_p, &count,
                                dlCreateRequest_p
                                /* CA changes Start */
                                ,internalCellIndex
                                /* CA Changes end */
                                ))
                    {
                        return MAC_FAILURE;
                    }
                    /* Cyclomatic Complexity changes - ends here */
                    break;
                }
                case SPS_N1_PUCCH_AN_PERSIST_LIST:
                {
                    if (SPS_N1_PUCCH_AN_PERSIST_LIST_TAG_VALUE != tagLen)
                    {         
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_N1_PUCCH_AN_PERSIST_LIST_INVALID_TAGLEN");         
                        return MAC_FAILURE;
                    }
                    index = spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                            N1PucchAnPersistentListVal.numOfN1PucchAnPersistent++;
                    spsDownlinkInfo_p->spsDownlinkSetupInfo.N1PucchAnPersistentListVal.\
                        N1PucchAnPersistent[index]= LTE_GET_U16BIT(msg_p);
                    msg_p += U16BIT_LEN;
                    count += U16BIT_LEN;
                    if ((spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                                N1PucchAnPersistentListVal.N1PucchAnPersistent[index] > \
                                N1_PUCCH_AN_PERSISTENT_MAX_VALUE) || \
                            (spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                             N1PucchAnPersistentListVal.numOfN1PucchAnPersistent < \
                             MIN_NUM_OF_PUCCH_AN_PERSISTENT) || \
                            (spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                             N1PucchAnPersistentListVal.numOfN1PucchAnPersistent > \
                             MAX_NUM_OF_PUCCH_AN_PERSISTENT))
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,
                                LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,
                                spsDownlinkInfo_p->spsDownlinkSetupInfo.N1PucchAnPersistentListVal.\
                                N1PucchAnPersistent[index],
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_N1_PUCCH_AN_PERSIST_LIST_INVALID");  
                        return MAC_FAILURE;
                    }
                }
                break;
                case SPS_DL_MAX_HARQ_RETX :
                {
                    if (SPS_DL_MAX_HARQ_RETX_TAG_LEN != tagLen)
                    {         
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_DL_MAX_HARQ_RETX_INVALID_TAGLEN");         
                        return MAC_FAILURE;
                    }
                    spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                        isMaxSpsHarqRetxPresent = TRUE;
                    spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                        maxSpsHarqRetx = *msg_p++;
                    count++;
                    if ((spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                                maxSpsHarqRetx < MAX_SPS_HARQ_RETX_MIN_VALUE )|| \
                            (spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                             maxSpsHarqRetx > MAX_SPS_HARQ_RETX_MAX_VALUE))
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,
                                LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,
                                spsDownlinkInfo_p->spsDownlinkSetupInfo.maxSpsHarqRetx,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_DL_SETUP_MAX_SPS_HARQ_RETX_INVALID");  
                        return MAC_FAILURE;
                    }
                }
                break;
                case SPS_DL_EXPLICIT_RELEASE_AFTER :
                {
                    if (SPS_DL_EXPLICIT_RELEASE_AFTER_TAG_LEN != tagLen)
                    {         
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_DL_EXPLICIT_RELEASE_AFTER_TAGLEN");         
                        return MAC_FAILURE;
                    }
                    spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                        isExplicitReleaseAfterPresent = TRUE;
                    spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                        explicitReleaseAfter = *msg_p++;
                    count++;
                    if ((spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                                explicitReleaseAfter < EXPLICIT_RELEASE_AFTER_MIN_VALUE) ||\
                            (spsDownlinkInfo_p->spsDownlinkSetupInfo.\
                             explicitReleaseAfter > EXPLICIT_RELEASE_AFTER_MAX_VALUE))
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,
                                LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,
                                spsDownlinkInfo_p->spsDownlinkSetupInfo.explicitReleaseAfter,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_DL_SETUP_SPS_EXPLICIT_RELEASE_AFTER_INVALID");  
                        return MAC_FAILURE;
                    }
                }
                break;
                case SPS_UL_INFO :
                {
                    if (SPS_UL_INFO_TAG_MIN_VALUE  > tagLen || 
                            SPS_UL_INFO_TAG_MAX_VALUE < tagLen )
                    {         
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                ulCreateRequest_p->ueIdx,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_UL_INFO_INVALID_TAGLEN");         
                        return MAC_FAILURE;
                    }
                    spsUplinkInfo_p->requestType = *msg_p++;
                    count++;
                    if (spsUplinkInfo_p->requestType > SPS_SETUP)
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,
                                LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                ulCreateRequest_p->ueIdx,spsUplinkInfo_p->requestType,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_SPS_UL_INFO_REQUEST_TYPE_INVALID");  
                        return MAC_FAILURE;
                    }
                    /* setting the isSpsUlInfoPresent flag true */
                    ulCreateRequest_p->isSpsUlInfoPresent = TRUE;
                }
                break;
                /*SPR 6861 Fix start*/
                case MAC_SPS_UL_SETUP_INFO :
                /*SPR 6861 Fix end*/
                {
                    /* Cyclomatic Complexity changes - starts here */
                    if (MAC_SUCCESS != parseSPSULSetupInfo (tagLen, &msg_p, &count,
                                ulCreateRequest_p
                                /* CA changes Start */
                                ,internalCellIndex
                                /* CA Changes end */
                                ))
                    {
                        return MAC_FAILURE;
                    }
                    /* Cyclomatic Complexity changes - ends here */
                    break;
                }
                case P_ZERO_PERSISTENT :
                {
                    /* Cyclomatic Complexity changes - starts here */
                    if (MAC_SUCCESS != parseSPSPZeroPersistentInfo (
                                dlCreateRequest_p->ueIndex, tagLen, 
                                &msg_p, &count, ulCreateRequest_p
                                /* CA changes Start */
                                , internalCellIndex
                                /* CA Changes end */
                                ))
                    {
                        return MAC_FAILURE;
                    }
                    /* Cyclomatic Complexity changes - ends here */
                    break;
                }
                case TWO_INTERVALS_CONFIG :
                {
                    if (SPS_UL_TWO_INTERVALS_CONFIG_TAG_LEN_VALUE  != tagLen)
                    {         
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                ulCreateRequest_p->ueIdx,tagLen,internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_UL_TWO_INTERVALS_CONFIG_INVALID_TAGLEN");         
                        return MAC_FAILURE;
                    }
                    spsUplinkInfo_p->spsUplinkSetupInfo.\
                        isTwoIntervalConfigPresent = TRUE;
                    spsUplinkInfo_p->spsUplinkSetupInfo.\
                        twoIntervalsConfig = *msg_p++;
                    count++;
                    if (spsUplinkInfo_p->spsUplinkSetupInfo.\
                            isTwoIntervalConfigPresent > LTE_TRUE)
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,
                                LOGWARNING,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                dlCreateRequest_p->ueIndex,
                                spsUplinkInfo_p->spsUplinkSetupInfo.twoIntervalsConfig,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "SPS_UL_TWO_INTERVALS_CONFIG_INVALID");  
                        return MAC_FAILURE;
                    }
                }
                break;
            };

        };
    }
    if (count != tagLength)
    {        
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateRequest_p->ueIndex,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SPS_CONFIG_INFO_INVALID_TAGLEN");         

        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseSPSDLSetupInfo
 * Inputs         : tagLen - tag length of the SPS_CONFIG
 *                  msgBuf - Pointer to the data received from RRC
 *                  count_p - Pointer to the remaining length
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : dlCreateRequest_p - Pointer to UE context for downlink
 * Returns        : MacRetType
 * Description    : This function parse the SPS DL Setup information and  
 *                     updates the UeContextForDownlink structure
 ******************************************************************************/
STATIC  MacRetType parseSPSDLSetupInfo( UInt16 tagLen, UInt8 **msgBuf, 
        UInt16 *count_p, UeContextForDownlink *dlCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 count = *count_p;

    spsDlInfo *spsDownlinkInfo_p = 
        &(dlCreateRequest_p->spsDownlinkInfo);
    msg_p = *msgBuf;

    if (SPS_DL_SETUP_INFO_TAG_MIN_VALUE  > tagLen || 
            SPS_DL_SETUP_INFO_TAG_MAX_VALUE < tagLen )
    {         
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), dlCreateRequest_p->ueIndex, tagLen, 
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "MAC_SPS_DL_SETUP_INFO_INVALID_TAGLEN");         
        return MAC_FAILURE;
    }
    spsDownlinkInfo_p->spsDownlinkSetupInfo.
        semiPersistentSchedIntervalDL = *msg_p++;
    count++;
    if ((spsDownlinkInfo_p->spsDownlinkSetupInfo.
                semiPersistentSchedIntervalDL > SPS_ITTERVAL_640)
            /* SPR 8506 Fix Start */ 
            || (LTE_FALSE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.supportedSpsDlIntervalList\
                [spsDownlinkInfo_p->spsDownlinkSetupInfo.semiPersistentSchedIntervalDL]))
        /* SPR 8506 Fix end */ 
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), dlCreateRequest_p->ueIndex,
                spsDownlinkInfo_p->spsDownlinkSetupInfo.semiPersistentSchedIntervalDL,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_SPS_DL_SETUP_INTERVAL_INVALID");  
        return MAC_FAILURE;
    }
    spsDownlinkInfo_p->spsDownlinkSetupInfo.
        numberOfConfSpsProcesses = *msg_p++;
    count++;
    if ((spsDownlinkInfo_p->spsDownlinkSetupInfo.
                numberOfConfSpsProcesses < MIN_NUMBER_OF_CONF_SPS_PROCESS) || 
            (spsDownlinkInfo_p->spsDownlinkSetupInfo.
             numberOfConfSpsProcesses > MAX_NUMBER_OF_CONF_SPS_PROCESS))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), dlCreateRequest_p->ueIndex,
                spsDownlinkInfo_p->spsDownlinkSetupInfo.numberOfConfSpsProcesses,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_SPS_DL_SETUP_NUM_SPS_PROCESS_INVALID");  
        return MAC_FAILURE;
    }

    *count_p = count;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseSPSULSetupInfo
 * Inputs         : tagLen - tag length of the SPS_CONFIG
 *                  msgBuf - Pointer to the data received from RRC
 *                  count_p - Pointer to the remaining length
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : ulCreateRequest_p - Pointer to UE context for Uplink
 * Returns        : MacRetType
 * Description    : This function parse the SPS UL Setup information and  
 *                     updates the UeContextForUplink structure
 ******************************************************************************/
STATIC  MacRetType parseSPSULSetupInfo( UInt16 tagLen, UInt8 **msgBuf, 
        UInt16 *count_p, UeContextForUplink   *ulCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 count = *count_p;
    spsUlInfo *spsUplinkInfo_p = &(ulCreateRequest_p->spsUplinkInfo);

    msg_p = *msgBuf;

    if (SPS_UL_SETUP_INFO_TAG_MIN_VALUE  > tagLen || 
            SPS_UL_SETUP_INFO_TAG_MAX_VALUE < tagLen )
    {         
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ulCreateRequest_p->ueIdx, tagLen, 
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "SPS_UL_SETUP_INFO_INVALID_TAGLEN");         
        return MAC_FAILURE;
    }
    spsUplinkInfo_p->spsUplinkSetupInfo.
        semiPersistentSchedIntervalUL = *msg_p++;
    count++;
    if ((spsUplinkInfo_p->spsUplinkSetupInfo.
                semiPersistentSchedIntervalUL > SPS_ITTERVAL_640)
            /* SPR 8506 Fix Start */ 
            || (LTE_FALSE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.supportedSpsUlIntervalList\
                [spsUplinkInfo_p->spsUplinkSetupInfo.semiPersistentSchedIntervalUL]))
        /* SPR 8506 Fix end */ 
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ulCreateRequest_p->ueIdx,
                spsUplinkInfo_p->spsUplinkSetupInfo.semiPersistentSchedIntervalUL,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "SPS_UL_SETUP_INTERVAL_INVALID");  
        return MAC_FAILURE;
    }
    spsUplinkInfo_p->spsUplinkSetupInfo.implicitReleaseAfter = *msg_p++;
    count++;
    if ( spsUplinkInfo_p->spsUplinkSetupInfo.implicitReleaseAfter >= 
            INVALID_IMPLICIT_RELEASE )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ulCreateRequest_p->ueIdx,
                spsUplinkInfo_p->spsUplinkSetupInfo.implicitReleaseAfter,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "SPS_UL_SETUP_SPS_EXPLICIT_RELEASE_AFTER_INVALID");  
        return MAC_FAILURE;
    }

    *count_p = count;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Funtion Name   : parseSPSPZeroPersistentInfo
 * Inputs         : ueIndex - UE Index
 *                  tagLen - tag length of the SPS_CONFIG
 *                  msgBuf - Pointer to the data received from RRC
 *                  count_p - Pointer to the remaining length
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : ulCreateRequest_p - Pointer to UE context for Uplink
 * Returns        : MacRetType
 * Description    : This function parse the SPS P_ZERO Persistent info and  
 *                     updates the UeContextForUplink structure
 ******************************************************************************/
STATIC  MacRetType parseSPSPZeroPersistentInfo( UInt16 ueIndex, 
        UInt16 tagLen, UInt8 **msgBuf, UInt16 *count_p, 
        UeContextForUplink *ulCreateRequest_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = PNULL;
    UInt16 count = *count_p;

    spsUlInfo *spsUplinkInfo_p = &(ulCreateRequest_p->spsUplinkInfo);

    msg_p = *msgBuf;

    if (SPS_UL_P_ZERO_PERSISTENT_TAG_LEN_VALUE != tagLen) 
    {         
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ulCreateRequest_p->ueIdx, tagLen, 
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "SPS_UL_P_ZERO_PERSISTENT_INVALID_TAGLEN");         
        return MAC_FAILURE;
    }
    spsUplinkInfo_p->spsUplinkSetupInfo.isP0TagPresent = TRUE;
    spsUplinkInfo_p->spsUplinkSetupInfo.p0PersistentInfo.
        p0NominalPuschPersistent = *msg_p++;
    count++;
    if ((spsUplinkInfo_p->spsUplinkSetupInfo.
                p0PersistentInfo.p0NominalPuschPersistent < 
                P0_NOMINAL_PUSCH_PERSISTENT_MIN_VALUE )|| 
            (spsUplinkInfo_p->spsUplinkSetupInfo.
             p0PersistentInfo.p0NominalPuschPersistent > 
             P0_NOMINAL_PUSCH_PERSISTENT_MAX_VALUE))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ueIndex,
                spsUplinkInfo_p->spsUplinkSetupInfo.
                p0PersistentInfo.p0NominalPuschPersistent,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "SPS_UL_P_ZERO_NOMINAL_PUSCH_PERSISTENT_INVALID");  
        return MAC_FAILURE;
    }
    spsUplinkInfo_p->spsUplinkSetupInfo.
        p0PersistentInfo.p0UePuschPersistent = *msg_p++;
    count++;
    if ((spsUplinkInfo_p->spsUplinkSetupInfo.
                p0PersistentInfo.p0UePuschPersistent < 
                P0_UE_PUSCH_PERSISTENT_MIN_VALUE) || 
            (spsUplinkInfo_p->spsUplinkSetupInfo.
             p0PersistentInfo.p0UePuschPersistent > 
             P0_UE_PUSCH_PERSISTENT_MAX_VALUE))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID, LOGWARNING, MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ulCreateRequest_p->ueIdx,
                spsUplinkInfo_p->spsUplinkSetupInfo.\
                p0PersistentInfo.p0UePuschPersistent,
                internalCellIndex, DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE, FUNCTION_NAME,
                "SPS_UL_P_ZERO_UE_PUSCH_PERSISTENT_INVALID");  
        return MAC_FAILURE;
    }

    *count_p = count;
    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/*****************************************************************************
 * Function Name  : parseRohcProfile
 * Inputs         : message_p - Pointer to the buffer containing the
 *                              values of the Rohc Profile
 *                  msgLength - Length Of API Message
 *                  internalCellIndex - cell index used at MAC
 *                  dlLcInfo_p - Pointer to the LogicalChannelConfigInfo 
 *                  ulLcInfo_p - Pointer to the ulLogicalChannelInfo 
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received
 from RRC at the time of LC configuration and populate
 the  dlLcInfo_p , ulLcInfo_p member
 *****************************************************************************/
STATIC MacRetType parseRohcProfile(
        UInt8 *message_p,
        UInt16 tagLength,
        LogicalChannelConfigInfo* dlLcInfo_p,
        ulLogicalChannelInfo* ulLcInfo_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p  = message_p;

    if (tagLength != ROHC_PROFILE_TAG_LENGTH)
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                ROHC_PROFILE,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_ROHC_PROFILE_LENGTH");

        return MAC_FAILURE;

    }
    dlLcInfo_p->rohcProfile = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    ulLcInfo_p->rohcProfile = dlLcInfo_p->rohcProfile;

    /* Checking the range of the maxUlSpsDciPerTti */
    if ( ROHC_PROFILE_MAX_VALUE <= dlLcInfo_p->rohcProfile )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                dlLcInfo_p->rohcProfile,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_ROHC_PROFILE");

        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/*****************************************************************************
 * Function Name  : parseUEReconfigCompInd
 * Inputs         : message_p - Pointer to the buffer containing the
 *                              values of the UEReconfigCOmplete
 *                  msgLength - Length Of API Message
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : ueReconfigCompInd_p - Pointer to the UEReconfigCompInd struct
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This method will parse the passed buffer that is received
 from RRC when SPS reconfiguration is happening in 
 RRCConnectionReconfiguration or RRCConnectionSetup message.
 *****************************************************************************/
STATIC MacRetType parseUEReconfigCompInd(
        UInt8 *message_p,
        UInt16 msgLength,
        UEReconfigCompInd *ueReconfigCompInd_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p  = message_p;

    if (msgLength != MAC_RECONFIG_COMPLETE_IND_MSG_LEN)
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                MAC_RECONFIG_COMPLETE_IND,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_MAC_RECONFIG_COMPLETE_IND_MSG_LENGTH");

        return MAC_FAILURE;

    }

    /* SPR 20828 Changes Start */
    UInt16 rrcUeIndex = LTE_GET_U16BIT(msg_p);
    ueReconfigCompInd_p->ueIndex = getUeIdxFromRrcUeIdx(rrcUeIndex);
    /* SPR 20828 Changes End */

    msg_p += U16BIT_LEN;

    if (MAC_SUCCESS !=  validateUEIndex( ueReconfigCompInd_p->ueIndex
                /* CA changes Start */
                ,internalCellIndex
                /* CA Changes end */
                ))
    {
        LOG_MAC_MSG(RRC_DEL_UE_MSG_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),MAC_RECONFIG_COMPLETE_IND,
                ueReconfigCompInd_p->ueIndex,
                MAC_INVALID_UE_ID,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"InvalidUEId in MAC_RECONFIG_COMPLETE_IND");

        return MAC_FAILURE;
    }

    ueReconfigCompInd_p->response = *msg_p;
    msg_p++;
    if (MAC_SUCCESS < ueReconfigCompInd_p->response)
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                ueReconfigCompInd_p->response,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_MAC_RECONFIG_COMPLETE_IND_RESPONSE");

        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}
/* SPS_CHG */
/* +DYNAMIC_ICIC */
/****************************************************************************
 * Function Name  : parsePHRTimerConfig
 * Inputs         : message_p - Pointer to the buffer Received
 *                  tagLen - length of the API message received
 *                  ulLCCreateReq_p - pointer to uplink create LC structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to create a UE context.
 *****************************************************************************/
STATIC  MacRetType parsePHRTimerConfig(
        UInt8 **message_p,
        /* +- SPR 17777 */
        UeContextForUplink *ulCreateReq_p)
{
    UInt8 *msg_p = *message_p;

    UInt8 periodicTimer = *msg_p++;
    UInt8 prohTimer = *msg_p++;

    /* Validate the timer values */
    if (MAX_PHR_TIMER < periodicTimer ||
            MAX_PHR_TIMER < prohTimer)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid periodicTimer %u or prohTimer %u\n",periodicTimer,prohTimer); 
        return MAC_FAILURE;
    }

    switch (prohTimer)
    {
        case 0: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 0;
            break;
        }
        case 1: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 10;
            break;
        }
        case 2: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 20;
            break;
        }
        case 3: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 50;
            break;
        }
        case 4: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 100;
            break;
        }
        case 5: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 200;
            break;
        }
        case 6: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 500;
            break;
        }
        case 7: 
        {  
            ulCreateReq_p->phrTimerCfg.prohibitPHRTimer = 1000;
            break;
        }
    }

    ulCreateReq_p->phrGrant = PHR_GRANT_DATA_SIZE;
    *message_p = msg_p;

    return MAC_SUCCESS;
}
/* -DYNAMIC_ICIC */

/*****************************************************************************
 * Function Name  : getTimeWaitDurationForState
 * Inputs         : timeout_p  - Timeout value for the select
 * Outputs        : None
 * Returns        : None
 * Description    : This function will set the timeout value for the select.
 *****************************************************************************/
/* CA Changes start */
void getTimeWaitDurationForState(TimeSpec * timeout_p)
{
    CellState cellState = CELL_INIT;
    UInt8 cellIndex = 0;
    for (cellIndex = 0; cellIndex < MAX_NUM_CELL ; cellIndex++)
    {
        if (cellSpecificParams_g.cellConfigAndInitParams_p[cellIndex])     
        { 
            cellState = cellSpecificParams_g.\
                        cellConfigAndInitParams_p[cellIndex]->cellState;
            switch (cellState)
            {
                case CELL_WAITING_FOR_PHY_CAPABILITY:
                case CELL_WAITING_FOR_FIRST_SFI:

                {
                    timeout_p->tv_nsec = 0;
                    timeout_p->tv_sec = PARAM_REQUEST_WAIT_TIME;
                    break;
                }

                case CELL_PHY_RECONFIG_RECVD_AFTER_CELL_STOP:
                case CELL_PHY_RUNNING_CONFIG_RECVD:
                case CELL_WAITING_FOR_PHY_CONFIG:
                {
                    timeout_p->tv_nsec = 0;
                    timeout_p->tv_sec = CONFIGCELL_RESPONSE_WAIT_TIME;
                    break;
                }
                /* + SPR_10941 */
                case CELL_WAIT_FOR_PHY_START:
                case CELL_WAITING_FOR_PHY_STOP_AFTER_DELETE_REQ:
                case CELL_WAITING_FOR_PHY_STOP_AFTER_STOP_REQ:
                /* - SPR_10941 */
                {
                    timeout_p->tv_nsec = 0;
                    timeout_p->tv_sec  = PHY_STOP_RSP_WAIT_TIME;
                    break;
                }

                case CELL_INIT:                   
                case CELL_PHY_INIT:
                case CELL_PHY_CONFIG:
                case CELL_PHY_STOP:
                case CELL_PHY_RUNNING:
                default:
                break;
            }
        }
    }
}
/* CA Changes end */


/* CA Changes start*/
/*****************************************************************************
 * Function Name  : receiveStartPhyRes 
 * Inputs         : msgBuf  - pointer to the message buffer received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : bytes read
 * Description    : This function  will process the Cell start PHY Response
 *****************************************************************************/
#ifndef FLEXRAN
SInt32 receiveStartPhyRes(UInt8 *msgBuf,InternalCellIndex internalCellIndex)
    /* CA Changes end */

{
    SInt32 bytesRead = 0;
#ifndef TDD_CONFIG
    RDTSC_AND_CLOCK_START_SOCKET;
#endif

    /* CA Changes start*/
        if (0 != (bytesRead = recvControlInfoFromPhysical((void *)msgBuf,
                        internalCellIndex)))
            {
            }
#ifdef LAYER2_PHYSIM_THREAD
            else if (0 != (bytesRead = recvDataFromPhysical((void *)msgBuf,
                            internalCellIndex )))

#else
                /* CHG PURIFY start */
            else if (0 != (bytesRead = recvDataFromPhysicalByLength((void *)msgBuf,
                            FAPI_CTRL_MSG_MAX_BUF_SZ, internalCellIndex)))
                /* CA Changes end */
#endif
                /* CHG PURIFY end */
            {

                /* SPR FIX 10770, 10772, 10717 START  */
                /* Logic to push node in recvDataFromPhyQ_gp[internalCellIndex]
                 * is removed.   
                 */ 
                /* SPR FIX 10770, 10772, 10717 END  */

            }
#ifndef TDD_CONFIG
    /* CA Stats Changes Start */
    RDTSC_AND_CLOCK_END_SOCKET(internalCellIndex);
    /* CA Stats Changes End */
#endif

    return bytesRead;
}
#endif

/* CA Changes start */
/*****************************************************************************
 * Function Name  : sendReConfigPhyCellAfterCellStopRes 
 * Inputs         : transactionId  - identifier of message
 *                  response - response to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will send the response of PHY reconfiguration 
 *                  after cell stop to RRC
 *****************************************************************************/
void sendReConfigPhyCellAfterCellStopRes(UInt16 transactionId, UInt32 response,
        InternalCellIndex internalCellIndex)

{
    /* Irrespective of the retVali, send it to RRC */
    /* Review comment fix start RJ29 */
    if( MAC_SEND_ERROR ==
            /* + coverity 54152 */
            sendPhyCellRespToRRC(PHY_RECONFIG_CELL_CNF,
                (SInt32) transactionId, (MacRetType) response, 
                macCommonGetRRCCellIndex(internalCellIndex) )) 
        /* - coverity 54152 */
        /* CA Changes end */
        /* Review comment fix end RJ29 */
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                MAJOR_ALARM);
    }
    else
    {
        LOG_MAC_MSG(RRC_PHY_CELL_RECONFIG_REQ_ID,LOGWARNING,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                /*destModuleId*/ PHY_MODULE_ID,PHY_RECONFIG_CELL_CNF,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"Mac Reconfig SentRespToRRC");
    }
}


/*****************************************************************************
 * Function Name  : sendConfigPhyCellRes 
 * Inputs         : transactionId  - identifier of message
 *                  response - response to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will send the response of PHY configuration 
 *                  to RRC
 *****************************************************************************/
/* CA Changes start */
void sendConfigPhyCellRes(UInt16 transactionId, UInt32 response,
        InternalCellIndex internalCellIndex)
{
    /* Review comment fix start RJ29 */
    if(MAC_SEND_ERROR == sendPhyCellRespToRRC(PHY_CONFIG_CELL_CNF, 
                /* + coverity 54151 */
                (SInt32) transactionId, (MacRetType)/*retval*/response, 
                macCommonGetRRCCellIndex(internalCellIndex)))
        /* - coverity 54151 */
        /* CA Changes end */
        /* Review comment fix end RJ29 */
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                MAJOR_ALARM);
    }
    else
    {
        LOG_MAC_MSG(RRC_PHY_CELL_CONFIG_REQ_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                /*destModuleId*/PHY_MODULE_ID,/*msgId*/PHY_CONFIG_CELL_CNF,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"PHY_Cell_Config SentRespToRRC");
    }
}

/*****************************************************************************
 * Function Name  : sendStartPhyResDuringMacCellConfig 
 * Inputs         : transactionId  - identifier of message
 *                  response - response to be sent to RRC
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will send the response of CELL Start
 *                  to RRC after CELL is configured at MAC
 *****************************************************************************/
void sendStartPhyResDuringMacCellConfig(UInt16 transactionId, UInt32 response
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA changes End */
        )
{
    UInt32 count = 0;
    CellStartRes cellStartRes = {0};

    cellStartRes.response = response;  
    if(MAC_SUCCESS == response)
    {
        /* SPR 5346 changes start */   
#ifdef FDD_CONFIG        
        UInt32 currentSFN = 0;
        UInt32 currentSF = 0;
        /* SPR 5946 changes start */   
        getSFAndSFN(&currentSFN,&currentSF,internalCellIndex);
        /* SPR 5946 changes end */   
        /* + BUG 12703 */
        /* +- SPR 17777 */
        dummyTxDLControlMsg(PHY_DL_DELAY, currentSFN, 
                currentSF,internalCellIndex);
        /* +- SPR 17777 */
        /* - BUG 12703 */
#endif
		/* SPR 5346 changes end */   
		/* SPR 7787 fix start */
		/* SPR 4915 : Start */
		/* SPR 8638 Start */
#ifdef TDD_CONFIG
		/* Commneted for compilation of TDD CA */
        {
            initUlDLExecutionFlow(internalCellIndex);
            initMacTDDConfig(internalCellIndex);
            populateTddELSchedulerArray(cellSpecificParams_g.\
                    cellConfigAndInitParams_p[internalCellIndex]->cellParams_p, internalCellIndex);
            assignTddPdschTxMapOfDLHarqPointer(cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                    cellParams_p->subFrameAssign, internalCellIndex);
        }
#endif
        /* SPR 8638 End */

        /* SPR 7787 fix start */
#ifndef FLEXRAN
        lteFD_CLR(phyRxSockFD_g[internalCellIndex], &staticReadFds);
#endif
        /* SPR 7787 fix end */

        while (count < NUM_OF_EXEC_FLOWS)
        {
            semPostDefault(&waitForCellSetupIndSemArr_g[(internalCellIndex * NUM_OF_EXEC_FLOWS) + count]);
            count++;
        }

        /* SPR 4915 : End */
        cellStartRes.sfn = getSysFrameNumer(internalCellIndex);

        LOG_MAC_MSG(RRC_MAC_CELL_START_REQ_ID, LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reConfigFailValues_g[internalCellIndex][0],reConfigFailValues_g[internalCellIndex][1],
                reConfigFailValues_g[internalCellIndex][2],reConfigFailValues_g[internalCellIndex][3],
                reConfigFailValues_g[internalCellIndex][4],
                (UDouble32)reConfigFailValues_g[internalCellIndex][5],
                (UDouble32)reConfigFailValues_g[internalCellIndex][6],
                FUNCTION_NAME,"MAC_CELL_START Successful");

    }
    cellStartRes.transactionId = transactionId;
    /* Review comment fix start RJ29 */
    /* CA changes Start */
    if( MAC_SEND_ERROR == sendMsgToRRC(MAC_CELL_START_CNF,
                &cellStartRes, macCommonGetRRCCellIndex(internalCellIndex)))
        /* CA changes End */
        /* Review comment fix end RJ29 */
    {
        ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                MAJOR_ALARM);
    }
    return;
}

/*****************************************************************************
 * Function Name  : sendStopPhyCellStopRes 
 * Inputs         : transactionId  - identifier of message
 *                  response - response to be sent to RRC
 *                  cellIndex - cell index sent by RRC 
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will send the response of CELL Stop
 *                  to RRC 
 *****************************************************************************/
/* CA Changes start */
void sendStopPhyCellStopRes(UInt16 transactionId, UInt32 response,
        RrcCellIndex cellIndex)
{

    InternalCellIndex internalCellIndex = 
        macCommonGetInternalCellIndex(cellIndex);
    resetCurrentTick(internalCellIndex);
    /* CA Changes end */
    /* MAC move to configure state */
    if (MAC_SUCCESS == response)
    {
        LOG_MAC_MSG(RRC_PHY_CELL_STOP_RES_ID, LOGINFO,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                /*destModuleId*/DEFAULT_INT_VALUE,/*msgId*/2 /*PHY_CONFIG_WITH_EXPLICIT_START*/,
                cellIndex,internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "sendPhyCellRespToRRC Success CNF");
        /* Review comment fix start RJ29 */
        /* Rel 5.3: Coverity 54149 Fix Start */
        /* CA Changes start  */
        if( MAC_SEND_ERROR == 
                sendPhyCellRespToRRC(PHY_CELL_STOP_CNF,
                    transactionId, (MacRetType)response, cellIndex))
            /* CA Changes end  */
            /* Rel 5.3: Coverity 54149 Fix End */
            /* Review comment fix start RJ29 */
        {
            ALARM_MSG (MAC_MODULE_ID, 
                    SEND_MSG_FAILED_ALARM_ID,
                    MAJOR_ALARM);
        }
        else
        {
            LOG_MAC_MSG(RRC_PHY_CELL_STOP_RES_ID, LOGINFO,
                    MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    /*destModuleId*/DEFAULT_INT_VALUE,/*msgId*/PHY_CELL_STOP_CNF,cellIndex,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "sendPhyCellRespToRRC Failed to send CNF");
        }
    }
}

/*****************************************************************************
 * Function Name  : sendStopPhyCellDeleteRes 
 * Inputs         : transactionId  - identifier of message
 *                  response - response to be sent to RRC
 *                  cellIndex - cell index sent by RRC 
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will send the response of CELL DELETE
 *                  to RRC 
 *****************************************************************************/
/* CA Changes start */
void sendStopPhyCellDeleteRes(UInt16 transactionId, UInt32 response,
        RrcCellIndex cellIndex)
{
    /*KLOCKWORK_CHANGES_START_99 */ 
#ifdef  LOG_PRINT_ENABLED 
    InternalCellIndex internalCellIndex = macCommonGetInternalCellIndex(cellIndex);
#endif
    /*KLOCKWORK_CHANGES_STOP_99 */ 
    /* CA Changes end */
    if (MAC_SUCCESS == response)
    {
        if( MAC_SEND_ERROR == 
                sendPhyCellRespToRRC(PHY_DELETE_CELL_CNF,
                    transactionId, MAC_SUCCESS, cellIndex))
        {
            ALARM_MSG (MAC_MODULE_ID, 
                    SEND_MSG_FAILED_ALARM_ID,
                    MAJOR_ALARM);
        }
        else
        {
#ifdef  LOG_PRINT_ENABLED 
            LOG_MAC_MSG(RRC_PHY_DELETE_CELL_REQ_ID,LOGINFO,
                    MAC_RRC_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    /*destModuleId*/DEFAULT_INT_VALUE,PHY_DELETE_CELL_CNF,cellIndex,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"sendPhyCellRespToRRC");
#endif
        }
    }
    else
    {
#ifdef  LOG_PRINT_ENABLED 
        LOG_MAC_MSG(RRC_PHY_DELETE_CELL_REQ_ID, LOGERROR,
                MAC_L1_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                /*destModuleId*/DEFAULT_INT_VALUE,/*msgId*/PHY_DELETE_CELL_CNF, cellIndex,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PHY_DELETE_CELL_FAIL, No PHY response");
#endif
    }
}

#ifdef UTFWK_SIMULATION

/*****************************************************************************
 * Function Name  : receiveForPhyResMsgs 
 * Inputs         : msgBuf  - message buffer pointer
 * Outputs        : None
 * Returns        : Bytes Read
 * Description    : This function  process START PHY response.
 *                  
 *****************************************************************************/
SInt32 receiveForPhyResMsgs(UInt8 * msgBuf)
{
    SInt32 byteRead = 0;
    switch (waitFromStateEvent_g)
    {
        case WAITING_FOR_PHY_START_RES_ST:
        /*SPR 6043 Fix Start */
        case WAITING_FOR_PHY_EXPLICIT_START_RES_ST:
        /*SPR 6043 Fix End */
        byteRead = receiveStartPhyRes(msgBuf);
        break;

        case WAITING_FOR_PHY_MAC_INIT_LAYER_RES_ST:
        case WAITING_FOR_PHY_CONFIG_CELL_RES_ST:
        case WAITING_FOR_PHY_RECONFIG_CELL_RES_ST:
        byteRead = recvControlInfoFromPhysical((void *)msgBuf);
        break;

        case WAITING_FOR_PHY_CELL_STOP_RES_ST:
        byteRead = receiveStartPhyRes(msgBuf);
        break;

        case WAITING_FOR_PHY_DELETE_CELL_RES_ST:
        byteRead = receiveStartPhyRes(msgBuf);
        break;
        default:
        lteWarning("Error waitFromStateEvent_g[%d]\n",waitFromStateEvent_g);
        break;

    }
    return byteRead;
}
/*****************************************************************************
 * Function Name  : processWaitingForPhyResMsgs 
 * Inputs         : transactionId  - identifier of message
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process the CELL related Procedures 
 *                  CELL stop/start etc
 *****************************************************************************/
void processWaitingForPhyResMsgs(UInt16 transactionId)
{
    UInt32 ret = 0;
    UInt32 loop_count = 1000;

    UInt32 reTry = 1;
    TimeSpec timer;
    /* + Coverity_Stack Fix */
    UInt8 *msgBuf = PNULL;
    msgBuf = (UInt8 *)getMemFromPool(FAPI_CTRL_MSG_MAX_BUF_SZ, PNULL);
    /* - Coverity_Stack Fix */
    /* Coverity 31152 Fix Start*/
    if(!msgBuf)
    {
        return ;
    }
    /* Coverity 31152 Fix End*/ 

    SInt32 byteRead = 0;

    timer.tv_nsec = 50000000;
    timer.tv_sec = 0;
    if (-1 == pselect_wrapper(1, PNULL, PNULL, PNULL, &timer, PNULL))
    {
        /* SPR 7385 Changes Starts */
        /* SPR 7976 */
        lteWarning("select failed\n");
        freeMemPool(msgBuf);
        return;
        /* SPR 7976 */
        /* SPR 7385 Changes Ends */
    }

    while (loop_count--)
    {
        byteRead = receiveForPhyResMsgs(msgBuf);
        if(byteRead > 0 )
        {
            switch (waitFromStateEvent_g)
            {

                case WAITING_FOR_PHY_MAC_INIT_LAYER_RES_ST:
                ret  = handlePhyParamReqResp(msgBuf,byteRead);
                sendMacInitLayerRes(transactionId,ret);
                freeMemPool(msgBuf);
                return ;

                /*SPR 6043  Fix Start */
                case WAITING_FOR_PHY_EXPLICIT_START_RES_ST:
                /*SPR 6043 Fix End */
                ret  = handleStartPhyRes(msgBuf,byteRead);
                sendStartPhyResDuringMacCellConfig(transactionId,ret);
                freeMemPool(msgBuf);
                return ;
                case WAITING_FOR_PHY_CONFIG_CELL_RES_ST:
                ret  = handleConfigPhyCellRes(msgBuf,byteRead);
                sendConfigPhyCellRes(transactionId,ret);
                freeMemPool(msgBuf);
                return ;

                case WAITING_FOR_PHY_RECONFIG_CELL_RES_ST:
                case WAITING_FOR_RUNNING_PHY_RECONFIG_CELL_RES_ST :
                ret  = handleReConfigPhyCellAfterCellStop(msgBuf,byteRead);
                sendReConfigPhyCellAfterCellStopRes(transactionId,ret);
                freeMemPool(msgBuf);
                return ;

                break;

                case WAITING_FOR_PHY_CELL_STOP_RES_ST:
                ret  = handleStopPhyRes(msgBuf,byteRead);
                sendStopPhyCellStopRes(transactionId,ret,macCommonGetRRCCellIndex(internalCellIndex));
                freeMemPool(msgBuf);
                return ;

                case WAITING_FOR_PHY_DELETE_CELL_RES_ST:
                ret  = handleStopPhyRes(msgBuf,byteRead);
                sendStopPhyCellDeleteRes(transactionId,ret);
                freeMemPool(msgBuf);
                return ;
                default:
                freeMemPool(msgBuf);
                return;
            }
        }
        else 
        {
            /*waiting for response*/
            timer.tv_nsec = 50000000;
            timer.tv_sec = 0;
            if (-1 == pselect_wrapper(1, PNULL, PNULL, PNULL, &timer, PNULL))
            {
                /* SPR 7385 Changes Starts */
                /* SPR 7976 */
                lteWarning("select failed\n");
                freeMemPool(msgBuf);
                /* SPR 7976 */
                /* SPR 7385 Changes Ends */
            }

            switch (waitFromStateEvent_g)
            {
                case WAITING_FOR_PHY_MAC_INIT_LAYER_RES_ST:
                if( reTry++ < MAX_PARAM_MAC_INIT_REQUEST_RETRY)
                {
                    fapiSendPhyParamReq();
                }
                else 
                {
                    sendMacInitLayerRes(transactionId,MAC_FAILURE,internalCellIndex);
                    freeMemPool(msgBuf);
                    return;
                }
                break;


                case WAITING_FOR_PHY_CONFIG_CELL_RES_ST:
                if( reTry++ < MAX_PARAM_PHY_CONFIG_REQUEST_RETRY)
                {
/* Coverity # 62894*/
                    sendConfigPhyCell();
                }
                else 
                {
                    sendConfigPhyCellRes(transactionId,MAC_FAILURE);
                    freeMemPool(msgBuf);
                    return;
                }
                break;

                case WAITING_FOR_PHY_RECONFIG_CELL_RES_ST:
                case WAITING_FOR_RUNNING_PHY_RECONFIG_CELL_RES_ST :
                if( reTry++ < MAX_PARAM_PHY_RECONFIG_REQUEST_RETRY)
                {
                    sendReConfigPhyCellAfterCellStop();
                }
                else 
                {
                    sendReConfigPhyCellAfterCellStop(transactionId,MAC_FAILURE);
                    freeMemPool(msgBuf);
                    return;
                }
                break;
            }
        }
    }
    freeMemPool(msgBuf);
}

/*****************************************************************************
 * Function Name  : ElprocessOAMAndRRCMsg 
 * Inputs         : numOfMsg - number of Messages received from OAM/RRM
 *                  delayToPhy - Delay TTI to phy
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process OAM and RRC Messages
 *****************************************************************************/
void ElprocessOAMAndRRCMsg(UInt8 numOfMsg, UInt32 delayToPhy)
{
    UInt8 mem_type = 0;
    UInt8 *msgBuf       = PNULL;
    SInt32 bytesRead     = 0;
    UInt16 transactionId = 0;
    UInt8 msgHdr[RRC_MAC_API_HEADER_LEN] = {0};
    LTE_GCC_UNUSED_PARAM(delayToPhy)
        while (numOfMsg--)  
        {
            msgBuf = receiveOAMAndRRCMsg(msgHdr,&bytesRead,&mem_type);
            if(PNULL != msgBuf)
            {
                transactionId = LTE_GET_U16BIT(msgHdr);
                waitFromStateEvent_g = 0;
                /* +- SPR 17777 */
                processOAMAndRRCMsg(msgHdr,msgBuf,bytesRead); 
                if(0 == mem_type )
                {
                    freeMemPool(msgBuf);
                }
                if(waitFromStateEvent_g)
                {
                    /*this is a porting fuction*/
                    processWaitingForPhyResMsgs(transactionId);
                }
            }
        }
}
#endif
/*****************************************************************************
 * Function Name  : lteMacProcessControlInfoFromPhysical 
 * Inputs         : delayToPhy - Delay to phy
 *                  recvBuffer_p - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process control Information 
 *                  Received from Physical layer 
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacProcessControlInfoFromPhysical( void* recvBuffer_p, 
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    processControlInfoFromPhysical(recvBuffer_p,byteRead,internalCellIndex);
}
/* CA Changes end */
/*****************************************************************************
 * Function Name  : ElProcessReqTimerExpireHandlerFSM 
 * Inputs         : internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process the timeout Events for PHY states
 *****************************************************************************/
void ElProcessReqTimerExpireHandlerFSM(InternalCellIndex internalCellIndex)
{
    /* +- SPR 18490 */
    static UInt8 reTry[MAX_NUM_CELL] = {1,1};

    CellState cellState =  cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                           cellState;

    LOG_MAC_MSG( PHY_MAC_STATE_MACHINE_HANDLER, LOGDEBUG, MAC_L1_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), MAC_REQ_TIMEOUT_RETRY_EV,0,0
            ,__LINE__, 0, 0 ,0, __func__, "" );
    /* +SPR_11258 Changes */
    /* +- SPR 17777 */
    lteLPrioThrPhyApiHandlerFuncTable[cellState][MAC_REQ_TIMEOUT_RETRY_EV](
            &(reTry[internalCellIndex]), 0,internalCellIndex);
    /* -SPR_11258 Changes */
}
/*****************************************************************************
 * Function Name  : ElProcessPhyResForOAMAndRRCMsgFSM 
 * Inputs         : recvBuffer
 *                  byteRead
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process the PHY Event on PHY states
 *****************************************************************************/
/* CA Changes start */
void ElProcessPhyResForOAMAndRRCMsgFSM(UInt8* recvBuffer_p, UInt16 byteRead,
        InternalCellIndex internalCellIndex)
{

    /* +- SPR 18490 */
    CellState cellState =  cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                           cellState;

    LOG_MAC_MSG( PHY_MAC_STATE_MACHINE_HANDLER, LOGDEBUG, MAC_L1_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, internalCellIndex, 
            MAC_RECV_MSG_FROM_PHY_EV, byteRead,0,0,0, 
            __func__, "" );
    /* +- SPR 17777 */
    lteLPrioThrPhyApiHandlerFuncTable[cellState][MAC_RECV_MSG_FROM_PHY_EV](
            recvBuffer_p,byteRead,internalCellIndex);
    /* +- SPR 16091 */
}


/* CA Changes end */
/*****************************************************************************
 * Function Name  : lteMacMacInitLayerPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Phy Parameter Request and
 send the MAC INIT Layer Response to OAM.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacMacInitLayerPhyHandler ( void * msgBuf,
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt32 ret = 0;
    ret  = handlePhyParamReqResp(msgBuf,byteRead, internalCellIndex);
    /*Coverity Fix*/

    if(ret)
    {
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellState = CELL_PHY_INIT;
    }
    else
    {
        /* +SPR_11258 Changes */
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellState = CELL_INIT;
        /* -SPR_11258 Changes */
    }
    /* SPR 16091 fix start */
    sendMacInitLayerRes(phyInitTransactionId_g,ret,internalCellIndex);
    /*SPR 16417 Fix Start*/
    phyInitTransactionId_g = (UInt16)INVALID_TRANS_ID;
    /*SPR 16417 Fix End*/
    /* SPR 16091 fix end */
}
/* CA Changes end */

/*****************************************************************************
 * Function Name  : lteMacStartPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Phy start Request and
 *                  send the CELL start Response to OAM. 
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacStartPhyHandler (void * msgBuf, 
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt32 ret = 0;
    ConfigCellRes configCellRes = {0};
    /* + SPR_10009 */ 
    CellStartRes cellStartRes = {0};
    /* - SPR_10009 */
      CellConfigParams *cellParams_p = PNULL;

	/** SPR 14505 Changes **/
    /* CellConfigParams * */cellParams_p = cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
	/** SPR 14505 Changes **/
	/* + Critical section changes */
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
    UInt8 isOtherCellStateRunning = 0;  
#endif

	/* - Critical section changes */
	/* Coverity 63746 Changes Start */
    if(internalCellIndex < MAX_NUM_CELL)
    {
        ret  = handleStartPhyRes(msgBuf,byteRead,internalCellIndex);
        if(ret)
        {
            /** SPR 14505 Changes **/
            if(cellParams_p)
            {
                if( PNULL !=  pTxReqMsgBuff_gp[internalCellIndex] )
                {
                    freeMemPool(pTxReqMsgBuff_gp[internalCellIndex]);
                }
                if(cellParams_p->numOfTxAnteenas == NUM_OF_TX_ANTENNAS_4 && cellParams_p->dlAvailableRBs == 100)
                {
                    GET_MEM_FROM_POOL(UInt8, pTxReqMsgBuff_gp[internalCellIndex], 2 * DATA_BUFFER_SIZE, PNULL);
                }
                else
                {
                    GET_MEM_FROM_POOL(UInt8, pTxReqMsgBuff_gp[internalCellIndex], DATA_BUFFER_SIZE, PNULL);
                }
            }
			/** SPR 14505 Changes **/
/*Dual Cell change start*/
/*Dual Cell change End*/

            /* + Critical section changes */
                    if (IS_CA_ENABLED())
                    {
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
                        semWait(&cellSyncSem_g);
#endif
/*Dual Cell Change start*/
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                            cellState = CELL_PHY_RUNNING;
/*Dual Cell Change End*/
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))

                        /* If CA is ON and other cell is also running then write sync according to
                         * cell sync tracker state */   
                        isOtherCellStateRunning = CHECK_CELL_STATE(!internalCellIndex);

                        lteMacInterfacePostAllSyncFds(internalCellIndex, isOtherCellStateRunning);

                        if(macParams_g.lowestRunningCellIndex > internalCellIndex)
                        {
                            macParams_g.lowestRunningCellIndex = internalCellIndex;
                        }

                        /* SPR 13132 Changes Start */
                        resetPrevTickEventFdContainer(internalCellIndex);
                        /* SPR 16617 Changes Start */
                        semPost(&cellSyncSem_g);
                        /* SPR 16617 Changes Start */
#if defined TDD_CONFIG && !defined SEM_SYNC
                        /* SPR 16617 Changes End */
                        //eventFD_t tempfd = {0};
                        if((isOtherCellStateRunning) && (
                                    (getCurrentTickForCell(internalCellIndex))  == (getCurrentTickForCell(!internalCellIndex)+1)))
                        {
                            //eventfd_read_wrapper(ev_fd_sfi_g[!internalCellIndex],&tempfd);
                        }
#endif                
				/* SPR 13132 Changes End  */
#endif      
                    }
            else
            {
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                    cellState = CELL_PHY_RUNNING;
            }   

            /* - Critical section changes */
            postCellSetupInd(internalCellIndex);
            /* Clear the PHY RX SockFd as the subsequent ticks will now be
             * received from the MAC thread  */
#ifndef FLEXRAN
            lteFD_CLR(phyRxSockFD_g[internalCellIndex], &staticReadFds);
#endif

        }

		/* + SPR_10009 */ 
		if (cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
               explicitStartRequired)
       {
           cellStartRes.response = ret;  
           cellStartRes.sfn = getSysFrameNumer(internalCellIndex);
           cellStartRes.transactionId = transactionId_g[internalCellIndex];
			/* Review comment fix start RJ29 */
			/* CA changes Start */
           if( MAC_SEND_ERROR == sendMsgToRRC(MAC_CELL_START_CNF,
                       &cellStartRes, macCommonGetRRCCellIndex(internalCellIndex)))
				/* CA changes End */
				/* Review comment fix end RJ29 */
           {
               ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                       MAJOR_ALARM);
           }
           cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
               explicitStartRequired = FALSE;
			/* +SPR_11258 Changes */
           if(MAC_FAILURE == ret)
           {
               cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                   cellState = CELL_WAIT_FOR_PHY_START;
           }
			/* -SPR_11258 Changes */
       }
       else
       {
           {
               configCellRes.response = ret;
               configCellRes.transactionId = transactionId_g[internalCellIndex];
			/* + SPR_10846 */
               if(MAC_SEND_ERROR ==
                       sendMsgToRRC(MAC_CONFIG_CELL_CNF, &configCellRes, macCommonGetRRCCellIndex(internalCellIndex)))
				/* - SPR_10846 */
               {
                   ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                           MAJOR_ALARM);
               }
			/* +SPR_11258 Changes */
               if(MAC_FAILURE == ret)
               {
                   cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                       cellState = CELL_PHY_CONFIG;
               }
			/* -SPR_11258 Changes */
           }
       }
		/* - SPR_10009 */ 
       transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
    }
	/* Coverity 63746 Changes End */
}
/* CA Changes end */


/*****************************************************************************
 * Function Name  : lteMacConfigCellReqPhyHandler
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell configuration request
 *                  and send response to OAM.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacConfigCellReqPhyHandler (void * msgBuf,
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt32 ret = 0;
    ret  = handleConfigPhyCellRes(msgBuf,byteRead);
    if(ret)
    {
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->
            cellState = CELL_PHY_CONFIG;
    }
    else
    {
        /* +SPR_11258 Changes */
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->
            cellState = CELL_PHY_INIT;
        /* -SPR_11258 Changes */
    }
    {
        sendConfigPhyCellRes( transactionId_g[internalCellIndex], ret,
                internalCellIndex );
        /* SPR 16091 fix start */
        transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        /* SPR 16091 fix end */
    }
}

/******************************************************************************
 * Function Name  : lteMacReconfigCellReqPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell Reconfiguration request
 *                  and send response to OAM.
 *****************************************************************************/
void lteMacReconfigCellReqPhyHandler (void * msgBuf,
        SInt32 byteRead, InternalCellIndex internalCellIndex)
{
    UInt32 ret = 0;
    ret  = handleReConfigPhyCellAfterCellStop(msgBuf,byteRead,
            internalCellIndex);
    /* +SPR_11258 Changes */
    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
        cellState = CELL_WAIT_FOR_PHY_START;
    /* -SPR_11258 Changes */
    sendReConfigPhyCellAfterCellStopRes(transactionId_g[internalCellIndex],
            ret,internalCellIndex);
    /* SPR 16091 fix start */
    transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
    /* SPR 16091 fix end */
}

/*****************************************************************************
 * Function Name  : lteMacCellStopReqPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell Stop request
 *                  and send response to OAM.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacCellStopReqPhyHandler (void * msgBuf,
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt32 ret = 0;
    ret  = handleStopPhyRes(msgBuf,byteRead);

    /* + SPR_10941 */
    /* + Coverity 72761 */
    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
        cellState =         CELL_WAIT_FOR_PHY_START;
    /* Dual Cell delete/setup start */
    /* SPR 21412 Fix Start */
    /* SPR 21412 Fix End */
    /* Dual Cell delete/setup end */
    /* - SPR_10941 */
    /* - Coverity 72761 */
    sendStopPhyCellStopRes(transactionId_g[internalCellIndex],
            ret,macCommonGetRRCCellIndex(internalCellIndex));
    /* + SPR_10941 */
    transactionId_g[internalCellIndex] = INVALID_TRANS_ID; 
    /* - SPR_10941 */
}
/* CA Changes end */
/*****************************************************************************
 * Function Name  : lteMacCellDeleteReqPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell Delete request
 *                  and send response to OAM.
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacCellDeleteReqPhyHandler (void * msgBuf, 
        SInt32 byteRead, InternalCellIndex internalCellIndex)
{
    UInt32 ret = 0;
    ret  = handleStopPhyRes(msgBuf,byteRead);
    /* +SPR_11258 Changes */
    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
        cellState = CELL_PHY_STOP;
    /* -SPR_11258 Changes */
    /* SPR 21412 Fix Start */
    //Changing the Phy State of Both cells as only stop for Cell 0 is send
    if(cellSpecificParams_g.numOfCells > 1)
    {
        cellSpecificParams_g.cellConfigAndInitParams_p[!internalCellIndex]->\
            cellState = CELL_PHY_STOP;
    }
    /* SPR 21412 Fix End */
    sendStopPhyCellDeleteRes(transactionId_g[internalCellIndex],ret,
            macCommonGetRRCCellIndex(internalCellIndex));
    /* SPR 16091 fix start */
    transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
    /* SPR 16091 fix end */

}

/* CA Changes end */

/*****************************************************************************
 * Function Name  : lteMacInvalidPhyCellEvent
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process invalid event received from PHY. 
 *****************************************************************************/
/* CA Changes start */
/* +- SPR 17777 */
void lteMacInvalidPhyCellEvent(void * msgBuf,
        SInt32 byteRead, InternalCellIndex internalCellIndex)
{
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(msgBuf)
        LTE_GCC_UNUSED_PARAM(internalCellIndex)
        LTE_GCC_UNUSED_PARAM(byteRead)
        /* +- SPR 17777 */

}
/* CA Changes end */

/*****************************************************************************
 * Function Name  : lteMacReTryMacInitLayerPhyHandler 
 * Inputs         :
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process PHY param Request
 *                   on Time outand send MAC INIT LAYER response to OAM.
 *****************************************************************************/
/* CA Changes start */

/* +- SPR 17777 */
void lteMacReTryMacInitLayerPhyHandler ( void * msgBuf,
        SInt32 byteRead,InternalCellIndex internalCellIndex)  
{
    UInt8* reTry_p =  (UInt8 *)msgBuf;

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex)  ,
            /* SPR 16091 fix start */
            __LINE__, phyInitTransactionId_g,cellSpecificParams_g.\
            /* SPR 16091 fix end */
            cellConfigAndInitParams_p[internalCellIndex]->cellState,
            internalCellIndex,byteRead, 0, 0, __func__, "PARAM_REQ" );

    /* +SPR_11258 Changes */
    LOG_MAC_MSG( MAC_PHY_MSG_RETRANSMISSION, LOGDEBUG, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, *reTry_p, 
            cellSpecificParams_g.cellConfigAndInitParams_p\
            [internalCellIndex]->cellState,
            MAX_PARAM_MAC_INIT_REQUEST_RETRY, internalCellIndex,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"PhyInitReq");
    if( (*reTry_p)++ < MAX_PARAM_MAC_INIT_REQUEST_RETRY)
    {
        /* + Coverity_62934 */ 
        if( MAC_FAILURE == 	fapiSendPhyParamReq(internalCellIndex))
        {
            *reTry_p = 1;
            transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        }    
        /* - Coverity_62934 */ 
    }
    else
    {
        /* SPR 16091 fix start */
        sendMacInitLayerRes(phyInitTransactionId_g,
                MAC_FAILURE,internalCellIndex);
        /*SPR 16417 Fix Start*/
        phyInitTransactionId_g = (UInt16)INVALID_TRANS_ID;
        /*SPR 16417 Fix End*/
        *reTry_p = 1;
        /* SPR 16091 fix end */
        transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellState = CELL_INIT;
        /* -SPR_11258 Changes */
    }
}
/* CA Changes end */

/*****************************************************************************
 * Function Name  : lteMacReTryConfigCellReqPhyHandler 
 * Inputs         : 
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell configuration request
 *                  on  timout  and send response to RRC.
 *****************************************************************************/
/* CA Changes start */

/* +- SPR 17777 */
void lteMacReTryConfigCellReqPhyHandler (void * msgBuf,
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt8* reTry_p =  (UInt8 *)msgBuf;

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, transactionId_g[internalCellIndex], cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState,
            internalCellIndex,byteRead, 0, 0, __func__, "CONFIG_REQ" );

    /* +SPR_11258 Changes */
    LOG_MAC_MSG( MAC_PHY_MSG_RETRANSMISSION, LOGDEBUG, MAC_L1_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__,  *reTry_p, cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState,
            MAX_PARAM_PHY_CONFIG_REQUEST_RETRY, internalCellIndex,
            0,0, __func__, "ConfigReq" );
    if( (*reTry_p)++ < MAX_PARAM_PHY_CONFIG_REQUEST_RETRY)
    {
        sendConfigPhyCell(internalCellIndex);
    }
    else
    {
        sendConfigPhyCellRes(transactionId_g[internalCellIndex],
                MAC_FAILURE,internalCellIndex);
        *reTry_p = 1;
        transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellState = CELL_PHY_INIT;
        /* -SPR_11258 Changes */
    }
}

/* CA Changes end */

/*****************************************************************************
 * Function Name  : lteMacReTryReconfigCellReqInPhyRunningPhyHandler 
 * Inputs         :
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell reconfiguration request
 *                  and send response to OAM.
 *****************************************************************************/
/* +- SPR 17777 */
void lteMacReTryReconfigCellReqInPhyRunningPhyHandler(void * msgBuf,
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{

    UInt8* reTry_p =  (UInt8 *)msgBuf;

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, transactionId_g[internalCellIndex], cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState,
            internalCellIndex,byteRead, 0, 0, __func__, "MINOR_RECONFIG_REQ" );

    /* +SPR_11258 Changes */
    LOG_MAC_MSG( MAC_PHY_MSG_RETRANSMISSION, LOGDEBUG, 
            MAC_L1_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__,  *reTry_p, cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState, 
            MAX_PARAM_PHY_RECONFIG_REQUEST_RETRY, internalCellIndex, 0, 0, 
            __func__, "PhyReconfigReq");

    if( (*reTry_p)++ < MAX_PARAM_PHY_RECONFIG_REQUEST_RETRY)
    {


    }
    else
    {
        if( MAC_SEND_ERROR == sendPhyCellRespToRRC(PHY_RECONFIG_CELL_CNF,
                    transactionId_g[internalCellIndex],
                    MAC_FAILURE,macCommonGetRRCCellIndex(internalCellIndex) ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                    MAJOR_ALARM);
        }
        *reTry_p = 1;
        transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        /* +SPR_11258 Changes */
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellState = CELL_PHY_RUNNING;
        /* -SPR_11258 Changes */
    }
    /* -SPR_11258 Changes */
}
/*****************************************************************************
 * Function Name  : lteMacReTryReconfigCellReqAfterCellStopPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex
 * Outputs        : None
 * Returns        : None
 * Description    : This function  will process Cell reconfiguration request
 *                  and send response to OAM.
 *****************************************************************************/
/* CA Changes start */

/* +- SPR 17777 */
void lteMacReTryReconfigCellReqAfterCellStopPhyHandler (void * msgBuf, 
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt8* reTry_p =  (UInt8 *)msgBuf;

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, transactionId_g[internalCellIndex], cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState,
            internalCellIndex,byteRead, 0, 0, __func__, "MAJOR_RECONFIG_REQ" );

    /* +SPR_11258 Changes */
    LOG_MAC_MSG( MAC_PHY_MSG_RETRANSMISSION, LOGDEBUG, 
            MAC_L1_INF, GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__,  *reTry_p, cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState, 
            MAX_PARAM_PHY_RECONFIG_REQUEST_RETRY, internalCellIndex, 0, 0, 
            __func__, "PhyReconfigReq");

    if( (*reTry_p)++ < MAX_PARAM_PHY_RECONFIG_REQUEST_RETRY)
    {
        /* + SPR_13064 */ 
        sendReConfigPhyCellAfterCellStop(internalCellIndex);
        /* - SPR_13064 */ 
    }
    else
    {
        sendReConfigPhyCellAfterCellStopRes(transactionId_g[internalCellIndex],
                MAC_FAILURE,internalCellIndex);
        *reTry_p = 1;
        transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            cellState = CELL_WAIT_FOR_PHY_START;
        /* -SPR_11258 Changes */
    }
}

/* CA Changes end */

/*****************************************************************************
 * Function Name  : lteMacReTryStartPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function will process implicit Cell start Request on
 *                  timeout
 *****************************************************************************/

/* +- SPR 17777 */
void lteMacReTryStartPhyHandler (void * msgBuf, 
        SInt32 byteRead, InternalCellIndex internalCellIndex)
{
    UInt8* reTry_p =  (UInt8 *)msgBuf;
    CellStartRes cellStartRes = {0};
    ConfigCellRes configCellRes = {0};

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, transactionId_g[internalCellIndex], cellSpecificParams_g.\
            cellConfigAndInitParams_p[internalCellIndex]->cellState,
            internalCellIndex,byteRead, 0, 0, __func__, "PHY_START_REQ" );

    if (cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
            explicitStartRequired)
    {      
        /* +SPR_11258 Changes */
        LOG_MAC_MSG( MAC_PHY_MSG_RETRANSMISSION, LOGDEBUG, MAC_L1_INF, 
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                __LINE__,  *reTry_p, cellSpecificParams_g.\
                cellConfigAndInitParams_p[internalCellIndex]->cellState,
                MAX_PARAM_PHY_START_REQUEST_RETRY, internalCellIndex,
                0, 0, __func__, "ExplicitStart");

        if( (*reTry_p)++ < MAX_PARAM_PHY_START_REQUEST_RETRY)
        {
            /* Retry for PHY start request and sends the response if any 
             * failure occurs */
            if( MAC_FAILURE == sendMacCellStartReq( transactionId_g[internalCellIndex],
                        internalCellIndex) )
            {
                *reTry_p = 1;
                transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
                cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                    cellState = CELL_WAIT_FOR_PHY_START;
                /* -SPR_11258 Changes */
            }
        }
        else
        {
            cellStartRes.response = MAC_FAILURE;  
            cellStartRes.sfn = getSysFrameNumer(internalCellIndex);
            cellStartRes.transactionId = transactionId_g[internalCellIndex];
            /* Review comment fix start RJ29 */
            /* CA changes Start */
            if( MAC_SEND_ERROR == sendMsgToRRC(MAC_CELL_START_CNF,
                        &cellStartRes, macCommonGetRRCCellIndex(internalCellIndex)))
                /* CA changes End */
                /* Review comment fix end RJ29 */
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                        MAJOR_ALARM);
            }
            /* +SPR_11258 Changes */
            *reTry_p = 1;
            transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                cellState = CELL_WAIT_FOR_PHY_START;
            /* -SPR_11258 Changes */
        }
    }
    else 
    {    
        /* +SPR_11258 Changes */
        LOG_MAC_MSG( MAC_PHY_MSG_RETRANSMISSION, LOGDEBUG, MAC_L1_INF, 
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                __LINE__,  *reTry_p, cellSpecificParams_g.\
                cellConfigAndInitParams_p[internalCellIndex]->cellState,
                MAX_PARAM_PHY_START_REQUEST_RETRY, internalCellIndex,
                0, 0, __func__, "ImplicitStart");

        if( (*reTry_p)++ < MAX_PARAM_PHY_START_REQUEST_RETRY)
        {
            sendStartPhyInd(internalCellIndex);
        }
        else
        {
            /* Send failure to L3 for MAC_CONFIG_CELL_REQ */
            configCellRes.response = MAC_FAILURE;
            configCellRes.transactionId = transactionId_g[internalCellIndex];
            if(MAC_SEND_ERROR ==
                    sendMsgToRRC(MAC_CONFIG_CELL_CNF, &configCellRes,
                        macCommonGetRRCCellIndex(internalCellIndex)))
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                        MAJOR_ALARM);
            }

            *reTry_p = 1;

            transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
                cellState = CELL_PHY_CONFIG;
            /* -SPR_11258 Changes */
        }
    }
}

/*****************************************************************************
 * Function Name  : lteMacTimeOutCellStopPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function will process Phy Cell Stop Request on timeout
 *                  and send the CELL stop Response to RRC. 
 *****************************************************************************/
/* +- SPR 17777 */
void lteMacTimeOutCellStopPhyHandler(void *msgBuf_p, 
        SInt32 byteRead,InternalCellIndex internalCellIndex)
{
    UInt8* reTry_p =  (UInt8 *)msgBuf_p;
    /* +SPR_11258 Changes */
    *reTry_p = 1;
    /* -SPR_11258 Changes */

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, transactionId_g[internalCellIndex], 
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]\
            ->cellState,internalCellIndex,byteRead, 0, 0, __func__, "PHY_STOP_REQ" );

    sendStopPhyCellStopRes(transactionId_g[internalCellIndex],MAC_SUCCESS,
            macCommonGetRRCCellIndex(internalCellIndex));

    /* +SPR_11258 Changes */
    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
        cellState =         CELL_WAIT_FOR_PHY_START;
    /* -SPR_11258 Changes */
    transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
}

/*****************************************************************************
 * Function Name  : lteMacTimeOutCellDelPhyHandler 
 * Inputs         : delayToPhy - Delay to phy
 *                  msgBuf - Pointer to buffer received
 *                  byteRead - Number of bytes read from socket
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function will process Phy Cell Delete Request on 
 *                  timeout and send the CELL DELETE Response to RRC. 
 *****************************************************************************/
/* +- SPR 17777 */
void lteMacTimeOutCellDelPhyHandler( void * msgBuf, 
        SInt32 byteRead ,InternalCellIndex internalCellIndex)
{
    UInt8* reTry_p =  (UInt8 *)msgBuf;
    /* +SPR_11258 Changes */
    *reTry_p = 1;
    /* -SPR_11258 Changes */

    LOG_MAC_MSG( MAC_PHY_TIMEOUT, LOGWARNING, MAC_L1_INF, 
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
            __LINE__, transactionId_g[internalCellIndex],
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]\
            ->cellState,internalCellIndex,byteRead, 0, 0, __func__, "PHY_STOP_REQ" );
    /*SPR 19508 +*/
    sendStopPhyCellDeleteRes( transactionId_g[internalCellIndex], MAC_SUCCESS,
            macCommonGetRRCCellIndex(internalCellIndex));
    /*SPR 19508 -*/

    /* +SPR_11258 Changes */
    cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]->\
        cellState = CELL_PHY_STOP;
    /* -SPR_11258 Changes */
    transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
}

/*CID 83627 Fix start*/ 
/******************************************************************************
 * Function Name  : sendMacCellStartReq
 * Inputs         : transactionId - random id generated which should be same for 
 *                    request sent by RRC layer and response sent by MAC layer.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function  processes the API MAC_CELL_START_REQ 
 *                    received from RRC.
 *****************************************************************************/
/* CA Changes start */
STATIC  MacRetType  sendMacCellStartReq(UInt16  transactionId,
        InternalCellIndex internalCellIndex)
{
    MacRetType retval     = MAC_FAILURE; 
    CellStartRes cellStartRes = {0};

    if(MAC_SUCCESS == sendStartReqToPhy(internalCellIndex))
    {
 #ifndef FLEXRAN   
        setFd( phyRxSockFD_g[internalCellIndex] );
 #endif
        retval = MAC_SUCCESS;
    }

    if(MAC_SUCCESS != retval)
    {
        cellStartRes.response = MAC_FAILURE;
        cellStartRes.transactionId = transactionId;
        /* Review comment fix start RJ29 */
        if( MAC_SEND_ERROR == sendMsgToRRC(MAC_CELL_START_CNF,
                    &cellStartRes, macCommonGetRRCCellIndex(internalCellIndex)))
            /* Review comment fix end RJ29 */
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }               
    }
    else 
    {
#ifndef FLEXRAN    
        lteFD_SET(phyRxSockFD_g[internalCellIndex], &staticReadFds);	
#endif
    }
    return retval;
}
/* CA Changes end */
/*SPR 16855 +-*/
/*****************************************************************************
 * Function Name : rrcStateMachineHandler
 * Inputs        : ueIndex - UE - Id 
 *                 event - Event Id
 *                 rrcOamPendReq_p - Data stored
 *                 dlData_p - Data to be sent/received from DL thread 
 *                 ulData_p - Data to be sent/received from UL thread  
 *                 response_p - Pointer to return code from HP thread 
 *                 internalCellIndex - cell index used at MAC
 * Returns       : None
 * Description   : This method will call the appropriate function in the state
 machine.
 *****************************************************************************/
void rrcStateMachineHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p, 
        InternalCellIndex internalCellIndex )
{
    LOG_MAC_MSG( MAC_CTRL_SAP_STATE_MACHINE_HANDLER, LOGDEBUG, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ueIndex, rrcOamMsghandler[internalCellIndex].currentState,
            event, internalCellIndex, 0, 0 ,0, __func__, "" );
    if( PNULL == rrcOamPendReq_p )
    {
        rrcOamPendReq_p = rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p;
    }
    lteLPrioThrApiHandlerFuncTable
        [rrcOamMsghandler[internalCellIndex].currentState][event]( 
                ueIndex, event, rrcOamPendReq_p, dlData_p, ulData_p, 
                response_p,internalCellIndex );
}

/*****************************************************************************
 * Function Name  : rrcMsgEnqueuePendingHandler
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method enqueues the message into the Pending queue
 till the time previous message is processed.
 *****************************************************************************/
void rrcMsgEnqueuePendingHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(response_p)
        LP_RrcOamLPPendingNode pendingNode_p = PNULL;
    /* Allocate memory for pending node */
    GET_MEM_NODE_RRC_OAM_LP_PENDING_NODE_Q( pendingNode_p, 
            RrcOamLPPendingNode );
    /*+COVERITY 5.2.2 - 32645*/
    if(PNULL == pendingNode_p)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"pendingNode_p Null UE %u\n",ueIndex);
        return;
    }
    /*+COVERITY 5.2.2 - 32645*/
    pendingNode_p->ueIndex = ueIndex;
    pendingNode_p->eventId = event;
    pendingNode_p->rrcOamPendReq_p = rrcOamPendReq_p;
    pendingNode_p->dlData_p = dlData_p;
    pendingNode_p->ulData_p = ulData_p;
    /*coverity id 63539*/
    if(!ENQUEUE_RRC_OAM_LP_PENDING_NODE_Q( &rrcOamPendingQ_g[internalCellIndex], pendingNode_p ))
    {

        FREE_MEM_NODE_RRC_OAM_LP_PENDING_NODE_Q(pendingNode_p); 
    }    
}

/*****************************************************************************
 * Function Name  : rrcMsgProcessPendingHandler
 * Inputs         : internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method checks and dequeues any message from the 
 Pending queue if not processed earlier.
 *****************************************************************************/
void rrcMsgProcessPendingHandler(InternalCellIndex internalCellIndex)
{
    UInt16 response = MAC_SUCCESS;
    LP_RrcOamLPPendingNode pendingNode_p = PNULL;

    if( COUNT_RRC_OAM_LP_PENDING_NODE_Q( &rrcOamPendingQ_g[internalCellIndex] ) )
    {
        DEQUEUE_RRC_OAM_LP_PENDING_NODE_Q( 
                &rrcOamPendingQ_g[internalCellIndex], pendingNode_p );

        rrcStateMachineHandler( pendingNode_p->ueIndex, pendingNode_p->eventId, 
                pendingNode_p->rrcOamPendReq_p, pendingNode_p->dlData_p, 
                pendingNode_p->ulData_p, &response, internalCellIndex );
        FREE_MEM_NODE_RRC_OAM_LP_PENDING_NODE_Q( pendingNode_p );
    }
}

/*****************************************************************************
 * Function Name  : lteMacInvalidEvent
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method is called in the state when invalid event has
 *                  occured.
 *****************************************************************************/
void lteMacInvalidEvent( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    LOG_MAC_MSG( MAC_CTRL_SAP_INVALID_EVENT_RECVD, LOGWARNING, MAC_RRC_INF,
            GET_CURRENT_TICK_FOR_CELL(internalCellIndex), ueIndex, event,
            internalCellIndex,sizeof(dlData_p),sizeof(ulData_p),sizeof(response_p),
            sizeof(rrcOamPendReq_p), __func__, "" );
    /* +- SPR 17777 */
}

/*****************************************************************************
 * Function Name  : rrcOamPendingReqHandler
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method is called in the state when message is received
 *                  from RRC and LP thread needs to wait for response from HP
 *                  thread. It also sends rthe request to HP thread.
 *****************************************************************************/
void rrcOamPendingReqHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(response_p)
        LTE_GCC_UNUSED_PARAM(ueIndex)
        /* +- SPR 17777 */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
    rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
    rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = rrcOamPendReq_p;
    rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
    /* Sets state to WAIT_FOR_MAC_THREAD to wait for MAC thread(s) to finish 
     * their respective tasks. */
    rrcOamMsghandler[internalCellIndex].currentState = WAIT_FOR_MAC_THREAD;

    /* Send the data to HP thread */
    sendToHPThread( event, dlData_p, ulData_p,internalCellIndex );

    /* Reset DL and UL data */
    rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
    rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;
}

/*****************************************************************************
 * Function Name  : rrcOamPendingResetHadler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method is called in the state when message is received
 *                  from RRC and LP thread needs to wait for response from HP
 *                  thread. It also sends rthe request to HP thread.
 *****************************************************************************/
void rrcOamPendingResetHadler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p 
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(response_p)
        LTE_GCC_UNUSED_PARAM(ueIndex)
        /* +- SPR 17777 */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
    rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
    rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = rrcOamPendReq_p;
    rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;

    /* Do not change the state as it has still not sent the response */
    /* Send the data to HP thread */
    sendToHPThread( event, dlData_p, ulData_p,internalCellIndex );

    /* Reset DL and UL data */
    rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
    rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;
}

/*****************************************************************************
 * Function Name  : setResponseBitmask 
 * Inputs         : threadId - thread Id from which this function is called.
 *                  data_p - Pointer to data received.
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method sets the bitmask for the response received from
 *                  MAC (DL/UL) threads.
 *****************************************************************************/
void setResponseBitmask( UInt8 threadId, void *data_p, InternalCellIndex internalCellIndex )
{
    switch ( threadId )
    {
        case DL_THD: 
        {
            rrcOamMsghandler[internalCellIndex].bitMaskRecvd |= MAC_RESPONSE_FRM_DL_THD;
            rrcOamMsghandler[internalCellIndex].dlData_p = (RrcOamHiPrioQNode *)data_p;
            break;
        }
        case UL_THD: 
        {
            rrcOamMsghandler[internalCellIndex].bitMaskRecvd |= MAC_RESPONSE_FRM_UL_THD;
            rrcOamMsghandler[internalCellIndex].ulData_p = data_p;
            break;
        }
    }
}

/*****************************************************************************
 * Function Name  : macCreateUeRequestHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will create passive context for API
 *                  MAC_CREATE_UE_ENTITY_REQ and sends the request to HP 
 *                  thread.
 *****************************************************************************/
void macCreateUeRequestHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p, 
        InternalCellIndex internalCellIndex )
{
    UInt32 currSFN = 0;
    UInt32 currSF = 0;
    UInt32 createULUEBitMap =0; 
    UInt32 createDLUEBitMap =0;
    MacRetType resp = MAC_SUCCESS;
    UEEntityCreateRes createUEEntityRes = {0}; 

    RrcOamHiPrioQNode *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode *ulRrcOamHiPrioQNode_p = PNULL;
    ULCreateUeReq *createUlUeEntityReq_p     = PNULL;
    DLCreateUeReq *createDlUeEntityReq_p     = PNULL;

    /* variable for uplink UE structure */
    UeContextForUplink*   ulCreateUEEntityReq_p = PNULL;
    ulCreateUEEntityReq_p = (UeContextForUplink *)getMemFromPool(sizeof(UeContextForUplink), NULL);

    if(PNULL == ulCreateUEEntityReq_p)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Memory allocation failure for "
                "ulCreateUeEntityReq_p for UE:%u\n", ueIndex);
        return;
    }

    /* variable for downlink UE structure */
    UeContextForDownlink* dlCreateUEEntityReq_p  = PNULL;
    dlCreateUEEntityReq_p = (UeContextForDownlink *)getMemFromPool(sizeof(UeContextForDownlink), NULL);

    if(PNULL == dlCreateUEEntityReq_p)
    {
        freeMemPool(ulCreateUEEntityReq_p);
        LOG_MAC_ERROR(MAC_RRC_INF,"Memory allocation failure for "
                "dlCreateUeEntityReq_p for UE:%u\n", ueIndex);
        return;
    }

    /* SPR 16717 fix start */
    do
    {
        memCpy(ulCreateUEEntityReq_p, &rrcOamPendReq_p->ulCreateUEEntityReq, sizeof(UeContextForUplink));
        memCpy(dlCreateUEEntityReq_p, &rrcOamPendReq_p->dlCreateUEEntityReq, sizeof(UeContextForDownlink));
        if( PNULL != ulUECtxInfoArr_g[ueIndex].ulUEContext_p )
        {
            /* +- SPR 17777 */
            /* UL UE context exists before hand, hence return failure */
            LOG_MAC_MSG(MAC_UECONTEXT_FAIL_ID, LOGWARNING, MAC_RRC_INF,
                    getCurrentTick(), ueIndex, __LINE__,sizeof(dlData_p),sizeof(ulData_p),0, 
                    0, 0, __func__, "UL UeCtx" );
            /* +- SPR 17777 */
            resp = MAC_FAILURE;
            break;
        }
        /* - coverity 24640 fix */

        /* Get current SFN and SF to be passed to SRS config to
         * have same copies in active and passive index */
        getSFAndSFN(&currSFN,&currSF,internalCellIndex);
        /* Create UE for passive context */
        resp = createMACUEEntity( dlCreateUEEntityReq_p,
                ulCreateUEEntityReq_p,
                ulCreateUEEntityReq_p->numLogicalChannels,
                /* +- SPR 17777 */
                internalCellIndex,
                &createULUEBitMap, &createDLUEBitMap,
                currSFN, currSF );

        /* + Coverity 52871 */
        if ( MAC_SUCCESS == resp || MAC_LOG_CH_ERROR == resp)
            /* - Coverity 52871 */
        {
            /* SPR 20673 start*/
        {
            addUEPeriodicReportBatchInfo(ueIndex,internalCellIndex);
        }
            /* SPR 20673 end  */

            /* Get DL/UL context and store the information */
            /*+COVERITY 5.3.0 - 32651*/
            dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
            if( PNULL == dlRrcOamHiPrioQNode_p)
            { 
                LOG_MAC_ERROR(MAC_RRC_INF,"dlRrcOamHiPrioQNode_p Null UE %u\n",ueIndex);
                resp = MAC_FAILURE;
            }
            else
            {
                ulRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
                if( PNULL == ulRrcOamHiPrioQNode_p)
                {
                    LOG_MAC_ERROR(MAC_RRC_INF,"ulRrcOamHiPrioQNode_p Null UE %u\n",ueIndex);
                    FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q(dlRrcOamHiPrioQNode_p);
                    resp = MAC_FAILURE;
                }
            }
            /*-COVERITY 5.3.0 - 32651*/
        }
    } while (0);
    /* SPR 16717 fix end */

    /* + Coverity 52871 */
    if(MAC_SUCCESS == resp || MAC_LOG_CH_ERROR == resp)
        /* - Coverity 52871 */
    {
        /*+COVERITY 5.3.0 - 32651*/
        memCpy(&rrcOamPendReq_p->dlCreateUEEntityReq, dlCreateUEEntityReq_p, sizeof(UeContextForDownlink));
        memCpy(&rrcOamPendReq_p->ulCreateUEEntityReq, ulCreateUEEntityReq_p, sizeof(UeContextForUplink));
        rrcOamPendReq_p->response = resp;
        rrcOamPendReq_p->SFN = currSFN;
        rrcOamPendReq_p->SF = currSF;
        /*-COVERITY 5.3.0 - 32651*/
        dlRrcOamHiPrioQNode_p->rrcMsgId = MAC_CREATE_UE_ENTITY_REQ;
        ulRrcOamHiPrioQNode_p->rrcMsgId = MAC_CREATE_UE_ENTITY_REQ;
        dlRrcOamHiPrioQNode_p->ueIndex = ueIndex;
        ulRrcOamHiPrioQNode_p->ueIndex = ueIndex;
        dlRrcOamHiPrioQNode_p->eventId = MAC_HP_CREATE_UE_ENTITY_EV;
        ulRrcOamHiPrioQNode_p->eventId = MAC_HP_CREATE_UE_ENTITY_EV;
        createDlUeEntityReq_p =
            &dlRrcOamHiPrioQNode_p->rrcOamReqResp.dlCreateUeReq;
        createUlUeEntityReq_p =
            &ulRrcOamHiPrioQNode_p->rrcOamReqResp.ulCreateUeReq;
        createUlUeEntityReq_p->ueIndex = dlCreateUEEntityReq_p->ueIndex;
        createDlUeEntityReq_p->ueIndex = dlCreateUEEntityReq_p->ueIndex;
        {

        fillUlMapsInfoToHPthread(createULUEBitMap, ulRrcOamHiPrioQNode_p, 
                MAC_CREATE_UE_ENTITY_REQ,internalCellIndex);
        fillDRXMeasInfo(createDLUEBitMap, 
                dlRrcOamHiPrioQNode_p, 
                dlCreateUEEntityReq_p,
                ulCreateUEEntityReq_p,
                internalCellIndex);
        }

        /* Send to HP thread, initailize state machine variables and change
         * state */
        rrcOamPendingReqHandler( ueIndex, event, rrcOamPendReq_p, 
                dlRrcOamHiPrioQNode_p, ulRrcOamHiPrioQNode_p, 
                response_p,internalCellIndex );
        LOG_MAC_MSG(MAC_UE_CREATE_SUCCESS_ID,LOGINFO,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_CREATE_UE_ENTITY_REQ, resp, 0,internalCellIndex,
                DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_CREATE_SUCCESS");

    }
    else
    {
        LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_CREATE_UE_ENTITY_REQ, resp, 0,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_CREATE_FAIL"); 

        createUEEntityRes.transactionId = rrcOamPendReq_p->transactionId;    
        createUEEntityRes.response = MAC_FAILURE;
        dlCreateUEEntityReq_p->ueIndex = rrcOamPendReq_p->rrcUeIndex;
        if(MAC_SEND_ERROR == sendToRRC( dlCreateUEEntityReq_p,
                    ulCreateUEEntityReq_p,
                    MAC_CREATE_UE_ENTITY_CNF, 
                    &createUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA changes End */
                    ,PNULL,PNULL
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }

        /* SPR 20872 Fix Start */
        freeUeIdx(ueIndex);
        /* SPR 20872 Fix End */

        freeMemPool( rrcOamPendReq_p );
    }

    /* + coverity 24640 -fix */
    freeMemPool(ulCreateUEEntityReq_p);
    freeMemPool(dlCreateUEEntityReq_p);
    /* - coverity 24640 -fix */
}

/*****************************************************************************
 * Function Name  : lteMacCreateUeReqLPHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_CREATE_UE_ENTITY_REQ 
 *                  and sends the same to RRC.
 *****************************************************************************/
void lteMacCreateUeReqLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(event)
        UInt16 hpRetCode = *((UInt16 *)(response_p));
    UEEntityCreateRes createUEEntityRes = {0};
    UInt32 retCode = 0;
    UInt16 resp = 0;
    DLCreateUeResp *createDlUeEntityResp_p = PNULL;
    /* CA Changes start */
	CellConfigParams *cellParams_p = PNULL;
    RRCReqAPI tempMsgId = MAC_CREATE_UE_ENTITY_CNF;
    {
        cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    }
    /* CA Changes end */

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
            LOG_MAC_ERROR(MAC_RRC_INF,"hpRetCode %u rrcOamMsghandler retCode %u UE %u cell %u\n",
                    hpRetCode,rrcOamMsghandler[internalCellIndex].retCode,ueIndex,internalCellIndex);
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        RrcOamHiPrioQNode *ulHPData_p = 
            (RrcOamHiPrioQNode *)(rrcOamMsghandler[internalCellIndex].ulData_p);
        ULCreateUeResp *createUlUeEntityResp_p = 
            &ulHPData_p->rrcOamReqResp.ulCreateUeResp;
        UeContextForUplink *uplkUEInfo_p = 
            &rrcOamPendReq_p->ulCreateUEEntityReq;
        UeContextForDownlink *dlCreateUEEntityReq_p =
            &rrcOamPendReq_p->dlCreateUEEntityReq;
        UInt16 transactionId = rrcOamPendReq_p->transactionId;

        if( MAC_SUCCESS != hpRetCode ||
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            createUEEntityRes.response = MAC_FAILURE;
            LOG_MAC_ERROR(MAC_RRC_INF,"hpRetCode %u rrcOamMsghandler retCode %u UE %u cell %u\n",
                    hpRetCode,rrcOamMsghandler[internalCellIndex].retCode,ueIndex,internalCellIndex);
        }
        else
        {
            resp = rrcOamPendReq_p->response;

            retCode = createUEULConfigCnf(createUlUeEntityResp_p,
                    dlCreateUEEntityReq_p,uplkUEInfo_p,
                    rrcOamPendReq_p->SFN, rrcOamPendReq_p->SF,internalCellIndex);

            if (MAC_FAILURE == retCode)
            {
                createUEEntityRes.response = MAC_FAILURE;
                LOG_MAC_ERROR(MAC_RRC_INF,"createUEULConfigCnf failed UE %u\n",
                        ueIndex);
            }
            else
            {
                dlData_p = rrcOamMsghandler[internalCellIndex].dlData_p;
                createDlUeEntityResp_p = 
                    &dlData_p->rrcOamReqResp.dlCreateUeResp;
                retCode = createUEDLConfigCnf( 
                        createDlUeEntityResp_p, dlCreateUEEntityReq_p
                        /* CA changes Start */
                        ,internalCellIndex
                        /* CA Changes end */
                        );

                if (MAC_SUCCESS == retCode)
                {
                    createUEEntityRes.response = MAC_SUCCESS;
                }
                else
                {
                    createUEEntityRes.response = MAC_FAILURE;
                    LOG_MAC_ERROR(MAC_RRC_INF,"createUEDLConfigCnf failed UE %u\n",
                            ueIndex);
                }
            }
        }
        if(MAC_SUCCESS == createUEEntityRes.response)
        {
            if (MAC_SUCCESS == resp)
            {
                createUEEntityRes.response = MAC_SUCCESS;
                /*! \code
                 *   If UE Has SPS Setup Info
                 *     Send the SPS Crnti In Resp
                 * \endcode
                 * */
                {
                if(TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
                        [internalCellIndex]->initParams_p->spsSysWideParam.enableSps)
                {
                    if (SPS_SETUP ==
                            dlUECtxInfoArr_g[ueIndex].dlUEContext_p->spsDlInfo.requestType)
                    {
                        createUEEntityRes.spsCrnti =
                            dlUECtxInfoArr_g[ueIndex].dlUEContext_p->spsDlInfo.SpsCrnti;
                    }
                    else if (SPS_SETUP ==
                            ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.requestType)
                    {
                        createUEEntityRes.spsCrnti =
                            ulUECtxInfoArr_g[ueIndex].ulUEContext_p->spsUlInfo.SpsCrnti;
                    }
                }
            }
            }
            else if (MAC_LOG_CH_ERROR == resp || MAC_RRC_LOG_CH_EXISTS == resp)
            {
                LOG_MAC_ERROR(MAC_RRC_INF,"createUEEntityRes.responseMAC_PARTIAL_SUCCESS UE %u\n",
                        ueIndex);
                createUEEntityRes.response = MAC_PARTIAL_SUCCESS;
            }
            ulUECtxInfoArr_g[ueIndex].pendingDeleteFlag = FALSE;
            dlUECtxInfoArr_g[ueIndex].pendingDeleteFlag = FALSE;

            cellParams_p->totalActiveUE++;
        }
        createUEEntityRes.transactionId = transactionId;
        /* Set the ue Index in response to the ueIndex received from RRC */
        dlCreateUEEntityReq_p->ueIndex = rrcOamPendReq_p->rrcUeIndex;
        if(MAC_SEND_ERROR == sendToRRC( dlCreateUEEntityReq_p,
                    uplkUEInfo_p,
                    tempMsgId,
                    &createUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA changes End */
                    /*SPR 4870 Changes Start*/
                    ,PNULL,PNULL
                    /*SPR 4870 Changes End*/
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
        rrcOamfreeRespBuffer(internalCellIndex);
        freeMemPool(rrcOamPendReq_p);

        /* Reset information in global state machine structure */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
        rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
        rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
        rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }
}

/*****************************************************************************
 * Function Name  : macReconfigUeRequestHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will create passive context for API
 *                  MAC_RECONFIG_UE_ENTITY_REQ and sends the request to HP 
 *                  thread.
 *****************************************************************************/
void macReconfigUeRequestHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    UInt8 spsCrntiFlag = FALSE;
    UInt32 currSFN = 0;
    UInt32 currSF = 0;
    UInt8 gapPatternId =0;
    /*+COVERITY 5.3.0 - 32264*/
    UInt32 resp = MAC_SUCCESS;
    /*-COVERITY 5.3.0 - 32264*/
    ULReconfigUeReq *ulReconfigUeReq_p = PNULL; 
    ULReconfigUeResp *ulReconfigUeResp_p = PNULL;
    DLReconfigUeReq *dlReconfigUeReq_p = PNULL; 
    DLReconfigUeResp *dlReconfigUeResp_p = PNULL; 
    UEEntityReconfigRes reconfigUEEntityRes = {0};
    LP_RrcOamHiPrioQNode ulLpData_p = (LP_RrcOamHiPrioQNode)ulData_p;
    /* Rel 5.3: Coverity 24640 Fix Start */
    UeContextForDownlink *dlCreateUEEntityReq_p = PNULL; 
    UeContextForUplink *ulCreateUEEntityReq_p = PNULL;
    /* 
     ** Allocate the memory for UeContextForUplink and UeContextForDownlink
     ** for this function and should be freed in this function itself.
     */
    GET_MEM_FROM_POOL(UeContextForUplink, ulCreateUEEntityReq_p, 
            sizeof(UeContextForUplink), PNULL);
    if (PNULL == ulCreateUEEntityReq_p)
    {
        return;
    }
    GET_MEM_FROM_POOL(UeContextForDownlink, dlCreateUEEntityReq_p, 
            sizeof(UeContextForDownlink), PNULL);
    if (PNULL == dlCreateUEEntityReq_p)
    {
        freeMemPool(ulCreateUEEntityReq_p);
        return;
    }
    *dlCreateUEEntityReq_p = rrcOamPendReq_p->dlCreateUEEntityReq;
    *ulCreateUEEntityReq_p = rrcOamPendReq_p->ulCreateUEEntityReq;

    /* Rel 5.3: Coverity 24640 Fix End */
    DLUEContext  *dlUeCtx_p = 
        dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    ULUEContext *ulUeCtx_p =
        ulUECtxInfoArr_g[ueIndex].ulUEContext_p;

    reconfigUEEntityRes.spsCrnti = 0;

    do
    {
        if( PNULL == ulData_p )
        {
            resp = MAC_FAILURE;
            break;
        }
        /* -Coverity 40421 */
        /* +Coverity 40420 */
        if( PNULL == dlData_p )
        {
            resp = MAC_FAILURE;
            break;
        }
        /* -Coverity 40420 */
        if( PNULL == dlUeCtx_p || PNULL == ulUeCtx_p )
        {
            resp = MAC_FAILURE;
            break;
        }
        dlReconfigUeReq_p = 
            &dlData_p->rrcOamReqResp.dlReconfigUeReq;
        dlReconfigUeResp_p = 
            &dlData_p->rrcOamReqResp.dlReconfigUeResp;
        ulReconfigUeReq_p = 
            &ulLpData_p->rrcOamReqResp.ulReconfigUeReq;
        ulReconfigUeResp_p = 
            &ulLpData_p->rrcOamReqResp.ulReconfigUeResp;
        /*! \code
         *  If UE Has SPS Setup Info
         *     Send the SPS Crnti In Resp
         *     If SPS CRNTI is already sent then do not send.
         * \endcode
         * */
        if(TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.enableSps)
        {
            /* Check if SPS is Already configured */
            if (SPS_SETUP == dlUeCtx_p->spsDlInfo.requestType) 
            {
                spsCrntiFlag = TRUE;
            }
            else if (SPS_SETUP == ulUeCtx_p->spsUlInfo.requestType) 
            {
                spsCrntiFlag = TRUE;
            }
        }
        /* Get current SFN and SF to be passed to SRS config to
         * have same copies in active and passive index */
        getSFAndSFN(&currSFN,&currSF,internalCellIndex);
        gapPatternId = dlUeCtx_p->measGapContext.measGapConfig.gapPatternId;

        /*SPR 8105 Fix Start*/
        rrcOamPendReq_p->reconfigInfo.cqiOffset = 0;
        rrcOamPendReq_p->reconfigInfo.cqiPeriodicity = 0;
        rrcOamPendReq_p->reconfigInfo.riOffset = 0;
        rrcOamPendReq_p->reconfigInfo.riPeriodicity = 0;
        rrcOamPendReq_p->reconfigInfo.srOffset = 0;
        rrcOamPendReq_p->reconfigInfo.srPeriodicity = 0;
        rrcOamPendReq_p->reconfigInfo.srsOffset = 0;
        rrcOamPendReq_p->reconfigInfo.srsPeriodicity = 0;
        rrcOamPendReq_p->reconfigInfo.cqiRiReconfigBitMap = 0;
        rrcOamPendReq_p->reconfigInfo.srReconfigBitMap = 0;
        rrcOamPendReq_p->reconfigInfo.srsReconfigBitMap = 0;
        rrcOamPendReq_p->measGapBitMask = 0;
        /*SPR 8105 Fix End*/

        /*Reconfig Changes Start */
        resp = reconfigureMACUEEntity( dlCreateUEEntityReq_p,
                ulCreateUEEntityReq_p,
                ulCreateUEEntityReq_p->numLogicalChannels,
                internalCellIndex,                
                ulReconfigUeReq_p, dlReconfigUeReq_p,
                currSFN, currSF,gapPatternId,
                &rrcOamPendReq_p->measGapBitMask,&rrcOamPendReq_p->reconfigInfo);
        /*Reconfig Changes End */
    } while(0);

    if (MAC_SUCCESS == resp)
    {
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_SUCCESS_ID,LOGINFO,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_RECONFIGURE_UE_ENTITY_REQ, DEFAULT_INT_VALUE, 0,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_SUCCESS");
        rrcOamPendReq_p->dlCreateUEEntityReq = *dlCreateUEEntityReq_p;
        rrcOamPendReq_p->ulCreateUEEntityReq = *ulCreateUEEntityReq_p;
        /* SPR 16082 fix start */
        rrcOamPendReq_p->dlMeasGapConfigType = dlUeCtx_p->measGapConfigType;
        rrcOamPendReq_p->ulMeasGapConfigType = ulUeCtx_p->measGapConfigType;

        rrcOamPendReq_p->dlMeasGapContext = dlUeCtx_p->measGapContext;
        rrcOamPendReq_p->ulMeasGapContext = ulUeCtx_p->measGapContext;
        /* SPR 16082 fix end */
        rrcOamPendReq_p->response = resp;
        rrcOamPendReq_p->SFN = currSFN;
        rrcOamPendReq_p->SF = currSF;
        rrcOamPendReq_p->spsCrntiFlag = spsCrntiFlag;
        rrcOamPendReq_p->gapPatternId = gapPatternId;
        /* Send to HP thread, initailize state machine variables and change
         * state */
        rrcOamPendingReqHandler( ueIndex, event, rrcOamPendReq_p, 
                dlData_p, ulData_p, response_p,internalCellIndex );
        /* Rel 5.3: Coverity 24640 Fix Start */
        freeMemPool(ulCreateUEEntityReq_p);
        freeMemPool(dlCreateUEEntityReq_p);
        /* Rel 5.3: Coverity 24640 Fix End */

        return;
    }
    else if( MAC_LOG_CH_ERROR == resp || 
            MAC_RRC_LOG_CH_EXISTS == resp || 
            MAC_RRC_LOG_CH_NOT_EXISTS == resp )
    {
        /*SPR 16855 +-*/
    }
    else
    {
        LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_RECONFIGURE_UE_ENTITY_REQ, resp, 0,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL"); 
        reconfigUEEntityRes.response= MAC_FAILURE;
    }
    /* SPS_CHG */
    if((TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.enableSps) && (MAC_SUCCESS != resp))
    {
        reconfigUEEntityRes.spsCrnti = 0;    
    }
    /* SPS_CHG */
    /*SPR 2262 changes stop*/
    if( resp != MAC_SUCCESS )
    {
        ueReconfigComplete = 0x55;
        reconfigUEEntityRes.transactionId = rrcOamPendReq_p->transactionId;
        /* function that sends the confirmation message to RRC
         * */
        if(MAC_SEND_ERROR == sendToRRC(dlCreateUEEntityReq_p,
                    ulCreateUEEntityReq_p,
                    MAC_RECONFIGURE_UE_ENTITY_CNF, 
                    &reconfigUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA changes End */
                    /* Coverity 60419 */
                    ,ulReconfigUeResp_p
                    ,dlReconfigUeResp_p
                    /* Coverity 60419 */
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
    }
    /* Free the memory for state machine handler */
    freeMemPool( rrcOamPendReq_p );
    /* +Coverity 40420, 40421 */
    if( PNULL != dlData_p )
    {
        FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( dlData_p );
    }
    if( PNULL != ulData_p )
    {
        FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q( ulData_p );
    }
    /* -Coverity 40420, 40421 */
    /* Rel 5.3: Coverity 24640 Fix Start */
    freeMemPool(ulCreateUEEntityReq_p);
    freeMemPool(dlCreateUEEntityReq_p);
    /* Rel 5.3: Coverity 24640 Fix End */
}

/*****************************************************************************
 * Function Name  : lteMacReconfigUeReqLPHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_RECONFIG_UE_ENTITY_REQ
 *                  and sends the same to RRC.
 *****************************************************************************/
void lteMacReconfigUeReqLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(event)
        UEEntityReconfigRes reconfigUEEntityRes = {0};
    UInt16 transactionId = 0; 
    UInt16 resp = 0;
    UInt16 hpRetCode = *((UInt16 *)(response_p));
    DLReconfigUeResp *dlReconfigUeResp_p = PNULL;
    DLUEContext  *dlUeCtx_p = 
        dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    ULUEContext *ulUeCtx_p =
        ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    InitParams *initParams_p =  cellSpecificParams_g.\
                                cellConfigAndInitParams_p[internalCellIndex]->initParams_p;
    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        UeContextForUplink *uplkUEInfo_p = 
            &rrcOamPendReq_p->ulCreateUEEntityReq;
        UeContextForDownlink *dlCreateUEEntityReq_p = 
            &rrcOamPendReq_p->dlCreateUEEntityReq;
        RrcOamHiPrioQNode *ulHPData_p = 
            (RrcOamHiPrioQNode *)(rrcOamMsghandler[internalCellIndex].ulData_p);
        ULReconfigUeResp *ulReconfigUeResp_p = 
            &ulHPData_p->rrcOamReqResp.ulReconfigUeResp;
        do
        {
            if( PNULL == dlUeCtx_p || PNULL == ulUeCtx_p )
            {
                resp = MAC_FAILURE;
                break;
            }

            transactionId = rrcOamPendReq_p->transactionId;
            resp = rrcOamPendReq_p->response;

            /* Get the context for DL */
            dlData_p = rrcOamMsghandler[internalCellIndex].dlData_p;
            dlReconfigUeResp_p =
                &dlData_p->rrcOamReqResp.dlReconfigUeResp;

            if( hpRetCode != MAC_SUCCESS || 
                    MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode ||
                    MAC_SUCCESS != resp )
            {
                resp = MAC_FAILURE;
                break;
            }
            /*Reconfig Changes Start */
            resp = reconfigUEULConfigCnf(ulReconfigUeResp_p, 
                    dlCreateUEEntityReq_p,
                    uplkUEInfo_p,
                    rrcOamPendReq_p->SFN, rrcOamPendReq_p->SF,
                    &rrcOamPendReq_p->reconfigInfo,
                    internalCellIndex);
            /*Reconfig Changes End */
            if (MAC_FAILURE == resp )
            {
                break;
            }

            /*Reconfig Changes Start */
            resp = reconfigUEDLConfigCnf(dlReconfigUeResp_p,
                    dlCreateUEEntityReq_p,
                    /* SPR 16082 fix start */
                    rrcOamPendReq_p->dlMeasGapConfigType,
                    rrcOamPendReq_p->ulMeasGapConfigType,
                    &rrcOamPendReq_p->dlMeasGapContext,
                    &rrcOamPendReq_p->ulMeasGapContext,
                    /* SPR 16082 fix end */
                    rrcOamPendReq_p->gapPatternId,
                    &rrcOamPendReq_p->measGapBitMask,
                    internalCellIndex
                    );
            /*Reconfig Changes End */
            if ( MAC_FAILURE == resp )
            {
                break;
            }

            /*! \code
             *   If UE Has SPS Setup Info
             *     Send the SPS Crnti In Resp
             *     If SPS CRNTI is already sent then do not send.
             * \endcode
             * */
            /* SPR FIX 6776 Start */
            if( TRUE == initParams_p->spsSysWideParam.enableSps )
            {
                if( FALSE == rrcOamPendReq_p->spsCrntiFlag )
                {
                    if ( SPS_SETUP == 
                            dlCreateUEEntityReq_p->spsDownlinkInfo.requestType)
                    {
                        reconfigUEEntityRes.spsCrnti = 
                            dlUeCtx_p->spsDlInfo.SpsCrnti;
                    }
                    else if(SPS_SETUP == 
                            uplkUEInfo_p->spsUplinkInfo.requestType)
                    {
                        reconfigUEEntityRes.spsCrnti = 
                            ulUeCtx_p->spsUlInfo.SpsCrnti;
                    }
                }
            }
            /* SPR FIX 6776 End */
        }while(0);
        if( MAC_FAILURE == resp )
        {
            reconfigUEEntityRes.response = MAC_FAILURE;
            if( TRUE == initParams_p->spsSysWideParam.enableSps )
            {
                reconfigUEEntityRes.spsCrnti = 0;
            }
        }
        else
        {
            reconfigUEEntityRes.response = MAC_SUCCESS;
        }

        ueReconfigComplete = 0x55;
        reconfigUEEntityRes.transactionId = transactionId;
        /* function that sends the confirmation message to RRC
         * */
        if(MAC_SEND_ERROR == sendToRRC(dlCreateUEEntityReq_p,
                    uplkUEInfo_p,
                    MAC_RECONFIGURE_UE_ENTITY_CNF, 
                    &reconfigUEEntityRes,
                    /* CA changes Start */
                    macCommonGetRRCCellIndex(internalCellIndex),
                    /* CA changes End */
                    /*SPR 4870 Changes Start*/ 
                    ulReconfigUeResp_p,
                    dlReconfigUeResp_p
                    /*SPR 4870 Changes End*/ 
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
        rrcOamfreeRespBuffer(internalCellIndex);

        freeMemPool( rrcOamPendReq_p );
        /* Reset information in global state machine structure */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
        rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
        rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
        rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }
}

/*****************************************************************************
 * Function Name  : lteMacHoRachResourceReqLPHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_HO_RACH_RESOURCE_REQ
 *                  and sends the same to RRC.
 *****************************************************************************/
void lteMacHoRachResourceReqLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    HORachResourceRespInfo hoRachResourceResp = {0};
    ConFreeRACHResourcesInfo rachResourceInfo = {0};
    UInt16 hpRetCode = *((UInt16 *)(response_p));
    UInt16 resp = 0;

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    { 
        RrcOamHiPrioQNode *ulHPData_p = 
            (RrcOamHiPrioQNode *)(rrcOamMsghandler[internalCellIndex].ulData_p);

        UInt16 tcrnti = ulHPData_p->rrcOamReqResp.hoRachInfo.tcRNTI;
        rachResourceInfo.preambleIndex = 
            ulHPData_p->rrcOamReqResp.hoRachInfo.preambleIndex;
        rachResourceInfo.prachMaskIndex = 
            ulHPData_p->rrcOamReqResp.hoRachInfo.prachMaskIndex;

        if(INVALID_PREAMBLE_IDX == rachResourceInfo.preambleIndex)
        {
            resp = createMACDLUEConnHandOverEntity(
                    INVALID_PREAMBLE_IDX,
                    ueIndex, &tcrnti
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
        }
        else
        {
            resp = createMACDLUEConnHandOverEntity(
                    rachResourceInfo.preambleIndex,
                    ueIndex, &tcrnti
                    /* CA changes Start */
                    , internalCellIndex
                    /* CA Changes end */
                    );
        }
        if (MAC_SUCCESS == resp)
        {
            hoRachResourceResp.tcrnti = tcrnti;
            hoRachResourceResp.preambleIdx =
                rachResourceInfo.preambleIndex;
            hoRachResourceResp.prachMaskIdx =
                rachResourceInfo.prachMaskIndex;
            LOG_MAC_MSG(RRC_HO_RACH_RESOURCE_REQ_MSG_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),MAC_HO_RACH_RESOURCE_REQ,
                    ueIndex,resp,
                    hoRachResourceResp.tcrnti,
                    hoRachResourceResp.preambleIdx,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"CONN_HANDOVER_ENTITY_SUCCESS");
        }
        else
        {
            LOG_MAC_MSG(RRC_HO_RACH_RESOURCE_REQ_MSG_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),MAC_HO_RACH_RESOURCE_REQ,
                    ueIndex,resp,
                    hoRachResourceResp.tcrnti,
                    hoRachResourceResp.preambleIdx,
                    event,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"CONN_HANDOVER_ENTITY_FAILURE");
            ConnHOEntityFailureInterfaceNode *connHOEntityFailureInterfaceNode_p = PNULL;
            GET_MEM_FROM_POOL(ConnHOEntityFailureInterfaceNode,
                    connHOEntityFailureInterfaceNode_p,
                    sizeof(ConnHOEntityFailureInterfaceNode), PNULL);
            /* + Coverity 32102 */
            if( PNULL == connHOEntityFailureInterfaceNode_p )
            {
                resp = MAC_FAILURE;
            }
            /* - Coverity 32102 */
            else
            {
                connHOEntityFailureInterfaceNode_p->preambleIndex = 
                    rachResourceInfo.preambleIndex; 
                /* SPR 14117 fix start */
                connHOEntityFailureInterfaceNode_p->tcRnti = tcrnti;
                /* SPR 14117 fix end */
                /*SPR 21103 Start*/
                if(MAC_FAILURE == putEntryInPdcchRachInterfaceQueue(
                            HO_RACH_CONN_HO_ENTITY_FAILURE, 
                            connHOEntityFailureInterfaceNode_p,
                            internalCellIndex))
                {
                    freeMemPool(connHOEntityFailureInterfaceNode_p);
                }
                /*SPR 21103 End*/
            }
        }
        /* SPR 3607 Fix Start*/
        hoRachResourceResp.resp = resp;
        hoRachResourceResp.ueIndex = rrcOamPendReq_p->rrcUeIndex;
        hoRachResourceResp.transactionId = rrcOamPendReq_p->transactionId;
        /* Send Msg to RRC */
        if(MAC_SEND_ERROR  ==
                sendMsgToRRC(MAC_HO_RACH_RESOURCE_RESP,
                    &hoRachResourceResp
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ))
        {
            ALARM_MSG(MAC_MODULE_ID,
                    SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
        }

        rrcOamfreeRespBuffer(internalCellIndex);
        freeMemPool( rrcOamPendReq_p );

        /* Reset information in global state machine structure */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
        rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
        rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
        rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }
}

/* SPR 8379 changes start */
/*****************************************************************************
 * Function Name  : lteMacIntraHoResReqLPHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_HO_RACH_RESOURCE_REQ
 *                  and sends the same to RRC.
 *****************************************************************************/
void lteMacIntraHoResReqLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    HORachResourceRespInfo hoRachResourceResp = {0};
    UInt16 hpRetCode = *((UInt16 *)(response_p));
    UInt16 resp = 0;

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    { 
        RrcOamHiPrioQNode *ulHPData_p = 
            (RrcOamHiPrioQNode *)(rrcOamMsghandler[internalCellIndex].ulData_p);

        hoRachResourceResp.tcrnti =
            dlUECtxInfoArr_g[ueIndex].dlUEContext_p->crnti;
        hoRachResourceResp.preambleIdx =
            ulHPData_p->rrcOamReqResp.hoRachInfo.preambleIndex;
        hoRachResourceResp.prachMaskIdx =
            ulHPData_p->rrcOamReqResp.hoRachInfo.prachMaskIndex;
        resp = ulHPData_p->rrcOamReqResp.hoRachInfo.resp;

        if ( MAC_SUCCESS == resp )
        {
            /* Update preambleIdx, ulSyncLossState and intraEnbHOFlag in DL 
             * context */
            dlUECtxInfoArr_g[ueIndex].
                dlUEContext_p->ulSyncLossOrHOInfoInDL.preambleIdx = hoRachResourceResp.preambleIdx;
            dlUECtxInfoArr_g[ueIndex].
                dlUEContext_p->ulSyncLossOrHOInfoInDL.ulSyncLossState =
                UL_SYNC_LOSS_OFF;
            dlUECtxInfoArr_g[ueIndex].dlUEContext_p->intraEnbHOFlag = 
                TRUE;

            LOG_MAC_MSG(RRC_HO_RACH_RESOURCE_REQ_MSG_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),MAC_HO_RACH_RESOURCE_REQ,
                    ueIndex,resp,
                    hoRachResourceResp.tcrnti,
                    hoRachResourceResp.preambleIdx,
                    event,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"CONN_HANDOVER_ENTITY_SUCCESS");
        }
        else
        {
            LOG_MAC_MSG(RRC_HO_RACH_RESOURCE_REQ_MSG_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),MAC_HO_RACH_RESOURCE_REQ,
                    ueIndex,resp,
                    hoRachResourceResp.tcrnti,
                    hoRachResourceResp.preambleIdx,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PREAMBLE_ID_0_ALLOCATED");
            resp = MAC_SUCCESS;
        }
        /* SPR 3607 Fix Start*/
        hoRachResourceResp.resp = resp;
        hoRachResourceResp.ueIndex = rrcOamPendReq_p->rrcUeIndex;
        hoRachResourceResp.transactionId = rrcOamPendReq_p->transactionId;
        /* Send Msg to RRC */
        if(MAC_SEND_ERROR  ==
                sendMsgToRRC(MAC_HO_RACH_RESOURCE_RESP,
                    &hoRachResourceResp
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ))
        {
            ALARM_MSG(MAC_MODULE_ID,
                    SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
        }

        rrcOamfreeRespBuffer(internalCellIndex);
        freeMemPool( rrcOamPendReq_p );

        /* Reset information in global state machine structure */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
        rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
        rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
        rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }
}
/* SPR 8379 changes end */

/*****************************************************************************
 * Function Name  : lteMacResetUeBeforeHarqResetLPHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_RESET_UE_ENTITY_REQ
 *                  and sends again request to high priority thread to mark 
 *                  pending delete flag as false.
 *****************************************************************************/
void lteMacResetUeBeforeHarqResetLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    UInt16 transactionId = rrcOamPendReq_p->transactionId;
    DLResetUeReq       *dlResetUeReq_p       = PNULL;
    ULResetUeReq       *ulResetUeReq_p       = PNULL;
    RrcOamHiPrioQNode  *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode  *ulRrcOamHiPrioQNode_p = PNULL;
    LTE_GCC_UNUSED_PARAM(event)
        /* CA_phase2_harq_code Start */  
        /* CA_phase2_harq_code End */  

        UInt16 hpRetCode = *((UInt16 *)(response_p));

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        rrcOamfreeRespBuffer(internalCellIndex);
        if( hpRetCode == MAC_SUCCESS || 
                MAC_SUCCESS == rrcOamMsghandler[internalCellIndex].retCode )
        {
            do
            {
                DLUEContext * ueDLContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
                if (PNULL != ueDLContext_p)
                {
                    /*Reset DL HARQ Entity for a UE*/
                    /* SPR 2446 Fix Begins*/
                    resetMACDLHarqEntity(&ueDLContext_p->dlHarqContext_p);
                    /* SPR 2446 Fix Ends*/
                    /*Reset DL Context for a UE*/
                    /*CA Changes start  */
                    resetMACDLUEEntity(ueDLContext_p, internalCellIndex);
                    /*CA Changes end  */

                    /* Reset the nodes for PUCCH (SR,CQI,RI)*/
                    ULUEContext *ueULContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
                    if (PNULL == ueULContext_p)
                    {
                        hpRetCode = MAC_FAILURE;
                    }
                    else
                    {
                        /*CA Changes start  */
                        resetMACULUEEntity(ueULContext_p, internalCellIndex);
                        /*CA Changes end  */
                        /* SPR 9385 changes start*/
                        /* In case of CHANGE_CRNTI_REQ, the function changeCrntiReqHandler()
                         * will be called to process the request, which will invoke the 
                         * state machine for MAC_RRC_CHANGE_CRNTI_EV. Hence, changing the state
                         * into MAC_CTRL_IDLE_ST*/
                        if(MAC_CHANGE_CRNTI_CNF == rrcOamPendReq_p->respMsgId)
                        {
                            ChangeCrntiInfo changeCrntiInfo = {0};
                            changeCrntiInfo.ueIndex = rrcOamPendReq_p->changeCrntiInfo.ueIndex;
                            changeCrntiInfo.oldCrnti = rrcOamPendReq_p->changeCrntiInfo.oldCrnti;
                            changeCrntiInfo.newCrnti = rrcOamPendReq_p->changeCrntiInfo.newCrnti;
                            /** SPR 12320 Changes Start **/
                            UeCellInfo  ueCellInfo = {0};
                            ueCellInfo.sCellIndex = START_SCELL_INDEX;
                            /** SPR 12320 Changes End **/


                            /* CA_Phase3_Re-estab_changes start */

                            /* Cyclomatic_complexity_changes_start */
                            resetSecondCellInResetUeReq(ueDLContext_p,
                                    ueULContext_p,
                                    rrcOamPendReq_p,
                                    changeCrntiInfo.ueIndex,
                                    &ueCellInfo,
                                    internalCellIndex);
                            /* Cyclomatic_complexity_changes_end */

                            freeMemPool( rrcOamPendReq_p );
                            /* CA_Phase3_Re-estab_changes end */
                            /* Reset information in global state machine structure */
                            rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
                            rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
                            rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
                            rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
                            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
                            rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
                            changeCrntiReqHandler(transactionId,changeCrntiInfo,
                                    internalCellIndex); 
                        }
                        else
                        {    
                            /* SPR 9385 changes end*/
                            dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
                            /* + coverity 32138 */
                            if( PNULL == dlRrcOamHiPrioQNode_p )
                            {
                                hpRetCode = MAC_FAILURE;
                                break;
                            }
                            /* - coverity 32138 */
                            ulRrcOamHiPrioQNode_p = 
                                (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
                            /* + coverity 32138 */
                            if( PNULL == ulRrcOamHiPrioQNode_p )
                            {
                                freeMemPool( dlRrcOamHiPrioQNode_p );
                                hpRetCode = MAC_FAILURE;
                                break;
                            }
                            /* - coverity 32138 */
                            dlRrcOamHiPrioQNode_p->rrcMsgId = 
                                MAC_RESET_UE_ENTITY_REQ;
                            ulRrcOamHiPrioQNode_p->rrcMsgId = 
                                MAC_RESET_UE_ENTITY_REQ;

                            ulRrcOamHiPrioQNode_p->ueIndex = ueIndex;
                            dlRrcOamHiPrioQNode_p->ueIndex = ueIndex;

                            dlRrcOamHiPrioQNode_p->eventId = 
                                MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV;
                            ulRrcOamHiPrioQNode_p->eventId = 
                                MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV;

                            dlResetUeReq_p  = 
                                &dlRrcOamHiPrioQNode_p->rrcOamReqResp.\
                                dlResetUeReq;
                            ulResetUeReq_p  = &ulRrcOamHiPrioQNode_p->\
                                              rrcOamReqResp.ulResetUeReq;
                            dlResetUeReq_p->ueIndex = ueIndex;
                            ulResetUeReq_p->ueIndex = ueIndex;
                            /** SPR 12320 Changes Start **/
                            UeCellInfo  ueCellInfo = {0};
                            ueCellInfo.sCellIndex = START_SCELL_INDEX;
                            /** SPR 12320 Changes End **/

                            /* CA_phase2_harq_code Start */  
                            /* Cyclomatic_complexity_changes_start */
                            resetSecondCellInResetUeReq(ueDLContext_p,
                                    ueULContext_p,
                                    rrcOamPendReq_p,
                                    ueIndex,
                                    &ueCellInfo,
                                    internalCellIndex);
                            /* Cyclomatic_complexity_changes_end */
                            /* CA_phase2_harq_code End */  


                            dlResetUeReq_p->pendingDeleteFlag = FALSE;
                            ulResetUeReq_p->pendingDeleteFlag = FALSE;

                            hpRetCode = MAC_SUCCESS;
                            /* Call the state machine to wait for response 
                             * from MAC (DL/UL) Thread */
                            rrcStateMachineHandler( ueIndex, 
                                    MAC_HP_SEND_RESET_REQ_AGAIN,
                                    rrcOamPendReq_p, dlRrcOamHiPrioQNode_p, 
                                    ulRrcOamHiPrioQNode_p, &hpRetCode, 
                                    internalCellIndex);
                        }
                    }
                }
                else
                {
                    hpRetCode = MAC_FAILURE;
                }
            }while(0);
        }

        if( MAC_SUCCESS != hpRetCode ||
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )

        {
            /* SPR 9385 changes start*/
            /* In Failure scenario, Check that Reset UE is triggered by 
             * MAC_CHANGE_CRNTI_REQ or MAC_RESET_UE_ENTITY_REQ 
             * and send Response to RRC accordingly */
            if(MAC_CHANGE_CRNTI_CNF == rrcOamPendReq_p->respMsgId)
            {
                ChangeCrntiRespInfo changeCrntiResp = {0};
                /*SPR 12103 fix, updating RRC ueIndex in the resp structure*/
                /*Removed MULTI_SECTOR flag*/
                changeCrntiResp.ueIndex = getRrcUeIdxFromUeIdx(ueIndex);
                changeCrntiResp.resp = (UInt16)hpRetCode;
                changeCrntiResp.transactionId = transactionId;

                /* function that sends the confirmation message to  RRC
                */
                /* SPR 11056 FIX START */
                if(MAC_SEND_ERROR  ==
                        sendMsgToRRC(MAC_CHANGE_CRNTI_CNF, &changeCrntiResp, 
                            macCommonGetRRCCellIndex(internalCellIndex)))
                    /* SPR 11056 FIX END */
                {
                    ALARM_MSG(MAC_MODULE_ID,
                            SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
                }
            }
            else
            {    
                /* SPR 9385 changes end*/

                UEEntityResetRes resetUEEntityRes = {0};
                resetUEEntityRes.idx = rrcOamPendReq_p->rrcUeIndex;
                resetUEEntityRes.response = (UInt16)hpRetCode;
                resetUEEntityRes.transactionId = transactionId;
                /* function that sends the confirmation message to  RRC
                */
                if(MAC_SEND_ERROR  ==
                        sendMsgToRRC(MAC_RESET_UE_ENTITY_CNF,&resetUEEntityRes
                            /* CA changes Start */
                            ,macCommonGetRRCCellIndex(internalCellIndex)
                            /* CA Changes end */
                            ))
                {
                    ALARM_MSG(MAC_MODULE_ID,
                            SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
                }
            }
            freeMemPool( rrcOamPendReq_p );
            /* Reset information in global state machine structure */
            rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
            rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
            rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
            rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
            rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
            rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

            /* Check and process any pending message */
            rrcMsgProcessPendingHandler(internalCellIndex);
        }
    }
}

/*****************************************************************************
 * Function Name  : lteMacResetUeAfterHarqResetLPHandler 
 * Inputs         : ueIndex - UE - Id 
 *                  event - Event Id
 *                  rrcOamPendReq_p - Data stored
 *                  dlData_p - Data to be sent/received from DL thread 
 *                  ulData_p - Data to be sent/received from UL thread  
 *                  response_p - Pointer to return code from HP thread 
 *                  internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_RESET_UE_ENTITY_REQ
 *                  to send response to RRC.
 *****************************************************************************/
void lteMacResetUeAfterHarqResetLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    UInt16 resp       = MAC_SUCCESS;
    UInt16 hpRetCode = *((UInt16 *)(response_p));
    UEEntityResetRes resetUEEntityRes = {0};
    /* SPR 9385 changes start*/
    ChangeCrntiRespInfo changeCrntiResp = {0};
    /* SPR 9385 changes end*/

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        if( hpRetCode != MAC_SUCCESS ||
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            resp = MAC_FAILURE;
        }
        rrcOamfreeRespBuffer(internalCellIndex);
        /* SPR 9385 changes start*/
        /* if Reset UE Entity is triggered by MAC_CHANGE_CRNTI_REQ then store
         *  the required informations for changing crnti in local variables
         *  before resetting the node rrcOamPendReq_p.
         */

        if((rrcOamPendReq_p->respMsgId == MAC_CHANGE_CRNTI_CNF)) 
        {
            /*SPR 12103 fix, updating RRC ueIndex in the resp structure*/
            changeCrntiResp.ueIndex = getRrcUeIdxFromUeIdx(rrcOamPendReq_p->rrcUeIndex);
            changeCrntiResp.resp = resp;
            changeCrntiResp.transactionId = rrcOamPendReq_p->transactionId;
            /* function that sends the confirmation message to  RRC
            */
            /* SPR 11056 FIX START */
            if(MAC_SEND_ERROR  ==
                    sendMsgToRRC(MAC_CHANGE_CRNTI_CNF, &changeCrntiResp, 
                        macCommonGetRRCCellIndex(internalCellIndex)))
                /* SPR 11056 FIX END */
            {
                ALARM_MSG(MAC_MODULE_ID,
                        SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
            }
        }
        else
        {
            /* SPR 9385 changes end*/
            resetUEEntityRes.idx = rrcOamPendReq_p->rrcUeIndex;
            resetUEEntityRes.response = resp;
            resetUEEntityRes.transactionId = rrcOamPendReq_p->transactionId;
            /* Review comment fix start MAC_RESET_12 */
            LOG_MAC_MSG(MAC_RESET_UE_ENTITY_FAILURE_CNF,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),resetUEEntityRes.idx,
                    resetUEEntityRes.transactionId, resetUEEntityRes.response, 
                    internalCellIndex,event, 
                    ueIndex, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, "MAC_RESET_UE_ENTITY_FAILURE_CNF");
            /* Review comment fix end MAC_RESET_12 */
            /* function that sends the confirmation message to  RRC
            */
            if(MAC_SEND_ERROR  ==
                    sendMsgToRRC(MAC_RESET_UE_ENTITY_CNF,&resetUEEntityRes
                        /* CA changes Start */
                        ,macCommonGetRRCCellIndex(internalCellIndex)
                        /* CA Changes end */
                        ))
            {
                ALARM_MSG(MAC_MODULE_ID,
                        SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
            }
            /* SPR 11800 fix start */
        }
        /* SPR 11800 fix end */
        freeMemPool(rrcOamPendReq_p);

        /* Reset information in global state machine structure */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
        rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
        rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
        rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }
}

/* SPR 9385 changes start*/
/*****************************************************************************
 * Function Name  : changeCrntiReqHandler 
 * Inputs         : transactionId 
 *                  changeCrntiInfo
 *                  internalCellIndex
 * Returns        : None
 * Description    :This function handles the MAC_CHANGE_CRNTI_REQ received from RRC,
 *                  after reset is done. 
 *****************************************************************************/
void changeCrntiReqHandler(UInt16 transactionId,ChangeCrntiInfo changeCrntiInfo,
        InternalCellIndex internalCellIndex)
{
    UInt16 resp       = MAC_SUCCESS;
    ChangeCrntiRespInfo changeCrntiResp = {0};
    RachInterfaceQueueNode *rachMgrRrcOamHiPrioQNode_p = PNULL;
    RRCRachChangeCRNTIInterface *rrcRachChangeCRNTINode_p = PNULL;
    RNTIInfo *oldRntiInfo_p = PNULL;
    RNTIInfo *newRntiInfo_p = PNULL;

    do
    {       
        resp = macChangeCrntiReq(changeCrntiInfo,internalCellIndex);
        if(MAC_SUCCESS != resp )            
        {
            resp = MAC_FAILURE;
            break;
        }
        /*SPR 16855 +-*/
        oldRntiInfo_p = getUeIdxFromRNTIMap(changeCrntiInfo.oldCrnti,
                internalCellIndex);
        newRntiInfo_p = getUeIdxFromRNTIMap(changeCrntiInfo.newCrnti,
                internalCellIndex);
        if( ( PNULL == oldRntiInfo_p ) && (PNULL == newRntiInfo_p ) )
        {
            resp = MAC_FAILURE;
            break;
        }
        GET_MEM_FROM_POOL(RRCRachChangeCRNTIInterface,
                rrcRachChangeCRNTINode_p,
                sizeof(RRCRachChangeCRNTIInterface),
                PNULL);
        if( PNULL == rrcRachChangeCRNTINode_p )
        {
            resp = MAC_FAILURE;
            break;
        }
        rrcRachChangeCRNTINode_p->ueIndex = changeCrntiInfo.ueIndex;
        rrcRachChangeCRNTINode_p->oldCrnti = changeCrntiInfo.oldCrnti;
        rrcRachChangeCRNTINode_p->newCrnti = changeCrntiInfo.newCrnti;
        rachMgrRrcOamHiPrioQNode_p = (RachInterfaceQueueNode *)
            getInitializedRefPointer( RACH_MGRQ );
        if( PNULL == rachMgrRrcOamHiPrioQNode_p )
        {
            /* Free the memory */
            freeMemPool( rrcRachChangeCRNTINode_p );
            resp = MAC_FAILURE;
            break;
        }
        rachMgrRrcOamHiPrioQNode_p->ueIndex = rrcRachChangeCRNTINode_p->ueIndex;
        rachMgrRrcOamHiPrioQNode_p->msgType = CHANGE_CRNTI;
        rachMgrRrcOamHiPrioQNode_p->rachInterface_p = rrcRachChangeCRNTINode_p;
        rachMgrRrcOamHiPrioQNode_p->eventId = MAC_HP_CHANGE_CRNTI_EV;

        LP_RrcOamPendingReq rrcOamPendingReq_p = 
            getMemFromPool(sizeof(RrcOamPendingReq),PNULL);
        if(PNULL == rrcOamPendingReq_p)
        {
            LOG_MAC_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, 
                    L2_SYS_FAIL, GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(RrcOamPendingReq), internalCellIndex,0,0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG( MAC_MODULE_ID, 
                    MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
            /* Free the memory */
            freeMemPool( rachMgrRrcOamHiPrioQNode_p );
            freeMemPool( rrcRachChangeCRNTINode_p );
            resp = MAC_FAILURE;
            break;
        }
        /*10826_fix_start*/
        else
        {
            memSet(rrcOamPendingReq_p,0,sizeof(RrcOamPendingReq));
        }
        /*10826_fix_end*/

        rrcOamPendingReq_p->transactionId = transactionId;

        /*10826_fix_start*/
        rrcOamPendingReq_p->respMsgId = MAC_CHANGE_CRNTI_CNF;
        /*10826_fix_end*/
        /*SPR 12103 fix start*/
        rrcOamPendingReq_p->rrcUeIndex = changeCrntiInfo.ueIndex;
        /*SPR 12103 fix end*/

        /* Call the state machine to wait for response from MAC (UL) 
         * Thread */
        resp = MAC_SUCCESS;

        rrcStateMachineHandler( 
                rachMgrRrcOamHiPrioQNode_p->ueIndex,
                MAC_RRC_CHANGE_CRNTI_EV, rrcOamPendingReq_p,
                PNULL, rachMgrRrcOamHiPrioQNode_p, &resp,internalCellIndex);
        /*SPR 16855 +-*/
    } while( 0 );

    LOG_MAC_MSG(RRC_CHANGE_CRNTI_MSG_ID,LOGWARNING,
            MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),MAC_CHANGE_CRNTI_REQ,
            changeCrntiInfo.ueIndex,resp,
            changeCrntiInfo.oldCrnti, 
            changeCrntiInfo.newCrnti,
            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME,"RRC_MAC_CHANGE_CRNTI_REQ");

    /* Send Msg to RRC in case of FAILURE */
    if ( MAC_SUCCESS != resp )
    {
        /*SPR 12103 fix, updating RRC ueIndex in the resp structure*/
        changeCrntiResp.ueIndex = getRrcUeIdxFromUeIdx( changeCrntiInfo.ueIndex);
        changeCrntiResp.resp = resp;
        changeCrntiResp.transactionId = transactionId;

        if(MAC_SEND_ERROR  ==
                sendMsgToRRC(MAC_CHANGE_CRNTI_CNF, &changeCrntiResp, 
                    macCommonGetRRCCellIndex(internalCellIndex)))
        {
            ALARM_MSG(MAC_MODULE_ID,
                    SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
        }
    }   
}
/* SPR 9385 changes end*/
/*****************************************************************************
 * Function Name  : lteMacChangeCRNTIReqLPHandler 
 * Inputs         : ueIndex - UE - Id 
 event - Event Id
 rrcOamPendReq_p - Data stored
 dlData_p - Data to be sent/received from DL thread 
 ulData_p - Data to be sent/received from UL thread  
 response_p - Pointer to return code from HP thread 
 internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_CHANGE_CRNTI_REQ
 and sends the same to RRC.
 *****************************************************************************/
void lteMacChangeCRNTIReqLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    /* SPR 9385 chnages start */
    RrcOamHiPrioQNode  *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode  *ulRrcOamHiPrioQNode_p = PNULL;
    DLResetUeReq       *dlResetUeReq_p       = PNULL;
    ULResetUeReq       *ulResetUeReq_p       = PNULL;
    /* SPR 9385 chnages end */
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(event)
        ChangeCrntiRespInfo changeCrntiResp = {0};
    UInt16 hpRetCode = *((UInt16 *)(response_p));

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        if ( MAC_SUCCESS != hpRetCode ||
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            hpRetCode = MAC_FAILURE;
        }
        /* SPR 9385 changes start*/
        /* In case of SUCCESS, pendingDeleteFlag needs to be  set as FALSE,
         *  and state machine is invoked for MAC_HP_SEND_RESET_REQ_AGAIN,
         *  with eventId MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV*/
	/* SPR 22340 Fix Start */
	 rrcOamfreeRespBuffer(internalCellIndex);
	/* SPR 22340 Fix End */
        if(hpRetCode == MAC_SUCCESS)
        {
            dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
            if( PNULL == dlRrcOamHiPrioQNode_p )
            {
                hpRetCode = MAC_FAILURE;
            }
            else
            {
                ulRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
                if( PNULL == ulRrcOamHiPrioQNode_p )
                {
                    freeMemPool( dlRrcOamHiPrioQNode_p );
                    hpRetCode = MAC_FAILURE;
                }
                else
                {
                    dlRrcOamHiPrioQNode_p->rrcMsgId = MAC_RESET_UE_ENTITY_REQ;
                    ulRrcOamHiPrioQNode_p->rrcMsgId = MAC_RESET_UE_ENTITY_REQ;
                    ulRrcOamHiPrioQNode_p->ueIndex = ueIndex;
                    dlRrcOamHiPrioQNode_p->ueIndex = ueIndex;

                    dlRrcOamHiPrioQNode_p->eventId = 
                        MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV;
                    ulRrcOamHiPrioQNode_p->eventId = 
                        MAC_HP_RESET_UE_AFTER_HARQ_RESET_ENTITY_EV;

                    dlResetUeReq_p  = &dlRrcOamHiPrioQNode_p->rrcOamReqResp.dlResetUeReq;
                    ulResetUeReq_p  = &ulRrcOamHiPrioQNode_p->rrcOamReqResp.ulResetUeReq;
                    dlResetUeReq_p->ueIndex = ueIndex;
                    ulResetUeReq_p->ueIndex = ueIndex;

                    dlResetUeReq_p->pendingDeleteFlag = FALSE;
                    ulResetUeReq_p->pendingDeleteFlag = FALSE;

                    /* Call the state machine to wait for response
                     * from MAC (DL/UL) Thread */
                    rrcStateMachineHandler( ueIndex,
                            MAC_HP_SEND_RESET_REQ_AGAIN,
                            rrcOamPendReq_p, dlRrcOamHiPrioQNode_p,
                            ulRrcOamHiPrioQNode_p, &hpRetCode,internalCellIndex);
                }
            }
        } 

        /* Send Msg to RRC in case of FAILURE*/
        /* SPR 9385 changes end*/
        if ( MAC_SUCCESS != hpRetCode ||
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            changeCrntiResp.transactionId = rrcOamPendReq_p->transactionId;
            changeCrntiResp.resp = (UInt16)hpRetCode;
            /*SPR 12103 fix, updating RRC ueIndex in the resp structure*/
            changeCrntiResp.ueIndex = getRrcUeIdxFromUeIdx(ueIndex);

            if(MAC_SEND_ERROR  ==
                    sendMsgToRRC(MAC_CHANGE_CRNTI_CNF, &changeCrntiResp, 
                        macCommonGetRRCCellIndex(internalCellIndex)))
            {
                ALARM_MSG(MAC_MODULE_ID,
                        SEND_MSG_FAILED_ALARM_ID,MAJOR_ALARM);
            }
            /* SPR 9385 changes start*/
            /* SPR 20445 Fix Start */
	    /* SPR 22340 Fix + - */
            freeMemPool( rrcOamPendReq_p );

            /* Reset information in global state machine structure */
            rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
            rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
            rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
            rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
            rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
            rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

            /* Check and process any pending message */
            rrcMsgProcessPendingHandler(internalCellIndex);
            /* SPR 20445 Fix End */
        }   
        /* SPR 9385 changes end*/
    }
}

/*****************************************************************************
 * Function Name  : macDeleteUeRequestHandler 
 * Inputs         : ueIndex - UE - Id 
 event - Event Id
 rrcOamPendReq_p - Data stored
 dlData_p - Data to be sent/received from DL thread 
 ulData_p - Data to be sent/received from UL thread  
 response_p - Pointer to return code from HP thread 
 internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will create passive context for API
 MAC_DELETE_UE_REQ and sends the request to HP 
 thread.
 *****************************************************************************/
void macDeleteUeRequestHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p
        /*CA changes start*/
        , InternalCellIndex internalCellIndex)
/*CA changes end */
{
    UEEntityDeleteRes deleteUEEntityRes = {0};
    MacRetType          resp                  = MAC_SUCCESS;
    UInt32              deleteULUEBitMap      = 0;
    UInt32              deleteDLUEBitMap      = 0;
    /** SPR 12320 Fix : Start **/
    UInt32              servCellIndex         = 0;
    UeCellInfo          ueCellInfo            = {0};
    DLUESCellContext    *dlUeScellContext_p   = PNULL;
    /** SPR 12320 Fix : End **/
    DLDeleteUeReq      *dlDeleteUeReq_p       = PNULL;
    ULDeleteUeReq      *ulDeleteUeReq_p       = PNULL;
    RrcOamHiPrioQNode  *dlRrcOamHiPrioQNode_p = PNULL;
    RrcOamHiPrioQNode  *ulRrcOamHiPrioQNode_p = PNULL;
    DLUEContext *dlUEContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    /* SPR 13725 fix start */
    ULUEContext *uLUEContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    /* SPR 13725 fix end */
    /* Compilation fix */
    RRCRachDeleteUeHoInterface *rrcRachDeleteUeHOInterfaceNode = PNULL;
    UInt16 rrcMsgCnf = MAC_DELETE_UE_ENTITY_CNF;
    /* +- SPR 17777 */
    /* Coverity 113373 Fix Start */
    UInt8 isNodeToBeEnq = LTE_FALSE;
    /* Coverity 113373 Fix End */
    LTE_GCC_UNUSED_PARAM(dlData_p)
        LTE_GCC_UNUSED_PARAM(ulData_p)
        if ( !dlUEContext_p )
        {
            lteWarning("DL - UE Index does not exist\n");
            resp = MAC_FAILURE;
        }
    /* +- SPR 16583 */
        else
        {
            do 
            {
            {
                /* ICIC changes start*/
                if(dlUEContext_p->userLocationType == CE_USER)
                {
                    --(rrmMacCellGlobal_gp[internalCellIndex]->totalCellEdgeUserCount);
                }

                deleteUEPeriodicReportBatchInfo(ueIndex, internalCellIndex);
            }    

                /* ICIC changes end*/
                if(dlUEContext_p->tcrntiFlag)
                {
                    GET_MEM_FROM_POOL(RRCRachDeleteUeHoInterface,
                            rrcRachDeleteUeHOInterfaceNode,
                            sizeof(RRCRachDeleteUeHoInterface), PNULL);
                    if(rrcRachDeleteUeHOInterfaceNode == PNULL)
                    {
                        resp = MAC_FAILURE;
                        break;
                    }
                    else
                    {
                        isNodeToBeEnq = LTE_TRUE;
                        rrcRachDeleteUeHOInterfaceNode->preambleIndex = 
                            dlUEContext_p->ulSyncLossOrHOInfoInDL.preambleIdx;
                    }
                }
                /* SPR 7844 changes start */
                /* Commented else and made common piece of code */
                /* SPR 7844 changes end */
                /*+COVERITY 5.3.0 - 32652*/
                dlRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(DL_THD);
                if( PNULL == dlRrcOamHiPrioQNode_p )
                { 
                    resp = MAC_FAILURE;
                    /* Coverity 110682 Fix Start */
                    if(rrcRachDeleteUeHOInterfaceNode != PNULL)
                    {
                        freeMemPool(rrcRachDeleteUeHOInterfaceNode);
                        rrcRachDeleteUeHOInterfaceNode = PNULL;
                    }
                    /* Coverity 110682 Fix End */
                    break;
                }
                ulRrcOamHiPrioQNode_p = (RrcOamHiPrioQNode *)getInitializedRefPointer(UL_THD);
                if( PNULL == ulRrcOamHiPrioQNode_p)
                {
                    FREE_MEM_NODE_RRC_OAM_LPTOHP_THDH_PRIO_Q(dlRrcOamHiPrioQNode_p);
                    /* Coverity 110682 Fix Start */
                    if(rrcRachDeleteUeHOInterfaceNode != PNULL)
                    {
                        freeMemPool(rrcRachDeleteUeHOInterfaceNode);
                        rrcRachDeleteUeHOInterfaceNode = PNULL;
                    }
                    /* Coverity 110682 Fix End */
                    resp = MAC_FAILURE;
                    break;
                }
                /* Coverity 113373 Fix Start */
                if( LTE_TRUE == isNodeToBeEnq )
                {
                    if(MAC_FAILURE == putEntryInPdcchRachInterfaceQueue(
                                RACH_DELETE_UE_HO,
                                rrcRachDeleteUeHOInterfaceNode,
                                internalCellIndex))
                    {
                        freeMemPool(rrcRachDeleteUeHOInterfaceNode);
                        rrcRachDeleteUeHOInterfaceNode = PNULL;
                    }
                }
                /* Coverity 110682 Fix Start */
                else
                {
                    if(rrcRachDeleteUeHOInterfaceNode != PNULL)
                    {
                        freeMemPool(rrcRachDeleteUeHOInterfaceNode);
                        rrcRachDeleteUeHOInterfaceNode = PNULL;
                    }
                }
                /* Coverity 110682 Fix End */
                /* Coverity 113373 Fix End */

            }while( 0 );

            if ( MAC_FAILURE != resp )
            {
                /*-COVERITY 5.3.0 - 32652*/
                dlRrcOamHiPrioQNode_p->rrcMsgId = MAC_DELETE_UE_ENTITY_REQ;
                ulRrcOamHiPrioQNode_p->rrcMsgId = MAC_DELETE_UE_ENTITY_REQ;
                dlRrcOamHiPrioQNode_p->ueIndex = ueIndex;
                ulRrcOamHiPrioQNode_p->ueIndex = ueIndex;
                dlRrcOamHiPrioQNode_p->eventId = MAC_HP_DELETE_UE_ENTITY_EV;
                ulRrcOamHiPrioQNode_p->eventId = MAC_HP_DELETE_UE_ENTITY_EV;

                dlDeleteUeReq_p  = &dlRrcOamHiPrioQNode_p->rrcOamReqResp.dlDeleteUeReq;
                ulDeleteUeReq_p  = &ulRrcOamHiPrioQNode_p->rrcOamReqResp.ulDeleteUeReq;
                dlDeleteUeReq_p->ueIndex = ueIndex;
                ulDeleteUeReq_p->ueIndex = ueIndex;

                /* 
                 * delete node from all maps here and update the bitmap which map is updated
                 * code will come here 
                 */
            {
                /* +- SPR 22275 */
                /* SPR 16583 fix start */
                /* There might be the case when UL UE Context is NULL when DL 
                 * context exists, in case of target during HO. During HO, there
                 * will be a DL UE Context, but there will not be any meas gap 
                 * context. At this particular time, UL UE context will also not 
                 * exist, hence, there will be no SR/CQI/RI nodes. In all other 
                 * cases, there should not be any case when DL and UL contexts are 
                 * not in sync, i.e, either of DL or UL UE Context is NULL.
                 * Though above mentioned scenario should not occur as at target 
                 * when MAC_CREATE_UE_REQ is not received, L3 should send 
                 * HO_REL_RACH_RESOURCE_IND, but in case L3 does send DELETE, MAC 
                 * should not crash or return failure for DELETE Request. */
                if( PNULL != uLUEContext_p )
                {
                    deleteUEMeasgapContext  (ueIndex, &deleteDLUEBitMap,internalCellIndex);
                    /** SPR 12320 Fix : Start **/
                    ueCellInfo.isPCell = TRUE;
                    deleteUEPucchSRSContext (ueIndex, &deleteULUEBitMap,&ueCellInfo,internalCellIndex);
                }
                /* SPR 16583 fix end */

                if (PNULL != dlUEContext_p)
                {
                    for(servCellIndex = START_SCELL_INDEX; servCellIndex <= dlUEContext_p->\
                            scellCount ;servCellIndex++)
                    {
                        dlUeScellContext_p = dlUEContext_p->\
                                             dlUeScellContext_p[servCellIndex];

                        if(PNULL != dlUeScellContext_p)
                        {
                            /* Mem-Leak Changes Start */
                            scellStateMngrFreeAllUeScellTimerNode(ueIndex, servCellIndex);
                            /* Mem-Leak Changes Start */
                            ueCellInfo.isPCell = FALSE;
                            ueCellInfo.sCellIndex = servCellIndex;
                            ueCellInfo.sCellInternalCellIndex = dlUeScellContext_p->internalCellIndex;

                            if (MAC_FAILURE == 
                                    deleteUEPucchSRSContext(ueIndex,&deleteULUEBitMap
                                        ,&ueCellInfo,internalCellIndex))
                            {
                                lteWarning ("\n deleteUEPucchSRSContext() failed for"
                                        "servCellIndex :%d \n",servCellIndex);
                            }
                        }
                    }
                }
                /** SPR 12320 Fix : End **/

                /*
                 * populate all element in request structure 
                 */
                fillUlMapsInfoToHPthread( deleteULUEBitMap, ulRrcOamHiPrioQNode_p, 
                        MAC_DELETE_UE_ENTITY_REQ,internalCellIndex); 
                /* + coverity 32221 */
                dlDeleteUeReq_p->deleteUEMsg = (RRCConfigureDlUEMsg) deleteDLUEBitMap;
                /* - coverity 32221 */
                if(RRC_CONFIGURE_MEAS_GAP_40MS_MAP == deleteDLUEBitMap)
                {
                    dlDeleteUeReq_p->activeIndexFor40MsMeasGapMap =
                        /*CA Changes start  */
                        measGap40msInfo_gp[internalCellIndex]->passiveIndex;
                    /*CA Changes end  */
                }
                else if(RRC_CONFIGURE_MEAS_GAP_80MS_MAP == deleteDLUEBitMap)
                {
                    dlDeleteUeReq_p->activeIndexFor80MsMeasGapMap =
                        /*CA Changes start  */
                        measGap80msInfo_gp[internalCellIndex]->passiveIndex;
                    /*CA Changes end  */
                }
#ifdef ENDC_ENABLED
				/*Meas_Gap_Changes_Start*/
                else if(RRC_CONFIGURE_MEAS_GAP_20MS_MAP == deleteDLUEBitMap)
                {
                    dlDeleteUeReq_p->activeIndexFor20MsMeasGapMap =
                        /*CA Changes start  */
                        measGap20msInfo_gp[internalCellIndex]->passiveIndex;
                    /*CA Changes end  */
                }
                else if(RRC_CONFIGURE_MEAS_GAP_160MS_MAP == deleteDLUEBitMap)
                {
                    dlDeleteUeReq_p->activeIndexFor160MsMeasGapMap =
                        /*CA Changes start  */
                        measGap160msInfo_gp[internalCellIndex]->passiveIndex;
                    /*CA Changes end  */
                }
                /*Meas_Gap_Changes_End*/
#endif
            }

                rrcOamPendReq_p->deleteDLUEBitMap = deleteDLUEBitMap;
                rrcOamPendReq_p->deleteULUEBitMap = deleteULUEBitMap;

                /* Send to HP thread, initailize state machine variables and change
                 * state */
                rrcOamPendingReqHandler( ueIndex, event, rrcOamPendReq_p, 
                        dlRrcOamHiPrioQNode_p, ulRrcOamHiPrioQNode_p, 
                        response_p,internalCellIndex );
                /*+COVERITY 32674*/
                resp = MAC_SUCCESS;
                /*-COVERITY 32674*/
            }
        }
    /*+COVERITY - 32674*/
    if( MAC_SUCCESS != resp )
        /*-COVERITY - 32674*/
    {        
        deleteUEEntityRes.idx = rrcOamPendReq_p->rrcUeIndex;
        deleteUEEntityRes.response = resp;    
        deleteUEEntityRes.transactionId = rrcOamPendReq_p->transactionId;
        /* function that sends the confirmation message to RRC
        */
        if(MAC_SEND_ERROR == sendMsgToRRC( rrcMsgCnf, 
                    &deleteUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }
        freeMemPool( rrcOamPendReq_p );
    }
}

/*****************************************************************************
 * Function Name  : lteMacDeleteUeReqLPHandler 
 * Inputs         : ueIndex - UE - Id 
 event - Event Id
 rrcOamPendReq_p - Data stored
 dlData_p - Data to be sent/received from DL thread 
 ulData_p - Data to be sent/received from UL thread  
 response_p - Pointer to return code from HP thread 
 internalCellIndex - cell index used at MAC
 * Returns        : None
 * Description    : This method will make response of MAC_DELETE_UE_REQ
 and sends the same to RRC.
 * */
/*****************************************************************************/
void lteMacDeleteUeReqLPHandler( UInt16 ueIndex, 
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p, 
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        /*CA changes start*/
        InternalCellIndex internalCellIndex)
/*CA changes end */
{
    UEEntityDeleteRes deleteUEEntityRes = {0};
    UInt32 deleteULUEBitMap = rrcOamPendReq_p->deleteULUEBitMap;
    UInt32 deleteDLUEBitMap = rrcOamPendReq_p->deleteDLUEBitMap;
    UInt16 resp = 0;
    UInt16 hpRetCode = *((UInt16 *)(response_p));
    /*REL10_CR_CHANGES_START*/
    UInt8 loopIdx = 0;
    /*REL10_CR_CHANGES_END*/
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(event)
        /** SPR 12320 Fix : Start **/
        UInt32              servCellIndex         = 0;
    UeCellInfo          ueCellInfo            = {0};
    /* SPR 16583 fix start */
    ULUEContext *uLUeCtx_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    /* SPR 16583 fix end */
    DLUEContext *dlUEContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
    DLUESCellContext *dlUeScellContext_p = PNULL;
    /** SPR 12320 Fix : End **/

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[internalCellIndex].bitMaskRecvd != rrcOamMsghandler[internalCellIndex].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        if( MAC_SUCCESS != hpRetCode ||
                MAC_SUCCESS != rrcOamMsghandler[internalCellIndex].retCode )
        {
            resp = MAC_FAILURE;
        }
        else
        {
            /*REL10_CR_CHANGES_START*/
            /*Populate the deleteUEEntityRes structure to send lc status*/
            dlData_p = rrcOamMsghandler[internalCellIndex].dlData_p;
            ulData_p = rrcOamMsghandler[internalCellIndex].ulData_p;
            for ( loopIdx = 0; loopIdx < MAX_NUMBER_OF_LOGICAL_CHANNEL; loopIdx++)
            {
                if( PNULL != dlData_p && PNULL != ulData_p)
                {
                    if( dlData_p->rrcOamReqResp.dlDeleteUeResp.deleteLCStatus[loopIdx] <= 
                            ((RrcOamHiPrioQNode *)ulData_p)->rrcOamReqResp.ulDeleteUeResp.deleteLCStatus[loopIdx])
                    {
                        deleteUEEntityRes.deleteLCStatus[loopIdx] = 
                            dlData_p->rrcOamReqResp.dlDeleteUeResp.deleteLCStatus[loopIdx];
                    }
                    else
                    {  
                        deleteUEEntityRes.deleteLCStatus[loopIdx] = 
                            ((RrcOamHiPrioQNode *)ulData_p)->rrcOamReqResp.ulDeleteUeResp.deleteLCStatus[loopIdx];
                    }
                }
                else if (PNULL != dlData_p)
                { 
                    deleteUEEntityRes.deleteLCStatus[loopIdx] = 
                        dlData_p->rrcOamReqResp.dlDeleteUeResp.deleteLCStatus[loopIdx];
                }
                else
                {
                    deleteUEEntityRes.deleteLCStatus[loopIdx] = 
                        ((RrcOamHiPrioQNode *)ulData_p)->rrcOamReqResp.ulDeleteUeResp.deleteLCStatus[loopIdx];
                }

            }
            /*REL10_CR_CHANGES_END*/

            /* SPR 22275 Fix + */
            /*code removed*/
            /* SPR 22275 Fix - */
            /*BUG:9307:END*/
            /* SPR 16583 fix start */
            /* Refer to comment before sending the message to HP thread. The 
             * same logic applies here as well. */
	{
            if( PNULL != uLUeCtx_p )
            {
                deleteUEMeasgapContext(ueIndex, &deleteDLUEBitMap,internalCellIndex);
                /** SPR 12320 Fix : Start **/
                ueCellInfo.isPCell = TRUE;
                deleteUEPucchSRSContext (ueIndex, &deleteULUEBitMap,&ueCellInfo,internalCellIndex);
            }
	}
            /* SPR 16583 fix end */

            if (PNULL != dlUEContext_p)
            {
                for(servCellIndex = START_SCELL_INDEX; servCellIndex <= dlUEContext_p->\
                        scellCount ;servCellIndex++)
                {
                    dlUeScellContext_p = dlUEContext_p->\
                                         dlUeScellContext_p[servCellIndex];

                    if(PNULL != dlUeScellContext_p)
                    {
                        ueCellInfo.isPCell = FALSE;
                        ueCellInfo.sCellIndex = servCellIndex;
                        ueCellInfo.sCellInternalCellIndex = dlUeScellContext_p->internalCellIndex;

                        if (MAC_FAILURE == 
                                deleteUEPucchSRSContext(ueIndex,&deleteULUEBitMap
                                    ,&ueCellInfo,internalCellIndex))
                        {
                            lteWarning ("\n deleteUEPucchSRSContext() failed for"
                                    "servCellIndex :%d \n",servCellIndex);
                        }
                    }
                }
            }
            /** SPR 12320 Fix : End **/
            deleteUEContextLPThd(ueIndex, internalCellIndex);
            resp = MAC_SUCCESS;
        }
        rrcOamfreeRespBuffer(internalCellIndex);

        /* Fill and send response to RRC */
        deleteUEEntityRes.idx = getRrcUeIdxFromUeIdx(ueIndex);
        deleteUEEntityRes.response = resp;    
        deleteUEEntityRes.transactionId = rrcOamPendReq_p->transactionId;
        /* function that sends the confirmation message to RRC */
	RRCReqAPI msgCnf = MAC_DELETE_UE_ENTITY_CNF;
        if(MAC_SEND_ERROR == sendMsgToRRC(msgCnf, &deleteUEEntityRes
                    /* CA changes Start */
                    ,macCommonGetRRCCellIndex(internalCellIndex)
                    /* CA Changes end */
                    ))
        {
            ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
        }

        freeMemPool( rrcOamPendReq_p );

        /* Reset information in global state machine structure */
        rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
        rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;
        rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
        rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
        rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
        rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }

}

/****************************************************************************
 * Function Name  : rrcMsgFreePendingQueue
 * Inputs         : internalCellIndex 
 * Outputs        : None
 * Returns        : None
 * Description    : This function frees for any entry that is present in RRC
 *                  mesaage pending queue.
 *****************************************************************************/
void rrcMsgFreePendingQueue(InternalCellIndex internalCellIndex)
{
    LP_RrcOamLPPendingNode pendingNode_p = PNULL;
    UInt32 qCount = COUNT_RRC_OAM_LP_PENDING_NODE_Q( 
            &(rrcOamPendingQ_g[internalCellIndex]) );

    while( qCount-- )
    {
        DEQUEUE_RRC_OAM_LP_PENDING_NODE_Q( 
                &rrcOamPendingQ_g[internalCellIndex], pendingNode_p );
        FREE_MEM_NODE_RRC_OAM_LP_PENDING_NODE_Q( pendingNode_p );
    }
}

/*****************************************************************************
 * Function Name  : rrcMsgResetStateMachine 
 * Inputs         : internalCellIndex 
 * Returns        : None
 * Description    : This method resets the state machine.
 *****************************************************************************/
void rrcMsgResetStateMachine(InternalCellIndex internalCellIndex ) 
{
    /* Reset current state of RRC interface */
    rrcOamMsghandler[internalCellIndex].currentState = MAC_CTRL_IDLE_ST;
    rrcOamMsghandler[internalCellIndex].bitMaskRecvd = MAC_NO_RESPONSE_RCVD;
    rrcOamMsghandler[internalCellIndex].bitMaskSent = MAC_NO_RESPONSE_RCVD;
    rrcOamMsghandler[internalCellIndex].retCode = MAC_SUCCESS;
    rrcOamMsghandler[internalCellIndex].rrcOamPendReq_p = PNULL;

    /* Reset DL and UL data */
    rrcOamMsghandler[internalCellIndex].dlData_p = PNULL;
    rrcOamMsghandler[internalCellIndex].ulData_p = PNULL;
}
/*SPR 16855 +-*/

/* + PRS_CHANGES */
/****************************************************************************
 * Function Name  :  parsePRSConfigInfo
 * Inputs         : totalTagLen - length of the API message received
 *                  prsParseConfigInfo_p - pointer to cell config structure
 *                  message_p - message pointer 
 *                  dlResBlocks -
 *                  reconfigFlag -
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to configure PRS in the system
 *****************************************************************************/
 MacRetType  parsePRSConfigInfo(UInt8 *message_p, 
        PRSParseConfigInfo *prsParseConfigInfo_p,
        UInt16  totalTagLen,
        UInt8 dlResBlocks,
        UInt8 reconfigFlag
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    UInt8 *msg_p = message_p;
    UInt16 tag = 0;
    UInt16 tagLen = 0;
    UInt16 count  = 0;
    UInt8 prsBandwidth = 0;
    UInt8 prsSubframes = 0;
    UInt8 prsChangeBits = 0;
    /* + Coverity 40852 */
    MacRetType response = MAC_SUCCESS; 
    /* - Coverity 40852 */

    totalTagLen = totalTagLen - PRS_CONFIG_INFO_MIN_LEN;

    if(0 == reconfigFlag)
    {

        if (PRS_CONFIG_SETUP_MIN_VALUE >  totalTagLen ||
                PRS_CONFIG_SETUP_MAX_VALUE < totalTagLen)
        {
            response = MAC_FAILURE;
        }
    }
    else
    {
        if (PRS_CONFIG_RECONFIG_MIN_VALUE >  totalTagLen ||
                PRS_CONFIG_RECONFIG_MAX_VALUE < totalTagLen)
        {
            response = MAC_FAILURE;
        }

    }

    while(count < totalTagLen)
    {
        if (MAC_FAILURE == response)
        {
            break;
        }
        tag =  LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        count += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        count += U16BIT_LEN;

        switch(tag)
        {
            case PRS_BANDWIDTH_INFO :
            {
                if (PRS_BANDWIDTH_INFO_TAG_LEN != tagLen)
                {         
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            tagLen,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_BANDWIDTH_INFO_TAG_LEN");
                }

                prsBandwidth = *msg_p++;
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_PRS_BANDWIDTH_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        prsBandwidth,
                        internalCellIndex, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_PRS_BANDWIDTH_INFO_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/

                /* Check if PRS bandwidth is in range and not 
                 * greater than system bandwidth */
                /* Cyclomatic_complexity_changes_start */
                response = getPRSBandwidth(prsParseConfigInfo_p,
                        prsBandwidth,
                        internalCellIndex);
                /* Cyclomatic_complexity_changes_end */

                if (dlResBlocks < prsBandwidth)
                {
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            prsBandwidth,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"PRS_BANDWIDTH_GT_SYSTEM_BANDWIDTH");
                }
                count++;
                prsChangeBits |= (1 << PRS_BANDWIDTH_CHANGE); 
            }
            break;

            case PRS_SUBFRAMES_INFO:
            {

                if (PRS_SUBFRAMES_INFO_TAG_LEN  != tagLen)
                {         
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            tagLen,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_SUBFRAMES_INFO_TAG_LEN");
                }

                prsSubframes = *msg_p++;
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_PRS_SUBFRAMES_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        prsSubframes,
                        internalCellIndex, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_PRS_SUBFRAMES_INFO_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/
                switch (prsSubframes)
                { 
                    case PRS_SUBFRAMES_1:
                    case PRS_SUBFRAMES_2:
                    case PRS_SUBFRAMES_4:
                    case PRS_SUBFRAMES_6:

                    prsParseConfigInfo_p->prsSubframes = 
                        prsSubframes;
                    break;

                    default:

                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            prsSubframes,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_SUBFRAMES_VAL");
                    break;  

                }
                count++;

                prsChangeBits |= (1 << PRS_SUBFRAME_CHANGE);
            }
            break;

            case PRS_CONFIG_INDEX_INFO:
            {

                if (PRS_CONFIG_INDEX_INFO_TAG_LEN  != tagLen)
                {         
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            tagLen,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_CONFIG_INDEX_INFO_TAG_LEN");
                }

                prsParseConfigInfo_p->prsConfigIndex = 
                    LTE_GET_U16BIT(msg_p);
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_PRS_CONFIG_INDEX_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        prsParseConfigInfo_p->prsConfigIndex,
                        internalCellIndex, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_PRS_CONFIG_INDEX_INFO_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/

                if (PRS_CONFIG_INDEX_MAX_VALUE < 
                        prsParseConfigInfo_p->prsConfigIndex) 
                {
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            prsParseConfigInfo_p->prsConfigIndex,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_CONFIG_INDEX");
                }

                msg_p += U16BIT_LEN;
                count += U16BIT_LEN;
                prsChangeBits |= (1 << PRS_CONFIGURATION_INDEX_CHANGE);
            }
            break;

            case PRS_TRANSMISSION_POWER_INFO:
            {

                if (PRS_TRANSMISSION_POWER_INFO_TAG_LEN  != tagLen)
                {         
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            tagLen,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_TRANSMISSION_POWER_INFO_TAG_LEN");
                }

                prsParseConfigInfo_p->prsTransmissionPower = 
                    LTE_GET_U16BIT(msg_p);
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_PRS_TRANSMISSION_POWER_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        prsParseConfigInfo_p->prsTransmissionPower,
                        internalCellIndex, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_PRS_TRANSMISSION_POWER_INFO_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/

                if (PRS_TRANSMISSION_POWER_MAX_VALUE < 
                        prsParseConfigInfo_p->prsTransmissionPower)
                {
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            prsParseConfigInfo_p->prsTransmissionPower,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_TRANSMISSION_POWER_VAL");
                }

                msg_p += U16BIT_LEN;
                count += U16BIT_LEN;
                prsChangeBits |= (1 << PRS_TRANSMISSION_POWER_CHANGE);
            }
            break;

            case PRS_MUTING_CONFIG_INFO:
            {

                if (PRS_MUTING_CONFIG_INFO_TAG_LEN != tagLen)
                {         
                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                            tagLen,
                            internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_MUTING_CONFIG_INFO_TAG_LEN");
                }

                prsParseConfigInfo_p->bitsTobeRead = *msg_p++;
                count++;

                switch(prsParseConfigInfo_p->bitsTobeRead)
                {
                    case PRS_MUTING_BITS_TO_BE_READ_2:
                    case PRS_MUTING_BITS_TO_BE_READ_4:
                    /* SPR_8112_FIX_START */
                    case PRS_MUTING_BITS_TO_BE_READ_8:
                    /* SPR_8112_FIX_END */
                    case PRS_MUTING_BITS_TO_BE_READ_16:
                    /* Muting bits configuration is correct */
                    prsParseConfigInfo_p->prsMutingConfigIndex = 
                        LTE_GET_U16BIT(msg_p);
                    msg_p += U16BIT_LEN;
                    count += U16BIT_LEN;
                    break;

                    default :       

                    response = MAC_FAILURE;

                    LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            prsParseConfigInfo_p->bitsTobeRead,
                            prsParseConfigInfo_p->prsMutingConfigIndex,internalCellIndex,
                            DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,"INVALID_PRS_MUTING_BITS");
                    break; 
                }   
                prsChangeBits |= (1 << PRS_MUTING_CONFIGURATION_CHANGE);
                /* Review comment fix start SYNC_LOSS_2*/
                LOG_MAC_MSG(MAC_PRS_MUTING_CONFIG_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        prsParseConfigInfo_p->bitsTobeRead,
                        prsParseConfigInfo_p->prsMutingConfigIndex, 
                        internalCellIndex,
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, "MAC_PRS_MUTING_CONFIG_INFO_PARAM");
                /* Review comment fix end SYNC_LOSS_2*/
            }
            break;

        }  
    }

    prsParseConfigInfo_p->prsChangeBits = prsChangeBits;

    if (count != totalTagLen)
    {
        response = MAC_FAILURE;
    }

    return response;
}
/* - PRS_CHANGES */

#ifdef MAC_AUT_TEST
/****************************************************************************
 * Function Name  : parseRRCMsg_local 
 * Inputs         : msg_p - Buffer received from RRC
 msgId - message ID
 msgLen - length of message received
 transactionId 
 internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function process the parsing of RRC Message
 *****************************************************************************/
 void parseRRCMsg_local( UInt8 *msg_p,
        UInt16 msgId,
        UInt16 msgLen,
        UInt16 transactionId,
        InternalCellIndex internalCellIndex
        )
{
    macParseRRCMsg(msg_p, msgId, msgLen, transactionId,internalCellIndex);
}
#endif
/* CA Changes start */
/***************************************************************************
 * Function Name  : macCommonUpdateCellIndexMapping
 * Inputs         : rrcCellIndex - RRC cell index
 * Outputs        : None
 * Returns        : Updated internalCell index or INVALID_CELL_INDEX.
 * Variables      :
 * Description    : This function will update cell index mapping.
 ****************************************************************************/
InternalCellIndex macCommonUpdateCellIndexMapping(RrcCellIndex cellIndex)
{
    return layer2CommonUpdateCellIndexMapping(cellIndex);
}

/***************************************************************************
 * Function Name  : macCommonLookupIfValidCellIndex
 * Inputs         : rrcCellIndex - RRC cell index
 * Outputs        : None
 * Returns        : LTE_TRUE or LTE_FALSE
 * Variables      :
 * Description    : This function validate the rrc cell id.
 *****************************************************************************/
UInt8 macCommonLookupIfValidCellIndex(RrcCellIndex cellIndex)
{
    return layer2CommonLookupIfValidCellIndex(cellIndex);
}

/*************************************************************************
 * Function Name  : macCommonGetRRCCellIndex
 * Inputs         : internalCellIndex - internal cell id
 * Outputs        : None
 * Returns        : Higher layer given cell Index based on assigned internal
 *                  index or INVALID_CELL_INDEX if wrong internal index 
 *                  received.
 * Variables      :
 * Description    : This function will return return rrc cell index
 *                  corresponding to internal cell index.
 ****************************************************************************/
RrcCellIndex macCommonGetRRCCellIndex(InternalCellIndex internalCellIndex)
{
    return layer2CommonGetRRCCellIndex(internalCellIndex);
}

/***************************************************************************
 * Function Name  : macCommonGetInternalCellIndex
 * Inputs         : rrcCellIndex - RRC cell index
 * Outputs        : None
 * Returns        : internal index corresponding to higher layer assigned 
 *                  cell index or INVALID_CELL_INDEX if wrong rrc index received.
 * Variables      :
 * Description    : This function will return internal cell index corresponding  
 ****************************************************************************/
InternalCellIndex macCommonGetInternalCellIndex(RrcCellIndex rrcCellIndex)
{
    return layer2CommonGetInternalCellIndex(rrcCellIndex);
}

/****************************************************************************
 * Function Name  : macCommonDeleteCellIndexMapping
 * Inputs         : cellIndex - RRC cell index
 * Outputs        : None
 * Returns        : None
 * Variables      :
 * Description    : This function will delete the rrc to internal cell index
 *                   mapping and vice versa.
 ****************************************************************************/
void macCommonDeleteCellIndexMapping(RrcCellIndex cellIndex)
{
    layer2CommonDeleteCellIndexMapping(cellIndex);
    return;
}

/***************************************************************************
 * Function Name  : macCommonRevertCellIndexMapping
 * Inputs         : internalCellIndex - internal cell id
 * Outputs        : None
 * Returns        : None
 * Variables      :
 * Description    : This function will revert the cell index mapping.
 ****************************************************************************/
void macCommonRevertCellIndexMapping(InternalCellIndex internalIndex)
{

    layer2CommonRevertCellIndexMapping(internalIndex);
    return;
}

/****************************************************************************
 * Function Name  : validateCellIndex
 * Inputs         : ueIndex  - UE Index which uniquely identifies UE.
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This API takes cellIndex to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/

STATIC MacRetType validateCellIndex(UInt32 ueIndex, 
        InternalCellIndex internalCellIndex)
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    /* SPR 20275 Fix Start */
    if (dlUECtxInfoArr_g[ueIndex].dlUEContext_p)
    {
        if (internalCellIndex 
                != (dlUECtxInfoArr_g[ueIndex].dlUEContext_p->internalCellIndex))
        {
            LOG_MAC_MSG(OAM_RRC_INVALID_MSG_LEN_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"INVALID_MSG");
            return MAC_FAILURE;
        }
        return MAC_SUCCESS;
    }
    return MAC_FAILURE;
    /* SPR 20275 Fix End */
}

/******************************************************************************
 * Function Name  : macParseCreateUECategoryV1020Info 
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the UE Category information for CA in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType macParseCreateUECategoryV1020Info( UInt8 **msgBuf_pp, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p ,
        InternalCellIndex internalCellIndex)
{
    UInt8 *msg_p    = PNULL;
    MacRetType resp = MAC_SUCCESS;
    msg_p = *msgBuf_pp;

    if ( UE_CATEGORY_TAG_LEN != tagLen )
    {  
        LOG_MAC_MSG(MAC_INAVLID_LEN_MSG_ID,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                DEFAULT_INT_VALUE, 
                internalCellIndex,
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for UE_CATEGORY_V1020  Info");
        return MAC_FAILURE;
    }
    dlCreateReq_p->ueCategoryV1020 = *msg_p++;
    ulCreateReq_p->ueCategoryV1020 = dlCreateReq_p->ueCategoryV1020;
    resp = macValidateUeCategoryV1020(dlCreateReq_p->ueCategoryV1020,
            internalCellIndex);
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    dlCreateReq_p->ueCategoryV1020ReqType = LTE_TRUE;
    ulCreateReq_p->ueCategoryV1020ReqType = LTE_TRUE;

    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macParseCreatePUCCHFormatV1020 
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the PUCCH Format information for CA in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC MacRetType macParseCreatePUCCHFormatV1020( UInt8 **msgBuf_pp, 
        UInt16 tagLen, UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p    = PNULL;
    MacRetType retval = MAC_SUCCESS;
    UInt16 tag=0;

    msg_p = *msgBuf_pp;

    UInt8 pucchAnCsListElement=0;
    UInt16 pucchFormatTagLength=0;
    UInt8 requestType=0;
    if ( tagLen < PUCCH_FORMAT_V1020_MIN_LEN )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PUCCH_FORMAT_V1020_INFO_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    if (PUCCH_CHANNEL_SELECTION_CONFIG_V1020 == tag )
    {
        pucchFormatTagLength = tagLen - TAG_LEN;
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        if ( tagLen < PUCCH_CHANNEL_SELECTION_CONFIG_V1020_MIN_LEN )
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "PUCCH_CHANNEL_SELECTION_CONFIG_V1020_INFO_INVALID_TAGLEN");
            return MAC_FAILURE;
        }
        msg_p += U16BIT_LEN;
        requestType = *msg_p++;
        dlCreateReq_p->pucchFormatR10.requestType = requestType;
        ulCreateReq_p->pucchFormatR10.requestType = requestType;
        if(PUCCH_CHANNEL_SELECTION_CONFIG_V1020_SETUP == requestType)
        {
            pucchFormatTagLength = pucchFormatTagLength - 
                PUCCH_CHANNEL_SELECTION_CONFIG_V1020_MIN_LEN;
            while ( pucchFormatTagLength > 0)
            {
                tag = LTE_GET_U16BIT(msg_p);
                msg_p += U16BIT_LEN;
                tagLen = LTE_GET_U16BIT(msg_p);
                msg_p += U16BIT_LEN;
                pucchFormatTagLength = pucchFormatTagLength - tagLen;
                if (PUCCH_AN_CS_LIST_V1020 == tag )
                {
                    if ( tagLen < PUCCH_AN_CS_LIST_V1020_MIN_LEN )
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                ulCreateReq_p->ueIdx,tagLen,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "PUCCH_AN_CS_LIST_V1020"
                                "_INFO_INVALID_TAGLEN");
                        return MAC_FAILURE;
                    }
                    tagLen = tagLen - PUCCH_AN_CS_LIST_V1020_MIN_LEN;
                    retval = macParsePucchAnCsV1020(&msg_p,tagLen,
                            pucchAnCsListElement,dlCreateReq_p, 
                            ulCreateReq_p,internalCellIndex);
                    if ( retval != MAC_SUCCESS )
                    {
                        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                tagLen,
                                internalCellIndex, 
                                __LINE__, 
                                DEFAULT_INT_VALUE, 
                                DEFAULT_INT_VALUE, 
                                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME, 
                                "Invalid Tag Length for PUCCH_FORMAT_V1020 Info");
                        return MAC_FAILURE;
                    }
                    pucchAnCsListElement++;
                }
                else
                {
                    LOG_MAC_ERROR(MAC_RRC_INF,"Invalid PUCCH_AN_CS_LIST_V1020 tag %u\n",tag); 
                    retval = MAC_SYNTAX_ERROR_VAL;
                    return retval;
                }
            }
        }
        else
        {
            if(PUCCH_CHANNEL_SELECTION_CONFIG_V1020_RELEASE != requestType)
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid requestType for PUCCH_FORMAT_V1020 Info");
                return MAC_FAILURE;
            }
        }
    }

    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macParseCreateCAConfig 
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the CA config information for CA in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC MacRetType macParseCreateCAConfig( UInt8 **msgBuf_pp, 
        UInt16 tagLen, 
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex)
{
    UInt8 *msg_p    = PNULL;
    MacRetType resp = MAC_SUCCESS;
    UInt16 tag=0;

    msg_p = *msgBuf_pp;

    UInt16 caConfigTagLength=0;
    if ( tagLen < MIN_CA_CONFIG_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CA_CONFIG_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    caConfigTagLength = tagLen;
    caConfigTagLength = caConfigTagLength - MIN_CA_CONFIG_TAG_LEN;
    while (caConfigTagLength > 0)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        caConfigTagLength = caConfigTagLength - tagLen;
        switch( tag )
        {
            case SCELL_DEACTIVATION_TIMER_INFO :
            {
                /* + SPR 11631 Changes */
                resp = macParseScellDeactivationTimer(tagLen,&msg_p,
                        ulCreateReq_p, dlCreateReq_p, internalCellIndex, PNULL);
                /* - SPR 11631 Changes */
                if ( resp != MAC_SUCCESS )
                {
                    return MAC_FAILURE;
                }
                break;
            }
            case SCELL_INFO :
            {
                resp = macParseAndValidateScellInfo(tagLen,&msg_p,
                        ulCreateReq_p, dlCreateReq_p, internalCellIndex);
                if ( resp != MAC_SUCCESS )
                {
                    return MAC_FAILURE;
                }
                break;
            }
            case CA_LC_BANDWIDTH_DIST_INFO:
            {
                /* + SPR 11631 Changes */
                resp = macParseCALCBandwidthDistributionInfo(tagLen,&msg_p,
                        dlCreateReq_p,internalCellIndex, PNULL);
                /* - SPR 11631 Changes */
                if ( resp != MAC_SUCCESS )
                {
                    return MAC_FAILURE;
                }
                break;
            }
            default: 
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid Tag Received for CA_CONFIG Info");
                return MAC_FAILURE;
            }
        }
    }

    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macInitCAParams 
 * Inputs         : ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 * Outputs        : None
 * Returns        : None
 * Description    : This function initializes the CA config parameters
 ******************************************************************************/
STATIC void macInitCAParams (UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p )
{
    UInt8 n1PucchCount = 0,n1PucchListCount = 0, sCell = 0,
          cbsrCount=0,bandIndex = 0,lchIndex=0;
    dlCreateReq_p->ueCategoryV1020  = INVALID_UE_CATEGORY;
    ulCreateReq_p->ueCategoryV1020  = INVALID_UE_CATEGORY;
    dlCreateReq_p->ueCategoryV1020ReqType  = LTE_FALSE;
    ulCreateReq_p->ueCategoryV1020ReqType  = LTE_FALSE;
    dlCreateReq_p->trigger1r10 = LTE_FALSE;
    ulCreateReq_p->trigger2r10  = LTE_FALSE;
    dlCreateReq_p->trigger2r10 = LTE_FALSE;
    ulCreateReq_p->trigger1r10  = LTE_FALSE;
    ulCreateReq_p->pucchFormatR10.requestType = INVALID_REQUEST_TYPE;
    dlCreateReq_p->pucchFormatR10.requestType = INVALID_REQUEST_TYPE;
    for(n1PucchListCount = 0; n1PucchListCount<MAX_PUCCH_AN_CS_LIST; n1PucchListCount++)
    {
        for(n1PucchCount = 0; n1PucchCount<MAX_PUCCH_AN_CS; n1PucchCount++)
        {
            ulCreateReq_p->pucchFormatR10.n1Pucch[n1PucchListCount][n1PucchCount]
                = INVALID_16_VAL;
            dlCreateReq_p->pucchFormatR10.n1Pucch[n1PucchListCount][n1PucchCount]
                = INVALID_16_VAL;
        }
    }
    ulCreateReq_p->carrierAggrConfig.scellDeactivationTimer = LTE_FALSE;
    dlCreateReq_p->carrierAggrConfig.scellDeactivationTimer = LTE_FALSE;
    ulCreateReq_p->carrierAggrConfig.scellCount = LTE_FALSE;
    dlCreateReq_p->carrierAggrConfig.scellCount = LTE_FALSE;
    for (lchIndex = 0; lchIndex < MAC_MAX_LCHID; lchIndex++)
    {
        dlCreateReq_p->logicalChConfig[lchIndex].bandWidthDistribution[PCELL_SERV_CELL_IX] = 
            MAX_CA_LC_BANDWIDTH_DIST_VAL;
        dlCreateReq_p->logicalChConfig[lchIndex].isBandWidthTagPresent = LTE_FALSE;
        for (bandIndex = MAX_NUM_PCELL; bandIndex < MAX_SERVCELL; bandIndex++)
        {
            dlCreateReq_p->logicalChConfig[lchIndex].bandWidthDistribution[bandIndex] =
                LTE_FALSE;
        }
    }
    dlCreateReq_p->carrierAggrConfig.isBandWidthTagPresent = LTE_FALSE;
    dlCreateReq_p->carrierAggrConfig.bandWidthDistribution[PCELL_SERV_CELL_IX] = 
        MAX_CA_LC_BANDWIDTH_DIST_VAL;
    for (bandIndex = MAX_NUM_PCELL; bandIndex < (MAX_SERVCELL); bandIndex++)
    {
        dlCreateReq_p->carrierAggrConfig.bandWidthDistribution[bandIndex] = 
            LTE_FALSE;
    }
    for (sCell = 0; sCell < MAX_NUM_SCELL; sCell++)
    {
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].internalCellIndex = 
            INVALID_CELL_INDEX;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].sCellIndex = 
            INVALID_8_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].operationType = 
            INVALID_SCELL_OPERATION_TYPE;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].numOfLayer = LTE_FALSE;
        /* Coverity 60450*/
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].transmissionMode = INVALID_TX_MODE;
        /* Coverity 60450*/
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].rankIndicator = INVALID_RANK_INDICATOR;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].precodingIndex = 
            INVALID_CODE_BOOK_INDEX;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].isScellActivateStatus = 
            LTE_FALSE;
#ifdef HD_FDD_CONFIG
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].isHDFddFlag = 
            HD_FDD_FLAG_INVALID;
#endif
        /*SPR 12911 fix, Initialize Scell userLocationType with a valid value*/  
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].userLocationType = CC_USER; 
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].modScheme = 
            INVALID_8_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].pA = INVALID_8_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].isPAPresent = LTE_FALSE;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].
            codebookSubsetRestrictionv1020.cbsrType = CBSR_INVALID;
        for(cbsrCount = 0; cbsrCount<MAX_CBSR_VALUE_COUNT; cbsrCount++)
        {
            ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].
                codebookSubsetRestrictionv1020.cbsrValue[cbsrCount] = LTE_FALSE;
            dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].
                codebookSubsetRestrictionv1020.cbsrValue[cbsrCount] = LTE_FALSE;
        }
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].internalCellIndex = 
            INVALID_CELL_INDEX;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].sCellIndex = 
            INVALID_8_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].operationType = 
            INVALID_SCELL_OPERATION_TYPE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].numOfLayer = LTE_FALSE;
        /* Coverity 60451*/
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].transmissionMode = 
            INVALID_TX_MODE;
        /* Coverity 60451*/
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].dlNumHarqProcess = 
            LTE_FALSE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].dlInitMCS = 
            INVALID_8_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].modScheme = 
            INVALID_8_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].rankIndicator = INVALID_RANK_INDICATOR;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].precodingIndex = 
            INVALID_CODE_BOOK_INDEX;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].isScellActivateStatus = 
            0;
#ifdef HD_FDD_CONFIG
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].isHDFddFlag = 
            HD_FDD_FLAG_INVALID;
#endif
        /*SPR 12911 fix, Initialize Scell userLocationType with a valid value*/  
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].userLocationType = CC_USER; 

        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].pA = INVALID_8_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].isPAPresent = LTE_FALSE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].
            codebookSubsetRestrictionv1020.cbsrType = CBSR_INVALID;

        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.cqiMode = 
            CQI_MODE_INVALID;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.cqiIndication 
            = INVALID_CQI_REPORTING_MODE;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.cqiRequestType
            = INVALID_PERIODIC_CQI_REQ_TYPE;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPMIConfigIndex= INVALID_16_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPucchResourceIndex= INVALID_16_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodic= INVALID_PERIODIC_FORMAT;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodic_subband_k= INVALID_PERIODIC_FORMAT;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            riConfigIndex= MAC_RI_CONFIG_INDEX_INVALID;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPMIConfigIndexV1020= INVALID_16_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPucchResourceIndexV1020= INVALID_16_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            simultaneousACKNACKAndCQIV1020= INVALID_SIMULTANEOUS_ACK_NACK_VALUE;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            simultaneousACKNACKAndCQI= INVALID_SIMULTANEOUS_ACK_NACK_VALUE;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodicV1020= INVALID_PERIODIC_FORMAT;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodic_subband_kV1020= INVALID_PERIODIC_FORMAT;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            riConfigIndexV1020= MAC_RI_CONFIG_INDEX_INVALID;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiMaskV920= INVALID_8_VAL;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            pmiRiReportV920= INVALID_PMI_RI_CONF_V920;
        ulCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiInfoFlag = LTE_FALSE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiMode = CQI_MODE_INVALID;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiIndication = INVALID_CQI_REPORTING_MODE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiRequestType= INVALID_PERIODIC_CQI_REQ_TYPE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPMIConfigIndex= INVALID_16_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPucchResourceIndex= INVALID_16_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodic= INVALID_PERIODIC_FORMAT;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodic_subband_k= INVALID_PERIODIC_FORMAT;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            riConfigIndex= MAC_RI_CONFIG_INDEX_INVALID;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPMIConfigIndexV1020= INVALID_16_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiPucchResourceIndexV1020= INVALID_16_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            simultaneousACKNACKAndCQIV1020= INVALID_SIMULTANEOUS_ACK_NACK_VALUE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            simultaneousACKNACKAndCQI= INVALID_SIMULTANEOUS_ACK_NACK_VALUE;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodicV1020= INVALID_PERIODIC_FORMAT;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiformatIndicatorPeriodic_subband_kV1020= INVALID_PERIODIC_FORMAT;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            riConfigIndexV1020= MAC_RI_CONFIG_INDEX_INVALID;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiMaskV920= INVALID_8_VAL;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            pmiRiReportV920= INVALID_PMI_RI_CONF_V920;
        dlCreateReq_p->carrierAggrConfig.scellInfo[sCell].cqiInfo.
            cqiInfoFlag = LTE_FALSE;
    }
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateULReconfigPucchInfoV1020
 * Inputs         : ulUEContext_p - Pointer to UL UE Context
 *                  ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes and updates the UL Reconfig PUCCH
 *                  Config information
 *****************************************************************************/
STATIC void macProcessAndUpdateULReconfigPucchInfoV1020(
        ULUEContext *ulUEContext_p, ULReconfigUeReq *ulReconfigUeReq_p)
{
    UInt8 n1PucchList = 0, n1PucchCs = 0;
    ulUEContext_p->pucchFormatR10.requestType =
        ulReconfigUeReq_p->pucchFormatR10.requestType;
    for (n1PucchList = 0; n1PucchList < MAX_PUCCH_AN_CS_LIST; n1PucchList++)
    {
        for (n1PucchCs = 0; n1PucchCs < MAX_PUCCH_AN_CS; n1PucchCs++)
        {
            ulUEContext_p->pucchFormatR10.n1Pucch[n1PucchList][n1PucchCs]=
                ulReconfigUeReq_p->pucchFormatR10.n1Pucch[n1PucchList][n1PucchCs];
        }
    }
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigPucchInfoV1020
 * Inputs         : dlUEContext_p - Pointer to DL UE Context
 *                  dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes and updates the UL Reconfig PUCCH
 *                  Config information
 *****************************************************************************/
STATIC void macProcessAndUpdateDLReconfigPucchInfoV1020( 
        DLUEContext *dlUEContext_p, DLReconfigUeReq *dlReconfigUeReq_p)
{
    UInt8 n1PucchList = 0, n1PucchCs = 0;
    dlUEContext_p->pucchFormatR10.requestType =
        dlReconfigUeReq_p->pucchFormatR10.requestType;
    for (n1PucchList = 0; n1PucchList < MAX_PUCCH_AN_CS_LIST; n1PucchList++)
    {
        for (n1PucchCs = 0; n1PucchCs < MAX_PUCCH_AN_CS; n1PucchCs++)
        {
            dlUEContext_p->pucchFormatR10.n1Pucch[n1PucchList][n1PucchCs]=
                dlReconfigUeReq_p->pucchFormatR10.n1Pucch[n1PucchList][n1PucchCs];
        }
    }
}

/****************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigCAConfig 
 * Inputs         : dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MacRetType
 * Description    : This function process and updates DL Reconfig Measurement
 *                  Gap Config
 ****************************************************************************/
STATIC MacRetType  macProcessAndUpdateDLReconfigCAConfig(
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p
        ,InternalCellIndex internalCellIndex
        )
{
    UInt32 tlvType = 0;
    UInt8 tlvIndex = 0, cellCount = 0;
    for (tlvIndex = 0; tlvIndex < dlReconfigUeReq_p->caConfigDL.
            ueDLCAReconfigMsgTlvCount; tlvIndex++)
    {
        tlvType = dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigTlvRecieved[tlvIndex];
        switch(tlvType)
        {
            case DL_RECONFIG_CA_CONFIG_SCELL_DEACTIVATION_TIMER:
            {
                macProcessAndUpdateDLReconfigDeactivationTimer(
                        dlReconfigUeReq_p, dlUEContext_p);
                break;   
            }
            case DL_RECONFIG_CA_CONFIG_SCELL_INFO:
            {
                if( MAC_FAILURE == macProcessAndUpdateDLReconfigScellInfo(
                            dlReconfigUeReq_p,dlUEContext_p,cellCount
                            , internalCellIndex
                            ) )
                {
                    return MAC_FAILURE;
                }
                cellCount++;
                break;   
            }
            case DL_RECONFIG_CA_LC_BANDWIDTH_DIST_INFO:
            {
                macProcessAndUpdateDLReconfigCALCBandwidthDistributionInfo(
                        dlReconfigUeReq_p, dlUEContext_p);
                break;   
            }
        }
    }
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigDeactivationTimer 
 * Inputs         : dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig Deactivation 
 *                  Timer info
 * ****************************************************************************/
STATIC void macProcessAndUpdateDLReconfigDeactivationTimer( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p)
{
    dlUEContext_p->scellDeactivationTimer =
        dlReconfigUeReq_p->caConfigDL.scellDeactivation.scellDeactivationTimer;
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigCALCBandwidthDistributionInfo 
 * Inputs         : dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig LC Bandwidth 
 *                  Distance information
 * ****************************************************************************/
STATIC void macProcessAndUpdateDLReconfigCALCBandwidthDistributionInfo( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p)
{
    UInt8 numBandwidthDist = 0;
    /*Currently this array is for max number of Scells supported Cov_fix_6May_63669_Start */
    for (numBandwidthDist = PCELL_SERV_CELL_IX; numBandwidthDist <= MAX_NUM_SCELL\
            ; numBandwidthDist++)
    { /*Cov_fix_6May_63669_Stop */
        dlUEContext_p->bandWidthDistribution[numBandwidthDist] =
            dlReconfigUeReq_p->caConfigDL.dlBandWidthDistribution.
            bandWidthDistribution[numBandwidthDist];
    }
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigScellInfo 
 * Inputs         : dlReconfigUeReq_p - Pointer to DL Reconfig UE Request
 *                  dlUEContext_p - Pointer to DL UE Context
 *                  cellCount - 
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function process and updates DL Reconfig Scell Parameters
 * ****************************************************************************/
STATIC MacRetType macProcessAndUpdateDLReconfigScellInfo( 
        DLReconfigUeReq *dlReconfigUeReq_p, DLUEContext *dlUEContext_p,
        UInt8 cellCount, InternalCellIndex internalCellIndex
        )
{
    UInt32 tlvType = 0;
    DLSCELLReconfigInfo *dlReconfigScellInfo_p = PNULL;
    DLUESCellContext *dlUeScellContext_p = PNULL;
    UInt16 ueIndex = dlReconfigUeReq_p->ueIndex;
    ULUEContext *ulUEContext_p = PNULL;
    ulUEContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
    UInt8 tlvIndex = 0, scellIndex = 0;
    /* coverity fix-70310 start 
       Unused variable retval removed
       coverity fix-70310 start */

    scellIndex = dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[cellCount].sCellIndex;

    dlReconfigScellInfo_p = & dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL
        [cellCount];
    dlUeScellContext_p = dlUEContext_p->dlUeScellContext_p[scellIndex];
    if ((ADD == dlReconfigScellInfo_p->operationType) || (DELETE == dlReconfigScellInfo_p->operationType))
    {

        /*cyclomatic fix start*/ 
        /* coverity fix- 32228 start */
        if( macCheckOperationTypeForUeCategory(dlReconfigScellInfo_p,dlUEContext_p,scellIndex,
                    internalCellIndex))
            return MAC_SUCCESS;
        else
            return MAC_FAILURE;
        /* coverity fix- 32228 end */
        /*cyclomatic fix end*/ 
    } 
    dlUeScellContext_p->ScelldlCQIInfo.isSubBandReportAvailable  = LTE_FALSE;
    dlUeScellContext_p->ScelldlCQIInfo.isWideBandReportAvailable = LTE_FALSE;
    /* SPR 11043 changes start */
    dlUeScellContext_p->internalCellIndex = dlReconfigScellInfo_p->internalCellIndex;
    /* SPR 11043 changes end */
    for (tlvIndex = 0; tlvIndex < dlReconfigScellInfo_p->
            ueDLCAScellReconfigMsgTlvCount; tlvIndex++)
    {
        tlvType = dlReconfigScellInfo_p->
            ueDLCAScellInfoReconfigTlvRecieved[tlvIndex];
        switch(tlvType)
        {
            case DL_RECONFIG_SCELL_MIMO_CAPABILITY_V1020:
            {
                macProcessAndUpdateDLReconfigMimoCapabilityV1020(
                        dlReconfigScellInfo_p, dlUeScellContext_p);
                break;   
            }
            case DL_RECONFIG_SCELL_TRANS_MODE_INFO:
            {
                dlUeScellContext_p->ScelldlMIMOInfo.transmissionMode = 
                    (TransmissonMode) dlReconfigScellInfo_p->scellTransMode.transMode;
                if ( (TX_MODE_1 == dlUeScellContext_p->
                            ScelldlMIMOInfo.transmissionMode) ||
                        (TX_MODE_2 == dlUeScellContext_p->
                         ScelldlMIMOInfo.transmissionMode) ||
                        (TX_MODE_6 == dlUeScellContext_p->ScelldlMIMOInfo.
                         transmissionMode) || (TX_MODE_7 == 
                             dlUeScellContext_p->ScelldlMIMOInfo.transmissionMode))
                {
                    ulUEContext_p->ulUeScellContext_p[scellIndex]->scellpucchConfigInfo.
                        ueReportedRI = RANK_INDICATOR_1;
                }
                break;
            }
            case DL_RECONFIG_SCELL_CODEBOOK_SUBSET_RESTRICTION_V1020:
            {
                macProcessAndUpdateDLReconfigCodeBookV1020Info(
                        dlReconfigScellInfo_p, dlUeScellContext_p);
                break;
            }
            case DL_RECONFIG_SCELL_PDSCH_CONFIG_INFO:
            {
                dlUeScellContext_p->pA = 
                    dlReconfigScellInfo_p->scellPdschConfigInfo.dlPdschTransPower;
                LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] Pdsch Trans Power"\
                        "At HP Side = %d \n",
                        __func__, dlUeScellContext_p->pA);
                break;
            }
            case DL_RECONFIG_SCELL_CQI_INFO:
            {
                if (MAC_FAILURE == macProcessAndUpdateDLReconfigScellCQIInfo(ueIndex,
                            &(dlUeScellContext_p->ScelldlCQIInfo),
                            dlReconfigScellInfo_p,dlUeScellContext_p
                            , internalCellIndex
                            ))
                {
                    return MAC_FAILURE;
                }
                break;
            }
            case DL_RECONFIG_SCELL_NUM_OF_LAYER_INFO:
            {
                dlUeScellContext_p->ScelldlMIMOInfo.dlRi = 
                    ulUEContext_p->ulUeScellContext_p[scellIndex]->
                    scellpucchConfigInfo.ueReportedRI = ulUEContext_p->ulUeScellContext_p
                    [scellIndex]->scellpucchConfigInfo.ueReportedPeriodicRI =  
                    dlReconfigScellInfo_p->numOfLayersInfoDL.numOfLayers;
                break;
            }
            case DL_RECONFIG_SCELL_CODEBOOK_INDEX_INFO:
            {
                dlUeScellContext_p->ScelldlMIMOInfo.precodingIndex = 
                    dlReconfigScellInfo_p->codeBookIndexInfo.codeBookIndex;
                dlUeScellContext_p->ScelldlCQIInfo.wideBandPMIIndex =
                    dlReconfigScellInfo_p->codeBookIndexInfo.codeBookIndex;
                break;
            }
#ifdef HD_FDD_CONFIG
            case DL_RECONFIG_SCELL_RF_PARAMS:
            {
                macprocessAndUpdateDLReconfigScellRFParams( 
                        dlReconfigScellInfo_p, dlUEContext_p,scellIndex,
                        internalCellIndex);
                break;
            }
#endif
            case DL_RECONFIG_SCELL_ACTIVATE_STATUS:
            {
                dlUeScellContext_p->isScellActivateStatus =
                    dlReconfigScellInfo_p->isScellActivateStatus;
                /*spr 11041 fix start*/
                insertNodeInDlCAEventQueueRRCIntf(scellIndex,dlUeScellContext_p->isScellActivateStatus,ueIndex,internalCellIndex); 
                /*spr 11041 fix end*/
                break;
            }
        }
    }
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigMimoCapabilityV1020 
 * Inputs         : dlReconfigScellInfo_p - Pointer to DL Reconfig SCell UE Request
 *                  dlUeScellContext_p - Pointer to DL Reconfig Scell UE Context
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig Mimo
 *                  Capability Parameters
 * ****************************************************************************/
STATIC void macProcessAndUpdateDLReconfigMimoCapabilityV1020( 
        DLSCELLReconfigInfo *dlReconfigScellInfo_p, 
        DLUESCellContext *dlUeScellContext_p)
{
    dlUeScellContext_p->ScelldlMIMOInfo.numOfLayerMIMO =
        dlReconfigScellInfo_p->numOfLayerMIMO;
}

/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigCodeBookV1020Info 
 * Inputs         : dlReconfigScellInfo_p - Pointer to DL Reconfig SCell UE Request
 *                  dlUeScellContext_p - Pointer to DL Reconfig Scell UE Context
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig RF Parameters
 * ****************************************************************************/
STATIC void macProcessAndUpdateDLReconfigCodeBookV1020Info( 
        DLSCELLReconfigInfo *dlReconfigScellInfo_p, 
        DLUESCellContext *dlUeScellContext_p)
{
    if(dlReconfigScellInfo_p->codebookSubsetRestrictionv1020.cbsrType != 
            CBSR_INVALID)
    {    
        dlUeScellContext_p->codebookSubsetRestrictionv1020 = 
            dlReconfigScellInfo_p->codebookSubsetRestrictionv1020;
    }
}

#ifdef HD_FDD_CONFIG
/******************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigScellRFParams 
 * Inputs         : dlReconfigInfo_p - Pointer to DL Reconfig Info struct
 *                  dlUEContext_p - Pointer to DL UE Context
 *                  scellIndex - secondry cell index
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig RF Parameters
 * ****************************************************************************/
STATIC void macprocessAndUpdateDLReconfigScellRFParams( 
        DLSCELLReconfigInfo *dlReconfigInfo_p, DLUEContext *dlUEContext_p,
        UInt8 scellIndex,InternalCellIndex internalCellIndex)
{
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    if((LTE_TRUE==dlReconfigInfo_p->rfParams))
    {
        /** if ue is being made HD from either earlier type HD or FD **/
        /*Already RF_PARAMS (HD FDD UE Support) is not received in previous 
          config/reconfig*/
        if(LTE_FALSE == dlUEContext_p->dlUeScellContext_p[scellIndex]->isHDFddFlag)
        {
            dlUEContext_p->dlUeScellContext_p[scellIndex]->isHDFddFlag = LTE_TRUE;
            LOG_MAC_MSG(MAC_HD_FDD_CONFIG_SWITCH,LOGINFO,MAC_UL_Strategy,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlUEContext_p->ueIndex,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "UE changed from FDD->HD FDD");
            if(MAC_HD_FDD != cellParams_p->duplexingMode)
            {
                LOG_MAC_MSG(MAC_HD_FDD_CELL_NOT_SUPPORTED,LOGFATAL,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEContext_p->ueIndex,
                        cellParams_p->duplexingMode,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "Cell not supported for HD-FDD");
            }
        }
    }
    else if((LTE_TRUE==dlUEContext_p->dlUeScellContext_p[scellIndex]->isHDFddFlag) && 
            (LTE_FALSE==dlReconfigInfo_p->rfParams))
    {
        /** ue is being confirgured from HD to FD, so delete from the HD list **/
        LOG_MAC_MSG(MAC_HD_FDD_CONFIG_SWITCH,LOGINFO,MAC_UL_Strategy,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEContext_p->ueIndex,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "UE changed from HD FDD->FDD");
        /* SPR 11940 start */        
        deleteUeFromHdFddContext(dlUEContext_p, internalCellIndex);
        /* SPR 11940 end */        
        dlUEContext_p->dlUeScellContext_p[scellIndex]->isHDFddFlag = LTE_FALSE;
    }
}
#endif

/****************************************************************************
 * Function Name  : macProcessAndUpdateDLReconfigScellCQIInfo 
 * Inputs         : ueIndex - Stores UE index
 *                  dlCQIInfo_p - Pointer to DL CQI Info
 *                  dlReconfigScellInfo_p - Pointer to DL Reconfig Scell UE Request
 *                  dlUeScellContext_p - Pointer to DL UE Scell Context
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MacRetType
 * Description    : This function process and updates DL Reconfig CQI Info
 ****************************************************************************/
STATIC MacRetType macProcessAndUpdateDLReconfigScellCQIInfo( UInt16 ueIndex,
        SCELLDLCQIInfo *dlCQIInfo_p, DLSCELLReconfigInfo *dlReconfigScellInfo_p, 
        DLUESCellContext *dlUeScellContext_p
        ,InternalCellIndex internalCellIndex
        )
{
    UInt8 cqiValue = 0;   
    /* + CQI_5.0 */
    SubBandReportInfo tempSubbandReportInfo;
    memSet(&tempSubbandReportInfo,0,sizeof(SubBandReportInfo));

    dlCQIInfo_p->cqiTypeIndicator = 
        dlReconfigScellInfo_p->cqiInfo.cqiIndication;
    dlUeScellContext_p->isSubbandPMIAvailable = LTE_FALSE;
    dlUeScellContext_p->aperiodicMode12Rcvd = LTE_FALSE;
    dlCQIInfo_p->cqiMode = dlReconfigScellInfo_p->cqiInfo.cqiMode;    

    dlCQIInfo_p->modulationSchemeCodeWordOne = 
        dlReconfigScellInfo_p->dlCqiConfigInfo.modScheme;   
    dlCQIInfo_p->modulationSchemeCodeWordTwo = 
        dlReconfigScellInfo_p->dlCqiConfigInfo.modScheme;   
    cqiValue = getCQIFromMCS(dlCQIInfo_p->mcsIndexCodeWordOne);

    dlCQIInfo_p->widebandCQICodeWordOne =
        dlCQIInfo_p->widebandCQICodeWordTwo =
        dlCQIInfo_p->initialCqiValue = cqiValue;
    updateDLSINRCW0(ueIndex,cqiValue, internalCellIndex);
    updateDLSINRCW1(ueIndex,cqiValue, internalCellIndex);

    if (PNULL == dlCQIInfo_p->subBandReportInfo_p)
    {
        GET_MEM_FROM_POOL(SubBandReportInfo,
                dlCQIInfo_p->subBandReportInfo_p,
                sizeof(SubBandReportInfo),PNULL);

        if ( PNULL == dlCQIInfo_p->subBandReportInfo_p )
        {
            LOG_MAC_MSG(L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, L2_SYS_FAIL,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex), __LINE__, 
                    sizeof(SubBandReportInfo), internalCellIndex,0, 0, 0,0, 
                    __FILE__, __func__);
            ALARM_MSG(MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID, 
                    CRITICAL_ALARM);
            return MAC_FAILURE;
        }
        *(dlCQIInfo_p->subBandReportInfo_p) = tempSubbandReportInfo ;
        dlCQIInfo_p->isSubBandReportAvailable = LTE_FALSE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macProcessAndUpdateULReconfigCAConfig 
 * Inputs         : ueIndex - UE id
 *                  ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 *                  ulUEContext_p - Pointer to UL UE Context
 *                  ulReconfigUeResp_p - Pointer to UL Reconfig UE Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MacRetType
 * Description    : This function process and updates DL Reconfig Measurement
 *                  Gap Config
 ****************************************************************************/
/* +- SPR 17777 */
STATIC MacRetType  macProcessAndUpdateULReconfigCAConfig(
#ifdef HD_FDD_CONFIG
        UInt16 ueIndex,
#endif
        /* +- SPR 17777 */
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt32 tlvType = 0;
    UInt8 tlvIndex= 0, cellCount = 0;
    for (tlvIndex = 0; tlvIndex < ulReconfigUeReq_p->
            caConfigUL.ueULCAReconfigMsgTlvCount; tlvIndex++)
    {
        tlvType = ulReconfigUeReq_p->
            caConfigUL.ueULCAReconfigTlvRecieved[tlvIndex];
        switch(tlvType)
        {
            case UL_RECONFIG_CA_CONFIG_SCELL_DEACTIVATION_TIMER:
            {
                macProcessAndUpdateULReconfigDeactivationTimer(
                        ulReconfigUeReq_p, ulUEContext_p);
                break;   
            }
            case UL_RECONFIG_CA_CONFIG_SCELL_INFO:
            {
                /* +- SPR 17777 */
                if( MAC_FAILURE == macProcessAndUpdateULReconfigScellInfo(
#ifdef HD_FDD_CONFIG
                            ueIndex,
#endif
                            /* +- SPR 17777 */
                            ulReconfigUeReq_p, ulUEContext_p,cellCount,
                            ulReconfigUeResp_p,internalCellIndex
                            ) )
                {
                    return MAC_FAILURE;
                }
                cellCount++;
                break;   
            }
        }
    }
    return MAC_SUCCESS;
}
/******************************************************************************
 * Function Name  : macProcessAndUpdateULReconfigDeactivationTimer 
 * Inputs         : ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 *                  ulUEContext_p - Pointer to UL UE Context
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates UL Reconfig Deactivation
 *                  Timer parameters
 * ****************************************************************************/
STATIC  void macProcessAndUpdateULReconfigDeactivationTimer( 
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p)
{
    ulUEContext_p->scellDeactivationTimer =
        ulReconfigUeReq_p->caConfigUL.scellDeactivation.scellDeactivationTimer;
}
/******************************************************************************
 * Function Name  : macProcessAndUpdateULReconfigScellInfo 
 * Inputs         : ulReconfigUeReq_p - Pointer to UL Reconfig UE Request
 *                  ueIndex - UE id
 *                  ulUEContext_p - Pointer to UL UE Context
 *                  cellCount - 
 *                  ulReconfigUeResp_p - Pointer to UL Reconfig UE Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MacRetType
 * Description    : This function process and updates UL Reconfig Scell Info
 *                  Parameters
 * ****************************************************************************/
/* +- SPR 17777 */
STATIC MacRetType macProcessAndUpdateULReconfigScellInfo(
#ifdef HD_FDD_CONFIG
        UInt16 ueIndex,
#endif
        /* +- SPR 17777 */
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p, 
        UInt8 cellCount,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex
        )
{
    ULSCELLReconfigInfo *ulReconfigScellInfo_p = PNULL;
    UInt32 tlvType = 0;
    ULUESCellContext *ulUeScellContext_p = PNULL;
    UInt8 tlvIndex = 0, scellIndex = 0;
#ifdef HD_FDD_CONFIG
    UInt8 isUeSwitchFromFDToHD = LTE_FALSE;
#endif
    /** SPR 12320 Fix : START **/
    /*SPR 16855 +-*/
    UInt32 count = 0;
    /*SPR 16855 +-*/
    /** SPR 12320 Fix : END **/
    scellIndex = ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[cellCount].sCellIndex;

    ulReconfigScellInfo_p = &(ulReconfigUeReq_p->caConfigUL.
            scellReconfigInfoUL[cellCount]);
    ulUeScellContext_p = ulUEContext_p->ulUeScellContext_p[scellIndex];

    if (ADD == ulReconfigScellInfo_p->operationType)
    {
        /* SPR 11541 Fix : Start */
        //return MAC_SUCCESS;
        /* SPR 11541 Fix : End */
    }
    else if (DELETE == ulReconfigScellInfo_p->operationType)
    {
        /** SPR 12320 Fix : START **/
        /*SPR 16855 Fix Start*/
        for (count = 0;count < MAX_NUM_MAPS;count++)
        {
            memCpy(&(ulReconfigUeResp_p->pucchNodesForCqi[count]),
                    &(ulUeScellContext_p->scellpucchConfigInfo.pucchNodesForCqi[count]),sizeof(pucchNodeForReport));
            memCpy(&(ulReconfigUeResp_p->pucchNodesForWbCqi[count]),
                    &(ulUeScellContext_p->scellpucchConfigInfo.pucchNodesForWbCqi[count]),sizeof(pucchNodeForReport));
            memCpy(&(ulReconfigUeResp_p->pucchNodesForRI[count]),
                    &(ulUeScellContext_p->scellpucchConfigInfo.pucchNodesForRI[count]),sizeof(pucchNodeForReport));
            memCpy(&(ulReconfigUeResp_p->pucchNodesForCqi2[count]),
                    &(ulUeScellContext_p->scellpucchConfigInfo.pucchNodesForCqi2[count]),sizeof(pucchNodeForReport));
            memCpy(&(ulReconfigUeResp_p->pucchNodesForWbCqi2[count]),
                    &(ulUeScellContext_p->scellpucchConfigInfo.pucchNodesForWbCqi2[count]),sizeof(pucchNodeForReport));
            memCpy(&(ulReconfigUeResp_p->pucchNodesForRI2[count]),
                    &(ulUeScellContext_p->scellpucchConfigInfo.pucchNodesForRI2[count]),sizeof(pucchNodeForReport));
        }
        /*SPR 16855 Fix End*/
        /* SPR 11541 Fix : Start */
        longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex =
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex;

        longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
            !longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex;
        /* SPR 11541 Fix : End */
        if(ulUeScellContext_p != PNULL)
        {
            freeMemPool(ulUeScellContext_p);
            /* + SPR 20759 */
            ulUEContext_p->ulUeScellContext_p[scellIndex] = PNULL;
            /* - SPR 20759 */
        }
        /** SPR 12320 Fix : END **/
        return MAC_SUCCESS;
    }
    /* SPR 11043 changes start */
    ulUeScellContext_p->internalCellIndex = ulReconfigScellInfo_p->internalCellIndex;
    /* SPR 11043 changes end */
    for (tlvIndex = 0; tlvIndex < ulReconfigScellInfo_p->
            ueULCAScellReconfigMsgTlvCount; tlvIndex++)
    {
        tlvType = ulReconfigScellInfo_p->ueULCAScellInfoReconfigTlvRecieved
            [tlvIndex];
        switch(tlvType)
        {
#ifdef HD_FDD_CONFIG
            case UL_RECONFIG_SCELL_RF_PARAMS:
            {
                if( (LTE_TRUE==ulReconfigScellInfo_p->rfParams) )
                {
                    /** if ue is being made HD from either earlier type HD or FD
                     ** UE is already added in global list via DL operation **/
                    if(LTE_FALSE == ulUeScellContext_p->isHDFddFlag)
                    {
                        isUeSwitchFromFDToHD = LTE_TRUE;
                    }
                }
                else if((LTE_TRUE==ulUeScellContext_p->isHDFddFlag) && 
                        (LTE_FALSE==ulReconfigScellInfo_p->rfParams))
                {
                    /** ue is being confirgured from HD to FD
                     ** UE is already deleted in global list via DL operation **/
                    ulUeScellContext_p->isHDFddFlag = LTE_FALSE;
                }
                break;
            }
#endif
            case UL_RECONFIG_SCELL_PUCCH_CONFIG_INFO:          
            {
                /* SPR 11541 Fix : Start */
                /* +- SPR 17777 */
                macProcessAndUpdateULReconfigPUCCHScellInfo(
#ifdef HD_FDD_CONFIG
                        ueIndex,
#endif
                        /* +- SPR 17777 */
                        ulReconfigScellInfo_p, ulUeScellContext_p,
                        ulReconfigUeResp_p,internalCellIndex);
                /* SPR 11541 Fix : End */
                break;
            }
            case UL_RECONFIG_SCELL_ACTIVATE_STATUS:
            {
                ulUeScellContext_p->isScellActivateStatus =
                    ulReconfigScellInfo_p->isScellActivateStatus;
                break;
            }
        }
    }
#ifdef HD_FDD_CONFIG
    if (isUeSwitchFromFDToHD == LTE_TRUE)
    {
        ulUeScellContext_p->isHDFddFlag = LTE_TRUE;
        hdFddCtxConfigReconfigUpdate(ulUEContext_p->ueIndex);
        /* SPR 11940 start*/        
        hdFddCtxReconfigUpdateReports(ulUEContext_p, internalCellIndex);
        /* SPR 11940 end*/        
    }
#endif
    return MAC_SUCCESS;
}

#ifdef FDD_CONFIG

void macProcessAndUpdateULReconfigScellInfo_dummy(UInt16 ueIndex,
        ULReconfigUeReq *ulReconfigUeReq_p, ULUEContext *ulUEContext_p,
        UInt8 cellCount,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex
        )
{

    /* +- SPR 17777 */
    macProcessAndUpdateULReconfigScellInfo(
#ifdef HD_FDD_CONFIG
            ueIndex,
#endif
            /* +- SPR 17777 */
            ulReconfigUeReq_p, ulUEContext_p,
            cellCount,
            ulReconfigUeResp_p,
            internalCellIndex
            );
}

#endif
/******************************************************************************
 * Function Name  : macProcessAndUpdateULReconfigPUCCHScellInfo 
 * Inputs         : ueIndex -  UE id
 *                  ulReconfigScellInfo_p - Pointer to UL Reconfig Scell Info structure
 *                  ulUeScellContext_p - Pointer to UL UE Scell Context
 *                  ulReconfigUeResp_p - Pointer to UL Reconfig UE Response
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None.
 * Description    : This function process and updates DL Reconfig RF Parameters
 * ****************************************************************************/
/* +- SPR 17777 */
STATIC void macProcessAndUpdateULReconfigPUCCHScellInfo(
#ifdef HD_FDD_CONFIG
        UInt16 ueIndex,
#endif
        /* +- SPR 17777 */
        ULSCELLReconfigInfo *ulReconfigScellInfo_p, 
        ULUESCellContext *ulUeScellContext_p,
        ULReconfigUeResp *ulReconfigUeResp_p,
        InternalCellIndex internalCellIndex) //This is the pcell of the UE
{
    RRCInfPUCCHConfigResInfo *rrcInfpucchConfigResInfo_p = 
        &ulReconfigUeResp_p->rrcInfpucchConfigResInfo;
    RRCInfPUCCHConfigReqInfo *rrcInfpucchConfigReqInfo_p = 
        &ulReconfigScellInfo_p->rrcInfpucchConfigReqInfoScell;
    ULCQIResInfo *ulCQIResInfo_p = &rrcInfpucchConfigResInfo_p->ulCqiResInfo;
    ULCQIReqInfo *ulCQIReqInfo_p = &rrcInfpucchConfigReqInfo_p->ulCqiReqInfo;
    PucchConfig *pucchConfig_p = &ulUeScellContext_p->scellpucchConfigInfo;

    rrcInfpucchConfigResInfo_p->switchActiveToPassiveFlag =
        rrcInfpucchConfigReqInfo_p->switchPassiveToActiveFlag;

    rrcInfpucchConfigResInfo_p->pucchConfigMsg =
        rrcInfpucchConfigReqInfo_p->pucchConfigMsg;
    /* SPR 11541 Fix : Start */
    //Cell params to be picked up from the scell
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[ulReconfigScellInfo_p->internalCellIndex]->cellParams_p;
    /* SPR 11541 Fix : End */

    /* CQI Configuration */
    if(rrcInfpucchConfigReqInfo_p->pucchConfigMsg & UL_RECONFIG_CQI_IND)
    {
        if(0 != rrcInfpucchConfigReqInfo_p->switchPassiveToActiveFlag ) 
        {
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex =
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap;

            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->passiveIndex =
                rrcInfpucchConfigReqInfo_p->activeIndexForPUCCHMap ^ 0x01;

        }
        rrcInfpucchConfigResInfo_p->ulReconfigCqiRiMsg = 
            ulCQIReqInfo_p->cqiPeriodicReqInfo.cqiRiReconfigMsg;

        ulCQIResInfo_p->cqiConfigMsg = ulCQIReqInfo_p->cqiConfigMsg;

        ulCQIResInfo_p->cqiPeriodicResInfo.cqiPeriodicMsg =
            ulCQIReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg;

        macPopulateScellCQIInfo(pucchConfig_p, 
                &rrcInfpucchConfigReqInfo_p->ulCqiReqInfo 
                , internalCellIndex
                );

        if(PERIODIC_FEEDBACK_SUBBAND == 
                pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType &&
                FREQUENCY_SELECTIVE_ON == cellParams_p->freqSelectiveSchDL)
        {
            macInitBandwidthScellPart(ulUeScellContext_p, internalCellIndex);   
        }   
    }
    /** HD FDD Changes **/
#ifdef HD_FDD_CONFIG
    if((LTE_TRUE==ulUeScellContext_p->isHDFddFlag))
    {
        /* if current map is NULL, means the reports are deleted 
         * checking only CQI map not RI as both are deleted at the same time */
        if (!(pucchConfig_p->pucchNodesForCqi[longPeriodicSRCQIPMIRIMapInfo_gp
                    [internalCellIndex]->activeIndex].pucchNodePtr))
        {
            /* Reset all the CQI/PMI/RI parameters in static map */
            HD_UE_RESET_REPORT_INFO(ueIndex, HD_UE_STATIC_MAP_CQI_PMI);
            HD_UE_RESET_REPORT_INFO(ueIndex, HD_UE_STATIC_MAP_RI);
        }
        else
        {
            /* Reconfig all the CQI/PMI/RI parameters in static map */
            updateHDFddSemiStaticMap(ueIndex, HD_UE_STATIC_MAP_CQI_PMI);
            updateHDFddSemiStaticMap(ueIndex, HD_UE_STATIC_MAP_RI);
        }
    }
#endif
}

/****************************************************************************
 * Function Name  : macValidateUeCategoryV1020
 * Inputs         : ueCategoryV1020
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This API takes ueCategory for CA to validate and returns the
 *                  result of validation to the calling function.
 *****************************************************************************/
 MacRetType macValidateUeCategoryV1020(UInt8 ueCategoryV1020,
        InternalCellIndex internalCellIndex
        )
{
    if ( (ueCategoryV1020 > MAC_MAX_UE_CATEGORY_V1020) ||
            (ueCategoryV1020 < MAC_MIN_UE_CATEGORY_V1020) )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ueCategoryV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value Received for UeCategory Info");
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}
/****************************************************************************
 * Function Name  : macParsePucchAnCsV1020
 * Inputs         : msg_pp - pointer to the input buffer
 *                  remainingTagLen - length of remaining of the API message 
 *                  received 
 *                  pucchAnCsListElement- position of  pucchAnCs element in
 *                  pucchAnCsList
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parses the input buffer and fills in the
 *                  structure needed by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType macParsePucchAnCsV1020 ( UInt8 **msgBuf_pp,
        UInt16 remainingTagLen,
        UInt8 pucchAnCsListElement,
        UeContextForDownlink *dlCreateReq_p,
        UeContextForUplink   *ulCreateReq_p,
        InternalCellIndex internalCellIndex
        )
{
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Entry ", __func__ );
    UInt8 *msg_p    = PNULL;

    MacRetType resp = MAC_SUCCESS;
    UInt8 pucchIndex = 0;
    UInt16 tagLen = 0;
    UInt16 tag = 0;
    UInt16 n1Pucch=0;
    msg_p = *msgBuf_pp;
    while (remainingTagLen > 0 )
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        remainingTagLen = remainingTagLen - tagLen;
        if (PUCCH_AN_CS_V1020 == tag )
        {
            if ( PUCCH_AN_CS_V1020_LEN != tagLen )
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlCreateReq_p->ueIndex,tagLen,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "PUCCH_AN_CS_V1020_INFO_INVALID_TAGLEN");
                return MAC_FAILURE;
            }
            n1Pucch = LTE_GET_U16BIT(msg_p);
            msg_p += U16BIT_LEN;
            resp = macValidateN1Pucch(n1Pucch,internalCellIndex);
            if (resp != MAC_SUCCESS)
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid value Received for n1Pucch = [0,2047]");
                return resp;
            }
            dlCreateReq_p->pucchFormatR10.n1Pucch
                [pucchAnCsListElement][pucchIndex] = n1Pucch;
            ulCreateReq_p->pucchFormatR10.n1Pucch
                [pucchAnCsListElement][pucchIndex] = n1Pucch;
            pucchIndex++;
        }
        else
        {
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid Tag Received for macParsePucchAnCsV1020");
            /* SPR 16029 fix start */
            return MAC_SYNTAX_ERROR_VAL;            
            /* SPR 16029 fix end */
        }
    }
    *msgBuf_pp = msg_p;
    LTE_MAC_UT_LOG(LOG_INFO, PARSE_UTIL,"[%s] Exit ", __func__ );
    return resp;
}

/****************************************************************************
 *  Function Name  : macValidateN1Pucch
 *  Inputs         : n1Pucch
 *                   internalCellIndex - cell Index used at mac
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE.
 *  Description    : This API takes n1Pucch to validate and returns the result
 *                   of validation to the calling function.
 * ****************************************************************************/
STATIC  MacRetType macValidateN1Pucch(UInt16 n1Pucch
        ,InternalCellIndex internalCellIndex
        )
{
    if ( n1Pucch > MAX_N1PUCCH_RESOURCE_VAL )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                n1Pucch,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value Received for n1Pucch");
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macParseScellDeactivationTimer
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 *                  dlReconfigUeReq_p - pointer to Downlink Reconfig UE request structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for MAC_FAILURE
 * Description    : This function is called on receiving SCELL_DEACTIVATION_TIMER_INFO
 *                  and returns the result of parsing to the calling function.
 * ****************************************************************************/                                        
STATIC  MacRetType macParseScellDeactivationTimer(UInt16 tagLen,
        UInt8 **msgBuf_pp,
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        /* + SPR 11631 Changes */
        ,DLReconfigUeReq *dlReconfigUeReq_p
        /* - SPR 11631 Changes */
        )
{
    UInt8 scellDeactivationTimer=0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;

    if ( tagLen != SCELL_DEACTIVATION_TIMER_INFO_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SCELL_DEACTIVATION_TIMER_INFO_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    scellDeactivationTimer = *msg_p++;
    if(MAC_SUCCESS!=(macValidateScellDeactivationTimer(scellDeactivationTimer, 
                    internalCellIndex)))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SCELL_DEACTIVATION_TIMER_INFO_PARSING_FAILED");
        return MAC_FAILURE;
    }
    /* + SPR 11631 Changes */
    if(PNULL != dlReconfigUeReq_p)
    {
        dlReconfigUeReq_p->caConfigDL.scellDeactivation.scellDeactivationTimer = 
            scellDeactivationTimer;
    }
    /* - SPR 11631 Changes */
    dlCreateReq_p->carrierAggrConfig.scellDeactivationTimer = 
        scellDeactivationTimer;
    ulCreateReq_p->carrierAggrConfig.scellDeactivationTimer = 
        scellDeactivationTimer;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macValidateScellDeactivationTimer
 * Inputs         : scellDeactivationTimer
 *                  internalCellIndex - cell Index used at mac
 * Outputs        : None
 *  Returns       : MAC_SUCCESS or reason for failure.
 *                  (possible values are rf2 = 20ms, rf4=40ms, rf8=80ms, 
 *                  rf16=160ms, rf32=320ms, rf64=640ms, rf128=1280ms)
 * Description    : This API takes scellDeactivationTimer to validate and
 *                  returns the result of validation to the calling function.
 * ****************************************************************************/                                        
STATIC  MacRetType macValidateScellDeactivationTimer(
        UInt8 scellDeactivationTimer
        ,InternalCellIndex internalCellIndex
        )
{
    UInt8 count=0;
    for (count =0;count < SCELL_DEACTIVATION_TIMER_VALUE_COUNT;count++)
    {
        if(scellDeactivationTimer == validScellDeactivationTimerValues_g[count])
            break;
    }
    if(count < SCELL_DEACTIVATION_TIMER_VALUE_COUNT )
    {
        return MAC_SUCCESS;
    }
    else
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                scellDeactivationTimer,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value Received for scellDeactivationTimer");
        return MAC_FAILURE;
    }
}

/****************************************************************************
 * Function Name  : macParseAndValidateScellInfo
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for MAC_FAILURE
 * Description    : This function is called on receiving SCELL_INFO and
 *                  returns the result of parsing of Scell Info to the 
 *                  calling function.
 * ****************************************************************************/
STATIC  MacRetType macParseAndValidateScellInfo(UInt16 tagLen,
        UInt8 **msgBuf_pp,
        UeContextForUplink *ulCreateReq_p,
        UeContextForDownlink *dlCreateReq_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if ( tagLen < MIN_SCELL_INFO_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SCELL_INFO_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    if (MAC_SUCCESS !=  macParseScellInfo(&msg_p,tagLen,
                dlCreateReq_p, ulCreateReq_p,internalCellIndex))
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SCELL_INFO_PARSING_FAILED");
        return MAC_FAILURE;
    }
    dlCreateReq_p->carrierAggrConfig.scellCount++;
    ulCreateReq_p->carrierAggrConfig.scellCount++;

    *msgBuf_pp = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macParseCALCBandwidthDistributionInfo
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - the cell index used at MAC
 *                  dlReconfigUeReq_p - pointer to Downlink Reconfig UE request structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for MAC_FAILURE
 * Description    : This function is called on receiving CA_LC_BANDWIDTH_DIST_INFO
 *                  and returns the result of parsing of Scell Info to the 
 *                  calling function.
 * ****************************************************************************/                                        
STATIC  MacRetType macParseCALCBandwidthDistributionInfo(UInt16 tagLen,
        UInt8 **msgBuf_pp,
        UeContextForDownlink *dlCreateReq_p
        ,InternalCellIndex internalCellIndex
        /* + SPR 11631 Changes */
        ,DLReconfigUeReq *dlReconfigUeReq_p
        /* - SPR 11631 Changes */
        )
{
    UInt8 *msg_p    = PNULL;
    MacRetType resp = MAC_SUCCESS;
    msg_p = *msgBuf_pp;
    UInt8 index = 0, sumBandwidth = 0, bandWidthDistribution[MAX_SERVCELL] = {0};
    if ( tagLen != CA_LC_BANDWIDTH_DIST_INFO_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_INAVLID_LEN_MSG_ID,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                DEFAULT_INT_VALUE, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid tagLen Received for macParseCALCBandwidthDistributionInfo");
        return MAC_FAILURE;
    }
    /* Fetching Bandwidth distribution info from TLV  for a Psell and 
       scell upto MAX_SERVCELL */
    for (index= PCELL_SERV_CELL_IX; index< MAX_SERVCELL; index++)
    {
        bandWidthDistribution[index] = *msg_p++;
        resp = macValidateCALCBandwidthDistribution
            (bandWidthDistribution[index]);
        if (resp != MAC_SUCCESS)
        {
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    tagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Invalid value for CA_LC_BANDWIDTH_DIST_INFO");
            return resp;
        }
        /* + SPR 11631 Changes */
        if(PNULL != dlReconfigUeReq_p)
        {
            dlReconfigUeReq_p->caConfigDL.dlBandWidthDistribution.bandWidthDistribution[index] =
                bandWidthDistribution[index];
        }
        /* - SPR 11631 Changes */
        dlCreateReq_p->carrierAggrConfig.bandWidthDistribution[index] = 
            bandWidthDistribution[index];
        dlCreateReq_p->carrierAggrConfig.isBandWidthTagPresent = LTE_TRUE;
        sumBandwidth += bandWidthDistribution[index];
    }
    if (MAX_CA_LC_BANDWIDTH_DIST_VAL != sumBandwidth)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                DEFAULT_INT_VALUE, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "bandWidthDistribution enteries does"
                "not make a sum of 100");
        return MAC_FAILURE;
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macValidateCALCBandwidthDistribution
 *  Inputs         : bandWidthDistribution
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or reason for failure.
 *  Description    : This API takes n1Pucch to validate and returns the result
 *                   of validation to the calling function.
 * ****************************************************************************/
STATIC  MacRetType macValidateCALCBandwidthDistribution(
        UInt8 bandWidthDistribution)
{
    if (bandWidthDistribution > MAX_CA_LC_BANDWIDTH_DIST_VAL)
    {
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellInfo
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                 : tagLen - tag length  of the SCELL_INFO API message received
 *                   dlCreateReq_p - pointer to Downlink create UE structure
 *                   ulCreateReq_p - pointer to Uplink create UE structure
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for SCELL_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UeContextForDownlink *dlCreateReq_p,
        UeContextForUplink   *ulCreateReq_p,
        InternalCellIndex internalCellIndex
        ) 
{
    UInt8 cellIndex=0,scellIndex=0,operationType=0,scellCount = 0;
    InternalCellIndex intSCellIndex = INVALID_CELL_INDEX;
    UInt16  remainingTagLen = 0;
    MacRetType resp = MAC_SUCCESS;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    remainingTagLen = tagLen;
    scellCount = dlCreateReq_p->carrierAggrConfig.scellCount;
    if(scellCount > 0)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Currently one Scell is supported");
        return MAC_FAILURE;
    }
    ScellInfo *dlScellInfo_p = &dlCreateReq_p->carrierAggrConfig.
        scellInfo[scellCount];
    ScellInfo *ulScellInfo_p = &ulCreateReq_p->carrierAggrConfig.
        scellInfo[scellCount];
    cellIndex = *msg_p++;
    intSCellIndex =  macCommonGetInternalCellIndex(cellIndex);
    /*KLOCWORK_FIX_START_47*/
    if (MAX_INTERNAL_CELL_INDEX < intSCellIndex)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "SCELL_NOT_EXISTS Invalid value for cellIndex");
        return MAC_FAILURE;
    }
    /*KLOCWORK_FIX_END_47*/
    dlScellInfo_p->internalCellIndex = intSCellIndex;
    ulScellInfo_p->internalCellIndex = intSCellIndex;

    if(!(CELL_PHY_RUNNING == 
                cellSpecificParams_g.cellConfigAndInitParams_p
                [dlScellInfo_p->internalCellIndex]->cellState))
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "SCELL_NOT_RUNNING");
        return MAC_FAILURE;
    }

    scellIndex = *msg_p++;
    if(scellIndex < MIN_SCELL_INDEX || scellIndex > MAX_SCELL_INDEX)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for scellIndex");
        return MAC_FAILURE;

    }
    dlScellInfo_p->sCellIndex = scellIndex;
    ulScellInfo_p->sCellIndex = scellIndex;
    operationType= *msg_p++;
    if(OPERATION_TYPE_ADD != operationType)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid value for operationType");
        return MAC_FAILURE;

    }
    dlScellInfo_p->operationType = operationType;
    ulScellInfo_p->operationType = operationType;
    remainingTagLen = remainingTagLen - MIN_SCELL_INFO_TAG_LEN; 
    /* Cyclomatic Complexity changes start */
    resp = macParseScellInfoTag(remainingTagLen,&msg_p,
            internalCellIndex,
            dlCreateReq_p,ulCreateReq_p);
    /* Cyclomatic Complexity changes end */
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseScellInfoTag
 *  Inputs         : remainingTagLen - tag length  of the SCELL_INFO API message  received
 *                 : msgBuf_pp - pointer to the input buffer
 *                 : internalCellIndex - the cell index used at MAC
 *                   ulCreateReq_p
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for SCELL_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellInfoTag(UInt16 remainingTagLen,
        UInt8 **msgBuf_pp,
        InternalCellIndex internalCellIndex,
        UeContextForDownlink *dlCreateReq_p,
        UeContextForUplink   *ulCreateReq_p
        ) 
{
    MacRetType resp = MAC_SUCCESS;
    UInt16 tagLen, tag = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    UInt8 scellCount = dlCreateReq_p->carrierAggrConfig.scellCount;
    ScellInfo *dlScellInfo_p = &dlCreateReq_p->carrierAggrConfig.
        scellInfo[scellCount];
    ScellInfo *ulScellInfo_p = &ulCreateReq_p->carrierAggrConfig.
        scellInfo[scellCount];
    while ( remainingTagLen > 0 && (MAC_SUCCESS == resp))
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        remainingTagLen = remainingTagLen - tagLen;
        switch( tag )
        {
            case MIMO_CAPABILITY_DL_V1020 :
            {
                resp = macParseScellMimoCapabilityV1020(&msg_p,tagLen,
                        dlScellInfo_p,internalCellIndex);
                break;
            }
            case TX_MODE_INFO :
            {
                resp = macParseScellTxModeInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p, internalCellIndex);
                break;
            }
            case CODEBOOK_SUBSET_RESTRICTION_V1020 :
            {
                resp = macParseScellCodeBookSubsetRestV1020(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p, internalCellIndex);
                break;
            }
            case PDSCH_CONFIG_INFO :
            {
                resp = macParseScellPDSCHConfigInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p, internalCellIndex);
                break;
            }
            case CQI_INFO :
            {
                resp = macParseCACreateUECqiInfo(&msg_p,tagLen,scellCount,
                        dlCreateReq_p, ulCreateReq_p,internalCellIndex);
                if (resp != MAC_SUCCESS)
                {
                    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            tagLen,
                            internalCellIndex, 
                            __LINE__, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_INT_VALUE, 
                            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME, 
                            "Parsing CQI_INFO failed");
                }

                break;
            }
            case DL_NUM_HARQ_PROC :
            {
                resp = macParseScellDLHarqProc(&msg_p,tagLen,
                        dlScellInfo_p);
                break;
            }
            case DL_INIT_MCS :
            {
                resp = macParseScellDLInitMCS(&msg_p,tagLen,
                        dlScellInfo_p);
                break;
            }
            case NUM_OF_LAYER_INFO :
            {
                /* +- SPR 17777 */
                resp = macParseScellNumOfLayerInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p);
                /* +- SPR 17777 */
                break;
            }
            case CODEBOOK_INDEX_INFO :
            {
                /* +- SPR 17777 */
                resp = macParseScellCodebookIndexInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p);
                /* +- SPR 17777 */
                break;
            }
            case USER_LOCATION_TYPE :
            {
                resp = macParseScellUserLocationType(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p);
                break;
            }
            case RF_PARAMS :
            {
                resp = macParseScellRFParams(&msg_p,tagLen,
                        /* +- SPR 17777 */
#ifdef HD_FDD_CONFIG
                        dlScellInfo_p, ulScellInfo_p,
#endif
                        internalCellIndex,
                        /* +- SPR 17777 */
                        dlCreateReq_p->ueIndex);
                break;
            }
            case SCELL_ACTIVATE_STATUS :
            {/*spr 11041 fix start*/
                /* +- SPR 17777 */
                resp = macParseScellActivationStatus(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p, internalCellIndex);
                /* +- SPR 17777 */
                break;/*spr 11041 fix end*/
            }
            default: 
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tagLen,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Invalid Tag Identifer Recieved in SCELL_INFO");
                resp = MAC_FAILURE;
            }
        }

        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseScellMimoCapabilityV1020
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for MIMO_CAPABILITY_DL_V1020
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellMimoCapabilityV1020(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        InternalCellIndex internalCellIndex
        ) 
{
    UInt8 numOfLayer = 0, loopCount = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if ( tagLen != MIMO_CAPABILITY_DL_V1020_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_INAVLID_LEN_MSG_ID,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                DEFAULT_INT_VALUE, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for MIMO_CAPABILITY_DL_V1020 info");
        return MAC_SYNTAX_ERROR_VAL;
    }
    numOfLayer = *msg_p++;
    for (loopCount =0 ;loopCount < NUM_OF_LAYERS_COUNT; loopCount++)
    {
        if(validnumOfLayerValues_g[loopCount] == numOfLayer)
            break;
    }
    if(loopCount == NUM_OF_LAYERS_COUNT)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid valu for numOfLayer");
        return MAC_FAILURE;
    }
    dlScellInfo_p->numOfLayer = numOfLayer;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellTxModeInfo
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellTxModeInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        InternalCellIndex internalCellIndex
        ) 
{
    /* Coverity 60453, 60452, 60491*/
    TransmissonMode transmissionMode = INVALID_TX_MODE;
    /* Coverity 60453, 60452, 60491*/
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (tagLen != TX_MODE_INFO_LEN)
    {
        LOG_MAC_MSG(OAM_RRC_INVALID_MSG_LEN_ID,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag LengthTX_MODE_INFO Info");
        return MAC_SYNTAX_ERROR_VAL;
    }    
    transmissionMode = (TransmissonMode)*msg_p++;
    if (MAC_SUCCESS != 
            validateTransmissionMode(transmissionMode
                , internalCellIndex
                ))
    {
        lteWarning("Invalid value for transmissionMode[%u] .\n",
                transmissionMode);
        return MAC_SYNTAX_ERROR_VAL;
    }
    dlScellInfo_p->transmissionMode = transmissionMode; 
    ulScellInfo_p->transmissionMode = transmissionMode; 
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macParseScellReconfigTXModeInfo 
 * Inputs         : msgBuf_pp - Pointer to the incoming message
 *                  len - Length of the API message
 *                  dlUEInfo_p - Ptr to a structure to be filled for Scell DL
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the TX Mode information and updates 
 *                  the DL structure for UE context reconfiguration at MAC.
 *****************************************************************************/
STATIC  MacRetType macParseScellReconfigTXModeInfo (UInt8 **msgBuf_pp, 
        UInt8                len,
        ScellInfo *dlUEInfo_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf_pp;

    if (len != TX_MODE_INFO_LEN)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Minimum length require not present for TX_MODE_INFO_LEN");
        return MAC_SYNTAX_ERROR_VAL;
    }    
    dlUEInfo_p->transmissionMode = (TransmissonMode)*msg_p;
    msg_p++;
    if (MAC_SUCCESS != 
            validateTransmissionMode(dlUEInfo_p->transmissionMode
                , internalCellIndex
                ))
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid transmissionMode");
        return MAC_SYNTAX_ERROR_VAL;
    }
    if((1 == dlUEInfo_p->transmissionMode) ||
            (2 == dlUEInfo_p->transmissionMode)||
            (7 == dlUEInfo_p->transmissionMode)) 
    {
        dlUEInfo_p->codebookSubsetRestrictionv1020.cbsrType = CBSR_INVALID;
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellCodeBookSubsetRestV1020
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CODEBOOK_SUBSET_RESTRICTION_V1020
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellCodeBookSubsetRestV1020(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 loopCount = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    codebookSubsetRestrictionType  CbsrType = CBSR_INVALID;
    if (tagLen != CODEBOOK_SUBSET_RESTRICTION_V1020_TAG_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid Tag Length %u for"
                "CODEBOOK_SUBSET_RESTRICTION_V1020  Info\n"
                ,tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }    
    CbsrType =  (codebookSubsetRestrictionType)*msg_p++;
    /*Coverity 60781 start*/
    if(CbsrType > CBSR_TYPE_MAX_VAL)
        /*Coverity 60781 end*/
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid value for CbsrType[%u] .\n",CbsrType);
        return MAC_SYNTAX_ERROR_VAL;

    }
    /* SPR 12053 Fix Start */
    if((3 == dlScellInfo_p->transmissionMode)||
            (4 == dlScellInfo_p->transmissionMode)||
            (5 == dlScellInfo_p->transmissionMode)||
            (6 == dlScellInfo_p->transmissionMode)||
            (8 == dlScellInfo_p->transmissionMode)
            /* SPR 12053 Fix End */
      )
    {
        dlScellInfo_p->codebookSubsetRestrictionv1020.cbsrType = CbsrType;
        ulScellInfo_p->codebookSubsetRestrictionv1020.cbsrType = CbsrType;

        for(loopCount =0;loopCount < MAX_CBSR_VALUE_COUNT;loopCount++)
        {
            dlScellInfo_p->codebookSubsetRestrictionv1020.cbsrValue[loopCount] = 
                *msg_p++;
            ulScellInfo_p->codebookSubsetRestrictionv1020.cbsrValue[loopCount] = 
                dlScellInfo_p->codebookSubsetRestrictionv1020.cbsrValue[loopCount];
        }
        /* +- SPR 17777 */
        if (( validateCBSR( (codebookSubsetRestrictionInfo*)&dlScellInfo_p->codebookSubsetRestrictionv1020, 
                        (UInt8) dlScellInfo_p->transmissionMode, 
                        /* +- SPR 17777 */
                        /* SPR 11543 Fix start */
                        dlScellInfo_p->internalCellIndex
                        /* SPR 11543 Fix end */
                        ) != MAC_SUCCESS))
        {
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlScellInfo_p->codebookSubsetRestrictionv1020.cbsrType,
                    internalCellIndex,
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Atleast one bit should be 1 in \
                    cbsrValue in MAC_CREATE_UE_ENTITY_REQ");
            return MAC_FAILURE;
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlScellInfo_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "codebookSubsetRestriction received for\
                TM other than 3,4,5,6 in MAC_CREATE_UE_ENTITY_REQ");
        return MAC_FAILURE;
    }

    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellPDSCHConfigInfo
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellPDSCHConfigInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        InternalCellIndex internalCellIndex
        ) 
{
    UInt8 pA = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if(tagLen != (PDSCH_CONFIG_INFO_PARAM_LENGTH + TAG_LEN))
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid Tag Length %u for PDSCH_CONFIG_INFO info\n",tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }
    pA = *msg_p++;
    if(MAX_PA_VALUE < pA)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE,PDSCH_CONFIG_INFO,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PDSCH_CONFIG_INFO.");
        return MAC_FAILURE;
    }
    dlScellInfo_p->isPAPresent = LTE_TRUE;
    ulScellInfo_p->isPAPresent = LTE_TRUE;
    dlScellInfo_p->pA = pA;
    ulScellInfo_p->pA = pA;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellDLHarqProc
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for dlNumHarqProcess 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellDLHarqProc(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p
        ) 
{
    UInt8 dlNumHarqProcess =0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (tagLen != DL_NUM_HARQ_PROC_TAG_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid Tag Length %u for DL_NUM_HARQ_PROC Info\n",tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }    
    dlNumHarqProcess = *msg_p++;
    /* CA TDD Changes Start */
#ifdef TDD_CONFIG
    if (dlNumHarqProcess > getMaxDLHarq(dlScellInfo_p->internalCellIndex) ||
            dlNumHarqProcess < MIN_DL_NUM_HARQ_PROC_VAL)
#elif FDD_CONFIG
        if ((dlNumHarqProcess < MIN_DL_NUM_HARQ_PROC_VAL) ||
                (dlNumHarqProcess > MAX_DL_NUM_HARQ_PROC_VAL))
#endif
            /* CA TDD Changes End */
        {
            LOG_MAC_ERROR(MAC_RRC_INF,"Invalid dlNumHarqProcess[%u]\n",dlNumHarqProcess);
            return MAC_SYNTAX_ERROR_VAL;
        }
    dlScellInfo_p->dlNumHarqProcess = dlNumHarqProcess;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellDLInitMCS
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellDLInitMCS(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p
        ) 
{
    UInt8 dlInitMCS = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (tagLen != DL_INIT_MCS_TAG_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid Tag Length %u for DL_INIT_MCS\n",tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }    
    dlInitMCS = *msg_p++;
    if (dlInitMCS > MAX_DL_INIT_MCS_VAL)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid dlInitMCS[%u]\n",dlInitMCS);
        return MAC_SYNTAX_ERROR_VAL;
    }
    dlScellInfo_p->dlInitMCS = dlInitMCS;

    /* Cyclomatic_complexity_changes_start */
    getModSchemeFromMcsIndex(dlScellInfo_p->dlInitMCS,
            &(dlScellInfo_p->modScheme));
    /* Cyclomatic_complexity_changes_end */

    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellNumOfLayerInfo
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info,
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   internalCellIndex - cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for NUM_OF_LAYER_INFO
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellNumOfLayerInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p
        /* +- SPR 17777 */
        ) 
{
    UInt8 rankIndicator = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (tagLen != NUM_OF_LAYER_INFO_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid Tag Length %u for NUM_OF_LAYER_INFO\n",tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }    

    rankIndicator = *msg_p++;

    if ((MIN_NUM_OF_LAYER > rankIndicator) || 
            (MAX_NUM_OF_LAYER_4x4 < rankIndicator))
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid rankIndicator : %u\n",rankIndicator);
        return MAC_SYNTAX_ERROR_VAL;
    }
    dlScellInfo_p->rankIndicator = rankIndicator;
    ulScellInfo_p->rankIndicator = rankIndicator;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellCodebookIndexInfo
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   internalCellIndex - cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CODEBOOK_INDEX_INFO
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellCodebookIndexInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p
        /* +- SPR 17777 */
        ) 
{
    UInt8 precodingIndex = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (tagLen != CODEBOOK_INDEX_INFO_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid tag length %u for CODEBOOK_INDEX_INFO\n",tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }    
    precodingIndex = *msg_p++;
    if (MAC_SUCCESS != 
            validatePrecodingIndex(precodingIndex, 
                /* SPR 11543 Fix start */
                dlScellInfo_p->internalCellIndex
                /* SPR 11543 Fix end */
                ))
    {
        return MAC_SYNTAX_ERROR_VAL;
    }
    dlScellInfo_p->precodingIndex = precodingIndex;
    ulScellInfo_p->precodingIndex = precodingIndex;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellUserLocationType
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for USER_LOCATION_TYPE
 *                   and fills in the structure needed by MAC to create a 
 *                   UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellUserLocationType(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p
        ) 
{
    UInt8 userLocationType = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if((tagLen - TAG_LEN) < USER_LOCATION_TYPE_LEN)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid tag length %u for USER_LOCATION_TYPE\n",tagLen);
        return MAC_SYNTAX_ERROR_VAL;
    }
    userLocationType = *msg_p++;
    if(userLocationType >= MAX_USER_LOCATION)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid userLocationType %u\n",userLocationType);
        return MAC_FAILURE;
    }
    dlScellInfo_p->userLocationType = userLocationType;
    ulScellInfo_p->userLocationType = userLocationType;
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellRFParams
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   internalCellIndex - cell index used at MAC
 *                   ueIndex - UE id
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellRFParams(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        /* +- SPR 17777 */
#ifdef HD_FDD_CONFIG
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
#endif
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex,
        UInt16 ueIndex
        ) 
{
#ifdef HD_FDD_CONFIG
    UInt8 hdFddFlag = 0;
#endif
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if(tagLen != RF_PARAMS_LEN)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,ueIndex,RF_PARAMS,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "RF_PARAMS_INVALID_LENGTH");
        return MAC_FAILURE;
    }
#ifdef HD_FDD_CONFIG
    hdFddFlag = *msg_p++;
    /* The flag should be either LTE_TRUE or LTE_FALSE */
    if((hdFddFlag!=LTE_TRUE) && (hdFddFlag!= LTE_FALSE))
    {
        LOG_MAC_MSG(MAC_HD_FDD_INVALID_FLAG,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),hdFddFlag,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "Invalid Flag received in Create UE");
        return MAC_FAILURE;
    }
    dlScellInfo_p->isHDFddFlag = hdFddFlag;
    ulScellInfo_p->isHDFddFlag = hdFddFlag;
#else
    msg_p++;
#endif
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellActivationStatus
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                   tagLen - length of tag
 *                   dlScellInfo_p - pointer to downlink Scell info
 *                   ulScellInfo_p - pointer to uplink Scell info
 *                   ueIndex - UE id
 *                   internalCellIndex - cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellActivationStatus(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        ScellInfo *dlScellInfo_p,
        ScellInfo *ulScellInfo_p,
        /* +- SPR 17777 */
        InternalCellIndex internalCellIndex
        ) 
{
    UInt8 isScellActivateStatus = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if(tagLen != SCELL_ACTIVATE_STATUS_LEN)
    {
        LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                LINE_NUMBER,DEFAULT_INT_VALUE, DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "SCELL_ACTIVATE_STATUS_INVALID_LENGTH");
        return MAC_FAILURE;
    }
    isScellActivateStatus = *msg_p++;
    /* The flag should be either LTE_TRUE or LTE_FALSE */
    if(!( (isScellActivateStatus==LTE_TRUE) || 
                (isScellActivateStatus == LTE_FALSE)) )
    {
        LOG_MAC_MSG(MAC_HD_FDD_INVALID_FLAG,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),isScellActivateStatus,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "Invalid Flag received in Create UE");
        return MAC_FAILURE;
    }
    dlScellInfo_p->isScellActivateStatus = isScellActivateStatus;
    ulScellInfo_p->isScellActivateStatus = isScellActivateStatus;

    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}
/****************************************************************************
 *  Function Name  : macParseCACreateUECqiInfo
 *  Inputs         : msgBuf_pp - message to input buffer
 *                   tagLen - pointer to the length remaining of the API message received
 *                   scellCount-SCELL number for which data is going to be parsed
 *                   ulLCCreateReq_p - pointer to uplink create LC structure
 *                   dlLCCreateReq_p - pointer to downlink create LC structure
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to 
 *                   create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCACreateUECqiInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UInt8  scellCount,
        UeContextForDownlink *dlLCCreateReq_p,
        UeContextForUplink   *ulLCCreateReq_p,
        InternalCellIndex internalCellIndex
        ) 
{
    UInt8 aperiodicCQIEnabled=0,periodicCQIEnabled=0;
    UInt8 tag = 0, transmissionMode = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    CqiInfo *cqiInfoUl_p=NULL,*cqiInfoDl_p=NULL;
    cqiInfoUl_p = &ulLCCreateReq_p->carrierAggrConfig.
        scellInfo[scellCount].cqiInfo;	
    cqiInfoDl_p = &dlLCCreateReq_p->carrierAggrConfig.
        scellInfo[scellCount].cqiInfo;	
    if ( tagLen > SCELL_CQI_MAX_LEN || tagLen < SCELL_CQI_MIN_LEN )

    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulLCCreateReq_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_INFO_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    /*tagLen +4*/
    tag = LTE_GET_U16BIT(msg_p);
    cqiInfoUl_p->cqiInfoFlag = LTE_TRUE;
    cqiInfoDl_p->cqiInfoFlag = LTE_TRUE;

    if ( CQI_APERIODIC_INFO == tag )
    {
        aperiodicCQIEnabled = LTE_TRUE;
        transmissionMode =  dlLCCreateReq_p->carrierAggrConfig.scellInfo[scellCount].
            transmissionMode;
        resp = macParseCAUECqiAperiodicInfo(&msg_p,cqiInfoDl_p,cqiInfoUl_p,
                transmissionMode,
                /* SPR 11543 Fix start */
                dlLCCreateReq_p->carrierAggrConfig.scellInfo[scellCount].internalCellIndex
                /* SPR 11543 Fix end */

                );
        if ( resp != MAC_SUCCESS )
        {
            return resp;
        }
        tag = LTE_GET_U16BIT(msg_p);
        /* if Periodic CQI Info is present */
    }/* if ( CQI_PERIODIC_INFO == tag )*/
    if ( CQI_PERIODIC_INFO == tag )
    {
        periodicCQIEnabled = LTE_TRUE;
        transmissionMode =  dlLCCreateReq_p->carrierAggrConfig.scellInfo[scellCount].
            transmissionMode;
        resp = macParseCAUECqiPeriodicInfo(&msg_p,cqiInfoDl_p,cqiInfoUl_p,
                transmissionMode, 
                /* SPR 11543 Fix start */
                dlLCCreateReq_p->carrierAggrConfig.scellInfo[scellCount].internalCellIndex
                /* SPR 11543 Fix end */
                );
        if ( resp != MAC_SUCCESS )
        {
            return resp;
        }
        tag = LTE_GET_U16BIT(msg_p);
    }/*if ( CQI_PERIODIC_INFO == tag )*/

    if ( (periodicCQIEnabled == LTE_TRUE) && (aperiodicCQIEnabled == LTE_TRUE) )
    {
        cqiInfoDl_p->cqiIndication = PERIODIC_APERIODIC_MODE;
    }
    else if (periodicCQIEnabled == LTE_TRUE)
    {
        cqiInfoDl_p->cqiIndication = PERIODIC_CQI_REPORTING_MODE;
    }
    else if  (aperiodicCQIEnabled == LTE_TRUE)
    {
        cqiInfoDl_p->cqiIndication = APERIODIC_CQI_REPORTING_MODE;
    }
    /* - CQI_4.1 */
    if (CQI_REPORT_CONFIG_V920 == tag)
    {
        UInt16 cqiTagLenV920 = 0;
        /* skip CQI_REPORT_CONFIG_V920 tag */
        msg_p += U16BIT_LEN;

        /* cqi report v920 tag length*/
        cqiTagLenV920 = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;

        if ( CQI_REPORT_V920_LEN > cqiTagLenV920 )
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulLCCreateReq_p->ueIdx,cqiTagLenV920,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                    DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                    "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
            return MAC_FAILURE;
        }
        /*tagLen +4  */
        tag = LTE_GET_U16BIT(msg_p);
        if (CQI_MASK_V920 == tag)
        {
            /* skip CQI_MASK_V920 tag */
            msg_p += U16BIT_LEN;
            //Skip the tag length
            msg_p += U16BIT_LEN;
            cqiInfoUl_p->cqiMaskV920 = *msg_p++;
            /** SPR 14459 Changes Start **/ 
            if (cqiInfoUl_p->cqiMaskV920 != LTE_FALSE)
                /** SPR 14459 Changes End **/ 
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulLCCreateReq_p->ueIdx,
                        cqiInfoUl_p->cqiMaskV920,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "CQI_MASK_V920_INVALID_VALUE");
                return MAC_FAILURE;
            }
            /** SPR 14459 Changes Start **/ 
            /* if cqiMaskV920 TAG is present and cqiMaskV920 value is 0
             * then cqi mask should be set to TRUE */
            cqiInfoUl_p->cqiMaskV920 = TRUE;
            /** SPR 14459 Changes End **/ 
            tag = LTE_GET_U16BIT(msg_p);
            /*tagLen +5  */
        }
        if (PMI_RI_REPORT_V920 == tag)
        {
            /* skip PMI_RI_REPORT_V920 tag */
            msg_p += U16BIT_LEN;
            //Skip the tag length
            msg_p += U16BIT_LEN;
            cqiInfoUl_p->pmiRiReportV920 = *msg_p++;
            if (cqiInfoUl_p->pmiRiReportV920 != LTE_TRUE &&
                    cqiInfoUl_p->pmiRiReportV920 != LTE_FALSE )
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulLCCreateReq_p->ueIdx,
                        cqiInfoUl_p->pmiRiReportV920,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "PMI_RI_REPORT_V920_INVALID_VALUE");
                return MAC_FAILURE;
            }
            cqiInfoDl_p->pmiRiReportV920 = 
                cqiInfoUl_p->pmiRiReportV920;
            /*tagLen +5 */
        }


    }
    *msgBuf_pp = msg_p;
    return resp;
}/*macParseCACreateUECqiInfo*/

/****************************************************************************
 * Function Name  : macValidateCsiTriggerR10
 * Inputs         : trigger1r10, trigger2r10
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes trigger1r10, trigger2r10  to validate and 
 *                  returns the result of validation to the calling function.
 * ****************************************************************************/
STATIC  MacRetType macValidateCsiTriggerR10 ( UInt8 trigger1r10, UInt8 trigger2r10)
{
    /* SPR 12482 Fix start */
    /* Note- Validation of aperiodic csi triggers are commented as of now since
     * the possible values of these triggers are as follows
     * 1- Aperiodic CSI configured on both Pcell and Scell-
     *    trigger1r10 = 64  trigger2r10 = 192
     * 2- Aperiodic CSI configured on Pcell , Periodic CSI configured on Scell
     *    trigger1r10 = 0  trigger2r10 = 128
     * 3- Periodic CSI configured on  Pcell , Aperiodic CSI configured on Scell
     *    trigger1r10 = 64 trigger2r10 = 64 */
    /* if ( trigger1r10 != TRIGGER1R10_VAL )
       {
       lteWarning("Invalid value for trigger1r10 .\n");
       return MAC_FAILURE;
       }
       if ( trigger2r10 != TRIGGER2R10_VAL )
       {
       lteWarning("Invalid value for triggerr2r10 .\n");
       return MAC_FAILURE;
       } */
    /* SPR 12482 Fix end */
    /* +- SPR 17777 */
    LTE_GCC_UNUSED_PARAM(trigger1r10)
        LTE_GCC_UNUSED_PARAM(trigger2r10)
        return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macValidateScellRel
 * Inputs         : scellRelFlag
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes scellRelFlag to validate and returns the result
 *                  of validation to the calling function.
 ****************************************************************************/
STATIC  MacRetType macValidateScellRel(UInt8 scellRelFlag)
{
    if (! ((LTE_TRUE == scellRelFlag)  || (LTE_FALSE == scellRelFlag)) )
    {
        lteWarning("Invalid range for scellRelFlag\n");
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macParseReconfigUECategoryV1020Info 
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlUEInfo_p - pointer to Downlink reconfig UE structure
 *                  ulUEInfo_p - pointer to Uplink reconfig UE structure
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                  ulReconfigUeReq_p - pointer to Uplink reconfig UE structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the UE Category information for CA in 
 *                  Reconfig UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType macParseReconfigUECategoryV1020Info( UInt8 **msgBuf_pp, 
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        )
{
    MacRetType resp = MAC_SUCCESS;

    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->
        ueReconfigMsgTlvCount]= DL_RECONFIG_UE_CATEGORY_V1020;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    /* + SPR 14900 Changes */
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->
        ueReconfigMsgTlvCount]=UL_RECONFIG_UE_CATEGORY_V1020;
    /* - SPR 14900 Changes */
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

    if ( UE_CATEGORY_TAG_LEN != tagLen )
    {  
        lteWarning("Invalid Tag Length %d for UE_CATEGORY_V1020  Info\n"
                ,tagLen);
        return MAC_FAILURE;
    }
    dlUEInfo_p->ueCategoryV1020 = *(*msgBuf_pp)++;
    ulUEInfo_p->ueCategoryV1020 = dlUEInfo_p->ueCategoryV1020;
    resp = macValidateUeCategoryV1020(dlUEInfo_p->ueCategoryV1020,internalCellIndex );
    if (resp != MAC_SUCCESS)
    {
        return resp;
    }
    dlUEInfo_p->ueCategoryV1020ReqType = LTE_TRUE;
    ulUEInfo_p->ueCategoryV1020ReqType = LTE_TRUE;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macParseReconfigPUCCHFormatV1020Info 
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlUEInfo_p - pointer to Downklink reconfig UE structure
 *                  ulUEInfo_p - pointer to Uplink reconfig UE structure
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                  ulReconfigUeReq_p - pointer to Uplink reconfig UE structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the PUCCHFormatV1020 information for CA in 
 *                  Reconfig UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType macParseReconfigPUCCHFormatV1020Info( UInt8 **msgBuf_pp, 
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        )
{
    UInt8 *msg_p    = PNULL;
    MacRetType retval = MAC_SUCCESS;
    UInt16 tag=0;

    msg_p = *msgBuf_pp;
    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_PUCCH_CONFIG_INFO_V1020;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    /* + SPR 14900 Changes */
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->
        ueReconfigMsgTlvCount]=UL_RECONFIG_PUCCH_CONFIG_INFO_V1020;
    /* - SPR 14900 Changes */
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

    UInt8 pucchAnCsListElement=0;
    UInt16 pucchFormatTagLength=0;
    UInt8 requestType=0;
    if ( tagLen < PUCCH_FORMAT_V1020_MIN_LEN )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "PUCCH_FORMAT_V1020_INFO_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    if (PUCCH_CHANNEL_SELECTION_CONFIG_V1020 == tag )
    {
        pucchFormatTagLength = tagLen - TAG_LEN;
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        if ( tagLen < PUCCH_CHANNEL_SELECTION_CONFIG_V1020_MIN_LEN )
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulUEInfo_p->ueIdx,tagLen,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,
                    "PUCCH_CHANNEL_SELECTION_CONFIG_V1020_INFO_INVALID_TAGLEN");
            return MAC_FAILURE;
        }
        msg_p += U16BIT_LEN;
        requestType = *msg_p++;
        dlUEInfo_p->pucchFormatR10.requestType = requestType;
        if(PUCCH_CHANNEL_SELECTION_CONFIG_V1020_SETUP == requestType)
        {
            pucchFormatTagLength = pucchFormatTagLength - 
                PUCCH_CHANNEL_SELECTION_CONFIG_V1020_MIN_LEN;
            while ( pucchFormatTagLength > 0)
            {
                tag = LTE_GET_U16BIT(msg_p);
                if (PUCCH_AN_CS_LIST_V1020 == tag )
                {
                    tag = LTE_GET_U16BIT(msg_p);
                    msg_p += U16BIT_LEN;
                    tagLen = LTE_GET_U16BIT(msg_p);
                    msg_p += U16BIT_LEN;
                    pucchFormatTagLength = pucchFormatTagLength - tagLen;
                    if ( tagLen < PUCCH_AN_CS_LIST_V1020_MIN_LEN )
                    {
                        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                                ulUEInfo_p->ueIdx,tagLen,
                                internalCellIndex,
                                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                                DEFAULT_FLOAT_VALUE,
                                DEFAULT_FLOAT_VALUE,
                                FUNCTION_NAME,
                                "PUCCH_AN_CS_LIST_V1020"
                                "_INFO_INVALID_TAGLEN");
                        return MAC_FAILURE;
                    }
                    tagLen = tagLen - PUCCH_AN_CS_LIST_V1020_MIN_LEN;
                    retval = macParsePucchAnCsV1020(&msg_p,tagLen,
                            pucchAnCsListElement,dlUEInfo_p, 
                            ulUEInfo_p
                            ,internalCellIndex);
                    if ( retval != MAC_SUCCESS )
                    {
                        lteWarning("Parsing PUCCH_FORMAT_V1020 failed.\n");
                        return MAC_FAILURE;
                    }
                    pucchAnCsListElement++;
                }
                else
                {
                    retval = MAC_SYNTAX_ERROR_VAL;
                    return retval;
                }
            }
        }
        else
        {
            if(PUCCH_CHANNEL_SELECTION_CONFIG_V1020_RELEASE != requestType)
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->ueIdx,tagLen,
                        internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "PUCCH_AN_CS_LIST_V1020"
                        "_INFO_INVALID_REQUEST_TYPE");
                return MAC_FAILURE;
            }
        }

    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : macParseReconfigCAConfigInfo
 * Inputs         : msgBuf_pp - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlUEInfo_p - pointer to Downlink reconfig UE Context structure
 *                  ulUEInfo_p - pointer to Uplink reconfig UE Context structure
 *                  internalCellIndex - cell index used at MAC
 *                  dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                  ulReconfigUeReq_p - pointer to Uplink reconfig UE structure
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the CA config information for CA in 
 *                  Reconfig UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType macParseReconfigCAConfigInfo( UInt8 **msgBuf_pp, 
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        )
{
    UInt8 *msg_p    = PNULL;
    MacRetType resp = MAC_SUCCESS;

    UInt16 tag=0;

    msg_p = *msgBuf_pp;

    dlReconfigUeReq_p->ueReconfigTlvRecieved[dlReconfigUeReq_p->ueReconfigMsgTlvCount]=
        DL_RECONFIG_CA_CONFIG_INFO;
    dlReconfigUeReq_p->ueReconfigMsgTlvCount++;

    /** SPR 14282 : #ifdef FDD removed **/	
    ulReconfigUeReq_p->ueReconfigTlvRecieved[ulReconfigUeReq_p->
        ueReconfigMsgTlvCount]=UL_RECONFIG_CA_CONFIG_INFO;
    ulReconfigUeReq_p->ueReconfigMsgTlvCount++;

    UInt16 caConfigTagLength=0;
    if ( tagLen < MIN_CA_CONFIG_TAG_LEN )
    {
        lteWarning("Invalid Tag Length %d for  CA_CONFIG  Info\n"
                ,tagLen);
        return MAC_FAILURE;
    }
    caConfigTagLength = tagLen;
    caConfigTagLength = caConfigTagLength - MIN_CA_CONFIG_TAG_LEN;
    while (caConfigTagLength > 0)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        caConfigTagLength = caConfigTagLength - tagLen;
        switch( tag )
        {
            case SCELL_DEACTIVATION_TIMER_INFO :
            {
                dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigTlvRecieved
                    [dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigMsgTlvCount]=
                    DL_RECONFIG_CA_CONFIG_SCELL_DEACTIVATION_TIMER;
                dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigMsgTlvCount++;

                ulReconfigUeReq_p->caConfigUL.ueULCAReconfigTlvRecieved
                    [ulReconfigUeReq_p->caConfigUL.ueULCAReconfigMsgTlvCount]=
                    UL_RECONFIG_CA_CONFIG_SCELL_DEACTIVATION_TIMER;
                ulReconfigUeReq_p->caConfigUL.ueULCAReconfigMsgTlvCount++;

                /* + SPR 11631 Changes */
                resp = macParseScellDeactivationTimer(tagLen,&msg_p,
                        ulUEInfo_p, dlUEInfo_p, internalCellIndex, dlReconfigUeReq_p);
                /* - SPR 11631 Changes */
                if ( resp != MAC_SUCCESS )
                {
                    return MAC_FAILURE;
                }
                break;
            }
            case SCELL_INFO :
            {
                dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigTlvRecieved
                    [dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigMsgTlvCount]=
                    DL_RECONFIG_CA_CONFIG_SCELL_INFO;
                dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigMsgTlvCount++;

                ulReconfigUeReq_p->caConfigUL.ueULCAReconfigTlvRecieved
                    [ulReconfigUeReq_p->caConfigUL.ueULCAReconfigMsgTlvCount]=
                    UL_RECONFIG_CA_CONFIG_SCELL_INFO;
                ulReconfigUeReq_p->caConfigUL.ueULCAReconfigMsgTlvCount++;

                if ( tagLen < MIN_SCELL_INFO_TAG_LEN )
                {
                    lteWarning("Invalid Tag Length %d for"
                            "SCELL_INFO_TAG_LEN  Info\n"
                            ,tagLen);
                    return MAC_FAILURE;
                }
                resp = macParseScellReconfigInfo(&msg_p,tagLen,
                        dlUEInfo_p, ulUEInfo_p, internalCellIndex
                        ,dlReconfigUeReq_p
                        ,ulReconfigUeReq_p
                        );
                if (resp != MAC_SUCCESS)
                {
                    lteWarning("Parsing SCELL_INFO failed.\n");
                    return resp;
                }
                dlUEInfo_p->carrierAggrConfig.scellCount++;
                ulUEInfo_p->carrierAggrConfig.scellCount++;
                break;
            }
            case CA_LC_BANDWIDTH_DIST_INFO:
            {
                dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigTlvRecieved
                    [dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigMsgTlvCount]=
                    DL_RECONFIG_CA_LC_BANDWIDTH_DIST_INFO;
                dlReconfigUeReq_p->caConfigDL.ueDLCAReconfigMsgTlvCount++;

                /* + SPR 11631 Changes */
                resp = macParseCALCBandwidthDistributionInfo(tagLen,&msg_p,
                        dlUEInfo_p, internalCellIndex, dlReconfigUeReq_p);
                /* - SPR 11631 Changes */
                if ( resp != MAC_SUCCESS )
                {
                    return MAC_FAILURE;
                }
                break;
            }
            default: 
            {
                lteWarning("Invalid Tag [%d] Identifer Recieved in CA CONFIG",tag);
                return MAC_FAILURE;
            }
        }
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseScellReconfigInfo
 *  Inputs         : msgBuf_pp - pointer to the input buffer
 *                 : tagLen - tag length  of the SCELL_INFO API message received
 *                   dlUEInfo_p - pointer to downlink reconfig UE Context structure
 *                   ulUEInfo_p - pointer to uplink reconfig UE Context structure
 *                   internalCellIndex - the cell index used at MAC
 *                   dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                   ulReconfigUeReq_p - pointer to Uplink reconfig UE structure
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for SCELL_INFO 
 *                   and fills in the structure needed by MAC to Reconfig a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellReconfigInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        ) 
{
    UInt8 cellIndex = 0, scellIndex=0,operationType=0,scellCount=0;
    InternalCellIndex intSCellIndex = INVALID_CELL_INDEX;
    /*KLOCKWORK_CHANGES_START_107*/
    UInt16  remainingTagLen = tagLen;
    /*KLOCKWORK_CHANGES_STOP_107*/
    MacRetType resp = MAC_SUCCESS;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    scellCount = dlUEInfo_p->carrierAggrConfig.scellCount; 
    cellIndex = *msg_p++;

    intSCellIndex = macCommonGetInternalCellIndex(cellIndex);
    /*KLOCWORK_FIX_START_46*/
    if (MAX_INTERNAL_CELL_INDEX < intSCellIndex)
    {
        lteWarning("SCELL_NOT_EXISTS\nInvalid value for cellIndex [%u], valid "
                "range [%u,%u] .\n",
                cellIndex,MIN_SCELL_ID,MAX_SCELL_ID);
        return MAC_FAILURE;
    }
    /*KLOCWORK_FIX_END_46*/
    scellIndex = *msg_p++;
    if(scellIndex < MIN_SCELL_INDEX || scellIndex > MAX_SCELL_INDEX)
    {
        lteWarning("Invalid value for scellIndex [%u], valid range [%u,%u] .\n",
                scellIndex,MIN_SCELL_INDEX,MAX_SCELL_INDEX);
        return MAC_FAILURE;

    }
    operationType= *msg_p++;
    if(!((OPERATION_TYPE_ADD == operationType)
                || (OPERATION_TYPE_MODIFY == operationType)
                || (OPERATION_TYPE_DELETE == operationType)))
    {
        lteWarning("Invalid value for operationType [%u], valid values are  [%u,%u, %u] .\n",
                operationType,
                OPERATION_TYPE_ADD,
                OPERATION_TYPE_MODIFY,
                OPERATION_TYPE_DELETE);
        return MAC_FAILURE;

    }
    ScellInfo *dlScellInfo_p = &dlUEInfo_p->carrierAggrConfig.scellInfo
        [scellCount];
    ScellInfo *ulScellInfo_p = &ulUEInfo_p->carrierAggrConfig.scellInfo
        [scellCount];
    dlScellInfo_p->internalCellIndex = intSCellIndex;
    ulScellInfo_p->internalCellIndex = intSCellIndex;
    /* 
     * In case of DFS, scell delete and scell add TLVs are received in same ue_reconfigure message from RRC.
     * This scenario is not handled at MAC.
     * Also, scell_index will be same for the scell which will be deleted and scell which will be added. 
     * So to handle this scenario for DFS, operationType is being set as OPERATION_TYPE_MODIFY.
     * */
    dlScellInfo_p->sCellIndex = scellIndex;
    ulScellInfo_p->sCellIndex = scellIndex;
    dlScellInfo_p->operationType = operationType;
    ulScellInfo_p->operationType = operationType;
    remainingTagLen = remainingTagLen - MIN_SCELL_INFO_TAG_LEN; 

    /* + SPR 14900 Changes */
    /* + Coverity_72075_72076 Changes */
    dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[scellCount].internalCellIndex = dlScellInfo_p->internalCellIndex;
    dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[scellCount].sCellIndex = dlScellInfo_p->sCellIndex;
    dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[scellCount].operationType = dlScellInfo_p->operationType;

    ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].internalCellIndex = ulScellInfo_p->internalCellIndex;
    ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].sCellIndex = ulScellInfo_p->sCellIndex;
    ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].operationType = ulScellInfo_p->operationType;
    /* - Coverity_72075_72076 Changes */
    /* - SPR 14900 Changes */

    /* Cyclomatic Complexity changes start */
    resp = macParseScellReconfigInfoTag(remainingTagLen,&msg_p,
            internalCellIndex,
            dlUEInfo_p,ulUEInfo_p
            ,dlReconfigUeReq_p
            ,ulReconfigUeReq_p
            );
    /* Cyclomatic Complexity changes end */
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseScellReconfigInfoTag
 *  Inputs         : remainingTagLen - tag length  of the SCELL_RECONFIG_INFO API
 *                   message  received
 *                 : msgBuf_pp - pointer to the input buffer
 *                 : internalCellIndex - the cell index used at MAC
 *                   dlUEInfo_p - pointer to Downlink Reconfig
 *                   ulUEInfo_p - pointer to Uplink Reconfig 
 *                   dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                   ulReconfigUeReq_p - pointer to Uplink reconfig UE structure
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for SCELL_RECONFIG_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseScellReconfigInfoTag(UInt16 remainingTagLen,
        UInt8 **msgBuf_pp,
        InternalCellIndex internalCellIndex,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p
        ,DLReconfigUeReq *dlReconfigUeReq_p
        ,ULReconfigUeReq *ulReconfigUeReq_p
        ) 
{
    MacRetType resp = MAC_SUCCESS;
    UInt16 tagLen, tag = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    UInt8 scellCount = dlUEInfo_p->carrierAggrConfig.scellCount;
    ScellInfo *dlScellInfo_p = &dlUEInfo_p->carrierAggrConfig.scellInfo
        [scellCount];
    ScellInfo *ulScellInfo_p = &ulUEInfo_p->carrierAggrConfig.scellInfo
        [scellCount];
    UInt8 ueDLCAScellReconfigTlvCount = 0, ueULCAScellReconfigTlvCount = 0;
    DLSCELLReconfigUeTLVs *ueDLCAScellReconfigTlvReceived_p = PNULL;
    ULSCELLReconfigUeTLVs *ueULCAScellReconfigTlvReceived_p = PNULL;


    ueDLCAScellReconfigTlvCount =  dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[scellCount].
        ueDLCAScellReconfigMsgTlvCount;
    ueULCAScellReconfigTlvCount = ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].
        ueULCAScellReconfigMsgTlvCount;
    ueDLCAScellReconfigTlvReceived_p =  dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[scellCount].
        ueDLCAScellInfoReconfigTlvRecieved;
    ueULCAScellReconfigTlvReceived_p =  ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].
        ueULCAScellInfoReconfigTlvRecieved;

    while ( remainingTagLen > 0)
    {
        tag = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        tagLen = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;
        remainingTagLen = remainingTagLen - tagLen;
        switch( tag )
        {
            case MIMO_CAPABILITY_DL_V1020 :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_MIMO_CAPABILITY_V1020;
                ueDLCAScellReconfigTlvCount++;


                resp = macParseScellMimoCapabilityV1020(&msg_p,tagLen,
                        dlScellInfo_p,internalCellIndex);
                break;
            }
            case TX_MODE_INFO :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_TRANS_MODE_INFO;
                ueDLCAScellReconfigTlvCount++;

                resp = macParseScellReconfigTXModeInfo (&msg_p, tagLen,
                        dlScellInfo_p,internalCellIndex );
                /* Coverity 60233 */
                break;
                /* Coverity 60233 */
            }
            case CODEBOOK_SUBSET_RESTRICTION_V1020 :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_CODEBOOK_SUBSET_RESTRICTION_V1020;
                ueDLCAScellReconfigTlvCount++;

                resp = macParseScellCodeBookSubsetRestV1020(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p,internalCellIndex);
                break;
            }
            case PDSCH_CONFIG_INFO :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_PDSCH_CONFIG_INFO;
                ueDLCAScellReconfigTlvCount++;

                resp = macParseScellPDSCHConfigInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p, internalCellIndex);
                break;
            }
            case CQI_INFO :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_CQI_INFO;
                ueDLCAScellReconfigTlvCount++;

                resp = macParseCAReconfigUECqiInfo(&msg_p,tagLen,
                        dlUEInfo_p, ulUEInfo_p,internalCellIndex
                        /* +- SPR 17777 */
                        ,ulReconfigUeReq_p
                        );
                break;
            }
            case DL_NUM_HARQ_PROC :
            {
                resp = macParseScellDLHarqProc(&msg_p,tagLen,
                        dlScellInfo_p);
                break;
            }
            case DL_INIT_MCS :
            {
                resp = macParseScellDLInitMCS(&msg_p,tagLen,
                        dlScellInfo_p);
                break;
            }
            case NUM_OF_LAYER_INFO :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_NUM_OF_LAYER_INFO;
                ueDLCAScellReconfigTlvCount++;

                /* +- SPR 17777 */
                resp = macParseScellNumOfLayerInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p);
                /* +- SPR 17777 */
                break;
            }
            case CODEBOOK_INDEX_INFO :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_CODEBOOK_INDEX_INFO;
                ueDLCAScellReconfigTlvCount++;

                if (tagLen != CODEBOOK_INDEX_INFO_LEN)
                {
                    lteWarning(
                            "Invalid tag length %u "
                            "for CODEBOOK_INDEX_INFO\n",tagLen);
                    return MAC_SYNTAX_ERROR_VAL;
                }    
                /* +- SPR 17777 */
                resp = macParseScellCodebookIndexInfo(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p);
                /* +- SPR 17777 */
                break;
            }
            case USER_LOCATION_TYPE :
            {
                resp = macParseScellUserLocationType(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p);
                break;
            }
            case RF_PARAMS :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_RF_PARAMS;
                ueDLCAScellReconfigTlvCount++;

                *(ueULCAScellReconfigTlvReceived_p+ueULCAScellReconfigTlvCount) = 
                    UL_RECONFIG_SCELL_RF_PARAMS;
                ueULCAScellReconfigTlvCount++;

                resp = macParseScellRFParams(&msg_p,tagLen,
                        /* +- SPR 17777 */
#ifdef HD_FDD_CONFIG
                        dlScellInfo_p, ulScellInfo_p,
#endif
                        internalCellIndex,
                        /* +- SPR 17777 */
                        dlUEInfo_p->ueIndex);
                break;
            }
            case SCELL_ACTIVATE_STATUS :
            {
                *(ueDLCAScellReconfigTlvReceived_p+ueDLCAScellReconfigTlvCount) = 
                    DL_RECONFIG_SCELL_ACTIVATE_STATUS;
                ueDLCAScellReconfigTlvCount++;

                *(ueULCAScellReconfigTlvReceived_p+ueULCAScellReconfigTlvCount) = 
                    UL_RECONFIG_SCELL_ACTIVATE_STATUS;
                ueULCAScellReconfigTlvCount++;

                if(tagLen != SCELL_ACTIVATE_STATUS_LEN)
                {
                    LOG_MAC_MSG(MAC_TAG_PARSE_FAILURE_ID,LOGDEBUG,MAC_RRC_INF,
                            GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                            LINE_NUMBER,dlUEInfo_p->ueIndex,RF_PARAMS,
                            internalCellIndex,DEFAULT_INT_VALUE,
                            DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                            FUNCTION_NAME,
                            "SCELL_ACTIVATE_STATUS_INVALID_LENGTH");
                    return MAC_FAILURE;
                }/*spr 11041 fix start*/ 
                /* +- SPR 17777 */
                resp = macParseScellActivationStatus(&msg_p,tagLen,
                        dlScellInfo_p, ulScellInfo_p,internalCellIndex);
                /* +- SPR 17777 */
                break;/*spr 11041 fix end*/
            }
            default: 
            {
                lteWarning("Invalid Tag [%d] Identifer Recieved in SCELL_INFO",tag);
                resp =  MAC_FAILURE;
            }
        }
        if(resp != MAC_SUCCESS)
        {
            return resp;
        }
    }
    dlReconfigUeReq_p->caConfigDL.scellReconfigInfoDL[scellCount].
        ueDLCAScellReconfigMsgTlvCount = ueDLCAScellReconfigTlvCount;
    ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].
        ueULCAScellReconfigMsgTlvCount = ueULCAScellReconfigTlvCount;
    *msgBuf_pp = msg_p;
    return resp;
}
/****************************************************************************
 *  Function Name  : macParseCAReconfigUECqiInfo
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   tagLen - pointer to the length remaining of the API message received
 *                   dlUEInfo_p - pointer to Downlink Reconfig Cqi structure
 *                   ulUEInfo_p - pointer to Uplink Reconfig Cqi structure
 *                   internalCellIndex - the cell index used at MAC
 *                   dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                   ulReconfigUeReq_p - pointer to Uplink reconfig UE structure
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAReconfigUECqiInfo(UInt8 **msgBuf_pp,
        UInt16 tagLen,
        UeContextForDownlink *dlUEInfo_p,
        UeContextForUplink   *ulUEInfo_p,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        ,ULReconfigUeReq     *ulReconfigUeReq_p
        ) 
{
    UInt8 aperiodicCQIEnabled=0,periodicCQIEnabled=0;
    UInt8 tag = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    UInt8 scellCount = dlUEInfo_p->carrierAggrConfig.scellCount;
    UInt8 transmissionMode = dlUEInfo_p->carrierAggrConfig.scellInfo[scellCount].transmissionMode;

    MacRetType resp = MAC_SUCCESS;
    CqiInfo *cqiInfoUl_p=NULL,*cqiInfoDl_p=NULL;
    ULCQIReqInfo *ulCqiReqInfo_p = 
        &ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].rrcInfpucchConfigReqInfoScell.ulCqiReqInfo;
    ulCqiReqInfo_p->cqiConfigMsg = UL_RECONFIG_NO_CQI_MSG;
    ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = UL_RECONFIG_NO_CQI_SUBBAND_RI_MSG;

    cqiInfoUl_p = &ulUEInfo_p->carrierAggrConfig.scellInfo[scellCount].cqiInfo;	
    cqiInfoDl_p = &dlUEInfo_p->carrierAggrConfig.scellInfo[scellCount].cqiInfo;	
    if ( tagLen > SCELL_CQI_MAX_LEN || tagLen < SCELL_CQI_MIN_LEN )
    {
        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                ulUEInfo_p->ueIdx,tagLen,internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "CQI_INFO_INVALID_TAGLEN");
        return MAC_FAILURE;
    }
    /*tagLen +4*/
    tag = LTE_GET_U16BIT(msg_p);
    cqiInfoUl_p->cqiInfoFlag = LTE_TRUE;
    cqiInfoDl_p->cqiInfoFlag = LTE_TRUE;
    ulReconfigUeReq_p->caConfigUL.scellReconfigInfoUL[scellCount].rrcInfpucchConfigReqInfoScell.pucchConfigMsg = 
        (ULReconfigPucchMsgType) (ulReconfigUeReq_p->caConfigUL.
                scellReconfigInfoUL[scellCount].rrcInfpucchConfigReqInfoScell.pucchConfigMsg | UL_RECONFIG_CQI_IND); 
    /* SPR 12554 Fix Start */
    /* No need to proceed furthur because CQI INFO has been come for APERIODIC
     * CQI RELEASE only*/
    if(tagLen == 4)
    {

        *msgBuf_pp = msg_p;
        return MAC_SUCCESS;
    }
    /* SPR 12554 Fix End */
    if ( CQI_APERIODIC_INFO == tag )
    {
        aperiodicCQIEnabled = LTE_TRUE;
        resp = macParseCAReconfigUECqiAperiodicInfo(
                &msg_p,cqiInfoDl_p,cqiInfoUl_p,
                transmissionMode,
                /* SPR 11543 Fix start */
                /* +- SPR 17777 */
                dlUEInfo_p->carrierAggrConfig.scellInfo[scellCount].internalCellIndex
                /* SPR 11543 Fix end */
                /* +- SPR 17777 */
                ,ulCqiReqInfo_p
                );
        if ( resp != MAC_SUCCESS )
        {
            return resp;
        }
        tag = LTE_GET_U16BIT(msg_p);
        /* if Periodic CQI Info is present */
    }/* if ( CQI_APERIODIC_INFO == tag )*/
    if ( CQI_PERIODIC_INFO == tag )
    {
        periodicCQIEnabled = LTE_TRUE;
        resp = macParseCAReconfigUECqiPeriodicInfo(
                &msg_p,cqiInfoDl_p,cqiInfoUl_p,
                transmissionMode,
                /* SPR 11543 Fix start */
                dlUEInfo_p->carrierAggrConfig.scellInfo[scellCount].internalCellIndex
                /* SPR 11543 Fix end */
                /* +- SPR 17777 */
                ,ulCqiReqInfo_p
                );
        if ( resp != MAC_SUCCESS )
        {
            return resp;
        }
        tag = LTE_GET_U16BIT(msg_p);
    }/*if ( CQI_PERIODIC_INFO == tag )*/

    if ( (periodicCQIEnabled == LTE_TRUE) && (aperiodicCQIEnabled == LTE_TRUE) )
    {
        cqiInfoDl_p->cqiIndication = PERIODIC_APERIODIC_MODE;
    }
    else if (periodicCQIEnabled == LTE_TRUE)
    {
        cqiInfoDl_p->cqiIndication = PERIODIC_CQI_REPORTING_MODE;
    }
    else if  (aperiodicCQIEnabled == LTE_TRUE)
    {
        cqiInfoDl_p->cqiIndication = APERIODIC_CQI_REPORTING_MODE;
    }
    /* - CQI_4.1 */
    if (CQI_REPORT_CONFIG_V920 == tag)
    {
        UInt16 cqiTagLenV920 = 0;
        /* skip CQI_REPORT_CONFIG_V920 tag */
        msg_p += U16BIT_LEN;

        /* cqi report v920 tag length*/
        cqiTagLenV920 = LTE_GET_U16BIT(msg_p);
        msg_p += U16BIT_LEN;

        if ( CQI_REPORT_V920_LEN > cqiTagLenV920 )
        {
            LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                    MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    ulUEInfo_p->ueIdx,cqiTagLenV920,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                    DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                    "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");
            return MAC_FAILURE;
        }
        /*tagLen +4  */
        tag = LTE_GET_U16BIT(msg_p);
        if (CQI_MASK_V920 == tag)
        {
            /* skip CQI_MASK_V920 tag */
            msg_p += U16BIT_LEN;
            //Skip the tag length
            msg_p += U16BIT_LEN;
            cqiInfoUl_p->cqiMaskV920 = *msg_p++;
            /** SPR 14459 Changes Start **/ 
            if (cqiInfoUl_p->cqiMaskV920 != LTE_FALSE)
                /** SPR 14459 Changes End **/ 
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->ueIdx,
                        cqiInfoUl_p->cqiMaskV920,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "CQI_MASK_V920_INVALID_VALUE");
                return MAC_FAILURE;
            }
            /** SPR 14459 Changes Start **/ 
            /* if cqiMaskV920 TAG is present and  cqiMaskV920 value is 0
             * then cqi mask should be set to TRUE */

            cqiInfoUl_p->cqiMaskV920 = TRUE;
            /** SPR 14459 Changes End **/ 
            tag = LTE_GET_U16BIT(msg_p);
            /*tagLen +5  */
        }
        if (PMI_RI_REPORT_V920 == tag)
        {
            /* skip PMI_RI_REPORT_V920 tag */
            msg_p += U16BIT_LEN;
            //Skip the tag length
            msg_p += U16BIT_LEN;
            cqiInfoUl_p->pmiRiReportV920 = *msg_p++;
            if (cqiInfoUl_p->pmiRiReportV920 != LTE_TRUE &&
                    cqiInfoUl_p->pmiRiReportV920 != LTE_FALSE )
            {
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        ulUEInfo_p->ueIdx,
                        cqiInfoUl_p->pmiRiReportV920,
                        internalCellIndex,DEFAULT_INT_VALUE,
                        DEFAULT_INT_VALUE,DEFAULT_FLOAT_VALUE,
                        DEFAULT_FLOAT_VALUE,FUNCTION_NAME,
                        "PMI_RI_REPORT_V920_INVALID_VALUE");
                return MAC_FAILURE;
            }
            cqiInfoDl_p->pmiRiReportV920 = 
                cqiInfoUl_p->pmiRiReportV920;
            /*tagLen +5 */
        }


    }
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseCAReconfigUECqiAperiodicInfo
 *  Inputs         : msgBuf_pp - input message buffer
 *                   cqiInfoDl_p - pointer to downlink CQI info structure
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission mode - CQI transmission mode
 *                   internalCellIndex - the cell index used at MAC
 *                   dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                   ulCqiReqInfo_p- Pointer to uplinkCqi request info
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAReconfigUECqiAperiodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p, 
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        ,ULCQIReqInfo *ulCqiReqInfo_p
        )
{
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    UInt8 len = 0; 
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    ulCqiReqInfo_p->cqiConfigMsg = 
        (ULReconfigCQIType) (ulCqiReqInfo_p->cqiConfigMsg | UL_RECONFIG_CQI_APERIODIC_IND);

    /* Bandwidth Fix */
    if (DL_NUM_RB > cellParams_p->dlAvailableRBs)
    {
        lteWarning("Aperiodic mode configured with DL "
                "RBs are less than 8\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cellParams_p->dlAvailableRBs,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Aperiodic mode configured \
                with DL RBs are less than 8");
        return MAC_FAILURE;
    }
    /* Bandwidth Fix */
    msg_p += U16BIT_LEN;
    len = LTE_GET_U16BIT(msg_p);
    if(len != MIN_CQI_APERIODIC_LEN)
    {
        lteWarning("Invalid Length for cqiAperiodicInfo .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiAperiodicInfo");
        return MAC_FAILURE;
    }
    msg_p += U16BIT_LEN;

    cqiInfoUl_p->cqiMode = (CQIMode)*msg_p++;
    cqiInfoDl_p->cqiMode = cqiInfoUl_p->cqiMode;

    /* This function validates the CQI mode for corresponding TM modes */
    if (MAC_FAILURE == 
            (validateAperiodicModeForTXMode(cqiInfoDl_p->cqiMode,
                                            transmissionMode)))

    {
        lteWarning("TX mode [%d] is not compatible with CQI aperiodic mode [%d]\n",
                transmissionMode,cqiInfoDl_p->cqiMode);
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoDl_p->cqiMode,
                internalCellIndex,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "TX mode is not compatible with CQI aperiodic mode");

        return MAC_FAILURE;
    }       

    *msgBuf_pp = msg_p;

    return resp;
}

/****************************************************************************
 *  Function Name  : macParseCAReconfigUECqiPeriodicInfo
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoDl_p - pointer to downlink CQI info structure
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission mode - CQI transmission Mode
 *                   internalCellIndex - the cell index used at MAC
 *                   dlReconfigUeReq_p - pointer to Downlink reconfig UE structure
 *                   ulCqiReqInfo_p- Pointer to uplinkCqi request info
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for periodic CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAReconfigUECqiPeriodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        /* +- SPR 17777 */
        ,ULCQIReqInfo *ulCqiReqInfo_p
        )
{
    UInt8 tag = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    ulCqiReqInfo_p->cqiConfigMsg = 
        (ULReconfigCQIType) (ulCqiReqInfo_p->cqiConfigMsg | UL_RECONFIG_CQI_PERIODIC_IND);
    /* skip the CQI_PERIODIC_INFO tag */
    msg_p += U16BIT_LEN;

    /* cqi periodic tag length*/
    cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    cqiInfoUl_p->cqiRequestType =  *(msg_p);
    msg_p++;
    /* + SPR 5953 Fix */
    cqiInfoDl_p->cqiRequestType =  
        cqiInfoUl_p->cqiRequestType;
    /* - SPR 5953 Fix */
    if (  cqiInfoUl_p->cqiRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        return MAC_FAILURE;
    }
    if ( cqiInfoUl_p->cqiRequestType )
    {
        if ( cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN)
        {
            lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    cqiPeriodicTagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
            return MAC_FAILURE;
        }
        tag = LTE_GET_U16BIT(msg_p);

        if ( CQI_PMI_CONFIG_INDEX_INFO == tag)
        {
            resp = macParseCAReconfigUECqiPMIConfigIndex(
                    &msg_p,cqiInfoUl_p,transmissionMode,
                    internalCellIndex,ulCqiReqInfo_p
                    );
            if(MAC_SUCCESS != resp)
            {
                return resp;
            }
            tag = LTE_GET_U16BIT(msg_p);
        }/*if ( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)*/
        if ( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)
        {
            resp = macParseCAReconfigUECqiPMIIndexV1020(
                    &msg_p,cqiInfoUl_p,transmissionMode,
                    internalCellIndex,ulCqiReqInfo_p
                    );
            if(MAC_SUCCESS != resp)
            {
                return resp;
            }
        }/*if ( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)*/

    }/* if (  ulLCCreateReq_p->scellInfo[scellIndex].cqiRequestType )*/
    /* SPR 21043 Start */
    else
    {
        cqiInfoUl_p->cqiMaskV920 = FALSE;
    }    
    /* SPR 21043 End */
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseCAReconfigUECqiPMIConfigIndex
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission Mode
 *                   internalCellIndex - cell index used at MAC
 *                   ulCqiReqInfo_p - Pointer of uplink CQI Info received
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for PMI Config Index
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAReconfigUECqiPMIConfigIndex(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p
        )
{
    UInt8 tag=0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->
                                     cellParams_p;
    /* SPR 11035 changes start */
    /* skip CQI_PMI_CONFIG_INDEX_INFO tag */
    msg_p += U16BIT_LEN;
    /* SPR 11035 changes end */
    cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    if ( cqiPeriodicTagLen <  PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->cqiPMIConfigIndex = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

#ifdef FDD_CONFIG
    if (cqiInfoUl_p->cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX ||
            cqiInfoUl_p->cqiPMIConfigIndex == MAC_MAX_CQI_PMI_CONFIG_INDEX_3_1_7  )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        return MAC_FAILURE;
    }
#endif
    cqiInfoUl_p->cqiPucchResourceIndex = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    if (cqiInfoUl_p->cqiPucchResourceIndex > 
            MAC_MAX_CQI_PUCCH_RESOURCE_INDEX)
    {
        lteWarning("Invalid range for cqiPucchResourceIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndex");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->simultaneousACKNACKAndCQI = (*msg_p);
    if ((cqiInfoUl_p->simultaneousACKNACKAndCQI != SIMULTANEOUS_ACK_NACK_CQI_0)
            && (cqiInfoUl_p->simultaneousACKNACKAndCQI != 
                SIMULTANEOUS_ACK_NACK_CQI_1))
    {
        lteWarning("Invalid range for simultaneousACKNACKAndCQI .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->simultaneousACKNACKAndCQI,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for simultaneousACKNACKAndCQI");
        return MAC_FAILURE;
    }
    msg_p++;
    cqiInfoUl_p->cqiformatIndicatorPeriodic = (PeriodicFeedbackType)*msg_p;
    msg_p++;
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodic(
                cqiInfoUl_p->cqiformatIndicatorPeriodic))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n",
                cqiInfoUl_p->cqiformatIndicatorPeriodic);

        return MAC_FAILURE;
    }

    tag = LTE_GET_U16BIT(msg_p);
    /*tagLen + 5  */
    /*tagLen + 10  */
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
            (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->
                    cqiPeriodicReqInfo.cqiPeriodicMsg | 
                    UL_RECONFIG_CQI_PERIODIC_SUBBAND_IND); 

        resp = macParseCAUECqiFormatPeriodicSubbandK(
                &msg_p,cqiInfoUl_p,
                cellParams_p,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    else
    {
        if(cqiInfoUl_p->cqiformatIndicatorPeriodic)
        {
            return MAC_FAILURE;
        }
    }
    tag = LTE_GET_U16BIT(msg_p);
    /*tagLen +5  */
    if (RI_CONFIG_INDEX_INFO == tag)
    {
        ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
            (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->
                    cqiPeriodicReqInfo.cqiPeriodicMsg | 
                    UL_RECONFIG_CQI_PERIODIC_RI_IND); 

        resp = macParseCAUECqiRIConfigIndex(
                &msg_p,cqiInfoUl_p,transmissionMode,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseCAUECqiFormatPeriodicSubbandK
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for Periodic Sub bandK
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiFormatPeriodicSubbandK(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        CellConfigParams *cellParams_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 tagLen =0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (DL_NUM_RB > cellParams_p->dlAvailableRBs)
    {
        lteWarning("Periodic Subband mode configured with DL "
                "RBs are less than 8\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cellParams_p->dlAvailableRBs,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Periodic Subband mode configured \
                with DL RBs are less than 8");
        return MAC_FAILURE;
    }
    /* - CQI_4.1 */
    msg_p += U16BIT_LEN;
    tagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    if (tagLen < CQI_FORMAT_PERIODIC_SUBBAND_K_LEN)
    {
        LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_CREATE_UE_ENTITY_REQ,tagLen, 0,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_CREATE_FAIL");

        return MAC_FAILURE;
    }
    cqiInfoUl_p->cqiformatIndicatorPeriodic_subband_k = *msg_p;
    msg_p++;
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodicSubbandK(
                cqiInfoUl_p->cqiformatIndicatorPeriodic_subband_k))
    {
        lteWarning("Invalid range for "
                "cqiformatIndicatorPeriodic_subband_k:%d\n",
                cqiInfoUl_p->cqiformatIndicatorPeriodic_subband_k);

        return MAC_FAILURE;
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/* SPR 16583 fix start */
/*****************************************************************************
 * Function Name  : lteMacHoRachReleaseLPHandler 
 * Inputs         : ueIndex - UE - Id 
 event - Event Id
 rrcOamPendReq_p - Data stored
 dlData_p - Data to be sent/received from DL thread 
 ulData_p - Data to be sent/received from UL thread  
 response_p - Pointer to return code from HP thread 
 * Returns        : None
 * Description    : This method will delete the UE context after releasing 
 *                  the crnti and preamble.
 *****************************************************************************/
void lteMacHoRachReleaseLPHandler( UInt16 ueIndex,
        MacProcessRrcOamMsgEvent event, LP_RrcOamPendingReq rrcOamPendReq_p,
        RrcOamHiPrioQNode *dlData_p, void *ulData_p, void *response_p,
        InternalCellIndex internalCellIndex)
{
    DLUEContext *ueDLContext_p  = PNULL;
    UInt16 hpRetCode = *((UInt16 *)(response_p));

    if( PNULL != dlData_p )
    {
        /* Set Bitmask for the DL thread it has received response */
        setResponseBitmask( DL_THD, dlData_p,internalCellIndex);
    }
    if( PNULL != ulData_p )
    {
        /* Set Bitmask for the UL thread it has received response */
        setResponseBitmask( UL_THD, ulData_p,internalCellIndex);
    }

    /* Check the bitmask if eligible to send the response to RRC */
    if( rrcOamMsghandler[0].bitMaskRecvd != rrcOamMsghandler[0].bitMaskSent )
    {
        /* Store the return code from the HP thread */
        if( MAC_SUCCESS != hpRetCode || 
                MAC_SUCCESS != rrcOamMsghandler[0].retCode )
        {
            rrcOamMsghandler[0].retCode = MAC_FAILURE;
        }
        else
        {
            rrcOamMsghandler[0].retCode = MAC_SUCCESS;
        }
    }
    else
    {
        ueDLContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
        if (PNULL == ueDLContext_p )
        {
            LOG_MAC_MSG( DEL_DL_UE_CONTXT_HO_ID, LOGWARNING, MAC_RRC_INF,
                    getCurrentTick(), ueIndex,event,0,0,0, 0,0,
                    __func__ , "HoRelRach" );
        }
        else
        {
#ifdef HD_FDD_CONFIG
            if(TRUE == ueDLContext_p->isHDFddFlag)
            {
                deleteUeFromHdFddContext(ueDLContext_p,internalCellIndex);
            }
#endif
            /* HD FDD Changes End*/
            freeMemPool(ueDLContext_p);
            dlUECtxInfoArr_g[ueIndex].dlUEContext_p = PNULL;
            /* SPR 21484 fix start */
            if ((ueIndex != INVALID_UE_ID) && (0 == setUeIdxInvalid(ueIndex,UE_IDX_MAPPING_FOR_MAC)))
            {
                freeUeIdx(ueIndex);
            }
            /* SPR 21484 fix end */

        }
        rrcOamfreeRespBuffer(internalCellIndex);
        freeMemPool( rrcOamPendReq_p );

        /* Reset information in global state machine structure */
        rrcMsgResetStateMachine(internalCellIndex);

        /* Check and process any pending message */
        rrcMsgProcessPendingHandler(internalCellIndex);
    }
}
/* SPR 16583 fix end */
/****************************************************************************
 *  Function Name  : macParseCAUECqiRIConfigIndex
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission Mode
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for RI Config Index 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiRIConfigIndex(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 len =0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;

    msg_p += U16BIT_LEN;
    len = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    if(len != RI_CONFIG_INDEX_INFO_LEN)
    {
        lteWarning("Invalid Length for riConfigIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Length for riConfigIndex");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->riConfigIndex = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    /*tagLen +6 */
    if ((cqiInfoUl_p->riConfigIndex > MAC_MAX_RI_CONFIG_INDEX))
    {
        lteWarning("Invalid range for riConfigIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->riConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for riConfigIndex");
        return MAC_FAILURE;
    }

    else if( TX_MODE_3 != transmissionMode &&
            TX_MODE_4 != transmissionMode &&                         
            TX_MODE_5 != transmissionMode &&                        
            TX_MODE_6 != transmissionMode && 
            TX_MODE_8 != transmissionMode )                          
    {
        cqiInfoUl_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;
        lteWarning("riConfigIndex is configured in TX mode other "
                "than 3 and 4.\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->riConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "riConfigIndex is configured \
                in TX mode other than 3 and 4");
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseCAReconfigUECqiPMIIndexV1020
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission Mode
 *                   internalCellIndex - cell index used at MAC
 *                  ulCqiReqInfo_p - Pointer of uplink CQI Info received
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for PMI IndexV1020
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAReconfigUECqiPMIIndexV1020(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p
        )
{
    UInt8 tag=0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* SPR 11035 changes start */
    /* skip CQI_PMI_CONFIG_INDEX_INFO_v1020 tag */
    msg_p += U16BIT_LEN;
    /* SPR 11035 changes end */
    cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    if ( cqiPeriodicTagLen <  PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->cqiPMIConfigIndexV1020 = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    resp = validateCqiPMIConfigIndex(cqiInfoUl_p->cqiPMIConfigIndexV1020, 
            internalCellIndex);
    if (resp != MAC_SUCCESS)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPMIConfigIndexV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndexV1020");
        return resp;

    }
    cqiInfoUl_p->cqiPucchResourceIndexV1020 = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    resp = validateCqiPucchResourceIndexR10(cqiInfoUl_p->cqiPucchResourceIndexV1020, internalCellIndex);
    if (resp != MAC_SUCCESS)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPucchResourceIndexV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndexV1020");
        return resp;
    }
    cqiInfoUl_p->simultaneousACKNACKAndCQIV1020 = *msg_p;
    msg_p++;
    resp = validateSimultaneousACKNACKAndCQI(
            cqiInfoUl_p->simultaneousACKNACKAndCQIV1020
            ,internalCellIndex
            );
    if ( resp != MAC_SUCCESS )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->simultaneousACKNACKAndCQIV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for simultaneousACKNACKAndCQIV1020");
        return resp;
    }
    cqiInfoUl_p->cqiformatIndicatorPeriodicV1020 = (PeriodicFeedbackType)*msg_p;
    msg_p++;
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodic(cqiInfoUl_p->cqiformatIndicatorPeriodicV1020))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n",
                cqiInfoUl_p->cqiformatIndicatorPeriodicV1020);

        return MAC_FAILURE;
    }

    tag = LTE_GET_U16BIT(msg_p);
    /*tagLen + 10 */
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
            (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->
                    cqiPeriodicReqInfo.cqiPeriodicMsg | 
                    UL_RECONFIG_CQI_PERIODIC_SUBBAND_IND); 

        resp = macParseCAUECqiFormatPeriodicSubbandKV1020(
                &msg_p,cqiInfoUl_p,
                cellParams_p,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    else
    {
        if(cqiInfoUl_p->cqiformatIndicatorPeriodicV1020)
        {
            return MAC_FAILURE;
        }
    }
    tag = LTE_GET_U16BIT(msg_p);

    /*tagLen +5  effective 25*/
    if (RI_CONFIG_INDEX_INFO == tag)
    {
        ulCqiReqInfo_p->cqiPeriodicReqInfo.cqiPeriodicMsg = 
            (ULReconfigPeriodicCQIType) (ulCqiReqInfo_p->
                    cqiPeriodicReqInfo.cqiPeriodicMsg | 
                    UL_RECONFIG_CQI_PERIODIC_RI_IND); 

        resp = macParseCAUECqiRIConfigIndexV1020(
                &msg_p,cqiInfoUl_p,transmissionMode,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    } 
    /*EICIC Changes Starts*/
    tag = LTE_GET_U16BIT(msg_p);
    if (CSI_CONFIG_INDEX_VR10 == tag) 
    { 
        resp = macParseCAUECqiConfigIndexV10Info(
                &msg_p,cqiInfoUl_p,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        } 
    }
    *msgBuf_pp = msg_p;
    return resp;
}
#ifdef FDD_CONFIG

MacRetType macParseCAReconfigUECqiPMIIndexV1020_dummy(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex,
        ULCQIReqInfo *ulCqiReqInfo_p
        )
{
    MacRetType resp ;
    resp = macParseCAReconfigUECqiPMIIndexV1020(msgBuf_pp,
            cqiInfoUl_p,
            transmissionMode,
            internalCellIndex,
            ulCqiReqInfo_p
            );
    return resp;
}
#endif

/****************************************************************************
 *  Function Name  : macParseCAUECqiFormatPeriodicSubbandKV1020
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   cellParams_p -  pointer to cell parameters
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for Periodic Sub bandKV1020
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiFormatPeriodicSubbandKV1020(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        CellConfigParams *cellParams_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 tagLen = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    if (DL_NUM_RB > cellParams_p->dlAvailableRBs)
    {
        lteWarning("Periodic Subband mode configured with DL "
                "RBs are less than 8\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cellParams_p->dlAvailableRBs,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Periodic Subband mode configured \
                with DL RBs are less than 8");
        return MAC_FAILURE;
    }
    /* - CQI_4.1 */
    msg_p += U16BIT_LEN;
    tagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    if (tagLen < CQI_FORMAT_PERIODIC_SUBBAND_K_LEN)
    {
        LOG_MAC_MSG(MAC_UE_CREATE_FAIL_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                MAC_CREATE_UE_ENTITY_REQ,tagLen, 0,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_CREATE_FAIL");

        return MAC_FAILURE;
    }
    cqiInfoUl_p->cqiformatIndicatorPeriodic_subband_kV1020 = *msg_p;
    msg_p++;
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodicSubbandK(cqiInfoUl_p->
                cqiformatIndicatorPeriodic_subband_kV1020))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic_subband_kV1020:%d\n",
                cqiInfoUl_p->cqiformatIndicatorPeriodic_subband_kV1020);
        return MAC_FAILURE;
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseCAUECqiConfigIndexV10Info
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                     internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for CQIPMI and RI Configindex for ABS
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiConfigIndexV10Info(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 len =0;
    UInt8 *msg_p    = PNULL;
    UInt16 tag             = 0;

    msg_p = *msgBuf_pp;
    msg_p +=U16BIT_LEN;
    len = LTE_GET_U16BIT(msg_p);
    msg_p +=U16BIT_LEN;

    if (CSI_CONFIG_INDEX_VR10_TAG_LENGTH > len)
    { 
        lteWarning("Invalid Length for riConfigIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Length for riConfigIndex");
        return MAC_FAILURE;
    }

    cqiInfoUl_p->cqiConfigRequestType = *(msg_p);
    msg_p++;

    if ( cqiInfoUl_p->cqiConfigRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiConfigRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");

        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    if ( cqiInfoUl_p->cqiConfigRequestType )
    {
        tag = LTE_GET_U16BIT(msg_p);
        if (tag == CQI_PMI_CONFIGINDEX2_VR10)
        {
            msg_p += 2;
            len = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (CQI_PMI_CONFIGINDEX2_VR10_TAG_LENGTH > len)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        cqiInfoUl_p->cqiConfigRequestType,len,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "CQI_REPORT_CONFIG_V920_INVALID_TAGLEN");

                return MAC_FAILURE;
            }
            cqiInfoUl_p->cqiPMIConfigIndex_2 = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            tag = LTE_GET_U16BIT(msg_p);
        }
        if (tag == RI_CONFIG_INDEX_INFO)
        {
            msg_p += 2;
            len = LTE_GET_U16BIT(msg_p);
            msg_p += 2;

            if (RI_CONFIG_INDEX_INFO_LEN > len)
            {      
                LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,
                        MAC_RRC_INF,GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        tag,len,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,
                        "RI_CONFIG_INDEX_INFO_INVALID_TAGLEN");
                return MAC_FAILURE;
            }
            cqiInfoUl_p->riConfigIndex_2 = LTE_GET_U16BIT(msg_p);;
            msg_p += 2;
        }

    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 *  Function Name  : macParseCAUECqiRIConfigIndexV1020
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmissionMode
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for RI Config IndexV1020
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiRIConfigIndexV1020(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 len =0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    msg_p +=U16BIT_LEN;
    len = LTE_GET_U16BIT(msg_p);
    msg_p +=U16BIT_LEN;

    if(len != RI_CONFIG_INDEX_INFO_LEN)
    {
        lteWarning("Invalid Length for riConfigIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Length for riConfigIndex");
        return MAC_FAILURE;
    }

    cqiInfoUl_p->riConfigIndexV1020 = LTE_GET_U16BIT(msg_p);
    msg_p +=U16BIT_LEN;
    /*tagLen +6  */
    if (cqiInfoUl_p->riConfigIndexV1020 > MAC_MAX_RI_CONFIG_INDEX)
    {
        lteWarning("Invalid range for riConfigIndexV1020.\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->riConfigIndexV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for riConfigIndex");
        return MAC_FAILURE;
    }

    else if( TX_MODE_3 != transmissionMode &&
            TX_MODE_4 != transmissionMode &&                         
            TX_MODE_5 != transmissionMode &&                        
            TX_MODE_6 != transmissionMode && 
            TX_MODE_8 != transmissionMode )                          
    {
        cqiInfoUl_p->riConfigIndexV1020 = MAC_RI_CONFIG_INDEX_INVALID;
        lteWarning("riConfigIndexV1020 is configured in TX mode other than 3 and 4.\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->riConfigIndexV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "riConfigIndex is configured \
                in TX mode other than 3 and 4");
    }
    *msgBuf_pp = msg_p;
    return MAC_SUCCESS;
}
/****************************************************************************
 *  Function Name  : macParseCAUECqiAperiodicInfo
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoDl_p - pointer to downlink CQI info structure
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission mode 
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the Aperiodic info for CQI_INFO 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiAperiodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p, 
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 len =0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    if (DL_NUM_RB > cellParams_p->dlAvailableRBs)
    {
        lteWarning("Aperiodic mode configured with DL "
                "RBs are less than 8\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cellParams_p->dlAvailableRBs,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Aperiodic mode configured \
                with DL RBs are less than 8");
        return MAC_FAILURE;
    }
    /* skip CQI_APERIODIC_INFO tag */
    msg_p += U16BIT_LEN;
    len = LTE_GET_U16BIT(msg_p);
    if(len != MIN_CQI_APERIODIC_LEN)
    {
        lteWarning("Invalid Length for cqiAperiodicInfo .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                len,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiAperiodicInfo");
        return MAC_FAILURE;
    }
    msg_p += U16BIT_LEN;

    cqiInfoUl_p->cqiMode = (CQIMode)*msg_p++;
    cqiInfoDl_p->cqiMode = cqiInfoUl_p->cqiMode;

    /* This function validates the CQI mode for corresponding TM modes */
    if (MAC_FAILURE == 
            (validateAperiodicModeForTXMode(cqiInfoDl_p->cqiMode,
                                            transmissionMode)))

    {
        lteWarning("TX mode [%d] is not compatible with CQI aperiodic mode [%d]\n",
                transmissionMode,cqiInfoDl_p->cqiMode);
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoDl_p->cqiMode,
                internalCellIndex,
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "TX mode is not compatible with CQI aperiodic mode");

        return MAC_FAILURE;
    }       
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseCAUECqiPeriodicInfo
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoDl_p - pointer to downlink CQI info structure
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission mode 
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for periodic CQI_INFO 
 *                   and fills in the structure needed by MAC to create 
 *                   a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiPeriodicInfo(
        UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoDl_p,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 tag = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    UInt32 cqiPeriodicTagLen = 0;
    /* skip the CQI_PERIODIC_INFO tag */
    msg_p += U16BIT_LEN;
    /* cqi periodic tag length*/
    cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);

    msg_p += U16BIT_LEN;

    cqiInfoUl_p->cqiRequestType =  *(msg_p);
    msg_p++;
    cqiInfoDl_p->cqiRequestType =  
        cqiInfoUl_p->cqiRequestType;
    if (  cqiInfoUl_p->cqiRequestType > SETUP)
    {
        lteWarning("Invalid CQI Request Type");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiRequestType,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid CQI Request Type");
        return MAC_FAILURE;
    }
    if ( cqiInfoUl_p->cqiRequestType )
    {
        if ( cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN)
        {
            lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    cqiPeriodicTagLen,
                    internalCellIndex, 
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "cqiPeriodicTagLen < PERIODIC_CQI_SETUP_LEN");
            return MAC_FAILURE;
        }
        tag = LTE_GET_U16BIT(msg_p);

        if ( CQI_PMI_CONFIG_INDEX_INFO == tag)
        {
            resp = macParseCACreateUECqiPMIConfigIndex(
                    &msg_p,cqiInfoUl_p,transmissionMode,
                    internalCellIndex);
            if(MAC_SUCCESS != resp)
            {
                return resp;
            }
            tag = LTE_GET_U16BIT(msg_p);
        }/*if ( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)*/
        if ( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)
        {
            resp = macParseCAUECqiPMIConfigIndexV1020
                (&msg_p,cqiInfoUl_p,transmissionMode,internalCellIndex);
        }/*if ( CQI_PMI_CONFIG_INDEX_INFO_v1020 == tag)*/

    }/* if (  ulLCCreateReq_p->scellInfo[scellIndex].cqiRequestType )*/
    /* SPR 21043 Start */
    else
    {
        cqiInfoUl_p->cqiMaskV920 = FALSE;
    }    
    /* SPR 21043 End */
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseCACreateUECqiPMIConfigIndex
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission mode
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for PMI Config index 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCACreateUECqiPMIConfigIndex(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 tag=0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    MacRetType resp = MAC_SUCCESS;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    UInt32 cqiPeriodicTagLen = 0;
    /* SPR 11035 changes start */
    /* skip CQI_PMI_CONFIG_INDEX_INFO tag */
    msg_p += U16BIT_LEN;
    /* SPR 11035 changes end */
    cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    if ( cqiPeriodicTagLen <  PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->cqiPMIConfigIndex = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
#ifdef FDD_CONFIG
    if (cqiInfoUl_p->cqiPMIConfigIndex > MAC_MAX_CQI_PMI_CONFIG_INDEX ||
            cqiInfoUl_p->cqiPMIConfigIndex == 
            MAC_MAX_CQI_PMI_CONFIG_INDEX_3_1_7  )
    {
        lteWarning("Invalid range for cqiPMIConfigIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPMIConfigIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndex");
        return MAC_FAILURE;
    }
#endif
    cqiInfoUl_p->cqiPucchResourceIndex = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    if (cqiInfoUl_p->cqiPucchResourceIndex > MAC_MAX_CQI_PUCCH_RESOURCE_INDEX)
    {
        lteWarning("Invalid range for cqiPucchResourceIndex .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for "
                "cqiPucchResourceIndex");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->simultaneousACKNACKAndCQI = (*msg_p);
    if ((cqiInfoUl_p->simultaneousACKNACKAndCQI != 
                SIMULTANEOUS_ACK_NACK_CQI_0) &&
            (cqiInfoUl_p->simultaneousACKNACKAndCQI != 
             SIMULTANEOUS_ACK_NACK_CQI_1))
    {
        lteWarning("Invalid range for simultaneousACKNACKAndCQI .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->simultaneousACKNACKAndCQI,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for"
                "simultaneousACKNACKAndCQI");
        return MAC_FAILURE;
    }
    msg_p++;
    cqiInfoUl_p->cqiformatIndicatorPeriodic = 
        (PeriodicFeedbackType)*msg_p;
    msg_p++;
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodic
            (cqiInfoUl_p->cqiformatIndicatorPeriodic))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n",
                cqiInfoUl_p->cqiformatIndicatorPeriodic);

        return MAC_FAILURE;
    }
    tag = LTE_GET_U16BIT(msg_p);
    /*tagLen + 5  */
    /*tagLen + 10  */
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        resp = macParseCAUECqiFormatPeriodicSubbandK(
                &msg_p,cqiInfoUl_p,
                cellParams_p,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    else
    {
        if(cqiInfoUl_p->cqiformatIndicatorPeriodic)
        {
            return MAC_FAILURE;
        }
    }
    tag = LTE_GET_U16BIT(msg_p);
    if (RI_CONFIG_INDEX_INFO == tag)
    {
        resp = macParseCAUECqiRIConfigIndex(
                &msg_p,cqiInfoUl_p,transmissionMode,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    *msgBuf_pp = msg_p;
    return resp;
}

/****************************************************************************
 *  Function Name  : macParseCAUECqiPMIConfigIndexV1020
 *  Inputs         : msgBuf_pp - pointer to input buffer
 *                   cqiInfoUl_p - pointer to uplink CQI info structure
 *                   transmission mode 
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : MAC_SUCCESS or MAC_FAILURE
 *  Description    : This function parses the input buffer for PMI ConfigV1020 
 *                   and fills in the structure needed by MAC to create a UE context
 * ****************************************************************************/
STATIC  MacRetType macParseCAUECqiPMIConfigIndexV1020(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    MacRetType resp = MAC_SUCCESS;
    UInt32 tag =0,cqiPeriodicTagLen = 0;
    UInt8 *msg_p    = PNULL;
    msg_p = *msgBuf_pp;
    /* SPR 11035 changes start */
    /* skip CQI_PMI_CONFIG_INDEX_INFO_v1020 tag */
    msg_p += U16BIT_LEN;
    /* SPR 11035 changes end */
    cqiPeriodicTagLen = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;

    if ( cqiPeriodicTagLen <  PERIODIC_CQI_LEN )
    {
        lteWarning("cqiPeriodicTagLen < PERIODIC_CQI_LEN");
        LOG_MAC_MSG(MAC_UE_RECONFIGURE_FAIL,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPeriodicTagLen,DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                internalCellIndex,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"MAC_UE_RECONFIGURE_FAIL");
        return MAC_FAILURE;
    }
    cqiInfoUl_p->cqiPMIConfigIndexV1020 = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    resp = validateCqiPMIConfigIndex(cqiInfoUl_p->cqiPMIConfigIndexV1020, 
            internalCellIndex);
    if (resp != MAC_SUCCESS)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPMIConfigIndexV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPMIConfigIndexV1020");
        return resp;

    }
    cqiInfoUl_p->cqiPucchResourceIndexV1020 = LTE_GET_U16BIT(msg_p);
    msg_p += U16BIT_LEN;

    resp = validateCqiPucchResourceIndexR10(cqiInfoUl_p->cqiPucchResourceIndexV1020
            , internalCellIndex);
    if (resp != MAC_SUCCESS)
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->cqiPucchResourceIndexV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndexV1020");
        return resp;
    }
    cqiInfoUl_p->simultaneousACKNACKAndCQIV1020 = *msg_p;
    msg_p++;
    resp = validateSimultaneousACKNACKAndCQI(
            cqiInfoUl_p->simultaneousACKNACKAndCQIV1020
            ,internalCellIndex
            );
    if ( resp != MAC_SUCCESS )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiInfoUl_p->simultaneousACKNACKAndCQIV1020,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for simultaneousACKNACKAndCQIV1020");
        return resp;
    }
    cqiInfoUl_p->cqiformatIndicatorPeriodicV1020 = (PeriodicFeedbackType)*msg_p;
    msg_p++;
    if(MAC_SUCCESS != validateCqiformatIndicatorPeriodic(
                cqiInfoUl_p->cqiformatIndicatorPeriodicV1020))
    {
        lteWarning("Invalid range for cqiformatIndicatorPeriodic:%d\n",
                cqiInfoUl_p->cqiformatIndicatorPeriodicV1020);

        return MAC_FAILURE;
    }

    tag = LTE_GET_U16BIT(msg_p);
    /*tagLen + 10 */
    if(CQI_FORMAT_PERIODIC_SUBBAND_K == tag)
    {
        resp = macParseCAUECqiFormatPeriodicSubbandKV1020(
                &msg_p,cqiInfoUl_p,
                cellParams_p,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    else
    {
        if(cqiInfoUl_p->cqiformatIndicatorPeriodicV1020)
        {
            LOG_MAC_ERROR(MAC_RRC_INF,"Invalid cqiformatIndicatorPeriodicV1020 %u\n",
                    cqiInfoUl_p->cqiformatIndicatorPeriodicV1020);
            return MAC_FAILURE;
        }
    }
    tag = LTE_GET_U16BIT(msg_p);

    /*tagLen +5  effective 25*/
    if (RI_CONFIG_INDEX_INFO == tag)
    {
        resp = macParseCAUECqiRIConfigIndexV1020(
                &msg_p,cqiInfoUl_p,transmissionMode,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        }
    }
    /*EICIC Changes Starts*/
    tag = LTE_GET_U16BIT(msg_p);

    if (CSI_CONFIG_INDEX_VR10 == tag) 
    { 
        resp = macParseCAUECqiConfigIndexV10Info(
                &msg_p,cqiInfoUl_p,
                internalCellIndex
                );
        if(MAC_SUCCESS != resp)
        {
            return resp;
        } 
    }
    /*EICIC Changes Ends*/
    *msgBuf_pp = msg_p;
    return resp;
}
#ifdef FDD_CONFIG

MacRetType macParseCAUECqiPMIConfigIndexV1020_dummy(UInt8 **msgBuf_pp,
        CqiInfo *cqiInfoUl_p,
        UInt8 transmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    MacRetType resp;
    resp =	macParseCAUECqiPMIConfigIndexV1020(msgBuf_pp,
            cqiInfoUl_p,
            transmissionMode,
            internalCellIndex
            );
    return resp;
}
#endif

/****************************************************************************
 *  Function Name  : insertNodeInDlCAEventQueueRRCIntf 
 *  Inputs         : sCellIndex - scell index 
 *                   isScellActivateState -
 *                   ueIndex -
 *                   internalCellIndex - the cell index used at MAC
 *  Outputs        : None
 *  Returns        : void 
 *  Description    : This function prepare and insert Scell state transition 
 *                   event in scell event Q 
 * ****************************************************************************/
/*ca chngs start*/
/* +- SPR 18268 */
void insertNodeInDlCAEventQueueRRCIntf(InternalCellIndex sCellIndex,UInt8 isScellActivateStatus,UInt16 ueIndex,
        /* +- SPR 18268 */
        InternalCellIndex internalCellIndex)
{
    DLCAEventQueueNode * eventQNode_p = PNULL;
    ServingCellIndex servCellIndex = INVALID_CELL_INDEX;

    GET_MEM_NODE_DL_CA_EVENT_Q(eventQNode_p,DLCAEventQueueNode);
    if(eventQNode_p != PNULL)
    { 
        eventQNode_p->ueId = ueIndex;
        servCellIndex = getServeCellIndexFromInternalCellId(dlUECtxInfoArr_g[ueIndex].dlUEContext_p,sCellIndex);
        eventQNode_p->scellId = servCellIndex; 
        /*prepare and insert Scell state transition event in scell event Q*/
        /*spr 11042 fix start*/  
        if(isScellActivateStatus == LTE_TRUE)
        {
            eventQNode_p->dlCAQosEvent = DL_CA_EVENT_RRM_SCELL_ACTIVATION;
        }
        if(isScellActivateStatus == LTE_FALSE)
        {
            eventQNode_p->dlCAQosEvent = DL_CA_EVENT_RRM_SCELL_DEACTIVATION;
        }
        /*spr 11042 fix end*/ 
        if(!ENQUEUE_DL_CA_EVENT_Q(dlCAEventQueue_gp[internalCellIndex],(void *)eventQNode_p))
        {
            FREE_MEM_NODE_DL_CA_EVENT_Q(eventQNode_p); 
        }
    }
}
/*ca chngs end*/
/****************************************************************************
 * Function Name  : validatecqiPucchResourceIndexR10
 * Inputs         : cqiPucchResourceIndex - Specifies the pucch resources for 
 periodic CQI on uplink.
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or reason for failure.
 * Description    : This API takes cqiPucchResourceIndex  to validate and 
 returns the result  of validation to the calling function.
 ****************************************************************************/

STATIC  MacRetType validateCqiPucchResourceIndexR10(UInt32 cqiPucchResourceIndex
        ,InternalCellIndex internalCellIndex
        )
{
    if (cqiPucchResourceIndex > (MAC_MAX_CQI_PUCCH_RESOURCE_INDEX-1))
    {
        lteWarning("Invalid range for cqiPucchResourceIndexR10 .\n");
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                cqiPucchResourceIndex,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid range for cqiPucchResourceIndexR10");
        return MAC_FAILURE;
    }
    return MAC_SUCCESS;
}
/*SPR 16855 +-*/
/*****************************************************************************
 * Function Name  : sendStartPhyInd
 * Inputs         : internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function sends start request to PHY.
 *****************************************************************************/
void sendStartPhyInd(InternalCellIndex internalCellIndex)
{
    /*SPR 16855 +-*/
#if (!defined(DL_UL_SPLIT) && !defined(DL_UL_SPLIT_TDD))
#define PROCESS_OAM_AND_RRC_MSG                    MAC_PROCESS_OAM_AND_RRC_MSG
#define RDTSC_AND_CLOCK_START_SPLIT_FDD(FLOW, EL)  RDTSC_AND_CLOCK_START_FDD(EL)
#define RDTSC_AND_CLOCK_END_SPLIT_FDD(FLOW, EL, CELL)    RDTSC_AND_CLOCK_END_MAC(EL, CELL)
#endif
#ifdef DL_UL_SPLIT_TDD
#define RDTSC_AND_CLOCK_START_SPLIT_FDD(FLOW, EL)  RDTSC_AND_CLOCK_START_SPLIT_TDD(FLOW, EL) 
#define RDTSC_AND_CLOCK_END_SPLIT_FDD(FLOW, EL)    RDTSC_AND_CLOCK_END_SPLIT_TDD(FLOW, EL)
#endif
        /* SPR 10852 fix start */
        RDTSC_AND_CLOCK_START_SPLIT_FDD(RRC_OAM_FLOW_ID, MAC_PROCESS_START_PHY);
        /* SPR 10852 fix end */
        if (MAC_FAILURE == sendStartReqToPhy(internalCellIndex))
        {
            LTE_MAC_UT_LOG(LOG_WARNING, CELL_CONF,"Error sending Start request to "
                    "PHY");
            /* SPR 10852 fix start */
            RDTSC_AND_CLOCK_END_SPLIT_FDD(RRC_OAM_FLOW_ID, MAC_PROCESS_START_PHY, internalCellIndex);
            /* SPR 10852 fix end */
            /* Not able to send the Phy start request, send failure response to
             * l3*/
            ConfigCellRes configCellRes = {0};
            configCellRes.response = MAC_FAILURE;
            configCellRes.transactionId = transactionId_g[internalCellIndex];
            /** SPR 11056 Changes Start **/
            if(MAC_SEND_ERROR ==
                    sendMsgToRRC(MAC_CONFIG_CELL_CNF, &configCellRes, 
                        macCommonGetRRCCellIndex(internalCellIndex)))
                /** SPR 11056 Changes End **/
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID,
                        MAJOR_ALARM);
            }
            transactionId_g[internalCellIndex] = INVALID_TRANS_ID;
        }
        else 
        {
            /*SPR 21054 fix start*/
            /* SPR 10852 fix start */
            RDTSC_AND_CLOCK_END_SPLIT_FDD(RRC_OAM_FLOW_ID,MAC_PROCESS_START_PHY, 
                    internalCellIndex);
            /* SPR 10852 fix end */
            cellSpecificParams_g.cellConfigAndInitParams_p[internalCellIndex]
                ->cellState = CELL_WAITING_FOR_FIRST_SFI;
            /*SPR 21054 fix end*/
        }
    return; 
}
/*SPR 16855 +-*/

/****************************************************************************
 * Function Name  : macPopulateScellCQIInfo 
 * Inputs         : pucchConfig_p - Pointer to update PUCCH configuration
 *                  ulCqiReqInfo_p - Pointer of uplink CQI Info received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function calls the appropriate function based on cqi Config
 ****************************************************************************/
STATIC void macPopulateScellCQIInfo( PucchConfig *pucchConfig_p,ULCQIReqInfo *ulCqiReqInfo_p
        , InternalCellIndex internalCellIndex
        )
{
    switch(ulCqiReqInfo_p->cqiConfigMsg)
    {
        case UL_RECONFIG_CQI_APERIODIC_MSG:
        macPopulateScellCqiAperiodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiAperiodicInfo);
        break;
        case UL_RECONFIG_CQI_PERIODIC_MSG:
        macPopulateScellCqiPeriodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiPeriodicReqInfo
                , internalCellIndex
                );
        break;
        case UL_RECONFIG_CQI_PERIODIC_APERIODIC_MSG:
        macPopulateScellCqiPeriodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiPeriodicReqInfo
                , internalCellIndex
                );
        macPopulateScellCqiAperiodicInfo(pucchConfig_p,&ulCqiReqInfo_p->cqiAperiodicInfo);
        break;
        default:
        break;
    }
}

/****************************************************************************
 * Function Name  : macPopulateScellCqiAperiodicInfo 
 * Inputs         : pucchConfig_p - Pointer to update PUCCH configuration
 *                  cqiAperiodicInfo_p - Pointer of CQI Aperiodic Info received
 * Outputs        : None
 * Returns        : None
 * Description    : This function Updates the Aperiodic CQI information 
 *                  in PUCCH context of UE.
 ****************************************************************************/
STATIC void macPopulateScellCqiAperiodicInfo( PucchConfig *pucchConfig_p,ULCQIAperiodicInfo *cqiAperiodicInfo_p)
{
    pucchConfig_p->cqiPmiRiInfoAperiodic.cqiMode =
        cqiAperiodicInfo_p->cqiAperiodicMode;
}

/****************************************************************************
 * Function Name  : macPopulateScellCqiPeriodicInfo 
 * Inputs         : pucchConfig_p - Pointer to update PUCCH configuration
 *                  cqiPeriodicReqInfo_p - Pointer of CQI periodic Info received
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function Updates the periodic CQI information 
 *                  in PUCCH context of UE.
 ****************************************************************************/
STATIC void macPopulateScellCqiPeriodicInfo( PucchConfig *pucchConfig_p,ULCQIPeriodicReqInfo *cqiPeriodicReqInfo_p
        , InternalCellIndex internalCellIndex
        )
{

    RIConfigIndexInfo *riConfigIndexInfo_p = &(cqiPeriodicReqInfo_p->riConfigIndexInfo);

    ULReconfigCQIRIMsgType reconfigCQIRIRetValue = 
        cqiPeriodicReqInfo_p->cqiRiReconfigMsg;

    pucchConfig_p->cqiformatIndicatorPeriodicV1020 = 
        cqiPeriodicReqInfo_p->cqiformatIndicatorPeriodicV1020;
    pucchConfig_p->cqiformatIndicatorPeriodic_subband_kV1020 = 
        cqiPeriodicReqInfo_p->cqiformatIndicatorPeriodic_subband_kV1020;
    if (CQI_MAP_RECONFIGURE_IND & reconfigCQIRIRetValue)
    {    
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate CQI parameters\n" ,__func__);
        pucchConfig_p->cqiPmiConfigIndex = cqiPeriodicReqInfo_p->cqiPmiConfigIndex;
        pucchConfig_p->cqiPmiConfigIndexV1020 = 
            cqiPeriodicReqInfo_p->cqiPMIConfigIndexV1020;
        pucchConfig_p->cqiPeriodicity = cqiPeriodicReqInfo_p->cqiPeriodicity;

        pucchConfig_p->cqiOffset = cqiPeriodicReqInfo_p->cqiOffset;
        pucchConfig_p->maxCQIWrapAround[
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
            cqiPeriodicReqInfo_p->maxCQIWrapAround;
        if( PERIODIC_FEEDBACK_SUBBAND ==
                pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType )
        {
            pucchConfig_p->maxWbCQIWrapAround[
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
                cqiPeriodicReqInfo_p->maxWbCQIWrapAround;
        }
        pucchConfig_p->cqiPUCCHRBIndex = cqiPeriodicReqInfo_p->cqiPUCCHRBIndex;
    }

    if(RI_MAP_RECONFIGURE_IND & reconfigCQIRIRetValue)
    {
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate RI parameters\n" ,__func__);

        pucchConfig_p->riConfigIndex = riConfigIndexInfo_p->riConfigIndex;
        pucchConfig_p->riConfigIndexV1020 = cqiPeriodicReqInfo_p->riConfigIndexV1020;

        pucchConfig_p->riPeriodicity = riConfigIndexInfo_p->riPeriodicity;
        pucchConfig_p->riOffset = riConfigIndexInfo_p->riOffset;
        pucchConfig_p->maxRIWrapAround[
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] =
            riConfigIndexInfo_p->maxRIWrapAround ;
    }
    /*eicic changes*/

    if (CQI_MAP_RECONFIGURE_IND2 & reconfigCQIRIRetValue)
    {    
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate CQI parameters\n" ,__func__);
        pucchConfig_p->cqiPmiConfigIndex_2 = cqiPeriodicReqInfo_p->cqiPmiConfigIndex_2;
        pucchConfig_p->cqiPmiConfigIndexV1020 = 
            cqiPeriodicReqInfo_p->cqiPMIConfigIndexV1020;
        pucchConfig_p->cqiPeriodicity_2 = cqiPeriodicReqInfo_p->cqiPeriodicity_2;

        pucchConfig_p->cqiOffset_2 = cqiPeriodicReqInfo_p->cqiOffset_2;
        pucchConfig_p->maxCQIWrapAround2[
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
            cqiPeriodicReqInfo_p->maxCQIWrapAround2;
        if( PERIODIC_FEEDBACK_SUBBAND ==
                pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType )
        {
            pucchConfig_p->maxWbCQIWrapAround2[
                longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] = 
                cqiPeriodicReqInfo_p->maxWbCQIWrapAround2;
        }
        pucchConfig_p->cqiPUCCHRBIndex = cqiPeriodicReqInfo_p->cqiPUCCHRBIndex;
    }

    if(RI_MAP_RECONFIGURE_IND2 & reconfigCQIRIRetValue)
    {
        LTE_MAC_UT_LOG(LOG_MINOR,PARSE_UTIL,"[%s] At HP Populate RI parameters\n" ,__func__);

        pucchConfig_p->riConfigIndex_2 = riConfigIndexInfo_p->riConfigIndex_2;
        pucchConfig_p->riConfigIndexV1020 = cqiPeriodicReqInfo_p->riConfigIndexV1020;

        pucchConfig_p->riPeriodicity_2 = riConfigIndexInfo_p->riPeriodicity_2;
        pucchConfig_p->riOffset_2 = riConfigIndexInfo_p->riOffset_2;
        pucchConfig_p->maxRIWrapAround2[
            longPeriodicSRCQIPMIRIMapInfo_gp[internalCellIndex]->activeIndex] =
            riConfigIndexInfo_p->maxRIWrapAround2 ;
    }
    if((CQI_RESOURCE_INDEX_RECONFIGURE_IND & reconfigCQIRIRetValue) ||
            (RI_RESOURCE_INDEX_RECONFIGURE_IND & reconfigCQIRIRetValue) ||
            (CQI_RESOURCE_INDEX_RECONFIGURE_IND2 & reconfigCQIRIRetValue) ||
            (RI_RESOURCE_INDEX_RECONFIGURE_IND2 & reconfigCQIRIRetValue))
    {
        pucchConfig_p->cqiPUCCHRBIndex = cqiPeriodicReqInfo_p->cqiPUCCHRBIndex;
        pucchConfig_p->cqiPucchResourceIndexV1020 = 
            cqiPeriodicReqInfo_p->cqiPucchResourceIndexV1020;
    }

    /* Default configuration parameters for Periodic CQI 
     * are always over written whenever 
     * reconfiguration message is recieved */ 

    if(CQI_DEFAULT_PARAMETERS_IND & reconfigCQIRIRetValue)
    {
        pucchConfig_p->cqiPmiRiInfo.periodicFeedBackType = (PeriodicFeedbackType)cqiPeriodicReqInfo_p->periodicFeedBackType;
        pucchConfig_p->cqiPmiRiInfo.periodicRepMode = (PeriodicReportingModes)cqiPeriodicReqInfo_p->periodicRepMode;
        pucchConfig_p->cqiPmiRiInfo.widebandPeriodicity  = cqiPeriodicReqInfo_p->widebandPeriodicity;
        pucchConfig_p->simultaneousAckNackAndCQI = cqiPeriodicReqInfo_p->simultaneousAckNackAndCQI;
        pucchConfig_p->simultaneousAckNackAndCQIV1020 = 
            cqiPeriodicReqInfo_p->simultaneousACKNACKAndCQIV1020;
    }
    switch(cqiPeriodicReqInfo_p->cqiPeriodicMsg)
    {
        case UL_RECONFIG_CQI_SUBBAND_K_MSG:
        pucchConfig_p->cqiPmiRiInfo.k = cqiPeriodicReqInfo_p->cqiFormatPeriodicSubbandK.subbandCQI_k;
        break;
        case UL_RECONFIG_CQI_SUBBAND_RI_MSG:
        pucchConfig_p->cqiPmiRiInfo.k = cqiPeriodicReqInfo_p->cqiFormatPeriodicSubbandK.subbandCQI_k;
        break;
        default: break;
    }
}

#ifdef FDD_CONFIG
void macPopulateScellCqiPeriodicInfo_dummy( PucchConfig *pucchConfig_p,ULCQIPeriodicReqInfo *cqiPeriodicReqInfo_p
        , InternalCellIndex internalCellIndex
        )
{
    macPopulateScellCqiPeriodicInfo( pucchConfig_p,cqiPeriodicReqInfo_p
            , internalCellIndex
            );
}
#endif

/****************************************************************************
 * Function Name  : macSendRrcPhyFailResponse
 * Inputs         : Message ID
 *                : Transaction Id
 *                : Internal cell Index
 * Outputs        : None
 * Returns        : Return Success
 * Description    : This function sends the failure response for PHY-RRC messages
 *****************************************************************************/
    UInt32 macSendRrcPhyFailResponse
(
 UInt16 msgId,
 UInt16 transactionId,
 RrcCellIndex cellIndex
 )
{
    SInt32 retVal = 0;
    switch(msgId)
    {
        case PHY_CONFIG_CELL_REQ:
        {
            retVal = sendPhyCellRespToRRC(PHY_CONFIG_CELL_CNF, 
                    transactionId, MAC_FAILURE, cellIndex);
            /*cov warning fix 12 june*/
            if(retVal == -1)
            {
                return MAC_FAILURE;
            }    
            break;
        }
        case PHY_CREATE_UE_ENTITY_REQ:
        {
            break;
        }
        case PHY_RECONFIG_UE_ENTITY_REQ:
        {
            break;
        }
        case PHY_DELETE_UE_ENTITY_REQ:
        {
            break;
        }
        case PHY_CHANGE_CRNTI_REQ:
        {
            break;
        }
        case PHY_RECONFIG_CELL_REQ:
        {
            break; 
        }
        case PHY_DELETE_CELL_REQ:
        {
            break;
        }
        case PHY_CELL_STOP_REQ:
        {
            break;
        } 
        case PHY_CELL_START_REQ:
        {
            break;
        }
        default:
        {
            break;
        }
    }

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : macSendRrcFailResponse
 * Inputs         : Message ID
 *                : Transaction Id
 *                : Intenal Cell Index
 * Outputs        : None
 * Returns        : Return Success
 * Description    : This function sends the failure response for RRC messages
 *****************************************************************************/
    UInt32 macSendRrcFailResponse
(
 UInt16 msgId,
 UInt16 transactionId,
 RrcCellIndex cellIndex
 )
{
    switch(msgId)
    {
        case MAC_CONFIG_CELL_REQ:
        {
            ConfigCellRes configCellRes = {0};
            configCellRes.response = MAC_FAILURE;
            configCellRes.transactionId = transactionId;
            configCellRes.errorType = MAC_RRC_ERROR_CELL_IN_INVALID_STATE;
            /* function that sends the confirmation message to RRC */
            if(MAC_SEND_ERROR == 
                    sendMsgToRRC(MAC_CONFIG_CELL_CNF, &configCellRes, cellIndex))
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
            }
            break;
        }
        case MAC_RECONFIG_CELL_REQ:
        {
            break;
        }
        case MAC_DELETE_CELL_REQ:
        {
            break;
        }
        case MAC_CELL_START_REQ:
        {
            break;
        }
        case MAC_CELL_STOP_REQ:
        {
            break;
        }
        case MAC_SFN_REQ:
        {
            break;
        }
        case MAC_CREATE_UE_ENTITY_REQ:
        {
            break;
        }
        case MAC_DELETE_UE_ENTITY_REQ:
        {
            break;
        }
        case MAC_RECONFIGURE_UE_ENTITY_REQ:
        {
            break;
        }
        case MAC_CHANGE_CRNTI_REQ:
        {
            break;
        }
        case MAC_RESET_UE_ENTITY_REQ:
        {
            break;
        }
        case MAC_HO_RACH_RESOURCE_REQ:
        {
            break;
        }
        /* +- SPR 19066 */ 
        default:
        {
            break;
        }
    }

    LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
            0xFFFFFFFF, MAC_FAILURE, cellIndex, 
            __LINE__, 
            DEFAULT_INT_VALUE, 
            DEFAULT_INT_VALUE, 
            DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
            FUNCTION_NAME, 
            "Either MAC Layer is not "
            "initialized yet or macPhyRegistration is not successful");

    return MAC_SUCCESS;
}

/*CA changes end*/
/* SPR 12240 Changes Start */
/******************************************************************************
 * Function Name  : parseCreateUECodebookSubsetRestrictionV1020 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the Codebook subset restrictionV1020 in 
 *                  Create UE Entity Request and fills in the structure needed  
 *                  by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECodebookSubsetRestrictionV1020( 
        UInt8 **msgBuf, UInt16 tagLen, UeContextForDownlink *dlCreateReq_p 
        ,InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p           = PNULL;
    UInt8  i               = 0;
    codebookSubsetRestrictionType  CbsrType = CBSR_INVALID;

    msg_p = *msgBuf;

    if ( tagLen != CODEBOOK_SUBSET_RESTRICTION_V1020_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for "
                "codebookSubsetRestriction MAC_CREATE_UE_ENTITY_REQ");
        return MAC_FAILURE;
    }
    CbsrType =  (codebookSubsetRestrictionType)*msg_p++;
    if(CbsrType > CBSR_TYPE_MAX_VAL)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid CbsrType %u in parseCreateUECodebookSubsetRestrictionV1020\n",CbsrType);
        return MAC_SYNTAX_ERROR_VAL;
    }
    /* Codebook subset restriction is supported for 
     * transmission modes 3, 4, 5, 6 and 8. 
     * TM Mode 9 is not supported in current release.
     */ 
    if((TX_MODE_3 == dlCreateReq_p->transmissionMode)||
            (TX_MODE_4 == dlCreateReq_p->transmissionMode)||
            (TX_MODE_5 == dlCreateReq_p->transmissionMode)||
            (TX_MODE_6 == dlCreateReq_p->transmissionMode)||
            (TX_MODE_8 == dlCreateReq_p->transmissionMode)
      )
    {
        dlCreateReq_p->cbsrInfo.cbsrType = CbsrType;
        /* TM 9 is not currently supported so storing only 8 bytes */
        for (i = 0; i < MAX_CBSR_SIZE; i++)
        {
            dlCreateReq_p->cbsrInfo.cbsrValue[i] = *msg_p++;
        }
        /* Moving the pointer 6 bytes ahead as we have stored only 8 bytes and total 
         * 14 bytes are present in the CBSR Value for V1020 tag */
        msg_p += MAX_CBSR_VALUE_COUNT - MAX_CBSR_SIZE;
        if (( validateCBSR(&dlCreateReq_p->cbsrInfo, (UInt8) dlCreateReq_p->transmissionMode, 
                        /* +- SPR 17777 */
                        internalCellIndex) != MAC_SUCCESS))
        {
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlCreateReq_p->cbsrInfo.cbsrType,
                    internalCellIndex,
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Atleast one bit should be 1 in "
                    "cbsrValue in MAC_CREATE_UE_ENTITY_REQ");
            return MAC_FAILURE;
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "codebookSubsetRestriction received for "
                "TM other than 3,4,5,6 in MAC_CREATE_UE_ENTITY_REQ");
        return MAC_FAILURE;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseRecfgCodebookSubRestrictionV1020 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the API message 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  currentTransmissionMode - current configured transmission mode
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the codebook subset restrictionV1020
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC for a Release 10 UE.
 *****************************************************************************/
STATIC  MacRetType parseRecfgCodebookSubRestrictionV1020 (UInt8 **msgBuf, 
        UInt8                tagLen,
        UeContextForDownlink *dlUEInfo_p, 
        UInt8                currentTransmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p = PNULL;
    UInt8 i = 0;
    codebookSubsetRestrictionType  CbsrType = CBSR_INVALID;

    msg_p = *msgBuf;

    if ( CODEBOOK_SUBSET_RESTRICTION_V1020_TAG_LEN != tagLen )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for codebookSubsetRestriction "
                "in MAC_RECONFIGURE_UE_ENTITY_REQ");
        return MAC_SYNTAX_ERROR_VAL;
    }
    CbsrType =  (codebookSubsetRestrictionType)*msg_p++;

    if(CbsrType > CBSR_TYPE_MAX_VAL)
    {
        return MAC_SYNTAX_ERROR_VAL;
    }

    if(((INVALID_TRANS_MODE == dlUEInfo_p->transmissionMode) && 
                (
                 (TX_MODE_3 == currentTransmissionMode)||
                 (TX_MODE_4 == currentTransmissionMode)||
                 (TX_MODE_5 == currentTransmissionMode)||
                 (TX_MODE_6 == currentTransmissionMode)||
                 (TX_MODE_8 == currentTransmissionMode)
                )
       ) ||
            (TX_MODE_3 == dlUEInfo_p->transmissionMode)||
            (TX_MODE_4 == dlUEInfo_p->transmissionMode)||
            (TX_MODE_5 == dlUEInfo_p->transmissionMode)||
            (TX_MODE_6 == dlUEInfo_p->transmissionMode)||
            (TX_MODE_8 == dlUEInfo_p->transmissionMode))
    {
        /* Reconfiguration of CBSR without changing transmission mode
         * or by reconfiguring the transmission mode
         */
        dlUEInfo_p->cbsrInfo.cbsrType = CbsrType;
        /* TM 9 is not currently supported so storing only 8 Bytes */
        for (i = 0; i < MAX_CBSR_SIZE; i++)
        {
            dlUEInfo_p->cbsrInfo.cbsrValue[i] = *msg_p++;
        }
        /* Moving the pointer 6 bytes ahead as we have stored only 8 bytes and total 
         * 14 bytes are present in the CBSR Value for V1020 tag */
        msg_p += MAX_CBSR_VALUE_COUNT - MAX_CBSR_SIZE;

        if((INVALID_TRANS_MODE == dlUEInfo_p->transmissionMode) &&
                (
                 (TX_MODE_3 == currentTransmissionMode)||
                 (TX_MODE_4 == currentTransmissionMode)||
                 (TX_MODE_5 == currentTransmissionMode)||
                 (TX_MODE_6 == currentTransmissionMode)||
                 (TX_MODE_8 == currentTransmissionMode)
                )
          )
        {
            /* +- SPR 17777 */
            if(MAC_SUCCESS != validateCBSR(&(dlUEInfo_p->cbsrInfo),
                        currentTransmissionMode,
                        internalCellIndex)
              )
                /* +- SPR 17777 */
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEInfo_p->cbsrInfo.cbsrType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Atleast one bit should be 1 in "
                        "cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ");
                return MAC_FAILURE;
            }
        }
        else
        {
            /* +- SPR 17777 */
            if(MAC_SUCCESS != validateCBSR(&(dlUEInfo_p->cbsrInfo),
                        dlUEInfo_p->transmissionMode,
                        internalCellIndex)
              )
                /* +- SPR 17777 */
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEInfo_p->cbsrInfo.cbsrType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Atleast one bit should be 1 in "
                        "cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ");
                return MAC_FAILURE;
            }
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "codebookSubsetRestriction received for TM "
                "other than 3,4,5,6,8 in MAC_RECONFIGURE_UE_ENTITY_REQ");
        return MAC_SYNTAX_ERROR_VAL;
    }
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/******************************************************************************
 * Function Name  : parseCreateUECodebookSubsetRestrictionV920 
 * Inputs         : msgBuf - pointer to the input buffer
 *                  tagLen - Length of the tag
 *                  dlCreateReq_p - pointer to Downlink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function parse the Codebook subset restrictionV920 for 
 *                  Rel 9 TM8 UE in Create UE Entity Request and fills in the structure 
 *                  needed by MAC to create a UE context.
 ******************************************************************************/
STATIC  MacRetType parseCreateUECodebookSubsetRestrictionV920( 
        UInt8 **msgBuf, UInt16 tagLen, UeContextForDownlink *dlCreateReq_p 
        ,InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p           = PNULL;
    UInt8  i               = 0;
    codebookSubsetRestrictionType  CbsrType = CBSR_INVALID;

    msg_p = *msgBuf;

    if ( tagLen != CODEBOOK_SUBSET_RESTRICTION_V920_TAG_LEN )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for "
                "codebookSubsetRestriction MAC_CREATE_UE_ENTITY_REQ");
        return MAC_FAILURE;
    }
    CbsrType =  (codebookSubsetRestrictionType)*msg_p++;
    if(CbsrType > CBSR_TYPE_MAX_VAL_V920)
    {
        LOG_MAC_ERROR(MAC_RRC_INF,"Invalid CbsrType :%u \n",CbsrType);
        return MAC_SYNTAX_ERROR_VAL;
    }
    if(TX_MODE_8 == dlCreateReq_p->transmissionMode)
    {
        dlCreateReq_p->cbsrInfo.cbsrType = CbsrType;
        /* Reading only 4 bytes which will come for Rel 9 TM8 UE*/
        for (i = 0; i < MAX_CBSR_VALUE_COUNT_V920; i++)
        {
            dlCreateReq_p->cbsrInfo.cbsrValue[i] = *msg_p++;
        }
        /* +- SPR 17777 */
        if (( validateCBSR(&dlCreateReq_p->cbsrInfo, (UInt8) dlCreateReq_p->transmissionMode, 
                        internalCellIndex) != MAC_SUCCESS))
            /* +- SPR 17777 */
        {
            LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    dlCreateReq_p->cbsrInfo.cbsrType,
                    internalCellIndex,
                    __LINE__, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_INT_VALUE, 
                    DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME, 
                    "Atleast one bit should be 1 in "
                    "cbsrValue in MAC_CREATE_UE_ENTITY_REQ");
            return MAC_FAILURE;
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlCreateReq_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "codebookSubsetRestriction received for "
                "other than TM8 in MAC_CREATE_UE_ENTITY_REQ");
        return MAC_FAILURE;
    }

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parseRecfgCodebookSubRestrictionV920 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the API message 
 *                  dlUEInfo_p - Ptr to a structure to be filled for DL
 *                  currentTransmissionMode - current configured transmission mode
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the codebook subset restrictionV920
 *                  and updates the DL structure for UE context
 *                  reconfiguration at MAC for a Release 9 TM8 UE.
 *****************************************************************************/
STATIC  MacRetType parseRecfgCodebookSubRestrictionV920 (UInt8 **msgBuf, 
        UInt8                tagLen,
        UeContextForDownlink *dlUEInfo_p, 
        UInt8                currentTransmissionMode,
        InternalCellIndex internalCellIndex
        )
{
    UInt8 *msg_p = PNULL;
    UInt8 i = 0;
    codebookSubsetRestrictionType  CbsrType = CBSR_INVALID;

    msg_p = *msgBuf;

    if ( CODEBOOK_SUBSET_RESTRICTION_V920_TAG_LEN != tagLen )
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for codebookSubsetRestriction "
                "in MAC_RECONFIGURE_UE_ENTITY_REQ");
        return MAC_SYNTAX_ERROR_VAL;
    }
    CbsrType =  (codebookSubsetRestrictionType)*msg_p++;

    if(CbsrType > CBSR_TYPE_MAX_VAL_V920)
    {
        return MAC_SYNTAX_ERROR_VAL;
    }

    if(((INVALID_TRANS_MODE == dlUEInfo_p->transmissionMode) && 
                (TX_MODE_8 == currentTransmissionMode)) ||
            (TX_MODE_8 == dlUEInfo_p->transmissionMode))
    {
        /* Reconfiguration of CBSR without changing transmission mode
         * or by reconfiguring the transmission mode
         */
        dlUEInfo_p->cbsrInfo.cbsrType = CbsrType;
        /* Reading only 4 bytes which will come for Rel 9 TM8 UE*/
        for (i = 0; i < MAX_CBSR_VALUE_COUNT_V920; i++)
        {
            dlUEInfo_p->cbsrInfo.cbsrValue[i] = *msg_p++;
        }

        if((INVALID_TRANS_MODE == dlUEInfo_p->transmissionMode) && 
                (TX_MODE_8 == currentTransmissionMode))          
        {
            /* +- SPR 17777 */
            if(MAC_SUCCESS != validateCBSR(&(dlUEInfo_p->cbsrInfo),
                        currentTransmissionMode,
                        internalCellIndex)
              )
                /* +- SPR 17777 */
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEInfo_p->cbsrInfo.cbsrType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Atleast one bit should be 1 in "
                        "cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ");
                return MAC_FAILURE;
            }
        }
        else
        {
            /* +- SPR 17777 */
            if(MAC_SUCCESS != validateCBSR(&(dlUEInfo_p->cbsrInfo),
                        dlUEInfo_p->transmissionMode,
                        internalCellIndex)
              )
                /* +- SPR 17777 */
            {
                LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        dlUEInfo_p->cbsrInfo.cbsrType,
                        internalCellIndex, 
                        __LINE__, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_INT_VALUE, 
                        DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME, 
                        "Atleast one bit should be 1 in "
                        "cbsrValue in MAC_RECONFIGURE_UE_ENTITY_REQ");
                return MAC_FAILURE;
            }
        }
    }
    else
    {
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                dlUEInfo_p->transmissionMode,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "codebookSubsetRestriction not received for "
                "TM8 in MAC_RECONFIGURE_UE_ENTITY_REQ");
        return MAC_SYNTAX_ERROR_VAL;
    }
    *msgBuf = msg_p;
    return MAC_SUCCESS;
}
/* SPR 12240 Changes End */

/* Cyclomatic_complexity_changes_start */
/****************************************************************************
 * Function Name  : parseSfnGapInfo 
 * Inputs         : cellState - cell state,
 *                  cellParams_p - cellParams_p
 *                  remLen - Pointer to remaining length of API message,
 *                  msgBuf - pointer that address of data read from socket,
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UL Sync Loss Timer information
 *                  received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
MacRetType parseSfnGapInfo(CellState cellState,
        CellConfigParams *cellParams_p,
        UInt16 *remLen,
        UInt8  **msgBuf,
        InternalCellIndex internalCellIndex)
{
    UInt8  sfnGap = 0;
    UInt8 *msg_p = PNULL;
    msg_p = *msgBuf;

    /* Cell Start Stop Chg */
    /* CA Changes start */ 
    if ((CELL_WAIT_FOR_PHY_START == cellState) ||
            (CELL_WAITING_FOR_FIRST_SFI == cellState))
    {
        sfnGap = *msg_p++;
        *remLen -= 1;
        cellParams_p->sfnGap = sfnGap;
        /* CA Changes end */ 
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_SFN_GAP_INFO_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                sfnGap,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_SFN_GAP_INFO_PARAM");
        /* Review comment fix end SYNC_LOSS_1*/
    }
    else
    {
        /* Ignore the SFN Gap IE */
        /*+SPR 3416*/
        /* SPR 12813 Changes Start */
        msg_p += 1;
        /* SPR 12813 Changes End */
        *remLen -= 1;
        /*-SPR 3416*/
    }

    *msgBuf = msg_p;

    return MAC_SUCCESS;
}

/****************************************************************************
 * Function Name  : parsePuschConfigCommonInfo
 * Inputs         : tagLen - tag length,
 *                  sfn - system frame num
 *                  sf - subframe
 *                  remLen - Pointer to remaining length of API message,
 *                  msgBuf - pointer that address of data read from socket,
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse the UL Sync Loss Timer information
 *                  received in MAC_RECONFIG_CELL_REQ.
 ****************************************************************************/
MacRetType parsePuschConfigCommonInfo(UInt16 tagLen,
        UInt16 sfn,
        UInt8 sf,
        UInt16 *remLen,
        UInt8  **msgBuf,
        InternalCellIndex internalCellIndex)
{
    ReconfigPuschConfigCommon *reconfig_p = PNULL;
    MacRetType retval = MAC_SUCCESS;
    UInt8 *msg_p = PNULL;

    msg_p = *msgBuf;

    if((*remLen >= PUSCH_CONFIG_COMMON_PARAM_LENGTH) && (PUSCH_CONFIG_COMMON_TAG_LEN == tagLen))
    {
        /* CA Changes start */
        reconfig_p = 
            &(reconfigMacCell_g[internalCellIndex].reconfigPuschConfigCommon);
        /* CA Changes end */
        reconfig_p->targetSfn = sfn;
        reconfig_p->targetSf = sf;
        reconfig_p->reconfigEnable64Qam = *msg_p;
        reconfig_p->updateFlag = TRUE;
        /* CA Changes start */
        reconfigMacCell_g[internalCellIndex].reconfigUpdate++;
        /* CA Changes end */
        msg_p += 1;
        /*Updating the remLen*/
        *remLen -=  PUSCH_CONFIG_COMMON_PARAM_LENGTH;
        /* Review comment fix start SYNC_LOSS_1*/
        LOG_MAC_MSG(MAC_PUSCH_CONFIG_COMMON_PARAM,LOGINFO,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                reconfig_p->reconfigEnable64Qam,
                internalCellIndex, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, "MAC_PUSCH_CONFIG_COMMON_PARAM:ReconfigCellReq");
        /* Review comment fix end SYNC_LOSS_1*/
        *msgBuf = msg_p;
    }
    else
    {
        retval = MAC_FAILURE;
    }


    return retval;
}

/****************************************************************************
 * Function Name  : resetSecondCellInResetUeReq
 * Inputs         : ueDLContext_p
 *                  rrcOamPendReq_p
 *                  ueIndex
 *                  ueCellInfo_p
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function reset the second Cell Context in reset UE
 *                  request.
 ****************************************************************************/
void resetSecondCellInResetUeReq(DLUEContext *ueDLContext_p,
        ULUEContext *ueULContext_p,
        LP_RrcOamPendingReq rrcOamPendReq_p,
        UInt16 ueIndex,
        UeCellInfo  *ueCellInfo_p,
        InternalCellIndex internalCellIndex)
{
    UInt8               servCellIndex = 0;
    DLUESCellContext   *dlUeScellContext_p = PNULL;
    /** SPR 12320 Fix : Start **/
    ULUESCellContext   *ulUeScellContext_p = PNULL;
    ScellPucchConfig   *tempSCellPucchConfigInfo_p = PNULL;
    /** SPR 12320 Fix : End **/

    for(servCellIndex = START_SCELL_INDEX; servCellIndex <= ueDLContext_p->\
            scellCount ;servCellIndex++)
    {
        dlUeScellContext_p = ueDLContext_p->\
                             dlUeScellContext_p[servCellIndex];

        /** SPR 12320 Fix : START **/
        ulUeScellContext_p = ueULContext_p->\
                             ulUeScellContext_p[servCellIndex];

        if (PNULL != ulUeScellContext_p)
        {
            tempSCellPucchConfigInfo_p = 
                &(ulUeScellContext_p->scellpucchConfigInfo); 
        }
        /** SPR 12320 Fix : END **/
        if(PNULL != dlUeScellContext_p)
        {
            /*
             * In case of scellRelFlag 
             * is LTE_TRUE then all scell Context will be released
             */
            if(LTE_TRUE == rrcOamPendReq_p->dlscellRelFlag)
            {
                if (MAC_FAILURE == 
                        macDeleteScellMACDLHarqEntity(ueDLContext_p,
                            servCellIndex,
                            dlUeScellContext_p->internalCellIndex))
                {
                    lteWarning ("\n macDeleteScellMACDLHarqEntity() failed for"
                            "servCellIndex :%d \n",servCellIndex);
                }
                /** SPR 12320 Changes Start **/
                /** SPR 14282 Changes : #ifdef FDD removed **/ 
                deleteSCellPucchNodesForUE( tempSCellPucchConfigInfo_p, WIDEBAND_CQI_REPORT,
                        ueCellInfo_p, internalCellIndex, ueIndex);
                deleteSCellPucchNodesForUE( tempSCellPucchConfigInfo_p, CQI_REPORT ,
                        ueCellInfo_p, internalCellIndex,ueIndex);
                deleteSCellPucchNodesForUE( tempSCellPucchConfigInfo_p, RI_REPORT ,
                        ueCellInfo_p, internalCellIndex,ueIndex);
                if(ueDLContext_p->scellCount)
                {
                    ueDLContext_p->scellCount--;
                }
                if(ueULContext_p->scellCount)
                {
                    ueULContext_p->scellCount--;
                } 
                ueDLContext_p->dlUeScellContext_p[servCellIndex]= PNULL;
                if (ueULContext_p->ulUeScellContext_p[servCellIndex] != PNULL)
                {
                    freeMemPool(ueULContext_p->ulUeScellContext_p[servCellIndex]);
                    ueULContext_p->ulUeScellContext_p[servCellIndex] = PNULL;
                } 
                freeMemPool(dlUeScellContext_p);
                dlUeScellContext_p = PNULL;
                /** SPR 12320 Changes End **/
            }
            else
            {
                resetMACDLHarqEntity
                    (&(dlUeScellContext_p->ScelldlHarqContext_p));
            }
        }
    }

    return;
}

/****************************************************************************
 * Function Name  : processRRCMsgForPhy
 * Inputs         : msgId
 *                  destModuleId
 *                  msgLen
 *                  msgBuf_p
 *                  transactionId
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : None
 * Description    : This function handles RRC message for PHY.
 ****************************************************************************/
void processRRCMsgForPhy(UInt16 msgId,
        UInt16 destModuleId,
        UInt16 msgLen,
        UInt8 *msgBuf_p,
        UInt16 transactionId,
        InternalCellIndex internalCellIndex)
{
    UInt8 *data_p        = PNULL;

    switch(msgId)
    {
        case PHY_CONFIG_CELL_REQ:
        {
            processRRCPhyConfigCellReq (msgId, msgLen, 
                    msgBuf_p, transactionId,internalCellIndex);

            /* CA Changes end */
            /* Cyclomatic Complexity changes - ends here */
            break;	
        }
        case PHY_CREATE_UE_ENTITY_REQ:
        {
            LOG_MAC_MSG(RRC_PHY_CREATE_UE_REQ_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    destModuleId,msgId,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PHY_CREATE_UE_REQ_RECVD");
            data_p = msgBuf_p;
            if (MAC_SUCCESS == ueConfigHandler(
                        transactionId,
                        data_p + PHY_API_HEADER_LEN,
                        /* +- SPR 17777 */
                        internalCellIndex))
            {
                LOG_MAC_MSG(RRC_PHY_CREATE_UE_REQ_ID,LOGWARNING,MAC_RRC_INF,
                        GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                        destModuleId,msgId,internalCellIndex,
                        DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                        DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                        FUNCTION_NAME,"PHY_CREATE_UE_SUCCESS");
            }
            break;
        }
        case PHY_RECONFIG_UE_ENTITY_REQ:
        {
            LOG_MAC_MSG(RRC_PHY_RECONFIG_UE_ENTITY_REQ_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    destModuleId,msgId,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PHY_RECONFIG_UE_ENTITY_REQ_RECVD");
            data_p = msgBuf_p;
            if(MAC_SEND_ERROR == handleUeReconfigReq(data_p + PHY_API_HEADER_LEN,
                        transactionId, internalCellIndex
                        ))
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
            }
            break;
        }
        case PHY_DELETE_UE_ENTITY_REQ:
        {
            LOG_MAC_MSG(RRC_PHY_DELETE_UE_ENTITY_REQ_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    destModuleId,msgId,internalCellIndex,
                    DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"PHY_DELETE_UE_ENTITY_REQ_RECVD");

            data_p = msgBuf_p;
            if(MAC_SEND_ERROR == handleUeDeleteReq(data_p + PHY_API_HEADER_LEN,
                        transactionId, internalCellIndex
                        ))
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
            }
            break;
        }
        case PHY_CHANGE_CRNTI_REQ:
        {
            data_p = msgBuf_p;
            if(MAC_SEND_ERROR == handlePhyChangeCrntiReq(data_p + PHY_API_HEADER_LEN,
                        transactionId, internalCellIndex
                        ))
            {
                ALARM_MSG (MAC_MODULE_ID, SEND_MSG_FAILED_ALARM_ID, MAJOR_ALARM);
            }
            break;
        }
        case PHY_RECONFIG_CELL_REQ:
        {
            processRRCPhyReconfigCellReq (msgId, msgLen, 
                    msgBuf_p, transactionId,internalCellIndex);
            break; 
        }/* PHY_RECONFIG_CELL_REQ */
        case PHY_DELETE_CELL_REQ: /*PHY_DELETE_CELL_REQ starts*/
        {
#ifdef MSPD_WATCH_DOG
            is_phy_running = FALSE; 
#endif

            /* SPR 23393 Changes Start */
            fprintf(stderr,"PHY DELETE REQ RECEIVED FROM L3\n"); 
            /* SPR 23393 Changes End */
            /* +- SPR 17777 */
            processRRCPhyDeleteCellReq (msgId,
                    msgBuf_p, transactionId
                    ,internalCellIndex
                    );
            //cell_state_changes
            break;
        } /*PHY_DELETE_CELL_REQ ends*/
        case PHY_CELL_STOP_REQ: /* Cell Start Stop Chg */
        {
#ifdef MSPD_WATCH_DOG
            is_phy_running = FALSE; 
#endif
            /* +- SPR 17777 */
            /* SPR 23393 Changes Start */
            fprintf(stderr,"PHY STOP REQ RECEIVED FROM L3\n"); 
            /* SPR 23393 Changes End */
            processRRCPhyCellStopReq (msgId,
                    msgBuf_p, transactionId, internalCellIndex);
            break;
        } 
        case PHY_CELL_START_REQ:
        {
            /* +- SPR 17777 */
            processRRCPhyCellStartReq (msgId,
                    msgBuf_p, transactionId, internalCellIndex);
            break;
        }/* Cell Start Stop Chg*/
        default:
        break;
    }

    return;
}

/****************************************************************************
 * Function Name  : getPRSBandwidth
 * Inputs         : prsParseConfigInfo_p
 *                  prsBandwidth
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function validates the 
 ****************************************************************************/
MacRetType getPRSBandwidth(PRSParseConfigInfo *prsParseConfigInfo_p,
        UInt8 prsBandwidth,
        InternalCellIndex internalCellIndex)
{
    MacRetType response = MAC_SUCCESS;

    switch(prsBandwidth)
    {
        case DL_RES_BLKS_6RBS:
        prsParseConfigInfo_p->prsBandwidth = DL_BW_1DOT4_MHZ;
        break;

        case DL_RES_BLKS_15RBS:
        prsParseConfigInfo_p->prsBandwidth = DL_BW_3_MHZ;
        break;

        case DL_RES_BLKS_25RBS:
        prsParseConfigInfo_p->prsBandwidth = DL_BW_5_MHZ;
        break;

        case DL_RES_BLKS_50RBS:
        prsParseConfigInfo_p->prsBandwidth = DL_BW_10_MHZ;
        break;

        case DL_RES_BLKS_75RBS:
        prsParseConfigInfo_p->prsBandwidth = DL_BW_15_MHZ;
        break;

        case DL_RES_BLKS_100RBS:
        prsParseConfigInfo_p->prsBandwidth = DL_BW_20_MHZ;
        break;

        default:
        response = MAC_FAILURE;

        LOG_MAC_MSG(MAC_INVALID_PARAMETER_RECEIVED_ID,LOGWARNING,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),DEFAULT_INT_VALUE,
                prsBandwidth,
                internalCellIndex,
                DEFAULT_INT_VALUE,DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,"INVALID_PRS_BANDWIDTH_VAL");
        break;
    }

    return response;
}

/****************************************************************************
 * Function Name  : checkForOpCode
 * Inputs         : opCode : Received opcode
 * Outputs        : None
 * Returns        : Parsed opcode
 * Description    : This function validates the opCode
 ****************************************************************************/
STATIC RRCTag checkForOpCode(LCOperationType opCode)
{
    if (ADD == opCode)
    {
        return CREATE_LC_ERROR;
    }
    else if (RECONFIGURE == opCode)
    {
        return RECONFIGURE_LC_ERROR;
    }
    else if (DELETE == opCode)
    {
        return DELETE_LC_ERROR;
    }
    else
    {
        /* SPR 22579 Coverity Changes + */
        return  (RRCTag)INVALID_SCELL_OPERATION_TYPE; 
        /* SPR 22579 Coverity Changes - */
    }
}
/****************************************************************************
 * Function Name  : readDataFromRxSockFd
 * Inputs         : msgHdr : Pointer to message
 *                  msgLen : Message len
 *                  flag : Receiving mode
 * Outputs        : None
 * Returns        : number of bytes received
 * Description    : This function find number of bytes received.
 ****************************************************************************/
SInt32 readDataFromRxSockFd(UInt8 *msgHdr ,UInt32 msgLen ,
        SInt32 flag,InternalCellIndex internalCellIndex)
{
    SInt32 bytesRead = 0;

    if (( bytesRead = recvfrom_wrapper(rxSockFD_g,msgHdr,msgLen, flag,PNULL, 0))
            == MAC_RECV_ERROR)
        /* SPR 6949 Fix End */
    {
        if ( errno != EAGAIN )
        {
            LOG_MAC_MSG(OAM_RRC_INVALID_MSG_LEN_ID,LOGWARNING,MAC_RRC_INF,
                    GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                    errno,bytesRead,LINE_NUMBER,
                    internalCellIndex,DEFAULT_INT_VALUE,
                    DEFAULT_FLOAT_VALUE,DEFAULT_FLOAT_VALUE,
                    FUNCTION_NAME,"INVALID_MSG");
        }
        return MAC_RECV_ERROR; 
    }
    return bytesRead;
}
/****************************************************************************
 * Function Name  : prepareReconfigDLULUEContext 
 * Inputs         : msg_p : Pointer to message
 *                  ulUEInfo_p : UeContextForUplink
 *                  dlUEInfo_p : UeContextForDownlink
 * Outputs        : None
 * Returns        : None
 * Description    : This function initializes the dl/ul ue contexts for Reconfiguration.
 ****************************************************************************/
/*cyclomatic fix start*/
STATIC  void prepareReconfigDLULUEContext(UeContextForUplink *ulUEInfo_p,
        UeContextForDownlink *dlUEInfo_p)
{
    ulUEInfo_p->numLogicalChannels = 0;
    dlUEInfo_p->dwlkLogicalChCount = 0;
    /* - CL-MIMO LJA*/
    dlUEInfo_p->cbsrInfo.cbsrType = CBSR_INVALID;
    /* - CL-MIMO LJA*/
    dlUEInfo_p->cqiInfoFlag      = FALSE;
    ulUEInfo_p->cqiinfoflag      = FALSE;
    ulUEInfo_p->cqiRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    /* + SPR 5953 Fix */ 
    dlUEInfo_p->cqiRequestType = INVALID_PERIODIC_CQI_REQ_TYPE;
    /* - SPR 5953 Fix */ 
    ulUEInfo_p->simultaneousACKNACKAndCQI = INVALID_SIMULTANEOUS_ACK_NACK_VALUE;

    dlUEInfo_p->maxRB            = INVALID_RB;

    /* SPR_4410 Fix Start */
    dlUEInfo_p->transmissionMode = INVALID_TX_MODE;
    /* SPR_4410 Fix End */

    dlUEInfo_p->cbsrInfo.cbsrType = CBSR_INVALID;

    dlUEInfo_p->rankIndicator = INVALID_RANK_INDICATOR;

    dlUEInfo_p->precodingIndex   = INVALID_CODE_BOOK_INDEX;
    ulUEInfo_p->requestType      = INVALID_SR_REQ_TYPE;

    dlUEInfo_p->ueCategory = INVALID_UE_CATEGORY;
    /* Coverity 55028 55029*/
    dlUEInfo_p->numHarqProcess = MAC_MAX_NUM_HARQ;
    ulUEInfo_p->uePriority = MAC_MAX_UEPRIORITY;
    /* Coverity 55028 55029*/
    ulUEInfo_p->ueCategory = INVALID_UE_CATEGORY;
    /* + SPR_12569 */
    ulUEInfo_p->ueComplianceRelease = INVALID_RELEASE; 
    /* - SPR_12569 */ 
    ulUEInfo_p->srsRequestType = FALSE;

    /* + DRX_CHG */
    dlUEInfo_p->drxRequestType = FALSE;
    /* - DRX_CHG */
    /* +MEAS_GAP_CHG */
    dlUEInfo_p->measGapRequestType = FALSE;
    /* - MEAS _GAP_CHG */
    /*SPR_3061_FIX*/
    /*SPR_3061_FIX*/
    /* SPR 2454 changes end */
    /*SPR 2617 Start*/
    ulUEInfo_p->riConfigIndex = MAC_RI_CONFIG_INDEX_INVALID;
    /*SPR 2617 End*/
    /*SPR_3061_FIX*/
    dlUEInfo_p->timeAlignmentTimer      = 0;
    /*SPR_3061_FIX*/


}
/****************************************************************************
 * Function Name  : macCheckOperationTypeForUeCategory 
 * Inputs         : dlReconfigScellInfo_p : DLSCELLReconfigInfo 
 *                  dlUEContext_p : DLUEContext
 *                  scellIndex : scell index
 *                  internalCellIndex : InternalCellIndex
 * Outputs        : None
 * Returns        : None
 * Description    : This function Check operation type and assign ue category.
 ****************************************************************************/
STATIC MacRetType macCheckOperationTypeForUeCategory(DLSCELLReconfigInfo *dlReconfigScellInfo_p,
        DLUEContext *dlUEContext_p,UInt8 scellIndex,InternalCellIndex internalCellIndex)  
{   
    if (ADD == dlReconfigScellInfo_p->operationType)
    {
        /* SPR 11355 Fix Start */
        dlUEContext_p->ueCategory = dlUEContext_p->ueCategoryV1020;
        /* SPR 11355 Fix End */
        return MAC_SUCCESS;
    }
    else
    {
        /* SPR 11355 Fix Start */
        if(dlUEContext_p->ueCategory == 6 || dlUEContext_p->ueCategory == 7 )  
        {
            dlUEContext_p->ueCategory = 4;
        }
        else if(dlUEContext_p->ueCategory == 8 )  
        {
            dlUEContext_p->ueCategory = 5;
        }
        /* SPR 11355 Fix End */
        macDeleteDLScellContext(dlUEContext_p,scellIndex,internalCellIndex);
        return MAC_SUCCESS;
    }
}
/*cyclomatic fix end*/ 
/* Cyclomatic_complexity_changes_end */

/* + SPS_TDD_Changes */
/****************************************************************************
 * Function Name  : checkMeasGapAndSendUEForSPSDeactDL 
 * Inputs         : dlUEContext_p- DL Context of UE
 ulUEContext_p - UL Context of Ue
 * Outputs        : None
 * Returns        : None
 * Description    : This function release the SPS resources reserved for UE and 
 *                  put entry in deactivation queue
 *****************************************************************************/
static void checkMeasGapAndSendUEForSPSDeactDL( DLUEContext * dlUEContext_p,
        InternalCellIndex internalCellIndex)
{
    LP_MacDlSpsDeactReq  macDlSpsDectReq_p = PNULL;

    /*If SPS TTI Index lies in measgap then :
     * 1. In case of SPS_ACTIVATED ,state deactivation will be sent to UE.
     * 2. In case of SPS_ACTIVATION_INITIATED state, we will implicitly release SPS 
     *    and if SPS data needs to be scheduled then SPS will be reactivated.
     */

    if ( (TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.enableSps) &&\
            ((dlUEContext_p->spsDlInfo.spsState == SPS_ACTIVATED)||\
             (dlUEContext_p->spsDlInfo.spsState == SPS_ACTIVATION_INITIATED)))
    {
        if (MEAS_GAP_ON == dlUEContext_p->spsDlInfo.ueMeasGapTTI[dlUEContext_p->spsDlInfo.ttiIndex])
        {
            if( MAC_FAILURE == dlStateMachine[dlUEContext_p->spsDlInfo.spsState]
                    [MEAS_GAP_RECONFIG]( dlUEContext_p->ueIndex,
                        dlUEContext_p->spsDlInfo.spsState,
                        MEAS_GAP_RECONFIG, dlUEContext_p, PNULL
                        /* + SPS_TDD_Changes*/
#ifdef FDD_CONFIG
                        ,PHY_DL_DELAY
#else
                        ,DL_ADVANCE_TICK
#endif                        
                        /* - SPS_TDD_Changes*/
                        ,internalCellIndex) )
            {
                /* Allocate the memory for deactivation queue node */
                macDlSpsDectReq_p = (LP_MacDlSpsDeactReq)getMemFromPool(
                        sizeof(MacDlSpsDeactReq), PNULL);
                /* Fill deactivation queue node */
                /*CoverityId:87591; SPR:19339*/
                if(PNULL != macDlSpsDectReq_p)
                {
                    macDlSpsDectReq_p->ueIndex =  dlUEContext_p->ueIndex;
                    macDlSpsDectReq_p->cause = MEAS_GAP_RECONFIG;
                    /* Enqueue the node to deactivation queue so that it
                     *                  * can be processed in next tick */
                    if (MAC_FAILURE == ENQUEUE_MAC_DL_SPS_Q( dlSpsDeactQ_gp[internalCellIndex],
                                macDlSpsDectReq_p ))
                    {
                        ltePanic("Enqueue DL SPS Failed\n");
                    }
                }
                else
                {
                    LOG_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL,
                            L2_SYS_FAIL, getCurrentTick(), __LINE__,
                            sizeof(MacDlSpsDeactReq), 0, 0, 0, 0,0,
                            __FILE__, __func__);
                    ALARM_MSG( MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID,
                            CRITICAL_ALARM);
                    ltePanic("getMemFromPool fails %s", __func__);
                }
                /*CoverityId:87591; SPR:19339*/
                /* Update Q Stats */
                LTE_MAC_QUEUE_USED( DL_SPS_DEACT_Q,
                        QCOUNT_MAC_DL_SPS_Q( dlSpsDeactQ_gp[internalCellIndex] ),
                        internalCellIndex);
            }

        }

    }
}
/****************************************************************************
 * Function Name  : checkMeasGapAndSendUEForSPSDeactUL 
 * Inputs         : dlUEContext_p- DL Context of UE
 ulUEContext_p - UL Context of Ue
 * Outputs        : None
 * Returns        : None
 * Description    : This function release the SPS resources reserved for UE and 
 *                  put entry in deactivation queue
 *****************************************************************************/
static void checkMeasGapAndSendUEForSPSDeactUL( ULUEContext * ulUEContext_p,
        InternalCellIndex internalCellIndex)
{
    LP_MacULSpsDeactReq  macUlSpsDectReq_p = PNULL;

    /*If SPS TTI Index lies in measgap then :
     * 1. In case of SPS_ACTIVATED ,state deactivation will be sent to UE.
     * 2. In case of SPS_ACTIVATION_INITIATED state, we will implicitly release SPS 
     *    and if SPS data needs to be scheduled then SPS will be reactivated.
     */

    if ( (TRUE == cellSpecificParams_g.cellConfigAndInitParams_p\
                [internalCellIndex]->initParams_p->spsSysWideParam.enableSps) &&\
            ((ulUEContext_p->spsUlInfo.spsState == SPS_ACTIVATED)||\
             (ulUEContext_p->spsUlInfo.spsState == SPS_ACTIVATION_INITIATED)))
    {
        if (MEAS_GAP_ON == ulUEContext_p->spsUlInfo.ueMeasGapTTI[ulUEContext_p->spsUlInfo.actTtiIndex])
        {
#ifdef FDD_CONFIG
            LP_MacULSpsStatus dataReq_p = PNULL;
            dataReq_p = (LP_MacULSpsStatus)getMemFromPool( sizeof(MacULSpsStatus), PNULL);

            /*coverityId:98803;SPR:19339 */
            if ( PNULL != dataReq_p  )
            {

                dataReq_p->ueIndex = ulUEContext_p->ueIndex;
                dataReq_p->response = MEAS_GAP_RECONFIG;
                dataReq_p->requestType = 0;
                dataReq_p->spsOpp = 0;
                dataReq_p->numRbs = 0;

                if( MAC_FAILURE == ulStateMachine[ulUEContext_p->spsUlInfo.spsState]
                        [MEAS_GAP_RECONFIG]( ulUEContext_p->ueIndex,
                            ulUEContext_p->spsUlInfo.spsState,
                            MEAS_GAP_RECONFIG, ulUEContext_p, dataReq_p,
                            PHY_DL_DELAY, internalCellIndex
                            ) 
                  )
                {
                    /* Coverity 88647 Fix Start */
                    freeMemPool(dataReq_p);
                    dataReq_p = PNULL;
                    /* Coverity 88647 Fix End */
                    /* Allocate the memory for deactivation queue node */
                    macUlSpsDectReq_p = (LP_MacULSpsDeactReq)getMemFromPool(
                            sizeof(MacULSpsDeactReq), PNULL);
                    /* Fill deactivation queue node */
                    if( PNULL != macUlSpsDectReq_p )
                    {
                        macUlSpsDectReq_p->ueIndex =  ulUEContext_p->ueIndex;
                        macUlSpsDectReq_p->cause = MEAS_GAP_RECONFIG;
                        /* Enqueue the node to deactivation queue so that it
                         *                  * can be processed in next tick */
                        if (MAC_FAILURE == ENQUEUE_MAC_UL_SPS_Q( ulSpsDeactQ_gp[internalCellIndex],
                                    macUlSpsDectReq_p ))
                        {
                            ltePanic("Enqueue UL SPS Failed\n");
                        }
                    }
                    else
                    {
                        LOG_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL,
                                L2_SYS_FAIL, getCurrentTick(), __LINE__,
                                sizeof(MacULSpsDeactReq), 0, 0, 0, 0,0,
                                __FILE__, __func__);
                        ALARM_MSG( MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID,
                                CRITICAL_ALARM);
                        ltePanic("getMemFromPool fails %s", __func__);
                    }

                    /* Update Q Stats */
                    LTE_MAC_QUEUE_USED( UL_SPS_DEACT_Q,
                            QCOUNT_MAC_UL_SPS_Q( ulSpsDeactQ_gp[internalCellIndex] ),
                            internalCellIndex);
                }
                else
                {
                    freeMemPool(dataReq_p);
                    dataReq_p = PNULL;
                }
            }
            else
            {    
                LOG_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL, L2_SYS_FAIL,
                        getCurrentTick(), __LINE__, sizeof(MacULSpsStatus), 0,0,0,
                        0.0,0.0,__FILE__,__func__);
                ALARM_MSG( MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID, CRITICAL_ALARM);
                ltePanic("getMemFromPool fails %s",__FUNCTION__);
            }
            /*coverityId:98803;SPR:19339 */
#else
            {
                /* Allocate the memory for deactivation queue node */
                macUlSpsDectReq_p = (LP_MacULSpsDeactReq)getMemFromPool(
                        sizeof(MacULSpsDeactReq), PNULL);
                /* Fill deactivation queue node */
                if( PNULL != macUlSpsDectReq_p )
                {
                    macUlSpsDectReq_p->ueIndex =  ulUEContext_p->ueIndex;
                    macUlSpsDectReq_p->cause = MEAS_GAP_RECONFIG;
                    /* Enqueue the node to deactivation queue so that it
                     *                  * can be processed in next tick */
                    if (MAC_FAILURE == ENQUEUE_MAC_UL_SPS_Q( ulSpsDeactQ_gp[internalCellIndex],
                                macUlSpsDectReq_p ))
                    {
                        ltePanic("Enqueue UL SPS Failed\n");
                    }
                }
                else
                {
                    LOG_MSG( L2_GET_MEMFROMPOOL_FAIL_ID, LOGFATAL,
                            L2_SYS_FAIL, getCurrentTick(), __LINE__,
                            sizeof(MacULSpsDeactReq), 0, 0, 0, 0,0,
                            __FILE__, __func__);
                    ALARM_MSG( MAC_MODULE_ID, MEM_ALLOC_FAILED_ALARM_ID,
                            CRITICAL_ALARM);
                    ltePanic("getMemFromPool fails %s", __func__);
                }

                /* Update Q Stats */
                LTE_MAC_QUEUE_USED( UL_SPS_DEACT_Q,
                        QCOUNT_MAC_UL_SPS_Q( ulSpsDeactQ_gp[internalCellIndex] ),
                        internalCellIndex);
            }
#endif
        }

    }
}
//cell_state_changes
/* - SPS_TDD_Changes */

/* SPR 19679: TDD HARQ Multiplexing Changes Start */
#ifdef TDD_CONFIG 
/******************************************************************************
 * Function Name  : validateTddAckNackFeedbackMode
 * Inputs         : msgBuf - pointer to the input buffer
 *                  msgLen_p - length of the API message received
 *                  tagLen_p - Length of the tag
 *                  ulCreateReq_p - pointer to Uplink create UE structure
 *                  internalCellIndex - cell index used at MAC
 * Outputs        : None
 * Returns        : MAC_SUCCESS or MAC_FAILURE
 * Description    : This function vaildates tddAckNackfeedbackmode
 * ******************************************************************************/
STATIC  MacRetType validateTddAckNackFeedbackMode(UInt8 **msgBuf, 
        UInt16 tagLen,
        UeContextForUplink *ulCreateReq_p
        /* CA changes Start */
        ,InternalCellIndex internalCellIndex
        /* CA Changes end */
        )
{
    MacRetType resp = MAC_SUCCESS;
    UInt8 *msg_p           = PNULL;

    /* CA Changes start */
    CellConfigParams *cellParams_p = cellSpecificParams_g.\
                                     cellConfigAndInitParams_p[internalCellIndex]->cellParams_p;
    /* CA Changes end */
    msg_p = *msgBuf;
    if ( tagLen != 5 )
    {
        lteWarning
            ("Invalid Tag Length for TDD ACK NACK FEEDBACK MODE INFO");
        /* Review comment fix start RJ13 */
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for \
                TDD ACK NACK FEEDBACK MODE INFO");
        /* Review comment fix end RJ13 */
        return MAC_FAILURE;
    }
    ulCreateReq_p->tddAckNackFeedbackMode = *msg_p++;

    if (( ulCreateReq_p->tddAckNackFeedbackMode != HARQ_MULTIPLEXING ) && \
            ( ulCreateReq_p->tddAckNackFeedbackMode != HARQ_BUNDLING ))
    {
        lteWarning
            ("Invalid feedback mode ");

        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex, 
                __LINE__, 
                DEFAULT_INT_VALUE, 
                DEFAULT_INT_VALUE, 
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME, 
                "Invalid Tag Length for \
                TDD ACK NACK FEEDBACK MODE INFO");
        return MAC_FAILURE;
    }

    if (( ulCreateReq_p->tddAckNackFeedbackMode == HARQ_MULTIPLEXING )&& \
            ( cellParams_p->subFrameAssign == UL_DL_CONFIG_5 ))
    {
        lteWarning
            ("Incorrect config for ACK NACK FEEDBACK MODE"); 
        LOG_MAC_MSG(MAC_PARSING_ERROR,LOGERROR,MAC_RRC_INF,
                GET_CURRENT_TICK_FOR_CELL(internalCellIndex),
                tagLen,
                internalCellIndex,
                __LINE__,
                DEFAULT_INT_VALUE,
                DEFAULT_INT_VALUE,
                DEFAULT_FLOAT_VALUE, DEFAULT_FLOAT_VALUE,
                FUNCTION_NAME,
                "Invalid Feedback mode for config5 \
                TDD ACK NACK FEEDBACK MODE INFO");
        return MAC_FAILURE;
    }
    *msgBuf = msg_p;
    return resp; 
}
#endif
/* SPR 19679: TDD HARQ Multiplexing Changes End */

/* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
/****************************************************************************
 * Function Name  : parseUEUplinkRAT1Info 
 * Inputs         : msgBuf - Pointer to the incoming message
 *                  len - Length of the incoming API buffer 
 *                  ulUEInfo_p - Ptr to a structure to be filled for UL
 * Outputs        : None
 * Returns        : MAC_SUCCESS/MAC_FAILURE
 * Description    : This function parse UE Uplink rat1 support 
 *                  and updates UL structure for UE context at MAC.
 *****************************************************************************/
STATIC  MacRetType parseUEUplinkRAT1Info (UInt8 **msgBuf, 
        UInt16                len,
        UeContextForUplink *ulUEInfo_p,
	InternalCellIndex internalCellIndex
        )
{
	UInt8 *msg_p    = PNULL;
	msg_p = *msgBuf;

    if ( UPLINK_RAT1_INFO_TAG_LENGTH != len )
    {
        LOG_MAC_ERROR(MAC_RRC_INF, "Invalid Tag Length[%d] for UE_UPLINK_RAT1 INFO",len);
        return MAC_FAILURE;
    }
    ulUEInfo_p->isUplinkRAT1Supported = *msg_p++;

    *msgBuf = msg_p;
    return MAC_SUCCESS;
}
#endif
/* SPR 21958 PUSCH RAT1 Support End */

/* SPR 21819 changes */
/*****************************************************************************
 * Function Name  : macUpdateControlStateOnSRB1DLPacket
 * Inputs         : ueIndex - UE for which SRB1 is being sent
 * Outputs        : None
 * Returns        : None
 * Description    : This function performs state change when SRB1 packet is sent
 *****************************************************************************/
void macUpdateControlStateOnSRB1DLPacket (UInt16 ueIndex)
{
    ULUEContext  *ulUEContext_p = PNULL;
    if (ueIndex < MAX_UE_SUPPORTED)
    {
        ulUEContext_p = ulUECtxInfoArr_g[ueIndex].ulUEContext_p;
        if(PNULL != ulUEContext_p)
        {
            /* Enable SRS State in UL UE Context when first SRB data is being sent to UE, the first SRB-1
             * packet will be carrying the rrcConnectionReconfiguration PDU with SRS configuration. So enable 
             * SRS new configuration at MAC when UE receives the new configuration */
           if(SRS_DEDICATED_CONFIG_TYPE_SETUP_WAITING == ulUEContext_p->srsConfigInfo.srsConfigType)
           {
               ulUEContext_p->srsConfigInfo.srsConfigType = SRS_DEDICATED_CONFIG_TYPE_SETUP;
           }
        }
    }
}
/* SPR 21819 changes */






