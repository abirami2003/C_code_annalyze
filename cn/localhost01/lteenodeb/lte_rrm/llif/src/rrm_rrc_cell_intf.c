/* vim: ts=4:et:ai:ci:sw=4
 */
/******************************************************************************
 *
 *   FILE NAME:
 *       rrm_cell_rrc_intf.c
 *
 *   DESCRIPTION:
 *       Contains functions for Filling Structures of RRC API's
 *
 *
 *
 *
 *   DATE            AUTHOR      REFERENCE       REASON
 *   28 Feb 2012     Gur29220    ---------       Initial
 *   13 MAY 2012     gur30487                    CLPC regarding changes
 *   25 MAY 2012     gur30784                    mapping of SIB1 and SIB2 params
 *   13 JUN 2012     gur30784                    Access barring info params
 *   26 JUL 2012     gur27278                    Removed compilation warnings
 *   18 Dec 2012     gur29220                    Fix of SPR 5014
 *   29 Jan 2013     gur27278                    Added code for SPS feature
 *   21 Mar 2013     gur29220    SPR 5692        Fixed Access Class Barring
 *                                               Functionality in Sib-2
 *   22 Apr 2013     gur29220    SPR 6008        System_time_info was absent
 *   1  May, 2014    gur26515                    Added code changes for SPR 10730
 *   6  June 2014    gur26515    SPR 10730            Added code changes for SPR 10730
 *   01 May 2014     gur32417    CA STG 3        Carrier Aggregation Stage 3
 *                                               code changes
 *   19 June 2014    gur35095    SPR 11769       CSR 00082391 Fix
 *
 *   26 Jun,2014     gur29990    12215           SI Value Tag Logic modified
 *   06 Jun 2014     gur29990    SPR 11575       SIB 4 broadcast issue fix
 *   30 Jun 2014     gur29831    SPR 12271       Cell barred reconf issue fix 
 *   18 Jun 2014     gur25767    SPR 11861       SIB 4 multiple PCI broadcast issue fix
 *   24 Jul 2014     gur32417    SPR 12689       PCI conflict with serving issue changes
 *   22 AUG 2014     gur29831    SPR 13268       Re conversion of prs muting config
 28 AUG 2014     gur35932    SPR 12929       Loop running for 15 neighbours(in case
 of having 16 neighbours)
 *   18 SEP 2014     gur29831    SPR 13531       Incorrect cell id fix 
 *   25 SEP 2014     gur29831                    Prs config fix 
 *   Copyright (c) 2012, Aricent Inc. All Rights Reserved
 *
 ******************************************************************************/


/****************************************************************************
 * Standard Library Includes
 ****************************************************************************/

/****************************************************************************
  PROJECT INCLUDES
 ****************************************************************************/
#include "rrm_rrc_cell_intf.h"
#include "rrm_cell_mgr.h"
#include "rrm_api_defines.h"
#include "rrm_api_types.h"
#include "rrm_defines.h"
#include "l3_api_composer.h"
#include "rrc_s1apRrm_intf.h"
#include "s1ap_rrm_composer.h"
#include "s1ap_rrm_parser.h"
#include "rrm_mem_utils.h"
#include "rrm_utils.h"
/* COMP_WARN_1_FEB:compilation warning removal */
#include "x2ap_rrm_composer.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "rrm_rrc_cell_embms.h"
#endif

#ifdef LTE_EMBMS_SUPPORTED
/****************************************************************************
 * Exported Variables/Functions
 ****************************************************************************/
 extern
 rrm_void_t
    rrm_map_conf_sib_type_2_info_for_embms
    (
 rrmcm_mbsfn_subframe_config_list_t *p_cellm_mbsfn_list,
 mbsfn_subframe_config_list_t *p_rrc_mbsfn_list
 );

extern
rrm_return_et
map_reconf_scheduling_info_list_for_mbms
(
 rrm_cell_context_t          *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
 rrm_bool_et                 sib_13_schedule
);

extern
rrm_void_t
map_sib_type_13_Info_for_mbms
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_setup_req_t *p_rrc_rrm_cell_setup_req
 );

extern
rrm_void_t
rrm_fill_sib_2_for_cell_reconfig
(
 rrmcm_mbsfn_config_info_t *p_mbsfn_from_cell,
 mbsfn_subframe_config_t   *p_mbsfn_to_rrc

 );

extern
rrm_void_t
update_collision_free_scheduling_list_for_mbms
(
 rrm_cell_context_t      *p_cell_context ,
 scheduling_info_list_t  *p_scheduling_info_list ,
 U16                     *sib_temp_bitmask ,
 U16                     *p_sib_bitmask
 );

/*SPR 18672:start*/
extern
rrm_void_t
rrm_map_only_reserved_info_after_delte
(
 rrm_cell_context_t *p_cell_context,
  rrc_rrm_cell_setup_req_t *p_rrc_rrm_cell_setup_req
   );

/*SPR 18672:end*/

#endif
/*DYNAMIC SIB SCHEDULING START*/
sib_msg_info_t    sib_msg_data[RRM_MAX_SF_VALUE] = {{RRM_ZERO}};
/*DYNAMIC SIB SCHEDULING END*/
rrm_return_et
map_reconf_sib_type_8_Info_for_son
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 );


rrm_void_t 
rrm_son_map_hrpd_1xrtt_ncl_list
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 );

rrm_void_t
rrm_son_map_cdma2000_hrpd
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 );
rrm_void_t
rrm_son_map_cdma2000_1xrtt
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 );


void 
rrm_son_map_cell_reselection_params_cdma2000
(
 neigh_cell_list_cdma2000_t         *p_neigh_cell_list_cdma2000,
    /*SPR 17777 +-*/
 rrmcm_rmif_cdma2000_freq_cells_t   *p_cdma2000_freq_cells,
 U8                                  cdma2000_freq_cells
    /*SPR 17777 +-*/
 );

static rrm_void_t
map_sib_type_5_ncl_params(
        inter_freq_carrier_freq_t   *p_reconfig_inter_freq,
        lte_ncl_t           *p_lte_ncl);

void set_scheduling_info_for_sib(
        sib_type_1_Info_t   *sib_type_1_Info,
        U8                  sib_type,
        U8                  sib_periodicity
        );

/*bug 9979 Fix -Start */
static
rrm_void_t
fill_mac_prs_reconfig
(
 prs_t              *p_cellm_prs_reconfig,
 rrc_mac_reconfig_t   *p_mac_reconfig_info
 );
/*bug 9979 Fix -End */
#define RRM_SIB_1_PRESENT 0x0001
#define RRM_SIB_2_PRESENT 0x0002
#define RRM_SIB_3_PRESENT 0x0004 
#define RRM_SIB_4_PRESENT 0x0008
#define RRM_SIB_5_PRESENT 0x0010
#define RRM_SIB_6_PRESENT 0x0020
#define RRM_SIB_7_PRESENT 0x0040
#define RRM_SIB_8_PRESENT 0x0080
#define RRM_SIB_9_PRESENT 0x0100
#define RRM_SIB_3_TO_9_PRESENCE_BITMASK 0x1FC
#define RRM_NON_BROADCAST_INFO_PRESENCE_FLAG    0x0200 
#define RRM_NBROADCAST_SYNC_SIGNAL_PRESENT_FLAG 0x0400
#define RRM_NBROADCAST_CELL_PARAM_PRESENT_FLAG  0x0800
#define RRM_NBROADCAST_MAC_RECONF_PRESENT_FLAG  0x1000
#define RRM_MIB_INFO_PRESENT                    0x2000
#define RRM_NBROADCAST_MAC_PRS_RECONF_PRESENT_FLAG  0x4000
#define RRM_INVALID_SI_PRESENT_U8    0xFF
#define RRM_INVALID_START_SF_U16     0xFFFF
#define RRM_INVALID_SEGMENT_ID_U8       0xFF
#define RRM_INVALID_SI_SEGMENT_PERIODICITY   0xFFFF
#define RRM_INVALID_SI_PERIODICITY_U8   0xFF
#define RRM_MAX_PCI_VALUE       504


static U16  sib_presence_bitmask = RRM_ZERO;
/* BUG_371 FIX START */ 
void 
clear_undesired_sib_mapping_info_in_sib1
(
 U16                     sib_bitmask,
 U16                     config_sib_bitmask,
 scheduling_info_list_t  *p_scheduling_info_list
 )
{
    RRM_UT_TRACE_ENTER();
    if(!(sib_bitmask & RRM_SIB_3_PRESENT) && !(config_sib_bitmask & RRM_SIB_3_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 3 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_3); 

    }
    if(!(sib_bitmask & RRM_SIB_4_PRESENT) && !(config_sib_bitmask & RRM_SIB_4_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 4 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_4); 
    }
    if(!(sib_bitmask & RRM_SIB_5_PRESENT) && !(config_sib_bitmask & RRM_SIB_5_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 5 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_5); 
    }
    if(!(sib_bitmask & RRM_SIB_6_PRESENT) && !(config_sib_bitmask & RRM_SIB_6_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 6 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_6); 
    }
    if(!(sib_bitmask & RRM_SIB_7_PRESENT) && !(config_sib_bitmask & RRM_SIB_7_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 7 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_7); 
    }
    if(!(sib_bitmask & RRM_SIB_8_PRESENT) && !(config_sib_bitmask & RRM_SIB_8_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 8 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_8); 
    }
    if(!(sib_bitmask & RRM_SIB_9_PRESENT) && !(config_sib_bitmask & RRM_SIB_9_PRESENT))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB 9 was neither present in Cell COnfig nor present in Cell reconfig"
                "Remove it's shedduling info if present");
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_9); 
    }

    RRM_UT_TRACE_EXIT(); 
}

rrm_void_t
merge_cell_config_reconfig_scheduling_list
(
 scheduling_info_list_t  *p_reconfig_scheduling_info_list,
 rrm_scheduling_info_list_t	*p_config_scheduling_info_list
 )
{
    U8 config_sibtype        = RRM_ZERO;
    U8 config_si_periodicity = RRM_ZERO;
    U8 config_si_count       = RRM_ZERO;
    U8 config_sib_count      = RRM_ZERO;

    RRM_UT_TRACE_ENTER();


    p_reconfig_scheduling_info_list->count = RRM_ZERO;

    for(config_si_count = RRM_ZERO ; config_si_count < p_config_scheduling_info_list->count ; config_si_count++)
    {
        p_reconfig_scheduling_info_list->scheduling_info[p_reconfig_scheduling_info_list->count].sib_mapping_info.count = RRM_ZERO;
        for(config_sib_count = RRM_ZERO; config_sib_count < p_config_scheduling_info_list->scheduling_info[config_si_count].
                sib_mapping_info.count ; config_sib_count++)
        {
            config_sibtype = p_config_scheduling_info_list->scheduling_info[config_si_count].sib_mapping_info.sib_type[config_sib_count];
            config_si_periodicity = p_config_scheduling_info_list->scheduling_info[config_si_count].si_periodicity;

            p_reconfig_scheduling_info_list->scheduling_info[p_reconfig_scheduling_info_list->count].si_periodicity = config_si_periodicity;
            p_reconfig_scheduling_info_list->scheduling_info[p_reconfig_scheduling_info_list->count].
                sib_mapping_info.sib_type[p_reconfig_scheduling_info_list->
                scheduling_info[p_reconfig_scheduling_info_list->count].sib_mapping_info.count] = config_sibtype;
            p_reconfig_scheduling_info_list->scheduling_info[p_reconfig_scheduling_info_list->count].sib_mapping_info.count++;
        }
        p_reconfig_scheduling_info_list->count++;
    }


    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME : rrm_update_bitmask_for_cell_reconfig_mib_sib
 *   INPUT         : p_rrc_rrm_cell_reconfig_req
 *   OUTPUT        : SIB bitmask updated in p_rrc_rrm_cell_reconfig_req for
 *                   cell reconfig request
 *   DESCRIPTION   :
 *          This function update the bitmask of SIB for cell reconfig request.
 *
 *   RETURNS       : none
 *****************************************************************************/
rrm_void_t
rrm_update_bitmask_for_cell_reconfig_mib_sib(rrc_rrm_cell_reconfig_req_t   
        *p_rrc_rrm_cell_reconfig_req )
{
    RRM_UT_TRACE_ENTER();
    if (RRM_MIB_INFO_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_MIB_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_1_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_2_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_3_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_4_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_5_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_5_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_6_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_6_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_7_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_7_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_8_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        /* Fix for reconfig 27/06/2013 */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_8_INFO_PRESENCE_FLAG;
    }
    if (RRM_SIB_9_PRESENT & sib_presence_bitmask)
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_9_INFO_PRESENCE_FLAG;
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 *   FUNCTION NAME : rrm_update_bitmask_for_cell_reconfig_sib
 *   INPUT         : p_rrc_rrm_cell_reconfig_req
 *   OUTPUT        : SIB bitmask updated in p_rrc_rrm_cell_reconfig_req for
 *                   cell reconfig request
 *   DESCRIPTION   :
 *          This function update the bitmask of SIB for cell reconfig request.
 *
 *   RETURNS       : none
 *****************************************************************************/
    rrm_void_t
rrm_update_bitmask_for_cell_reconfig_sib(rrm_cell_context_t   *p_cell_context ,
        sib_type_1_Info_t    *p_sib_type_1_Info)
{
    /* CSR 00051178 CHANGES START */
    U8                   si_periodicity = RRM_ZERO;
    /* CSR 00051178 CHANGES END */
    RRM_UT_TRACE_ENTER();
    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_3_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_3_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_3, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 3 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_3_PRESENT; 
        /* BUG_371 FIX END */ 
    }

    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_4_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_4_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_4, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 4 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_4_PRESENT;
        /* BUG_371 FIX END */ 
    }

    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_5_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_5_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_5, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 5 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_5_PRESENT; 
        /* BUG_371 FIX END */ 
    }

    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_6_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_6_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_6, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 6 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_6_PRESENT; 
        /* BUG_371 FIX END*/ 
    }

    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_7_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_7_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_7, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 7 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_7_PRESENT; 
        /* BUG_371 FIX END */ 
    }

    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_8_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_8_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_8, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 8 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_8_PRESENT; 
        /* BUG_371 FIX END */ 
    }

    if ( !(p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_9_PRESENT) && 
            (sib_presence_bitmask & RRM_SIB_9_PRESENT)
       )
    {
        si_periodicity = p_cell_context->si_segment_data_sib_scheduling[p_cell_context->operator_info.
            sib_1_info.scheduling_info_list.count].si_segment_periodicity;
        set_scheduling_info_for_sib(p_sib_type_1_Info,RRM_RRC_SIB_TYPE_9, si_periodicity);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New SIB 9 Added");
        /* BUG_371 FIX START */ 
        p_cell_context->sib_present_at_cell_reconfig_time_bitmask |= RRM_SIB_9_PRESENT; 
        /* BUG_371 FIX END */ 
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/* BUG_371 FIX END */ 
/****************************************************************************
 *   FUNCTION NAME : rrm_update_bitmask_for_cell_reconfig
 *   INPUT         : p_rrc_rrm_cell_reconfig_req
 *   OUTPUT        : SIB bitmask updated in p_rrc_rrm_cell_reconfig_req for 
 *                   cell reconfig request
 *   DESCRIPTION   :
 *          This function update the bitmask of SIB for cell reconfig request.
 *
 *   RETURNS       : none
 *****************************************************************************/

rrm_void_t rrm_update_bitmask_for_cell_reconfig
(
 /* CSR 00051178 CHANGES START */
 rrm_cell_context_t *p_cell_context,
 /* BUG_822 FIX START */ 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
 rrm_cell_procedure_et    cell_procedure
 /* BUG_822 FIX END */ 
 )
{
    sib_type_1_Info_t   *p_sib_type_1_Info = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    /* During Cell Reconfiguration, if any of SIB is modified then
       SIB 1 shall be transmitted as Mandatory because SIB 1 has the
       system_info_tag which will force UE to read new SIBs.
       Also, the scheduling info present in SIB 1 shall be the same as
       transmitted in Cell Config. The scheduling info can have new info
       about new SIBs but scheduling info during Cell Config should be 
       intacted*/
    sib_presence_bitmask |= RRM_SIB_1_PRESENT;

    /*Klockwork_fix_start*/
    rrm_update_bitmask_for_cell_reconfig_mib_sib(p_rrc_rrm_cell_reconfig_req); 
    /*Klockwork_fix_end*/

    if( (RRM_NON_BROADCAST_INFO_PRESENCE_FLAG & sib_presence_bitmask) &&
            (RRM_NBROADCAST_SYNC_SIGNAL_PRESENT_FLAG & sib_presence_bitmask))
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SYNC_SIGNAL_INFO_PRESENCE_FLAG;
    }
    if( (RRM_NON_BROADCAST_INFO_PRESENCE_FLAG & sib_presence_bitmask) &&
            (RRM_NBROADCAST_CELL_PARAM_PRESENT_FLAG & sib_presence_bitmask))
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_CELL_PARAMETER_INFO_PRESENCE_FLAG;
    }
    if( (RRM_NON_BROADCAST_INFO_PRESENCE_FLAG & sib_presence_bitmask) &&
            (RRM_NBROADCAST_MAC_RECONF_PRESENT_FLAG & sib_presence_bitmask))
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG;
    }
    if( (RRM_NON_BROADCAST_INFO_PRESENCE_FLAG & sib_presence_bitmask) &&
            (RRM_NBROADCAST_MAC_RECONF_PRESENT_FLAG & sib_presence_bitmask) &&
            (RRM_NBROADCAST_MAC_PRS_RECONF_PRESENT_FLAG & sib_presence_bitmask))
    {
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= 
            RRC_RRM_RECONFIG_PRS_INFO_PRESENT;
    }

    /* In Cell Reconfig, SIB 1 is Mandatory so it can be accessed here without any
       bitmask check. It has the scheduling info stored from the Cell Context which 
       is prepared during the Cell Config Request. Below written logic will first
       check, if the scheduling info for the already existing SIBs is present or not.
       In case it is present(which should be the case as that SIB is modified) then
       it won't fill its scheduling info and only adds for the newly added SIBs.*/

    p_sib_type_1_Info = &p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info;
    RRM_ASSERT(RRM_PNULL != p_sib_type_1_Info);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Scheduling Count from Last Stored@RRM/Latest Info from Cell Reconfig = %d",
            p_sib_type_1_Info->scheduling_info_list.count);

    /* Resetting the bitmask only to check the presence of SIBs
       from SIB 3 to 9  on bit 2 to 8(bit starting from 0) during  CEll Reconfig */
    sib_presence_bitmask = sib_presence_bitmask  & RRM_SIB_3_TO_9_PRESENCE_BITMASK;

    /* sib_present_at_cell_config_time_bitmask can have values from 
       SIB 3 to SIB 10 with SIB 3 starting from bit position 2 below.

       Bit Position:- 9      8    7     6     5     4    3    2    1   0
Value:-       0/1    0/1  0/1   0/1   0/1   0/1  0/1  0/1   0   0

sib_presence_bitmask can have all the values defined above.

Below operation shall extract only the newly set SIBs*/

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Cell Config Bitmask = 0x%x, Reconfig Bitmask = 0x%x",
            p_cell_context->sib_present_at_cell_config_time_bitmask, sib_presence_bitmask);
    /* BUG_371 FIX START */ 
    //p_cell_context->sib_present_at_cell_reconfig_time_bitmask = p_cell_context->sib_present_at_cell_config_time_bitmask; 
    p_cell_context->sib_present_at_cell_reconfig_time_bitmask = 0x00;
    /* BUG_371 FIX END */ 
    /*DYNAMIC ICIC START*/

    /*Klockwork_fix_start*/
    rrm_update_bitmask_for_cell_reconfig_sib(p_cell_context ,p_sib_type_1_Info);
    /*Klockwork_fix_end*/

    /* BUG_371 FIX START */ 
    clear_undesired_sib_mapping_info_in_sib1( p_cell_context->sib_present_at_cell_reconfig_time_bitmask ,
            p_cell_context->sib_present_at_cell_config_time_bitmask,
            &(p_sib_type_1_Info->scheduling_info_list));


    if( RRM_ZERO == p_sib_type_1_Info->scheduling_info_list.count)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Scheduling info for reconfig request is Empty , due to incorrect Scheduling info provided by operator"
                "Send the last successfull Scheduling  info in reconfig request");
        merge_cell_config_reconfig_scheduling_list(&(p_sib_type_1_Info->scheduling_info_list), &(p_cell_context->operator_info.sib_1_info.scheduling_info_list));
    } 

    /* BUG_822 FIX START */ 
    if (cell_procedure == CELL_RECONFIG_PROC)
    {
        RRM_MEMCPY((scheduling_info_list_t*)&(p_cell_context->p_new_reconfig_data->operator_info.sib_1_info.scheduling_info_list),
                &(p_sib_type_1_Info->scheduling_info_list), sizeof(scheduling_info_list_t));
    }
    else if ((cell_procedure == CELL_UPDATE_PROC) ||
            (cell_procedure == CELL_MLB_RECONFIG_PROC) ||
            (cell_procedure == CELL_RECONFIG_FOR_ICIC_PROC)
            )
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "No Need to copy Schduling Info as no nwe SIB is added/deleted in the procdere(%d)",
                cell_procedure);

    }
    /* BUG_371 FIX END */ 

    /* BUG_822 FIX END */ 

    sib_presence_bitmask = RRM_ZERO;
    /* BUG_371 FIX START */ 
    if( p_cell_context->sib_present_at_cell_reconfig_time_bitmask != 
            p_cell_context->sib_present_at_cell_config_time_bitmask )
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Scheduling info is chanded during Cell reconfig , update SI transmission info also ");

        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG;


        /* coverity : CID 63690*/
        fill_mac_config_scheduling_info_list((rrm_si_window_length_et ) p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_window_length,
                &(p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.si_transmission_info),
                (rrm_scheduling_info_list_t*)(&(p_sib_type_1_Info->scheduling_info_list)));

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_SI_TRANSMISSION_INFO_PRESENT;

    } 
    RRM_UT_TRACE_EXIT();
    /* BUG_371 FIX END */ 
}


/****************************************************************************
 *   FUNCTION NAME : mac_reconfig
 *   INPUT         : cell_context
 *   OUTPUT        : p_mac_reconfig_info
 *   DESCRIPTION   :
 *    		This function Maps the cell reconfig params from CELLM to RRC
 *   RETURNS       :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
mac_reconfig
(
 rrm_cell_context_t *cell_context, 
 rrc_mac_reconfig_t   *p_mac_reconfig_info
 )
{

    U8        index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_mac_reconfig_info->bitmask = RRM_ZERO;

    /* LTE_RRM_CONFIG_START configuration for cell setup coming from rrm_oam.cfg */
    p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_PUCCH_CQI_SINR_THRESHOLD_PRESENT;
    /* BUG_371 FIX START */
    /*p_mac_reconfig_info->pucch_cqi_sinr_value = 
      cell_context->operator_info.rrm_mac_config.pucch_cqi_sinr_value;*/
    p_mac_reconfig_info->pucch_cqi_sinr_value = 
        cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.pucch_cqi_sinr_value;

    p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_UL_SYNC_LOSS_TIMER_PRESENT;
    /*p_mac_reconfig_info->ul_sync_loss_timer = 
      (U8)cell_context->operator_info.rrm_mac_config.ul_sync_loss_timer;*/
    p_mac_reconfig_info->ul_sync_loss_timer = 
        (U8)cell_context->ran_info.mac_layer_params.ul_sync_loss_timer;
    /* BUG_371 FIX END */

    /*CSR:00047975 - FIX STARTS */
    p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_DCI_FORMAT_FOR_SI_MESSAGES_PRESENT;
    p_mac_reconfig_info->dci_format_for_si_msgs = cell_context->operator_info.
        rrm_mac_config.rrm_dci_format_for_si_msg ;
    /*CSR:00047975 - FIX ENDS */
    if (cell_context->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == 
            RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A)
    {
        p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_RBS_PER_TBS_DCI_1A_PRESENT;
        for(index = RRM_ZERO; index < RBS_FOR_DCI_1A_SIZE; index++)
        {
            p_mac_reconfig_info->num_rbs_per_tbs_dci_1a[index] =
                /* + SPR 17665 + */
                cell_context->operator_info.rrm_mac_config.num_rbs_per_tbs_dci_1a[index];
            /* - SPR 17665 - */
        }
    }
    else if (cell_context->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == 
            RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C)
    {
        p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_RBS_PER_TBS_DCI_1C_PRESENT;
        for(index = RRM_ZERO; index < RBS_FOR_DCI_1C_SIZE; index++)
        {
            p_mac_reconfig_info->num_rbs_per_tbs_dci_1c[index] = 
                /* + SPR 17665 + */
                cell_context->operator_info.rrm_mac_config.num_rbs_per_tbs_dci_1c[index];
            /* - SPR 17665 - */        
        }
        /* :Bug :179 start */
        p_mac_reconfig_info->dci_format_for_si_msgs = RRC_RBS_PER_TBS_DCI_1C; 
        /* : Bug:179 end */
    }

    p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_N_GAP_PRESENT;
    /* BUG_371 FIX START */
    /*p_mac_reconfig_info->n_gap = 
      cell_context->ran_info.mac_layer_params.ul_sync_loss_timer;*/
    p_mac_reconfig_info->n_gap = 
        cell_context->ran_info.mac_layer_params.n_gap;
    /* BUG_371 FIX END */

    p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_SI_TRANSMISSION_INFO_PRESENT;
    fill_mac_config_scheduling_info_list(cell_context->operator_info.sib_1_info.si_window_length,
            &(p_mac_reconfig_info->si_transmission_info),
            &(cell_context->operator_info.sib_1_info.scheduling_info_list));

    /* SPS related changes start */
    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT)
    {
        p_mac_reconfig_info->sps_crnti_range.start_sps_crnti = 
            cell_context->operator_info.sps_crnti_range_info.start_sps_crnti_range;

        p_mac_reconfig_info->sps_crnti_range.end_sps_crnti = 
            cell_context->operator_info.sps_crnti_range_info.end_sps_crnti_range;

        p_mac_reconfig_info->bitmask |= RRC_RRM_RECONFIG_SPS_CRNTI_RANGE_PRESENT;
    }
    /* SPS related changes end */
    /* LTE_RRM_CONFIG_END*/
    /*bug 9979 Fix -Start */
    if(cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT &&
            cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT)
    {
        fill_mac_prs_reconfig(&(cell_context->ran_info.physical_layer_params.physical_layer_param_prs),
                p_mac_reconfig_info);
    }
    /*bug 9979 Fix -End */
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *	FUNCTION NAME   : set_scheduling_info_for_sib 
 *
 *  INPUT           : *sib_type_1_Info, sib_type, sib_periodicity
 *  OUTPUT          : sib_type_1_Info
 *	DESCRIPTION	    : This function updates the scheduling list for 
 *                    the requested SIB with the apropriate periodicty.
 *	RETURNS		    : None
 *****************************************************************************/
void set_scheduling_info_for_sib(
        sib_type_1_Info_t   *sib_type_1_Info,
        U8                  sib_type,
        U8                  sib_periodicity
        )
{
    U16             si_seg_count = RRM_ZERO;
    U8              sib_mapping = RRM_ZERO;
    rrm_bool_et     sib_found = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    /* CSR 00051178 CHANGES START */
    for(si_seg_count = RRM_ZERO; si_seg_count < sib_type_1_Info->scheduling_info_list.count; si_seg_count++)
    {
        sib_found = RRM_FALSE;
        if(sib_type_1_Info->scheduling_info_list.scheduling_info[si_seg_count].sib_mapping_info.count)
        {
            for(sib_mapping = RRM_ZERO; sib_mapping < sib_type_1_Info->scheduling_info_list.
                    scheduling_info[si_seg_count].sib_mapping_info.count; sib_mapping++)
            {
                if (sib_type == sib_type_1_Info->scheduling_info_list.scheduling_info[si_seg_count].
                        sib_mapping_info.sib_type[sib_mapping])
                {
                    sib_found = RRM_TRUE;
                    break;
                }
            }
        }
    }
    if (RRM_FALSE == sib_found)
    {
        sib_type_1_Info->scheduling_info_list.
            scheduling_info[sib_type_1_Info->scheduling_info_list.count].sib_mapping_info.
            count = RRM_ONE ;

        sib_type_1_Info->scheduling_info_list.
            scheduling_info[sib_type_1_Info->scheduling_info_list.count].sib_mapping_info.
            /* BUG_371 FIX START */
            /* Fix for SPR 11431, 11539 start */
            sib_type[RRM_ZERO] = sib_type;
        /* Fix for SPR 11431, 11539 end */
        /* BUG_371 FIX END */
        sib_type_1_Info->scheduling_info_list.
            scheduling_info[sib_type_1_Info->scheduling_info_list.count].
            si_periodicity = sib_periodicity ;

        sib_type_1_Info->scheduling_info_list.count++;
    }
    /* Function Exit */
    RRM_UT_TRACE_EXIT();
}

/*DYNAMIC SIB SCHEDULING START*/
/****************************************************************************
 *	FUNCTION NAME   : return_new_si_window 
 *  INPUT		    : siWindowSize 
 *  OUTPUT		    : new siWindowSize
 *	RETURNS		    : new siwindow to check
 *	DESCRIPTION	    : This function returns the new  si window to check for 
 *                    SIB occurence.
 *****************************************************************************/
U8 return_new_si_window
(
 U8  siWindowSize
 )
{
    U8  count_to_check = RRM_ZERO;

    if(siWindowSize == RRM_ONE)
    {
        /* SPR_11104_FIX_START */
        count_to_check = RRM_FORTY;
        /* SPR_11104_FIX_END */
    }
    else if(siWindowSize == RRM_TWO)
    {
        count_to_check = RRM_ONE;
    }
    else if(siWindowSize == RRM_FIVE)
    {
        count_to_check = RRM_TWO;
    }
    else if(siWindowSize == RRM_TEN)
    {
        count_to_check = RRM_FIVE;
    }
    else if(siWindowSize == RRM_FIFTEEN)
    {
        count_to_check = RRM_TEN;
    }
    else if(siWindowSize == RRM_TWENTY)
    {
        count_to_check = RRM_FIFTEEN;
    }
    /* SPR_11104_FIX_START */
    else if(siWindowSize == RRM_FORTY)
        /* SPR_11104_FIX_END */
    {
        count_to_check = RRM_TWENTY;
    }

    return count_to_check;
}

#ifdef TDD_MODE_FLAG

/****************************************************************************
 *  FUNCTION NAME   : block_sf_in_actual_tdd
 *  INPUT           : periodicity,orderOfSIMsg,siWindowSize
 *  OUTPUT          : start_sf_for_this_sfn
 *  RETURNS         : none
 *  DESCRIPTION     : This function blocks the subframe in actual tdd  
 *****************************************************************************/

rrm_void_t block_sf_in_actual_tdd(U32  start_sf_for_this_sfn, 
        U16  periodicity, 
        U8   orderOfSIMsg,
        U16  siWindowSize)
{
    U32    count = RRM_ZERO;
    U32    i = RRM_ZERO;
    U16    temp = RRM_ZERO;
    count = start_sf_for_this_sfn;
    temp = count % siWindowSize;
    if (temp)
    {
        count = count - temp;
    }

    while(count < RRM_MAX_SF_VALUE)
    {
        /*cov fix start 40961*/
        for(i = count; ((i < count + siWindowSize) && (i < RRM_MAX_SF_VALUE)); i++)
            /*cov fix end 40961*/
        {
            if (sib_msg_data[i].sub_frame_type == DL_SUBFRAME)
            {
                sib_msg_data[i].occupied = RRM_TRUE;
                sib_msg_data[i].segment_id = orderOfSIMsg;
                //RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"\n SI [%d] on index [%d]", orderOfSIMsg, i);
            }
        }

        count = count + (periodicity * RRM_MAX_SUBFRAME);
    }
}
/****************************************************************************
 *  FUNCTION NAME   : check_for_number_of_occupied_and_empty_sf_tdd 
 *  INPUT           : start_sf_for_this_sfn,si_periodicity, 
 *                  : *p_already_present_si, *p_initial_value, si_order,
 *                  : siWindowSize
 *  OUTPUT          : RRM_TRUE if sf is free and RRM_FALSE if sf is occupied 
 *  RETURNS         : RRM_TRUE/RRM_FALSE 
 *  DESCRIPTION     : This function checks avaiablilty of occupied and empty 
 *                  : sub frame in TDD
 *****************************************************************************/

U8 check_for_number_of_occupied_and_empty_sf_tdd(U32     start_sf_for_this_sfn,
        U16     si_periodicity,
        U8      *p_already_present_si,
        U16     *p_initial_value,
        U8       si_order,
        U16      siWindowSize)
{

    U8     segment_id = RRM_ZERO;
    U32    count = RRM_ZERO;
    U8     status = RRM_FALSE;
    U8     initial_value_check = RRM_FALSE;
    U8     occurance = RRM_ZERO;
    U16    i = RRM_ZERO;
    U16    count_1 = RRM_ZERO;

    count = start_sf_for_this_sfn;

    //for (count = start_sf_for_this_sfn; count < 10240; count++)
    while(count < RRM_MAX_SF_VALUE)
    {
        if((sib_msg_data[count].occupied == RRM_TRUE) &&
                (sib_msg_data[count].sub_frame_type == DL_SUBFRAME) &&
                (((count / RRM_MAX_SUBFRAME) % RRM_TWO) != RRM_ZERO) && 
                ((count % RRM_MAX_SUBFRAME) != RRM_FIVE) &&
                (initial_value_check == RRM_TRUE))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    " SI = [%d] is occupied on SFN [%d] and SF [%d]", 
                    sib_msg_data[count].segment_id,
                    count / RRM_MAX_SUBFRAME, count%RRM_MAX_SUBFRAME);
            segment_id = sib_msg_data[count].segment_id;
            /*BUG_FIX_843_START*/
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "SI [%d] Collision happens with SI [%d]", si_order, segment_id);
            /*BUG_FIX_843_END*/
            status = RRM_FALSE;
            *p_already_present_si = segment_id;
            break;
        }
        else if((sib_msg_data[count].occupied == RRM_FALSE) &&
                (sib_msg_data[count].sub_frame_type == DL_SUBFRAME))
        {
            if (initial_value_check == RRM_FALSE)
            {
                *p_initial_value = count;
                initial_value_check = RRM_TRUE;
            }
            status = RRM_TRUE;
            count = count + (si_periodicity * RRM_MAX_SUBFRAME);
        }
        else
        {
            count++;
        }
    }

    for (i = RRM_ZERO; i < si_order; i++)
    {
        occurance = RRM_ZERO;
        for (count_1 = RRM_ZERO; count_1 < *p_initial_value; count_1++)
        {
            if ((i + RRM_ONE) == sib_msg_data[count_1].segment_id)
            {
                occurance++;
            }
        }
        if (occurance > siWindowSize)
        {
            status = RRM_FALSE; 
        }
    }
    return status;
}

/****************************************************************************
 *  FUNCTION NAME   : rrm_initialize_ul_dl_configuration_structure 
 *  INPUT           : p_data
 *  OUTPUT          : none 
 *  RETURNS         : none
 *  DESCRIPTION     : This Function initialize uplink & downlink configuration
 structure
 *****************************************************************************/

void rrm_initialize_ul_dl_configuration_structure(ul_dl_config_data_array_t  *p_data)
{
    p_data->ul_dl_config_data[RRM_ZERO].switch_point_periodicity = RRM_FIVE; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_THREE] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_FOUR] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_SIX] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_SEVEN] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_EIGHT] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ZERO].sub_frame_structure[RRM_NINE] = UL_SUBFRAME; 

    p_data->ul_dl_config_data[RRM_ONE].switch_point_periodicity = RRM_FIVE; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_THREE] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_FOUR] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_SIX] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_SEVEN] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_EIGHT] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_ONE].sub_frame_structure[RRM_NINE] = DL_SUBFRAME; 

    p_data->ul_dl_config_data[RRM_TWO].switch_point_periodicity = RRM_FIVE; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_THREE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_FOUR] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_SIX] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_SEVEN] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_EIGHT] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_TWO].sub_frame_structure[RRM_NINE] = DL_SUBFRAME; 

    p_data->ul_dl_config_data[RRM_THREE].switch_point_periodicity = RRM_TEN; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_THREE] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_FOUR] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_SIX] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_SEVEN] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_EIGHT] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_THREE].sub_frame_structure[RRM_NINE] = DL_SUBFRAME; 

    p_data->ul_dl_config_data[RRM_FOUR].switch_point_periodicity = RRM_TEN; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_THREE] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_FOUR] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_SIX] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_SEVEN] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_EIGHT] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FOUR].sub_frame_structure[RRM_NINE] = DL_SUBFRAME; 

    p_data->ul_dl_config_data[RRM_FIVE].switch_point_periodicity = RRM_TEN; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_THREE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_FOUR] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_SIX] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_SEVEN] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_EIGHT] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_FIVE].sub_frame_structure[RRM_NINE] = DL_SUBFRAME; 

    p_data->ul_dl_config_data[RRM_SIX].switch_point_periodicity = RRM_FIVE; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_ZERO] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_ONE] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_TWO] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_THREE] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_FOUR] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_FIVE] = DL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_SIX] = SPECIAL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_SEVEN] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_EIGHT] = UL_SUBFRAME; 
    p_data->ul_dl_config_data[RRM_SIX].sub_frame_structure[RRM_NINE] = DL_SUBFRAME; 

}

/****************************************************************************
 *	FUNCTION NAME   : rrm_get_collision_free_si_scheduling_list 
 *  INPUT		    : p_si_segment_data,p_si_window_length 
 *  OUTPUT		    : p_si_segment_data,p_si_window_length
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function prepares the collision free SI count ,
 *                    SI peridicities and SI window length.
 *****************************************************************************/
rrm_void_t 
rrm_get_collision_free_si_scheduling_list
(
 rrm_cell_context_t           *cell_context,
 rrm_si_segment_data_t        *p_si_segment_data,
 /*cov fix start 48132*/
 rrm_si_window_length_et      p_si_window_length
 /*cov fix end 48132*/
 )
{
    U32             sysFrameNum = RRM_ZERO;
    U32             x = RRM_ZERO;
    U32             periodicity = RRM_ZERO;
    U32             count = RRM_ZERO;
    U32             orderOfSIMsg = RRM_ZERO;
    U32             seg_count = RRM_ZERO;

    U8              is_si_window_circulated = RRM_FALSE;
    U8              si_window_modification_count = RRM_ZERO;
    U8              collision_free_entries_final_count = RRM_ZERO;
    U8              collision_free_entries_counter = RRM_ZERO;
    U8              collision_free_entries_with_si_window_length = RRM_ZERO;
    U8              siWindowSize = RRM_ZERO;
    U8              collision_found_in_total = RRM_FALSE;
    U8              collision_count = RRM_ZERO;
    U8              old_si_segment_position = RRM_ZERO;
    U8              new_si_segment_position = RRM_ZERO;
    U8              si_segment_found = RRM_FALSE;
    U8              status = RRM_FALSE;
    U8              i = RRM_ZERO;
    U8              already_present_si = RRM_INVALID_SI_PRESENT_U8;
    U16             actual_start_sf = RRM_INVALID_START_SF_U16;

    rrm_si_segment_data_t       temp_si_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    rrm_si_segment_data_t       minimum_collision_free_si_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    rrm_si_segment_data_t       temp_minimum_collision_free_si_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    ul_dl_config_data_array_t   ul_dl_data;
    /* coverity : 16540 ,  ,rel2.0.1 */
    /* coverity : CID 29727 */
    rrm_si_window_length_et     new_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_1;



    RRM_UT_TRACE_ENTER();
    /*cov fix start 48132*/
    rrm_get_window_lenth_in_ms(p_si_window_length, &siWindowSize); 
    /*cov fix end 48132*/
    rrm_initialize_ul_dl_configuration_structure(&ul_dl_data);
    /* Copy the orginal scheduling info to a temporary data struct */
    RRM_MEMCPY(&temp_si_data, p_si_segment_data, sizeof(rrm_si_segment_data_t) * RRM_MAX_SI_SEGMENTS);

    for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SFN_VALUE ; sysFrameNum++)
    {
        /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
          "SFN :- [%d] and Sub Frame Type is ", sysFrameNum);*/
        for (i = RRM_ZERO; i <RRM_MAX_SUBFRAME  ; i++)
        {
            sib_msg_data[sysFrameNum * RRM_MAX_SUBFRAME + i].segment_id = RRM_INVALID_SEGMENT_ID_U8;
            sib_msg_data[sysFrameNum * RRM_MAX_SUBFRAME + i].sub_frame_type = 
                ul_dl_data.ul_dl_config_data[cell_context->ran_info.physical_layer_params.
                physical_layer_param_tdd_frame_structure.sub_frame_assignment].
                sub_frame_structure[i];
            if (sib_msg_data[sysFrameNum * RRM_MAX_SUBFRAME + i].sub_frame_type == DL_SUBFRAME)
            {
                sib_msg_data[sysFrameNum * RRM_MAX_SUBFRAME + i].occupied = RRM_FALSE;
            }
            else
            {
                sib_msg_data[sysFrameNum * RRM_MAX_SUBFRAME + i].occupied = RRM_TRUE;
            }
            /*  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                " SF = %d; Occupied = %d [%d]", sysFrameNum * 10 + i, 
                sib_msg_data[sysFrameNum * 10 + i].occupied, sib_msg_data[sysFrameNum * 10 + i].sub_frame_type);*/
        }
        if (((sysFrameNum) % RRM_TWO) == RRM_ZERO)
        {
            sib_msg_data[sysFrameNum * RRM_MAX_SUBFRAME + RRM_FIVE].occupied = RRM_TRUE;
        }
    }

    while (seg_count < RRM_MAX_SI_SEGMENTS)
    {
        orderOfSIMsg = p_si_segment_data[seg_count].si_segment_id;
        periodicity  = p_si_segment_data[seg_count].si_segment_periodicity;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "SI - [%d], Periodicity - [%d]", orderOfSIMsg, periodicity);
        /*As per the specification 36.331 start SFN and SF are calculated by using
         **following formula
         **x = (n - 1)*w, where w is the si-WindowLength
         **n which corresponds to the order of entry in the list of SI messages
         **configured by schedulingInfoList in SystemInformationBlockType1
         **Subframe a = (x mod 10)
         **starting SFN is calculated by (SFN mod T) = FLOOR(x/10)
         **where T is the si-Periodicity of the concerned SI message
         **/
        x = (orderOfSIMsg - RRM_ONE) * siWindowSize;
        /*Find the starting SF*/
        /*Find the start SFN*/
        /*subFrameNum = x % 10;

          y = (U32)RRM_FLOOR((float)x/10);
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
         * "x - [%d], y - [%d] sysFrameNum :-", x, y);*/
        collision_found_in_total = RRM_FALSE;
        status = check_for_number_of_occupied_and_empty_sf_tdd(x,
                periodicity, &already_present_si, &actual_start_sf, orderOfSIMsg, siWindowSize);
        if (RRM_TRUE == status)
        {
            collision_found_in_total = RRM_FALSE;
        }
        else
        {
            if(collision_free_entries_final_count < collision_free_entries_counter)
            {
                RRM_MEMCPY(&minimum_collision_free_si_data, 
                        &temp_minimum_collision_free_si_data,
                        sizeof(rrm_si_segment_data_t) * RRM_MAX_SI_SEGMENTS);
                collision_free_entries_final_count = collision_free_entries_counter;
                collision_free_entries_with_si_window_length = siWindowSize;
            }
            collision_free_entries_counter = RRM_ZERO;
            collision_found_in_total = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Collision found for SI - [%d] at SFN [%d]", orderOfSIMsg, sysFrameNum);
            if (collision_count == RRM_ZERO)
            {
                old_si_segment_position = orderOfSIMsg;
            }
            new_si_segment_position = orderOfSIMsg;
            collision_count++;
            for (i = RRM_ZERO; i < RRM_MAX_SI_SEGMENTS; i++)
            {
                if (RRM_FALSE ==  p_si_segment_data[i].is_periodicity_changed)
                {
                    p_si_segment_data[i].is_periodicity_changed = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Periodicity Modified for SI - [%d] Old [%d] ", 
                            i+1, p_si_segment_data[i].si_segment_periodicity);
                    /*BUG_FIX_843_START*/
                    if (p_si_segment_data[i].si_segment_periodicity == RRM_SI_PERIODICITY_RF_512)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "Not modifying periodicity for SI - [%d]  New [%d]", 
                                i+RRM_ONE, p_si_segment_data[i].si_segment_periodicity);
                    }
                    else
                    {
                        p_si_segment_data[i].si_segment_periodicity *= 2;
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "Periodicity Modified for SI - [%d]  New [%d]", 
                                i+RRM_ONE, p_si_segment_data[i].si_segment_periodicity);
                    }
                    /*BUG_FIX_843_END*/
                    break;
                }
            }
            /*BUG_FIX_843_START*/
            if (i != RRM_MAX_SI_SEGMENTS)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "New Periodicity [%d]", p_si_segment_data[i].si_segment_periodicity);
            }
            /*BUG_FIX_843_END*/
            for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SFN_VALUE * RRM_MAX_SUBFRAME; sysFrameNum++)
            {
                sib_msg_data[sysFrameNum].segment_id = RRM_INVALID_SEGMENT_ID_U8;
                sib_msg_data[sysFrameNum].occupied = RRM_FALSE;
            }
        }
        if(collision_found_in_total == RRM_FALSE)
        {
            block_sf_in_actual_tdd(actual_start_sf, periodicity, orderOfSIMsg, siWindowSize);
            /* Store entries temporarily in array to get the maximum number of
             * collision free entries without changing the si_window length
             */
            temp_minimum_collision_free_si_data[collision_free_entries_counter].si_segment_id = orderOfSIMsg;
            temp_minimum_collision_free_si_data[collision_free_entries_counter].si_segment_periodicity = 
                p_si_segment_data[seg_count].si_segment_periodicity;
            temp_minimum_collision_free_si_data[collision_free_entries_counter].is_periodicity_changed = RRM_TRUE;
            collision_free_entries_counter++;

            seg_count++;
            sysFrameNum = RRM_ZERO;
        }
        else
        {
            if ((collision_count == RRM_MAX_SI_SEGMENTS + RRM_ONE) && (old_si_segment_position == new_si_segment_position))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Collision reached to MAX [%d] for SI [%d]", 
                        collision_count, old_si_segment_position);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " Reshuffling SI Window OLD Value [%d] ", siWindowSize);
                /* Copy the orginal scheduling info to a temporary data struct */
                /*BUG_FIX_843_START*/
                RRM_MEMCPY(p_si_segment_data, &temp_si_data, sizeof(rrm_si_segment_data_t) * RRM_MAX_SI_SEGMENTS);
                /*BUG_FIX_843_END*/
                if(RRM_TRUE == is_si_window_circulated)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "SI Window Length Circulated.. ");
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Reporting least collision enteries for initially configured window length ");
                    break;
                }
                siWindowSize = return_new_si_window(siWindowSize);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " SI Window NEW Value [%d] ", siWindowSize);
                rrm_get_rrm_rrc_si_window_length( siWindowSize , &new_si_window_length);
                si_window_modification_count++;
                /*BUG_FIX_843_START*/
                if (si_window_modification_count == RRM_SIX)
                    /*BUG_FIX_843_END*/
                {
                    is_si_window_circulated = RRM_TRUE;
                }
                collision_count = RRM_ZERO;
            }
            else if (old_si_segment_position != new_si_segment_position)
            {
                old_si_segment_position = new_si_segment_position;
            }
            seg_count = RRM_ZERO;
        }
    }
    /* Prinitng the Matrx */
    if (RRM_FALSE == collision_found_in_total)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Finally Has the collision free info");
        count = RRM_ZERO;
        for (seg_count = RRM_ZERO; seg_count < RRM_MAX_SI_SEGMENTS; seg_count++)
        {
            for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SF_VALUE; sysFrameNum++)
            {
                if(seg_count + RRM_ONE == sib_msg_data[sysFrameNum].segment_id)
                {
                    count++;
                    if (RRM_FALSE == si_segment_found)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"SI %d Periodicity = [%d]", 
                                seg_count + RRM_ONE, p_si_segment_data[seg_count].si_segment_periodicity);
                        si_segment_found = RRM_TRUE;
                    }
                    /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED," [%d]; ", sysFrameNum); */
                }
            }
            si_segment_found = RRM_FALSE;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Collision Free Minimum Entries are...");
        for (seg_count = RRM_ZERO; seg_count < collision_free_entries_final_count; seg_count++)
        {
            if (RRM_TRUE == minimum_collision_free_si_data[seg_count].is_periodicity_changed)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"SI %d Periodicity = [%d] ", 
                        seg_count + RRM_ONE, minimum_collision_free_si_data[seg_count].si_segment_periodicity);
            }
        }
        for (seg_count = collision_free_entries_final_count; 
                seg_count < RRM_MAX_SI_SEGMENTS; seg_count++)
        {
            /* Assign INVALID Periodicities for the segmets that can't be scheduled */
            p_si_segment_data[seg_count].si_segment_periodicity = 0xFFFF;
            p_si_segment_data[seg_count].si_segment_id = seg_count + RRM_ONE;
            p_si_segment_data[seg_count].is_periodicity_changed = RRM_FALSE;
        }
        rrm_get_rrm_rrc_si_window_length( collision_free_entries_with_si_window_length , &new_si_window_length);
    }
}


#else
/****************************************************************************
 *	FUNCTION NAME   : block_sf_in_actual 
 *  INPUT		    : start_sf_for_this_sfn,siWindowSize,orderOfSIMsg
 *  OUTPUT		    : None
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function marks the subframes, that are specified
 *                    by input, as busy.
 *****************************************************************************/
rrm_void_t 
block_sf_in_actual
(
 U32 start_sf_for_this_sfn, 
 U8  siWindowSize, 
 U8  orderOfSIMsg
 )
{
    U8     count_to_check = RRM_ZERO;
    U8     occupied_count = RRM_ZERO;
    U32    count = RRM_ZERO;
    U32    max_count_to_check = RRM_ZERO;

    if(siWindowSize == RRM_ONE)
    {
        count_to_check = RRM_ONE;
    }
    else if(siWindowSize == RRM_TWO)
    {
        count_to_check = RRM_TWO;
    }
    else if(siWindowSize == RRM_FIVE)
    {
        count_to_check = RRM_FIVE;
    }
    else if(siWindowSize == RRM_TEN)
    {
        count_to_check = RRM_TEN;
    }
    else if(siWindowSize == RRM_FIFTEEN )
    {
        count_to_check = RRM_FIFTEEN + RRM_FIVE;
    }
    else if(siWindowSize == RRM_TWENTY)
    {
        count_to_check = RRM_TWENTY;
    }
    /* SPR_11104_FIX_START */
    else if(siWindowSize == RRM_FORTY)
    {
        count_to_check = RRM_FORTY;
    }
    /* SPR_11104_FIX_END */
    if (siWindowSize <= RRM_TEN)
    {
        max_count_to_check = start_sf_for_this_sfn + RRM_TEN;
    }
    else
    {
        max_count_to_check = start_sf_for_this_sfn + count_to_check;
    }
    for (count = start_sf_for_this_sfn; count < max_count_to_check; count++)
    {
        if(sib_msg_data[count].occupied == RRM_TRUE)
        {
            /* Do Nothing */
            /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"\n Actual SI = [%d] is occupied on position [%d]", 
              sib_msg_data[count].segment_id,
              count%10);*/
        }
        else
        {
            sib_msg_data[count].occupied = RRM_TRUE;
            sib_msg_data[count].segment_id = orderOfSIMsg;
            occupied_count++;
            /*
             ** RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"\n SIB [%d] on index [%d]", orderOfSIMsg, count);
             */
            if (occupied_count == siWindowSize)
                break;
        }
    }
}
/****************************************************************************
 *	FUNCTION NAME   : check_for_number_of_occupied_and_empty_sf 
 *  INPUT		    : start_sf_for_this_sfn,siWindowSize
 *  OUTPUT		    : None
 *	RETURNS		    : RRM_TRUE  : if collision is found
 *                    RRM_FALSE : if collision is not found
 *	DESCRIPTION	    : This function checks for the occupied and empty 
 *                    subframes to find the collision.
 *****************************************************************************/
rrm_bool_et 
check_for_number_of_occupied_and_empty_sf
(   
 U32     start_sf_for_this_sfn,
 U8      siWindowSize
 )
{
    U8     count_to_check = RRM_ZERO;
    U8     occupied_count = RRM_ZERO;
    U8     unused_count = RRM_ZERO;
    U8     segment_id= RRM_ZERO;
    U32    count = RRM_ZERO;
    U32    max_count_to_check = RRM_ZERO;

    if(siWindowSize == RRM_ONE)
    {
        count_to_check = RRM_ONE;
    }
    else if(siWindowSize == RRM_TWO)
    {
        count_to_check = RRM_TWO;
    }
    else if(siWindowSize == RRM_FIVE)
    {
        count_to_check = RRM_FIVE;
    }
    else if(siWindowSize == RRM_TEN)
    {
        count_to_check = RRM_TEN;
    }
    else if(siWindowSize == RRM_FIFTEEN)
    {
        count_to_check = RRM_FIFTEEN + RRM_FIVE;
    }
    else if(siWindowSize == RRM_TWENTY)
    {
        count_to_check = RRM_TWENTY;
    }
    /* SPR_11104_FIX_START */
    else if(siWindowSize == RRM_FORTY)
    {
        count_to_check = RRM_FORTY;
    }
    /* SPR_11104_FIX_END */
    if (siWindowSize <= RRM_TEN)
    {
        max_count_to_check = start_sf_for_this_sfn + RRM_TEN;
    }
    else
    {
        max_count_to_check = start_sf_for_this_sfn + count_to_check;
    }
    for (count = start_sf_for_this_sfn; count < max_count_to_check; count++)
    {
        if(sib_msg_data[count].occupied == RRM_TRUE)
        {
            /* RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"\n SI = [%d] is occupied on position [%d]", 
               sib_msg_data[count].segment_id,
               count%10);*/
            occupied_count++;
            segment_id = sib_msg_data[count].segment_id;
        }
        else
        {
            unused_count++;
        }
    }

    /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
      "Occupied Count = [%d],  Unused Count = [%d]", 
      occupied_count, unused_count);*/
    if(siWindowSize == RRM_FIFTEEN)
    {
        count_to_check = RRM_FIFTEEN;
    }
    if (unused_count >= count_to_check)
    {
        return RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Collision happens because of SI [%d]", segment_id);
        return RRM_FALSE;
    }
}
/****************************************************************************
 *	FUNCTION NAME   : rrm_get_collision_free_si_scheduling_list 
 *  INPUT		    : cell_context,p_si_segment_data,p_si_window_length 
 *  OUTPUT		    : p_si_segment_data,p_si_window_length
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function prepares the collision free SI count ,
 *                    SI peridicities and SI window length.
 *****************************************************************************/
rrm_void_t   
rrm_get_collision_free_si_scheduling_list
(
 rrm_cell_context_t           *cell_context,
 rrm_si_segment_data_t        *p_si_segment_data,
 /*cov fix start 48132*/
 rrm_si_window_length_et      p_si_window_length
 /*cov fix end 48132*/
 )
{
    U16      sysFrameNum = RRM_ZERO;
    U16      x = RRM_ZERO;
    U16      y = RRM_ZERO;
    U16      periodicity = RRM_ZERO;
    U16      count = RRM_ZERO;
    U16      start_sf_for_this_sfn = RRM_ZERO;
    U8       orderOfSIMsg = RRM_ZERO;
    U8       seg_count = RRM_ZERO;
    U8       si_window_modification_count = RRM_ZERO;
    U8       collision_free_entries_final_count = RRM_ZERO;
    U8       collision_free_entries_counter = RRM_ZERO;
    U8       collision_free_entries_with_si_window_length = RRM_ZERO;
    U8       collision_count = RRM_ZERO;
    U8       old_si_segment_position = RRM_ZERO;
    U8       new_si_segment_position = RRM_ZERO;
    U8       si_segment_found = RRM_FALSE;
    U8       siWindowSize = RRM_ZERO;
    rrm_bool_et            is_si_window_circulated = RRM_FALSE;
    rrm_bool_et            collision_found_in_total = RRM_FALSE;
    rrm_bool_et            status = RRM_FALSE;
    rrm_si_segment_data_t  temp_si_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    rrm_si_segment_data_t  minimum_collision_free_si_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    rrm_si_segment_data_t  temp_minimum_collision_free_si_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    /* Coverity_ID : 29727 */
    rrm_si_window_length_et new_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_1;

    RRM_UT_TRACE_ENTER();
    /* coverity : 29726 ,  ,rel2.0.1 */
    rrm_get_window_lenth_in_ms(p_si_window_length, &siWindowSize); 

    /* Cov_121042_Fix_Start */
    if(RRM_ZERO == siWindowSize)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Incorrect value for si window length = %d. Can't proceed further",siWindowSize);
        return;
    }
    /* Cov_121042_Fix_End */

    /* To obtain the collision free SIB scheduling list , RRM shall consider all the 
     * possible SIB's that can be scheduled in the system at any point of time :
     * -- SIBs scheduled by SON
     * -- SIBs Scheduled at the time of Cell reconfiguration
     * -- PWS (ETWS/CMAS) SIB's
     * 
     * For the SI's ,other than configured  by the user, RRM will consider a default
     * periodicity of rf32 .
     * 
     * This information (SI periodicties) shall be used by RRM later on when any 
     * new SIB in the particular SI is scheduled.
     *
     * This calculation for all the SI segements has been done initially because the algo
     * can also change the si_window_length configured by user. This si_window_len
     * shall be configured with L3 during Cell Setup request so all the SIBs and their 
     * periodicities has been taken into account for the final calculation.
     */

    /* Copy the orginal scheduling info to a temporary data struct */
    RRM_MEMCPY(&temp_si_data, p_si_segment_data, sizeof(rrm_si_segment_data_t) * RRM_MAX_SI_SEGMENTS);

    /* Initialize the SFN-SF array */
    for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SFN_VALUE * RRM_TEN; sysFrameNum++)
    {
        sib_msg_data[sysFrameNum].segment_id = RRM_INVALID_SEGMENT_ID_U8;
        sib_msg_data[sysFrameNum].occupied = RRM_FALSE;
    }

    while (seg_count < RRM_MAX_SI_SEGMENTS)
    {
        orderOfSIMsg = p_si_segment_data[seg_count].si_segment_id;
        periodicity  = p_si_segment_data[seg_count].si_segment_periodicity;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "SI - [%d], Periodicity - [%d]", orderOfSIMsg, periodicity);
        /*As per the specification 36.331 start SFN and SF are calculated by using
         **following formula
         **x = (n - 1)*w, where w is the si-WindowLength
         **n which corresponds to the order of entry in the list of SI messages
         **configured by schedulingInfoList in SystemInformationBlockType1
         **Subframe a = (x mod 10)
         **starting SFN is calculated by (SFN mod T) = FLOOR(x/10)
         **where T is the si-Periodicity of the concerned SI message
         **/
        x = (orderOfSIMsg - RRM_ONE) * siWindowSize;
        /*Find the starting SF*/

        y = (U32)RRM_FLOOR((float)x/RRM_TEN);
        /*Find the start SFN*/
        /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
          "x - [%d], y - [%d] sysFrameNum :-", x, y);*/

        /* Initialise this flag as it will determine if the enteries are collision free or not */
        collision_found_in_total = RRM_FALSE;
        for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SFN_VALUE; sysFrameNum++)
        {
            if((sysFrameNum % periodicity) == y)
            {
                /* RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                   "Working on SFN [%d] ", sysFrameNum);*/
                start_sf_for_this_sfn = sysFrameNum * RRM_TEN;
                status = check_for_number_of_occupied_and_empty_sf(start_sf_for_this_sfn,
                        siWindowSize);

                if (RRM_TRUE == status)
                {
                    collision_found_in_total = RRM_FALSE;
                }
                else
                {
                    if(collision_free_entries_final_count < collision_free_entries_counter ) 
                    {
                        RRM_MEMCPY(&minimum_collision_free_si_data, 
                                &temp_minimum_collision_free_si_data,
                                sizeof(rrm_si_segment_data_t) * RRM_MAX_SI_SEGMENTS);
                        collision_free_entries_final_count = collision_free_entries_counter;
                        collision_free_entries_with_si_window_length = siWindowSize;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Enteries Copied with count = %d and si_window = %d", 
                                collision_free_entries_final_count, siWindowSize);
                    }
                    collision_free_entries_counter = RRM_ZERO;
                    collision_found_in_total = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Collision found for SI - [%d] at SFN [%d]", orderOfSIMsg, sysFrameNum);
                    if (collision_count == RRM_ZERO)
                    {
                        old_si_segment_position = orderOfSIMsg;
                    }
                    new_si_segment_position = orderOfSIMsg;
                    collision_count++;
                    for (count = RRM_ZERO; count < RRM_MAX_SI_SEGMENTS; count++)
                    {
                        if (RRM_FALSE ==  p_si_segment_data[count].is_periodicity_changed)
                        {
                            p_si_segment_data[count].is_periodicity_changed = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Periodicity Modified for SI - [%d] Old [%d] ", 
                                    count+RRM_ONE, p_si_segment_data[count].si_segment_periodicity);
                            /*BUG_FIX_843_START*/
                            if (p_si_segment_data[count].si_segment_periodicity == RRM_SI_PERIODICITY_RF_512)
                            {
                                /*SPR 17777 +-*/
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                        "Not modifying periodicity for SI - [%d]  New [%d];Unused variable cell_context=%p", 
                                        count+RRM_ONE, p_si_segment_data[count].si_segment_periodicity,cell_context);
                                /*SPR 17777 +-*/
                            }
                            else
                            {
                                p_si_segment_data[count].si_segment_periodicity *= RRM_TWO;
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                                        "Periodicity Modified for SI - [%d]  New [%d]", 
                                        count+RRM_ONE, p_si_segment_data[count].si_segment_periodicity);
                            }
                            /*BUG_FIX_843_END*/
                            break;
                        }
                    }
                    /*BUG_FIX_843_START*/
                    if (count != RRM_MAX_SI_SEGMENTS)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "New Periodicity [%d]", p_si_segment_data[count].si_segment_periodicity);
                    }
                    /*BUG_FIX_843_END*/
                    for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SFN_VALUE * RRM_MAX_SUBFRAME; sysFrameNum++)
                    {
                        sib_msg_data[sysFrameNum].segment_id = RRM_INVALID_SEGMENT_ID_U8;
                        sib_msg_data[sysFrameNum].occupied = RRM_FALSE;
                    }
                    break;                              
                }
            }
        }
        if(collision_found_in_total == RRM_FALSE)
        {
            /* Above logic checks for the collision on all the SFN's  for any other sceduled SI segment.
             * This code will actually bloack the SFN and SF for the particular SI segment.
             */
            /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
              "Blocking in Actual:- ");*/
            for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SFN_VALUE; sysFrameNum++)
            {
                if((sysFrameNum % periodicity) == y)
                {
                    /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                      "Blocking SFN [%d] ", sysFrameNum);*/
                    start_sf_for_this_sfn = sysFrameNum * RRM_MAX_SUBFRAME;
                    block_sf_in_actual(start_sf_for_this_sfn, siWindowSize, orderOfSIMsg);
                }
            }
            /* Store entries temporarily in array to get the maximum number of
             * collision free entries without changing the si_window length
             */
            temp_minimum_collision_free_si_data[collision_free_entries_counter].si_segment_id = orderOfSIMsg;
            temp_minimum_collision_free_si_data[collision_free_entries_counter].si_segment_periodicity = 
                p_si_segment_data[seg_count].si_segment_periodicity;
            temp_minimum_collision_free_si_data[collision_free_entries_counter].is_periodicity_changed = RRM_TRUE;
            collision_free_entries_counter++;

            /* Increment for next SI segment */
            seg_count++;
            sysFrameNum = RRM_ZERO;
        }
        else
        {
            if ((collision_count == RRM_MAX_SI_SEGMENTS+ RRM_ONE) && (old_si_segment_position == new_si_segment_position))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Collision reached to MAX [%d] for SI [%d]", 
                        collision_count, old_si_segment_position);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Reshuffling SI Window OLD Value [%d] ", siWindowSize);
                /* Copy the orginal scheduling info to a temporary data struct */
                RRM_MEMCPY(p_si_segment_data, &temp_si_data, sizeof(rrm_si_segment_data_t) * RRM_MAX_SI_SEGMENTS);
                if(RRM_TRUE == is_si_window_circulated)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "SI Window Length Circulated.. ");
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Reporting least collision enteries for initially configured window length ");
                    break;
                }
                siWindowSize = return_new_si_window(siWindowSize);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " SI Window NEW Value [%d] ", siWindowSize);
                rrm_get_rrm_rrc_si_window_length( siWindowSize , &new_si_window_length);
                si_window_modification_count++;
                if (si_window_modification_count == RRM_SIX)
                {
                    is_si_window_circulated = RRM_TRUE;
                }
                collision_count = RRM_ZERO;
            }
            else if (old_si_segment_position != new_si_segment_position)
            {
                old_si_segment_position = new_si_segment_position;
            }
            seg_count = RRM_ZERO;
        }
    }
    /* Prinitng the Matrx */
    if (RRM_FALSE == collision_found_in_total)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Finally Has the collision free info");
        count = RRM_ZERO;
        for (seg_count = RRM_ZERO; seg_count < RRM_MAX_SI_SEGMENTS; seg_count++)
        {
            for (sysFrameNum = RRM_ZERO; sysFrameNum < RRM_MAX_SF_VALUE; sysFrameNum++)
            {
                if(seg_count + RRM_ONE == sib_msg_data[sysFrameNum].segment_id)
                {
                    count++;
                    if (RRM_FALSE == si_segment_found)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                "SI [%d] Periodicity = [%d]", 
                                seg_count + 1, p_si_segment_data[seg_count].si_segment_periodicity);
                        si_segment_found = RRM_TRUE;
                    }
                    if((count % siWindowSize) == RRM_ONE)
                    {
                        /* RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"[%d]-", sysFrameNum);*/
                    }
                    else if((count % siWindowSize) == RRM_ZERO)
                    {
                        /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"[%d]; ", sysFrameNum); */
                    }
                }
            }
            si_segment_found = RRM_FALSE;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Collision Free Minimum Entries are...");
        for (seg_count = RRM_ZERO; seg_count < collision_free_entries_final_count; seg_count++)
        {
            if (RRM_TRUE == minimum_collision_free_si_data[seg_count].is_periodicity_changed)
            {
                p_si_segment_data[seg_count].si_segment_id = seg_count + RRM_ONE;
                p_si_segment_data[seg_count].si_segment_periodicity = 
                    minimum_collision_free_si_data[seg_count].si_segment_periodicity;
                p_si_segment_data[seg_count].is_periodicity_changed = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"SI [%d] Periodicity = [%d] ", 
                        seg_count + RRM_ONE, minimum_collision_free_si_data[seg_count].si_segment_periodicity);
            }
        }
        for (seg_count = collision_free_entries_final_count; 
                seg_count < RRM_MAX_SI_SEGMENTS; seg_count++)
        {
            /* Assign INVALID Periodicities for the segmets that can't be scheduled */
            p_si_segment_data[seg_count].si_segment_periodicity = 0xFFFF;
            p_si_segment_data[seg_count].si_segment_id = seg_count + RRM_ONE;
            p_si_segment_data[seg_count].is_periodicity_changed = RRM_FALSE;
        }
        rrm_get_rrm_rrc_si_window_length( collision_free_entries_with_si_window_length , &new_si_window_length);
     /*Coverity 82703 Fix Start*/
     /*p_si_window_length = new_si_window_length;*/
     /*Coverity 82703 Fix End*/
    }
}
#endif
/****************************************************************************
 *	FUNCTION NAME   : get_rrm_si_peridicity_from_peridicity_in_rf 
 *  INPUT		    : p_periodicity_rf
 *  OUTPUT		    : rrm_si_periodicity
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function converts the si periodicity into
 *                    RF form that is required at RRM-RRC interface.
 *****************************************************************************/
rrm_void_t
get_rrm_si_peridicity_from_peridicity_in_rf
(
 U16  periodicity_rf,
 U8   *rrm_si_periodicity
 )
{
    switch(periodicity_rf)
    {
        case RRM_SI_PERIODICITY_RF_8:
            *rrm_si_periodicity= RRM_RRC_RF_8;
            break;
        case RRM_SI_PERIODICITY_RF_16:
            *rrm_si_periodicity = RRM_RRC_RF_16;
            break;
        case RRM_SI_PERIODICITY_RF_32:
            *rrm_si_periodicity = RRM_RRC_RF_32;
            break;
        case RRM_SI_PERIODICITY_RF_64:
            *rrm_si_periodicity = RRM_RRC_RF_64;
            break;
        case RRM_SI_PERIODICITY_RF_128:
            *rrm_si_periodicity= RRM_RRC_RF_128;
            break;
        case RRM_SI_PERIODICITY_RF_256:
            *rrm_si_periodicity= RRM_RRC_RF_256;
            break;
        case RRM_SI_PERIODICITY_RF_512:
            *rrm_si_periodicity= RRM_RRC_RF_512;
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for si periodicity = %d",periodicity_rf);
            break;
    }
}

/****************************************************************************
 *	FUNCTION NAME   : clear_sib_mapping_info_in_sib1 
 *  INPUT		    : p_scheduling_info_list , sib_type
 *  OUTPUT		    : None
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function clears the scheduling info of the sibs
 *                    that are not present in the cell setup request.
 *****************************************************************************/
rrm_void_t
clear_sib_mapping_info_in_sib1
(
 scheduling_info_list_t *p_scheduling_info_list,
 rrm_sib_type_et         sib_type
 )
{
    U8          si_count        = RRM_ZERO;
    U8          sib_count       = RRM_ZERO;
    U8          new_si_count    = RRM_ZERO; 
    U8          new_sib_count    = RRM_ZERO; 
    rrm_bool_et sib_cleared     = RRM_FALSE;  

    for(si_count = RRM_ZERO ; ((si_count < p_scheduling_info_list->count) && !sib_cleared ) ; si_count++)
    {
        for(sib_count = RRM_ZERO; sib_count < p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.count; sib_count++)
        {
            if(p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.sib_type[sib_count] == sib_type)
            {
                new_sib_count = sib_count;
                sib_cleared = RRM_TRUE;
                break;
            }    
        }


        if(sib_cleared) 
        {
            /* CSR 00051178 CHANGES START */
            /* If this is the only SIB in this SI */
            if(RRM_ONE == p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.count)
            {          
                /* CSR 00051178 CHANGES START */
                for(new_si_count = si_count; new_si_count < (p_scheduling_info_list->count - RRM_ONE); new_si_count++)
                {
                    RRM_MEMCPY(&(p_scheduling_info_list->scheduling_info[new_si_count]),
                            &(p_scheduling_info_list->scheduling_info[new_si_count + RRM_ONE]),
                            sizeof(scheduling_info_t));
                }
                p_scheduling_info_list->count--;
                /* CSR 00051178 CHANGES END */
            }
            else
            {
                for(sib_count = new_sib_count ; sib_count < (p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.count -RRM_ONE)  ; 
                        sib_count++)
                {
                    /* CSR 00051178 CHANGES START */
                    p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.sib_type[sib_count] =
                        p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.sib_type[sib_count+RRM_ONE];
                    /* CSR 00051178 CHANGES END */
                }
                /* CSR 00051178 CHANGES START */
                /* Reduce the number of SIBs in this SI by one */
                p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.count = 
                    p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.count - RRM_ONE;
                /* CSR 00051178 CHANGES END */
            }
            /* BUG_371 FIX START */
            /*Cov_fix_start_63687*/
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "SIB [%d] is removed from Scheduling Info List"
                    "New Scheduling Info list Count is (%d)",sib_type,p_scheduling_info_list->count);
            /* BUG_371 FIX END */
            /*Cov_fix_end_63687*/
        } 
    }

    /* BUG_371 FIX START */
    if(RRM_FALSE == sib_cleared)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "SIB [%d] is Not found in Scheduling Info List"
                "Scheduling Info list Count is (%d)",sib_type,p_scheduling_info_list->count);
    }
    /* BUG_371 FIX END */
}

/****************************************************************************
 *	FUNCTION NAME   : get_peridicity_in_rf_terms 
 *  INPUT		    : periodicity
 *  OUTPUT		    : p_periodicity_rf
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function converts SI periodiicty in terms of radio
 *                    frames.
 *****************************************************************************/
void
get_peridicity_in_rf_terms
(
 U8    periodicity, 
 U16    *p_periodicity_rf
 )
{
    switch(periodicity)
    {
        case RRM_RRC_RF_8:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_8;
            break;
        case RRM_RRC_RF_16:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_16;
            break;
        case RRM_RRC_RF_32:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_32;
            break;
        case RRM_RRC_RF_64:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_64;
            break;
        case RRM_RRC_RF_128:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_128;
            break;
        case RRM_RRC_RF_256:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_256;
            break;
        case RRM_RRC_RF_512:
            *p_periodicity_rf = RRM_SI_PERIODICITY_RF_512;
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for si periodicty = %d",periodicity);
            break;
    }
}

/****************************************************************************
 *	FUNCTION NAME   : check_for_available_sfn 
 *  INPUT		    : si_periodicity , x 
 *  OUTPUT		    : None
 *	RETURNS		    : RRM_TRUE : At least one SFN is avaiable for the SI
 *                    RRM_FALSE: No SFN is avaiable for the SI
 *	DESCRIPTION	    : This function checks for the avaialbility of the
 *                    SFN , for a particular SI message.
 *****************************************************************************/
rrm_bool_t
check_for_available_sfn
(
 U8    x,
 U8    si_periodicity 
 )
{
    U16          rf_num = RRM_ZERO;
    U16          periodicity_rf = RRM_ZERO ;
    rrm_bool_t   ret_val = RRM_FALSE;

    for(rf_num = RRM_ZERO ; rf_num < RRM_MAX_SFN_VALUE ; rf_num++)
    {
        get_peridicity_in_rf_terms(si_periodicity ,&periodicity_rf);
        /*coverity id: 29033, rel2.0.1,*/
        if(RRM_ZERO != periodicity_rf)
        {
            if((rf_num % periodicity_rf) == (RRM_FLOOR(x/RRM_TEN)))
            {
                ret_val = RRM_TRUE;
                break;
            }
        }
    }

    return ret_val;
}

/****************************************************************************
 *	FUNCTION NAME   : rrm_validate_si_periodicities 
 *  INPUT		    : p_scheduling_info_list , si_window_length
 *  OUTPUT		    : p_scheduling_info_list
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function validates the periodicities for SI 
 *                    messages.If no SFN is found for the SI meesage ,its
 *                    periodicty is increased.
 *****************************************************************************/
rrm_void_t
rrm_validate_si_periodicities
(
 scheduling_info_list_t  *p_scheduling_info_list,
 U8                      si_window_length
 )
{
    U8   si_count = RRM_ZERO;
    U8   si_periodicity = RRM_ZERO;
    U8   si_window_length_in_ms  = RRM_ZERO;
    U8   x = RRM_ZERO; 

    while(si_count < p_scheduling_info_list->count)
    {
        /* coverity : 29723 ,  ,rel2.0.1 */
        rrm_get_window_lenth_in_ms((rrm_si_window_length_et)si_window_length,&si_window_length_in_ms);
        x = si_count * si_window_length_in_ms ;
        si_periodicity = p_scheduling_info_list->scheduling_info[si_count].si_periodicity;

        if(RRM_FALSE == check_for_available_sfn(x , si_periodicity ))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Increment the periodicity for the SI[%d], as Invalid periodicy[%d] is found",
                    si_count,si_periodicity);
            if(si_periodicity == RRM_RRC_RF_512)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Can't increment the periodicy[%d] for SI [%d] further,go to next SI",
                        si_periodicity,si_count);
                si_count++;
            }
            else
            {
                p_scheduling_info_list->scheduling_info[si_count].si_periodicity = si_periodicity + RRM_ONE;
            }
        }
        else
        {
            si_count++;
        }
    }
}

/****************************************************************************
 *	FUNCTION NAME   : update_collision_free_sib_scheduling_list_in_sib1_for_cell_reconfig 
 *  INPUT		    : sib_bitmask,p_si_segment_data
 *  OUTPUT		    : p_scheduling_info_list
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function updates the scheduling info list in
 *                    SIB1 with the collision free SI's for only those 
 *                    SIB's that are requested in cell config request.
 *****************************************************************************/
void update_collision_free_sib_scheduling_list_in_sib1_for_cell_reconfig 
(
    /*SPR 17777 +-*/
 rrm_si_segment_data_t   *p_si_segment_data,
 scheduling_info_list_t  *p_scheduling_info_list
 )
{  
    U8  si_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for(si_count = RRM_ZERO ; si_count < p_scheduling_info_list->count ; si_count ++)
    {
        if(p_si_segment_data[si_count].si_segment_periodicity != 0xFF)
        {
            p_scheduling_info_list->scheduling_info[si_count].si_periodicity = p_si_segment_data[si_count].si_segment_periodicity;
        }
        else
        {
            break;
        }
    }
    p_scheduling_info_list->count = si_count;

    RRM_UT_TRACE_EXIT();
}

/* BUG_371 FIX START */
rrm_return_et
rrm_scheduling_info_configured_for_sib
(
 scheduling_info_list_t *p_scheduling_info_list,
 rrm_sib_type_et         sib_type
 )
{
    RRM_UT_TRACE_ENTER();
    U8 si_count = RRM_ZERO ;
    U8 sib_count = RRM_ZERO ;
    rrm_bool_et scheduling_info_present = RRM_FALSE;
    rrm_return_et   ret_val= RRM_FAILURE;

    for(si_count = RRM_ZERO ; ((si_count < p_scheduling_info_list->count) && (RRM_FALSE == scheduling_info_present)) ; si_count++)
    {
        for(sib_count = RRM_ZERO ; sib_count < p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.count; sib_count++)
        {
            if( sib_type == p_scheduling_info_list->scheduling_info[si_count].sib_mapping_info.sib_type[sib_count])
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Scheduling Info for SIB [%d] is present at SI POS [%d] and SIB MAPPING POS [%d]",
                        sib_type,si_count,sib_count);
                scheduling_info_present = RRM_TRUE; 
                ret_val= RRM_SUCCESS;
                break;
            }

        }
    }

    if( RRM_FALSE == scheduling_info_present )
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Scheduling Info for SIB [%d] is Not present in Scheduling info list", sib_type);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*Klockwork_fix_start*/
/****************************************************************************
 *  FUNCTION NAME   : update_collision_free_sib_scheduling_list_in_sib5_for_cell_config
 *  INPUT           : p_cell_context, sib_bitmask,p_si_segment_data
 *  OUTPUT          : p_scheduling_info_list
 *  RETURNS         : None
 *  DESCRIPTION     : This function updates the scheduling info list in
 *                    SIB1 with the collision free SI's for only those
 *                    SIB's that are requested in cell config request.
 *****************************************************************************/
    rrm_void_t
update_collision_free_sib_scheduling_list_in_sib5_for_cell_config(rrm_cell_context_t      *p_cell_context ,
        scheduling_info_list_t  *p_scheduling_info_list ,
        U16                     *sib_temp_bitmask ,
        U16                     *p_sib_bitmask )
{
    rrm_return_et   ret_val= RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_5_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_5); 
    }
    else
    {
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_5);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_5_PRESENT;
            *sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_5_INFO_PRESENCE_FLAG;
        }
    }

    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_6_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_6); 
    }
    else
    {
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_6);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_6_PRESENT;
            *sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_6_INFO_PRESENCE_FLAG;
        }
    }

    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_7_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_7); 
    }
    else
    {
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_7);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_7_PRESENT;
            *sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_7_INFO_PRESENCE_FLAG;
        }
    }

    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_8_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_8); 
    }
    else
    {
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_8);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_8_PRESENT;
            *sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_8_INFO_PRESENCE_FLAG;
        }
    }

    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_9_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_9); 
    }
    else
    {
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_9);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_9_PRESENT;
            *sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_9_INFO_PRESENCE_FLAG;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/


/****************************************************************************
 *	FUNCTION NAME   : update_collision_free_sib_scheduling_list_in_sib1_for_cell_config
 *  INPUT		    : p_cell_context, sib_bitmask,p_si_segment_data
 *  OUTPUT		    : p_scheduling_info_list
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function updates the scheduling info list in
 *                    SIB1 with the collision free SI's for only those 
 *                    SIB's that are requested in cell config request.
 *****************************************************************************/
void update_collision_free_sib_scheduling_list_in_sib1_for_cell_config
(
 rrm_cell_context_t      *p_cell_context,
 U16                     *p_sib_bitmask,
 rrm_si_segment_data_t   *p_si_segment_data,
 scheduling_info_list_t  *p_scheduling_info_list
 )
{  
    U8  si_count = RRM_ZERO;
    U8  rrm_si_periodicty = 0xFF;
    U16                     sib_temp_bitmask = 0x00;
    rrm_return_et   ret_val= RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    /* CSR 00051178 CHANGES START */
    /* Assign all the bitmask of the SIBs present in Cell Config Request API
     * towards L3 in the global variable defined "sib_present_at_cell_config_time_bitmask"
     * This variable shall be used later on during Reconfiguration procedure
     */
    /* Used later on in function rrm_update_bitmask_for_cell_reconfig*/
    p_cell_context->sib_present_at_cell_config_time_bitmask = 0x00;

    /* Assign By default MIB, SIB 1 and SIB 2 to this bitmask */
    p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_MIB_INFO_PRESENT;
    p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_1_PRESENT;
    p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_2_PRESENT;

    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_3_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_3); 
    }
    else
    {
        //It means data from OAM is coming from SIB and is eligible to be broadcast at L3.
        //Provided its scheduling information is also configured from OAM.
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_3);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_3_PRESENT;
            sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
        }
    }


    if(!(*p_sib_bitmask & CELL_SETUP_REQ_API_SIB_4_INFO_PRESENCE_FLAG))
    {
        clear_sib_mapping_info_in_sib1(p_scheduling_info_list , RRM_RRC_SIB_TYPE_4); 
    }
    else
    {
        ret_val = rrm_scheduling_info_configured_for_sib(p_scheduling_info_list,RRM_RRC_SIB_TYPE_4);
        if (ret_val == RRM_SUCCESS)
        {
            p_cell_context->sib_present_at_cell_config_time_bitmask |= RRM_SIB_4_PRESENT;
            sib_temp_bitmask |= CELL_SETUP_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
        }
    }
    /*Klockwork_fix_start*/
    update_collision_free_sib_scheduling_list_in_sib5_for_cell_config(p_cell_context ,
            p_scheduling_info_list ,&sib_temp_bitmask ,p_sib_bitmask);
    /*Klockwork_fix_end*/

    #ifdef LTE_EMBMS_SUPPORTED
    if (!(MBMS_SIBS_NOT_ON_BROADCAST &
        p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast))
    {
        update_collision_free_scheduling_list_for_mbms(p_cell_context,p_scheduling_info_list,
        &sib_temp_bitmask, p_sib_bitmask);
    }
    #endif

    for(si_count = RRM_ZERO ; si_count < p_scheduling_info_list->count ; si_count ++)
    {
        get_rrm_si_peridicity_from_peridicity_in_rf(p_si_segment_data[si_count].si_segment_periodicity ,&rrm_si_periodicty);
        if(rrm_si_periodicty != RRM_INVALID_SI_PERIODICITY_U8)
        {
            p_scheduling_info_list->scheduling_info[si_count].si_periodicity = rrm_si_periodicty;
        }
        else
        {
            break;
        }
    }
    p_scheduling_info_list->count = si_count;
    /* FIX_SB_371_START */
    if (*p_sib_bitmask & CELL_SETUP_REQ_API_EXPLICIT_START_REQUIRED_PRESENCE_FLAG)
    {
        sib_temp_bitmask |= CELL_SETUP_REQ_API_EXPLICIT_START_REQUIRED_PRESENCE_FLAG;
    }
    if (*p_sib_bitmask & CELL_SETUP_REQ_API_CDMA2000_PARAM_PRESENCE_FLAG)
    {
        sib_temp_bitmask |= CELL_SETUP_REQ_API_CDMA2000_PARAM_PRESENCE_FLAG;
    }
    /* FIX_SB_371_END */
    *p_sib_bitmask = sib_temp_bitmask;
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Local Bitmask at RRM = 0x[%x], Bitmask sent to L3 = 0x[%x]",
            p_cell_context->sib_present_at_cell_config_time_bitmask,
            sib_temp_bitmask);

    /* CSR 00051178 CHANGES END */
    p_cell_context->sib_present_at_cell_reconfig_time_bitmask = p_cell_context->sib_present_at_cell_config_time_bitmask; 
    RRM_UT_TRACE_EXIT();
}
/* BUG_371 FIX END */
/****************************************************************************
 *	FUNCTION NAME   : update_si_segment_data_vd_scheduling_info_configured 
 *  INPUT		    : p_scheduling_info_list ,si_window_length
 *  OUTPUT		    : p_si_segment_data
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function updates the si_segment_data to be used 
 *                    by collision detection algo.
 *****************************************************************************/
void update_si_segment_data_vd_scheduling_info_configured
(
 scheduling_info_list_t  *p_scheduling_info_list,
 U8                       si_window_length,
 rrm_si_segment_data_t   *p_si_segment_data
 )
{  
    U16  si_periodicity_rf = RRM_ZERO;
    U8   si_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    rrm_validate_si_periodicities(p_scheduling_info_list ,si_window_length);

    for(si_count = RRM_ZERO ; si_count < p_scheduling_info_list->count ; si_count++)
    {
        p_si_segment_data[si_count].si_segment_id = si_count + RRM_ONE ;
        get_peridicity_in_rf_terms(p_scheduling_info_list->scheduling_info[si_count].si_periodicity ,
                &si_periodicity_rf);
        p_si_segment_data[si_count].si_segment_periodicity =  si_periodicity_rf;
        p_si_segment_data[si_count].is_periodicity_changed = RRM_FALSE ;
    }

    for(si_count = p_scheduling_info_list->count; si_count < RRM_MAX_SI_SEGMENTS  ; si_count++)
    {
        p_si_segment_data[si_count].si_segment_id = si_count + RRM_ONE ;
        p_si_segment_data[si_count].si_segment_periodicity =  RRM_SI_PERIODICITY_RF_32;
        p_si_segment_data[si_count].is_periodicity_changed = RRM_FALSE ;
    }

    RRM_UT_TRACE_EXIT();
}
/*DYNAMIC SIB SCHEDULING END*/
/* SPR 5676 Fix Start*/

/****************************************************************************
 *  FUNCTION NAME   : update_cell_setup_scheduling_info_sib1_for_son
 *  INPUT           : *p_cell_ctx,sib_presense_bitmask
 *  OUTPUT          : *sib_type_1_Info
 *  DESCRIPTION     : This function checks for the SIBs present in the
 *                    cell config request and calls function to update
 *                    scheduling list for the appropriate SIB
 *  RETURNS         : RRM_TRUE/RRM_FALSE
 *****************************************************************************/
rrm_bool_et
update_cell_setup_scheduling_info_sib1_for_son(
        rrm_cell_context_t  *p_cell_ctx,
        U16                 sib_presense_bitmask,
        sib_type_1_Info_t   *sib_type_1_Info
        )
{
    U8          index = RRM_ZERO;
    U8          sib_presence_in_cell_ctx = RRM_ZERO;
    rrm_bool_et scheduling_info_changed = RRM_FALSE;
    /*DYNAMIC SIB SCHEDULING START*/
    U8          si_periodicity = RRM_ZERO;
    /*DYNAMIC SIB SCHEDULING END*/
    /* CSR 00051178 CHANGES START */
    U8          sib_count      = RRM_ZERO;
    /* CSR 00051178 CHANGES END */

    RRM_UT_TRACE_ENTER();

    /* Find the SIBs for which Scheduling Info already broadcasted */
    for(index = RRM_ZERO; index < p_cell_ctx->operator_info.sib_1_info.scheduling_info_list.count; index++)
    {
        /* CSR 00051178 CHANGES START */
        for(sib_count = RRM_ZERO ; sib_count <
                p_cell_ctx->operator_info.sib_1_info.scheduling_info_list.scheduling_info[index].
                sib_mapping_info.count ; sib_count ++)
        {
            /* CSR 00051178 CHANGES END */
            switch(p_cell_ctx->operator_info.sib_1_info.scheduling_info_list.scheduling_info[index].
                    sib_mapping_info.sib_type[sib_count])
            {
                case RRM_RRC_SIB_TYPE_3:
                    sib_presence_in_cell_ctx |= RRM_SIB_TYPE_3_PRESENT;
                    break;

                case RRM_RRC_SIB_TYPE_4:
                    sib_presence_in_cell_ctx |= RRM_SIB_TYPE_4_PRESENT;
                    break;

                case RRM_RRC_SIB_TYPE_5:
                    sib_presence_in_cell_ctx |= RRM_SIB_TYPE_5_PRESENT;
                    break;

                case RRM_RRC_SIB_TYPE_6:
                    sib_presence_in_cell_ctx |= RRM_SIB_TYPE_6_PRESENT;
                    break;

                case RRM_RRC_SIB_TYPE_7:
                    sib_presence_in_cell_ctx |= RRM_SIB_TYPE_7_PRESENT;
                    break;
                case RRM_RRC_SIB_TYPE_8:
                    sib_presence_in_cell_ctx |= RRM_SIB_TYPE_8_PRESENT;
                    break;
#ifdef LTE_EMBMS_SUPPORTED
                case RRM_RRC_SIB_TYPE_13:
                    sib_presence_in_cell_ctx |= RRM_RRC_SIB_TYPE_13;
                    break;
#endif

            }
        }
    }
    if((RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig) ||
            (RRM_FALSE == p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove))
    {
        /* If a SIB is to be broadcast in the current req and scheduling Info has not
         * been broadcast earlier, add the scheduling info for the new sib */
        if((sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG) &&
                !(sib_presence_in_cell_ctx & RRM_SIB_TYPE_3_PRESENT))
        {
            /*DYNAMIC SIB SCHEDULING START*/
            si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[p_cell_ctx->operator_info.
                sib_1_info.scheduling_info_list.count].si_segment_periodicity;
            set_scheduling_info_for_sib(sib_type_1_Info,RRM_RRC_SIB_TYPE_3,si_periodicity);
            /*DYNAMIC SIB SCHEDULING END*/
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 3 added in SIB 1");
        }

        if((sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_4_INFO_PRESENCE_FLAG) &&
                !(sib_presence_in_cell_ctx & RRM_SIB_TYPE_4_PRESENT))
        {
            /*DYNAMIC SIB SCHEDULING START*/
            si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[p_cell_ctx->operator_info.
                sib_1_info.scheduling_info_list.count].si_segment_periodicity;
            set_scheduling_info_for_sib(sib_type_1_Info,RRM_RRC_SIB_TYPE_4,si_periodicity);
            /*DYNAMIC SIB SCHEDULING END*/
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 4 added in SIB 1");
        }

        /* BUG-4464 FIX START*/
        if ( p_cell_ctx->p_ncl_built_from_updated_nrt_info != RRM_PNULL)
        {
            /* Bug 3238 start */
            if((sib_presence_in_cell_ctx & RRM_SIB_TYPE_4_PRESENT) &&
                (RRM_ZERO == p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Clear SIB4 mapping from SIB1 ");
                clear_sib_mapping_info_in_sib1(&(sib_type_1_Info->scheduling_info_list), RRM_RRC_SIB_TYPE_4);
                scheduling_info_changed = RRM_TRUE;
            }
            /* Bug 3238 end */
        }
        /* BUG-4464 FIX END*/

        if((sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_5_INFO_PRESENCE_FLAG) &&
                !(sib_presence_in_cell_ctx & RRM_SIB_TYPE_5_PRESENT))
        {
            /*DYNAMIC SIB SCHEDULING START*/
            si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[p_cell_ctx->operator_info.
                sib_1_info.scheduling_info_list.count].si_segment_periodicity;
            set_scheduling_info_for_sib(sib_type_1_Info,RRM_RRC_SIB_TYPE_5,si_periodicity);
            /*DYNAMIC SIB SCHEDULING END*/
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 5 added in SIB 1");
        }

        if((sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_6_INFO_PRESENCE_FLAG) &&
                !(sib_presence_in_cell_ctx & RRM_SIB_TYPE_6_PRESENT))
        {
            /*DYNAMIC SIB SCHEDULING START*/
            si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[p_cell_ctx->operator_info.
                sib_1_info.scheduling_info_list.count].si_segment_periodicity;
            set_scheduling_info_for_sib(sib_type_1_Info,RRM_RRC_SIB_TYPE_6,si_periodicity);
            /*DYNAMIC SIB SCHEDULING END*/
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 6 added in SIB 1");
        }

        if((sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_7_INFO_PRESENCE_FLAG) &&
                !(sib_presence_in_cell_ctx & RRM_SIB_TYPE_7_PRESENT))
        {
            /*DYNAMIC SIB SCHEDULING START*/
            si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[p_cell_ctx->operator_info.
                sib_1_info.scheduling_info_list.count].si_segment_periodicity;
            set_scheduling_info_for_sib(sib_type_1_Info,RRM_RRC_SIB_TYPE_7, si_periodicity);
            /*DYNAMIC SIB SCHEDULING END*/
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 7 added in SIB 1");
        }
        /* Start 7514 NRT Fix - SIB 8 */
        if((sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_8_INFO_PRESENCE_FLAG) &&
                !(sib_presence_in_cell_ctx & RRM_SIB_TYPE_8_PRESENT))
        {
            /*DYNAMIC SIB SCHEDULING START*/
            si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[p_cell_ctx->operator_info.
                sib_1_info.scheduling_info_list.count].si_segment_periodicity;
            set_scheduling_info_for_sib(sib_type_1_Info,RRM_RRC_SIB_TYPE_8, si_periodicity);
            /*DYNAMIC SIB SCHEDULING END*/
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 8 added in SIB 1");
        }
        /* End 7514 NRT Fix - SIB 8 */
/*csr_00101724 start */

        if(!(sib_presense_bitmask & CELL_RECONFIG_REQ_API_SIB_4_INFO_PRESENCE_FLAG) &&
                (sib_presence_in_cell_ctx & RRM_SIB_TYPE_4_PRESENT))
        {
            clear_sib_mapping_info_in_sib1(&(sib_type_1_Info->scheduling_info_list), RRM_RRC_SIB_TYPE_4);
            scheduling_info_changed = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scheduling info for SIB 4 removed in SIB 1");
        }
/*csr_00101724 end */
    }
    else if(RRM_PNULL != p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        /* If a SIB is to be deleted in the current req and scheduling Info has
         * been broadcast earlier, delete the scheduling info for the sib */
        if((sib_presence_in_cell_ctx & RRM_SIB_TYPE_5_PRESENT) &&
                (p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_INTER_FREQ_PARAMS_PRESENT) &&
                (RRM_ZERO == p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list))
        {
            clear_sib_mapping_info_in_sib1(&(sib_type_1_Info->scheduling_info_list), RRM_RRC_SIB_TYPE_5);
            scheduling_info_changed = RRM_TRUE;
        }
    }

    RRM_UT_TRACE_EXIT();

    return scheduling_info_changed;
}
/****************************************************************************
 *  FUNCTION NAME   : rrm_update_si_segment_data_in_cell_context 
 *  INPUT           : p_si_segment_data
 *  OUTPUT          : p_si_segment_data_cell_context
 *  DESCRIPTION     : this function updates segment data in cell context.
 *  RETURNS         : none
 *****************************************************************************/

rrm_void_t
rrm_update_si_segment_data_in_cell_context
(
 rrm_si_segment_data_t *p_si_segment_data_cell_context,
 rrm_si_segment_data_t *p_si_segment_data
 )
{
    U8 si_count = RRM_ZERO;
    U8 rrm_si_periodicty = RRM_ZERO;
    while((si_count < RRM_MAX_SI_SEGMENTS ) && (p_si_segment_data[si_count].si_segment_periodicity != 0xFFFF))
    {
        get_rrm_si_peridicity_from_peridicity_in_rf(p_si_segment_data[si_count].si_segment_periodicity ,
                &rrm_si_periodicty);
        p_si_segment_data_cell_context[si_count].si_segment_id = 
            p_si_segment_data[si_count].si_segment_id;
        p_si_segment_data_cell_context[si_count].si_segment_periodicity = rrm_si_periodicty;

        p_si_segment_data_cell_context[si_count].is_periodicity_changed = 
            p_si_segment_data[si_count].is_periodicity_changed;
        si_count++;
    }
}
/* SPR 5676 Fix End*/

/* Coverity_ID : 54441, 54443, 54444 start */
/****************************************************************************
 *   FUNCTION NAME       : rrm_map_si_window_length 
 *   INPUT               : U8 si_window_length
 *   OUTPUT              : None
 *   DESCRIPTION         : This function Maps si wnidow length
 *   RETURNS             : rrm_si_window_length_et
 *****************************************************************************/
rrm_si_window_length_et
rrm_map_si_window_length (
        U8 rrm_si_window_length
        )
{
    rrm_si_window_length_et si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_1;

    RRM_UT_TRACE_ENTER();
    switch (rrm_si_window_length)
    {
        case RRM_ZERO:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_1;
            break;
        case RRM_ONE:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_2;
            break;
        case RRM_TWO:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_5;
            break;
        case RRM_THREE:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_10;
            break;
        case RRM_FOUR:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_15;
            break;
        case RRM_FIVE:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_20;
            break;
        case RRM_SIX:
            si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_40;
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,\
                    "Invalid si window length[%d] recvd Assigning RRM_RRC_SI_WINDOW_LEN_MS_1 \
                    by default", rrm_si_window_length);
            break;
    }
    RRM_UT_TRACE_EXIT();

    return si_window_length;
}
/* Coverity_ID : 54441, 54443, 54444 end */
/****************************************************************************
 *	FUNCTION NAME :	build_send_rrc_setup_req 
 *  INPUT         : *cell_context,*rrc_rrm_cell_setup_req
 *  OUTPUT        : None 
 *	DESCRIPTION	  :
 *    		This function Maps the cell setup params coming from MIF to RRC
 *	RETURNS		  :
 *	                RRM_SUCCESS on Success.
 *	                RRM_FAILURE	on Failure.
 *****************************************************************************/
rrm_return_et
build_send_rrc_setup_req(rrm_cell_context_t        *cell_context, 
        rrc_rrm_cell_setup_req_t  *rrc_rrm_cell_setup_req)
{
    U8 		      eaid_count = RRM_ZERO;
    rrm_return_et       ret_val = RRM_SUCCESS;
    /*DYNAMIC SIB SCHEDULING START*/
    rrm_si_segment_data_t si_segment_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    U8 si_window_length_configured = RRM_ZERO;
    /*DYNAMIC SIB SCHEDULING END*/
#ifdef LTE_EMBMS_SUPPORTED
    U8 index                               = RRM_ZERO;
    U8 count                               = RRM_ZERO;
    scheduling_info_list_t *p_si_info_list = RRM_PNULL;
    rrm_bool_et single_sib_13_in_si  = RRM_FALSE;
#endif
    RRM_UT_TRACE_ENTER();

    /** Checks for NULL pointer*/
    if ((PNULL == cell_context) || (PNULL == rrc_rrm_cell_setup_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "map_rrc_cell_setup_req:Null pointers from CELL and send");
        return RRM_FAILURE;
    }
    else
    {
        do
        {
        /*Fill presence_bitmask*/
        /* SPR 13152 fix start */
        RRM_MEMSET(rrc_rrm_cell_setup_req, RRM_ZERO, sizeof(rrc_rrm_cell_setup_req_t));
        /* SPR 13152 fix end */
        rrc_rrm_cell_setup_req->presence_bitmask = RRM_ZERO;
        rrc_rrm_cell_setup_req->cell_index = cell_context->cell_index;

            /* SPR 19309 + */
        rrc_rrm_cell_setup_req->cell_config_param.mac_config.cfi_value =
            cell_context->ran_info.mac_layer_params.cfi_value;
            /* SPR 19309 - */
            /* SPR 19310 + */
        rrc_rrm_cell_setup_req->cell_config_param.mac_config.num_of_eul = cell_context->ran_info.mac_layer_params.num_of_eul;
        rrc_rrm_cell_setup_req->cell_config_param.mac_config.size_of_eul = cell_context->ran_info.mac_layer_params.size_of_eul;
        /* SPR 19310 - */
        /* SPR 20908 Start */
        

        /* SPR 21206 Start */
        rrc_rrm_cell_setup_req->cell_config_param.associated_layer2_inst=cell_context->operator_info.l2_instance;
        rrc_rrm_cell_setup_req->cell_config_param.bitmask |= RRC_RRM_ASSOCIATED_LAYER2_INST_FIELD_PRESENT;

        rrm_fill_l2_comm_info_params(&(rrc_rrm_cell_setup_req->cell_config_param.l2_comm_info_params),
                &(cell_context->l2_comm_info_params));
        /* SPR 21206 End */
        /* SPR 20908 End */
        /* SPR 15328 start */
        U8 utra_fdd_count = cell_context->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            num_irat_eutran_to_utran_fdd_carriers;

        U8 utra_tdd_count = cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            num_irat_eutran_to_utran_tdd_carriers;

        U8 geran_carr_count = cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.
            num_irat_eutran_to_geran_carriers;

        /* SPR 15328 end */

        ret_val = map_mib_info(cell_context, &(rrc_rrm_cell_setup_req->mib_info));
        /* Coverity 75148 Fix Start */
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failure returned from map_mib_info");
                break;
        }
        /* Coverity 75148 Fix End */

        if (cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
        {
            /* Coverity ID 76347 Fix Start */
                ret_val = map_sib_type_1(cell_context, &(rrc_rrm_cell_setup_req->
                        sib_type_1_Info));
            /* Coverity ID 76347 Fix End */
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Failure returned from map_sib_type_1");
                    break;
                }
        }
        if (cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
        {
            /* Coverity ID 78690 Fix Start */
                ret_val = map_sib_type_2(cell_context, &(rrc_rrm_cell_setup_req->sib_type_2_Info));
            /* Coverity ID 78690 Fix End */
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Failure returned from map_sib_type_2");
                    break;
                }
        }
        if (cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_3_INFO_PRESENT)
        {
            map_sib_type_3(cell_context, rrc_rrm_cell_setup_req);
        }
        /* BUG_11575_CHANGES_START */
        /* Code Deleted */
        /* BUG_11575_CHANGES_END */
        map_sib_type_4(cell_context, rrc_rrm_cell_setup_req);

        ret_val = map_sib_type_5(
                cell_context, 
                &rrc_rrm_cell_setup_req->sib_type_5_Info);
        /* Coverity 75148 Fix Start */
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failure returned from map_sib_type_5");
                    break;
        }
        /* Coverity 75148 Fix End */

        if(rrc_rrm_cell_setup_req->sib_type_5_Info.inter_freq_carrier_freq_list_list.count)
        {
            rrc_rrm_cell_setup_req->presence_bitmask |=
                CELL_SETUP_REQ_API_SIB_5_INFO_PRESENCE_FLAG;
        }

        if( RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT &
                cell_context->ran_info.mobility_params.bitmask)
        {
            /* 21481:SIB 6 is Added*/
            /* SPR 15328 start */
            if((RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT &
                    cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask) &&
                    ((utra_fdd_count > RRM_ZERO) || (utra_tdd_count > RRM_ZERO)))
                /* SPR 15328 end */
            {
                rrc_rrm_cell_setup_req->presence_bitmask |= CELL_SETUP_REQ_API_SIB_6_INFO_PRESENCE_FLAG;
                ret_val = map_sib_type_6(cell_context,
                        &rrc_rrm_cell_setup_req->sib_type_6_Info);
                /* Coverity 75148 Fix Start */
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Failure returned from map_sib_type_6");
                            break;
                }
                /* Coverity 75148 Fix End */
            }

            /* SIB 7 is Added*/
            /* SPR 15328 start */
            if((RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT &\
                    cell_context->ran_info.mobility_params.\
                    idle_mode_mobility_params.bitmask) &&
                    (geran_carr_count > RRM_ZERO))
                /* SPR 15328 end */
            {
                rrc_rrm_cell_setup_req->presence_bitmask |=\
                                                           CELL_SETUP_REQ_API_SIB_7_INFO_PRESENCE_FLAG;
                ret_val = map_sib_type_7(cell_context,
                        &rrc_rrm_cell_setup_req->sib_type_7_Info);
                if (RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                            "map_sib_type_7: Failure returned during map_sib_type_7");
                    break;
                }
            }

    	/* BUG_15960 Fix Start */
    	/* CDMA2000 changes start */
    	if(RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT & 
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask) 
   	    {
        	ret_val = map_sib_type_8(cell_context,
                                &rrc_rrm_cell_setup_req->sib_type_8_Info);
        	if(RRM_FAILURE == ret_val)
        	{
            		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    		"Failure returned from map_sib_type_8");
                    break;
        	}
        	/* Setting Bitmask for Sib-8 */
        	rrc_rrm_cell_setup_req->presence_bitmask |= 
                	         CELL_SETUP_REQ_API_SIB_8_INFO_PRESENCE_FLAG;
    	}
    	/* CDMA2000 changes ends */
    	/* BUG_15960 Fix Stop */
    }
    /* BUG_15960 Fix Deletion Start */
    /* BUG_15960 Fix Deletion Stop */

        /* SPR 14128 Fix START */
        if((cell_context->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT) && (cell_context->access_mgmt_params.access_mode != RRM_OAM_ACCESS_MODE_OPEN))
        {
            ret_val =  map_sib_type_9(
                    cell_context, 
                    &rrc_rrm_cell_setup_req->sib_type_9_Info);
            /* Coverity 75148 Fix Start */
            if(RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failure returned from map_sib_type_9");
                    break;
            }
            /* Coverity 75148 Fix End */
            if(RRM_ZERO != (rrc_rrm_cell_setup_req->sib_type_9_Info.presence_bitmask & SIB_9_HNB_ID_PRESENCE_FLAG))
            {
                rrc_rrm_cell_setup_req->presence_bitmask |= CELL_SETUP_REQ_API_SIB_9_INFO_PRESENCE_FLAG;
            }
            /* SPR 14128 Fix END */
        }
#ifdef LTE_EMBMS_SUPPORTED
        if (MBMS_SIB_13_ON_BROADCAST & 
                cell_context->rrm_cell_embms_data.current_sibs_on_boradcast)
        {
            map_sib_type_13_Info_for_mbms(
                    cell_context,
                    rrc_rrm_cell_setup_req);
            rrc_rrm_cell_setup_req->presence_bitmask |= 
                CELL_SETUP_REQ_API_SIB_13_INFO_PRESENCE_FLAG;

            /*SPR 18093:start*/
            rrc_rrm_cell_setup_req->presence_bitmask |=
                CELL_SETUP_REQ_API_EMBMS_AREA_INFO_LIST_PRESENCE_FLAG;
            /*SPR 18093:end*/
        }

        if (MBMS_SIBS_NOT_ON_BROADCAST & 
                cell_context->rrm_cell_embms_data.current_sibs_on_boradcast)
        {

            single_sib_13_in_si = rrm_check_only_sib13_present_in_si(
                    &(cell_context->operator_info.sib_1_info.scheduling_info_list)); 
            if (single_sib_13_in_si == RRM_TRUE)
            {
                /*
                 * Removing SIB TYPE 13 from SI information 
                 * which is present in SIB_TYPE 1 
                 */
                RRM_MEMSET(&rrc_rrm_cell_setup_req->sib_type_1_Info.scheduling_info_list,
                        RRM_ZERO, sizeof(scheduling_info_list_t)); 
                p_si_info_list = &(rrc_rrm_cell_setup_req->
                        sib_type_1_Info.scheduling_info_list);

                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Preparing SI scheduling List removing SIB13, and using this list "
                        "for collision detection");
                rrm_prepare_si_scheduling_list(cell_context,RRM_FALSE,p_si_info_list);
            }
/*SPR 18672:start*/
            if (RRM_TRUE == rrm_check_all_reserved_area_in_mcch(&(cell_context->rrm_cell_embms_data), RRM_ZERO,
                  RRM_TRUE, &(cell_context->operator_info.sib_13_info)))
            {
                /*Send Reserved cell and updated mbsfn info to RRC */
                rrm_map_only_reserved_info_after_delte(cell_context, rrc_rrm_cell_setup_req);
                rrc_rrm_cell_setup_req->presence_bitmask |=
                    CELL_SETUP_REQ_API_MCCH_CELL_RESERVATION_INFO_PRESENCE_FLAG;

                rrc_rrm_cell_setup_req->presence_bitmask |=
                    CELL_SETUP_REQ_API_EMBMS_AREA_INFO_LIST_PRESENCE_FLAG;

            }
/*SPR 18672:end*/

        }
#endif
        /*DYNAMIC SIB SCHEDULING START*/
        si_window_length_configured = rrc_rrm_cell_setup_req->sib_type_1_Info.si_window_length;

        update_si_segment_data_vd_scheduling_info_configured(&(rrc_rrm_cell_setup_req->sib_type_1_Info.scheduling_info_list) ,
                si_window_length_configured, si_segment_data);
        /*cov fix start 48132*/
        /*cov fix start 64260*/
        rrm_get_collision_free_si_scheduling_list(cell_context, si_segment_data, 
                ((rrm_si_window_length_et)rrc_rrm_cell_setup_req->sib_type_1_Info.si_window_length));
        /*cov fix end 64260*/
        /*cov fix end 48132*/

        rrm_update_si_segment_data_in_cell_context(cell_context->si_segment_data_sib_scheduling,
                si_segment_data);

        if(si_window_length_configured != rrc_rrm_cell_setup_req->sib_type_1_Info.si_window_length)
        {
            /* Coverity_ID : 54443 */
            cell_context->operator_info.sib_1_info.si_window_length = rrm_map_si_window_length(
                    rrc_rrm_cell_setup_req->sib_type_1_Info.si_window_length);
        }

#ifdef LTE_EMBMS_SUPPORTED
        /*
         * Removing SIB TYPE 13 from SI information 
         * which is present in SIB_TYPE 1 
         */
        if (MBMS_SIBS_NOT_ON_BROADCAST & 
                cell_context->rrm_cell_embms_data.current_sibs_on_boradcast)
        {
            if (single_sib_13_in_si == RRM_FALSE)
            {
                RRM_MEMSET(&rrc_rrm_cell_setup_req->sib_type_1_Info.scheduling_info_list,
                        RRM_ZERO, sizeof(scheduling_info_list_t)); 
                p_si_info_list = &(rrc_rrm_cell_setup_req->
                        sib_type_1_Info.scheduling_info_list);

                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Preparing SI scheduling List removing SIB13");
                rrm_prepare_si_scheduling_list(cell_context,RRM_FALSE,p_si_info_list);
            }
        }
#endif

        /* BUG_371 FIX START */
        update_collision_free_sib_scheduling_list_in_sib1_for_cell_config(cell_context,
                &(rrc_rrm_cell_setup_req->presence_bitmask),
                si_segment_data,
                &(rrc_rrm_cell_setup_req->sib_type_1_Info.scheduling_info_list));
        /* BUG_371 FIX END */
        /*DYNAMIC SIB SCHEDULING END*/
        /*update the scheduling info in the cells context*/
        rrm_memcpy_rrm_scheduling_info_list(
                &(cell_context->operator_info.sib_1_info.scheduling_info_list) ,
                (rrm_scheduling_info_list_t *)&(rrc_rrm_cell_setup_req->sib_type_1_Info.scheduling_info_list));

#ifdef LTE_EMBMS_SUPPORTED
        if (MBMS_SIBS_NOT_ON_BROADCAST &
                cell_context->rrm_cell_embms_data.current_sibs_on_boradcast)
        {
            for (index = RRM_ZERO; index < rrc_rrm_cell_setup_req->cell_config_param.
                    mac_config.si_transmission_info.count; index++)
            {
                RRM_MEMCPY(&cell_context->rrm_cell_embms_data.stored_si_start_offset[index],
                        &rrc_rrm_cell_setup_req->cell_config_param.mac_config.si_transmission_info.
                        si_transmission[index].si_start_offset_info.si_start_offset[count],
                        RRM_ONE);

            }
        }

        if (MBMS_SIB_13_ON_BROADCAST &
                cell_context->rrm_cell_embms_data.current_sibs_on_boradcast)
        {
            //Filling correct si_indexes
            for (index = RRM_ZERO; index < rrc_rrm_cell_setup_req->cell_config_param.
                    mac_config.si_transmission_info.count; index++)
            {
                RRM_MEMCPY(&rrc_rrm_cell_setup_req->cell_config_param.mac_config.si_transmission_info.
                        si_transmission[index].si_start_offset_info.si_start_offset[count],
                        &cell_context->rrm_cell_embms_data.si_start_offset[index],
                        RRM_ONE);
            }

        }
#endif
        if(RRMCM_RMIF_CDMA2000_CELL_PARAMS_PRESENCE_FLAG & 
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_cdma_params.presence_bitmask)
        {
            map_cdma2000_cell_param(&(cell_context->ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_cdma_params.cdma2000_cell_param),
                    &(rrc_rrm_cell_setup_req->cdma2000_cell_param));

            /* Setting Bitmask for CDMA2000_CELL_PARAMS */
            rrc_rrm_cell_setup_req->presence_bitmask |= 
                CELL_SETUP_REQ_API_CDMA2000_PARAM_PRESENCE_FLAG;
        }
        if (cell_context->epc_info.epc_params.general_epc_params.bitmask & 
                RRMCM_RMIF_EA_ID_PRESENT)
        {
            for(eaid_count=RRM_FALSE; eaid_count < MAX_EAID; eaid_count++)
            {
                rrc_rrm_cell_setup_req->emergency_area_id[eaid_count] = 
                    cell_context->epc_info.epc_params.general_epc_params.eaid[eaid_count];
            }
        }
        if (RRM_FALSE == cell_context->immediate_cell_start)
        {    
            rrc_rrm_cell_setup_req->explicit_start_required = 
                cell_context->immediate_cell_start;
            rrc_rrm_cell_setup_req->presence_bitmask |= 
                CELL_SETUP_REQ_API_EXPLICIT_START_REQUIRED_PRESENCE_FLAG;
        }
        ret_val = map_cell_config_param(
                cell_context, 
                &rrc_rrm_cell_setup_req->cell_config_param
                );
        /* Coverity 75148 Fix Start */
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failure returned from map_cell_config_param");
                    break;
        }
        /* Coverity 75148 Fix End */

        }while(RRM_ZERO);
    }

    /*sending Setup request to RRC*/
    if( RRM_SUCCESS == ret_val)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                 "RRC RRM CELL SETUP REQ filled succesfully.Proceed to compose");
    ret_val = rrm_il_send_rrc_rrm_cell_setup_req (rrc_rrm_cell_setup_req,
            RRM_CM_MODULE_ID,
            RRC_MODULE_ID,
            cell_context->ongoing_trans_id,cell_context->cell_index);
    }
    /* Function Exit */
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/****************************************************************************
 *   FUNCTION NAME :  map_mib_info
 *   INPUT         : *cell_context
 *   OUTPUT        : *p_mib_info
 *   DESCRIPTION   :
 *    		This function Maps the mib info for cell setup request coming from MIF to RRC
 *   RETURNS       :
 *                  RRM_SUCCESS on Success.
 *                  RRM_FAILURE on Failure.
 *****************************************************************************/
rrm_return_et
map_mib_info
(
 rrm_cell_context_t *cell_context, 
 mib_info_t         *p_mib_info
 )
{
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT)
    {
        switch(cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth)
        {
            case RRM_OAM_BW_N_6:
                p_mib_info->dl_band_width = RRM_RRC_BW_N_6;
                break;
            case RRM_OAM_BW_N_15:
                p_mib_info->dl_band_width = RRM_RRC_BW_N_15;
                break;
            case RRM_OAM_BW_N_25:
                p_mib_info->dl_band_width = RRM_RRC_BW_N_25;
                break;
            case RRM_OAM_BW_N_50:
                p_mib_info->dl_band_width = RRM_RRC_BW_N_50;
                break;
            case RRM_OAM_BW_N_75:
                p_mib_info->dl_band_width = RRM_RRC_BW_N_75;
                break;
            case RRM_OAM_BW_N_100:
                p_mib_info->dl_band_width = RRM_RRC_BW_N_100;
                break;
            default:
                p_mib_info->dl_band_width = cell_context->ran_info.rf_params.\
                                            rf_configurations.dl_bandwidth;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect dl_band_width = %u",
                        cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth);
                ret_val = RRM_FAILURE;
                break;
        }
    }
    if (RRM_SUCCESS == ret_val)
    {
        map_phich_config(cell_context, &p_mib_info->phich_config);
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME :   map_phich_config
 *   INPUT         : *cell_context
 *   OUTPUT        : *p_phich_config_info
 *   DESCRIPTION   :
 *    		This function Maps the phich config param of cell setup request from MIF to RRC
 *   RETURNS      :
 *                  RRM_SUCCESS on Success.
 *                  RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_phich_config
(
 rrm_cell_context_t *cell_context, 
 phich_config_t     *p_phich_config_info
 )
{
    RRM_UT_TRACE_ENTER();

    if( cell_context->operator_info.bitmask & RRMCM_RMIF_PHICH_CONFIG_PRESENT)
    {
        p_phich_config_info->phich_resource = cell_context\
                                              ->operator_info.phich_config.phich_resource;	/* M */

        p_phich_config_info->phich_duration = cell_context\
                                              ->operator_info.phich_config.phich_duration;	/* M */
    }
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   non_critical_extension
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_sib_type_1_v8_ies
 *   DESCRIPTION :
 *           This function Maps the non critical extension params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
non_critical_extension
(
 rrm_cell_context_t *cell_context,
 sib_type_1_v890_ies_t *p_sib_type_1_v8_ies
 )
{
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_sib_type_1_v8_ies->presence_bitmask = RRM_ZERO; 
    p_sib_type_1_v8_ies->presence_bitmask |= 
        SIB_TYPE_1_V890_IES_NON_CROTICAL_EXTENSION_PRESENT_FLAG;

    p_sib_type_1_v8_ies->non_critical_extension.presence_bitmask = RRM_ZERO;

    if(cell_context->operator_info.sib_1_info.ims_emergency_support_r9)
    {
        p_sib_type_1_v8_ies->non_critical_extension.presence_bitmask |=
            SIB_TYPE_1_V920_IES_IMS_EMERGENCY_SUPPORT_PRESENT_FLAG;
        p_sib_type_1_v8_ies->non_critical_extension.ims_emergency_support = RRM_RRC_TRUE;
    }

    if(cell_context->operator_info.sib_1_info.bitmask & RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT)
    {
        p_sib_type_1_v8_ies->non_critical_extension.presence_bitmask |= 
            SIB_TYPE_1_V920_IES_CELL_SELECTION_INFO_V920_PRESENT_FLAG;

        p_sib_type_1_v8_ies->non_critical_extension.cell_selection_info_v920.q_qual_min_r9 = 
            cell_context->operator_info.sib_1_info.cell_selection_info.q_qual_min_r9;

        if(cell_context->operator_info.sib_1_info.cell_selection_info.bitmask &
                RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT)
        {
            p_sib_type_1_v8_ies->non_critical_extension.cell_selection_info_v920.
                presence_bitmask = RRM_ZERO;

            p_sib_type_1_v8_ies->non_critical_extension.cell_selection_info_v920.presence_bitmask |= 
                CELL_SELECTION_INFO_Q_QUAL_MIN_OFFSET_R9_PRESENT_FLAG;

            p_sib_type_1_v8_ies->non_critical_extension.cell_selection_info_v920.q_qual_min_offset_r9 = 
                cell_context->operator_info.sib_1_info.cell_selection_info.q_qual_min_offset_r9_present;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_1
 *
 *   DESCRIPTION :
 *    		This function Maps the sib type 1 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_1
(
 rrm_cell_context_t *cell_context, 
 sib_type_1_Info_t  *p_sib_type_1_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /*Fill bitmask*/
    p_sib_type_1_info->presence_bitmask = RRM_ZERO;
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    map_cell_access_related_info(cell_context, 
            &p_sib_type_1_info->cell_access_related_info);

    map_cell_selection_info(cell_context,
            &p_sib_type_1_info->cell_selection_Info);
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    if(( cell_context->ran_info.bitmask & 
                RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            ( cell_context->ran_info.mobility_params.bitmask & 
              RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT ) &&
            ( cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask &
              RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS)
      )
    {
        if(cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_P_MAX_SIB1_PRESENT)
        {
            p_sib_type_1_info->presence_bitmask |= SIB_TYPE_1_P_MAX_PRESENCE_FLAG;

            p_sib_type_1_info->p_max = cell_context->\
                                       ran_info.mobility_params.idle_mode_mobility_params.\
                                       idle_mode_mobility_intra_freq_params.p_max_sib_1;
        }
    }
    if( cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT)
    {
        p_sib_type_1_info->freq_band_indicator = cell_context->\
                                                 ran_info.rf_params.rf_configurations.frequency_band_indicator;
    }
    /*Dynamic scheduling*/
    if (cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
    {
        p_sib_type_1_info->si_window_length = 
            cell_context->operator_info.sib_1_info.si_window_length;
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
        /*DYNAMIC SIB SCHEDULING START*/
        scheduling_info_list(cell_context, 
                &(p_sib_type_1_info->scheduling_info_list));
        /*DYNAMIC SIB SCHEDULING END*/
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    }
    /* BUG_12215_FIX_START */
    cell_context->system_info_tag_counter++;
    if (cell_context->system_info_tag_counter == RRMCC_MAX_TAG_VALUE)
    {
        cell_context->system_info_tag_counter = RRM_ZERO;
    }
    p_sib_type_1_info->si_value_tag = cell_context->system_info_tag_counter; /* BLR */
    /* BUG_12215_FIX_END */

#ifdef TDD_MODE_FLAG
    map_cell_setup_tdd_config(cell_context,
            p_sib_type_1_info);
#endif
    if (cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
    {
        p_sib_type_1_info->presence_bitmask |= SIB_TYPE_1_NON_CRITICAL_EXTENSION_PRESENT_FLAG; 
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    /*eMTC changes start */    
        ret_val = non_critical_extension(cell_context,
                &(p_sib_type_1_info->non_critical_extension));
    /*eMTC changes end */    
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_cell_access_related_info
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_cell_access_info
 *   DESCRIPTION :
 *    		This function Maps the cell access related params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_cell_access_related_info
(
 rrm_cell_context_t *cell_context, 
 cell_access_related_info_t *p_cell_access_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    U8            tac_size = RRM_ZERO;
    U8            cell_id = RRM_ZERO;

    U8            csg_octets = RRM_ZERO; 


    RRM_UT_TRACE_ENTER();

    /*fill bitmask*/
    p_cell_access_info->presence_bitmask = RRM_ZERO;

    if (cell_context->epc_info.epc_params.bitmask & RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT)
    {
        for(tac_size = RRM_ZERO; tac_size < MAX_TAC_SIZE; tac_size++)
        {
            p_cell_access_info->tac[tac_size]	= 
                cell_context->epc_info.epc_params.general_epc_params.tac[tac_size];
        }
    }
    for(cell_id = RRM_ZERO; cell_id < MAX_CELL_IDENTITY_OCTETS; cell_id++)
    {
        p_cell_access_info->cell_Id[cell_id] = 
            cell_context->ran_info.common_eutran_params.cell_identity[cell_id];
    }
    switch(cell_context->ran_info.cell_restriction_params.
            cell_and_access_barring.cell_barred)
    {
        case RRM_OAM_CELL_BARRED:
            p_cell_access_info->cell_barred = RRM_RRC_CELL_BARRED;
            break;
        case RRM_OAM_CELL_NOT_BARRED:
            p_cell_access_info->cell_barred = RRM_RRC_CELL_NOT_BARRED;
            break;
        default :
            p_cell_access_info->cell_barred = cell_context->ran_info.cell_restriction_params.
                cell_and_access_barring.cell_barred;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for cell_barred = %u",
                    cell_context->ran_info.cell_restriction_params.
                    cell_and_access_barring.cell_barred);
            ret_val = RRM_FAILURE;
            break;
    }

    /* BUG_371 FIX START */
    /*if (cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
      {
      p_cell_access_info->intra_freq_reselection = 
      cell_context->operator_info.sib_1_info.
      cell_access_info.intra_frequency_reselection;
      }*/
    if (cell_context->ran_info.bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT)
    {
        p_cell_access_info->intra_freq_reselection = cell_context->ran_info.cell_restriction_params.
            cell_and_access_barring.cell_access_info.intra_frequency_reselection;
    }
    /* BUG_371 FIX END */


    /*Disabling CSG ID Support
     */

    /*csg start - enabling csg support*/
    if(cell_context->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
    {
        /* Fix for CSR 58972 start*/
        if ((cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN) ||
                (cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
            /* Fix for CSR 58972 end*/
        {
            p_cell_access_info->csg_indication = RRC_FALSE;
        }
        else if(cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_HYBRID)
        {
            p_cell_access_info->csg_indication = RRC_FALSE;
            p_cell_access_info->presence_bitmask  |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG ;
            for(csg_octets = RRM_ZERO; csg_octets < NUM_CSG_OCTETS; csg_octets++)
            {
                p_cell_access_info->csg_identity[csg_octets] = 
                    cell_context->access_mgmt_params.csg_id[csg_octets];
            }
        }
        else if(cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_CLOSE)
        {
            p_cell_access_info->csg_indication = RRC_TRUE;
            p_cell_access_info->presence_bitmask  |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG ;
            for(csg_octets = RRM_ZERO; csg_octets < NUM_CSG_OCTETS; csg_octets++)
            {
                p_cell_access_info->csg_identity[csg_octets] = 
                    cell_context->access_mgmt_params.csg_id[csg_octets];
            }
        }

    }
    else
    {
        p_cell_access_info->csg_indication = RRC_FALSE;
    }
    /*csg end - enabling csg support*/
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    plmn_id_info_list(cell_context,
            &(p_cell_access_info->plmn_Id_info_list));
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

#ifdef TDD_MODE_FLAG
/****************************************************************************
 *   FUNCTION NAME :  map_cell_setup_tdd_config
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_sib_type_1_info
 *   DESCRIPTION :
 *          This function Maps the tdd params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_cell_setup_tdd_config
(
 rrm_cell_context_t *cell_context,
 sib_type_1_Info_t*  p_sib_type_1_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if ( cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT)
    {
        p_sib_type_1_info->presence_bitmask |= SIB_TYPE_1_TDD_CONFIG_PRESENT_FLAG;
        p_sib_type_1_info->tdd_config.sub_frame_assignment =
            (U8)cell_context->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure.sub_frame_assignment;

        p_sib_type_1_info->tdd_config.special_sub_frame_pattern =
            (U8)cell_context->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure.special_sub_frame_patterns;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
#endif
/****************************************************************************
 *   FUNCTION NAME       :  plmn_id_info_list
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_plmn_info_list
 *   DESCRIPTION :
 *    		This function Maps the plmn id info list params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
plmn_id_info_list
(
 rrm_cell_context_t *cell_context, 
 plmn_id_info_list_t *p_plmn_info_list
 )
{
    U8          plmn_count = RRM_ZERO;
    U8          valid_plmn = RRM_ZERO;
    U8          mcc_digits = RRM_ZERO;
    U8          mnc_digits = RRM_ZERO;
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* SPR 10730 Fix Start */
    if (cell_context->epc_info.epc_params.bitmask & RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT)
    {
        valid_plmn = p_plmn_info_list->count = cell_context->epc_info.epc_params.\
                     general_epc_params.num_valid_plmn;
        for(plmn_count=RRM_ZERO; plmn_count < valid_plmn; plmn_count++)
        {
            /* Initialisin the bitmask */
            p_plmn_info_list->plmn_identity_info[plmn_count].plmn_identity.presence_bitmask = RRM_ZERO;

            if(cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].bitmask & RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT)
            {
                switch(cell_context->epc_info.epc_params.general_epc_params.
                        plmn_list[plmn_count].cell_reserved_for_operator_use)
                {
                    case RRM_OAM_RESERVED_FOR_OPERATOR:
                        p_plmn_info_list->plmn_identity_info[plmn_count].
                            cell_res_for_operator_use = RRM_RRC_CELL_RESERVED;
                        break;
                    case RRM_OAM_NOT_RESERVED_FOR_OPERATOR:
                        p_plmn_info_list->plmn_identity_info[plmn_count].
                            cell_res_for_operator_use = RRM_RRC_CELL_NOT_RESERVED;
                        break;
                    default :
                        p_plmn_info_list->plmn_identity_info[plmn_count].
                            cell_res_for_operator_use =  cell_context->epc_info.epc_params.general_epc_params.
                            plmn_list[plmn_count].cell_reserved_for_operator_use;
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                                "Incorrect value received for"\
                                "cell_reserved_for_operator_use = %u",
                                cell_context->epc_info.epc_params.general_epc_params.
                                plmn_list[plmn_count].cell_reserved_for_operator_use);
                        ret_val = RRM_FAILURE;
                        break;
                }
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Cell Config:- cell_reserved_for_operator_use = %u",
                        cell_context->epc_info.epc_params.general_epc_params.
                        plmn_list[plmn_count].cell_reserved_for_operator_use);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Cell Config:- Bitmask for cell_reserved_for_operator_use is not present !!!");
            }

            if(cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].plmn_id.bitmask & RRMCM_MCC_PRESENCE_BITMASK)
            {
                p_plmn_info_list->plmn_identity_info[plmn_count].plmn_identity.\
                    presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

                for(mcc_digits = RRM_ZERO; mcc_digits < MAX_MCC_DIGITS; mcc_digits++)
                {
                    p_plmn_info_list->plmn_identity_info[plmn_count].
                        plmn_identity.mcc[mcc_digits] =
                        cell_context->epc_info.epc_params.general_epc_params.
                        plmn_list[plmn_count].plmn_id.mcc[mcc_digits];
                }
            }
            p_plmn_info_list->plmn_identity_info[plmn_count].
                plmn_identity.mnc.count	= 
                cell_context->epc_info.epc_params.general_epc_params.
                plmn_list[plmn_count].plmn_id.num_mnc_digit;
            for (mnc_digits = RRM_ZERO; mnc_digits < 
                    cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].plmn_id.num_mnc_digit; mnc_digits++)
            {
                p_plmn_info_list->plmn_identity_info[plmn_count].
                    plmn_identity.mnc.mnc[mnc_digits] = 
                    cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].plmn_id.mnc[mnc_digits];
            }	
        }	
    }
    /* SPR 10730 Fix End */

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   scheduling_info_list
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_sched_info
 *   DESCRIPTION :
 *    		This function Maps the scheduling info list params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
scheduling_info_list
(
 rrm_cell_context_t *cell_context, 
 scheduling_info_list_t  *p_sched_info
 )
{
    U8              scheduling_list = RRM_ZERO;
    U8              sib_mapping = RRM_ZERO;
    U8              valid_scheduling_list = RRM_ZERO;
    U8              valid_sib_mapping_info = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    valid_scheduling_list =	p_sched_info->count = 
        cell_context->operator_info.sib_1_info.\
        scheduling_info_list.count;

    for(scheduling_list = RRM_ZERO; scheduling_list < valid_scheduling_list; scheduling_list++)
    {
        valid_sib_mapping_info = 
            p_sched_info->scheduling_info[scheduling_list].sib_mapping_info.count = 
            cell_context->operator_info.sib_1_info.scheduling_info_list.
            scheduling_info[scheduling_list].sib_mapping_info.count;

        for(sib_mapping = RRM_ZERO; sib_mapping < valid_sib_mapping_info; sib_mapping++)
        {
            p_sched_info->scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping] = 
                cell_context->operator_info.sib_1_info.scheduling_info_list.
                scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping];
        }
        p_sched_info->scheduling_info[scheduling_list].si_periodicity = 
            cell_context->operator_info.sib_1_info.scheduling_info_list.
            scheduling_info[scheduling_list].si_periodicity;
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_cell_selection_info
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_cell_selection_info
 *   DESCRIPTION :
 *    		This function Maps the cell selection info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_cell_selection_info
(
 rrm_cell_context_t *cell_context, 
 cell_selection_Info_t *p_cell_selection_info
 )
{
    RRM_UT_TRACE_ENTER();

    /*bitmask*/
    p_cell_selection_info->presence_bitmask = RRM_ZERO;
    p_cell_selection_info->q_rx_lev_min =  
        cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_1;

    if(cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.bitmask & 
            RRMCM_RMIF_Q_RX_LEV_MIN_OFFSET_PRESENT)
    {
        p_cell_selection_info->presence_bitmask |= 
            CELL_SELECT_INFO_Q_RX_LEV_MIN_OFFSET_PRESENCE_FLAG;

        p_cell_selection_info->q_rx_lev_min_offset = 
            cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
            q_rx_lev_min_offset;
    }
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

#ifdef TDD_MODE_FLAG
/****************************************************************************
 *   FUNCTION NAME       :   tdd_config
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_tdd_config
 *   DESCRIPTION :
 *    		This function Maps the tdd config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
tdd_config
(void)
 /*SPR 17777 +-*/
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
#endif

/****************************************************************************
 *   FUNCTION NAME : fill_access_class_barring_info
 *   INPUT         : *p_access_class_barring_info
 *   OUTPUT        : *p_access_class_barring
 *   DESCRIPTION   : This function Maps the access class barring info params 
 *                   coming from MIF to RRC
 *
 *   RETURNS       :
 *       		RRM_SUCCESS     on Success.
 *       		RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
fill_access_class_barring_info(
        rrm_access_class_barring_info_t   *p_access_class_barring_info,
        access_class_barring_Info_t       *p_access_class_barring)
{
    RRM_UT_TRACE_ENTER();
    /* LTE_RRM_WARNING_REMOVAL_START*/
    p_access_class_barring->ac_barring_factor = 
        rrm_get_ac_barring_factor(p_access_class_barring_info);
    p_access_class_barring->ac_barring_time = 
        rrm_get_ac_barring_time(p_access_class_barring_info);
    p_access_class_barring->ac_barring_for_special_ac = 
        rrm_get_ac_barring_for_special_ac(p_access_class_barring_info);
    /* LTE_RRM_WARNING_REMOVAL_END */
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
            "ac_barring_factor[%d]   ac_barring_time[%d]  ac_barring_for_special_ac[%d]", 
            p_access_class_barring->ac_barring_factor, 
            p_access_class_barring->ac_barring_time, 
            p_access_class_barring->ac_barring_for_special_ac); 

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_2
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_sib_type_2_info
 *   DESCRIPTION :
 *    		This function Maps the sib type 2 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_sib_type_2(rrm_cell_context_t        *cell_context, 
        sib_type_2_Info_t         *p_sib_type_2_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_sib_type_2_info->presence_bitmask = RRM_ZERO;

    if (RRMCM_RMIF_BARRING_INFO_PRESENT == 
            (cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
             bitmask & RRMCM_RMIF_BARRING_INFO_PRESENT))
    {
        p_sib_type_2_info->presence_bitmask |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
        access_barring_info(cell_context, &(p_sib_type_2_info->access_barring_info));
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    }

    if(RRM_FAILURE == radio_resource_config_common_sib(
                cell_context,
                &(p_sib_type_2_info->radio_resource_config_common_sib)))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_WARNING, "Failure returned during" \
                "radio_resource_config_common_sib");
    }
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    ue_timers_and_constants(cell_context,
            &(p_sib_type_2_info->ue_timers_and_constants));

    freq_info(cell_context,
            &(p_sib_type_2_info->freq_info));
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/

    if(cell_context->ran_info.physical_layer_params.bitmask & \
	/* SPR 22248 MBMS Changes Start */
		RRMCM_RMIF_MBSFN_CONFIGURATION_INFO_PRESENT)
	/* SPR 22248 MBMS Changes Stop */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "MB_SFN is not supported in this Release");

        /*
           if(RRM_FAILURE == mbsfn_subframe_config_list(cell_context,rrc_rrm_cell_setup_req))
           {
           return RRM_FAILURE;
           }
         */
    }
    /*bug 9979 Fix - Delete*/

    p_sib_type_2_info->time_align_timer = 
        cell_context->operator_info.sib_2_info.time_alignment_timer;

    /*access_class_barring Info */ 
    /* SPR 5692 */
    if (cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
            access_barring_info.bitmask& 
            RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT");

        /*mmtel_voice_r9 Info */
        if(cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                access_barring_info.ssac_barring_r9.bitmask & RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT)
        {
            p_sib_type_2_info->presence_bitmask |= 
                SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG;
            fill_access_class_barring_info(&cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.access_barring_info.ssac_barring_r9.
                    ssac_barring_for_mmtel_voice_r9, 
                    &(p_sib_type_2_info->ssac_barring_for_mmtel_voice_r9));
        }

        /*mmtel_video_r9 Info */
        if(cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                access_barring_info.ssac_barring_r9.bitmask & RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT)
        {
            p_sib_type_2_info->presence_bitmask |= 
                SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG;
            fill_access_class_barring_info(&cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.access_barring_info.
                    ssac_barring_r9.ssac_barring_for_mmtel_video_r9, 
                    &(p_sib_type_2_info->ssac_barring_for_mmtel_video_r9));
        }
    }
    /* SPR 5692 */

    p_sib_type_2_info->access_barring_info.presence_bitmask = RRM_ZERO;

    if (cell_context->operator_info.sib_2_info.
            radio_res_config_common_sib.bitmask & RRMCM_RMIF_BARRING_INFO_PRESENT)
    {
        if (cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                access_barring_info.bitmask & RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT)
        {
            p_sib_type_2_info->access_barring_info.ac_barring_for_mo_signalling.
                ac_barring_factor = rrm_get_ac_barring_factor(&(
                            cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                            access_barring_info.ac_barring_for_mo_signalling));

            p_sib_type_2_info->access_barring_info.ac_barring_for_mo_signalling.
                ac_barring_time = rrm_get_ac_barring_time(&(cell_context->
                            operator_info.sib_2_info.radio_res_config_common_sib.
                            access_barring_info.ac_barring_for_mo_signalling));

            p_sib_type_2_info->access_barring_info.ac_barring_for_mo_signalling.
                ac_barring_for_special_ac = rrm_get_ac_barring_for_special_ac(
                        &(cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                            access_barring_info.ac_barring_for_mo_signalling));

            p_sib_type_2_info->access_barring_info.presence_bitmask |= 
                AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;
        }

        if(cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                access_barring_info.bitmask & RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
        {
            p_sib_type_2_info->access_barring_info.ac_barring_for_mo_data.
                ac_barring_factor = rrm_get_ac_barring_factor(&(cell_context->
                            operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
            p_sib_type_2_info->access_barring_info.ac_barring_for_mo_data.
                ac_barring_time = rrm_get_ac_barring_time(&(cell_context->operator_info.
                            sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
            p_sib_type_2_info->access_barring_info.ac_barring_for_mo_data.
                ac_barring_for_special_ac = rrm_get_ac_barring_for_special_ac(&
                        (cell_context->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                         ac_barring_for_mo_data));

            p_sib_type_2_info->access_barring_info.presence_bitmask |= 
                AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;
        }      

        p_sib_type_2_info->presence_bitmask |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
    }
    /*SPR_15289_changes_Start*/
    if (cell_context->operator_info.sib_2_info.presence_bitmask & RRMCM_RMIF_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG)
    {
        p_sib_type_2_info->presence_bitmask |= SIB2_AC_BARRING_FOR_CSFB_PRESENCE_FLAG;
        p_sib_type_2_info->ac_barring_for_csfb_r10.ac_barring_factor =
            cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_factor;
        p_sib_type_2_info->ac_barring_for_csfb_r10.ac_barring_time=
            cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_time;
        p_sib_type_2_info->ac_barring_for_csfb_r10.ac_barring_for_special_ac =
            cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_for_special_ac;
    }

    /*SPR_15289_changes_End*/

    #ifdef LTE_EMBMS_SUPPORTED
    if (MBMS_SIB_2_ON_BROADCAST &
                cell_context->rrm_cell_embms_data.current_sibs_on_boradcast)
    {
        rrm_map_conf_sib_type_2_info_for_embms(&cell_context->ran_info.physical_layer_params.
                physical_layer_param_mbsfn_config_info,
                &p_sib_type_2_info->mbsfn_subframe_config_list);
        p_sib_type_2_info->presence_bitmask |= SIB2_MBSFN_SUBFRAME_CONF_LIST_PRESENCE_FLAG;

    }
    #endif


    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   radio_resource_config_common_sib
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_rrc_comon_sib_info
 *   DESCRIPTION :
 *    		This function Maps the radio resource config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
radio_resource_config_common_sib(rrm_cell_context_t   *cell_context, 
        radio_resource_config_common_sib_t  *p_rrc_comon_sib_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if (RRM_FAILURE == rach_config_common(
                cell_context,
                &(p_rrc_comon_sib_info->rach_config_common)))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from rach_config_common");
        ret_val = RRM_FAILURE;
    }

    ret_val = bcch_config(
            cell_context,
            &(p_rrc_comon_sib_info->bcch_config));
    ret_val = pcch_config(
            cell_context,
            &(p_rrc_comon_sib_info->pcch_config));
    ret_val = prach_config_sib(
            cell_context,
            &(p_rrc_comon_sib_info->prach_config_sib));

    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        switch (cell_context->operator_info.sib_2_info.
                radio_res_config_common_sib.ul_cyclic_prefix_length)
        {
            case RRM_OAM_UL_CYC_PREFIX_LEN_1:
                p_rrc_comon_sib_info->ul_cyc_prefix_len = RRM_RRC_UL_CYC_PREFIX_LEN_1;
                break;

            case RRM_OAM_UL_CYC_PREFIX_LEN_2:
                p_rrc_comon_sib_info->ul_cyc_prefix_len = RRM_RRC_UL_CYC_PREFIX_LEN_2;
                break;

            default:
                p_rrc_comon_sib_info->ul_cyc_prefix_len = cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.ul_cyclic_prefix_length;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for ul_cyc_prefix_len = %u",
                        cell_context->operator_info.sib_2_info.
                        radio_res_config_common_sib.ul_cyclic_prefix_length);
                ret_val = RRM_FAILURE;
                break;
        }
    }
    ret_val = pdsch_config_common(
            cell_context,
            &(p_rrc_comon_sib_info->pdsch_config_common));
    ret_val = pusch_config_common(
            cell_context,
            &(p_rrc_comon_sib_info->pusch_config_common));

    ret_val = pucch_config_common(
            cell_context,
            &(p_rrc_comon_sib_info->pucch_config_common));
    ret_val = sounding_rs_ul_config_common(
            cell_context,
            &(p_rrc_comon_sib_info->sounding_rs_ul_config_common));
    ret_val = uplink_power_control_common(
            cell_context,
            &(p_rrc_comon_sib_info->uplink_power_control_common));
    /* CA_Stage3_PUCCH_Format_Enh: Start */
    ret_val = uplink_power_control_common_r10(
            cell_context,
            &(p_rrc_comon_sib_info->uplink_power_control_common_v1020));
    if(ret_val == RRM_SUCCESS)
    {
        p_rrc_comon_sib_info->presence_bitmask |= RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020;
    }
    /* CA_Stage3_PUCCH_Format_Enh: End */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   rach_config_common
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_rach_config_common
 *   DESCRIPTION         : This function Maps the common rach config params 
 *                         coming from MIF to RRC
 *   RETURNS             : RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rach_config_common
(
 rrm_cell_context_t   *cell_context, 
 rach_config_common_t *p_rach_config_common
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if(cell_context->ran_info.bitmask & RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT)
    {
        if(RRM_FAILURE == preamble_info(
                    cell_context,
                    &(p_rach_config_common->preamble_info)))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from preamble_info");
            ret_val = RRM_FAILURE;
        }
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
        power_ramping_params(cell_context,
                &(p_rach_config_common->power_ramping_params));

        ra_supervision_info(cell_context,
                &(p_rach_config_common->ra_supervision_info));
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
        p_rach_config_common->max_harq_msg_3_tx = 
            cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.max_harq_msg_3tx;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   rrm_preamble_info_lower
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_preamble_info
 *   DESCRIPTION :
 *          This function Maps the preamble info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
rrm_preamble_info_lower(rrm_cell_context_t *cell_context,
        preamble_info_t    *p_preamble_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    switch(cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.number_of_ra_preambles)
    {
        case RRM_OAM_RA_PREAMBLE_COUNT_N4:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N4;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N8:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N8;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N12:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N12;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N16:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N16;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N20:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N20;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N24:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N24;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N28:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N28;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N32:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N32;
            break;
        default :
            p_preamble_info->ra_preamble_count = cell_context->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.number_of_ra_preambles;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for number_of_ra_preambles = %u",
                    cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.number_of_ra_preambles);
            ret_val = RRM_FAILURE;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME       :   rrm_preamble_info_higher
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_preamble_info
 *   DESCRIPTION :
 *          This function Maps the preamble info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
rrm_preamble_info_higher(rrm_cell_context_t *cell_context,
        preamble_info_t    *p_preamble_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    switch(cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.number_of_ra_preambles)
    {
        case RRM_OAM_RA_PREAMBLE_COUNT_N36:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N36;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N40:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N40;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N44:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N44;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N48:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N48;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N52:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N52;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N56:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N56;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N60:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N60;
            break;
        case RRM_OAM_RA_PREAMBLE_COUNT_N64:
            p_preamble_info->ra_preamble_count = RRM_RRC_RA_PREAMBLE_COUNT_N64;
            break;
        default :
            p_preamble_info->ra_preamble_count = cell_context->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.number_of_ra_preambles;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for number_of_ra_preambles = %u",
                    cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.number_of_ra_preambles);
            ret_val = RRM_FAILURE;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/****************************************************************************
 *   FUNCTION NAME       :   preamble_info
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_preamble_info
 *   DESCRIPTION :
 *    		This function Maps the preamble info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
preamble_info
(
 rrm_cell_context_t *cell_context, 
 preamble_info_t    *p_preamble_info
 )
{
    rrm_preamble_info_t         *p_rrm_cellm_preamble_info = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_preamble_info->presence_bitmask = RRM_ZERO; 
    /*Klockwork_fix_start*/
    if (cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.number_of_ra_preambles <= RRM_OAM_RA_PREAMBLE_COUNT_N32 )
    {
        rrm_preamble_info_lower(cell_context ,p_preamble_info);
    }
    else
    {
        rrm_preamble_info_higher(cell_context ,p_preamble_info);
    }
    /*Klockwork_fix_end*/
    p_rrm_cellm_preamble_info = &(cell_context->ran_info.
            mac_layer_params.mac_layer_param_rach.
            preamble_info);
    if ((p_rrm_cellm_preamble_info->bitmask & RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT)
       )
    {
        p_preamble_info->presence_bitmask |= PREAMBLE_INFO_GROUP_A_CONFIG_PRESENCE_FLAG;
        if(RRM_FAILURE == preambles_group_a_config(
                    cell_context,
                    &(p_preamble_info->preambles_group_a_config)))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from preambles_group_a_config");
            ret_val = RRM_FAILURE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : rrm_build_and_send_enb_config_tranfer_req
 *   INPUT         : *p_tnl_discovery_req
 *   OUTPUT        : enb_ctx
 *   DESCRIPTION   : This function builds and sends the enb_config_transfer_req
 to RRC.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_build_and_send_enb_config_tranfer_req
(
 rrmcm_rmif_cell_son_tnl_discovery_req_t  *p_tnl_discovery_req,
    /* SPR_17367_Start */
    rrm_enb_context_t  *p_enb_ctx
    /* SPR_17367_End */
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    rrm_cell_index_t  cell_index = RRM_ZERO;
    /* SPR_17367_Start */
    rrm_connected_mme_node_t                    *p_rrm_connected_mme_node   = RRM_PNULL;
    U16                                         req_success_count           = RRM_ZERO;
    /* SPR_17367_End */
    RRM_UT_TRACE_ENTER();

    s1ap_rrm_enb_config_transfer_t enb_config_transfer = {RRM_NULL};

    /* SPR_17367_Start */
    p_rrm_connected_mme_node = (rrm_connected_mme_node_t*)ylFirst(&p_enb_ctx->connected_mme_list);

    while (RRM_PNULL != p_rrm_connected_mme_node)
    {

        if (RRM_TRUE == rrm_cellm_is_trgt_enb_associated_with_source_plmn(
                    &p_tnl_discovery_req->tnl_discovery_req.target_enb_id.plmn_id,
                    p_rrm_connected_mme_node))
        {
    enb_config_transfer.bitmask = ENB_CONFIGURATION_TRANSFER_REQ;
            enb_config_transfer.mme_id = p_rrm_connected_mme_node->mme_key_id;

    rrm_fill_plmn_identity_for_enb_transfer(&(p_tnl_discovery_req->tnl_discovery_req.target_enb_id.plmn_id),&(enb_config_transfer.gb_enb_id.plmn_identity));
    if (RRM_ENB_TYPE_HOME == p_tnl_discovery_req->tnl_discovery_req.target_enb_id.enb_type)
    {
        enb_config_transfer.gb_enb_id.enb_id.presence_bitmask = S1AP_OAM_HOME_ENB_ID_PRESENT;
        RRM_MEMCPY(enb_config_transfer.gb_enb_id.enb_id.home_enb_id.eNB_id,
                   p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id,
                   sizeof(enb_config_transfer.gb_enb_id.enb_id.home_enb_id.eNB_id));
    }

    if (RRM_ENB_TYPE_MACRO == p_tnl_discovery_req->tnl_discovery_req.target_enb_id.enb_type)
    {
        enb_config_transfer.gb_enb_id.enb_id.presence_bitmask = S1AP_OAM_MACRO_ENB_ID_PRESENT;
        RRM_MEMCPY(enb_config_transfer.gb_enb_id.enb_id.macro_enb_id.eNB_id,
                p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id,
                sizeof(enb_config_transfer.gb_enb_id.enb_id.macro_enb_id.eNB_id));
    }

    rrm_fill_plmn_identity_for_enb_transfer(&p_tnl_discovery_req->tnl_discovery_req.target_enb_id.plmn_id,
                                            &enb_config_transfer.target_supp_ta.plmn_identity);

    rrm_memcpy_u8(enb_config_transfer.target_supp_ta.tac,
               p_tnl_discovery_req->tnl_discovery_req.tac,
               sizeof(enb_config_transfer.target_supp_ta.tac));
               
            rrm_fill_plmn_identity_for_enb_transfer(&p_enb_ctx->enb_tai.plmn_id,
                                            &enb_config_transfer.source_supp_ta.plmn_identity);

    RRM_MEMCPY(enb_config_transfer.source_supp_ta.tac,
                    &p_enb_ctx->enb_tai.tac,
               sizeof(enb_config_transfer.source_supp_ta.tac));

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
        "TNL ENB config transfer tansaction ID =  %d", p_tnl_discovery_req->transaction_id);

    ret_val = rrm_il_send_s1ap_rrm_enb_config_transfer(&enb_config_transfer,
                           RRM_MODULE_ID,RRC_MODULE_ID, p_tnl_discovery_req->transaction_id,cell_index);
            if (RRM_SUCCESS == ret_val)
            {
                if (RRM_ENB_TYPE_HOME == p_tnl_discovery_req->tnl_discovery_req.target_enb_id.enb_type)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Successfully sent ENB config transfer to MMEId[%d] for HeNBId[0x%x%x%x%x]",
                            p_rrm_connected_mme_node->mme_key_id,
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ZERO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ONE],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_TWO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_THREE]);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Successfully sent ENB config transfer to MMEId[%d] for Macro eNBId[0x%x%x%x%x]",
                            p_rrm_connected_mme_node->mme_key_id,
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ZERO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ONE],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_TWO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_THREE]);
                }
		req_success_count++;
            }
            else
            {
                if (RRM_ENB_TYPE_HOME == p_tnl_discovery_req->tnl_discovery_req.target_enb_id.enb_type)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Failed to send ENB config transfer to MMEId[%d] for HeNBId[0x%x%x%x%x]",
                            p_rrm_connected_mme_node->mme_key_id,
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ZERO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ONE],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_TWO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_THREE]);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Failed to send ENB config transfer to MMEId[%d] for Macro eNBId[0x%x%x%x%x]",
                            p_rrm_connected_mme_node->mme_key_id,
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ZERO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_ONE],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_TWO],
                            p_tnl_discovery_req->tnl_discovery_req.target_enb_id.eNb_id[RRM_THREE]);
                }
            }
        }
	p_rrm_connected_mme_node = (rrm_connected_mme_node_t *)ylNext(&p_rrm_connected_mme_node->s_node);
    }
    if (RRM_ZERO != req_success_count)
    {
        ret_val = RRM_SUCCESS;
    }
    else
    {
        ret_val = RRM_FAILURE;
    }
    /* SPR_17367_End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*IPv6 changes begin*/
/*code cleaned -  L3 does not support
  MME CONFIG TRANSFER from RRM to L3 as per API DOC*/
/*IPv6 changes end*/

/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
/****************************************************************************
 *   FUNCTION NAME : map_ra_preambles_group_a_size_info 
 *   INPUT         : ra_preambles_group_a_size_val
 *   OUTPUT        : *p_preamble_group_a
 *   DESCRIPTION   : This function Maps ra preambles group a size Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ra_preambles_group_a_size_info(
        rrm_oam_ra_preambles_group_a_size_et  ra_preambles_group_a_size_val, 
        preambles_group_a_config_t            *p_preamble_group_a)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(ra_preambles_group_a_size_val)
    {
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N4;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N8;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N12;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N16;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N20;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N24;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N28;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N32;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N36;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N40;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N44;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N48;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N52;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N56;
            break;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60:
            p_preamble_group_a->ra_preambles_group_a_size =
                RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N60;
            break;

        default:
            p_preamble_group_a->ra_preambles_group_a_size = ra_preambles_group_a_size_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for size_of_ra_group_a = %u",
                    p_preamble_group_a->ra_preambles_group_a_size);
            ret_val = RRM_FAILURE;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_message_size_group_a_info
 *
 *   DESCRIPTION   : This function Maps message size group a Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_message_size_group_a_info(
        rrm_oam_group_a_msg_size_et  message_size_group_a_val,  
        preambles_group_a_config_t   *p_preamble_group_a)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(message_size_group_a_val)
    {
        case RRM_OAM_GROUP_A_MSG_SIZE_B56:
            p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B56;
            break;
        case RRM_OAM_GROUP_A_MSG_SIZE_B144:
            p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B144;
            break;
        case RRM_OAM_GROUP_A_MSG_SIZE_B208:
            p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B208;
            break;
        case RRM_OAM_GROUP_A_MSG_SIZE_B256:
            p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B256;
            break;
        default:
            p_preamble_group_a->group_a_msg_size = message_size_group_a_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for message_size_group_a = %u",
                    p_preamble_group_a->group_a_msg_size);
            ret_val = RRM_FAILURE;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME : map_group_b_msg_power_offset_val
 *   INPUT         : msg_power_offset_group_b_val
 *   OUTPUT        : *p_preamble_group_a
 *   DESCRIPTION   : This function Maps group b msg power offset value.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_group_b_msg_power_offset_val(
        rrm_oam_group_b_msg_power_offset_et  msg_power_offset_group_b_val,
        preambles_group_a_config_t           *p_preamble_group_a)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(msg_power_offset_group_b_val)
    {
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB0:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB0;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB5:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB5;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB8:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB8;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB10:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB10;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB12:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB12;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB15:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB15;
            break;
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB18:
            p_preamble_group_a->group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB18;
            break;

        default:
            p_preamble_group_a->group_b_msg_power_offset = msg_power_offset_group_b_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for message_power_offset_group_b = %u",
                    p_preamble_group_a->group_b_msg_power_offset);
            ret_val = RRM_FAILURE;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_preamble_trans_max_info
 *   INPUT         : preamble_tr_max_val
 *   OUTPUT        : *p_ra_supervision_info
 *   DESCRIPTION   : This function Maps preamble trans max Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_preamble_trans_max_info(
        rrm_oam_preamble_trans_max_et  preamble_tr_max_val,
        ra_supervision_info_t          *p_ra_supervision_info)
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(preamble_tr_max_val)
    {
        case RRM_OAM_PREAMBLE_TRANS_MAX_N3:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N3;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N4:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N4;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N5:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N5;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N6:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N6;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N7:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N7;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N8:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N8;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N10:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N10;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N20:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N20;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N50:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N50;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N100:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N100;
            break;
        case RRM_OAM_PREAMBLE_TRANS_MAX_N200:
            p_ra_supervision_info->preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N200;
            break;

        default :
            p_ra_supervision_info->preamble_trans_max = preamble_tr_max_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for preamble_trans_max= %u",
                    p_ra_supervision_info->preamble_trans_max);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/ 

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_response_window_size_info
 *   INPUT         : resp_win_size_val
 *   OUTPUT        : *p_ra_supervision_info
 *   DESCRIPTION   : This function Maps response window size Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_response_window_size_info(
        rrm_oam_ra_resp_win_size_et resp_win_size_val, 
        ra_supervision_info_t *p_ra_supervision_info )
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(resp_win_size_val)
    {
        case RRM_OAM_RA_RESP_WIN_SIZE_SF2:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF2;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF3:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF3;
            break;
        case RRM_OAM_RA_RESP_WIN_SIZE_SF4:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF4;
            break;
        case RRM_OAM_RA_RESP_WIN_SIZE_SF5:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF5;
            break;
        case RRM_OAM_RA_RESP_WIN_SIZE_SF6:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF6;
            break;
        case RRM_OAM_RA_RESP_WIN_SIZE_SF7:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF7;
            break;
        case RRM_OAM_RA_RESP_WIN_SIZE_SF8:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF8;
            break;
        case RRM_OAM_RA_RESP_WIN_SIZE_SF10:
            p_ra_supervision_info->ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF10;
            break;
        default :
            p_ra_supervision_info->ra_resp_win_size = resp_win_size_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect value received for response_window_size = %u",
                    p_ra_supervision_info->ra_resp_win_size);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_mac_contention_resolution_timer_info
 *   INPUT         : mac_cont_res_timer_val
 *   OUTPUT        : *p_ra_supervision_info
 *   DESCRIPTION   : This function Maps mac contention resolution timer Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_mac_contention_resolution_timer_info(  
        rrm_oam_mac_cont_resol_timer_et   mac_cont_res_timer_val,       
        ra_supervision_info_t            *p_ra_supervision_info)
{
    rrm_return_et  ret_val = RRM_SUCCESS; 

    RRM_UT_TRACE_ENTER();

    switch(mac_cont_res_timer_val)
    {
        case RRM_OAM_MAC_CONT_RES_TIMER_SF8:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF8;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF16:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF16;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF24:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF24;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF32:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF32;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF40:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF40;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF48:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF48;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF56:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF56;
            break;
        case RRM_OAM_MAC_CONT_RES_TIMER_SF64:
            p_ra_supervision_info->mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF64;
            break;

        default :
            p_ra_supervision_info->mac_cont_resol_timer = mac_cont_res_timer_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for contention_resolution_timer = %u",
                    p_ra_supervision_info->mac_cont_resol_timer);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_srs_bandwidth_config_info
 *   INPUT         : srs_bw_config_val
 *   OUTPUT        : *p_sounding_rs_ul_info
 *   DESCRIPTION   : This function Maps srs bandwidth config Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_srs_bandwidth_config_info(  
        rrm_oam_srs_bw_config_et        srs_bw_config_val,
        sounding_rs_ul_config_common_t  *p_sounding_rs_ul_info)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(srs_bw_config_val)
    {
        case RRM_OAM_SRS_BW_CONFIG_BW0:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW0;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW1:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW1;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW2:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW2;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW3:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW3;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW4:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW4;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW5:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW5;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW6:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW6;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_BW_CONFIG_BW7:
            p_sounding_rs_ul_info->setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW7;
            ret_val = RRM_SUCCESS;
            break;

        default :
            p_sounding_rs_ul_info->setup.srs_bw_config = srs_bw_config_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for srs_bw_config = %u",
                    p_sounding_rs_ul_info->setup.srs_bw_config);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_srs_subframe_config_info
 *   INPUT         : srs_subframe_config_val
 *   OUTPUT        : *p_sounding_rs_ul_info
 *   DESCRIPTION   : This function Maps srs subframe config Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_srs_subframe_config_info(
        rrm_oam_srs_subframe_config_et  srs_subframe_config_val,        
        sounding_rs_ul_config_common_t  *p_sounding_rs_ul_info)
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(srs_subframe_config_val)
    {  

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC0:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC0;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC1:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC1;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC2:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC2;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC3:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC3;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC4:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC4;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC5:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC5;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC6:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC6;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC7:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC7;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC8:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC8;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC9:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC9;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC10:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC10;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC11:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC11;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC12:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC12;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC13:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC13;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC14:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC14;
            ret_val = RRM_SUCCESS;
            break;
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC15:
            p_sounding_rs_ul_info->setup.srs_subframe_config =
                RRM_RRC_SRS_SUBFRAME_CONFIG_SC15;
            ret_val = RRM_SUCCESS;
            break;

        default :
            p_sounding_rs_ul_info->setup.srs_subframe_config = srs_subframe_config_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for srs_subframe_config = %u",
                    p_sounding_rs_ul_info->setup.srs_subframe_config);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ul_power_control_alpha_info
 *   INPUT         : ul_power_control_alpha_info
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps ul power control alpha Info
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ul_power_control_alpha_info( 
        rrm_oam_alpha_et                ul_power_control_alpha_info,
        uplink_power_control_common_t   *p_ul_power_control_info)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(ul_power_control_alpha_info)
    {
        case RRM_OAM_AL_0:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0;
            break;
        case RRM_OAM_AL_0_4:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0_4;
            break;
        case RRM_OAM_AL_0_5:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0_5;
            break;
        case RRM_OAM_AL_0_6:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0_6;
            break;
        case RRM_OAM_AL_0_7:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0_7;
            break;
        case RRM_OAM_AL_0_8:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0_8;
            break;
        case RRM_OAM_AL_0_9:
            p_ul_power_control_info->alpha = RRM_RRC_AL_0_9;
            break;
        case RRM_OAM_AL_1:
            p_ul_power_control_info->alpha = RRM_RRC_AL_1;
            break;
        default :
            p_ul_power_control_info->alpha = ul_power_control_alpha_info; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for alpha = %u",
                    ul_power_control_alpha_info);
            ret_val = RRM_FAILURE;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_info
 *   INPUT         : delta_f_pucch_format_one_info
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_info(
        rrmc_delta_f_pucch_format_one_et  delta_f_pucch_format_one_info,
        uplink_power_control_common_t *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_one_info)
    {
        case RRMC_DELTAF_NEG_TWO:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one = RRM_RRC_DELTAF_NEG_TWO;
            break;
        case RRMC_DELTAF_ZERO:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one = RRM_RRC_DELTAF_ZERO;
            break;
        case RRMC_DELTAF_POS_TWO:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one = RRM_RRC_DELTAF_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one = delta_f_pucch_format_one_info;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_one = %u",
                    p_ul_power_control_info->delta_f_list_pucch.delta_f_pucch_format_one);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/ 

    RRM_UT_TRACE_EXIT();
    return ret_val;
} 

/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_1b_info
 *   INPUT         : delta_f_pucch_format_1b_val
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 1b Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_1b_info(
        rrmc_delta_f_pucch_format_one_b_et  delta_f_pucch_format_1b_val,
        uplink_power_control_common_t       *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_1b_val)
    {
        case RRMC_DELTA_F1:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = RRM_RRC_DELTA_F1;
            break;
        case RRMC_DELTA_F3:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = RRM_RRC_DELTA_F3;
            break;
        case RRMC_DELTA_F5:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = RRM_RRC_DELTA_F5;
            break;

        default :
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = delta_f_pucch_format_1b_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_one_b = %u",
                    p_ul_power_control_info->delta_f_list_pucch.delta_f_pucch_format_one_b);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_2_info
 *   INPUT         : delta_f_pucch_format_2_val
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2 Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_2_info(
        rrmc_delta_f_pucch_format_two_et    delta_f_pucch_format_2_val,
        uplink_power_control_common_t       *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_2_val)
    {
        case RRMC_FORMAT2_DELTA_NEG_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_NEG_TWO;
            break;
        case RRMC_FORMAT2_DELTA_ZERO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_ZERO;
            break;
        case RRMC_FORMAT2_DELTA_POS_ONE:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_POS_ONE;
            break;
        case RRMC_FORMAT2_DELTA_POS_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = delta_f_pucch_format_2_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_2 = %u",
                    p_ul_power_control_info->delta_f_pucch_format_two.delta_f_pucch_format_two);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* CA_Stage3_PUCCH_Format_Enh: Start */
/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_3_r10_info
 *   INPUT         : delta_f_pucch_format_3_r10_val
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2b info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_3_r10_info(
        rrmc_delta_f_pucch_format_three_r10_et   delta_f_pucch_format_3_r10_val,
        uplink_power_control_common_v1020_t      *p_ul_power_control_info_r10)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_3_r10_val)
    {
        case RRMC_FORMAT_3_R10_DELTA_NEG_ONE:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF_1; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_ZERO:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF0; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_POS_ONE:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF1; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_POS_TWO:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF2; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_POS_THREE:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF3; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_POS_FOUR:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF4; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_POS_FIVE:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF5; 
            break;
        case RRMC_FORMAT_3_R10_DELTA_POS_SIX:
            p_ul_power_control_info_r10->pucch_format3_r10 = DELTAF6; 
            break;
        default:
            p_ul_power_control_info_r10->pucch_format3_r10 = 
                delta_f_pucch_format_3_r10_val;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_3_r10_val = %u",
                    delta_f_pucch_format_3_r10_val);
            ret_val = RRM_FAILURE;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_1b_cs_r10_info
 *   INPUT         : delta_f_pucch_format_1b_cs_r10_val
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2b info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_1b_cs_r10_info(
        rrmc_delta_f_pucch_format_one_b_cs_r10_et  delta_f_pucch_format_1b_cs_r10_val,
        uplink_power_control_common_v1020_t        *p_ul_power_control_info_r10)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_1b_cs_r10_val)
    {
        case RRMC_FORMAT_1B_CS_R10_DELTA_POS_ONE:
            p_ul_power_control_info_r10->pucch_format1_bcs_r10 = DELTA_F1;
            break;

        case RRMC_FORMAT_1B_CS_R10_DELTA_POS_TWO:
            p_ul_power_control_info_r10->pucch_format1_bcs_r10 = DELTA_F2;
            break;

        default:
            p_ul_power_control_info_r10->pucch_format1_bcs_r10 = 
                delta_f_pucch_format_1b_cs_r10_val;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_1b_cs_r10_val = %u",
                    delta_f_pucch_format_1b_cs_r10_val);
            ret_val = RRM_FAILURE;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CA_Stage3_PUCCH_Format_Enh: End */

/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_2b_info
 *   INPUT         : delta_f_pucch_format_2b_val
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2b info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_2b_info(
        rrmc_delta_f_pucch_format_two_ab_et  delta_f_pucch_format_2b_val,
        uplink_power_control_common_t        *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_2b_val)
    {
        case RRMC_DELTA_NEG_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_NEG_TWO;
            break;
        case RRMC_DELTA_ZERO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_ZERO;
            break;
        case RRMC_DELTA_POS_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = delta_f_pucch_format_2b_val;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_two_b = %u",
                    delta_f_pucch_format_2b_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_delta_f_pucch_format_2a_info
 *   INPUT         : delta_f_pucch_format_two_ab_val
 *   OUTPUT        : *p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2a Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_delta_f_pucch_format_2a_info(
        rrmc_delta_f_pucch_format_two_ab_et delta_f_pucch_format_two_ab_val,
        uplink_power_control_common_t       *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_two_ab_val)
    {
        case RRMC_DELTA_NEG_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_NEG_TWO;
            break;
        case RRMC_DELTA_ZERO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_ZERO;
            break;
        case RRMC_DELTA_POS_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = delta_f_pucch_format_two_ab_val;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_two_a = %u",
                    delta_f_pucch_format_two_ab_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ue_timer_300_info
 *   INPUT         : timer_300_val
 *   OUTPUT        : *p_ue_timers
 *   DESCRIPTION   : This function Maps ue timer 300 info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ue_timer_300_info(
        rrm_oam_timer_300_301_et   timer_300_val,
        ue_timers_and_constants_t  *p_ue_timers)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(timer_300_val)
    {
        case RRM_OAM_TIMER_300_301_MS100:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS100;
            break;
        case RRM_OAM_TIMER_300_301_MS200:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS200;
            break;
        case RRM_OAM_TIMER_300_301_MS300:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS300;
            break;
        case RRM_OAM_TIMER_300_301_MS400:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS400;
            break;
        case RRM_OAM_TIMER_300_301_MS600:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS600;
            break;
        case RRM_OAM_TIMER_300_301_MS1000:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS1000;
            break;
        case RRM_OAM_TIMER_300_301_MS1500:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS1500;
            break;
        case RRM_OAM_TIMER_300_301_MS2000:
            p_ue_timers->timer_300 = RRM_RRC_TIMER_300_301_MS2000;
            break;

        default :
            p_ue_timers->timer_300 = timer_300_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for t300 = %u",
                    timer_300_val );
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ue_timer_310_info
 *   INPUT         : ue_timer_310_val
 *   OUTPUT        : *p_ue_timers
 *   DESCRIPTION   : This function Maps ue timer 310 info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ue_timer_310_info(
        rrm_oam_timer_310_et       ue_timer_310_val,
        ue_timers_and_constants_t  *p_ue_timers)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(ue_timer_310_val)
    {
        case RRM_OAM_TIMER_310_MS0:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS0;
            break;
        case RRM_OAM_TIMER_310_MS50:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS50;
            break;
        case RRM_OAM_TIMER_310_MS100:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS100;
            break;
        case RRM_OAM_TIMER_310_MS200:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS200;
            break;
        case RRM_OAM_TIMER_310_MS500:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS500;
            break;
        case RRM_OAM_TIMER_310_MS1000:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS1000;
            break;
        case RRM_OAM_TIMER_310_MS2000:
            p_ue_timers->timer_310 = RRM_RRC_TIMER_310_MS2000;
            break;

        default :
            p_ue_timers->timer_310 = ue_timer_310_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for t310 = %u",
                    p_ue_timers->timer_310);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ue_timer_311_info
 *   INPUT         : ue_timer_311_val
 *   OUTPUT        : *p_ue_timers
 *   DESCRIPTION   : This function Maps ue timer 311 info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ue_timer_311_info(
        rrm_oam_timer_311_et       ue_timer_311_val,
        ue_timers_and_constants_t  *p_ue_timers)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(ue_timer_311_val)
    {
        case RRM_OAM_TIMER_311_MS1000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS1000;
            break;
        case RRM_OAM_TIMER_311_MS3000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS3000;
            break;
        case RRM_OAM_TIMER_311_MS5000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS5000;
            break;
        case RRM_OAM_TIMER_311_MS10000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS10000;
            break;
        case RRM_OAM_TIMER_311_MS15000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS15000;
            break;
        case RRM_OAM_TIMER_311_MS20000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS20000;
            break;
        case RRM_OAM_TIMER_311_MS30000:
            p_ue_timers->timer_311 = RRM_RRC_TIMER_311_MS30000;
            break;
        default :
            p_ue_timers->timer_311 = ue_timer_311_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect value received for t311 = %u",
                    p_ue_timers->timer_311);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ue_constant_310_info
 *   INPUT         : ue_const_310_val
 *   OUTPUT        : *p_ue_timers
 *   DESCRIPTION   : This function Maps ue constant 310 info
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
    /*bug_12775_changes_start*/
rrm_return_et
map_ue_constant_310_info(
        /* Start fix for Coverity_ID : 69746 */
        rrm_oam_out_of_sync_n310_et ue_const_310_val,
        /* End fix for Coverity_ID : 69746 */
        ue_timers_and_constants_t  *p_ue_timers)
    /*bug_12775_changes_end*/
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(ue_const_310_val)
    {
      /* Start fix for Coverity_ID : 69746 */
      case RRM_OAM_TIMER_N310_N1:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N1;
            break;
      case RRM_OAM_TIMER_N310_N2:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N2;
            break;
      case RRM_OAM_TIMER_N310_N3:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N3;
            break;
      case RRM_OAM_TIMER_N310_N4:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N4;
            break;
      case RRM_OAM_TIMER_N310_N6:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N6;
            break;
      case RRM_OAM_TIMER_N310_N8:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N8;
            break;
      case RRM_OAM_TIMER_N310_N10:
            p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N10;
            break;
      case RRM_RRC_TIMER_N310_N20:
      	    p_ue_timers->timer_n310 = RRM_RRC_TIMER_N310_N20;
            break;
      default :
            p_ue_timers->timer_n310 = ue_const_310_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect value received for n310 = %u",
                    p_ue_timers->timer_n310);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ue_constant_311_info
 *   INPUT         : ue_const_311_val
 *   OUTPUT        : *p_ue_timers
 *   DESCRIPTION   : This function Maps ue constant 311 info
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ue_constant_311_info(
        /* Start fix for Coverity_ID : 69745 */
        rrm_oam_in_sync_n311_et   ue_const_311_val,
        /* End fix for Coverity_ID : 69745 */
        ue_timers_and_constants_t  *p_ue_timers)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(ue_const_311_val)
    {
      /* Start fix for Coverity_ID : 69745 */
        /* + coverity 110800 */
        case RRM_OAM_TIMER_N311_N1:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N1;
            break;
        }
        case RRM_OAM_TIMER_N311_N2:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N2;
            break;
        }
        case RRM_OAM_TIMER_N311_N3:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N3;
            break;
        }
        case RRM_OAM_TIMER_N311_N4:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N4;
            break;
        }
        case RRM_OAM_TIMER_N311_N5:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N5;
            break;
        }
        case RRM_OAM_TIMER_N311_N6:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N6;
            break;
        }
        case RRM_OAM_TIMER_N311_N8:
        {
            p_ue_timers->timer_n311 = (U8)RRM_RRC_TIMER_N311_N8;
            break;
      /* End fix for Coverity_ID : 69745 */
        }
        default :
        {
            p_ue_timers->timer_n311 = (U8)ue_const_311_val;
            /* - coverity 110800 */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect value received for n311 = %u",
                    p_ue_timers->timer_n311);
            ret_val = RRM_FAILURE;
            break;
        }
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_ue_timer_301_info
 *   INPUT         : timer_301_val
 *   OUTPUT        : *p_ue_timers
 *   DESCRIPTION   : This function Maps ue timer 301 info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_ue_timer_301_info(
        rrm_oam_timer_300_301_et   timer_301_val,
        ue_timers_and_constants_t  *p_ue_timers)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(timer_301_val)
    {
        case RRM_OAM_TIMER_300_301_MS100:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS100;
            break;
        case RRM_OAM_TIMER_300_301_MS200:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS200;
            break;
        case RRM_OAM_TIMER_300_301_MS300:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS300;
            break;
        case RRM_OAM_TIMER_300_301_MS400:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS400;
            break;
        case RRM_OAM_TIMER_300_301_MS600:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS600;
            break;
        case RRM_OAM_TIMER_300_301_MS1000:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS1000;
            break;
        case RRM_OAM_TIMER_300_301_MS1500:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS1500;
            break;
        case RRM_OAM_TIMER_300_301_MS2000:
            p_ue_timers->timer_301 = RRM_RRC_TIMER_300_301_MS2000;
            break;

        default :
            p_ue_timers->timer_301 = timer_301_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for t301 = %u",
                    timer_301_val );
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_start*/
rrm_return_et
map_q_hyst_info_lower_range
(
 rrm_oam_q_hyst_et          q_hyst_val,
 rrc_rrm_cell_setup_req_t   *rrc_rrm_cell_setup_req
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(q_hyst_val)
    { 
        case RRM_OAM_Q_HYST_DB0:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB0;
            break;
        case RRM_OAM_Q_HYST_DB1:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB1;
            break;
        case RRM_OAM_Q_HYST_DB2:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB2;
            break;
        case RRM_OAM_Q_HYST_DB3:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB3;
            break;
        case RRM_OAM_Q_HYST_DB4:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB4;
            break;
        case RRM_OAM_Q_HYST_DB5:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB5;
            break;
        case RRM_OAM_Q_HYST_DB6:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB6;
            break;
        case RRM_OAM_Q_HYST_DB8:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB8;
            break;
        default:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = q_hyst_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect q_hyst = %u", q_hyst_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
rrm_return_et
map_q_hyst_info_higher_range
(
 rrm_oam_q_hyst_et          q_hyst_val,
 rrc_rrm_cell_setup_req_t   *rrc_rrm_cell_setup_req
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(q_hyst_val)
    {
        case RRM_OAM_Q_HYST_DB10:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB10;
            break;
        case RRM_OAM_Q_HYST_DB12:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB12;
            break;
        case RRM_OAM_Q_HYST_DB14:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB14;
            break;
        case RRM_OAM_Q_HYST_DB16:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB16;
            break;
        case RRM_OAM_Q_HYST_DB18:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB18;
            break;
        case RRM_OAM_Q_HYST_DB20:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB20;
            break;
        case RRM_OAM_Q_HYST_DB22:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst =RRM_RRC_Q_HYST_DB22;
            break;
        case RRM_OAM_Q_HYST_DB24:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = RRM_RRC_Q_HYST_DB24;
            break;
        default:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                q_hyst = q_hyst_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect q_hyst = %u", q_hyst_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_end*/

/****************************************************************************
 *   FUNCTION NAME : map_q_hyst_info
 *   INPUT         : q_hyst_val
 *   OUTPUT        : *rrc_rrm_cell_setup_req
 *   DESCRIPTION   : This function Maps q hyst info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_q_hyst_info(
        rrm_oam_q_hyst_et          q_hyst_val,
        rrc_rrm_cell_setup_req_t   *rrc_rrm_cell_setup_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /*klock_works_changes_start*/
    if(q_hyst_val<=RRM_OAM_Q_HYST_DB8)
    {
        ret_val=map_q_hyst_info_lower_range(q_hyst_val, rrc_rrm_cell_setup_req);
    }
    else
    {
        ret_val=map_q_hyst_info_higher_range(q_hyst_val, rrc_rrm_cell_setup_req);
    }    
    /*klock_works_changes_end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_t_evaluation_info
 *   INPUT         : t_evaluation_val
 *   OUTPUT        : *rrc_rrm_cell_setup_req
 *   DESCRIPTION   : This function Maps t evaluation value
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_t_evaluation_info(
        rrm_oam_t_evaluation_et     t_evaluation_val,
        rrc_rrm_cell_setup_req_t   *rrc_rrm_cell_setup_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(t_evaluation_val)
    {
        case RRM_OAM_T_EVAL_S_30:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_30;
            break;
        case RRM_OAM_T_EVAL_S_60:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_60;
            break;
        case RRM_OAM_T_EVAL_S_120:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_120;
            break;
        case RRM_OAM_T_EVAL_S_180:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_180;
            break;

            /* LTE_RRM_MALL, CID 11123 */
        case RRM_OAM_T_EVAL_S_240:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_240;
            /* Fix for Coverity, LTE_RRM_MALL:CID:11123 [Prasant] */
            break;
        default:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_evaluation = t_evaluation_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect t_evaluation = %u", t_evaluation_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_t_hyst_normal_info
 *   INPUT         : t_hyst_normal_val
 *   OUTPUT        : *rrc_rrm_cell_setup_req
 *   DESCRIPTION   : This function Maps t hyst normal info
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_t_hyst_normal_info(
        rrm_oam_t_hyst_normal_et    t_hyst_normal_val,
        rrc_rrm_cell_setup_req_t    *rrc_rrm_cell_setup_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(t_hyst_normal_val)
    {
        case RRM_OAM_T_HYST_NORMAL_S_30:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_30;
            break;
        case RRM_OAM_T_HYST_NORMAL_S_60:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_60;
            break;
        case RRM_OAM_T_HYST_NORMAL_S_120:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_120;
            break;
        case RRM_OAM_T_HYST_NORMAL_S_180:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_180;
            break;
        case RRM_OAM_T_HYST_NORMAL_S_240:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_240;
            break;

        default:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.mobility_state_params.t_hyst_normal = t_hyst_normal_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect t_hyst_normal = %u", t_hyst_normal_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_q_hyst_sf_medium_info
 *   INPUT         : q_hyst_sf_val
 *   OUTPUT        : *rrc_rrm_cell_setup_req
 *   DESCRIPTION   : This function Maps Q hyst sf medium info
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_q_hyst_sf_medium_info(
        rrm_oam_q_hyst_sf_et        q_hyst_sf_val,  
        rrc_rrm_cell_setup_req_t    *rrc_rrm_cell_setup_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(q_hyst_sf_val)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_medium = RRM_RRC_Q_HYST_NEG_SIX;
            break;
        case RRM_OAM_Q_HYST_NEG_FOUR:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_medium = RRM_RRC_Q_HYST_NEG_FOUR;
            break;
        case RRM_OAM_Q_HYST_NEG_TWO:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_medium = RRM_RRC_Q_HYST_NEG_TWO;
            break;
        case RRM_OAM_Q_HYST_ZERO:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_medium = RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_medium = q_hyst_sf_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect speed_state_params.q_hyst_sf_medium = %u", q_hyst_sf_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_q_hyst_sf_high_info
 *   INPUT         : q_hyst_sf_high_val
 *   OUTPUT        : *rrc_rrm_cell_setup_req
 *   DESCRIPTION   : This function Maps Q hyst sf hidh value.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_q_hyst_sf_high_info(
        rrm_oam_q_hyst_sf_et       q_hyst_sf_high_val,
        rrc_rrm_cell_setup_req_t   *rrc_rrm_cell_setup_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(q_hyst_sf_high_val)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_high = RRM_RRC_Q_HYST_NEG_SIX;
            break;
        case RRM_OAM_Q_HYST_NEG_FOUR:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_high = RRM_RRC_Q_HYST_NEG_FOUR;
            break;
        case RRM_OAM_Q_HYST_NEG_TWO:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_high = RRM_RRC_Q_HYST_NEG_TWO;
            break;
        case RRM_OAM_Q_HYST_ZERO:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_high = RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
                speed_depend_reselect.speed_depend_scaling_param_hyst.\
                q_hyst_sf_high = q_hyst_sf_high_val;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect speed_state_params.q_hyst_sf_high = %u",
                    q_hyst_sf_high_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME : map_intra_freq_q_offset_info
 *   INPUT         : q_offset_range_val
 *   OUTPUT        : *q_offset
 *   DESCRIPTION   : This function Maps q offset range value.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_intra_freq_q_offset_info(
        rrm_oam_q_offset_range_et  q_offset_range_val,
        U8                         *q_offset)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(q_offset_range_val)
    {
        case RRM_OAM_Q_OFFESET_RANGE_DB_24:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_24;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_22:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_22;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_20:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_20;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_18:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_18;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_16:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_16;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_14:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_14;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_12:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_12;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_10:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_10;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_8:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_8;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_6:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_6;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_5:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_5;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_4:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_4;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_3:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_3;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_2:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_2;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB_1:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB_1;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB0:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB0;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB1:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB1;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB2:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB2;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB3:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB3;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB4:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB4;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB5:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB5;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB6:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB6;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB8:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB8;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB10:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB10;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB12:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB12;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB14:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB14;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB16:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB16;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB18:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB18;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB20:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB20;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB22:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB22;
            break;
        case RRM_OAM_Q_OFFESET_RANGE_DB24:
            *q_offset = RRM_RRC_Q_OFFESET_RANGE_DB24;
            break;

        default:
            *q_offset =  q_offset_range_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Unexpected value for .q_offset_cell = %u", q_offset_range_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/

/****************************************************************************
 *   FUNCTION NAME       :   preambles_group_a_config
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_preamble_group_a
 *   DESCRIPTION :
 *    		This function Maps the preambles group a config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et preambles_group_a_config(
        rrm_cell_context_t         *cell_context, 
        preambles_group_a_config_t *p_preamble_group_a)
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
    /* mapping ra preambles group a size */ 
    ret_val = map_ra_preambles_group_a_size_info(cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.
            ra_preamble_groupA_info.size_of_ra_group_a, 
            p_preamble_group_a); 
    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/


    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
    /* mapping message size group a*/
    /* Coverity 74896 Fix Start */
    if(ret_val != RRM_FAILURE)
    {
        ret_val = map_message_size_group_a_info(cell_context->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.
                ra_preamble_groupA_info.message_size_group_a, 
                p_preamble_group_a);
    }
    /* Coverity 74896 Fix End */
    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/


    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
    /* mapping message power offset group b*/
    /* Coverity 74896 Fix Start */
    if(ret_val != RRM_FAILURE)
    {
        ret_val = map_group_b_msg_power_offset_val(cell_context->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.
                ra_preamble_groupA_info.message_power_offset_group_b,
                p_preamble_group_a); 
    }
    /* Coverity 74896 Fix End */
    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   power_ramping_params
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_power_ramping_params
 *   DESCRIPTION :
 *          This function Maps the power ramping params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
rrm_power_ramping_params_preamble(rrm_cell_context_t      *cell_context,
        power_ramping_params_t  *p_power_ramping_params )
{

    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    switch(cell_context->ran_info.mac_layer_params.mac_layer_param_rach.\
            preamble_initial_received_target_power)
    {
        case RRM_OAM_PREAMBLE_POWER_DBM_120:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_120;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_118:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_118;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_116:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_116;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_114:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_114;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_112:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_112;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_110:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_110;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_108:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_108;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_106:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_106;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_104:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_104;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_102:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_102;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_100:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_100;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_98:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_98;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_96:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_96;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_94:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_94;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_92:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_92;
            break;
        case RRM_OAM_PREAMBLE_POWER_DBM_90:
            p_power_ramping_params->preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_90;
            break;
        default:
            p_power_ramping_params->preamble_init_rec_target_pow =
                cell_context->ran_info.mac_layer_params.mac_layer_param_rach.
                preamble_initial_received_target_power;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for "\
                    "preamble_initial_received_target_power= %u",
                    cell_context->ran_info.mac_layer_params.mac_layer_param_rach.
                    preamble_initial_received_target_power);
            ret_val = RRM_FAILURE;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/****************************************************************************
 *   FUNCTION NAME       :   power_ramping_params
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_power_ramping_params
 *   DESCRIPTION :
 *    		This function Maps the power ramping params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
power_ramping_params
(
 rrm_cell_context_t     *cell_context, 
 power_ramping_params_t *p_power_ramping_params
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(cell_context->ran_info.mac_layer_params.mac_layer_param_rach.\
            power_ramping_step)
    {
        case RRM_OAM_POWER_RAMP_STEP_DB0:
            p_power_ramping_params->power_ramping_step = RRM_RRC_POWER_RAMP_STEP_DB0;
            break;
        case RRM_OAM_POWER_RAMP_STEP_DB2:
            p_power_ramping_params->power_ramping_step = RRM_RRC_POWER_RAMP_STEP_DB2;
            break;
        case RRM_OAM_POWER_RAMP_STEP_DB4:
            p_power_ramping_params->power_ramping_step = RRM_RRC_POWER_RAMP_STEP_DB4;
            break;
        case RRM_OAM_POWER_RAMP_STEP_DB6:
            p_power_ramping_params->power_ramping_step = RRM_RRC_POWER_RAMP_STEP_DB6;
            break;
        default:
            p_power_ramping_params->power_ramping_step = 
                cell_context->ran_info.mac_layer_params.mac_layer_param_rach.
                power_ramping_step;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for power_ramping_step = %u",
                    cell_context->ran_info.mac_layer_params.mac_layer_param_rach.
                    power_ramping_step);
            ret_val = RRM_FAILURE;
            break;
    }

    /*Klockwork_fix_start*/
    ret_val = rrm_power_ramping_params_preamble(cell_context ,p_power_ramping_params);
    /*Klockwork_fix_end*/


    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   ra_supervision_info
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_ra_supervision_info
 *   DESCRIPTION :
 *    		This function Maps the ra supervision info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
ra_supervision_info(
        rrm_cell_context_t    *cell_context, 
        ra_supervision_info_t *p_ra_supervision_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
    ret_val = map_preamble_trans_max_info(
            cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_trans_max, 
            p_ra_supervision_info); 

    ret_val = map_response_window_size_info(
            cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.response_window_size, 
            p_ra_supervision_info);

    ret_val = map_mac_contention_resolution_timer_info(
            cell_context->ran_info.mac_layer_params.mac_layer_param_rach.
            contention_resolution_timer, 
            p_ra_supervision_info);
    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   bcch_config
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_bcch_config_info
 *   DESCRIPTION :
 *    		This function Maps the bcch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
bcch_config
(
 rrm_cell_context_t *cell_context, 
 bcch_config_t      *p_bcch_config_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        switch(cell_context->operator_info.sib_2_info.\
                radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff)
        {
            case RRM_OAM_MOD_PERIOD_COEFF_N2:
                p_bcch_config_info->mod_period_coeff = RRM_RRC_MOD_PERIOD_COEFF_N2;
                break;
            case RRM_OAM_MOD_PERIOD_COEFF_N4:
                p_bcch_config_info->mod_period_coeff = RRM_RRC_MOD_PERIOD_COEFF_N4;
                break;
            case RRM_OAM_MOD_PERIOD_COEFF_N8:
                p_bcch_config_info->mod_period_coeff = RRM_RRC_MOD_PERIOD_COEFF_N8;
                break;
            case RRM_OAM_MOD_PERIOD_COEFF_N16:
                p_bcch_config_info->mod_period_coeff = RRM_RRC_MOD_PERIOD_COEFF_N16;
                break;
            default :
                p_bcch_config_info->mod_period_coeff = cell_context->operator_info.sib_2_info.\
                                                       radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for mod_period_coeff = %u",
                        cell_context->operator_info.sib_2_info.\
                        radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff);
                ret_val = RRM_FAILURE;
                break;
        }
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   rrm_pcch_config_nB
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_pcch_config_info
 *   DESCRIPTION :
 *          This function Maps the pcch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
rrm_pcch_config_nB(rrm_cell_context_t *cell_context,
        pcch_config_t      *p_pcch_config_info )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    switch(cell_context->operator_info.sib_2_info.\
            radio_res_config_common_sib.rrm_pcch_config.nB)
    {
        case RRM_OAM_NB_FOUR_T:
            p_pcch_config_info->nb = RRM_RRC_NB_FOUR_T;
            break;
        case RRM_OAM_NB_TWO_T:
            p_pcch_config_info->nb = RRM_RRC_NB_TWO_T;
            break;
        case RRM_OAM_NB_ONE_T:
            p_pcch_config_info->nb = RRM_RRC_NB_ONE_T;
            break;
        case RRM_OAM_NB_HALF_T:
            p_pcch_config_info->nb = RRM_RRC_NB_HALF_T;
            break;
        case RRM_OAM_NB_QUARTER_T:
            p_pcch_config_info->nb = RRM_RRC_NB_QUARTER_T;
            break;
        case RRM_OAM_NB_ONE_EIGHTH_T:
            p_pcch_config_info->nb = RRM_RRC_NB_ONE_EIGHTH_T;
            break;
        case RRM_OAM_NB_ONE_SIXTEENTH_T:
            p_pcch_config_info->nb = RRM_RRC_NB_ONE_SIXTEENTH_T;
            break;
        case RRM_OAM_NB_ONE_THIRTY_SECOND_T:
            p_pcch_config_info->nb = RRM_RRC_NB_ONE_THIRTY_SECOND_T;
            break;
        default :
            p_pcch_config_info->nb = cell_context->operator_info.sib_2_info.\
                                     radio_res_config_common_sib.rrm_pcch_config.nB;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for nb = %u",
                    cell_context->operator_info.sib_2_info.\
                    radio_res_config_common_sib.rrm_pcch_config.nB);
            ret_val = RRM_FAILURE;
            break;
    }
    /*Cov_fix_start_65047*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /* Cov_fix_end_65047*/
}
/*Klockwork_fix_end*/
/****************************************************************************
 *   FUNCTION NAME       :   pcch_config
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_pcch_config_info
 *   DESCRIPTION :
 *    		This function Maps the pcch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
pcch_config
(
 rrm_cell_context_t *cell_context, 
 pcch_config_t      *p_pcch_config_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        switch(cell_context->operator_info.\
                sib_2_info.radio_res_config_common_sib.rrm_pcch_config.\
                default_paging_cycle)
        {
            case RRM_OAM_DEF_PAG_CYCLE_RF32:
                p_pcch_config_info->default_paging_cycle = RRM_RRC_DEF_PAG_CYCLE_RF32;
                break;
            case RRM_OAM_DEF_PAG_CYCLE_RF64:
                p_pcch_config_info->default_paging_cycle = RRM_RRC_DEF_PAG_CYCLE_RF64;
                break;
            case RRM_OAM_DEF_PAG_CYCLE_RF128:
                p_pcch_config_info->default_paging_cycle = RRM_RRC_DEF_PAG_CYCLE_RF128;
                break;
            case RRM_OAM_DEF_PAG_CYCLE_RF256:
                p_pcch_config_info->default_paging_cycle = RRM_RRC_DEF_PAG_CYCLE_RF256;
                break;
            default :
                p_pcch_config_info->default_paging_cycle = cell_context->operator_info.\
                                                           sib_2_info.radio_res_config_common_sib.rrm_pcch_config.\
                                                           default_paging_cycle;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                        " default_paging_cycle = %u",
                        cell_context->operator_info.\
                        sib_2_info.radio_res_config_common_sib.rrm_pcch_config.\
                        default_paging_cycle);
                ret_val = RRM_FAILURE;
                break;
        }
        /*Klockwork_fix_start*/
        ret_val = rrm_pcch_config_nB(cell_context ,p_pcch_config_info );
        /*Klockwork_fix_end*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   prach_config_sib
 *   INPUT       : *cell_context
 *   OUTPUT      : *p_prach_config_info
 *   DESCRIPTION :
 *    		This function Maps the prach config sib params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
prach_config_sib
(
 rrm_cell_context_t *cell_context, 
 prach_config_sib_t *p_prach_config_info 
 )
{
    RRM_UT_TRACE_ENTER();

    if( cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)
    {
        p_prach_config_info->root_seq_index = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_prach.root_sequence_index;

        p_prach_config_info->prach_config_info.prach_config_index = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_prach.configuration_index;

        p_prach_config_info->prach_config_info.high_speed_flag = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_prach.high_speed_flag;

        p_prach_config_info->prach_config_info.zero_cor_zone_config =
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_prach.zero_correlation_zone_config;

        p_prach_config_info->prach_config_info.prach_freq_offset= 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_prach.frequency_offset;
    }
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   pdsch_config_common
 *   INPUT       : cell_context
 *   OUTPUT      : p_pdsch_config_info
 *   DESCRIPTION :
 *    		This function Maps the pdsch config common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
pdsch_config_common
(
 rrm_cell_context_t    *cell_context, 
 pdsch_config_common_t *p_pdsch_config_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT)
    {
        p_pdsch_config_info->ref_signal_power = 
            cell_context->ran_info.rf_params.rf_configurations.reference_signal_power;
    }

    if( cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)
    {
        switch(cell_context->ran_info.physical_layer_params.\
                physical_layer_param_pdsch.p_b)
        {
            case RRM_OAM_PB0:
                p_pdsch_config_info->pb = RRM_OAM_PB0;
                break;
            case RRM_OAM_PB1:
                p_pdsch_config_info->pb = RRM_OAM_PB1;
                break;
            case RRM_OAM_PB2:
                p_pdsch_config_info->pb = RRM_OAM_PB2;
                break;
            case RRM_OAM_PB3:
                p_pdsch_config_info->pb = RRM_OAM_PB3;
                break;
            default :
                p_pdsch_config_info->pb = cell_context->ran_info.physical_layer_params.\
                                          physical_layer_param_pdsch.p_b;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for p_b = %u",
                        cell_context->ran_info.physical_layer_params.\
                        physical_layer_param_pdsch.p_b);
                ret_val = RRM_FAILURE;
                break;
        }
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   pusch_config_common
 *   INPUT       : cell_context
 *   OUTPUT      : p_pusch_config_info
 *   DESCRIPTION :
 *    		This function Maps the pusch config common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
pusch_config_common
(
 rrm_cell_context_t    *cell_context, 
 pusch_config_common_t *p_pusch_config_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    pusch_config_basic(cell_context,
            &(p_pusch_config_info->pusch_config_basic));

    ul_ref_signals_pusch(cell_context,
            &(p_pusch_config_info->ul_ref_signals_pusch));
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   pusch_config_basic
 *   INPUT       : cell_context
 *   OUTPUT      : p_pusch_basic_config
 *   DESCRIPTION :
 *    		This function Maps the pusch config basic params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
pusch_config_basic
(
 rrm_cell_context_t   *cell_context, 
 pusch_config_basic_t *p_pusch_basic_config
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)
    {
        p_pusch_basic_config->nsb = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_pusch.n_sb;

        switch(cell_context->ran_info.physical_layer_params.
                physical_layer_param_pusch.pusch_hopping_mode)
        {
            case RRM_OAM_HM_INTER_SF:
                p_pusch_basic_config->hopping_mode = RRM_RRC_HM_INTER_SF;
                break;
            case RRM_OAM_HM_INTRA_AND_INTER_SF:
                p_pusch_basic_config->hopping_mode = RRM_RRC_HM_INTRA_AND_INTER_SF;
                break;
            default :
                p_pusch_basic_config->hopping_mode = cell_context->ran_info.physical_layer_params.
                    physical_layer_param_pusch.pusch_hopping_mode;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for pusch_hopping_mode = %u",
                        cell_context->ran_info.physical_layer_params.
                        physical_layer_param_pusch.pusch_hopping_mode);
                ret_val = RRM_FAILURE;
                break;
        }

        p_pusch_basic_config->pusch_hopping_offset = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_pusch.hopping_offset;

        p_pusch_basic_config->enable_64_qam = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_pusch.enable_64_qam;

    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   ul_ref_signals_pusch
 *   INPUT       : cell_context
 *   OUTPUT      : p_ul_ref_signal_info
 *   DESCRIPTION :
 *    		This function Maps the ul ref signals pusch params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
ul_ref_signals_pusch
(
 rrm_cell_context_t     *cell_context, 
 ul_ref_signals_pusch_t *p_ul_ref_signal_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if( cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)
    {
        switch(cell_context->ran_info.physical_layer_params.
                physical_layer_param_ul_reference_signal.group_hopping_enabled)
        {
            case RRM_TRUE:
                p_ul_ref_signal_info->group_hopping_enabled = RRC_TRUE;
                break;
            case RRM_FALSE:
                p_ul_ref_signal_info->group_hopping_enabled = RRC_FALSE;
                break;
            default :
                p_ul_ref_signal_info->group_hopping_enabled = cell_context->ran_info.physical_layer_params.
                    physical_layer_param_ul_reference_signal.group_hopping_enabled;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for group_hopping_enabled = %u",
                        cell_context->ran_info.physical_layer_params.
                        physical_layer_param_ul_reference_signal.group_hopping_enabled);
                ret_val = RRM_FAILURE;
                break;
        }

        p_ul_ref_signal_info->group_assign_pusch = 
            cell_context->ran_info.physical_layer_params.\
            physical_layer_param_ul_reference_signal.group_assignment_pusch;

        switch(cell_context->ran_info.physical_layer_params.
                physical_layer_param_ul_reference_signal.sequence_hopping_enabled)
        {
            case RRM_TRUE:
                p_ul_ref_signal_info->seq_hopping_enabled = RRC_TRUE;
                break;
            case RRM_FALSE:
                p_ul_ref_signal_info->seq_hopping_enabled = RRC_FALSE;
                break;
            default :
                p_ul_ref_signal_info->seq_hopping_enabled = cell_context->ran_info.physical_layer_params.
                    physical_layer_param_ul_reference_signal.sequence_hopping_enabled;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for sequence_hopping_enabled = %u",
                        cell_context->ran_info.physical_layer_params.
                        physical_layer_param_ul_reference_signal.sequence_hopping_enabled);
                ret_val = RRM_FAILURE;
                break;
        }

        p_ul_ref_signal_info->cyclic_shift = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_ul_reference_signal.cyclic_shift;

    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   pucch_config_commons
 *   INPUT       : cell_context
 *   OUTPUT      : p_pucch_config_info
 *
 *   DESCRIPTION :
 *    		This function Maps the pucch config common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
pucch_config_common
(
 rrm_cell_context_t     *cell_context, 
 pucch_config_common_t  *p_pucch_config_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if( cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)
    {
        switch(cell_context->ran_info.physical_layer_params.
                physical_layer_param_pucch.delta_pucch_shift)
        {
            case RRM_RRC_DS1:
                p_pucch_config_info->delta_pucch_shift = RRM_RRC_DS1;
                break;
            case RRM_RRC_DS2:
                p_pucch_config_info->delta_pucch_shift = RRM_RRC_DS2;
                break;
            case RRM_RRC_DS3:
                p_pucch_config_info->delta_pucch_shift = RRM_RRC_DS3;
                break;
            default :
                p_pucch_config_info->delta_pucch_shift = cell_context->ran_info.physical_layer_params.
                    physical_layer_param_pucch.delta_pucch_shift;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for delta_pucch_shift = %u",
                        cell_context->ran_info.physical_layer_params.
                        physical_layer_param_pucch.delta_pucch_shift);
                ret_val = RRM_FAILURE;
                break;
        }

        p_pucch_config_info->n_rb_cqi = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_pucch.n_rb_cqi;

        p_pucch_config_info->n_cs_an = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_pucch.n_cs_an;

        p_pucch_config_info->n_one_pucch_an = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_pucch.n1_pucch_an;

    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   sounding_rs_ul_config_common
 *   INPUT       : cell_contextcell_context
 *   OUTPUT      : p_sounding_rs_ul_info
 *
 *   DESCRIPTION :
 *    		This function Maps the sounding rs ul config common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
sounding_rs_ul_config_common(
        rrm_cell_context_t             *cell_context, 
        sounding_rs_ul_config_common_t *p_sounding_rs_ul_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_sounding_rs_ul_info->presence_bitmask = RRM_ZERO;
    if( cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT )
    {
        if (RRM_TRUE == cell_context->ran_info.physical_layer_params.
                physical_layer_param_srs.srsEnabled)
        {
            p_sounding_rs_ul_info->presence_bitmask |= 
                SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG;

            /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/ 
            /*mapping for the srs bandwidth config*/
            if(RRM_FAILURE == map_srs_bandwidth_config_info(
                        cell_context->ran_info.physical_layer_params.
                        physical_layer_param_srs.srs_bandwidth_config,
                        p_sounding_rs_ul_info))
            {
                ret_val = RRM_FAILURE;
            }
            /*mapping for the srs subframe config*/
            if(RRM_FAILURE == map_srs_subframe_config_info(
                        cell_context->ran_info.physical_layer_params.
                        physical_layer_param_srs.srs_subframe_config,
                        p_sounding_rs_ul_info))
            {
                ret_val = RRM_FAILURE;
            }
            /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
            p_sounding_rs_ul_info->setup.presence_bitmask = RRM_ZERO;
#ifdef TDD_MODE_FLAG
            if(cell_context->ran_info.physical_layer_params.physical_layer_param_srs.\
                    bitmask & RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT)
            {
                /*BUG_931_CHANGES_START*/
                p_sounding_rs_ul_info->setup.srs_max_up_pts =
                    RRM_SRS_MAX_UP_PTS_TRUE;
                p_sounding_rs_ul_info->setup.presence_bitmask |=
                    SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG;
            }
            /*BUG_931_CHANGES_START*/
#endif
            switch(cell_context->ran_info.physical_layer_params.physical_layer_param_srs.\
                    ack_nack_srs_simultaneous_transmission)
            {
                case RRM_TRUE :
                    p_sounding_rs_ul_info->setup.ack_nack_srs_simul_trans = RRC_TRUE;
                    break;
                case RRM_FALSE :
                    p_sounding_rs_ul_info->setup.ack_nack_srs_simul_trans = RRC_FALSE;
                    break;
                default :
                    p_sounding_rs_ul_info->setup.ack_nack_srs_simul_trans = 
                        cell_context->ran_info.physical_layer_params.physical_layer_param_srs.\
                        ack_nack_srs_simultaneous_transmission;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for "\
                            "ack_nack_srs_simul_trans = %u",
                            cell_context->ran_info.physical_layer_params.physical_layer_param_srs.\
                            ack_nack_srs_simultaneous_transmission);
                    ret_val = RRM_FAILURE;
                    break;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Value received for srs_enabled = %d",
                    cell_context->ran_info.physical_layer_params.
                    physical_layer_param_srs.srsEnabled);
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* CA_Stage3_PUCCH_Format_Enh: Start */
/****************************************************************************
 *   FUNCTION NAME       :   uplink_power_control_common_r10
 *   INPUT       : cell_context
 *   OUTPUT      : p_ul_power_control_info_r10
 *   DESCRIPTION :
 *    		This function Maps the uplink power control common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
    uplink_power_control_common_r10
(rrm_cell_context_t                  *p_cell_context,
 uplink_power_control_common_v1020_t *p_ul_power_control_info_r10)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if((p_cell_context->operator_info.bitmask & RRM_RRM_OPERATOR_UL_PWR_CTRL) &&
            (p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.bitmask &
             RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT))
    {   
        if( map_delta_f_pucch_format_3_r10_info( p_cell_context->operator_info.
                    rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_3_r10, 
                    p_ul_power_control_info_r10) == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to Map delta_f_pucch_format_3_r10");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        if( map_delta_f_pucch_format_1b_cs_r10_info( p_cell_context->operator_info.
                    rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b_cs_r10, 
                    p_ul_power_control_info_r10) == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to Map delta_f_pucch_format_3_r10");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "PUCCH Format R10 not supported by Cell.");
        ret_val = RRM_FAILURE;
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CA_Stage3_PUCCH_Format_Enh: End */
/****************************************************************************
 *   FUNCTION NAME       :   uplink_power_control_common
 *   INPUT       : cell_context
 *   OUTPUT      : p_ul_power_control_info
 *   DESCRIPTION :
 *    		This function Maps the uplink power control common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
uplink_power_control_common
(
 rrm_cell_context_t            *cell_context, 
 uplink_power_control_common_t *p_ul_power_control_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)
    {
        p_ul_power_control_info->p_zero_nominal_Pusch = 
            cell_context->ran_info.physical_layer_params.
            physical_layer_param_ul_power_control.p_0_nominal_pusch;


        /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
        /*mapping for ul power control alpha*/
        ret_val = map_ul_power_control_alpha_info(
                cell_context->ran_info.physical_layer_params.
                physical_layer_param_ul_power_control.alpha, 
                p_ul_power_control_info);
        /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/

        p_ul_power_control_info->p_zero_nominal_pucch = cell_context->\
                                                        ran_info.physical_layer_params.physical_layer_param_ul_power_control.\
                                                        p_0_nominal_pucch;
        /* BUG_371 FIX START */
    }
    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
        /*mapping for delta f pucch format*/
        ret_val = map_delta_f_pucch_format_info(
                cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1,
                p_ul_power_control_info);


        /*mapping for delta f pucch format 1b*/
        ret_val = map_delta_f_pucch_format_1b_info(
                cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b,
                p_ul_power_control_info);

        /*mapping for delta f pucch format 2*/
        ret_val = map_delta_f_pucch_format_2_info(
                cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2,
                p_ul_power_control_info); 

        /*mapping for delta f pucch format 2a*/
        ret_val = map_delta_f_pucch_format_2a_info(
                cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a,
                p_ul_power_control_info);

        /*mapping for delta f pucch format 2b*/
        ret_val = map_delta_f_pucch_format_2b_info(
                cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b,
                p_ul_power_control_info);
        /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/ 

        p_ul_power_control_info->delta_preamble_msg_three= 
            cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_preamble_msg_3;
    }
    /* BUG_371 FIX END */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   ue_timers_and_constants
 *   INPUT       : cell_context
 *   OUTPUT      : p_ue_timers
 *   DESCRIPTION :
 *    		This function Maps the ue timers and constant params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
ue_timers_and_constants
(
 rrm_cell_context_t        *cell_context, 
 ue_timers_and_constants_t *p_ue_timers
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if( cell_context->ran_info.bitmask & RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT)
    {
        /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
        /* mapping ue timer 300 info*/
        ret_val = map_ue_timer_300_info(
                cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t300,
                p_ue_timers);

        /* mapping ue timer 301 info*/
        ret_val = map_ue_timer_301_info(
                cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t301,
                p_ue_timers);

        /* mapping ue timer 311 info*/
        ret_val = map_ue_timer_311_info(
                cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t311,
                p_ue_timers);

        /* mapping ue timer 310 info*/
        ret_val = map_ue_timer_310_info(
                cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t310,
                p_ue_timers);

        /* mapping ue constant 310 info*/
        ret_val = map_ue_constant_310_info(
                cell_context->ran_info.rrc_timers_and_constants.rrc_constants.n310,
                p_ue_timers);

        /* mapping ue constant 311 info*/
        ret_val = map_ue_constant_311_info(
                cell_context->ran_info.rrc_timers_and_constants.rrc_constants.n311,
                p_ue_timers);
        /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   freq_info
 *   INPUT       : cell_context
 *   OUTPUT      : p_freq_info
 *   DESCRIPTION :
 *    		This function Maps the frequency info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
freq_info
(
 rrm_cell_context_t *cell_context, 
 freq_info_t        *p_freq_info
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /*bitmask*/
    p_freq_info->presence_bitmask = RRM_ZERO;

    /* Bug 602 Fix Start */
#ifndef TDD_MODE_FLAG 
    if( cell_context->ran_info.rf_params.rf_configurations.bitmask & 
            RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT)
    {
        p_freq_info->presence_bitmask |= FREQ_INFO_UL_BW_PRESENCE_FLAG;
        switch(cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth)
        {
            case RRM_OAM_BW_N_6:
                p_freq_info->ul_bandwidth = RRM_RRC_UL_BW_6RB;
                break;
            case RRM_OAM_BW_N_15:
                p_freq_info->ul_bandwidth = RRM_RRC_UL_BW_15RB;
                break;
            case RRM_OAM_BW_N_25:
                p_freq_info->ul_bandwidth = RRM_RRC_UL_BW_25RB;
                break;
            case RRM_OAM_BW_N_50:
                p_freq_info->ul_bandwidth = RRM_RRC_UL_BW_50RB;
                break;
            case RRM_OAM_BW_N_75:
                p_freq_info->ul_bandwidth = RRM_RRC_UL_BW_75RB;
                break;
            case RRM_OAM_BW_N_100:
                p_freq_info->ul_bandwidth = RRM_RRC_UL_BW_100RB;
                break;
            default :
                p_freq_info->ul_bandwidth = 
                    cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                        " ul_bandwidth = %u",
                        cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth);
                ret_val = RRM_FAILURE;
                break;
        }
    }
#endif
    /* Bug 602 Fix End */
    if(cell_context->operator_info.sib_2_info.rrm_freq_info.bitmask & \
            RRMCM_RMIF_UL_CARRIER_FREQ_PRESENT)
    {
        p_freq_info->presence_bitmask |= FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG;

        p_freq_info->ul_carrier_freq = 
            cell_context->operator_info.sib_2_info.rrm_freq_info.\
            ul_carrier_freq;		/*optional: dont fill, Nupur*/
    }
    p_freq_info->add_spectrum_emission = 
        cell_context->operator_info.sib_2_info.rrm_freq_info.\
        additional_spectrum_emission;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME       :   sib3_intra_search_v920
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *           This function Maps the sib3 intra search v920 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
sib3_intra_search_v920
(
 rrm_cell_context_t *cell_context,
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_setup_req->sib_type_3_Info.sib3_intra_search_v920.s_intra_search_p_r9 = 
        cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_p_r9;
    rrc_rrm_cell_setup_req->sib_type_3_Info.sib3_intra_search_v920.s_intra_search_q_r9 = 
        cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   sib3_non_intra_search_v920
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *           This function Maps the sib3 non intra search v920 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
sib3_non_intra_search_v920
(
 rrm_cell_context_t *cell_context,
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_setup_req->sib_type_3_Info.sib3_non_intra_search_v920.
        s_non_intra_search_p_r9 = 
        cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_p_r9;
    rrc_rrm_cell_setup_req->sib_type_3_Info.sib3_non_intra_search_v920.
        s_non_intra_search_q_r9 = 
        cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_3
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the sib type 3 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_3
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_setup_req->presence_bitmask |= \
                                                CELL_SETUP_REQ_API_SIB_3_INFO_PRESENCE_FLAG;

    rrc_rrm_cell_setup_req->sib_type_3_Info.presence_bitmask = RRM_ZERO;
    if(RRM_FAILURE == timecell_reselect_info_comm(cell_context,rrc_rrm_cell_setup_req))
    {
        ret_val = RRM_FAILURE;
    }
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    cell_reselect_serv_freq_info(cell_context,rrc_rrm_cell_setup_req);

    intra_freq_cell_reselect_info(cell_context,rrc_rrm_cell_setup_req);
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    if(cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT)
    {
        sib3_intra_search_v920(cell_context, rrc_rrm_cell_setup_req);
        rrc_rrm_cell_setup_req->sib_type_3_Info.presence_bitmask |= SIB_3_INTRA_SEARCH_V920_PRESENCE_FLAG;
    }

    if(cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT)
    {
        sib3_non_intra_search_v920(cell_context, rrc_rrm_cell_setup_req);
        rrc_rrm_cell_setup_req->sib_type_3_Info.presence_bitmask |= SIB_3_NON_INTRA_SEARCH_V920_PRESENCE_FLAG;
    }

    if(cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1)
    {
        rrc_rrm_cell_setup_req->sib_type_3_Info.q_qual_min_r9 = cell_context->operator_info.sib_3_info.q_qual_min_r9;
        rrc_rrm_cell_setup_req->sib_type_3_Info.presence_bitmask |= SIB_3_Q_QUAL_MIN_R9_PRESENCE_FLAG;
    }

    if(cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
    {
        rrc_rrm_cell_setup_req->sib_type_3_Info.thresh_serving_low_q_r9 = cell_context->operator_info.sib_3_info.thresh_serving_lowq_r9;
        rrc_rrm_cell_setup_req->sib_type_3_Info.presence_bitmask |= SIB_3_THRESH_SERVING_LOW_Q_R9_PRESENCE_FLAG;
    }
    /* SPR 21251 +- */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   timecell_reselect_info_comm
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the timecall reselect info comm  params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
timecell_reselect_info_comm
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* BLR start */
    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
    ret_val = map_q_hyst_info(
            cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst,
            rrc_rrm_cell_setup_req);

    /* SPR 14648 Fix Start */
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_q_hyst_info");
        RRM_UT_TRACE_EXIT();
        return ret_val;
    }
    /* SPR 14648 Fix End */

    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
    /* BLR: Changes end */				
    rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
        presence_bitmask = RRM_ZERO;
    if (cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
            idle_mode_mobility_common_params.bitmask & 
            RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT)
    {
        /* set the bit mask */
        rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
            presence_bitmask |= CELL_RESELECT_SPEED_DEPEND_RESELECT_PRESENCE_FLAG;

        /* BLR: Changes Start */
        /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
        ret_val = map_t_evaluation_info(
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_common_params.speed_state_params.t_evaluation,
                rrc_rrm_cell_setup_req);


        /* SPR 14648 Fix Start */
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                    "Failure returned from map_t_evaluation_info");
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /* SPR 14648 Fix End */

        ret_val = map_t_hyst_normal_info(
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_common_params.speed_state_params.t_hyst_normal, 
                rrc_rrm_cell_setup_req);

        /* SPR 14648 Fix Start */
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                    "Failure returned from map_t_hyst_normal_info");
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /* SPR 14648 Fix End */
        /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
        /* BLR: Changes end */			

        rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
            speed_depend_reselect.mobility_state_params.n_cell_change_medium\
            = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_common_params.\
            speed_state_params.n_cell_change_medium;

        rrc_rrm_cell_setup_req->sib_type_3_Info.timecell_reselect_info_comm.\
            speed_depend_reselect.mobility_state_params.n_cell_change_high\
            = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_common_params.\
            speed_state_params.n_cell_change_high;
    }

    /* BLR START */
    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
    ret_val = map_q_hyst_sf_medium_info(
            cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_medium,
            rrc_rrm_cell_setup_req);

    /* SPR 14648 Fix Start */
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_q_hyst_sf_medium_info");
        RRM_UT_TRACE_EXIT();
        return ret_val;
    }
    /* SPR 14648 Fix End */

    ret_val = map_q_hyst_sf_high_info(
            cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_high,
            rrc_rrm_cell_setup_req);

    /* SPR 14648 Fix Start */
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_q_hyst_sf_high_info");
    }
    /* SPR 14648 Fix End */

    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
    /*BLR END */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   cell_reselect_serv_freq_info
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the cell reselect serving freq info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
cell_reselect_serv_freq_info
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    RRM_UT_TRACE_ENTER();

    /*bitmask*/
    if( cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT)
    {
        if(cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_intra_freq_params.bitmask & \
                RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT)
        {
            rrc_rrm_cell_setup_req->sib_type_3_Info.cell_reselect_serv_freq_info.\
                presence_bitmask |= CELL_RESELECT_NON_INTRA_SEARCH_PRESENCE_FLAG;

            rrc_rrm_cell_setup_req->sib_type_3_Info.cell_reselect_serv_freq_info.\
                s_non_intra_search = cell_context->ran_info.mobility_params.\
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
                s_non_intra_search;
        }
        rrc_rrm_cell_setup_req->sib_type_3_Info.cell_reselect_serv_freq_info.\
            thresh_serving_low = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            thresh_serving_low;

        rrc_rrm_cell_setup_req->sib_type_3_Info.cell_reselect_serv_freq_info.\
            cell_reselect_priority = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            cell_reselection_priority;
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   intra_freq_cell_reselect_info
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the intra freq cell reselect info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
intra_freq_cell_reselect_info
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    rrm_return_et       ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /*bitmask*/
    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
        q_rx_lev_min = 
        cell_context->ran_info.mobility_params.\
        idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
        q_rx_lev_min_sib_3;

    if((cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_P_MAX_SIB3_PRESENT))
    {
        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            presence_bitmask |= INTRA_FREQ_CELL_RESELECT_P_MAX_PRESENCE_FLAG;

        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            p_max = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            p_max_sib_3;
    }

    if((cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_intra_freq_params.bitmask & \
                RRMCM_RMIF_S_INTRA_SEARCH_PRESENT))
    {
        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            presence_bitmask |= INTRA_FREQ_CELL_RESELECT_INTRA_SEARCH_PRESENCE_FLAG ;

        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            s_intra_search = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            s_intra_search;
    }

    /* BLR START */
    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_3_INFO_PRESENT )
    {
        if(cell_context->operator_info.sib_3_info.intra_freq_reselection_info.\
                bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT)
        {
            rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                presence_bitmask |= INTRA_FREQ_CELL_RESELECT_MEAS_BW_PRESENCE_FLAG;

            switch(cell_context->operator_info.sib_3_info.
                    intra_freq_reselection_info.measurement_bandwidth)
            {
                case RRM_OAM_BW_MEAS_N_6:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = RRM_RRC_BW_N_6;
                    break;
                case RRM_OAM_BW_MEAS_N_15:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = RRM_RRC_BW_N_15;
                    break;
                case RRM_OAM_BW_MEAS_N_25:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = RRM_RRC_BW_N_25;
                    break;
                case RRM_OAM_BW_MEAS_N_50:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = RRM_RRC_BW_N_50;
                    break;
                case RRM_OAM_BW_MEAS_N_75:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = RRM_RRC_BW_N_75;
                    break;
                case RRM_OAM_BW_MEAS_N_100:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = RRM_RRC_BW_N_100;
                    break;
                default:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.
                        intra_freq_cell_reselect_info.measure_bw = cell_context->operator_info.
                        sib_3_info.intra_freq_reselection_info.
                        measurement_bandwidth;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect measurement_bandwidth = %u",
                            cell_context->operator_info.
                            sib_3_info.intra_freq_reselection_info.
                            measurement_bandwidth);
                    ret_val = RRM_FAILURE;
                    break;
            }
        }
    }
    /* BLR END */
    if( cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT)
    {
        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            presence_antenna_port_1 = cell_context->operator_info.sib_3_info.\
            intra_freq_reselection_info.presence_antenna_port1;

        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            neigh_cell_config = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            neigh_cell_config;

        rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
            t_reselec_eutra = cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            t_reselection_eutra;
        /*BLR START */
        if((cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                    idle_mode_mobility_intra_freq_params.bitmask & \
                    RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT))
        {
            rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                presence_bitmask |= INTRA_FREQ_CELL_RESELECT_EUTRAN_SF_PRESENCE_FLAG ;

            switch(cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                    idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium)
            {
                case RRM_OAM_O_DOT_25:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_medium = RRM_RRC_O_DOT_25;
                    break;
                case RRM_OAM_O_DOT_5:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_medium = RRM_RRC_O_DOT_5;
                    break;
                case RRM_OAM_O_DOT_75:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_medium = RRM_RRC_O_DOT_75;
                    break;
                case RRM_OAM_l_DOT_0:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_medium = RRM_RRC_l_DOT_0;
                    break;
                default:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_medium = 
                        cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                        idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect speed_scale_factors.t_reselection_eutra_sf_medium = %u",
                            cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                            idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium);
                    ret_val = RRM_FAILURE;
                    break;
            }

            switch(cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                    idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high)
            {
                case RRM_OAM_O_DOT_25:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_high = RRM_RRC_O_DOT_25;
                    break;
                case RRM_OAM_O_DOT_5:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_high = RRM_RRC_O_DOT_5;
                    break;
                case RRM_OAM_O_DOT_75:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_high = RRM_RRC_O_DOT_75;
                    break;
                case RRM_OAM_l_DOT_0:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_high = RRM_RRC_l_DOT_0;
                    break;
                default:
                    rrc_rrm_cell_setup_req->sib_type_3_Info.intra_freq_cell_reselect_info.\
                        t_reselect_eutra_sf.sf_high = 
                        cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                        idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect speed_scale_factors.t_reselection_eutra_sf_medium = %u",
                            cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                            idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high);
                    ret_val = RRM_FAILURE;
                    break;
            }
        }
    }
    /*BLR END */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_4
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the sib type 4 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_4
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /*bitmask*/
    rrc_rrm_cell_setup_req->sib_type_4_Info.presence_bitmask=RRM_ZERO;
    if(cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT)
    {
        if(cell_context->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT)
        {
            /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
            intra_freq_neigh_black_cell_list(cell_context,rrc_rrm_cell_setup_req);
        }
    }
    if(cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_4_INFO_PRESENT)
    {
        /* BUG_11575_CHANGES_START */
        rrc_rrm_cell_setup_req->presence_bitmask |= 
            CELL_SETUP_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
        /* BUG_11575_CHANGES_END */
        csg_phy_cell_id_range(cell_context,rrc_rrm_cell_setup_req);
        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Bug_12689_fix: Start */
/****************************************************************************
 * FUNCTION    : rrm_check_pci_conflict_with_serving_cell
 * INPUT       : *intra_freq_cell, *p_cell_context
 * OUTPUT      : 
 * DESCRIPTION :
 *  		This function checks if on cell Setup if any previous PCI conflict 
 *          with Serving cell is resolved or any new PCI conflict has occured.
 * RETURNS     : VOID
 *****************************************************************************/
rrm_void_t
rrm_check_pci_conflict_with_serving_cell(
        intra_freq_cells_t *intra_freq_cell, 
        rrm_cell_context_t *p_cell_context
        )
{
    RRM_UT_TRACE_ENTER();
    if(intra_freq_cell->phy_cell_id != 
            p_cell_context->ran_info.rf_params.rf_configurations.phy_cell_id)
    {
        intra_freq_cell->is_pci_conflict = RRM_FALSE;
    }
    if(intra_freq_cell->phy_cell_id == 
            p_cell_context->ran_info.rf_params.rf_configurations.phy_cell_id)
    {
        intra_freq_cell->is_pci_conflict = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
}
/* Bug_12689_fix: End */
/****************************************************************************
 *   FUNCTION NAME       :   intra_freq_neigh_black_cell_list
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the intra freq neigh black cell list coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
intra_freq_neigh_black_cell_list
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    U8 valid_cells = RRM_ZERO;
    U8	cell_count = RRM_ZERO;
    U8 neigh_count = RRM_ZERO;
    U8	black_count = RRM_ZERO;
    rrm_return_et    ret_val = RRM_SUCCESS;
    U8 q_offset_cell_val = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    valid_cells = cell_context->ran_info.ncl_params.lte_ncl.\
                  num_valid_intra_freq_cell;

    for(cell_count=RRM_ZERO; cell_count < valid_cells; cell_count++)
    {  /* Changes start to be checked*/
        /* Bug_12689_fix: Start */
        rrm_check_pci_conflict_with_serving_cell(&(cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count]),
                cell_context);

        if ( (cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].broadcast_status == RRM_TRUE) &&
                (RRM_FALSE == cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].is_pci_conflict) )
            /* Bug_12689_fix: End */
        {
            if (cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].blacklisted == RRM_FALSE)
            {
                if( MAX_CELL_INTRA  > neigh_count)
                {
                    /*daho clean up(check is not needed as now ncl will not contain daho cell)*/  
                    /*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
                    /*coverity 30245, rel2.0.1, , rrm_oam_q_offset_range_et*/
                    ret_val = map_intra_freq_q_offset_info((rrm_oam_q_offset_range_et)cell_context->ran_info.ncl_params.lte_ncl.
                            intra_freq_cells[cell_count].q_offset, 
                            &q_offset_cell_val);
                    /*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
                    rrc_rrm_cell_setup_req->sib_type_4_Info.intra_freq_neigh_cell_list.\
                        neigh_cell[neigh_count].q_offset_cell  = q_offset_cell_val; 


                    rrc_rrm_cell_setup_req->sib_type_4_Info.intra_freq_neigh_cell_list.\
                        neigh_cell[neigh_count].phys_cell_id = cell_context->ran_info.\
                        ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id;

                    rrc_rrm_cell_setup_req->sib_type_4_Info.presence_bitmask |= SIB_4_NEIGH_CELL_LIST_PRESENCE_FLAG;
                    neigh_count++;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Max Nbr cells added for intra-freq. Can't broadcast pci = %d",
                            cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                }
            }
            else 
            {
                if( MAX_CELL_BLACK_LIST > black_count)
                {
                    rrc_rrm_cell_setup_req->sib_type_4_Info.\
                        intra_freq_black_listed_cell_list.black_listed_cell[black_count].\
                        start = cell_context->ran_info.ncl_params.lte_ncl.\
                        intra_freq_cells[cell_count].phy_cell_id;

                    rrc_rrm_cell_setup_req->sib_type_4_Info.presence_bitmask |= SIB_4_BLACK_LIST_LIST_PRESENCE_FLAG;

                    black_count++;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_WARNING,
                            "Max Nbr cells added for blacklist inter_freq  pci = %d",
                            cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                }
            }
        }   
    }
    rrc_rrm_cell_setup_req->sib_type_4_Info.intra_freq_neigh_cell_list.\
        count = neigh_count;

    rrc_rrm_cell_setup_req->sib_type_4_Info.intra_freq_black_listed_cell_list.\
        count = black_count;

    /* BUG_11575_CHANGES_START */
    if ((neigh_count != RRM_ZERO) ||
            (black_count != RRM_ZERO))
    {
        rrc_rrm_cell_setup_req->presence_bitmask |= 
            CELL_SETUP_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
    }
    /* BUG_11575_CHANGES_END */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   csg_phy_cell_id_range
 *   INPUT       : cell_context
 *   OUTPUT      : rrc_rrm_cell_setup_req
 *   DESCRIPTION :
 *    		This function Maps the csg phy cell id range params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
csg_phy_cell_id_range
(
 rrm_cell_context_t *cell_context, 
 rrc_rrm_cell_setup_req_t *rrc_rrm_cell_setup_req
 )
{
    RRM_UT_TRACE_ENTER();
    rrc_rrm_cell_setup_req->sib_type_4_Info.presence_bitmask |= 
        SIB_4_PHY_CELL_ID_PRESENCE_FLAG; /* BLR */
    rrc_rrm_cell_setup_req->sib_type_4_Info.csg_phy_cell_id_range.presence_bitmask = RRM_ZERO;
    rrc_rrm_cell_setup_req->sib_type_4_Info.csg_phy_cell_id_range.start = 
        cell_context->operator_info.sib_4_info.csg_id_range.start;

    /* BLR START */			
    if(cell_context->operator_info.sib_4_info.csg_id_range.bitmask & RRMCM_RMIF_CELL_ID_RANGE_PRESENT)
    {
        rrc_rrm_cell_setup_req->sib_type_4_Info.csg_phy_cell_id_range.\
            range = cell_context->operator_info.sib_4_info.csg_id_range.range;
        rrc_rrm_cell_setup_req->sib_type_4_Info.csg_phy_cell_id_range.\
            presence_bitmask |= PHY_CELL_ID_RANGE ;
    }
    /* BLR END */

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   csg_phy_cell_id_range_for_sib_4
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_4_Info
 *   DESCRIPTION :
 *          This function Maps the sib 4 params to send to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
csg_phy_cell_id_range_for_sib_4
(
 rrm_cell_context_t *cell_context,
 sib_type_4_Info_t  *p_sib_type_4_Info
 )
{
    RRM_UT_TRACE_ENTER();
    p_sib_type_4_Info->presence_bitmask |=
        SIB_4_PHY_CELL_ID_PRESENCE_FLAG;
    p_sib_type_4_Info->csg_phy_cell_id_range.presence_bitmask = RRM_ZERO;
    p_sib_type_4_Info->csg_phy_cell_id_range.start =
        cell_context->operator_info.sib_4_info.csg_id_range.start;

    if(cell_context->operator_info.sib_4_info.csg_id_range.bitmask & RRMCM_RMIF_CELL_ID_RANGE_PRESENT)
    {
        p_sib_type_4_Info->csg_phy_cell_id_range.\
            range = cell_context->operator_info.sib_4_info.csg_id_range.range;
        p_sib_type_4_Info->csg_phy_cell_id_range.\
            presence_bitmask |= PHY_CELL_ID_RANGE ;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/*LTE_RRM_KLOCWORK_WARN_11_JULY_START*/
/* BUG_371 FIX START */
/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_5_q_offset_cell
 *   INPUT       :cell_context
 *   OUTPUT      : p_sib_type_5_info
 *   DESCRIPTION :
 *              This function Maps the sib type 5 q offset cell params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_sib_type_5_q_offset_cell(const rrm_cell_context_t *cell_context,
        sib_type_5_Info_t  *p_sib_type_5_info,
        U8                  inter_freq_list,
        U8			 neigh_count)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    switch(cell_context->ran_info.\
            ncl_params.lte_ncl.inter_freq_cells[inter_freq_list].q_offset)
    {
        /* Coverity_fix_88505_start */
        case RRM_Q_OFFSET_RANGE_DB_24:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_24;
            break;
        case RRM_Q_OFFSET_RANGE_DB_22:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_22;
            break;
        case RRM_Q_OFFSET_RANGE_DB_20:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_20;
            break;
        case RRM_Q_OFFSET_RANGE_DB_18:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_18;
            break;
        case RRM_Q_OFFSET_RANGE_DB_16:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_16;
            break;
        case RRM_Q_OFFSET_RANGE_DB_14:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_14;
            break;
        case RRM_Q_OFFSET_RANGE_DB_12:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_12;
            break;
        case RRM_Q_OFFSET_RANGE_DB_10:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_10;
            break;
        case RRM_Q_OFFSET_RANGE_DB_8:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_8;
            break;
        case RRM_Q_OFFSET_RANGE_DB_6:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_6;
            break;
        case RRM_Q_OFFSET_RANGE_DB_5:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_5;
            break;
        case RRM_Q_OFFSET_RANGE_DB_4:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_4;
            break;
        case RRM_Q_OFFSET_RANGE_DB_3:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell =(U8)RRM_RRC_Q_OFFESET_RANGE_DB_3;
            break;
        case RRM_Q_OFFSET_RANGE_DB_2:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_2;
            break;
        case RRM_Q_OFFSET_RANGE_DB_1:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_1;
            break;
        case RRM_Q_OFFSET_RANGE_DB0:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB0;
            break;
        case RRM_Q_OFFSET_RANGE_DB1:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB1;
            break;
        case RRM_Q_OFFSET_RANGE_DB2:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB2;
            break;
        case RRM_Q_OFFSET_RANGE_DB3:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB3;
            break;
        case RRM_Q_OFFSET_RANGE_DB4:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB4;
            break;
        case RRM_Q_OFFSET_RANGE_DB5:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB5;
            break;
        case RRM_Q_OFFSET_RANGE_DB6:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB6;
            break;
        case RRM_Q_OFFSET_RANGE_DB8:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB8;
            break;
        case RRM_Q_OFFSET_RANGE_DB10:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB10;
            break;
        case RRM_Q_OFFSET_RANGE_DB12:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB12;
            break;
        case RRM_Q_OFFSET_RANGE_DB14:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB14;
            break;
        case RRM_Q_OFFSET_RANGE_DB16:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB16;
            break;
        case RRM_Q_OFFSET_RANGE_DB18:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB18;
            break;
        case RRM_Q_OFFSET_RANGE_DB20:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB20;
            break;
        case RRM_Q_OFFSET_RANGE_DB22:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB22;
            break;
        case RRM_Q_OFFSET_RANGE_DB24:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB24;
            break;
         /* Coverity_fix_88505_end */
        default:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                inter_freq_neigh_cell_list.
                neigh_cell[neigh_count].q_offset_cell = (U8)cell_context->ran_info.
                ncl_params.lte_ncl.inter_freq_cells[inter_freq_list].q_offset;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Unexpected value for q_offset_cell = %u",
                    cell_context->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_list].q_offset);
            ret_val = RRM_FAILURE;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_11_JULY_START*/

/*LTE_RRM_KLOCWORK_WARN_11_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_5_sf_high
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_5_info
 *   DESCRIPTION :
 *              This function Maps the sib type 5 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_sib_type_5_sf_high(const rrm_cell_context_t *cell_context,
        sib_type_5_Info_t  *p_sib_type_5_info,
        U8                  inter_freq_list)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    switch(cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
            idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_high)
    {
        case RRM_OAM_O_DOT_25:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_high = RRM_RRC_O_DOT_25;
            break;
        case RRM_OAM_O_DOT_5:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_high = RRM_RRC_O_DOT_5;
            break;
        case RRM_OAM_O_DOT_75:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_high = RRM_RRC_O_DOT_75;
            break;
        case RRM_OAM_l_DOT_0:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_high = RRM_RRC_l_DOT_0;
            break;
        default :
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_high = 
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_high;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                    " sf_high = %u",
                    cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                    idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_high);
            ret_val = RRM_FAILURE;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_11_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_5_sf_medium
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_5_info
 *   DESCRIPTION :
 *              This function Maps the sib type 5 sf medium params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_sib_type_5_sf_medium(const rrm_cell_context_t *cell_context,
        sib_type_5_Info_t  *p_sib_type_5_info,
        U8 		    inter_freq_list)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    switch(cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
            idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_medium)
    {
        case RRM_OAM_O_DOT_25:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_medium = RRM_RRC_O_DOT_25;
            break;
        case RRM_OAM_O_DOT_5:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_medium = RRM_RRC_O_DOT_5;
            break;
        case RRM_OAM_O_DOT_75:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_medium = RRM_RRC_O_DOT_75;
            break;
        case RRM_OAM_l_DOT_0:
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_medium = RRM_RRC_l_DOT_0;
            break;
        default :
            p_sib_type_5_info->inter_freq_carrier_freq_list_list.\
                inter_freq_carrier_freq_list[inter_freq_list].\
                speed_depend_scal_params.sf_medium = 
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_medium;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                    " sf_medium = %u",
                    cell_context->ran_info.mobility_params.idle_mode_mobility_params.\
                    idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_medium);
            ret_val = RRM_FAILURE;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*klock_works_changes_start*/

rrm_return_et
map_sib_5_rrc_inter_freq_params
(
 rrm_cell_context_t        *cell_context,
 U16                       *carrier_arfcn,
 inter_freq_carrier_freq_t *p_sib_5_rrc_inter_freq_carrier_freq,
 sib_type_5_Info_t         *p_sib_type_5_info,
 U8                        *inter_freq_list
 )
{        
    U8                   count                       = RRM_ZERO;
    U8                   inter_freq_cell             = RRM_ZERO; 
    inter_freq_cells_t                   *p_lte_ncl_inter_freq_cells = RRM_PNULL;
    U8                   neigh_count                 = RRM_ZERO;
    rrm_return_et        ret_val                     = RRM_SUCCESS; 
    U8                   black_count                 = RRM_ZERO;
    RRM_UT_TRACE_ENTER();


    if(cell_context != RRM_PNULL)   /* Klocwork_fix_27_aug */
    {
        if (cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT)
        {
            if(cell_context->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT) 
            {
                count = cell_context->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell;

                for(inter_freq_cell = RRM_ZERO; inter_freq_cell < count; inter_freq_cell++ )
                {
                    p_lte_ncl_inter_freq_cells = &(cell_context->ran_info.ncl_params.
                            lte_ncl.inter_freq_cells[inter_freq_cell]);
                    RRM_ASSERT(RRM_PNULL != p_lte_ncl_inter_freq_cells);

                    if(p_lte_ncl_inter_freq_cells->eutra_carrier_arfcn == *carrier_arfcn)
                    {
                        /* Change start to be checked */
                        if(p_lte_ncl_inter_freq_cells->broadcast_status == RRM_TRUE )
                        {    
                            if(p_lte_ncl_inter_freq_cells->blacklisted == RRM_FALSE)
                            {
                                if ( MAX_CELL_INTRA  > neigh_count) 
                                {
                                    /*Broadcast only if it is not a DAHO cell */
                                    if( p_lte_ncl_inter_freq_cells->phy_cell_id != 
                                            cell_context->operator_info.daho_cell_config_info.eutran_daho_cell_config_info.phy_cell_id )
                                    {
                                        p_sib_5_rrc_inter_freq_carrier_freq->inter_freq_neigh_cell_list.neigh_cell[neigh_count].q_offset_cell = 
                                            p_lte_ncl_inter_freq_cells->q_offset;
                                        /*LTE_RRM_KLOCWORK_WARN_11_JULY_START*/ 
                                        map_sib_type_5_q_offset_cell(cell_context,
                                                p_sib_type_5_info,
                                                *inter_freq_list,
                                                neigh_count); 
                                        /*LTE_RRM_KLOCWORK_WARN_11_JULY_END*/

                                        p_sib_5_rrc_inter_freq_carrier_freq->inter_freq_neigh_cell_list.neigh_cell[neigh_count].phys_cell_id = 
                                            p_lte_ncl_inter_freq_cells->phy_cell_id;

                                        neigh_count++;

                                        /*setting bitmask*/
                                        p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |= INTER_FREQ_CARR_NEIGH_CELL_LIST_PRESENCE_FLAG;
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                                "Max Nbr cells added for blacklist inter_freq  pci = %d",
                                                p_lte_ncl_inter_freq_cells->phy_cell_id);
                                    }
                                }
                            }
                            else if(p_lte_ncl_inter_freq_cells->blacklisted == RRM_TRUE)
                            {
                                p_sib_5_rrc_inter_freq_carrier_freq->inter_freq_black_listed_cell_list.
                                    black_listed_cell[black_count].presence_bitmask = RRM_ZERO;

                                p_sib_5_rrc_inter_freq_carrier_freq->inter_freq_black_listed_cell_list.
                                    black_listed_cell[black_count].start = 
                                    p_lte_ncl_inter_freq_cells->phy_cell_id; 

                                black_count++;

                                /*setting bitmask*/
                                p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |= 
                                    INTER_FREQ_CARR_BLACK_LIST_CELL_LIST_PRESENCE_FLAG;
                            }
                        }
                    }
                }

                p_sib_5_rrc_inter_freq_carrier_freq->inter_freq_neigh_cell_list.count = neigh_count;
                p_sib_5_rrc_inter_freq_carrier_freq->inter_freq_black_listed_cell_list.count = black_count;
            }
        }
    }
    else /* Klocwork_fix_27_aug */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cell Context received Null!");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_ENTER();
    return ret_val;
}          
/*klock_works_changes_end*/
/*SPR 6293 CODE CHANGES START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_5
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_5_info
 *   DESCRIPTION :
 *    		This function Maps the sib type 5 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_5
(
 rrm_cell_context_t *cell_context, 
 sib_type_5_Info_t  *p_sib_type_5_info
 )
{

    U8            inter_freq_list = RRM_ZERO; 
    U8            valid_inter_freq_list = RRM_ZERO;
    /* changes */
    U16           carrier_arfcn = RRM_ZERO;
    rrm_return_et    ret_val = RRM_SUCCESS;
    inter_freq_carrier_freq_t            *p_sib_5_rrc_inter_freq_carrier_freq = RRM_PNULL;
    inter_freq_params_t                  *p_oam_idle_mode_mobility_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* Klocwork changes start 22 may */
    RRM_ASSERT(RRM_PNULL != cell_context);
    /* Klocwork changes end 22 may */
    /* Klocwork changes start 27 may */
    RRM_ASSERT(RRM_PNULL != p_sib_type_5_info);
    /* Klocwork changes end 27 may */
    if(cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT)
    {
        p_sib_type_5_info->inter_freq_carrier_freq_list_list.count = 
            cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.num_valid_inter_freq_list;

        valid_inter_freq_list = cell_context->ran_info.mobility_params.\
                                idle_mode_mobility_params.num_valid_inter_freq_list;

        for(inter_freq_list = RRM_ZERO; inter_freq_list < valid_inter_freq_list; inter_freq_list++)
        {
            p_sib_5_rrc_inter_freq_carrier_freq = &(p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list]);
            RRM_ASSERT(RRM_PNULL != p_sib_5_rrc_inter_freq_carrier_freq);

            p_oam_idle_mode_mobility_params = &(cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_freq_params[inter_freq_list]);
            RRM_ASSERT(RRM_PNULL != p_oam_idle_mode_mobility_params);

            p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask = RRM_ZERO;

            p_sib_5_rrc_inter_freq_carrier_freq->eutra_dl_carrier_freq = 
                p_oam_idle_mode_mobility_params->eutra_carrier_arfcn;

            carrier_arfcn = p_sib_5_rrc_inter_freq_carrier_freq->eutra_dl_carrier_freq;

            p_sib_5_rrc_inter_freq_carrier_freq->qrx_lev_min = 
                p_oam_idle_mode_mobility_params->q_rx_lev_min_sib_5;

            if((p_oam_idle_mode_mobility_params->bitmask &  RRMCM_RMIF_P_MAX_PRESENT))
            {
                p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |=
                    INTER_FREQ_CARR_P_MAX_PRESENCE_FLAG;
                p_sib_5_rrc_inter_freq_carrier_freq->p_max = 
                    p_oam_idle_mode_mobility_params->p_max;
            }
            p_sib_5_rrc_inter_freq_carrier_freq->t_reselection_eutran = 
                p_oam_idle_mode_mobility_params->t_reselection_eutra;

            if((p_oam_idle_mode_mobility_params->bitmask & 
                        RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1))
            {
                /*setting bitmask*/
                p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |=
                    INTER_FREQ_CARR_SCALE_PARAM_PRESENCE_FLAG;

                /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
                map_sib_type_5_sf_medium(cell_context,p_sib_type_5_info,inter_freq_list);

                /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

                /*LTE_RRM_KLOCWORK_WARN_11_JULY_START*/
                map_sib_type_5_sf_high(cell_context,p_sib_type_5_info,inter_freq_list);
                /*LTE_RRM_KLOCWORK_WARN_11_JULY_END*/

            }
            p_sib_5_rrc_inter_freq_carrier_freq->thresh_x_high = 
                p_oam_idle_mode_mobility_params->thresh_x_high;

            p_sib_5_rrc_inter_freq_carrier_freq->thresh_x_low = 
                p_oam_idle_mode_mobility_params->thresh_x_low;


            p_sib_5_rrc_inter_freq_carrier_freq->measurement_bandwidth = 
                p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.allowed_meas_bandwidth;

            p_sib_5_rrc_inter_freq_carrier_freq->presence_antenna_port_1 =  
                p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.presence_antenna_port1;

            if((p_oam_idle_mode_mobility_params->bitmask & RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT))
            {
                p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |= 
                    INTER_FREQ_CARR_CELL_RESELCT_PRIOR_PRESENCE_FLAG;

                p_sib_5_rrc_inter_freq_carrier_freq->cell_reselect_priority = 
                    p_oam_idle_mode_mobility_params->cell_reselection_priority;
            }

            p_sib_5_rrc_inter_freq_carrier_freq->neigh_cell_config = 
                p_oam_idle_mode_mobility_params->neigh_cell_config;
#ifdef LTE_EMBMS_SUPPORTED
            if (MBMS_SIB_5_SCHEDULE_BROADCAST &
                cell_context->rrm_cell_embms_data.mbms_broadcast_status)
            {
                p_sib_5_rrc_inter_freq_carrier_freq->neigh_cell_config = 
                    cell_context->rrm_cell_embms_data.inter_cell_neigh_cell_config[inter_freq_list];
            }

#endif
            p_sib_5_rrc_inter_freq_carrier_freq->q_offset_freq = 
                p_oam_idle_mode_mobility_params->q_offset_freq;

            /*klock_works_changes_start*/

            ret_val=map_sib_5_rrc_inter_freq_params( cell_context, &carrier_arfcn, p_sib_5_rrc_inter_freq_carrier_freq, p_sib_type_5_info, &inter_freq_list);

            /*klock_works_changes_end*/

            if(p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT)
            {
                p_sib_5_rrc_inter_freq_carrier_freq->q_qual_min_r9 = 
                    p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.q_qual_min_r9;
                p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |= 
                    INTER_FREQ_CARR_Q_QUAL_MIN_R9_PRESENCE_FLAG;
            }

            if(p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.bitmask & 
                    RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT)
            {
                p_sib_5_rrc_inter_freq_carrier_freq->thresh_x_q_r9.thresh_x_high_q_r9 = 
                    p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.threshx_q_r9.thresh_serving_highq_r9;

                p_sib_5_rrc_inter_freq_carrier_freq->thresh_x_q_r9.thresh_x_low_q_r9 = 
                    p_oam_idle_mode_mobility_params->inter_freq_params_op_specific.threshx_q_r9.thresh_serving_lowq_r9;

                p_sib_5_rrc_inter_freq_carrier_freq->presence_bitmask |= 
                    INTER_FREQ_THRESH_X_Q_R9_PRESENCE_FLAG;
            }
        }
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_6_eutran_utran_fdd
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_6_info
 *   DESCRIPTION :
 *          This function Maps the sib type 6 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_void_t
map_sib_type_6_eutran_utran_fdd(rrm_cell_context_t *cell_context,
        sib_type_6_Info_t  *p_sib_type_6_info)
{
    U8            index   = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_sib_type_6_info->presence_bitmask |= 
        SIB_6_CARRIER_FREQ_LIST_UTRA_FDD_PRESENCE_FLAG ;

    /*Filling Utran_FDD_list */
    /* CSR_00082379_fix: Start */
    p_sib_type_6_info->carrier_freq_list_utra_fdd.count = RRM_ZERO;

    /* Fix for SPR 12929 Start */
    for(index = RRM_ZERO;(index < cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                num_irat_eutran_to_utran_fdd_carriers)
            && (cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                num_irat_eutran_to_utran_fdd_carriers
                <= RRM_MAX_NUM_UTRA_FDD_CARRIERS); index++)
        /* Fix for SPR 12929 End */
    {
        p_sib_type_6_info->carrier_freq_list_utra_fdd.count++;
        /* CSR_00082379_fix: End */

        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask = RRM_ZERO;
        /*arfcn_freq*/
        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].carrier_freq=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].utra_carrier_arfcn;

        /*q_rx_lev_min*/
        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].q_rx_lev_min=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].q_rx_lev_min;

        /*q_qual_min*/
        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].q_qual_min=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].q_qual_min;

        /* cell_reselection_priority*/
        if(RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT &
                cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].bitmask)
        {
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask |= 
                CR_FREQ_UTRA_FDD_CELL_RESEL_PRI_PRESENCE_FLAG;

            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].cell_reselection_priority =
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].cell_reselection_priority;
        }

        /* thresh_x_high*/
        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].thresh_x_high=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].thresh_x_high;

        /*thresh_x_low*/
        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].thresh_x_low=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].thresh_x_low;

        /*p_max_utra*/
        p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].p_max_utra=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].p_max_utra;

        /* threshx_q_r9*/
        if(RRMCM_RMIF_THRESHX_Q_R9_PRESENT & 
                cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].bitmask)
        {
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask |= 
                CR_FREQ_UTRA_FDD_THRESH_X_Q_R9_PRESENCE_FLAG;

            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                thresh_x_q_r9.thresh_x_high_q_r9=
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].threshx_q_r9.
                thresh_serving_highq_r9;

            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                thresh_x_q_r9.thresh_x_low_q_r9 =
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].threshx_q_r9.
                thresh_serving_lowq_r9;
        }

    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_6_eutran_utran_tdd
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_6_info
 *   DESCRIPTION :
 *          This function Maps the sib type 6 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_void_t
map_sib_type_6_eutran_utran_tdd(rrm_cell_context_t *cell_context,
        sib_type_6_Info_t  *p_sib_type_6_info)
{
    U8            index   = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_sib_type_6_info->presence_bitmask |=
        SIB_6_CARRIER_FREQ_LIST_UTRA_TDD_PRESENCE_FLAG ;

    /*Filling Utran_TDD_list */
    p_sib_type_6_info->carrier_freq_list_utra_tdd.count =
        cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.
        irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers;

    /* Fix for SPR 12929 Start */
    for(index = RRM_ZERO;(index < p_sib_type_6_info->carrier_freq_list_utra_tdd.count
                && p_sib_type_6_info->carrier_freq_list_utra_tdd.count
                <= RRM_MAX_NUM_UTRA_TDD_CARRIERS); index++)
        /* Fix for SPR 12929 End */
    {
        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask = RRM_ZERO;
        /*arfcn_freq*/
        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].carrier_freq =
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].utra_carrier_arfcn;

        /*q_rx_lev_min*/
        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].q_rx_lev_min=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].q_rx_lev_min;

        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask = RRM_ZERO;

        /* cell_reselection_priority*/
        if(RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT &
                cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].bitmask)
        {
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask |=
                CR_FREQ_UTRA_TDD_CELL_RESEL_PRI_PRESENCE_FLAG;

            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].cell_reselection_priority = 
                cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].cell_reselection_priority;
        }

        /* thresh_x_high*/
        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].thresh_x_high =
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].thresh_x_high;

        /*thresh_x_low*/
        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].thresh_x_low =
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].thresh_x_low;

        /*p_max_utra*/
        p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].p_max_utra=
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].p_max_utra;
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/*SPR 6293 CODE CHANGES END*/

/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_6
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_6_info
 *   DESCRIPTION :
 *    		This function Maps the sib type 6 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_6
(
 rrm_cell_context_t *cell_context, 
 sib_type_6_Info_t  *p_sib_type_6_info
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_sib_type_6_info->presence_bitmask = RRM_ZERO;
    if ( RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT & 
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask )
    {
        /*Klockwork_fix_start*/
        map_sib_type_6_eutran_utran_fdd(cell_context , p_sib_type_6_info);
        /*Klockwork_fix_end*/
    }
    /* CSR_00053776_CHANGES_START */    
    //#ifdef TDD_MODE_FLAG
    /* CSR_00053776_CHANGES_END */    
    if ( RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT &
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask )
    {
        /*Klockwork_fix_start*/
        map_sib_type_6_eutran_utran_tdd(cell_context , p_sib_type_6_info);
        /*Klockwork_fix_end*/
    }
    /* CSR_00053776_CHANGES_START */    
    //#endif
    /* CSR_00053776_CHANGES_END */    
    /* Filling t_resel_utra*/
    p_sib_type_6_info->t_resel_utra=
        cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.
        irat_eutra_to_utra_reselection_params.t_reselection_utra;
    if ( RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT &
            cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.bitmask
       )
    {
        p_sib_type_6_info->presence_bitmask |= 
            SIB_6_T_RESELECTION_UTRA_SF_PRESENCE_FLAG;

        switch(cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.
                irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =
                    cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.
                    irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                    t_reselection_eutra_sf_medium;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_medium= %d",
                        cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.
                        irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;

                break;
        }
        switch(cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.
                irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = 
                    cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.
                    irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                    t_reselection_eutra_sf_high;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_high= %d",
                        cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.
                        irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *FUNCTION NAME :   rrm_map_sib_type_7_geran_freq
 *INPUT       : cell_context
 *OUTPUT      : p_sib_type_7_info
 *DESCRIPTION :
 *This function Maps the sib type 7 params coming from MIF to RRC
 *
 *RETURNS :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_void_t
rrm_map_sib_type_7_geran_freq(sib_type_7_Info_t  *p_sib_type_7_info ,
        idle_mode_mobility_irat_geran_params_t  *p_idle_mode_mob_geran)
{
    carrier_freqs_info_geran_t     *p_carrier_freqs_info_geran = RRM_PNULL;
    irat_eutran_geran_carriers_t   *p_eutran_geran_carriers = RRM_PNULL;
    U8            index   = RRM_ZERO;
    U8            exp_arfcns_index = RRM_ZERO;
    U8            index_bitmap = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_sib_type_7_info->presence_bitmask |=\
                                          SIB_7_CR_FREQS_INFO_LST_PRESENCE_FLAG;

    p_sib_type_7_info->carrier_freqs_info_lst.\
        count = p_idle_mode_mob_geran->\
        irat_eutran_to_geran_list.\
        num_irat_eutran_to_geran_carriers;

    for(index = RRM_ZERO;(index < p_sib_type_7_info->carrier_freqs_info_lst.count
                && p_sib_type_7_info->carrier_freqs_info_lst.count
                <= MAX_NO_GERAN_FREQ_GROUUP); index++)
    {
        p_carrier_freqs_info_geran =\
                                    &(p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index]);

        p_eutran_geran_carriers =\
                                 &(p_idle_mode_mob_geran->\
                                         irat_eutran_to_geran_list.\
                                         irat_eutran_to_geran_carriers[index]);

        p_carrier_freqs_info_geran->\
            common_info.\
            presence_bitmask = RRM_ZERO;

        p_carrier_freqs_info_geran->\
            common_info.ncc_permitted[RRM_ZERO] = p_eutran_geran_carriers->\
            ncc_permitted; 

        p_carrier_freqs_info_geran->\
            common_info.q_rx_lev_min =\
            p_eutran_geran_carriers->q_rx_lev_min;    

        /* cell_reselection_priority*/
        p_carrier_freqs_info_geran->\
            common_info.presence_bitmask = RRM_ZERO;

        if(RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT &\
                p_eutran_geran_carriers->bitmask)      
        {
            p_carrier_freqs_info_geran->\
                common_info.presence_bitmask |=\
                CRFI_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG;

            p_carrier_freqs_info_geran->\
                common_info.cell_reselection_priority =\
                p_eutran_geran_carriers->cell_reselection_priority;
        }

        if(RRMCM_GERAN_P_MAX_GERAN_PRESENT &\
                p_eutran_geran_carriers->bitmask)
        {
            p_carrier_freqs_info_geran->\
                common_info.presence_bitmask |=\
                CRFI_GERAN_P_MAX_GERAN_PRESENCE_FLAG;

            p_carrier_freqs_info_geran->\
                common_info.p_max_geran = p_eutran_geran_carriers->\
                p_max_geran;
        }
        /* thresh_x_high */                            
        p_carrier_freqs_info_geran->\
            common_info.thresh_x_high = p_eutran_geran_carriers->\
            threshX_high;    

        /* thresh_x_high */
        p_carrier_freqs_info_geran->\
            common_info.thresh_x_low = p_eutran_geran_carriers->\
            threshX_low;    

        /* geran_carrier_freqs */

        /* starting_arfcn */
        p_carrier_freqs_info_geran->\
            carrier_freqs.starting_arfcn =\
            p_eutran_geran_carriers->\
            geran_car_freqs.starting_arfcn;

        /* band_indicator */
        switch(p_eutran_geran_carriers->\
                geran_car_freqs.\
                band_ind)
        {
            case RRM_SON_GERAN_DCS_1800:
                p_carrier_freqs_info_geran->\
                    carrier_freqs.band_indicator =\
                    RRM_RRC_DCS_1800;
                break;
            case RRM_SON_GERAN_PCS_1900:
                p_carrier_freqs_info_geran->\
                    carrier_freqs.band_indicator =\
                    RRM_RRC_PCS_1900;
                break;
            default:
                p_carrier_freqs_info_geran->\
                    carrier_freqs.band_indicator =\
                    p_eutran_geran_carriers->\
                    geran_car_freqs.\
                    band_ind;
                break;
        }   

        p_carrier_freqs_info_geran->carrier_freqs.\
            following_arfcns.presence_bitmask = RRM_ZERO;
        /* explicit_list_of_arfcns */            
        if (RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT &\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.bitmask)
        {
            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.presence_bitmask |=\
                GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.explicit_list_of_arfcns.count =\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.exp_arfcn_list_size;

            for (exp_arfcns_index = RRM_ZERO;\
                    exp_arfcns_index < MAX_EXPL_ARFCNS;
                    exp_arfcns_index++)
            {
                p_carrier_freqs_info_geran->carrier_freqs.\
                    following_arfcns.explicit_list_of_arfcns.\
                    data[exp_arfcns_index] = p_eutran_geran_carriers->\
                    geran_car_freqs.following_arfcns.\
                    exp_arfcn_list[exp_arfcns_index];
            }
        }

        /* equally_spaced_arfcns */
        if (RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT &\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.bitmask)                         
        {
            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.presence_bitmask |=\
                GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.equally_spaced_arfcns.arfcn_spacing =\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.arfcn_spacing;

            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.equally_spaced_arfcns.\
                num_of_following_arfcns =\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.num_of_following_arfcn;
        }

        /* var_bitmap_of_arfcns */

        if (RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT &\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.bitmask)
        {
            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.presence_bitmask |=\
                GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;

            p_carrier_freqs_info_geran->carrier_freqs.\
                following_arfcns.var_bitmap_of_arfcns.count =\
                p_eutran_geran_carriers->\
                geran_car_freqs.following_arfcns.arfcn_bmp_list_size;

            for(index_bitmap = RRM_ZERO;
                    index_bitmap < MAX_VAR_BITMAP_OF_ARFCNS;
                    index_bitmap++)
            {
                p_carrier_freqs_info_geran->carrier_freqs.\
                    following_arfcns.var_bitmap_of_arfcns.data[index_bitmap] =\
                    p_eutran_geran_carriers->\
                    geran_car_freqs.following_arfcns.arfcn_bmp_list[index_bitmap];
            }
        }
    }    
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/****************************************************************************
 *FUNCTION NAME :   map_sib_type_7
 *INPUT       : cell_context
 *OUTPUT      : p_sib_type_7_info
 *DESCRIPTION :
 *This function Maps the sib type 7 params coming from MIF to RRC
 *
 *RETURNS :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_7
(
 rrm_cell_context_t *cell_context, 
 sib_type_7_Info_t  *p_sib_type_7_info
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    idle_mode_mobility_irat_geran_params_t  *p_idle_mode_mob_geran = RRM_PNULL;

    RRM_UT_TRACE_ENTER();


    p_idle_mode_mob_geran = &(cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.\
            idle_mode_mobility_irat_geran_params);

    p_sib_type_7_info->presence_bitmask = RRM_ZERO;

    if (RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT &\
            p_idle_mode_mob_geran->bitmask )
    {
        /*Klockwork_fix_start*/
        rrm_map_sib_type_7_geran_freq(p_sib_type_7_info ,p_idle_mode_mob_geran );
        /*Klockwork_fix_end*/
    }    
    p_sib_type_7_info->t_reselection_geran = 
        p_idle_mode_mob_geran->\
        irat_eutra_to_geran_reselection_params.t_reselection_geran;

    if (RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT &\
            p_idle_mode_mob_geran->\
            irat_eutra_to_geran_reselection_params.bitmask)
    {
        switch(p_idle_mode_mob_geran->\
                irat_eutra_to_geran_reselection_params.\
                speed_state_scale_factor.\
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_RRC_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_RRC_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_RRC_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_RRC_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  p_idle_mode_mob_geran->\
                                                                  irat_eutra_to_geran_reselection_params.\
                                                                  speed_state_scale_factor.\
                                                                  t_reselection_eutra_sf_medium;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_medium= %d",
                        p_idle_mode_mob_geran->\
                        irat_eutra_to_geran_reselection_params.\
                        speed_state_scale_factor.\
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;

                break;
        }
        /*Coverity_fix_start_54950*/
        switch(p_idle_mode_mob_geran->\
                irat_eutra_to_geran_reselection_params.\
                speed_state_scale_factor.\
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                RRM_RRC_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                RRM_RRC_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                RRM_RRC_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                RRM_RRC_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                p_idle_mode_mob_geran->\
                                                                irat_eutra_to_geran_reselection_params.speed_state_scale_factor.\
                                                                t_reselection_eutra_sf_high; 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,\
                        RRM_WARNING, "Incorrect reslection eutra sf_high= %d",\
                        p_idle_mode_mob_geran->\
                        irat_eutra_to_geran_reselection_params.speed_state_scale_factor.\
                        t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }
        p_sib_type_7_info->presence_bitmask |=\
                                              SIB_7_T_RESEL_GERAN_SF_PRESENCE_FLAG;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*Coverity_fix_end_54950*/ 
}
/* CDMA2000 changes start */
/****************************************************************************
 *   FUNCTION NAME       :map_sib_type_8
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the sib type 8 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_8
(
 rrm_cell_context_t *p_cell_context,
 sib_type_8_Info_t  *p_sib_type_8_Info
 )

{
    /*coverity 23136:ret_val type changed to rrm_return_et: ,rel 1.3*/  
    rrm_return_et     ret_val = RRM_SUCCESS;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_idle_mode_mobility_irat_cdma = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_idle_mode_mobility_irat_cdma = &(p_cell_context->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params);

    p_sib_type_8_Info->presence_bitmask = RRM_ZERO;

    /* No need to fill sys_time_info */
    p_sib_type_8_Info->sys_time_info.presence_bitmask = RRM_ZERO;

    /* SPR 6008 */
    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_SYSTEM_TIME_INFO_PRESENCE_FLAG)
    {
        switch(p_idle_mode_mobility_irat_cdma->system_time_info)
        {
            case RRM_OAM_SYN_SYS_TIME:
                p_sib_type_8_Info->sys_time_info.cdma_eutra_sync = RRM_TRUE;
                break;

            case RRM_OAM_ASYN_SYS_TIME:
                p_sib_type_8_Info->sys_time_info.cdma_eutra_sync = RRM_FALSE;
                break;

            default:
                p_sib_type_8_Info->sys_time_info.cdma_eutra_sync = RRM_FALSE;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong Value of SYSTEM_TIME_INFO Recvd, so setting it as Asynchronous");
        }
        p_sib_type_8_Info->presence_bitmask |= SIB_8_SYS_TIME_INFO_PRESENCE_FLAG;
    }
    /* SPR 6008 */

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_SEARCH_WIN_SIZE_PRESENCE_FLAG)
    {
        p_sib_type_8_Info->search_window_size = 
            p_idle_mode_mobility_irat_cdma->search_window_size;
        p_sib_type_8_Info->presence_bitmask |= 
            SIB_8_SEARCH_WIN_SIZE_PRESENCE_FLAG;
    }

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT) ||
            ((p_cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT) &&
             p_cell_context->ran_info.ncl_params.inter_rat_ncl.num_valid_cdma2000_freq_cells > RRM_ZERO))
    {
        /* Start 7514 NRT Fix - SIB 8 */
        map_params_cdma2000_hrpd_1xrtt(p_cell_context, &p_cell_context->ran_info.ncl_params, p_sib_type_8_Info);
        /* End 7514 NRT Fix - SIB 8 */
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG)
    {
        switch(p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9)
        {
            case RRM_FALSE:
                {
                    p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_FALSE;
                    break;
                }
            case RRM_TRUE:
                {
                    p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_TRUE;
                    break;
                }
            default:
                p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = 
                    p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Invalid Value received for Sib-8 :"
                        "csfb_support_for_dual_rx_ues_r9 %d", 
                        p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9);
        }
        p_sib_type_8_Info->presence_bitmask |= 
            SIB_8_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG;
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG)
    {
        map_ac_barring_config_1_xrtt_r9(
                &(p_idle_mode_mobility_irat_cdma->ac_barring_config_1_xrtt_r9), 
                &(p_sib_type_8_Info->ac_barring_config_1_xrtt_r9));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 : ac_barring_config_1_xrtt_r9");
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG;
    }
    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG)
    {
        switch(p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920)
        {
            case RRM_RRC_POWER_DOWN_REG_R9_TRUE_8:
                p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                    RRM_RRC_POWER_DOWN_REG_R9_TRUE_8;
                break;
            default :
                p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                    p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong Value received for csfb_registration_param_1xrtt_v920 : %d",
                        p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920);
        }
        p_sib_type_8_Info->presence_bitmask |= 
            SIB_8_CSFB_REG_PARAM_1_XRTT_R9_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 :csfb_registration_param_1xrtt_v920");
    }

    RRM_UT_TRACE_EXIT();
    /*coverity 23135:type of ret_val changed to rrm_return_et: ,rel 1.3*/
    return ret_val;
}





/*  SIB 8 Changes Start */



/****************************************************************************
 *   FUNCTION NAME       :   update_hrpd_1xrtt_ncl_list
 *   INPUT       : p_inter_rat_ncl
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function updates the hrpd 1xrtt ncl list
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
update_hrpd_1xrtt_ncl_list
(
 inter_rat_ncl_t     *p_inter_rat_ncl,
 sib_type_8_Info_t   *p_sib_type_8_Info)
{
    U16    cdma2000_freq_cells = RRM_ZERO;
    U16    valid_cdma2000_freq_cells = RRM_ZERO;
    U8     cdma2000_bandclass = RRM_ZERO;
    U8     band_class_found = RRM_ZERO;
    U8     cdma2000_arfcn = RRM_ZERO;
    U8     arfcn_found = RRM_ZERO;
    U8     valid_count_arfcn = RRM_ZERO;
    U8     valid_pci_count = RRM_ZERO;
    U8     valid_bandclass_count = RRM_ZERO;
    U8     valid_arfcn_index = RRM_ZERO;
    neigh_cell_list_cdma2000_t  *p_neigh_cell_list_cdma2000 = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    valid_cdma2000_freq_cells = p_inter_rat_ncl->num_valid_cdma2000_freq_cells;

    for(cdma2000_freq_cells = RRM_ZERO; 
            cdma2000_freq_cells < valid_cdma2000_freq_cells; cdma2000_freq_cells++)
    {
        switch(p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].type)
        {
            case RRM_OAM_NCL_TYPE_1XRTT:
                {
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_1_xrtt.
                            cell_reselection_params_1_xrtt.neigh_cell_list);

                    /* Setting First element in CDMA2000 NCL list */
                    if(RRM_ZERO == p_neigh_cell_list_cdma2000->count)
                    {
                        (p_neigh_cell_list_cdma2000->count)++;

                        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].band_class =
                            p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].band_class;

                        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                         neigh_cells_per_freq_list.count)++;

                        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
                            arfcn = p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

                        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                         neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
                         phys_cell_id_list.count)++;

                        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
                            phys_cell_id_list.phys_cell_id_cdma2000[RRM_ZERO] = 
                            p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;
                    }
                    else if((RRM_ZERO < p_neigh_cell_list_cdma2000->count) && 
                            (RRM_SIXTEEN > p_neigh_cell_list_cdma2000->count))
                    {
                        for(cdma2000_bandclass=RRM_ZERO; 
                                cdma2000_bandclass < p_neigh_cell_list_cdma2000->count; cdma2000_bandclass++)
                        {
                            if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                        band_class) == (p_inter_rat_ncl->
                                            cdma2000_freq_cells[cdma2000_freq_cells].band_class))
                            {
                                /* Set Flag for BandClass */
                                band_class_found = RRM_TRUE;

                                for(cdma2000_arfcn=RRM_ZERO;
                                        cdma2000_arfcn < (p_neigh_cell_list_cdma2000->
                                            neigh_cell_cdma2000[cdma2000_bandclass].
                                            neigh_cells_per_freq_list.count); 
                                        cdma2000_arfcn++)
                                {
                                    if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                                neigh_cells_per_freq_list.
                                                neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                                arfcn) == (p_inter_rat_ncl->
                                                    cdma2000_freq_cells[cdma2000_freq_cells].arfcn))
                                    {
                                        /* Set Flag for ARFCN */
                                        arfcn_found = RRM_TRUE;
                                        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                         neigh_cells_per_freq_list.
                                         neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                         phys_cell_id_list.count)++;
                                        break;
                                    }
                                }
                                break;
                            }
                        }

                        /* Fill ARFCN & increment the count value */
                        if(band_class_found && !arfcn_found)
                        {
                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                             neigh_cells_per_freq_list.count)++;
                            valid_count_arfcn = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.count;

                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].arfcn =
                                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

                            valid_pci_count = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].
                                phys_cell_id_list.count; 

                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
                                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] =  p_inter_rat_ncl->
                                cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                             neigh_cells_per_freq_list.
                             neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
                             phys_cell_id_list.count)++; 
                        }
                        /* If Bandclass doesn't matches: Increment count for Bandclass & assign values */
                        if(!band_class_found)
                        {
                            valid_bandclass_count = p_neigh_cell_list_cdma2000->count;

                            /* Assign BandClass */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].band_class =
                                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].band_class;

                            valid_arfcn_index = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.count;

                            /* Assign ARFCN */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                                arfcn = p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

                            valid_pci_count = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                                phys_cell_id_list.count;

                            /* Assign PCI */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] =  p_inter_rat_ncl->
                                cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            /* Increment counter for Bandclass, ARFCN, PCI */
                            (p_neigh_cell_list_cdma2000->count)++;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                             neigh_cells_per_freq_list.count)++;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                             neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                             phys_cell_id_list.count)++;
                        }
                    }
                    /* Resetting FLAGS */
                    band_class_found = RRM_FALSE;
                    arfcn_found = RRM_FALSE;

                    break;
                }
            case RRM_OAM_NCL_TYPE_HRPD:
                {
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_hrpd.
                            cell_reselection_params_hrpd.neigh_cell_list);

                    /* Setting First element in CDMA2000 NCL list */
                    if(RRM_ZERO == p_neigh_cell_list_cdma2000->count)
                    {
                        (p_neigh_cell_list_cdma2000->count)++;

                        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].band_class =
                            p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].band_class;

                        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                         neigh_cells_per_freq_list.count)++;

                        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
                            arfcn = p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

                        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                         neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
                         phys_cell_id_list.count)++;

                        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
                            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
                            phys_cell_id_list.phys_cell_id_cdma2000[RRM_ZERO] = 
                            p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;
                    }
                    else if((RRM_ZERO < p_neigh_cell_list_cdma2000->count) && 
                            (RRM_SIXTEEN > p_neigh_cell_list_cdma2000->count))
                    {
                        for(cdma2000_bandclass=RRM_ZERO; 
                                cdma2000_bandclass < p_neigh_cell_list_cdma2000->count; cdma2000_bandclass++)
                        {
                            if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                        band_class) == (p_inter_rat_ncl->
                                            cdma2000_freq_cells[cdma2000_freq_cells].band_class))
                            {
                                /* Set Flag for BandClass */
                                band_class_found = RRM_TRUE;

                                for(cdma2000_arfcn=RRM_ZERO;
                                        cdma2000_arfcn < (p_neigh_cell_list_cdma2000->
                                            neigh_cell_cdma2000[cdma2000_bandclass].
                                            neigh_cells_per_freq_list.count); 
                                        cdma2000_arfcn++)
                                {
                                    if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                                neigh_cells_per_freq_list.
                                                neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                                arfcn) == (p_inter_rat_ncl->
                                                    cdma2000_freq_cells[cdma2000_freq_cells].arfcn))
                                    {
                                        /* Set Flag for ARFCN */
                                        arfcn_found = RRM_TRUE;
                                        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                         neigh_cells_per_freq_list.
                                         neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                         phys_cell_id_list.count)++;
                                        break;
                                    }
                                }
                                break;
                            }
                        }

                        /* Fill ARFCN & increment the count value */
                        if(band_class_found && !arfcn_found)
                        {
                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                             neigh_cells_per_freq_list.count)++;
                            valid_count_arfcn = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.count;

                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].arfcn =
                                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

                            valid_pci_count = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].
                                phys_cell_id_list.count; 

                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
                                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] =  p_inter_rat_ncl->
                                cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                             neigh_cells_per_freq_list.
                             neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
                             phys_cell_id_list.count)++; 
                        }
                        /* If Bandclass doesn't matches: Increment count for Bandclass & assign values */
                        if(!band_class_found)
                        {
                            valid_bandclass_count = p_neigh_cell_list_cdma2000->count;

                            /* Assign BandClass */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].band_class =
                                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].band_class;

                            valid_arfcn_index = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.count;

                            /* Assign ARFCN */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                                arfcn = p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

                            valid_pci_count = p_neigh_cell_list_cdma2000->
                                neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                                phys_cell_id_list.count;

                            /* Assign PCI */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] =  p_inter_rat_ncl->
                                cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            /* Increment counter for Bandclass, ARFCN, PCI */
                            (p_neigh_cell_list_cdma2000->count)++;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                             neigh_cells_per_freq_list.count)++;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                             neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                             phys_cell_id_list.count)++;
                        }
                    }
                    /* Resetting FLAGS */
                    band_class_found = RRM_FALSE;
                    arfcn_found = RRM_FALSE;
                    break;
                }
            default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Wrong Value received for type in NCL : CDMA2000");
        }
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   update_csfb_reg_1_xrtt_params
 *   INPUT       : p_ran_info
 *   OUTPUT      : p_csfb_reg_param_1_xrtt
 *   DESCRIPTION :
 *          This function updates the csfb reg 1 xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
update_csfb_reg_1_xrtt_params
(
 //    rrm_cell_context_t       *p_rrm_cell_context,
 ran_t                    *p_ran_info,
 csfb_reg_param_1_xrtt_t  *p_csfb_reg_param_1_xrtt
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t *p_irat_cdma_params = RRM_PNULL;
    p_irat_cdma_params = &((p_ran_info->mobility_params).
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->sid,
            p_irat_cdma_params->mobility_sib_8_params.sid,
            RRMCM_RMIF_XRTT_SID_OCTET_SIZE);
    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->nid,
            p_irat_cdma_params->mobility_sib_8_params.nid,
            RRMCM_RMIF_XRTT_NID_OCTET_SIZE);
    p_csfb_reg_param_1_xrtt->multiple_sid = p_irat_cdma_params->
        mobility_sib_8_params.multiple_sid;
    p_csfb_reg_param_1_xrtt->multiple_nid = p_irat_cdma_params->
        mobility_sib_8_params.multiple_nid;
    p_csfb_reg_param_1_xrtt->home_reg = p_irat_cdma_params->
        mobility_sib_8_params.home_reg;
    p_csfb_reg_param_1_xrtt->foreign_sid_reg = p_irat_cdma_params->
        mobility_sib_8_params.foreign_nid_reg;
    p_csfb_reg_param_1_xrtt->foreign_nid_reg = p_irat_cdma_params->
        mobility_sib_8_params.foreign_nid_reg;
    p_csfb_reg_param_1_xrtt->parame_reg = p_irat_cdma_params->
        mobility_sib_8_params.parame_reg;
    p_csfb_reg_param_1_xrtt->power_up_reg = p_irat_cdma_params->
        mobility_sib_8_params.power_up_reg;
    p_csfb_reg_param_1_xrtt->reg_period[RRM_ZERO] = 
        p_irat_cdma_params->mobility_sib_8_params.reg_prd;

    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->reg_zone,
            p_irat_cdma_params->mobility_sib_8_params.reg_zone,
            RRMCM_RMIF_XRTT_REG_ZONE_OCTET_SIZE);
    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->total_zone,
            p_irat_cdma_params->mobility_sib_8_params.total_zone,
            RRMCM_RMIF_XRTT_TOTAL_ZONE_OCTET_SIZE);
    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->zone_timer,
            p_irat_cdma_params->mobility_sib_8_params.zone_timer,
            RRMCM_RMIF_XRTT_ZONE_TIMER_OCTET_SIZE);

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   update_pre_reg_info_hrpd
 *   INPUT       : p_irat_cdma_params
 *   OUTPUT      : p_params_hrpd
 *   DESCRIPTION :
 *          This function updates pre reg info hrpd
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
update_pre_reg_info_hrpd
(
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params,
 params_hrpd_t    *p_params_hrpd
 )
{
    U8  valid_pre_reg_zone = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_params_hrpd->pre_reg_info_hrpd.pre_reg_allowed = 
        p_irat_cdma_params->pre_reg_info_hrpd.pre_reg_allowed;

    if(p_irat_cdma_params->pre_reg_info_hrpd.presence_bitmask & 
            RRMCM_RMIF_PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG)
    {
        p_params_hrpd->pre_reg_info_hrpd.pre_reg_zone_id = 
            p_irat_cdma_params->pre_reg_info_hrpd.pre_reg_zone_id;
        p_params_hrpd->pre_reg_info_hrpd.presence_bitmask |=
            PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG;
    }
    if(p_irat_cdma_params->pre_reg_info_hrpd.presence_bitmask & 
            RRMCM_RMIF_PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG)
    {
        p_params_hrpd->pre_reg_info_hrpd.secondary_list.
            count = p_irat_cdma_params->pre_reg_info_hrpd.secondary_list.
            count;
        for(valid_pre_reg_zone=RRM_ZERO; 
                valid_pre_reg_zone < p_irat_cdma_params->pre_reg_info_hrpd.
                secondary_list.count; valid_pre_reg_zone++)
        {
            p_params_hrpd->pre_reg_info_hrpd.secondary_list.
                pre_reg_zone_id[valid_pre_reg_zone] = p_irat_cdma_params->
                pre_reg_info_hrpd.secondary_list.
                pre_reg_zone_id[valid_pre_reg_zone];
        }
        /* Setting Bitmask for PRE_REG_INFO_HRPD_SECONDARY_LST */
        p_params_hrpd->pre_reg_info_hrpd.
            presence_bitmask |= PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   update_reselection_cdma2000_hrpd_params
 *   INPUT       : p_params_hrpd
 *   OUTPUT      : p_irat_cdma_params
 *   DESCRIPTION :
 *          This function updates reselection cdma2000 hrpd params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
update_reselection_cdma2000_hrpd_params
(
 params_hrpd_t                                *p_params_hrpd,
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params
 )
{
    cell_reselection_params_cdma2000_t  
        *p_rrc_resel_params_cdma2000 = RRM_PNULL;
    speed_scale_factors_t         *p_rrmcm_resel_params_cdma2000_sf = RRM_PNULL;

    p_rrc_resel_params_cdma2000 = &(p_params_hrpd->
            cell_reselection_params_hrpd);

    p_rrmcm_resel_params_cdma2000_sf = &(p_irat_cdma_params->
            cell_reselection_params_hrpd.t_reselection_cdma2000_sf);

    RRM_UT_TRACE_ENTER();

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG)
    {
        map_bandclass_list(
                &(p_irat_cdma_params->cell_reselection_params_hrpd.
                    band_class_list), 
                &(p_rrc_resel_params_cdma2000->band_class_list));

        p_rrc_resel_params_cdma2000->t_reselection_cdma2000 = 
            p_irat_cdma_params->cell_reselection_params_hrpd.t_reselection_cdma2000;

        switch(p_rrmcm_resel_params_cdma2000_sf->t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_O_DOT_25;
                break;

            case RRM_OAM_O_DOT_5 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_l_DOT_0;
                break;
            default:
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = p_rrmcm_resel_params_cdma2000_sf->
                    t_reselection_eutra_sf_medium;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong value received for t_reselection_eutra_sf_medium HRPD\
                        = %d, CDMA2000", p_rrmcm_resel_params_cdma2000_sf->
                        t_reselection_eutra_sf_medium);
        }

        switch(p_rrmcm_resel_params_cdma2000_sf->t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_O_DOT_25;
                break;

            case RRM_OAM_O_DOT_5 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_O_DOT_5;
                break;

            case RRM_OAM_O_DOT_75 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = p_rrmcm_resel_params_cdma2000_sf->
                    t_reselection_eutra_sf_high;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong value received for t_reselection_eutra_sf_high \
                        = %d, CDMA2000", p_rrmcm_resel_params_cdma2000_sf->
                        t_reselection_eutra_sf_high);
        }

        /* Re-setting Bitmask for RESELECT_CDMA2000_SF */
        p_rrc_resel_params_cdma2000->presence_bitmask = RRM_ZERO;

        /* Setting Bitmask for RESELECT_CDMA2000_SF */
        p_rrc_resel_params_cdma2000->presence_bitmask |=
            CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   map_cdma2000_hrpd
 *   INPUT       : p_ran_info
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function updates the cdma2000 hrpd
 *
 *   RETURNS     : none
 *****************************************************************************/
rrm_void_t
update_cdma2000_hrpd
(
 //    rrm_cell_context_t  *p_rrm_cell_context,
 ran_t               *p_ran_info,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{

    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_irat_cdma_params = RRM_PNULL;
    params_hrpd_t       *p_params_hrpd = RRM_PNULL;
    /*
       p_irat_cdma_params = &((p_rrm_cell_context->p_new_reconfig_data)->ran_info.mobility_params.
       idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);
     */
    p_irat_cdma_params = &((p_ran_info->mobility_params).
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_params_hrpd = &(p_sib_type_8_Info->params_hrpd);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_hrpd.presence_bitmask = RRM_ZERO;
    update_pre_reg_info_hrpd(p_irat_cdma_params, p_params_hrpd);

    update_reselection_cdma2000_hrpd_params(p_params_hrpd, p_irat_cdma_params);

    /* Setting Bitmask for HRPD Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_HRPD_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   map_reselection_cdma2000_1xrtt_params
 *   INPUT       : p_irat_cdma_params
 *   OUTPUT      : p_rrc_resel_params_1xrtt
 *   DESCRIPTION :
 *          This function updates reselection cdma2000 1xrtt params 
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
update_reselection_cdma2000_1xrtt_params
(
 rrmcm_idle_mode_mobility_irat_cdma_params_t    *p_irat_cdma_params,
 cell_reselection_params_cdma2000_t             *p_rrc_resel_params_1xrtt
 )
{
    speed_scale_factors_t    *p_rrmcm_resel_cdma2000_sf = RRM_PNULL;
    speed_state_scale_factors_t  *p_rrc_resel_cdma2000_sf = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
    {
        map_bandclass_list(&(p_irat_cdma_params->
                    cell_reselection_params_1xrtt.band_class_list),
                &(p_rrc_resel_params_1xrtt->band_class_list));
        p_rrc_resel_params_1xrtt->t_reselection_cdma2000 = 
            p_irat_cdma_params->cell_reselection_params_1xrtt.
            t_reselection_cdma2000;

        if(p_irat_cdma_params->cell_reselection_params_1xrtt.
                presence_bitmask & RRMCM_RMIF_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG)
        {
            p_rrmcm_resel_cdma2000_sf = &(p_irat_cdma_params->
                    cell_reselection_params_1xrtt.t_reselection_cdma2000_sf);
            p_rrc_resel_cdma2000_sf = &(p_rrc_resel_params_1xrtt->
                    t_reselection_cdma2000_sf);
            switch(p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_medium)
            {
                case RRM_OAM_O_DOT_25:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_O_DOT_25;
                    break;
                case RRM_OAM_O_DOT_5:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_O_DOT_5;
                    break;
                case RRM_OAM_O_DOT_75:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_O_DOT_75;
                    break;
                case RRM_OAM_l_DOT_0:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_l_DOT_0;
                    break;
                default:
                    p_rrc_resel_cdma2000_sf->sf_medium = 
                        p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_medium;

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Wrong value received for t_reselection_eutra_sf_medium 1XRTT\
                            = %d, CDMA2000",p_rrmcm_resel_cdma2000_sf->
                            t_reselection_eutra_sf_medium);
            }
            switch(p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_high)
            {
                case RRM_OAM_O_DOT_25:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_O_DOT_25;
                    break;
                case RRM_OAM_O_DOT_5:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_O_DOT_5;
                    break;
                case RRM_OAM_O_DOT_75:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_O_DOT_75;
                    break;
                case RRM_OAM_l_DOT_0:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_l_DOT_0;
                    break;
                default:
                    p_rrc_resel_cdma2000_sf->sf_high =
                        p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_high;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Wrong value received for t_reselection_eutra_sf_high 1XRTT\
                            = %d, CDMA2000", p_rrmcm_resel_cdma2000_sf->
                            t_reselection_eutra_sf_high);
            }
        }
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_cdma2000_1xrtt
 *   INPUT       : p_ran_info
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function updates the cdma2000 1xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
update_cdma2000_1xrtt
(
 // rrm_cell_context_t  *p_rrm_cell_context,
 ran_t               *p_ran_info,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_irat_cdma_params = RRM_PNULL;
    /*
       p_irat_cdma_params = &((p_rrm_cell_context->p_new_reconfig_data)->ran_info.mobility_params.
       idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);
     */
    p_irat_cdma_params = &((p_ran_info->mobility_params).
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);


    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_1_xrtt.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG)
    {
        /*
           update_csfb_reg_1_xrtt_params(p_rrm_cell_context,
           &(p_sib_type_8_Info->params_1_xrtt.csfb_reg_param_1_xrtt));
         */
        update_csfb_reg_1_xrtt_params(p_ran_info,
                &(p_sib_type_8_Info->params_1_xrtt.csfb_reg_param_1_xrtt));
        p_sib_type_8_Info->presence_bitmask |=
            CFSB_REG_PARAM_1_XRTT_PRESENCE_FLAG;
    }

    /* No Need to fill long_code_state_1_xrtt */

    update_reselection_cdma2000_1xrtt_params( p_irat_cdma_params,
            &(p_sib_type_8_Info->params_1_xrtt.
                cell_reselection_params_1_xrtt));

    /* Setting Bitmask for 1XRTT Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_1_XRTT_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}



/*  SIB 8 changes End   */





/****************************************************************************
 *   FUNCTION NAME       :   rrm_son_map_params_cdma2000_hrpd_1xrtt
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the cdma2000 hrpd 1xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
rrm_son_map_params_cdma2000_hrpd_1xrtt
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    RRM_UT_TRACE_ENTER();

    /* Mapping of HRPD struct starts */
    rrm_son_map_cdma2000_hrpd(p_rrm_cell_context, p_sib_type_8_Info);
    /* Mapping of HRPD struct ends */

    /* Mapping of 1XRTT struct starts */
    rrm_son_map_cdma2000_1xrtt(p_rrm_cell_context, p_sib_type_8_Info);
    /* Mapping of 1XRTT struct ends */

    if(p_rrm_cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT)
    {
        if(p_rrm_cell_context->ran_info.ncl_params.bitmask & 
                RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
        {
            rrm_son_map_hrpd_1xrtt_ncl_list(
                    p_rrm_cell_context, 
                    p_sib_type_8_Info);
        }
    }

    RRM_UT_TRACE_EXIT();
}






/****************************************************************************
 *   FUNCTION NAME       :   map_params_cdma2000_hrpd_1xrtt
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the cdma2000 hrpd 1xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_params_cdma2000_hrpd_1xrtt
(
 rrm_cell_context_t  *p_rrm_cell_context,
 /* Start 7514 NRT Fix - SIB 8 */
 ncl_params_t            *p_ncl_params,
 /* End 7514 NRT Fix - SIB 8 */
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    RRM_UT_TRACE_ENTER();

    /* Mapping of HRPD struct starts */
    map_cdma2000_hrpd(p_rrm_cell_context, p_sib_type_8_Info);
    /* Mapping of HRPD struct ends */

    /* Mapping of 1XRTT struct starts */
    map_cdma2000_1xrtt(p_rrm_cell_context, p_sib_type_8_Info);
    /* Mapping of 1XRTT struct ends */

    /* Start 7514 NRT Fix - SIB 8 */
    if(p_ncl_params->inter_rat_ncl.num_valid_cdma2000_freq_cells > RRM_ZERO)
    {
        map_hrpd_1xrtt_ncl_list(
                p_rrm_cell_context,
                &p_ncl_params->inter_rat_ncl,
                p_sib_type_8_Info);
    }
    /* End 7514 NRT Fix - SIB 8 */

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   rrm_son_map_cdma2000_hrpd
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the cdma2000 hrpd params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
rrm_son_map_cdma2000_hrpd
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_irat_cdma_params = RRM_PNULL;
    params_hrpd_t       *p_params_hrpd = RRM_PNULL;

    p_irat_cdma_params = &(p_rrm_cell_context->p_meas_config_sib_info_for_reconfig->
            cdma_params.idle_mode_mobility_irat_cdma_params);

    p_params_hrpd = &(p_sib_type_8_Info->params_hrpd);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_hrpd.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask & RRMCM_RMIF_PRE_REG_INFO_HRPD_PRESENCE_FLAG)
    {
        map_pre_reg_info_hrpd(p_irat_cdma_params, p_params_hrpd);
    }

    map_reselection_cdma2000_hrpd_params(p_params_hrpd, p_irat_cdma_params);

    /* Setting Bitmask for HRPD Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_HRPD_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}




/****************************************************************************
 *   FUNCTION NAME       :   rrm_son_map_cdma2000_1xrtt
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the cdma2000 hrpd 1xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
rrm_son_map_cdma2000_1xrtt
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_irat_cdma_params = RRM_PNULL;
    /*coverity 23144:removing "p_params_hrpd":, rel 1.3*/
    p_irat_cdma_params = &(p_rrm_cell_context->p_meas_config_sib_info_for_reconfig->
            cdma_params.idle_mode_mobility_irat_cdma_params);

    //p_params_hrpd = &(p_sib_type_8_Info->params_hrpd);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_1_xrtt.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG)
    {
        /* Fix for reconfig 27/06/2013 */
        map_csfb_reg_1_xrtt_params(p_irat_cdma_params,
                &(p_sib_type_8_Info->params_1_xrtt.csfb_reg_param_1_xrtt));
        p_sib_type_8_Info->params_1_xrtt.presence_bitmask |=
            CFSB_REG_PARAM_1_XRTT_PRESENCE_FLAG;
    }

    /* No Need to fill long_code_state_1_xrtt */

    map_reselection_cdma2000_1xrtt_params( p_irat_cdma_params,
            &(p_sib_type_8_Info->params_1_xrtt));

    /* Setting Bitmask for 1XRTT Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_1_XRTT_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}








/****************************************************************************
 *   FUNCTION NAME       :   map_cdma2000_hrpd
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the cdma2000 hrpd params coming from MIF to RRC
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_cdma2000_hrpd
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_irat_cdma_params = RRM_PNULL;
    params_hrpd_t       *p_params_hrpd = RRM_PNULL;

    p_irat_cdma_params = &(p_rrm_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_params_hrpd = &(p_sib_type_8_Info->params_hrpd);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_hrpd.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask & RRMCM_RMIF_PRE_REG_INFO_HRPD_PRESENCE_FLAG)
    {
        map_pre_reg_info_hrpd(p_irat_cdma_params, p_params_hrpd);
    }

    map_reselection_cdma2000_hrpd_params(p_params_hrpd, p_irat_cdma_params);

    /* Setting Bitmask for HRPD Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_HRPD_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_cdma2000_1xrtt
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the cma2000 1xrtt params coming from MIF to RRC
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_cdma2000_1xrtt
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_irat_cdma_params = RRM_PNULL;
    /*coverity 23144:removing "p_params_hrpd":, rel 1.3*/

    p_irat_cdma_params = &(p_rrm_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    //p_params_hrpd = &(p_sib_type_8_Info->params_hrpd);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_1_xrtt.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG)
    {
        /* Fix for reconfig 27/06/2013 */
        map_csfb_reg_1_xrtt_params(p_irat_cdma_params,
                &(p_sib_type_8_Info->params_1_xrtt.csfb_reg_param_1_xrtt));
        p_sib_type_8_Info->params_1_xrtt.presence_bitmask |=
            CFSB_REG_PARAM_1_XRTT_PRESENCE_FLAG;
    }

    /* No Need to fill long_code_state_1_xrtt */

    map_reselection_cdma2000_1xrtt_params( p_irat_cdma_params,
            &(p_sib_type_8_Info->params_1_xrtt));

    /* Setting Bitmask for 1XRTT Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_1_XRTT_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reselection_cdma2000_1xrtt_params
 *   INPUT       : p_irat_cdma_params
 *   OUTPUT      : p_params_1_xrtt
 *   DESCRIPTION :
 *          This function Maps the reselection cdma2000 1xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_reselection_cdma2000_1xrtt_params
(
 rrmcm_idle_mode_mobility_irat_cdma_params_t    *p_irat_cdma_params,
 params_1_xrtt_t                                *p_params_1_xrtt
 )
{
    speed_scale_factors_t    *p_rrmcm_resel_cdma2000_sf = RRM_PNULL;
    speed_state_scale_factors_t  *p_rrc_resel_cdma2000_sf = RRM_PNULL;
    cell_reselection_params_cdma2000_t             *p_rrc_resel_params_1xrtt = RRM_PNULL;

    p_rrc_resel_params_1xrtt = &(p_params_1_xrtt->cell_reselection_params_1_xrtt);
    RRM_UT_TRACE_ENTER();

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
    {
        map_bandclass_list(&(p_irat_cdma_params->
                    cell_reselection_params_1xrtt.band_class_list),
                &(p_rrc_resel_params_1xrtt->band_class_list));
        p_rrc_resel_params_1xrtt->t_reselection_cdma2000 = 
            p_irat_cdma_params->cell_reselection_params_1xrtt.
            t_reselection_cdma2000;

        if(p_irat_cdma_params->cell_reselection_params_1xrtt.
                presence_bitmask & RRMCM_RMIF_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG)
        {
            p_rrmcm_resel_cdma2000_sf = &(p_irat_cdma_params->
                    cell_reselection_params_1xrtt.t_reselection_cdma2000_sf);
            p_rrc_resel_cdma2000_sf = &(p_rrc_resel_params_1xrtt->
                    t_reselection_cdma2000_sf);
            switch(p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_medium)
            {
                case RRM_OAM_O_DOT_25:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_O_DOT_25;
                    break;
                case RRM_OAM_O_DOT_5:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_O_DOT_5;
                    break;
                case RRM_OAM_O_DOT_75:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_O_DOT_75;
                    break;
                case RRM_OAM_l_DOT_0:
                    p_rrc_resel_cdma2000_sf->sf_medium = RRM_OAM_l_DOT_0;
                    break;
                default:
                    p_rrc_resel_cdma2000_sf->sf_medium = 
                        p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_medium;

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Wrong value received for t_reselection_eutra_sf_medium 1XRTT\
                            = %d, CDMA2000",p_rrmcm_resel_cdma2000_sf->
                            t_reselection_eutra_sf_medium);
            }
            switch(p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_high)
            {
                case RRM_OAM_O_DOT_25:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_O_DOT_25;
                    break;
                case RRM_OAM_O_DOT_5:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_O_DOT_5;
                    break;
                case RRM_OAM_O_DOT_75:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_O_DOT_75;
                    break;
                case RRM_OAM_l_DOT_0:
                    p_rrc_resel_cdma2000_sf->sf_high = RRM_OAM_l_DOT_0;
                    break;
                default:
                    p_rrc_resel_cdma2000_sf->sf_high =
                        p_rrmcm_resel_cdma2000_sf->t_reselection_eutra_sf_high;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Wrong value received for t_reselection_eutra_sf_high 1XRTT\
                            = %d, CDMA2000", p_rrmcm_resel_cdma2000_sf->
                            t_reselection_eutra_sf_high);
            }
            p_rrc_resel_params_1xrtt->presence_bitmask = RRM_ZERO;
            p_rrc_resel_params_1xrtt->presence_bitmask |= CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;
        }
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_bandclass_list
 *   INPUT       : p_rrmcm_band_class_list
 *   OUTPUT      : P_rrc_band_class_list
 *   DESCRIPTION :
 *          This function Maps the bandclass list coming from MIF to RRC  
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_bandclass_list
(
 rrmcm_rmif_band_class_list_cdma2000_t  *p_rrmcm_band_class_list,
 band_class_list_cdma2000_t             *P_rrc_band_class_list
 )
{
    U8 valid_band_class = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    P_rrc_band_class_list->count = p_rrmcm_band_class_list->count;

    for(valid_band_class = RRM_ZERO; 
            valid_band_class < p_rrmcm_band_class_list->count; valid_band_class++)
    {
        P_rrc_band_class_list->band_class_info_cdma2000[valid_band_class].
            band_class = p_rrmcm_band_class_list->
            band_class_info_cdma2000[valid_band_class].band_class;

        if(p_rrmcm_band_class_list->band_class_info_cdma2000[valid_band_class].
                presence_bitmask & 
                RRMCM_RMIF_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG)
        {
            P_rrc_band_class_list->band_class_info_cdma2000[valid_band_class].
                cell_reselection_priority = p_rrmcm_band_class_list->
                band_class_info_cdma2000[valid_band_class].
                cell_reselection_priority;

            P_rrc_band_class_list->band_class_info_cdma2000[valid_band_class].
                presence_bitmask |= 
                BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;
        }

        P_rrc_band_class_list->band_class_info_cdma2000[valid_band_class].
            thresh_x_high = p_rrmcm_band_class_list->
            band_class_info_cdma2000[valid_band_class].thresh_x_high;
        P_rrc_band_class_list->band_class_info_cdma2000[valid_band_class].
            thresh_x_low = p_rrmcm_band_class_list->
            band_class_info_cdma2000[valid_band_class].thresh_x_low;
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reselection_cdma2000_hrpd_params
 *   INPUT       : p_params_hrpd
 *   OUTPUT      : p_irat_cdma_params
 *   DESCRIPTION :
 *          This function Maps the reselection cdma2000 hrpd params coming from MIF to RRC
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_reselection_cdma2000_hrpd_params
(
 params_hrpd_t                                *p_params_hrpd,
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params
 )
{
    cell_reselection_params_cdma2000_t  
        *p_rrc_resel_params_cdma2000 = RRM_PNULL;
    speed_scale_factors_t         *p_rrmcm_resel_params_cdma2000_sf = RRM_PNULL;

    p_rrc_resel_params_cdma2000 = &(p_params_hrpd->
            cell_reselection_params_hrpd);

    p_rrmcm_resel_params_cdma2000_sf = &(p_irat_cdma_params->
            cell_reselection_params_hrpd.t_reselection_cdma2000_sf);

    RRM_UT_TRACE_ENTER();

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG)
    {
        map_bandclass_list(
                &(p_irat_cdma_params->cell_reselection_params_hrpd.
                    band_class_list), 
                &(p_rrc_resel_params_cdma2000->band_class_list));

        p_rrc_resel_params_cdma2000->t_reselection_cdma2000 = 
            p_irat_cdma_params->cell_reselection_params_hrpd.t_reselection_cdma2000;

        switch(p_rrmcm_resel_params_cdma2000_sf->t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_O_DOT_25;
                break;

            case RRM_OAM_O_DOT_5 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = RRM_OAM_l_DOT_0;
                break;
            default:
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_medium = p_rrmcm_resel_params_cdma2000_sf->
                    t_reselection_eutra_sf_medium;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong value received for t_reselection_eutra_sf_medium HRPD\
                        = %d, CDMA2000", p_rrmcm_resel_params_cdma2000_sf->
                        t_reselection_eutra_sf_medium);
        }

        switch(p_rrmcm_resel_params_cdma2000_sf->t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_O_DOT_25;
                break;

            case RRM_OAM_O_DOT_5 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_O_DOT_5;
                break;

            case RRM_OAM_O_DOT_75 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0 :
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_rrc_resel_params_cdma2000->t_reselection_cdma2000_sf.
                    sf_high = p_rrmcm_resel_params_cdma2000_sf->
                    t_reselection_eutra_sf_high;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong value received for t_reselection_eutra_sf_high \
                        = %d, CDMA2000", p_rrmcm_resel_params_cdma2000_sf->
                        t_reselection_eutra_sf_high);
        }


        /* Re-setting Bitmask for RESELECT_CDMA2000_SF */
        p_rrc_resel_params_cdma2000->presence_bitmask = RRM_ZERO;

        /* Setting Bitmask for RESELECT_CDMA2000_SF */
        p_rrc_resel_params_cdma2000->presence_bitmask |=
            CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   rrm_son_map_hrpd_1xrtt_ncl_list
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the hrpd 1xrtt ncl list params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
rrm_son_map_hrpd_1xrtt_ncl_list
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info)
{
    U16    valid_cdma2000_freq_cells = RRM_ZERO;
    U16    cdma2000_freq_cells = RRM_ZERO;
    neigh_cell_list_cdma2000_t  *p_neigh_cell_list_cdma2000 = RRM_PNULL;
    inter_rat_ncl_t     *p_inter_rat_ncl = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma = RRM_PNULL;
    U8  valid_1xrtt_cell_index = RRM_ZERO;
    U8  valid_hrpd_cell_index = RRM_ZERO;
    /* CID 54923*/
    /* Coverity_fix_start_54923 */
    S32  HRPD_FOUND = RRM_ONE;
    /* CID 54923*/
    S32  XRTT_FOUND = RRM_ONE;
    /* Coverity_fix_end_54923 */
    U8  valid_cell_index = RRM_ZERO;
    rrm_bool_et  XRTT_CELL_FOUND = RRM_FALSE;
    rrm_bool_et  HRPD_CELL_FOUND = RRM_FALSE;

    rrmcm_rmif_cdma2000_freq_cells_t *p_cdma2000_freq_cells = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_cdma2000_freq_cells = p_rrm_cell_context->p_meas_config_sib_info_for_reconfig->
        cdma_params.cdma2000_freq_cells;

    p_inter_rat_ncl = &(p_rrm_cell_context->ran_info.ncl_params.inter_rat_ncl);


    p_irat_cdma = &(p_rrm_cell_context->p_meas_config_sib_info_for_reconfig->
            cdma_params.idle_mode_mobility_irat_cdma_params);

    valid_cdma2000_freq_cells = p_rrm_cell_context->p_meas_config_sib_info_for_reconfig->
        cdma_params.num_valid_cdma2000_freq_cells;

    /* Check for DAHO Cells */
    if(p_irat_cdma->cdma2000_cell_param.bitmask & 
            RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_1xrtt_cell_index = RRM_ZERO;
                valid_1xrtt_cell_index < valid_cdma2000_freq_cells;
                valid_1xrtt_cell_index++)
        {
            XRTT_FOUND = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_1xrtt_cell_index].CID),
                    RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);
            if(!XRTT_FOUND)
            {
                break;
            }
        }
    }

    if(p_irat_cdma->cdma2000_cell_param.bitmask & 
            RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_hrpd_cell_index = RRM_ZERO;
                valid_hrpd_cell_index < valid_cdma2000_freq_cells;
                valid_hrpd_cell_index++)
        {
            HRPD_FOUND = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_hrpd_cell_index].CID),
                    RRM_CDMA2000_HRPD_CELL_ID_LENGTH);
            if(!HRPD_FOUND)
            {
                break;
            }
        }
    }



    /* Loop for checking & setting bitmask for Cell Resel Params for 1XRTT, HRPD Cells */
    for(valid_cell_index = RRM_ZERO;
            valid_cell_index < valid_cdma2000_freq_cells;
            valid_cell_index++)
    {
        if((valid_cell_index == valid_hrpd_cell_index) || (valid_cell_index == valid_1xrtt_cell_index))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    "DAHO Cell index found, continuing search in ncl [%u]", valid_cell_index);
            continue;
        }

        if(RRM_OAM_NCL_TYPE_1XRTT == p_cdma2000_freq_cells[valid_cell_index].type)
        {
            XRTT_CELL_FOUND = RRM_TRUE;
        }
        else if(RRM_OAM_NCL_TYPE_HRPD == p_cdma2000_freq_cells[valid_cell_index].type)
        {
            HRPD_CELL_FOUND = RRM_TRUE;
        }
        if(XRTT_CELL_FOUND)
        {
            /* Set bitmask */
            p_sib_type_8_Info->params_1_xrtt.presence_bitmask |=
                CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Setting Bitmask for CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG");
        }
        if(HRPD_CELL_FOUND)
        {
            /* Set bitmask */
            p_sib_type_8_Info->params_hrpd.presence_bitmask |=
                PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Setting Bitmask for PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG");
        }
    }



    for(cdma2000_freq_cells = RRM_ZERO; 
            cdma2000_freq_cells < valid_cdma2000_freq_cells; cdma2000_freq_cells++)
    {
        if(!XRTT_FOUND || !HRPD_FOUND)
        {
            if((cdma2000_freq_cells == valid_hrpd_cell_index) || 
                    (cdma2000_freq_cells == valid_1xrtt_cell_index))
            {
                continue;
            }
        }
        switch(p_cdma2000_freq_cells[cdma2000_freq_cells].type)
        {
            case RRM_OAM_NCL_TYPE_1XRTT:
                {
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_1_xrtt.
                            cell_reselection_params_1_xrtt.neigh_cell_list);

                    rrm_son_map_cell_reselection_params_cdma2000(p_neigh_cell_list_cdma2000,
                            /*SPR 17777 +-*/
                            p_cdma2000_freq_cells,
                            cdma2000_freq_cells);
                            /*SPR 17777 +-*/
                    break;
                }
            case RRM_OAM_NCL_TYPE_HRPD:
                {
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_hrpd.
                            cell_reselection_params_hrpd.neigh_cell_list);
                    rrm_son_map_cell_reselection_params_cdma2000(p_neigh_cell_list_cdma2000,
                            /*SPR 17777 +-*/
                            p_cdma2000_freq_cells,
                            cdma2000_freq_cells);
                            /*SPR 17777 +-*/
                    break;
                }
            default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Wrong Value received for type in NCL : CDMA2000");
        }
    }

    RRM_UT_TRACE_EXIT();
}




/****************************************************************************
 *   FUNCTION NAME       :   map_hrpd_1xrtt_ncl_list
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_sib_type_8_Info
 *   DESCRIPTION :
 *          This function Maps the hrpd 1xrtt ncl list params
 *
 *   RETURNS     : none

 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_hrpd_1xrtt_ncl_list
(
 rrm_cell_context_t  *p_rrm_cell_context,
 /* Start 7514 NRT Fix - SIB 8 */
 inter_rat_ncl_t     *p_inter_rat_ncl,
 /* End 7514 NRT Fix - SIB 8 */
 sib_type_8_Info_t   *p_sib_type_8_Info)
{
    U16    valid_cdma2000_freq_cells = RRM_ZERO;
    U16    cdma2000_freq_cells = RRM_ZERO;
    neigh_cell_list_cdma2000_t  *p_neigh_cell_list_cdma2000 = RRM_PNULL;
    neigh_cell_list_cdma2000_v920_t  *p_cell_resel_cdma2000_v920 = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma = RRM_PNULL;
    U8  valid_1xrtt_cell_index = RRM_ZERO;
    U8  valid_hrpd_cell_index = RRM_ZERO;
    /* CID 54922*/
    /* Coverity_fix_start_54922 */
    S32  HRPD_FOUND = RRM_ONE;
    /* CID 54922*/
    S32  XRTT_FOUND = RRM_ONE;
    /* Coverity_fix_end_54922 */
    /* SPR 15235 fix */

    RRM_UT_TRACE_ENTER();

    /* Start 7514 NRT Fix - SIB 8 :delete */

    p_irat_cdma = &(p_rrm_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    valid_cdma2000_freq_cells = p_inter_rat_ncl->num_valid_cdma2000_freq_cells;

    /* Check for DAHO Cells */
    if(p_irat_cdma->cdma2000_cell_param.bitmask & 
            RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_1xrtt_cell_index = RRM_ZERO;
                valid_1xrtt_cell_index < valid_cdma2000_freq_cells;
                valid_1xrtt_cell_index++)
        {
            XRTT_FOUND = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_1xrtt_cell_index].CID),
                    RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);
            if(!XRTT_FOUND)
            {
                break;
            }
        }
    }

    if(p_irat_cdma->cdma2000_cell_param.bitmask & 
            RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_hrpd_cell_index = RRM_ZERO;
                valid_hrpd_cell_index < valid_cdma2000_freq_cells;
                valid_hrpd_cell_index++)
        {
            HRPD_FOUND = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_hrpd_cell_index].CID),
                    RRM_CDMA2000_HRPD_CELL_ID_LENGTH);
            if(!HRPD_FOUND)
            {
                break;
            }
        }
    }
    /* SPR 15235 Fix- Code moved to switch case- because if neighbor is found 
     * then only bitmask is to be set */



    for(cdma2000_freq_cells = RRM_ZERO; 
            cdma2000_freq_cells < valid_cdma2000_freq_cells; cdma2000_freq_cells++)
    {
        if(!XRTT_FOUND || !HRPD_FOUND)
        {
            /*SPR_16913_START*/
            if(((cdma2000_freq_cells == valid_hrpd_cell_index) || 
                    (cdma2000_freq_cells == valid_1xrtt_cell_index))&&(valid_hrpd_cell_index != RRM_ZERO && valid_1xrtt_cell_index != RRM_ZERO))
            /*SPR_16913_END*/    
            {
                continue;
            }
        }

        /*check for daho cell based on daho indication.
          Dont broadcast daho cell*/
        if(RRM_TRUE == p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].daho_indication)
        {
            continue;
        }
        switch(p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].type)
        {
            case RRM_OAM_NCL_TYPE_1XRTT:
                {
                    /* SPR 15235 Fix start */
                    /* Set bitmask */
                    p_sib_type_8_Info->params_1_xrtt.presence_bitmask |=
                        CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                            "Setting Bitmask for CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG");
                    /* SPR 15235 Fix end */
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_1_xrtt.
                            cell_reselection_params_1_xrtt.neigh_cell_list);

                    p_cell_resel_cdma2000_v920 = &(p_sib_type_8_Info->
                            cell_reselection_params_1_xrtt_v920.neigh_cell_list_v920);

                    map_cell_reselection_params_cdma2000(p_neigh_cell_list_cdma2000,
                            p_cell_resel_cdma2000_v920,
                            p_inter_rat_ncl,
                            cdma2000_freq_cells,
                            p_sib_type_8_Info);

                    break;
                }
            case RRM_OAM_NCL_TYPE_HRPD:
                {
                    /* SPR 15235 Fix start */
                    /* Set bitmask */
                    p_sib_type_8_Info->params_hrpd.presence_bitmask |=
                        PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Setting Bitmask for PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG");
                    /* SPR 15235 Fix end */
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_hrpd.
                            cell_reselection_params_hrpd.neigh_cell_list);
                    p_cell_resel_cdma2000_v920 = &(p_sib_type_8_Info->
                            cell_reselection_params_hrpd_v920.neigh_cell_list_v920);
                    map_cell_reselection_params_cdma2000(p_neigh_cell_list_cdma2000,
                            p_cell_resel_cdma2000_v920,
                            p_inter_rat_ncl,
                            cdma2000_freq_cells,
                            p_sib_type_8_Info);

                    break;
                }
            default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Wrong Value received for type in NCL : CDMA2000");
        }
    }

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 *   FUNCTION NAME       :   rrm_son_map_cell_reselection_params_cdma2000
 *   INPUT       : p_cell_resel_cdma2000_v920,p_inter_rat_ncl,p_cdma2000_freq_cells,
 cdma2000_freq_cells,p_sib_type_8_Info
 *   OUTPUT      : p_neigh_cell_list_cdma2000
 *   DESCRIPTION :
 *          This function Maps the cell reselection params cdma2000
 *
 *   RETURNS     : none
 *****************************************************************************/
void
rrm_son_map_cell_reselection_params_cdma2000
(
 neigh_cell_list_cdma2000_t         *p_neigh_cell_list_cdma2000,
    /*SPR 17777 +-*/
 rrmcm_rmif_cdma2000_freq_cells_t   *p_cdma2000_freq_cells,
 U8                                  cdma2000_freq_cells
    /*SPR 17777 +-*/
 )
{
    U8     cdma2000_bandclass = RRM_ZERO;
    U8     band_class_found = RRM_ZERO;
    U8     cdma2000_arfcn = RRM_ZERO;
    U8     arfcn_found = RRM_ZERO;
    U8     valid_pci_index = RRM_ZERO;
    U8     valid_count_arfcn = RRM_ZERO;
    U8     valid_pci_count = RRM_ZERO;
    U8     valid_bandclass_count = RRM_ZERO;
    U8     valid_arfcn_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Setting First element in CDMA2000 NCL list */
    if(RRM_ZERO == p_neigh_cell_list_cdma2000->count)
    {
        (p_neigh_cell_list_cdma2000->count)++;

        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].band_class =
            p_cdma2000_freq_cells[cdma2000_freq_cells].band_class;

        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
         neigh_cells_per_freq_list.count)++;

        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
            arfcn = p_cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
         neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
         phys_cell_id_list.count)++;

        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
            phys_cell_id_list.phys_cell_id_cdma2000[RRM_ZERO] = 
            p_cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;
    }
    else if((RRM_ZERO < p_neigh_cell_list_cdma2000->count) && 
            (RRM_SIXTEEN > p_neigh_cell_list_cdma2000->count))
    {
        for(cdma2000_bandclass=RRM_ZERO; 
                cdma2000_bandclass < p_neigh_cell_list_cdma2000->count; cdma2000_bandclass++)
        {
            if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                        band_class) == 
                    p_cdma2000_freq_cells[cdma2000_freq_cells].band_class)
            {
                /* Set Flag for BandClass */
                band_class_found = RRM_TRUE;

                for(cdma2000_arfcn=RRM_ZERO;
                        cdma2000_arfcn < (p_neigh_cell_list_cdma2000->
                            neigh_cell_cdma2000[cdma2000_bandclass].
                            neigh_cells_per_freq_list.count); 
                        cdma2000_arfcn++)
                {
                    if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                arfcn) ==
                            p_cdma2000_freq_cells[cdma2000_freq_cells].arfcn)
                    {
                        /* Set Flag for ARFCN */
                        arfcn_found = RRM_TRUE;

                        valid_pci_index = p_neigh_cell_list_cdma2000->
                            neigh_cell_cdma2000[cdma2000_bandclass].
                            neigh_cells_per_freq_list.
                            neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                            phys_cell_id_list.count;

                        if(valid_pci_index < RRM_SIXTEEN)
                        {
                            /* Assign PCI & increment count for PCI */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_index] = 
                                p_cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                             neigh_cells_per_freq_list.
                             neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                             phys_cell_id_list.count)++;
                        }
                        break;
                    }
                }
                break;
            }
        }

        /* Fill ARFCN & increment the count value */
        if(band_class_found && !arfcn_found)
        {
            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
             neigh_cells_per_freq_list.count)++;
            valid_count_arfcn = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.count;

            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.
                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].arfcn =
                p_cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

            valid_pci_count = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.
                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].
                phys_cell_id_list.count; 

            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.
                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] 
                = p_cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
             neigh_cells_per_freq_list.
             neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
             phys_cell_id_list.count)++; 
        }
        /* If Bandclass doesn't matches: Increment count for Bandclass & assign values */
        if(!band_class_found)
        {
            valid_bandclass_count = p_neigh_cell_list_cdma2000->count;

            /* Assign BandClass */
            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].band_class =
                p_cdma2000_freq_cells[cdma2000_freq_cells].band_class;

            valid_arfcn_index = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.count;

            /* Assign ARFCN */
            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                arfcn = p_cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

            valid_pci_count = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                phys_cell_id_list.count;

            /* Assign PCI */
            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] 
                = p_cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

            /* Increment counter for Bandclass, ARFCN, PCI */
            (p_neigh_cell_list_cdma2000->count)++;

            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
             neigh_cells_per_freq_list.count)++;

            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
             neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
             phys_cell_id_list.count)++;
        }
    }

    RRM_UT_TRACE_EXIT();
}




/****************************************************************************
 *   FUNCTION NAME       :   map_cell_reselection_params_cdma2000
 *   INPUT       : p_cell_resel_cdma2000_v920,p_inter_rat_ncl,cdma2000_freq_cells
 p_sib_type_8_Info
 *   OUTPUT      : p_neigh_cell_list_cdma2000                  
 *   DESCRIPTION :
 *          This function Maps the cell reselection params for cdma2000
 *
 *   RETURNS     : none
 *****************************************************************************/
void
map_cell_reselection_params_cdma2000
(
 neigh_cell_list_cdma2000_t         *p_neigh_cell_list_cdma2000,
 neigh_cell_list_cdma2000_v920_t    *p_cell_resel_cdma2000_v920,
 inter_rat_ncl_t                    *p_inter_rat_ncl,
 U8                                  cdma2000_freq_cells,
 sib_type_8_Info_t                  *p_sib_type_8_Info
 )
{
    U8     cdma2000_bandclass = RRM_ZERO;
    U8     band_class_found = RRM_ZERO;
    U8     cdma2000_arfcn = RRM_ZERO;
    U8     arfcn_found = RRM_ZERO;
    U8     valid_pci_index = RRM_ZERO;
    U8     valid_count_arfcn = RRM_ZERO;
    U8     valid_pci_count = RRM_ZERO;
    U8     valid_bandclass_count = RRM_ZERO;
    U8     valid_arfcn_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Setting First element in CDMA2000 NCL list */
    if(RRM_ZERO == p_neigh_cell_list_cdma2000->count)
    {
        (p_neigh_cell_list_cdma2000->count)++;

        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].band_class =
            p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].band_class;

        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
         neigh_cells_per_freq_list.count)++;

        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
            arfcn = p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

        (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
         neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
         phys_cell_id_list.count)++;

        p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[RRM_ZERO].
            neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[RRM_ZERO].
            phys_cell_id_list.phys_cell_id_cdma2000[RRM_ZERO] = 
            p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;
    }
    else if((RRM_ZERO < p_neigh_cell_list_cdma2000->count) && 
            (RRM_SIXTEEN > p_neigh_cell_list_cdma2000->count))
    {
        for(cdma2000_bandclass=RRM_ZERO; 
                cdma2000_bandclass < p_neigh_cell_list_cdma2000->count; cdma2000_bandclass++)
        {
            if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                        band_class) == (p_inter_rat_ncl->
                            cdma2000_freq_cells[cdma2000_freq_cells].band_class))
            {
                /* Set Flag for BandClass */
                band_class_found = RRM_TRUE;

                for(cdma2000_arfcn=RRM_ZERO;
                        cdma2000_arfcn < (p_neigh_cell_list_cdma2000->
                            neigh_cell_cdma2000[cdma2000_bandclass].
                            neigh_cells_per_freq_list.count); 
                        cdma2000_arfcn++)
                {
                    if((p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                arfcn) == (p_inter_rat_ncl->
                                    cdma2000_freq_cells[cdma2000_freq_cells].arfcn))
                    {
                        /* Set Flag for ARFCN */
                        arfcn_found = RRM_TRUE;

                        valid_pci_index = p_neigh_cell_list_cdma2000->
                            neigh_cell_cdma2000[cdma2000_bandclass].
                            neigh_cells_per_freq_list.
                            neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                            phys_cell_id_list.count;

                        if(valid_pci_index < RRM_SIXTEEN)
                        {
                            /* Assign PCI & increment count for PCI */
                            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                                neigh_cells_per_freq_list.
                                neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_index] = 
                                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                             neigh_cells_per_freq_list.
                             neigh_cells_per_bandclass_cdma2000[cdma2000_arfcn].
                             phys_cell_id_list.count)++;
                        }

                        /* If list is full then fill list for v920 */
                        else if(RRM_SIXTEEN == valid_pci_index)
                        {
                            /*
                               if(RRM_ZERO == p_cell_resel_cdma2000_v920->count)
                               {*/

                            /* Incrementing the count for Bandclass */
                            (p_cell_resel_cdma2000_v920->count)++;
                            /* Incrementing the count for ARFCN */
                            (p_cell_resel_cdma2000_v920->neigh_cell_cdma2000_v920[band_class_found].
                             neigh_cells_per_freq_list_v920.count)++;

                            valid_pci_index = p_cell_resel_cdma2000_v920->
                                neigh_cell_cdma2000_v920[band_class_found].
                                neigh_cells_per_freq_list_v920.
                                neigh_cells_per_bandclass_cdma2000_v920[arfcn_found].
                                phys_cell_id_list_v920.count;

                            /* Assign PCI */
                            p_cell_resel_cdma2000_v920->neigh_cell_cdma2000_v920[band_class_found].
                                neigh_cells_per_freq_list_v920.
                                neigh_cells_per_bandclass_cdma2000_v920[arfcn_found].
                                phys_cell_id_list_v920.phys_cell_id_cdma2000_v920[valid_pci_index] = 
                                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

                            /* Incrementing the count for PCI */
                            (p_cell_resel_cdma2000_v920->neigh_cell_cdma2000_v920[band_class_found].
                             neigh_cells_per_freq_list_v920.
                             neigh_cells_per_bandclass_cdma2000_v920[arfcn_found].phys_cell_id_list_v920.
                             count)++;

                            if(RRM_OAM_NCL_TYPE_1XRTT == 
                                    p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].type)
                            {
                                p_sib_type_8_Info->presence_bitmask |= 
                                    SIB_8_CELL_RESEL_PARAMS_1_XRTT_V920_PRESENCE_FLAG;
                            }
                            else if(RRM_OAM_NCL_TYPE_HRPD ==
                                    p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].type)
                            {
                                p_sib_type_8_Info->presence_bitmask |=
                                    SIB_8_CELL_RESEL_PARAMS_HRPD_V920_PRESENCE_FLAG;
                            }
                            /*
                               }*/
                        }
                        break;
                    }
                }
                break;
            }
        }

        /* Fill ARFCN & increment the count value */
        if(band_class_found && !arfcn_found)
        {
            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
             neigh_cells_per_freq_list.count)++;
            valid_count_arfcn = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.count;

            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.
                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].arfcn =
                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

            valid_pci_count = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.
                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn - RRM_ONE)].
                phys_cell_id_list.count; 

            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
                neigh_cells_per_freq_list.
                neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] =  p_inter_rat_ncl->
                cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[cdma2000_bandclass].
             neigh_cells_per_freq_list.
             neigh_cells_per_bandclass_cdma2000[(valid_count_arfcn-RRM_ONE)].
             phys_cell_id_list.count)++; 
        }
        /* If Bandclass doesn't matches: Increment count for Bandclass & assign values */
        if(!band_class_found)
        {
            valid_bandclass_count = p_neigh_cell_list_cdma2000->count;

            /* Assign BandClass */
            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].band_class =
                p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].band_class;

            valid_arfcn_index = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.count;

            /* Assign ARFCN */
            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                arfcn = p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].arfcn;

            valid_pci_count = p_neigh_cell_list_cdma2000->
                neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                phys_cell_id_list.count;

            /* Assign PCI */
            p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
                neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
                phys_cell_id_list.phys_cell_id_cdma2000[valid_pci_count] =  p_inter_rat_ncl->
                cdma2000_freq_cells[cdma2000_freq_cells].pn_offset;

            /* Increment counter for Bandclass, ARFCN, PCI */
            (p_neigh_cell_list_cdma2000->count)++;

            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
             neigh_cells_per_freq_list.count)++;

            (p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[valid_bandclass_count].
             neigh_cells_per_freq_list.neigh_cells_per_bandclass_cdma2000[valid_arfcn_index].
             phys_cell_id_list.count)++;
        }
    }
    /* Resetting FLAGS */
    /* Coverity 76513 fix Start */
   /* band_class_found = RRM_FALSE;
    arfcn_found = RRM_FALSE;*/
    /* Coverity 76513 fix End */

    RRM_UT_TRACE_EXIT();
}


/* Fix for reconfig 27/06/2013 */
/****************************************************************************
 *   FUNCTION NAME       :   map_csfb_reg_1_xrtt_params
 *   INPUT       : p_rrm_cell_context
 *   OUTPUT      : p_csfb_reg_param_1_xrtt
 *   DESCRIPTION :
 *          This function Maps the csfb reg 1 xrtt params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_csfb_reg_1_xrtt_params
(
 rrmcm_idle_mode_mobility_irat_cdma_params_t    *p_irat_cdma_params,
 csfb_reg_param_1_xrtt_t  *p_csfb_reg_param_1_xrtt
 )
{
    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->sid,
            p_irat_cdma_params->mobility_sib_8_params.sid,
            RRMCM_RMIF_XRTT_SID_OCTET_SIZE);
    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->nid,
            p_irat_cdma_params->mobility_sib_8_params.nid,
            RRMCM_RMIF_XRTT_NID_OCTET_SIZE);
    p_csfb_reg_param_1_xrtt->multiple_sid = p_irat_cdma_params->
        mobility_sib_8_params.multiple_sid;
    p_csfb_reg_param_1_xrtt->multiple_nid = p_irat_cdma_params->
        mobility_sib_8_params.multiple_nid;
    p_csfb_reg_param_1_xrtt->home_reg = p_irat_cdma_params->
        mobility_sib_8_params.home_reg;
    p_csfb_reg_param_1_xrtt->foreign_sid_reg = p_irat_cdma_params->
        mobility_sib_8_params.foreign_nid_reg;
    p_csfb_reg_param_1_xrtt->foreign_nid_reg = p_irat_cdma_params->
        mobility_sib_8_params.foreign_nid_reg;
    p_csfb_reg_param_1_xrtt->parame_reg = p_irat_cdma_params->
        mobility_sib_8_params.parame_reg;
    p_csfb_reg_param_1_xrtt->power_up_reg = p_irat_cdma_params->
        mobility_sib_8_params.power_up_reg;
    p_csfb_reg_param_1_xrtt->reg_period[RRM_ZERO] = 
        p_irat_cdma_params->mobility_sib_8_params.reg_prd;

    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->reg_zone,
            p_irat_cdma_params->mobility_sib_8_params.reg_zone,
            RRMCM_RMIF_XRTT_REG_ZONE_OCTET_SIZE);
    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->total_zone,
            p_irat_cdma_params->mobility_sib_8_params.total_zone,
            RRMCM_RMIF_XRTT_TOTAL_ZONE_OCTET_SIZE);
    RRM_MEMCPY(p_csfb_reg_param_1_xrtt->zone_timer,
            p_irat_cdma_params->mobility_sib_8_params.zone_timer,
            RRMCM_RMIF_XRTT_ZONE_TIMER_OCTET_SIZE);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_pre_reg_info_hrpd
 *   INPUT       : p_irat_cdma_params
 *   OUTPUT      : p_params_hrpd
 *   DESCRIPTION :
 *          This function Maps the pre reg info for hrpd
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_pre_reg_info_hrpd
(
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params,
 params_hrpd_t    *p_params_hrpd
 )
{
    U8  valid_pre_reg_zone = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_params_hrpd->pre_reg_info_hrpd.pre_reg_allowed = 
        p_irat_cdma_params->pre_reg_info_hrpd.pre_reg_allowed;

    if(p_irat_cdma_params->pre_reg_info_hrpd.presence_bitmask & 
            RRMCM_RMIF_PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG)
    {
        p_params_hrpd->pre_reg_info_hrpd.pre_reg_zone_id = 
            p_irat_cdma_params->pre_reg_info_hrpd.pre_reg_zone_id;
        p_params_hrpd->pre_reg_info_hrpd.presence_bitmask |=
            PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG;
    }
    if(p_irat_cdma_params->pre_reg_info_hrpd.presence_bitmask & 
            RRMCM_RMIF_PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG)
    {
        p_params_hrpd->pre_reg_info_hrpd.secondary_list.
            count = p_irat_cdma_params->pre_reg_info_hrpd.secondary_list.
            count;
        for(valid_pre_reg_zone=RRM_ZERO; 
                valid_pre_reg_zone < p_irat_cdma_params->pre_reg_info_hrpd.
                secondary_list.count; valid_pre_reg_zone++)
        {
            p_params_hrpd->pre_reg_info_hrpd.secondary_list.
                pre_reg_zone_id[valid_pre_reg_zone] = p_irat_cdma_params->
                pre_reg_info_hrpd.secondary_list.
                pre_reg_zone_id[valid_pre_reg_zone];
        }
        /* Setting Bitmask for PRE_REG_INFO_HRPD_SECONDARY_LST */
        p_params_hrpd->pre_reg_info_hrpd.
            presence_bitmask |= PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 *   FUNCTION NAME       :   map_ac_barring_config_1_xrtt_r9
 *   INPUT       : p_rrm_ac_barring_config_1_xrtt_r9
 *   OUTPUT      : p_rrc_ac_barring_config_1_xrtt_r9
 *   DESCRIPTION :
 *          This function Maps the access barring config 1 xrtt r9 params
 *
 *   RETURNS     : none
 *****************************************************************************/
/* COMP_WARN_1_FEB:compilation warning removal */
rrm_void_t
map_ac_barring_config_1_xrtt_r9
(
 rrmcm_rmif_ac_barring_config_1_xrtt_r9_t  *p_rrm_ac_barring_config_1_xrtt_r9,
 ac_barring_config_1_xrtt_r9_t    *p_rrc_ac_barring_config_1_xrtt_r9
 )
{
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_0_to_9_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_0_to_9_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_10_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_10_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_11_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_11_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_12_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_12_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_13_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_13_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_14_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_14_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_15_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_15_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_msg_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_msg_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_reg_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_reg_r9;
    p_rrc_ac_barring_config_1_xrtt_r9->ac_barring_emg_r9 = 
        p_rrm_ac_barring_config_1_xrtt_r9->ac_barring_emg_r9;
}

/* CDMA2000 changes ends */

/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_9
 *   INPUT       : cell_context
 *   OUTPUT      : p_sib_type_9_info
 *   DESCRIPTION :
 *    		This function Maps the sib type 9 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_sib_type_9
(
 rrm_cell_context_t *cell_context, 
 sib_type_9_Info_t  *p_sib_type_9_info
 )
{
    U8                hnb_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_sib_type_9_info->presence_bitmask = RRM_ZERO;
    p_sib_type_9_info->size_of_hnb_id = cell_context->access_mgmt_params.hnb_name_size;
    if (RRM_ZERO != p_sib_type_9_info->size_of_hnb_id)
    {
        p_sib_type_9_info->presence_bitmask |= SIB_9_HNB_ID_PRESENCE_FLAG;

        for(hnb_count=0; hnb_count < p_sib_type_9_info->size_of_hnb_id; hnb_count++)
        {
            p_sib_type_9_info->hnb_id[hnb_count] = 
                cell_context->access_mgmt_params.hnb_name[hnb_count];
        }
    }
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_cell_config_param
 *   INPUT       : cell_context
 *   OUTPUT      : p_cell_config_info
 *   DESCRIPTION :
 *    		This function Maps the cell config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_cell_config_param
(
 rrm_cell_context_t    *cell_context, 
 rrc_rrm_cell_config_t *p_cell_config_info
 )
{
    RRM_UT_TRACE_ENTER();

    cell_parameters(cell_context, &p_cell_config_info->cell_parameters);

    sync_signals(cell_context,&p_cell_config_info->sync_signals);

    mac_config(cell_context,&p_cell_config_info->mac_config);

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   map_cdma2000_cell_param_cdma2000_param_hrpd
 *   INPUT       : p_cdma2000_cell_param_cell
 *   OUTPUT      : p_cdma2000_cell_param_rrc
 *   DESCRIPTION :
 *          This function Maps the cdma2000 cell params coming from MIF to RRC
 *
 *   RETURNS     : none
 *****************************************************************************/
    rrm_void_t
map_cdma2000_cell_param_cdma2000_param_hrpd(rrmcm_rmif_cdma2000_cell_param_t  *p_cdma2000_cell_param_cell,
        cdma2000_cell_param_t             *p_cdma2000_cell_param_rrc )
{
    U8 hrpd_cell_id_len = RRM_ZERO;
    U8 valid_hrpd_cell_id_len = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG &
            p_cdma2000_cell_param_cell->bitmask)
    {
        valid_hrpd_cell_id_len = RRM_CDMA2000_HRPD_CELL_ID_LENGTH;
        p_cdma2000_cell_param_rrc->sector_id_hrpd.sector_id_length = 
            valid_hrpd_cell_id_len;

        for(hrpd_cell_id_len = RRM_ZERO; hrpd_cell_id_len < valid_hrpd_cell_id_len;
                hrpd_cell_id_len++)
        {
            p_cdma2000_cell_param_rrc->sector_id_hrpd.sector_id[hrpd_cell_id_len] =
                p_cdma2000_cell_param_cell->cell_id_hrpd.
                cdma2000_hrpd_cell_id[hrpd_cell_id_len];
        }
        p_cdma2000_cell_param_rrc->bitmask |=
            CDMA2000_PARAM_HRPD_SECTOR_ID_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for CDMA2000_PARAM_HRPD_SECTOR_ID_PRESENCE_FLAG");
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/****************************************************************************
 *   FUNCTION NAME       :   map_cdma2000_cell_param
 *   INPUT       : p_cdma2000_cell_param_cell
 *   OUTPUT      : p_cdma2000_cell_param_rrc
 *   DESCRIPTION :
 *          This function Maps the cdma2000 cell params coming from MIF to RRC
 *
 *   RETURNS     : none
 *****************************************************************************/
rrm_void_t
map_cdma2000_cell_param
(
 rrmcm_rmif_cdma2000_cell_param_t  *p_cdma2000_cell_param_cell,
 cdma2000_cell_param_t             *p_cdma2000_cell_param_rrc
 )
{
    RRM_UT_TRACE_ENTER();

    p_cdma2000_cell_param_rrc->bitmask = RRM_ZERO;

    p_cdma2000_cell_param_rrc->cdma2000_rand.rand_seed =
        p_cdma2000_cell_param_cell->cdma2000_rand.rand_seed;
    p_cdma2000_cell_param_rrc->cdma2000_rand.rand_min =
        p_cdma2000_cell_param_cell->cdma2000_rand.rand_min;
    p_cdma2000_cell_param_rrc->cdma2000_rand.rand_max =
        p_cdma2000_cell_param_cell->cdma2000_rand.rand_max;
    p_cdma2000_cell_param_rrc->cdma2000_rand.rand_regenerate_timer =
        p_cdma2000_cell_param_cell->cdma2000_rand.rand_regenerate_timer;

    p_cdma2000_cell_param_rrc->cdma2000_rand.bitmask |=
        CDMA2000_PARAM_RAND_MIN_PRESENCE_FLAG;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Setting Bitmask for CDMA2000_PARAM_RAND_MIN_PRESENCE_FLAG");

    p_cdma2000_cell_param_rrc->cdma2000_rand.bitmask |=
        CDMA2000_PARAM_RAND_MAX_PRESENCE_FLAG;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Setting Bitmask for CDMA2000_PARAM_RAND_MAX_PRESENCE_FLAG");

    if(RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG &
            p_cdma2000_cell_param_cell->bitmask)
    {
        RRM_MEMCPY(&(p_cdma2000_cell_param_rrc->cell_id_1xrtt.cdma2000_1xrtt_cell_id),
                (p_cdma2000_cell_param_cell->cell_id_1xrtt.cdma2000_1xrtt_cell_id),
                (sizeof(U8) * RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH));

        p_cdma2000_cell_param_rrc->bitmask |= 
            CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG");
    }
    /*Klockwork_fix_start*/
    map_cdma2000_cell_param_cdma2000_param_hrpd(p_cdma2000_cell_param_cell ,p_cdma2000_cell_param_rrc );
    /*Klockwork_fix_end*/
    /* CSR 00070260 FIX START */
    if( RRMCM_RMIF_CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG &
            p_cdma2000_cell_param_cell->bitmask)
    {
        RRM_MEMCPY((p_cdma2000_cell_param_rrc->ref_cell_id_1xrtt.cdma2000_1xrtt_ref_cell_id),
                (p_cdma2000_cell_param_cell->cdma2000_1xrtt_reference_cell_id),
                RRM_CDMA2000_1XRTT_REFERENCE_CELL_ID_LENGTH);

        p_cdma2000_cell_param_rrc->bitmask |= 
            CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG");
    }
    if( RRMCM_RMIF_CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG &
            p_cdma2000_cell_param_cell->bitmask)
    {
        RRM_MEMCPY((p_cdma2000_cell_param_rrc->ref_sector_id_hrpd.cdma2000_hrpd_ref_sector_id),
                (p_cdma2000_cell_param_cell->cdma2000_hrpd_reference_cell_id),
                RRM_CDMA2000_HRPD_REFERENCE_CELL_ID_LENGTH);

        p_cdma2000_cell_param_rrc->bitmask |= 
            CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG");
    }
    /* CSR 00070260 FIX END */
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   cell_parameters
 *
 *   DESCRIPTION :
 *    		This function Maps the physical cell params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
cell_parameters
(
 rrm_cell_context_t        *cell_context,
 rrc_phy_cell_parameters_t *p_phy_cell_param
 )
{
    RRM_UT_TRACE_ENTER();

    p_phy_cell_param->dl_earfcn = cell_context->ran_info.rf_params.rf_configurations.dl_earfcn;
    p_phy_cell_param->num_of_antennas = cell_context->ran_info.antenna_info.antenna_ports_count_number;
    p_phy_cell_param->subcarrier_spacing = 
        cell_context->operator_info.cell_params.sub_carrier_spacing;
    p_phy_cell_param->dl_cyclic_prefix = cell_context->operator_info.cell_params.dl_cyclic_prefix;
    p_phy_cell_param->rb_size = cell_context->operator_info.cell_params.rb_size;
    p_phy_cell_param->phys_cell_id = cell_context->ran_info.rf_params.rf_configurations.phy_cell_id;
    /* LTE_RRM_CONFIG cell configuration prarams coming from rrm_oam.cfg*/ 
    p_phy_cell_param->max_rs_epre = cell_context->operator_info.cell_params.max_rs_epre;


    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   sync_signals
 *
 *   DESCRIPTION :
 *    		This function Maps the sync signals params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
sync_signals
(
 rrm_cell_context_t     *cell_context, 
 rrc_phy_sync_signals_t *p_phy_sync_signals_info
 )
{
    U16            pci = RRM_ZERO;
    U8             n1_count = RRM_ZERO;
    U8             n2_count = RRM_ZERO;
    rrm_bool_et    flag = RRM_FALSE;
    U8 pci_values_m1_m2[RRM_MAX_M1_VALUES][RRM_MAX_M2_VALUES] = { {0, 1}/* 0 */, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6},
        {6, 7}, {7, 8}, {8, 9}, {9, 10}, {10, 11}/* 10 */, 
        {11, 12}, {12, 13}, {13, 14}, {14, 15}, {15, 16},
        {16, 17}, {17, 18}, {18, 19}, {19, 20}, {20, 21}/* 20 */, 
        {21, 22}, {22, 23}, {23, 24}, {24, 25}, {25, 26}, 
        {26, 27}, {27, 28}, {28, 29}, {29, 30},	{0, 2}/* 30 */, 
        {1, 3}, {2, 4}, {3, 5}, {4, 6}, {5, 7}, {6, 8}, 
        {7, 9}, {8, 10}, {9, 11}, {10, 12}/* 40 */, 
        {11, 13}, {12, 14}, {13, 15}, {14, 16}, {15, 17},
        {16, 18}, {17, 19}, {18, 20}, {19, 21}, {20, 22}/* 50 */, 
        {21, 23}, {22, 24}, {23, 25}, {24, 26}, {25, 27}, 
        {26, 28}, {27, 29}, {28, 30}, {0, 3}, {1, 4}/* 60 */, 
        {2, 5}, {3, 6}, {4, 7}, {5, 8}, {6, 9}, {7, 10}, 
        {8, 11}, {9, 12}, {10, 13}, {11, 14}/* 70 */, 
        {12, 15}, {13, 16}, {14, 17}, {15, 18}, {16, 19}, 
        {17, 20}, {18, 21}, {19, 22}, {20, 23}, {21, 24}/* 80 */, 
        {22, 25}, {23, 26}, {24, 27}, {25, 28}, {26, 29}, 
        {27, 30}, {0, 4}, {1, 5}, {2, 6}, {3, 7}/* 90 */, 
        {4, 8}, {5, 9}, {6, 10}, {7, 11}, {8, 12}, {9, 13}, 
        {10, 14}, {11, 15}, {12, 16}, {13, 17}/* 100 */, 
        {14, 18}, {15, 19}, {16, 20}, {17, 21}, {18, 22}, 
        {19, 23}, {20, 24}, {21, 25}, {22, 26},	{23, 27}/* 110 */, 
        {24, 28}, {25, 29}, {26, 30}, {0, 5}, {1, 6}, 
        {2, 7}, {3, 8}, {4, 9}, {5, 10}, {6, 11}/* 120 */, 
        {7, 12}, {8, 13}, {9, 14}, {10, 15}, {11, 16}, 
        {12, 17}, {13, 18}, {14, 19}, {15, 20},	{16, 21}/* 130 */, 
        {17, 22}, {18, 23}, {19, 24}, {20, 25}, {21, 26}, 
        {22, 27}, {23, 28}, {24, 29}, {25, 30},	{0, 6}/* 140 */, 
        {1, 7}, {2, 8}, {3, 9}, {4, 10}, {5, 11}, {6, 12}, 
        {7, 13}, {8, 14}, {9, 15}, {10, 16}/* 150 */, 
        {11, 17}, {12, 18}, {13, 19}, {14, 20}, {15, 21}, 
        {16, 22}, {17, 23}, {18, 24}, {19, 25},	{20, 26}/* 160 */, 
        {21, 27}, {22, 28}, {23, 29}, {24, 30}, {0, 7}, {1, 8}, 
        {2, 9} };

    RRM_UT_TRACE_ENTER();

    p_phy_sync_signals_info->prim_syn_signal_power = 
        (cell_context->ran_info.rf_params.rf_configurations.psch_power_offset)/RRM_TEN;
    p_phy_sync_signals_info->sec_syn_signal_power = 
        (cell_context->ran_info.rf_params.rf_configurations.ssch_power_offset)/RRM_TEN;

    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
    pci = cell_context->ran_info.rf_params.rf_configurations.phy_cell_id;
    /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/
    if(RRM_MAX_PCI_VALUE > pci)
    {
        for(n1_count=RRM_ZERO; n1_count<RRM_MAX_N1; n1_count++)	/* value of N1 can be 0,1,2 */
        {
            for(n2_count=RRM_ZERO; n2_count<RRM_MAX_N2; n2_count++)	/*value of N2 can be 0 to 167*/
            {
                if(pci == (RRM_THREE * n2_count + n1_count))
                {
                    p_phy_sync_signals_info->sec_syn_signal_m_seq1 = pci_values_m1_m2[n2_count][RRM_ZERO];
                    p_phy_sync_signals_info->sec_syn_signal_m_seq2 = pci_values_m1_m2[n2_count][RRM_ONE];
                    flag = RRM_TRUE;
                    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
                    break;
                    /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/
                }
            }
            if(RRM_TRUE == flag)
            {
                break;
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,  
                "Wrong Value of Phy Cell Id received");
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/*SPR_12535_FIX_START*/

/****************************************************************************
 *   FUNCTION NAME       :   get_dl_res_block_from_dl_bandwidth_for_cell_configuration
 *
 *   DESCRIPTION :
 *       This function will calculate the value of dl_res_blocks from 
 *		dl_bandwidth
 *
 *   RETURNS     :
 *       U8 value
 *****************************************************************************/
U8
get_dl_res_block_from_dl_bandwidth_for_cell_configuration
(
 rrm_cell_context_t *p_cell_context
 )
{
    U8           value = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            value = RRM_BW_N6;
            break;
        case RRM_OAM_BW_N_15:
            value = RRM_BW_N15;
            break;
        case RRM_OAM_BW_N_25:
            value = RRM_BW_N25;
            break;
        case RRM_OAM_BW_N_50:
            value = RRM_BW_N50;
            break;
        case RRM_OAM_BW_N_75:
            value = RRM_BW_N75;
            break;
        case RRM_OAM_BW_N_100:
            value = RRM_BW_N100;
            break;
        default :
            value = p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                    " dl_bandwith = %u",
                    p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth);
            break;
    }

    RRM_UT_TRACE_EXIT();
    return value;
}

/****************************************************************************
 *   FUNCTION NAME       :   get_ul_res_block_from_ul_bandwidth_for_cell_configuration
 *   INPUT       : cell_context
 *   OUTPUT      : 
 *   DESCRIPTION :
 *       This function will calculate the value of ul_res_blocks from
 *       ul_bandwidth
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
U8
get_ul_res_block_from_ul_bandwidth_for_cell_configuration
(
 rrm_cell_context_t *p_cell_context
 )
{
    U8          value = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            value = RRM_BW_N6;
            break;
        case RRM_OAM_BW_N_15:
            value = RRM_BW_N15;
            break;
        case RRM_OAM_BW_N_25:
            value = RRM_BW_N25;
            break;
        case RRM_OAM_BW_N_50:
            value = RRM_BW_N50;
            break;
        case RRM_OAM_BW_N_75:
            value = RRM_BW_N75;
            break;
        case RRM_OAM_BW_N_100:
            value = RRM_BW_N100;
            break;
        default :
            value = p_cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                    " ul_bandwith = %u",
                    p_cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth);
            break;
    }

    RRM_UT_TRACE_EXIT();
    return value;
}
/*SPR_12535_FIX_END*/




/****************************************************************************
 *   FUNCTION NAME       :   fill_mac_config_scheduling_info_list
 *   INPUT       : si_window_length, p_rrm_scheduling_info
 *   OUTPUT      : p_mac_config_si_info
 *   DESCRIPTION :
 *              This function Maps the mac config scheduling info list to RRC
 *
 *   RETURNS     : none
 *****************************************************************************/
    rrm_void_t
fill_mac_config_scheduling_info_list(rrm_si_window_length_et                 si_window_length,  
        rrc_si_transmission_info_list_t         *p_mac_config_si_info,
        const rrm_scheduling_info_list_t        *p_rrm_scheduling_info)
{
    U8 		          index   = RRM_ZERO;
    U8                offset_index = RRM_ZERO;
    U8		          si_start_offset = RRM_ZERO;
    U8              subframe_num    = RRM_ZERO;
    U8              si_window_length_ms = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    rrm_get_window_lenth_in_ms(si_window_length , &si_window_length_ms);
    p_mac_config_si_info->count = p_rrm_scheduling_info->count;

    for( index = RRM_ZERO; index < p_mac_config_si_info->count; index++ )
    {

        p_mac_config_si_info->si_transmission[index].bitmask = RRM_ZERO;

        p_mac_config_si_info->si_transmission[index].si_index = index;

        p_mac_config_si_info->si_transmission[index].bitmask |=
            RRC_RRM_NUM_OF_TRANSMISSIONS_PRESENT;
        p_mac_config_si_info->si_transmission[index].num_of_transmissions 
            = RRM_ONE;

        p_mac_config_si_info->si_transmission[index].bitmask |=
            RRC_RRM_SI_START_OFFSET_INFO_PRESENT;
        p_mac_config_si_info->si_transmission[index].si_start_offset_info.
            offset_count = RRM_ONE;

        subframe_num = (index * si_window_length_ms ) % RRM_MAX_SUBFRAME ;

        if( RRM_FIVE  ==  subframe_num )  
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "SIB [%d] collision with SIB 1 . Set si_offset as 1",
                    p_rrm_scheduling_info->scheduling_info[index].sib_mapping_info.sib_type[RRM_ZERO]+RRM_THREE);
            si_start_offset = RRM_ONE;
        }
        else
        {
            si_start_offset = RRM_ZERO;
        }


        for(offset_index = RRM_ZERO; offset_index < 
                p_mac_config_si_info->si_transmission[index].si_start_offset_info.
                offset_count; offset_index++ )
        {
            p_mac_config_si_info->si_transmission[index].si_start_offset_info.
                si_start_offset[offset_index].si_start_offset = si_start_offset;
            si_start_offset++; 
        }
    }

    RRM_UT_TRACE_EXIT(); 

}
/****************************************************************************
 *   FUNCTION NAME       : fill_mac_prs_config
 *   INPUT       : cell_context->
 *   OUTPUT      : p_mac_config_info
 *   DESCRIPTION :
 *    		This function Maps the PRS config params coming from MIF to RRC
 *
 *   RETURNS     :
 *****************************************************************************/
rrm_void_t
fill_mac_prs_config
(
 prs_t              *p_cellm_prs_config,
 rrc_mac_config_t   *p_mac_config_info
 )
{
    RRM_UT_TRACE_ENTER();
    if(p_cellm_prs_config != RRM_PNULL && p_mac_config_info != RRM_PNULL)
    {
        if(p_cellm_prs_config->prs_enable == RRM_TRUE)
        {
            p_mac_config_info->bitmask |=RRC_RRM_PRS_CONFIG_INFO_PRESENT;
            p_mac_config_info->prs_config_info.bitmask |= RRC_RRM_CONFIG_PRS_CONFIG_PRESENT ;

            p_mac_config_info->prs_config_info.request_type                  = RRM_TRUE;

            p_mac_config_info->prs_config_info.prs_config.prs_bandwidth_info.prs_bandwidth                   =
                p_cellm_prs_config->num_prs_resource_blocks;

            p_mac_config_info->prs_config_info.prs_config.prs_subframes_info.prs_subframes                   =
                p_cellm_prs_config->num_consecutive_prs_subfames;

            p_mac_config_info->prs_config_info.prs_config.prs_config_index_info.prs_config_index             =
                p_cellm_prs_config->prs_configuration_index;

            p_mac_config_info->prs_config_info.prs_config.prs_transmission_power_info.prs_transmission_power =
                p_cellm_prs_config->prs_transmission_power;

            if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_TWO_PRESENT)
            {
                p_mac_config_info->prs_config_info.prs_config.bitmask |=  RRC_RRM_CONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;

                /*spr_13268_fix_start */

                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_config->prs_muting_configration.muting_config_two;

                /*spr_13268_fix_end */

                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N2;

            }
            else if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_FOUR_PRESENT)
            {
                p_mac_config_info->prs_config_info.prs_config.bitmask |=  RRC_RRM_CONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;

                /*spr_13268_fix_start */

                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_config->prs_muting_configration.muting_config_four;

                /*spr_13268_fix_end */


                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N4;
            }
            else if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_EIGHT_PRESENT)
            {
                p_mac_config_info->prs_config_info.prs_config.bitmask |=  RRC_RRM_CONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_config->prs_muting_configration.muting_config_eight;
                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N8;
            }
            else if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT)
            {
                p_mac_config_info->prs_config_info.prs_config.bitmask |=  RRC_RRM_CONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_config->prs_muting_configration.muting_config_sixteen;
                p_mac_config_info->prs_config_info.prs_config.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N16;
            }
        }
        else
        {
            /* SPR 950: code changes start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "prs_enable is false");
            /* SPR 950: code changes end */
        }
    }
    else
    {

    }
    RRM_UT_TRACE_EXIT(); 
}


/****************************************************************************
 *   FUNCTION NAME       :   mac_config
 *   INPUT       : cell_context
 *   OUTPUT      : p_mac_config_info
 *   DESCRIPTION :
 *    		This function Maps the mac config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
mac_config
(
 rrm_cell_context_t *cell_context, 
 rrc_mac_config_t   *p_mac_config_info
 )
{
    /* SPR_19066_START */
    /* Code deleted */
    /* SPR_19066_END */
    U8 index = RRM_ZERO;
    /* SPR_19066_START */
    /* Code deleted */
    /* SPR_19066_END */
    /* SPR 23209 FIXED START */
    U8 plmn_count = RRM_ZERO;
    /* SPR 23209 FIXED END */
    RRM_UT_TRACE_ENTER();

    p_mac_config_info->bitmask = RRM_ZERO;
    p_mac_config_info->dl_res_blocks = get_dl_res_block_from_dl_bandwidth_for_cell_configuration(cell_context);

    /* Bug 602 Fix Start */
#ifdef TDD_MODE_FLAG 
    p_mac_config_info->ul_res_blocks = get_dl_res_block_from_dl_bandwidth_for_cell_configuration(cell_context);
#else
    if(cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth)
    {
        p_mac_config_info->ul_res_blocks = get_ul_res_block_from_ul_bandwidth_for_cell_configuration(cell_context);
    }
    else
    {
        p_mac_config_info->ul_res_blocks = get_dl_res_block_from_dl_bandwidth_for_cell_configuration(cell_context);
    }
#endif
    /* Bug 602 Fix End */

    p_mac_config_info->max_harq_retrans = cell_context->operator_info.rrm_mac_config.max_harq_retrans;

    p_mac_config_info->start_ra_rnti_range = 
        cell_context->operator_info.rrm_mac_config.start_rarnti_range;

    p_mac_config_info->end_ra_rnti_range = 
        cell_context->operator_info.rrm_mac_config.end_rarnti_range;

    p_mac_config_info->bitmask |= RRC_MAC_ENABLE_FREQUENCY_SELECTIVE_SCHEDULING_PRESENT;
    p_mac_config_info->enable_frequency_selective_scheduling.ul_freq_selective_enable = 
        cell_context->operator_info.
        rrm_mac_config.enable_frequency_selective_scheduling.ul_freq_selective_enable ;
    p_mac_config_info->enable_frequency_selective_scheduling.dl_freq_selective_enable = 
        cell_context->operator_info.
        rrm_mac_config.enable_frequency_selective_scheduling.dl_freq_selective_enable;
    /* SPR_19066_START */
    /* Code deleted */
    /* SPR_19066_END */

    p_mac_config_info->contention_free_rach_timer = 
        cell_context->operator_info.contention_free_rach_timer;
    /* SPR 20866 Fix Start */
    p_mac_config_info->bitmask |= RRC_RRM_CONTENTION_FREE_RACH_TIMER_PRESENT;
    /* SPR 20866 Fix End */
    /*Hard coding removed value was 6000*/ 
    p_mac_config_info->downlink_power_control_common.pcfichPowerOffset  = 
        cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset;

    p_mac_config_info->downlink_power_control_common.phichPowerOffset = 
        cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset;

    p_mac_config_info->downlink_power_control_common.pdcchPowerOffset = 
        cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pdcchPowerOffset;

    p_mac_config_info->downlink_power_control_common.pbchTransmissionPower = 
        cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pbchTransmissionPower;

    p_mac_config_info->downlink_power_control_common.pchTransmissionpower = 
        cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pchTransmissionpower;

    p_mac_config_info->bitmask |=RRC_MAC_TPC_RNTI_PRESENT;
    p_mac_config_info->tpc_rnti_range.startTpcRntiPucch =
        cell_context->operator_info.rrm_mac_config.
        mac_tpc_rnti_range.startTpcRntiPucch;
    p_mac_config_info->tpc_rnti_range.endTpcRntiPucch =
        cell_context->operator_info.rrm_mac_config.
        mac_tpc_rnti_range.endTpcRntiPucch;
    p_mac_config_info->tpc_rnti_range.startTpcRntiPusch =
        cell_context->operator_info.rrm_mac_config.
        mac_tpc_rnti_range.startTpcRntiPusch;
    p_mac_config_info->tpc_rnti_range.endTpcRntiPusch =
        cell_context->operator_info.rrm_mac_config.
        mac_tpc_rnti_range.endTpcRntiPusch;

    p_mac_config_info->bitmask |= RRC_MAC_POWER_CONTROL_PRESENT;
    p_mac_config_info->power_control_enable.harqBlerClpcPucchEnable =
        cell_context->operator_info.rrm_mac_config.
        mac_power_control_enable.harqBlerClpcPucchEnable;

    p_mac_config_info->power_control_enable.cqiSinrClpcPucchEnable =
        cell_context->operator_info.rrm_mac_config.
        mac_power_control_enable.cqiSinrClpcPucchEnable;

    p_mac_config_info->power_control_enable.clpcPuschEnable =
        cell_context->operator_info.rrm_mac_config.
        mac_power_control_enable.clpcPuschEnable;

    p_mac_config_info->power_control_enable.pdcchPowOrAggregationEnable =
        cell_context->operator_info.rrm_mac_config.
        mac_power_control_enable.pdcchPowOrAggregationEnable;

    p_mac_config_info->power_control_enable.clpcPuschfreqSelectiveEnable =
        cell_context->operator_info.rrm_mac_config.
        mac_power_control_enable.clpcPuschfreqSelectiveEnable;

    /* LTE_RRM_CONFIG_START configuration for cell setup coming from rrm_oam.cfg */
    p_mac_config_info->bitmask |= RRC_RRM_PUCCH_CQI_SINR_THRESHOLD_PRESENT;
    /* BUG_371 FIX START */
    /* p_mac_config_info->pucch_cqi_sinr_value = 
       cell_context->operator_info.rrm_mac_config.pucch_cqi_sinr_value;*/
    p_mac_config_info->pucch_cqi_sinr_value = 
        cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.pucch_cqi_sinr_value;

    p_mac_config_info->bitmask |= RRC_RRM_UL_SYNC_LOSS_TIMER_PRESENT;
    /*p_mac_config_info->ul_sync_loss_timer = 
      (U8)cell_context->operator_info.rrm_mac_config.ul_sync_loss_timer;*/
    p_mac_config_info->ul_sync_loss_timer = 
        (U8)cell_context->ran_info.mac_layer_params.ul_sync_loss_timer;
    /* BUG_371 FIX END */

    /*CSR:00047975 - FIX STARTS */
    p_mac_config_info->dci_format_for_si_msgs = cell_context->operator_info.
        rrm_mac_config.rrm_dci_format_for_si_msg ;
    /*CSR:00047975 - FIX ENDS */
    if (cell_context->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == 
            RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A)
    {
        p_mac_config_info->bitmask |= RRC_RRM_RBS_PER_TBS_DCI_1A_PRESENT;
        for(index = RRM_ZERO; index < RBS_FOR_DCI_1A_SIZE; index++)
        {
            p_mac_config_info->num_rbs_per_tbs_dci_1a[index] = 
                /* + SPR 17665 + */ 
                cell_context->operator_info.rrm_mac_config.num_rbs_per_tbs_dci_1a[index];
            /* - SPR 17665 - */
        }
        /* :  Bug:179 start */
        p_mac_config_info->dci_format_for_si_msgs = RRC_RBS_PER_TBS_DCI_1A; 
        /*: Bug:179 end */
    }
    else if (cell_context->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == 
            RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C)
    {
        p_mac_config_info->bitmask |= RRC_RRM_RBS_PER_TBS_DCI_1C_PRESENT;
        for(index = RRM_ZERO; index < RBS_FOR_DCI_1C_SIZE; index++)
        {
            p_mac_config_info->num_rbs_per_tbs_dci_1c[index] =
                /* + SPR 17665 + */
                cell_context->operator_info.rrm_mac_config.num_rbs_per_tbs_dci_1c[index];
            /* - SPR 17665 - */
        }
    }

    p_mac_config_info->bitmask |= RRC_RRM_N_GAP_PRESENT;
    /* BUG_371 FIX START */
    /* p_mac_config_info->n_gap = cell_context->operator_info.rrm_mac_config.n_gap;*/
    p_mac_config_info->n_gap = cell_context->ran_info.mac_layer_params.n_gap;
    /* BUG_371 FIX END */

    p_mac_config_info->bitmask |= RRC_RRM_SI_TRANSMISSION_INFO_PRESENT;
    fill_mac_config_scheduling_info_list(cell_context->operator_info.sib_1_info.si_window_length,
            &(p_mac_config_info->si_transmission_info),
            &(cell_context->operator_info.sib_1_info.scheduling_info_list));

    /* dynamic pdcch start */
    /* SPR 22016 Start */
    if(RRM_ZERO == cell_context->dynamic_pdcch)
    {
	/* Dynamic PDCCH is disabled */
    	p_mac_config_info->dynamic_pdcch = RRM_ONE;
    }
    else
    {
        /* Dynamic PDCCH is enabled */
    	p_mac_config_info->dynamic_pdcch = RRM_ZERO;
    }
    /* SPR 22016 End */
    p_mac_config_info->bitmask |= RRC_RRM_IS_DYNAMIC_PDCCH_DISABLED_PRESENT;
    /* dynamic pdcch end */
    /* LTE_RRM_CONFIG_END*/

    /* SPS related changes start */
    if( cell_context->operator_info.bitmask & RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT)
    {
        p_mac_config_info->sps_crnti_range.start_sps_crnti =
            cell_context->operator_info.sps_crnti_range_info.start_sps_crnti_range;

        p_mac_config_info->sps_crnti_range.end_sps_crnti =
            cell_context->operator_info.sps_crnti_range_info.end_sps_crnti_range;

        p_mac_config_info->bitmask |= RRC_RRM_SPS_CRNTI_RANGE_PRESENT;
    }
    /* SPS related changes end */
    if(cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT &&
            cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT)
    {
        fill_mac_prs_config(&(cell_context->ran_info.physical_layer_params.physical_layer_param_prs),
                p_mac_config_info);
    }

    /*SPR 23209 FIXED START*/
    p_mac_config_info->mocn_operator_info.num_operator_info = RRM_ZERO;

    for(plmn_count = RRM_ZERO;
            plmn_count < cell_context->epc_info.epc_params.general_epc_params.num_valid_plmn;
            plmn_count++)
    {
        if( cell_context->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].bitmask &
                RRMCM_RMIF_MOCN_OPERATOR_INDENTITY_PRESENT)
        {
            p_mac_config_info->mocn_operator_info.operator_id[
                p_mac_config_info->mocn_operator_info.num_operator_info++] =
                    cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].mocn_operator_identity;
        }
    }
    if(p_mac_config_info->mocn_operator_info.num_operator_info)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "MOCN is Enabled,Operator info sent in cell setup req to L3");
        p_mac_config_info->bitmask |= RRC_RRM_MOCN_OPERATOR_INFO_PRESENT;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "MOCN is disabled, No operator info sent in cell setup req to L3");
    }
    /*SPR 23209 FIXED END*/


/* SPR 19309 + */
    p_mac_config_info->cfi_value = cell_context->ran_info.mac_layer_params.cfi_value;
/* SPR 19309 - */
/* SPR 19310 + */
    p_mac_config_info->num_of_eul = cell_context->ran_info.mac_layer_params.num_of_eul;
    p_mac_config_info->size_of_eul = cell_context->ran_info.mac_layer_params.size_of_eul;
/* SPR 19310 - */
    /*  LAA Rel13 Code + */
    /*  LAA Rel13 Code - */
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :  access_barring_info
 *   INPUT       : cell_context
 *   OUTPUT      : p_access_barring_info
 *   DESCRIPTION :
 *              This function Maps the access barring info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
access_barring_info(
        rrm_cell_context_t     *cell_context,
        access_barring_info_t  *p_access_barring_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(cell_context->ran_info.cell_restriction_params.
            cell_and_access_barring.barring_for_emergency)
    {
        case RRM_FALSE:
            p_access_barring_info->acBarringForEmergency = RRC_FALSE;
            break;

        case RRM_TRUE:
            p_access_barring_info->acBarringForEmergency = RRC_TRUE;
            break;

        default:
            p_access_barring_info->acBarringForEmergency =
                cell_context->ran_info.cell_restriction_params.
                cell_and_access_barring.barring_for_emergency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"Inavlid value of barring_for_emergency: %d",
                    cell_context->ran_info.cell_restriction_params.
                    cell_and_access_barring.barring_for_emergency);
            ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
  MAP_RECONFIG_REQ
 ****************************************************************************/


/* code inherited */






/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_timecell_q_hyst_sf_medium
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates reconf timecall q hyst sf medium
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_timecell_q_hyst_sf_medium(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t	   *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_medium)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium = 
                RRM_RRC_Q_HYST_NEG_SIX;
            break;

        case RRM_OAM_Q_HYST_NEG_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_NEG_FOUR;
            break;

        case RRM_OAM_Q_HYST_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_NEG_TWO;
            break;

        case RRM_OAM_Q_HYST_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.q_hyst_sf_medium;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"invalid value for q_hyst_sf_medium: %d",
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.q_hyst_sf_medium);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_timecell_q_hyst_sf_high
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      ; p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates reconf timecall q hyst sf high
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_timecell_q_hyst_sf_high(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_high)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_NEG_SIX;
            break;

        case RRM_OAM_Q_HYST_NEG_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high = 
                RRM_RRC_Q_HYST_NEG_FOUR;
            break;

        case RRM_OAM_Q_HYST_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_NEG_TWO;
            break;

        case RRM_OAM_Q_HYST_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.q_hyst_sf_high;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"invalid value for q_hyst_sf_high: %d",
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.q_hyst_sf_high);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_timecell_q_hyst_sf_high
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_timecell_t_evaluation(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.t_evaluation)
    {
        case RRM_OAM_T_EVAL_S_30:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_30;
            break;

        case RRM_OAM_T_EVAL_S_60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_60;
            break;

        case RRM_OAM_T_EVAL_S_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_120;
            break;

        case RRM_OAM_T_EVAL_S_180:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_180;
            break;

        case RRM_OAM_T_EVAL_S_240:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_240;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = 
                p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.t_evaluation;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"invalid value for t_evaluation: %d",
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.t_evaluation); 
            ret_val = RRM_FAILURE;
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;

}




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_timecell_t_hyst_normal
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_timecell_t_hyst_normal(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    switch(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.t_hyst_normal)
    {
        case RRM_OAM_T_HYST_NORMAL_S_30:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_30;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_60;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_120;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_180:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_180;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_240:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_240;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =
                p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.t_hyst_normal;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"invalid value for t_hyst_normal: %d",
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.t_hyst_normal);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_timecell_reselect_info_comm
 *   INPUT       : p_cell_context
 *   OUTPUT      ; p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_timecell_reselect_info_comm
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        timecell_reselect_info_comm.presence_bitmask = RRM_ZERO;

    switch(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst)
    {
        case RRM_OAM_Q_HYST_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB0;
            break;

        case RRM_OAM_Q_HYST_DB1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB1;
            break;

        case RRM_OAM_Q_HYST_DB2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB2;
            break;

        case RRM_OAM_Q_HYST_DB3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB3;
            break;

        case RRM_OAM_Q_HYST_DB4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB4;
            break;

        case RRM_OAM_Q_HYST_DB5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB5;
            break;

        case RRM_OAM_Q_HYST_DB6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB6;
            break;

        case RRM_OAM_Q_HYST_DB8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB8;
            break;

        case RRM_OAM_Q_HYST_DB10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB10;
            break;

        case RRM_OAM_Q_HYST_DB12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB12;
            break;

        case RRM_OAM_Q_HYST_DB14:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB14;
            break;

        case RRM_OAM_Q_HYST_DB16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB16;
            break;

        case RRM_OAM_Q_HYST_DB18:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB18;
            break;

        case RRM_OAM_Q_HYST_DB20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB20;
            break;

        case RRM_OAM_Q_HYST_DB22:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB22;
            break;

        case RRM_OAM_Q_HYST_DB24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB24;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst: %d",
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst);
            ret_val = RRM_FAILURE;
    }


    if(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.bitmask & 
            RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            timecell_reselect_info_comm.presence_bitmask |= 
            CELL_RESELECT_SPEED_DEPEND_RESELECT_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            timecell_reselect_info_comm.speed_depend_reselect.
            mobility_state_params.n_cell_change_medium = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            n_cell_change_medium;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            timecell_reselect_info_comm.speed_depend_reselect.
            mobility_state_params.n_cell_change_high = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            n_cell_change_high;
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        /*this function map the sub info :  broken code to make modular*/
        update_reconf_timecell_q_hyst_sf_medium(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        update_reconf_timecell_q_hyst_sf_high(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/	
        update_reconf_timecell_t_evaluation(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        update_reconf_timecell_t_hyst_normal(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/ 
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_sib_type_5_inter_freq_Info
 *   INPUT       : p_reconfig_req_from_mif,p_rrc_rrm_cell_reconfig_req,inter_freq_list,
 p_neigh_count,p_black_count
 *   OUTPUT      : rrc_rrm_cell_reconfig_req_t
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
/* SPR_16103_Start */
update_reconf_sib_type_5_inter_freq_Info(const rrmcm_rmif_cell_reconfig_req_t
					    *p_reconfig_req_from_mif,
				      rrc_rrm_cell_reconfig_req_t
					    *p_rrc_rrm_cell_reconfig_req,
				      U8    inter_freq_list
				      )
/* SPR_16103_End */
{

    rrm_return_et		ret_val = RRM_SUCCESS;
    U8			count = RRM_ZERO;
    U8			inter_freq_cell = RRM_ZERO;
  /* SPR_16103_Start */
  U8			neigh_count = RRM_ZERO;
  U8			black_count = RRM_ZERO;
  /* SPR_16103_End */
    U16			carrier_arfcn = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    count = p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell;
    carrier_arfcn = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].eutra_dl_carrier_freq;


    for(inter_freq_cell = RRM_ZERO; inter_freq_cell < count; inter_freq_cell++ )
    {
        if(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_freq_cell].eutra_carrier_arfcn == carrier_arfcn)
        {
            if(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_freq_cell].blacklisted == RRM_FALSE)
            {
                switch(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                        inter_freq_cells[inter_freq_cell].q_offset)
                {
                    /* Coverity_fix_88508_start */
                    case RRM_Q_OFFSET_RANGE_DB_24:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_24;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_22:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_22;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_20:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_20;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_18:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_18;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_16:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_16;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_14:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_14;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_12:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_12;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_10:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_10;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_8:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_8;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_6:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_6;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_5:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_5;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_4:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_4;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_3:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_3;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_2:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_2;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB_1:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB_1;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB0:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB0;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB1:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB1;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB2:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB2;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB3:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB3;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB4:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB4;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB5:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB5;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB6:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB6;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB8:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB8;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB10:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB10;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB12:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB12;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB14:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB14;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB16:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB16;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB18:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB18;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB20:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB22;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB22:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB22;
                        break;

                    case RRM_Q_OFFSET_RANGE_DB24:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)RRM_RRC_Q_OFFESET_RANGE_DB24;
                        break;
                    /* Coverity_fix_88508_end */
                    default:
                        p_rrc_rrm_cell_reconfig_req->broadcast_info.
                            sib_type_5_Info.inter_freq_carrier_freq_list_list.
                            inter_freq_carrier_freq_list[inter_freq_list].
                            inter_freq_neigh_cell_list.neigh_cell[neigh_count].
                            q_offset_cell = (U8)p_reconfig_req_from_mif->ran_info.ncl_params.
                            lte_ncl.inter_freq_cells[inter_freq_list].q_offset;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"invalid value for q_offset: %d",
                                p_reconfig_req_from_mif->ran_info.ncl_params.
                                lte_ncl.inter_freq_cells[inter_freq_list].q_offset);
                        ret_val = RRM_FAILURE;
                }


            /* SPR_16103_Start */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].inter_freq_neigh_cell_list.neigh_cell[neigh_count].phys_cell_id = p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_freq_cell].phy_cell_id;
            /* SPR_16103_End */
                neigh_count++;

                /*setting bitmask*/
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_CARR_NEIGH_CELL_LIST_PRESENCE_FLAG;
            }

            else if(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_freq_list].blacklisted == RRM_TRUE)
            {

        /* SPR_16103_Start */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].inter_freq_black_listed_cell_list.black_listed_cell[black_count].start = p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_freq_cell].phy_cell_id; 
         /* SPR_16103_End */
                black_count++;

                /*setting bitmask*/
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_CARR_BLACK_LIST_CELL_LIST_PRESENCE_FLAG;
            }
        }
        /*coverity 23154: break commented since for loop exits after 1 execution,  rel1.3.1*/
        //break;
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].inter_freq_neigh_cell_list.count = neigh_count;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].inter_freq_black_listed_cell_list.count = black_count;


         /* SPR_16103_Start */
         /*Code Deleted*/
         /* SPR_16103_End */

    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_sib_type_5_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the sib type 5 for cell reconfig coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_sib_type_5_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    /* SPR_16103_Start */
    /* Code Deleted*/ 
    /* SPR_16103_End */
    U8 inter_freq_list = 0, valid_inter_freq_list=0;
    rrm_return_et    ret_val = RRM_SUCCESS;


    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
        inter_freq_carrier_freq_list_list.count = 
        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.num_valid_inter_freq_list;

    valid_inter_freq_list = p_reconfig_req_from_mif->ran_info.mobility_params.
        idle_mode_mobility_params.num_valid_inter_freq_list;

    for(inter_freq_list=0; inter_freq_list<valid_inter_freq_list; inter_freq_list++)
    {

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].
            presence_bitmask = RRM_ZERO;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].eutra_dl_carrier_freq = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].eutra_carrier_arfcn; 
        /*line deleted*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].qrx_lev_min = 
            p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].q_rx_lev_min_sib_5;

        if((p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[inter_freq_list].
                    bitmask &  RRMCM_RMIF_P_MAX_PRESENT))
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= 
                INTER_FREQ_CARR_P_MAX_PRESENCE_FLAG;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].p_max = 
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].p_max;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.
            sib_type_5_Info.inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].t_reselection_eutran = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].t_reselection_eutra;

        if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_freq_params[inter_freq_list].bitmask & 
                    RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1))
        {
            /*setting bitmask*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= 
                INTER_FREQ_CARR_SCALE_PARAM_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].speed_depend_scal_params.sf_medium = 
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].
                speed_scale_factors.t_reselection_eutra_sf_medium;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].speed_depend_scal_params.sf_high = 
                p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].
                speed_scale_factors.t_reselection_eutra_sf_high;
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].thresh_x_high = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].thresh_x_high;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].thresh_x_low = 
            p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[inter_freq_list].thresh_x_low;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].measurement_bandwidth = 
            p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].
            inter_freq_params_op_specific.allowed_meas_bandwidth;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].presence_antenna_port_1 =  
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].
            inter_freq_params_op_specific.presence_antenna_port1;

        if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_freq_params[inter_freq_list].bitmask &  
                    RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT))
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].
                presence_bitmask |= INTER_FREQ_CARR_CELL_RESELCT_PRIOR_PRESENCE_FLAG;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].
                cell_reselect_priority = 
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].cell_reselection_priority;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].neigh_cell_config = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].neigh_cell_config;	

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].q_offset_freq = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_list].q_offset_freq;

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
              /* SPR_16103_Start */
	      update_reconf_sib_type_5_inter_freq_Info(p_reconfig_req_from_mif,
				                               	      p_rrc_rrm_cell_reconfig_req,
                              					      inter_freq_list);	
              /* SPR_16103_End */
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].
                inter_freq_params_op_specific.bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].q_qual_min_r9 = 
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.q_qual_min_r9;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].
                presence_bitmask |= INTER_FREQ_CARR_Q_QUAL_MIN_R9_PRESENCE_FLAG;
        }

        if(p_reconfig_req_from_mif->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[inter_freq_list].
                inter_freq_params_op_specific.bitmask & RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].
                thresh_x_q_r9.thresh_x_high_q_r9 = 
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].
                inter_freq_params_op_specific.threshx_q_r9.thresh_serving_highq_r9;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].thresh_x_q_r9.thresh_x_low_q_r9 = 
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[inter_freq_list].
                inter_freq_params_op_specific.threshx_q_r9.thresh_serving_lowq_r9;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.
                inter_freq_carrier_freq_list[inter_freq_list].
                presence_bitmask |= INTER_FREQ_THRESH_X_Q_R9_PRESENCE_FLAG;
        }
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}








/****************************************************************************
 *   FUNCTION NAME : update_reconf_sib_type_7_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function updates sib type 7 for cell reconfig coming from MIF to RRC
 *
 *   RETURNS :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_sib_type_7_Info
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                   ret_val                  = RRM_SUCCESS;
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    U8                              index                    = RRM_ZERO;
    U8                              exp_arfcn_index          = RRM_ZERO;
    U8                              var_bitupdate_index         = RRM_ZERO;

    sib_type_7_Info_t               *p_sib_type_7_info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;
    p_sib_type_7_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.\
            sib_type_7_Info);

    idle_mode_mobility_irat_geran_params_t  *p_idle_mode_mob_geran = RRM_PNULL;

    p_idle_mode_mob_geran = &(p_reconfig_req_from_mif->ran_info.mobility_params.\
            idle_mode_mobility_params.\
            idle_mode_mobility_irat_geran_params);   

    p_sib_type_7_info->presence_bitmask = RRM_ZERO;

    if (RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT &\
            p_idle_mode_mob_geran->bitmask )
    {
        p_sib_type_7_info->presence_bitmask |=\
                                              SIB_7_CR_FREQS_INFO_LST_PRESENCE_FLAG;

        p_sib_type_7_info->carrier_freqs_info_lst.\
            count = p_idle_mode_mob_geran->\
            irat_eutran_to_geran_list.\
            num_irat_eutran_to_geran_carriers;    

        for(index = RRM_ZERO;(index < p_sib_type_7_info->carrier_freqs_info_lst.count
                    && p_sib_type_7_info->carrier_freqs_info_lst.count
                    <= MAX_NO_GERAN_FREQ_GROUUP); index++)
        {
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.\
                presence_bitmask = RRM_ZERO;

            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.ncc_permitted[RRM_ZERO] = p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].ncc_permitted;

            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.q_rx_lev_min =\
                p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].q_rx_lev_min;

            /* cell_reselection_priority*/
            if(RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                    common_info.presence_bitmask |=\
                    CRFI_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                    common_info.cell_reselection_priority =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    cell_reselection_priority;
            }

            if(RRMCM_GERAN_P_MAX_GERAN_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].\
                    common_info.presence_bitmask |=\
                    CRFI_GERAN_P_MAX_GERAN_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].\
                    common_info.p_max_geran = p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].p_max_geran;
            }

            /* thresh_x_high */                            
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.thresh_x_high = p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].threshX_high;

            /* thresh_x_high */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.thresh_x_low = p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].threshX_low;

            /* geran_carrier_freqs */

            /* starting_arfcn */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                carrier_freqs.starting_arfcn =\
                p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].\
                geran_car_freqs.starting_arfcn;

            /* band_indicator */
            switch(p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.band_ind)
            {
                case RRM_SON_GERAN_DCS_1800:
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].\
                        carrier_freqs.band_indicator =\
                        RRM_RRC_DCS_1800;
                    break;
                case RRM_SON_GERAN_PCS_1900:
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].\
                        carrier_freqs.band_indicator =\
                        RRM_RRC_PCS_1900;
                    break;
                default:
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].\
                        carrier_freqs.band_indicator =\
                        p_idle_mode_mob_geran->\
                        irat_eutran_to_geran_list.\
                        irat_eutran_to_geran_carriers[index].\
                        geran_car_freqs.band_ind;
                    break;
            }   

            /* explicit_list_of_arfcns */            
            p_sib_type_7_info->carrier_freqs_info_lst.\
                cr_freq_info[index].carrier_freqs.\
                following_arfcns.presence_bitmask = RRM_ZERO;

            if (RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs. following_arfcns.bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.presence_bitmask |=\
                    GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.explicit_list_of_arfcns.count =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.exp_arfcn_list_size;

                for (exp_arfcn_index = RRM_ZERO;
                        exp_arfcn_index < MAX_EXPL_ARFCNS;
                        exp_arfcn_index++)
                {
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].carrier_freqs.\
                        following_arfcns.explicit_list_of_arfcns.\
                        data[exp_arfcn_index] =\
                        p_idle_mode_mob_geran->\
                        irat_eutran_to_geran_list.\
                        irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                        following_arfcns.exp_arfcn_list[exp_arfcn_index];
                }
            }

            /* equally_spaced_arfcns */
            if (RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.presence_bitmask |=\
                    GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.equally_spaced_arfcns.arfcn_spacing =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.arfcn_spacing;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.equally_spaced_arfcns.\
                    num_of_following_arfcns =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.num_of_following_arfcn;
            }

            /* var_bitupdate_of_arfcns */
            if (RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.presence_bitmask |=\
                    GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.var_bitmap_of_arfcns.count =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.arfcn_bmp_list_size;

                for(var_bitupdate_index = RRM_ZERO;
                        var_bitupdate_index < MAX_VAR_BITMAP_OF_ARFCNS;
                        var_bitupdate_index++)
                {
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].carrier_freqs.\
                        following_arfcns.var_bitmap_of_arfcns.\
                        data[var_bitupdate_index] =\
                        p_idle_mode_mob_geran->\
                        irat_eutran_to_geran_list.\
                        irat_eutran_to_geran_carriers[index].\
                        geran_car_freqs.following_arfcns.arfcn_bmp_list[var_bitupdate_index];
                }    
            }
        }
    }

    p_sib_type_7_info->t_reselection_geran = 
        p_idle_mode_mob_geran->\
        irat_eutra_to_geran_reselection_params.t_reselection_geran;

    if ( RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT &\
            p_idle_mode_mob_geran->\
            irat_eutra_to_geran_reselection_params.bitmask
       )
    {
        p_sib_type_7_info->presence_bitmask |=\
                                              SIB_7_T_RESEL_GERAN_SF_PRESENCE_FLAG;

        switch(
                p_idle_mode_mob_geran->\
                irat_eutra_to_geran_reselection_params.\
                speed_state_scale_factor.\
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  p_idle_mode_mob_geran->\
                                                                  irat_eutra_to_geran_reselection_params.\
                                                                  speed_state_scale_factor.\
                                                                  t_reselection_eutra_sf_medium;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_medium= %d",
                        p_idle_mode_mob_geran->\
                        irat_eutra_to_geran_reselection_params.\
                        speed_state_scale_factor.\
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;
                break;
        }

        switch(p_idle_mode_mob_geran->\
                irat_eutra_to_geran_reselection_params.\
                speed_state_scale_factor.\
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                p_idle_mode_mob_geran->\
                                                                irat_eutra_to_geran_reselection_params.\
                                                                speed_state_scale_factor.\
                                                                t_reselection_eutra_sf_high;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_high= %d",
                        p_idle_mode_mob_geran->\
                        irat_eutra_to_geran_reselection_params.speed_state_scale_factor.\
                        t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}



/* Fix for reconfig 27/06/2013 */

/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_cdma2000_hrpd
 *
 *   DESCRIPTION :
 *          This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 ****************************************************************************/
rrm_void_t
update_reconf_cdma2000_hrpd
(
 rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_irat_cdma_params = RRM_PNULL;
    params_hrpd_t       *p_params_hrpd = RRM_PNULL;

    p_irat_cdma_params = &(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_params_hrpd = &(p_sib_type_8_Info->params_hrpd);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_hrpd.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask & RRMCM_RMIF_PRE_REG_INFO_HRPD_PRESENCE_FLAG)
    {
        map_pre_reg_info_hrpd(p_irat_cdma_params, p_params_hrpd);
    }

    map_reselection_cdma2000_hrpd_params(p_params_hrpd, p_irat_cdma_params);

    /* Setting Bitmask for HRPD Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_HRPD_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_cdma2000_1xrtt
 *
 *   DESCRIPTION :
 *          This function Maps the cell setup params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 ****************************************************************************/
rrm_void_t
update_reconf_cdma2000_1xrtt
(
 rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_irat_cdma_params = RRM_PNULL;

    p_irat_cdma_params = &(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info->params_1_xrtt.presence_bitmask = RRM_ZERO;

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG)
    {
        map_csfb_reg_1_xrtt_params(p_irat_cdma_params,
                &(p_sib_type_8_Info->params_1_xrtt.csfb_reg_param_1_xrtt));
        p_sib_type_8_Info->params_1_xrtt.presence_bitmask |=
            CFSB_REG_PARAM_1_XRTT_PRESENCE_FLAG;
    }

    /* No Need to fill long_code_state_1_xrtt */

    map_reselection_cdma2000_1xrtt_params( p_irat_cdma_params,
            &(p_sib_type_8_Info->params_1_xrtt));

    /* Setting Bitmask for 1XRTT Params */
    p_sib_type_8_Info->presence_bitmask |= SIB_8_PARAMS_1_XRTT_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 *    FUNCTION NAME       :  update_reconf_hrpd_1xrtt_ncl_list
 *
 *    DESCRIPTION :
 *       This function Maps the cell reconfig params coming from MIF to RRC
 *
 *    RETURNS     :
 *        RRM_SUCCESS     on Success.
 *        RRM_FAILURE     on Failure.
 ****************************************************************************/
rrm_void_t
update_reconf_hrpd_1xrtt_ncl_list
(
 rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
 sib_type_8_Info_t   *p_sib_type_8_Info)
{
    U16    valid_cdma2000_freq_cells = RRM_ZERO;
    U16    cdma2000_freq_cells = RRM_ZERO;
    neigh_cell_list_cdma2000_t  *p_neigh_cell_list_cdma2000 = RRM_PNULL;
    neigh_cell_list_cdma2000_v920_t  *p_cell_resel_cdma2000_v920 = RRM_PNULL;
    inter_rat_ncl_t     *p_inter_rat_ncl = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma = RRM_PNULL;
    U8  valid_1xrtt_cell_index = RRM_ZERO;
    U8  valid_hrpd_cell_index = RRM_ZERO;
    /* CID 54924*/
    /* Coverity_fix_start_54924 */
    S32  HRPD_FOUND = RRM_ONE;
    /* CID 54924*/
    S32  XRTT_FOUND = RRM_ONE;
    /* Coverity_fix_end_54924 */
    /* SPR 15235 fix */

    RRM_UT_TRACE_ENTER();

    p_inter_rat_ncl = &(p_reconfig_req_from_mif->ran_info.ncl_params.inter_rat_ncl);

    p_irat_cdma = &(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    valid_cdma2000_freq_cells = p_inter_rat_ncl->num_valid_cdma2000_freq_cells;

    /* Check for DAHO Cells */
    if(p_irat_cdma->cdma2000_cell_param.bitmask &
            RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_1xrtt_cell_index = RRM_ZERO;
                valid_1xrtt_cell_index < valid_cdma2000_freq_cells;
                valid_1xrtt_cell_index++)
        {
            XRTT_FOUND = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_1xrtt_cell_index].CID),
                    RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);
            if(!XRTT_FOUND)
            {
                break;
            }
        }
    }

    if(p_irat_cdma->cdma2000_cell_param.bitmask &
            RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_hrpd_cell_index = RRM_ZERO;
                valid_hrpd_cell_index < valid_cdma2000_freq_cells;
                valid_hrpd_cell_index++)
        {
            HRPD_FOUND = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_hrpd_cell_index].CID),
                    RRM_CDMA2000_HRPD_CELL_ID_LENGTH);
            if(!HRPD_FOUND)
            {
                break;
            }
        }
    }

    /* SPR 15235 Fix- Code moved to switch case- because if neighbor is found 
     * then only bitmask is to be set */

    /* Neigh cell list Structures need to be initialized as it accumulates previous values
     *        of cell config */
    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_1_xrtt.
            cell_reselection_params_1_xrtt.neigh_cell_list);

    p_cell_resel_cdma2000_v920 = &(p_sib_type_8_Info->
            cell_reselection_params_1_xrtt_v920.neigh_cell_list_v920);

    /* initializing xrtt neigh cell list */
    RRM_MEMSET(p_neigh_cell_list_cdma2000, RRM_ZERO, sizeof(neigh_cell_list_cdma2000_t));
    RRM_MEMSET(p_cell_resel_cdma2000_v920, RRM_ZERO, sizeof(neigh_cell_list_cdma2000_v920_t));

    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_hrpd.
            cell_reselection_params_hrpd.neigh_cell_list);
    p_cell_resel_cdma2000_v920 = &(p_sib_type_8_Info->
            cell_reselection_params_hrpd_v920.neigh_cell_list_v920);

    /* initializing hrpd neigh cell list */
    RRM_MEMSET(p_neigh_cell_list_cdma2000, RRM_ZERO, sizeof(neigh_cell_list_cdma2000_t));
    RRM_MEMSET(p_cell_resel_cdma2000_v920, RRM_ZERO, sizeof(neigh_cell_list_cdma2000_v920_t));

    for(cdma2000_freq_cells = RRM_ZERO;
            cdma2000_freq_cells < valid_cdma2000_freq_cells; cdma2000_freq_cells++)
    {
        if(!XRTT_FOUND || !HRPD_FOUND)
        {
            if((cdma2000_freq_cells == valid_hrpd_cell_index) ||
                    (cdma2000_freq_cells == valid_1xrtt_cell_index))
            {
                continue;
            }
        }
        switch(p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells].type)
        {
            case RRM_OAM_NCL_TYPE_1XRTT:
                {
                    /* SPR 15235 Fix start */
                    /* Set bitmask */
                    p_sib_type_8_Info->params_1_xrtt.presence_bitmask |=
                        CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Setting Bitmask for CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG");
                    /* SPR 15235 Fix end */
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_1_xrtt.
                            cell_reselection_params_1_xrtt.neigh_cell_list);

                    p_cell_resel_cdma2000_v920 = &(p_sib_type_8_Info->
                            cell_reselection_params_1_xrtt_v920.neigh_cell_list_v920);

                    map_cell_reselection_params_cdma2000(p_neigh_cell_list_cdma2000,
                            p_cell_resel_cdma2000_v920,
                            p_inter_rat_ncl,
                            cdma2000_freq_cells,
                            p_sib_type_8_Info);
                    break;
                }
            case RRM_OAM_NCL_TYPE_HRPD:
                {
                    /* SPR 15235 Fix start */
                    /* Set bitmask */
                    p_sib_type_8_Info->params_hrpd.presence_bitmask |=
                        PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Setting Bitmask for PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG");
                    /* SPR 15235 Fix end */
                    p_neigh_cell_list_cdma2000 = &(p_sib_type_8_Info->params_hrpd.
                            cell_reselection_params_hrpd.neigh_cell_list);
                    p_cell_resel_cdma2000_v920 = &(p_sib_type_8_Info->
                            cell_reselection_params_hrpd_v920.neigh_cell_list_v920);
                    map_cell_reselection_params_cdma2000(p_neigh_cell_list_cdma2000,
                            p_cell_resel_cdma2000_v920,
                            p_inter_rat_ncl,
                            cdma2000_freq_cells,
                            p_sib_type_8_Info);

                    break;
                }
            default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_WARNING, "Wrong Value received for type in NCL : CDMA2000");
        }
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_params_cdma2000_hrpd_1xrtt
 *
 *   DESCRIPTION :
 *          This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 ****************************************************************************/
rrm_void_t
update_reconf_params_cdma2000_hrpd_1xrtt
(
 rrm_cell_context_t  *p_rrm_cell_context,
 sib_type_8_Info_t   *p_sib_type_8_Info
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_rrm_cell_context->p_new_reconfig_data;

    /* Mapping of HRPD struct starts */
    update_reconf_cdma2000_hrpd(p_reconfig_req_from_mif, p_sib_type_8_Info);
    /* Mapping of HRPD struct ends */

    /* Mapping of 1XRTT struct starts */
    update_reconf_cdma2000_1xrtt(p_reconfig_req_from_mif, p_sib_type_8_Info);
    /* Mapping of 1XRTT struct ends */

    if(p_reconfig_req_from_mif->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT)
    {
        if(p_reconfig_req_from_mif->ran_info.ncl_params.bitmask &
                RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
        {
            update_reconf_hrpd_1xrtt_ncl_list(
                    p_reconfig_req_from_mif,
                    p_sib_type_8_Info);
        }
    }

    RRM_UT_TRACE_EXIT();
}

/*Klockwork_fix_start*/
/****************************************************************************
 *    FUNCTION NAME       :   update_reconf_sib_type_8_Info_cdma
 *    *
 *    *   DESCRIPTION :
 *    *      This function Maps the cell reconfig params coming from MIF to RRC
 *    *   for cdma
 *    *   RETURNS     :
 *    *       RRM_SUCCESS     on Success.
 *    *       RRM_FAILURE     on Failure.
 *    *****************************************************************************/
rrm_void_t
update_reconf_sib_type_8_Info_cdma(rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_idle_mode_mobility_irat_cdma ,
        sib_type_8_Info_t   *p_sib_type_8_Info)
{
    RRM_UT_TRACE_ENTER();
    switch(p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9)
    {
        case RRM_FALSE:
            {
                p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_FALSE;
                break;
            }
        case RRM_TRUE:
            {
                p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_TRUE;
                break;
            }
        default:
            p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 =
                p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid Value received for Sib-8 :" 
                    "csfb_support_for_dual_rx_ues_r9 %d",
                    p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9);
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 *    FUNCTION NAME       :   update_reconf_sib_type_8_Info_cdma_v920
 *    *
 *    *   DESCRIPTION :
 *    *      This function Maps the cell reconfig params coming from MIF to RRC
 *    *   for cdma
 *    *   RETURNS     :
 *    *       RRM_SUCCESS     on Success.
 *    *       RRM_FAILURE     on Failure.
 *    *****************************************************************************/
rrm_void_t
update_reconf_sib_type_8_Info_cdma_v920(rrmcm_idle_mode_mobility_irat_cdma_params_t 
        *p_idle_mode_mobility_irat_cdma ,
        sib_type_8_Info_t   *p_sib_type_8_Info)
{
    RRM_UT_TRACE_ENTER();
    switch(p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920)
    {
        case RRM_RRC_POWER_DOWN_REG_R9_TRUE_8:
            p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                RRM_RRC_POWER_DOWN_REG_R9_TRUE_8;
            break;
        default :
            p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Wrong Value received for csfb_registration_param_1xrtt_v920 : %d",
                    p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920);
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/****************************************************************************
 *    FUNCTION NAME       :   update_reconf_sib_type_8_Info
 *    *
 *    *   DESCRIPTION :
 *    *      This function Maps the cell reconfig params coming from MIF to RRC
 *    *
 *    *   RETURNS     :
 *    *       RRM_SUCCESS     on Success.
 *    *       RRM_FAILURE     on Failure.
 *    *****************************************************************************/
rrm_return_et
update_reconf_sib_type_8_Info
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    /* coverity : CID 23136,23135*/
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_idle_mode_mobility_irat_cdma = RRM_PNULL;


    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    sib_type_8_Info_t               *p_sib_type_8_Info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;
    p_sib_type_8_Info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.\
            sib_type_8_Info);


    p_idle_mode_mobility_irat_cdma = &(p_reconfig_req_from_mif->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params);

    p_sib_type_8_Info->presence_bitmask = RRM_ZERO;

    /* No need to fill sys_time_info */
    p_sib_type_8_Info->sys_time_info.presence_bitmask = RRM_ZERO;

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_SEARCH_WIN_SIZE_PRESENCE_FLAG)
    {
        p_sib_type_8_Info->search_window_size =
            p_idle_mode_mobility_irat_cdma->search_window_size;
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_SEARCH_WIN_SIZE_PRESENCE_FLAG;
    }

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT) ||
            (p_cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT))
    {
        update_reconf_params_cdma2000_hrpd_1xrtt(p_cell_context, p_sib_type_8_Info);
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG)
    {
        /*Klockwork_fix_start*/
        update_reconf_sib_type_8_Info_cdma(p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info);
        /*Klockwork_fix_end*/
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG;
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG)
    {
        map_ac_barring_config_1_xrtt_r9(
                &(p_idle_mode_mobility_irat_cdma->ac_barring_config_1_xrtt_r9),
                &(p_sib_type_8_Info->ac_barring_config_1_xrtt_r9));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 : ac_barring_config_1_xrtt_r9");
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG;
    }
    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG)
    {
        /*Klockwork_fix_start*/
        update_reconf_sib_type_8_Info_cdma_v920(p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info);
        /*Klockwork_fix_end*/
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_CSFB_REG_PARAM_1_XRTT_R9_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 :csfb_registration_param_1xrtt_v920");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Fix End for reconfig 27/06/2013 */



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_preamble_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig preamble info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_preamble_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;
    /*bitmask*/ 
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.rach_config_common.preamble_info.presence_bitmask = RRM_ZERO;

    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.number_of_ra_preambles)
    {
        case RRM_OAM_RA_PREAMBLE_COUNT_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N4;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N8;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N12;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N16;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N20;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N24;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N28:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N28;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N32:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N32;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N36:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N36;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N40:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N40;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N44:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N44;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N48:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N48;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N52:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N52;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N56:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N56;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N60;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N64:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N64;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.number_of_ra_preambles;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for number_of_ra_preambles: %d",
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.number_of_ra_preambles);
            ret_val = RRM_FAILURE;
    }

    update_reconf_preambles_group_a_config(p_cell_context,p_rrc_rrm_cell_reconfig_req);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_power_ramping_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig power ramping params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_power_ramping_params
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.power_ramping_step)
    {
        case RRM_OAM_POWER_RAMP_STEP_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =
                RRM_RRC_POWER_RAMP_STEP_DB0;
            break;

        case RRM_OAM_POWER_RAMP_STEP_DB2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =
                RRM_RRC_POWER_RAMP_STEP_DB2;
            break;

        case RRM_OAM_POWER_RAMP_STEP_DB4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =
                RRM_RRC_POWER_RAMP_STEP_DB4;
            break;

        case RRM_OAM_POWER_RAMP_STEP_DB6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step = 
                RRM_RRC_POWER_RAMP_STEP_DB6;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.power_ramping_step;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"Invalid value for power_ramping_step: %d",
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.power_ramping_step);
            ret_val = RRM_FAILURE;
    }

    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_initial_received_target_power)
    {
        case RRM_OAM_PREAMBLE_POWER_DBM_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_120;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_118:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_118;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_116:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_116;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_114:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_114;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_112:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_112;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_110:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_110;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_108:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_108;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_106:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_106;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_104:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_104;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_102:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_102;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_100;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_98:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_98;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_96:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_96;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_94:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_94;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_92:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_92;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_90:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_90;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_initial_received_target_power;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for preamble_initial_received_target_power: %d", 
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_initial_received_target_power);
            ret_val = RRM_FAILURE;
    }	

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ra_supervision_info
 *   INPUT       : p_cell_context\
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig ra supervision info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_ra_supervision_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_trans_max)
    {
        case RRM_OAM_PREAMBLE_TRANS_MAX_N3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N3;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N4;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N5;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N6;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = 
                RRM_RRC_PREAMBLE_TRANS_MAX_N7;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N8;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N10;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N20;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N50;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = 
                RRM_RRC_PREAMBLE_TRANS_MAX_N100;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = 
                RRM_RRC_PREAMBLE_TRANS_MAX_N200;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_trans_max;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for preamble_trans_max: %d",
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_trans_max);
            ret_val = RRM_FAILURE;
    }

    /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
    update_reconf_ra_resp_win_size(p_reconfig_req_from_mif,
            p_rrc_rrm_cell_reconfig_req);
    /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

    /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
    update_reconf_mac_cont_resol_timer(p_reconfig_req_from_mif,
            p_rrc_rrm_cell_reconfig_req);
    /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_preambles_group_a_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_preambles_group_a_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    preambles_group_a_config_t      *p_preamble_group_a =  RRM_PNULL;
    rrm_preamble_info_t             *p_rrm_cellm_preamble_info = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;

    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /*setting bitmask*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.rach_config_common.
        preamble_info.presence_bitmask = RRM_ZERO;

    p_rrm_cellm_preamble_info = &(p_reconfig_req_from_mif->ran_info.
            mac_layer_params.mac_layer_param_rach.
            preamble_info);
    RRM_ASSERT(RRM_PNULL != p_rrm_cellm_preamble_info);
    if ((p_rrm_cellm_preamble_info->bitmask & RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT)
       )
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.rach_config_common.
            preamble_info.presence_bitmask |= PREAMBLE_INFO_GROUP_A_CONFIG_PRESENCE_FLAG;

        switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a)
        {
            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N4;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N8;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size = RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N12;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N16;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N20;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N24;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N28;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N32;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N36;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N40;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N44;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N48;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N52;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N56;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N60;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size = p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                    size_of_ra_group_a;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Invalid value of size_of_ra_group_a: %d",
                        p_reconfig_req_from_mif->ran_info.mac_layer_params.
                        mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                        size_of_ra_group_a);
                ret_val = RRM_FAILURE;
        }

        p_preamble_group_a = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config);
        switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                message_size_group_a)
        {
            case RRM_OAM_GROUP_A_MSG_SIZE_B56:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B56;
                break;
            case RRM_OAM_GROUP_A_MSG_SIZE_B144:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B144;
                break;
            case RRM_OAM_GROUP_A_MSG_SIZE_B208:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B208;
                break;
            case RRM_OAM_GROUP_A_MSG_SIZE_B256:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B256;
                break;
            default:
                p_preamble_group_a->group_a_msg_size = 
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.\
                    mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.\
                    message_size_group_a;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for message_size_group_a = %u",
                        p_reconfig_req_from_mif->ran_info.mac_layer_params.\
                        mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.\
                        message_size_group_a);
                ret_val = RRM_FAILURE;
                break;
        }

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        update_reconf_preambles_group_b_msg_power_offset(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_preambles_group_b_msg_power_offset 
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_preambles_group_b_msg_power_offset(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
            message_power_offset_group_b)
    {
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB0;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB5;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB8;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB10;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB12;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB15:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB15;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB18:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB18;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                message_power_offset_group_b;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of message_power_offset_group_b:\
                    %d",p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                    message_power_offset_group_b );
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ra_resp_win_size
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig ra resp win size params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_ra_resp_win_size(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();


    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.response_window_size)
    {
        case RRM_OAM_RA_RESP_WIN_SIZE_SF2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF2;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF3;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF4;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF5;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF6;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF7;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF8;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF10;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.response_window_size;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for response_window_size: %d",
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.response_window_size); 
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/





/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_mac_cont_resol_timer
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig mac cont resol timer params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_mac_cont_resol_timer(const rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();


    switch(p_reconfig_req_from_mif->ran_info.mac_layer_params.
            mac_layer_param_rach.contention_resolution_timer)
    {
        case RRM_OAM_MAC_CONT_RES_TIMER_SF8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF8;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF16;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF24;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF32:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF32;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF40:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF40;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF48:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF48;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF56:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer = 
                RRM_RRC_MAC_CONT_RES_TIMER_SF56;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF64:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF64;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                p_reconfig_req_from_mif->ran_info.mac_layer_params.
                mac_layer_param_rach.contention_resolution_timer;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for contention_resolution_timer:%d",
                    p_reconfig_req_from_mif->ran_info.mac_layer_params.
                    mac_layer_param_rach.contention_resolution_timer);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_rach_config_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig  common rach config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_rach_config_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    update_reconf_preamble_info(p_cell_context,p_rrc_rrm_cell_reconfig_req);
    update_reconf_power_ramping_params(p_cell_context,p_rrc_rrm_cell_reconfig_req);
    update_reconf_ra_supervision_info(p_cell_context,p_rrc_rrm_cell_reconfig_req);

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.rach_config_common.max_harq_msg_3_tx = 
        p_reconfig_req_from_mif->ran_info.mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx;

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}




/****************************************************************************
 *   FUNCTION NAME : update_delta_f_pucch_format_1b_info
 *   INPUT         : delta_f_pucch_format_1b_val
 *   OUTPUT        : p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 1b Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_delta_f_pucch_format_1b_info(
        rrmc_delta_f_pucch_format_one_b_et  delta_f_pucch_format_1b_val,
        uplink_power_control_common_t       *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_1b_val)
    {
        case RRMC_DELTA_F1:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = RRM_RRC_DELTA_F1;
            break;
        case RRMC_DELTA_F3:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = RRM_RRC_DELTA_F3;
            break;
        case RRMC_DELTA_F5:
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = RRM_RRC_DELTA_F5;
            break;

        default :
            p_ul_power_control_info->delta_f_list_pucch.
                delta_f_pucch_format_one_b = delta_f_pucch_format_1b_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_one_b = %u",
                    p_ul_power_control_info->delta_f_list_pucch.delta_f_pucch_format_one_b);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}





/****************************************************************************
 *   FUNCTION NAME : update_delta_f_pucch_format_2_info
 *   INPUT         : delta_f_pucch_format_2_val
 *   OUTPUT        : p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2 Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_delta_f_pucch_format_2_info(
        rrmc_delta_f_pucch_format_two_et    delta_f_pucch_format_2_val,
        uplink_power_control_common_t       *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_2_val)
    {
        case RRMC_FORMAT2_DELTA_NEG_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_NEG_TWO;
            break;
        case RRMC_FORMAT2_DELTA_ZERO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_ZERO;
            break;
        case RRMC_FORMAT2_DELTA_POS_ONE:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_POS_ONE;
            break;
        case RRMC_FORMAT2_DELTA_POS_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = RRM_RRC_FORMAT2_DELTA_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two = delta_f_pucch_format_2_val;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_2 = %u",
                    p_ul_power_control_info->delta_f_pucch_format_two.delta_f_pucch_format_two);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME : update_delta_f_pucch_format_2a_info
 *   INPUT         : delta_f_pucch_format_two_ab_val
 *   OUTPUT        : p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2a Info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_delta_f_pucch_format_2a_info(
        rrmc_delta_f_pucch_format_two_ab_et delta_f_pucch_format_two_ab_val,
        uplink_power_control_common_t       *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_two_ab_val)
    {
        case RRMC_DELTA_NEG_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_NEG_TWO;
            break;
        case RRMC_DELTA_ZERO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_ZERO;
            break;
        case RRMC_DELTA_POS_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = delta_f_pucch_format_two_ab_val;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_two_a = %u",
                    delta_f_pucch_format_two_ab_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME : update_delta_f_pucch_format_2b_info
 *   INPUT         : delta_f_pucch_format_2b_val
 *   OUTPUT        : p_ul_power_control_info
 *   DESCRIPTION   : This function Maps delta f pucch format 2b info.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_delta_f_pucch_format_2b_info(
        rrmc_delta_f_pucch_format_two_ab_et  delta_f_pucch_format_2b_val,
        uplink_power_control_common_t        *p_ul_power_control_info)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(delta_f_pucch_format_2b_val)
    {
        case RRMC_DELTA_NEG_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_NEG_TWO;
            break;
        case RRMC_DELTA_ZERO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_ZERO;
            break;
        case RRMC_DELTA_POS_TWO:
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_POS_TWO;
            break;

        default :
            p_ul_power_control_info->delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = delta_f_pucch_format_2b_val;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_f_pucch_format_two_b = %u",
                    delta_f_pucch_format_2b_val);
            ret_val = RRM_FAILURE;
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_sync_signals
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig sync signal params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_sync_signals
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    U16 pci;
    U8 n1_count = RRM_ZERO, n2_count = RRM_ZERO, flag = RRM_FALSE;
    U8 pci_values_m1_m2[RRM_MAX_M1_VALUES][RRM_MAX_M2_VALUES] = { {0, 1}/* 0 */, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6},
        {6, 7}, {7, 8}, {8, 9}, {9, 10}, {10, 11}/* 10 */, 
        {11, 12}, {12, 13}, {13, 14}, {14, 15}, {15, 16},
        {16, 17}, {17, 18}, {18, 19}, {19, 20}, {20, 21}/* 20 */, 
        {21, 22}, {22, 23}, {23, 24}, {24, 25}, {25, 26}, 
        {26, 27}, {27, 28}, {28, 29}, {29, 30},	{0, 2}/* 30 */, 
        {1, 3}, {2, 4}, {3, 5}, {4, 6}, {5, 7}, {6, 8}, 
        {7, 9}, {8, 10}, {9, 11}, {10, 12}/* 40 */, 
        {11, 13}, {12, 14}, {13, 15}, {14, 16}, {15, 17},
        {16, 18}, {17, 19}, {18, 20}, {19, 21}, {20, 22}/* 50 */, 
        {21, 23}, {22, 24}, {23, 25}, {24, 26}, {25, 27}, 
        {26, 28}, {27, 29}, {28, 30}, {0, 3}, {1, 4}/* 60 */, 
        {2, 5}, {3, 6}, {4, 7}, {5, 8}, {6, 9}, {7, 10}, 
        {8, 11}, {9, 12}, {10, 13}, {11, 14}/* 70 */, 
        {12, 15}, {13, 16}, {14, 17}, {15, 18}, {16, 19}, 
        {17, 20}, {18, 21}, {19, 22}, {20, 23}, {21, 24}/* 80 */, 
        {22, 25}, {23, 26}, {24, 27}, {25, 28}, {26, 29}, 
        {27, 30}, {0, 4}, {1, 5}, {2, 6}, {3, 7}/* 90 */, 
        {4, 8}, {5, 9}, {6, 10}, {7, 11}, {8, 12}, {9, 13}, 
        {10, 14}, {11, 15}, {12, 16}, {13, 17}/* 100 */, 
        {14, 18}, {15, 19}, {16, 20}, {17, 21}, {18, 22}, 
        {19, 23}, {20, 24}, {21, 25}, {22, 26},	{23, 27}/* 110 */, 
        {24, 28}, {25, 29}, {26, 30}, {0, 5}, {1, 6}, 
        {2, 7}, {3, 8}, {4, 9}, {5, 10}, {6, 11}/* 120 */, 
        {7, 12}, {8, 13}, {9, 14}, {10, 15}, {11, 16}, 
        {12, 17}, {13, 18}, {14, 19}, {15, 20},	{16, 21}/* 130 */, 
        {17, 22}, {18, 23}, {19, 24}, {20, 25}, {21, 26}, 
        {22, 27}, {23, 28}, {24, 29}, {25, 30},	{0, 6}/* 140 */, 
        {1, 7}, {2, 8}, {3, 9}, {4, 10}, {5, 11}, {6, 12}, 
        {7, 13}, {8, 14}, {9, 15}, {10, 16}/* 150 */, 
        {11, 17}, {12, 18}, {13, 19}, {14, 20}, {15, 21}, 
        {16, 22}, {17, 23}, {18, 24}, {19, 25},	{20, 26}/* 160 */, 
        {21, 27}, {22, 28}, {23, 29}, {24, 30}, {0, 7}, {1, 8}, 
        {2, 9} };

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /* SPR 5014 start */
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.prim_syn_signal_power = 
        (p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.psch_power_offset)/RRM_TEN;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.sec_syn_signal_power = 
        (p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.ssch_power_offset)/RRM_TEN;
    /* SPR 5014 end */

    pci = p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.phy_cell_id;

    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
    if(RRM_MAX_PCI_VALUE > pci)
    {
        /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/
        for(n1_count=RRM_ZERO; n1_count<RRM_MAX_N1; n1_count++)	/* value of N1 can be 0,1,2 */
        {
            for(n2_count=RRM_ZERO; n2_count<RRM_MAX_N2; n2_count++)	/*value of N2 can be 0 to 167*/
            {
                if(pci == (RRM_THREE * n1_count + n2_count))
                {
                    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.sec_syn_signal_m_seq1 = pci_values_m1_m2[n2_count][RRM_ZERO];
                    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.sec_syn_signal_m_seq2 = pci_values_m1_m2[n2_count][RRM_ONE];
                    flag = RRM_TRUE;
                    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
                    break;
                    /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/
                }
            }
            if(RRM_TRUE == flag)
            {
                break;
            }
        }	
    }
    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Wrong Value of Phy Cell Id received");
    }
    /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_ue_timers_and_constants_timer_n311
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_ue_timers_and_constants_timer_n311(const rrmcm_rmif_cell_reconfig_req_t       *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t                *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
            rrc_constants.n311)
    {
        /* Coverity Fix 69755 Start */
        case RRM_OAM_TIMER_N311_N1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N1;
            break;

        case RRM_OAM_TIMER_N311_N2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N2;
            break;

        case RRM_OAM_TIMER_N311_N3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N3;
            break;

        case RRM_OAM_TIMER_N311_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N4;
            break;

        case RRM_OAM_TIMER_N311_N5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N5;
            break;

        case RRM_OAM_TIMER_N311_N6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N6;
            break;

        case RRM_OAM_TIMER_N311_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N8;
            break;

        case RRM_OAM_TIMER_N311_N10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = RRM_RRC_TIMER_N311_N10;
            break;
        /* Coverity Fix 69755 End */
        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = 
                p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                rrc_constants.n311;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for n311: %d",
                    p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                    rrc_constants.n311);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/* BUG_371 FIX START */
rrm_void_t
rrm_update_blacklisted_cell_list
(
 black_listed_cell_list_t  *p_intra_freq_black_listed_cell_list, 
 U8                        idx_to_be_rmvd,
 U8                        *p_black_count
 )
{ 
    U8 black_cnt_temp = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "BlackListed cell list count before update: [%d] and Position to be updated is [%d]",
            *p_black_count,idx_to_be_rmvd);

    if( (RRM_ONE == *p_black_count) ||
            (idx_to_be_rmvd == ((*p_black_count)- RRM_ONE)))
    {
        (*p_black_count)--;
    }
    else
    {
        for (black_cnt_temp = idx_to_be_rmvd; 
                black_cnt_temp < ((*p_black_count)- RRM_ONE); black_cnt_temp++)
        {
            p_intra_freq_black_listed_cell_list->black_listed_cell[black_cnt_temp].start = 
                p_intra_freq_black_listed_cell_list->black_listed_cell[black_cnt_temp + RRM_ONE ].start;

        }
        (*p_black_count)--;
    }

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "BlackListed cell list count after update: [%d]",*p_black_count);

    RRM_UT_TRACE_EXIT();
}

rrm_void_t
rrm_update_neighbour_cell_list
(
 neigh_cell_list_t     *p_intra_freq_neigh_cell_list, 
 U8                     idx_to_be_rmvd,
 U8                     *p_neigh_count
 )
{ 
    U8 neigh_cnt_temp = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Neighbour cell list count before update: [%d] and Position to be updated is [%d]",
            *p_neigh_count,idx_to_be_rmvd);

    if( (RRM_ONE == *p_neigh_count) ||
            (idx_to_be_rmvd == ((*p_neigh_count) - RRM_ONE)))
    {
        (*p_neigh_count)--;
    }
    else
    {
        for (neigh_cnt_temp = idx_to_be_rmvd; 
                neigh_cnt_temp < ((*p_neigh_count) - RRM_ONE); neigh_cnt_temp++)
        {
            p_intra_freq_neigh_cell_list->neigh_cell[neigh_cnt_temp].phys_cell_id =
                p_intra_freq_neigh_cell_list->neigh_cell[neigh_cnt_temp + RRM_ONE].phys_cell_id ;

            p_intra_freq_neigh_cell_list->neigh_cell[neigh_cnt_temp].q_offset_cell =
                p_intra_freq_neigh_cell_list->neigh_cell[neigh_cnt_temp + RRM_ONE].q_offset_cell;
        }
        (*p_neigh_count)--;
    }

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Neighbour cell list count after update: [%d]",*p_neigh_count);

    RRM_UT_TRACE_EXIT();
}
/* BUG_371 FIX END */
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_intra_freq_neigh_black_cell_list
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig intra freq neigh black cell list params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_intra_freq_neigh_black_cell_list
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    U8 valid_cells = RRM_ZERO;
    U8 cell_count = RRM_ZERO;
    U8 neigh_count = RRM_ZERO;
    U8 black_count = RRM_ZERO;
    /* BUG_371 FIX START */
    U8 neigh_cnt_temp = RRM_ZERO;
    U8 black_cnt_temp = RRM_ZERO;
    rrm_bool_et is_cell_present_in_list = RRM_FALSE;

    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /* Set the neigh_count and black_count as per the NCL data broadcasted in Cell Configuration */
    if( p_cell_context->sib_present_at_cell_config_time_bitmask & RRM_SIB_4_PRESENT)
    {
        if (p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask & 
                SIB_4_NEIGH_CELL_LIST_PRESENCE_FLAG)
        {
            neigh_count = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                intra_freq_neigh_cell_list.count;
        }
        if (p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask & 
                SIB_4_BLACK_LIST_LIST_PRESENCE_FLAG)
        {
            black_count = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                intra_freq_black_listed_cell_list.count;
        }
    }
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask = 0x00;


    valid_cells = p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell;

    for(cell_count=RRM_ZERO; cell_count < valid_cells; cell_count++)

    {
        if(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].broadcast_status == RRM_TRUE)
        {
            if(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].blacklisted == RRM_FALSE)
            {
                for (neigh_cnt_temp = RRM_ZERO; neigh_cnt_temp < neigh_count; neigh_cnt_temp++)
                {
                    if(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                            intra_freq_neigh_cell_list.neigh_cell[neigh_cnt_temp].phys_cell_id == 
                            p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                "INTRA: Neighbour with PCI Modified[%d]",
                                p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                                intra_freq_cells[cell_count].phy_cell_id);
                        is_cell_present_in_list = RRM_TRUE;
                        break;
                    }
                }
                if(RRM_TRUE == is_cell_present_in_list)
                {
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                        intra_freq_neigh_cell_list.neigh_cell[neigh_cnt_temp].q_offset_cell = 
                        p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].q_offset;
                    is_cell_present_in_list = RRM_FALSE;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "INTRA: New Neighbour with PCI[%d] is added. Check if it was earlier Blacklisted or not",
                            p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                            intra_freq_cells[cell_count].phy_cell_id);

                    for (black_cnt_temp = RRM_ZERO; black_cnt_temp < black_count; black_cnt_temp++)
                    {
                        if (p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                                intra_freq_cells[cell_count].phy_cell_id == 
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                                intra_freq_black_listed_cell_list.black_listed_cell[black_cnt_temp].start)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                    "INTRA :New Neighbour was earlier Blacklisted. So removing from blacklist");

                            rrm_update_blacklisted_cell_list( &(p_rrc_rrm_cell_reconfig_req->broadcast_info.
                                        sib_type_4_Info.intra_freq_black_listed_cell_list),
                                    black_cnt_temp,&black_count);

                            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= SIB_4_BLACK_LIST_LIST_PRESENCE_FLAG;
                            break;
                        }
                    }

                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                        intra_freq_neigh_cell_list.neigh_cell[neigh_count].phys_cell_id = 
                        p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id;
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                        intra_freq_neigh_cell_list.neigh_cell[neigh_count].q_offset_cell = 
                        p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].q_offset;

                    neigh_count++;
                }
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= SIB_4_NEIGH_CELL_LIST_PRESENCE_FLAG;
            }

            else if(p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].blacklisted == RRM_TRUE)
            {
                for (black_cnt_temp = RRM_ZERO; black_cnt_temp < black_count; black_cnt_temp++)
                {
                    if(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                            intra_freq_black_listed_cell_list.black_listed_cell[black_cnt_temp].start == 
                            p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                "INTRA :Blacklisted Cell with PCI Modified[%d]",
                                p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                        is_cell_present_in_list = RRM_TRUE;
                        break;
                    }
                }
                if(RRM_TRUE == is_cell_present_in_list)
                {
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.black_listed_cell[black_cnt_temp].start = 
                        p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id;
                    is_cell_present_in_list = RRM_FALSE;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "INTRA : New Blacklisted Cell with PCI[%d] is added. Check if it was earlier in Neighbour List or not",
                            p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                            intra_freq_cells[cell_count].phy_cell_id);

                    for (neigh_cnt_temp = RRM_ZERO; neigh_cnt_temp < neigh_count; neigh_cnt_temp++)
                    {
                        if (p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                                intra_freq_cells[cell_count].phy_cell_id == 
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                                intra_freq_neigh_cell_list.neigh_cell[neigh_cnt_temp].phys_cell_id )
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                    "INTRA : New Blacklisted Cell was earlier in Neighbour List . So removing from Neighbour list");

                            rrm_update_neighbour_cell_list( &(p_rrc_rrm_cell_reconfig_req->broadcast_info.
                                        sib_type_4_Info.intra_freq_neigh_cell_list),
                                    neigh_cnt_temp, &neigh_count);
                            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= SIB_4_NEIGH_CELL_LIST_PRESENCE_FLAG;
                            break;
                        } 
                    }
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.black_listed_cell[black_count].start = 
                        p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id;
                    black_count++;
                }

                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= SIB_4_BLACK_LIST_LIST_PRESENCE_FLAG;
            }
        }
    }
    /* BUG_371 FIX END */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_neigh_cell_list.count = neigh_count;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.count = black_count;

    if(RRM_ZERO !=p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask )
    {
        /* Bug:238*/
        sib_presence_bitmask |= RRM_SIB_4_PRESENT;
    }
    black_count=RRM_ZERO;
    neigh_count=RRM_ZERO;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}



/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_ue_timers_and_constants_timer_n310
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_ue_timers_and_constants_timer_n310(const rrmcm_rmif_cell_reconfig_req_t       *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t                *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    //mismatch in no. of elements of timer_n310 and n310. need to check

    switch(p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
            rrc_constants.n310)
    {
        /* Coverity Fix 69768 Start */
        case RRM_OAM_TIMER_N310_N1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N1;
            break;

        case RRM_OAM_TIMER_N310_N2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N2;
            break;

        case RRM_OAM_TIMER_N310_N3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N3;
            break;

        case RRM_OAM_TIMER_N310_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N4;
            break;

        case RRM_OAM_TIMER_N310_N6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N6;
            break;

        case RRM_OAM_TIMER_N310_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N8;
            break;

        case RRM_OAM_TIMER_N310_N10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N10;
            break;
        
        case RRM_OAM_TIMER_N310_N20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = RRM_RRC_TIMER_N310_N20;
            break;
        /* Coverity Fix 69768 End */
        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = 
                p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                rrc_constants.n310;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for n310: %d",
                    p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                    rrc_constants.n310);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/



/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_ue_timers_and_constants_timer_311
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig ue timers and constants for timer 311
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_ue_timers_and_constants_timer_311(const rrmcm_rmif_cell_reconfig_req_t       *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t 		*p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
            rrc_timers.t311)
    {
        case RRM_OAM_TIMER_311_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS1000;
            break;

        case RRM_OAM_TIMER_311_MS3000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS3000;
            break;

        case RRM_OAM_TIMER_311_MS5000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS5000;
            break;

        case RRM_OAM_TIMER_311_MS10000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS10000;
            break;

        case RRM_OAM_TIMER_311_MS15000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS15000;
            break;

        case RRM_OAM_TIMER_311_MS20000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS20000;
            break;

        case RRM_OAM_TIMER_311_MS30000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS30000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = 
                p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                rrc_timers.t311;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t311: %d",
                    p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                    rrc_timers.t311);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;

}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_ue_timers_and_constants_t301
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig ue timers and constants for timer 310
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_ue_timers_and_constants_timer_310(const rrmcm_rmif_cell_reconfig_req_t       *p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
            rrc_timers.t310)
    {
        case RRM_OAM_TIMER_310_MS0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS0;
            break;

        case RRM_OAM_TIMER_310_MS50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS50;
            break;

        case RRM_OAM_TIMER_310_MS100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS100;
            break;

        case RRM_OAM_TIMER_310_MS200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS200;
            break;

        case RRM_OAM_TIMER_310_MS500:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS500;
            break;

        case RRM_OAM_TIMER_310_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS1000;
            break;

        case RRM_OAM_TIMER_310_MS2000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS2000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                rrc_timers.t310;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t310: %d",
                    p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                    rrc_timers.t310);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/




/****************************************************************************
 *   FUNCTION NAME       :  update_reconf_ue_timers_and_constants_t301
 *   INPUT       : p_reconfig_req_from_mif
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig ue timers and constants for timer 301
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
update_reconf_ue_timers_and_constants_timer_301(const rrmcm_rmif_cell_reconfig_req_t	*p_reconfig_req_from_mif,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
            rrc_timers.t301)
    {
        case RRM_OAM_TIMER_300_301_MS100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS100;
            break;

        case RRM_OAM_TIMER_300_301_MS200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS200;
            break;

        case RRM_OAM_TIMER_300_301_MS300:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS300;
            break;

        case RRM_OAM_TIMER_300_301_MS400:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS400;
            break;

        case RRM_OAM_TIMER_300_301_MS600:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS600;
            break;

        case RRM_OAM_TIMER_300_301_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS1000;
            break;

        case RRM_OAM_TIMER_300_301_MS1500:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS1500;
            break;

        case RRM_OAM_TIMER_300_301_MS2000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS2000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                rrc_timers.t301;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"inavlid value for t301: %d",
                    p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                    rrc_timers.t301);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/





/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ue_timers_and_constants
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig ue timers and constants
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_ue_timers_and_constants
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;
    if (p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.bitmask &
            RRMCM_RMIF_RRC_TIMERS_PRESENT)
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;

        switch(p_reconfig_req_from_mif->ran_info.
                rrc_timers_and_constants.rrc_timers.t300)
        {
            case RRM_OAM_TIMER_300_301_MS100:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS100;
                break;

            case RRM_OAM_TIMER_300_301_MS200:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS200;
                break;

            case RRM_OAM_TIMER_300_301_MS300:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS300;
                break;

            case RRM_OAM_TIMER_300_301_MS400:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS400;
                break;

            case RRM_OAM_TIMER_300_301_MS600:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS600;
                break;

            case RRM_OAM_TIMER_300_301_MS1000:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS1000;
                break;

            case RRM_OAM_TIMER_300_301_MS1500:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS1500;
                break;

            case RRM_OAM_TIMER_300_301_MS2000:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS2000;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    ue_timers_and_constants.timer_300 = p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                    rrc_timers.t300;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"inavlid value for t300: %d",
                        p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.
                        rrc_timers.t300);
                ret_val = RRM_FAILURE;
        }

        update_reconf_ue_timers_and_constants_timer_301(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);

        update_reconf_ue_timers_and_constants_timer_310(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);

        update_reconf_ue_timers_and_constants_timer_311(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
    }
    /* Saperately done because no need to configure cell for these */
    if (p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.bitmask &
            RRMCM_RMIF_RRC_TIMERS_PRESENT)
    {
        p_cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t302 = 
            p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.rrc_timers.t302;

        p_cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t304_eutra = 
            p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.rrc_timers.t304_eutra;

        p_cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t304_irat = 
            p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.rrc_timers.t304_irat;
    }


    if (p_reconfig_req_from_mif->ran_info.rrc_timers_and_constants.bitmask &
            RRMCM_RMIF_RRC_CONSTANTS_PRESENT)
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;

        update_reconf_ue_timers_and_constants_timer_n310(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);

        update_reconf_ue_timers_and_constants_timer_n311(p_reconfig_req_from_mif,
                p_rrc_rrm_cell_reconfig_req);
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_downlink_power_control_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function update the reconf downlink power control params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_downlink_power_control_common
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    //commenting below written lines..as per new rrc code
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pcfichPowerOffset = 
        p_reconfig_req_from_mif->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.phichPowerOffset = 
        p_reconfig_req_from_mif->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pdcchPowerOffset = 
        p_reconfig_req_from_mif->operator_info.rrm_mac_config.mac_downlink_power_control_common.pdcchPowerOffset;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pbchTransmissionPower = 
        p_reconfig_req_from_mif->operator_info.rrm_mac_config.mac_downlink_power_control_common.pbchTransmissionPower;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pchTransmissionpower = 
        p_reconfig_req_from_mif->operator_info.rrm_mac_config.mac_downlink_power_control_common.pchTransmissionpower;

    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_DOWNLINK_POWER_CONTROL_COMMON_PRESENT;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}


/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_non_critical_extension
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function updates the cell reconfig non critical extensions params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_non_critical_extension
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;


    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        non_critical_extension.presence_bitmask = RRM_ZERO;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        non_critical_extension.presence_bitmask |= SIB_TYPE_1_V890_IES_NON_CROTICAL_EXTENSION_PRESENT_FLAG;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.presence_bitmask |= 
        SIB_TYPE_1_NON_CRITICAL_EXTENSION_PRESENT_FLAG;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
        non_critical_extension.presence_bitmask = RRM_ZERO;

    if (p_reconfig_req_from_mif->operator_info.sib_1_info.ims_emergency_support_r9)
    {

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.presence_bitmask |= 
            SIB_TYPE_1_V920_IES_IMS_EMERGENCY_SUPPORT_PRESENT_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.ims_emergency_support = RRM_RRC_TRUE;
    }



    if(p_reconfig_req_from_mif->operator_info.sib_1_info.bitmask & RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.cell_selection_info_v920.q_qual_min_r9 = 
            p_reconfig_req_from_mif->operator_info.sib_1_info.cell_selection_info.q_qual_min_r9;

        if(p_reconfig_req_from_mif->operator_info.sib_1_info.cell_selection_info.bitmask & RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.non_critical_extension.
                cell_selection_info_v920.presence_bitmask = RRM_ZERO;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
                non_critical_extension.cell_selection_info_v920.q_qual_min_offset_r9 = 
                p_reconfig_req_from_mif->operator_info.sib_1_info.cell_selection_info.q_qual_min_offset_r9_present;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.non_critical_extension.
                cell_selection_info_v920.presence_bitmask |= CELL_SELECTION_INFO_Q_QUAL_MIN_OFFSET_R9_PRESENT_FLAG;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.presence_bitmask |= SIB_TYPE_1_V920_IES_CELL_SELECTION_INFO_V920_PRESENT_FLAG;
    }


    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_scheduling_info_list
 *   INPUT       : p_cell_context

 * OUTPUT        : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig scheduling info list
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_scheduling_info_list
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    U8 scheduling_list = RRM_ZERO;
    U8 sib_mapping = RRM_ZERO;
    U8 valid_scheduling_list = RRM_ZERO;
    U8 valid_sib_mapping_info = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /* SPR 16442 START */
    if (p_reconfig_req_from_mif->operator_info.sib_1_info.scheduling_info_list.count == RRM_ZERO)
    {
	    valid_scheduling_list = p_cell_context->operator_info.sib_1_info.scheduling_info_list.count;
	    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.count =
		    p_cell_context->operator_info.sib_1_info.scheduling_info_list.count;

	    for(scheduling_list = RRM_ZERO; scheduling_list < valid_scheduling_list; scheduling_list++)
	    {
		    valid_sib_mapping_info =
			    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
			    scheduling_info[scheduling_list].sib_mapping_info.count =
			    p_cell_context->operator_info.sib_1_info.scheduling_info_list.
			    scheduling_info[scheduling_list].sib_mapping_info.count;
		    for(sib_mapping=RRM_ZERO; sib_mapping<valid_sib_mapping_info; sib_mapping++)
		    {
			    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
				    scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping] =
				    p_cell_context->operator_info.sib_1_info.scheduling_info_list.
				    scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping];
		    }
		    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
			    scheduling_info[scheduling_list].si_periodicity =
			    p_cell_context->operator_info.sib_1_info.scheduling_info_list.
			    scheduling_info[scheduling_list].si_periodicity;
	    }

    }
    else
    {
	    /* SPR 16442 END */
	    valid_scheduling_list = 
		    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
		    scheduling_info_list.count = 
		    p_reconfig_req_from_mif->operator_info.sib_1_info.scheduling_info_list.count;

	    for(scheduling_list = RRM_ZERO; scheduling_list < valid_scheduling_list; scheduling_list++)
	    {
		    valid_sib_mapping_info = 
			    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
			    scheduling_info[scheduling_list].sib_mapping_info.count = 
			    p_reconfig_req_from_mif->operator_info.sib_1_info.scheduling_info_list.
			    scheduling_info[scheduling_list].sib_mapping_info.count;
		    for(sib_mapping=RRM_ZERO; sib_mapping<valid_sib_mapping_info; sib_mapping++)
		    {
			    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
				    scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping] = 
				    p_reconfig_req_from_mif->operator_info.sib_1_info.scheduling_info_list.
				    scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping];
		    }
		    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
			    scheduling_info[scheduling_list].si_periodicity = 
			    p_reconfig_req_from_mif->operator_info.sib_1_info.scheduling_info_list.
			    scheduling_info[scheduling_list].si_periodicity;
	    }
	    /* SPR 16442 START */
    }
    /* SPR 16442 END */

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ac_barring_for_mo_signalling
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig access barring for mo signalling
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_ac_barring_for_mo_signalling
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    /*no need to check bitmask as already checked*/

    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    /* SPR fix 23041 start */
    if ( RRMCM_RMIF_SIB_2_INFO_PRESENT &
           p_reconfig_req_from_mif->operator_info.bitmask )
    {
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_signalling.
        ac_barring_factor = rrm_get_ac_barring_factor(&
                (p_reconfig_req_from_mif->operator_info.sib_2_info.radio_res_config_common_sib.
                 access_barring_info.ac_barring_for_mo_signalling));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_signalling.
        ac_barring_time = rrm_get_ac_barring_time(&
                (p_reconfig_req_from_mif->operator_info.sib_2_info.radio_res_config_common_sib.
                 access_barring_info.ac_barring_for_mo_signalling));

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_signalling.
        ac_barring_for_special_ac =rrm_get_ac_barring_for_special_ac(&
                (p_reconfig_req_from_mif->operator_info.sib_2_info.radio_res_config_common_sib.
                 access_barring_info.ac_barring_for_mo_signalling));
    }
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            access_barring_info.ac_barring_for_mo_signalling.
            ac_barring_factor = rrm_get_ac_barring_factor(&
                    (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                     access_barring_info.ac_barring_for_mo_signalling));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            access_barring_info.ac_barring_for_mo_signalling.
            ac_barring_time = rrm_get_ac_barring_time(&
                    (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                     access_barring_info.ac_barring_for_mo_signalling));

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            access_barring_info.ac_barring_for_mo_signalling.
            ac_barring_for_special_ac =rrm_get_ac_barring_for_special_ac(&
                    (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                     access_barring_info.ac_barring_for_mo_signalling));
    }
    /* SPR fix 23041 stop */

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ac_barring_for_mo_data
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig access barring for mo data
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_ac_barring_for_mo_data
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    /*bitmask already checked*/

    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->
        p_new_reconfig_data;

    /* SPR fix 23041 start */
    if ( RRMCM_RMIF_SIB_2_INFO_PRESENT &
           p_reconfig_req_from_mif->operator_info.bitmask )
    {
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_data.ac_barring_factor = 
        rrm_get_ac_barring_factor(&(p_reconfig_req_from_mif->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_data.ac_barring_time = 
        rrm_get_ac_barring_time(&(p_reconfig_req_from_mif->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_data.ac_barring_for_special_ac =
        rrm_get_ac_barring_for_special_ac(&(p_reconfig_req_from_mif->
                    operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
    }
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            access_barring_info.ac_barring_for_mo_data.ac_barring_factor = 
            rrm_get_ac_barring_factor(&(p_cell_context->operator_info.
                         sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            access_barring_info.ac_barring_for_mo_data.ac_barring_time = 
            rrm_get_ac_barring_time(&(p_cell_context->operator_info.
                        sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            access_barring_info.ac_barring_for_mo_data.ac_barring_for_special_ac =
            rrm_get_ac_barring_for_special_ac(&(p_cell_context->
                        operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
    }
    /* SPR fix 23041 stop */

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ssac_barring_for_mmtel_voice_r9
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function updates the ssac barring for mmtel voice r9
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_ssac_barring_for_mmtel_voice_r9
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->
        p_new_reconfig_data;

    /* SPR fix 23041 start */
    if ( RRMCM_RMIF_SIB_2_INFO_PRESENT &
           p_reconfig_req_from_mif->operator_info.bitmask )
    {
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_voice_r9.ac_barring_factor =
        rrm_get_ac_barring_factor(&(p_reconfig_req_from_mif->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_voice_r9.ac_barring_time =
        rrm_get_ac_barring_time(&(p_reconfig_req_from_mif->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac =
        rrm_get_ac_barring_for_special_ac(&(p_reconfig_req_from_mif->
                    operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
    }
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            ssac_barring_for_mmtel_voice_r9.ac_barring_factor =
            rrm_get_ac_barring_factor(&(p_cell_context->operator_info.
                        sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            ssac_barring_for_mmtel_voice_r9.ac_barring_time =
            rrm_get_ac_barring_time(&(p_cell_context->operator_info.
                        sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac =
            rrm_get_ac_barring_for_special_ac(&(p_cell_context->
                        operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
    }
    /* SPR fix 23041 stop */


    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_ssac_barring_for_mmtel_video_r9
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function updates cell reconfig ssac baarring for mmtel video r9
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_ssac_barring_for_mmtel_video_r9
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->
        p_new_reconfig_data;

    /* SPR fix 23041 start */
    if ( RRMCM_RMIF_SIB_2_INFO_PRESENT &
           p_reconfig_req_from_mif->operator_info.bitmask )
    {
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_video_r9.ac_barring_factor =
        rrm_get_ac_barring_factor(&(p_reconfig_req_from_mif->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_video_r9.ac_barring_time =
        rrm_get_ac_barring_time(&(p_reconfig_req_from_mif->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac =
        rrm_get_ac_barring_for_special_ac(&(p_reconfig_req_from_mif->
                    operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
    }
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            ssac_barring_for_mmtel_video_r9.ac_barring_factor =
            rrm_get_ac_barring_factor(&(p_cell_context->operator_info.
                        sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            ssac_barring_for_mmtel_video_r9.ac_barring_time =
            rrm_get_ac_barring_time(&(p_cell_context->operator_info.
                        sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac =
            rrm_get_ac_barring_for_special_ac(&(p_cell_context->
                        operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
    }
    /* SPR fix 23041 stop */

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_bcch_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the bcch config info for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_bcch_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_bcch_config.
            modification_period_coeff)
    {
        case RRM_OAM_MOD_PERIOD_COEFF_N2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                RRM_RRC_MOD_PERIOD_COEFF_N2;
            break;

        case RRM_OAM_MOD_PERIOD_COEFF_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                RRM_RRC_MOD_PERIOD_COEFF_N4;
            break;

        case RRM_OAM_MOD_PERIOD_COEFF_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                RRM_RRC_MOD_PERIOD_COEFF_N8;
            break;

        case RRM_OAM_MOD_PERIOD_COEFF_N16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff = 
                RRM_RRC_MOD_PERIOD_COEFF_N16;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                p_reconfig_req_from_mif->operator_info.sib_2_info.
                radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for modification_period_coeff:%u",\
                    p_reconfig_req_from_mif->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*klock_works_changes_start*/
rrm_return_et
find_pcch_config_nb
(
 rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )

{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_reconfig_req_from_mif->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_pcch_config.nB)
    {
        case RRM_OAM_NB_FOUR_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = RRM_RRC_NB_FOUR_T;
            break;

        case RRM_OAM_NB_TWO_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_TWO_T;
            break;

        case RRM_OAM_NB_ONE_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_T;
            break;

        case RRM_OAM_NB_HALF_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_HALF_T;
            break;

        case RRM_OAM_NB_QUARTER_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_QUARTER_T;
            break;

        case RRM_OAM_NB_ONE_EIGHTH_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb=
                RRM_RRC_NB_ONE_EIGHTH_T;
            break;

        case RRM_OAM_NB_ONE_SIXTEENTH_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_SIXTEENTH_T;
            break;

        case RRM_OAM_NB_ONE_THIRTY_SECOND_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_THIRTY_SECOND_T;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                p_reconfig_req_from_mif->operator_info.sib_2_info.
                radio_res_config_common_sib.rrm_pcch_config.nB;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for nB: %d",
                    p_reconfig_req_from_mif->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_pcch_config.nB);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*klock_works_changes_end*/



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_pcch_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the pcch config info for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_pcch_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle)
    {
        case RRM_OAM_DEF_PAG_CYCLE_RF32:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF32;
            break;

        case RRM_OAM_DEF_PAG_CYCLE_RF64:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF64;
            break;

        case RRM_OAM_DEF_PAG_CYCLE_RF128:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF128;
            break;

        case RRM_OAM_DEF_PAG_CYCLE_RF256:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF256;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                p_reconfig_req_from_mif->operator_info.sib_2_info.
                radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for default_paging_cycle: %d",
                    p_reconfig_req_from_mif->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle);
            ret_val = RRM_FAILURE;
    }

    /* SPR fix 23041 start */
    if ( RRMCM_RMIF_SIB_2_INFO_PRESENT & p_reconfig_req_from_mif->operator_info.bitmask )
    {
    ret_val=find_pcch_config_nb(p_reconfig_req_from_mif,p_rrc_rrm_cell_reconfig_req);
    }
    else
    {
        ret_val = pcch_config(
                p_cell_context,
                &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config));
    }
    /* SPR fix 23041 stop */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_sib3_intra_search_v920
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function updates the cell reconfig sib3 intra search v920 params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_sib3_intra_search_v920
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_intra_search_v920.s_intra_search_p_r9 = p_reconfig_req_from_mif->operator_info.sib_3_info.s_intra_search.s_intra_search_p_r9;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_intra_search_v920.s_intra_search_q_r9 = p_reconfig_req_from_mif->operator_info.sib_3_info.s_intra_search.s_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}


/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_sib3_non_intra_search_v920
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function updates the cell reconfig sib3 non intra search v920
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_sib3_non_intra_search_v920
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_non_intra_search_v920.s_non_intra_search_p_r9 = p_reconfig_req_from_mif->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_p_r9;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_non_intra_search_v920.s_non_intra_search_q_r9 = p_reconfig_req_from_mif->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_phich_config
 *   INPUT       : p_cell_context
 *   OUTPUT      ; p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the phich config info for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_phich_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;
    switch(p_reconfig_req_from_mif->operator_info.phich_config.phich_resource)
    {
        case RRM_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_ONE_SIXTH;
            break;

        case RRM_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_HALF;
            break;

        case RRM_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_ONE;
            break;

        case RRM_THREE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_TWO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = p_reconfig_req_from_mif->operator_info.phich_config.phich_resource;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of phich_resource: %d",
                    p_reconfig_req_from_mif->operator_info.phich_config.phich_resource);
            ret_val = RRM_FAILURE;
    }

    switch(p_reconfig_req_from_mif->operator_info.phich_config.phich_duration)
    {
        case RRM_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_duration = RRM_RRC_PHICH_D_NORMAL;
            break;

        case RRM_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_duration = RRM_RRC_PHICH_D_EXTENDED;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_duration = p_reconfig_req_from_mif->operator_info.phich_config.phich_duration;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of phich_duration: %d",
                    p_reconfig_req_from_mif->operator_info.phich_config.phich_duration);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_csg_phy_cell_id_range
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates csg phy cell id range for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_csg_phy_cell_id_range
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.csg_phy_cell_id_range.start = 
        p_reconfig_req_from_mif->operator_info.sib_4_info.csg_id_range.start;

    if(p_reconfig_req_from_mif->operator_info.sib_4_info.csg_id_range.bitmask & RRMCM_RMIF_CELL_ID_RANGE_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
            csg_phy_cell_id_range.presence_bitmask |= PHY_CELL_ID_RANGE ;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.csg_phy_cell_id_range.range = p_reconfig_req_from_mif->operator_info.sib_4_info.csg_id_range.range;
        //no. of elements in enum are not same. need to recheck
        switch(p_reconfig_req_from_mif->operator_info.sib_4_info.csg_id_range.range)
        {
            case RRM_OAM_N4:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_4;
                break;

            case RRM_OAM_N8:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_8;
                break;

            case RRM_OAM_N12:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_12;
                break;

            case RRM_OAM_N16:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_16;
                break;

            case RRM_OAM_N24:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_24;
                break;

            case RRM_OAM_N32:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_32;
                break;

            case RRM_OAM_N48:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_48;
                break;

            case RRM_OAM_N64:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_64;
                break;

            case RRM_OAM_N84:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_84;
                break;

            case RRM_OAM_N96:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_96;
                break;

            case RRM_OAM_N128:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_128;
                break;

            case RRM_OAM_N168:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_168;
                break;

            case RRM_OAM_N252:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_252;
                break;

            case RRM_OAM_N504:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_504;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = p_reconfig_req_from_mif->operator_info.sib_4_info.
                    csg_id_range.range;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "invalid value for range: %d",
                        p_reconfig_req_from_mif->operator_info.sib_4_info.
                        csg_id_range.range);
                ret_val = RRM_FAILURE;
        }

    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}



/****************************************************************************
 *   FUNCTION NAME       :   update_reconf_sib_type_9_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function updates the cell reconfig sib type 9 info
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
update_reconf_sib_type_9_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    /* SPR 14128 Fix Start */
    U8 hnb_count=RRM_ZERO;
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.presence_bitmask = RRM_ZERO;
    /* Start: CSR 00082391 */
    if(p_reconfig_req_from_mif->bitmask & RRMCM_RMIF_RRM_ACCESS_MGMT_PARAMS_PRESENT && p_cell_context->access_mgmt_params.access_mode != RRM_OAM_ACCESS_MODE_OPEN && p_reconfig_req_from_mif->access_mgmt_params.hnb_name_size > RRM_ZERO)
        /* END: CSR 00082391 */
        /* SPR 14128 Fix END */
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_9_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.size_of_hnb_id = p_reconfig_req_from_mif->access_mgmt_params.hnb_name_size;

        /*setting bitmask*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.presence_bitmask |= SIB_9_HNB_ID_PRESENCE_FLAG;

        for(hnb_count=RRM_ZERO; hnb_count < p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.size_of_hnb_id; hnb_count++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.hnb_id[hnb_count] = p_reconfig_req_from_mif->access_mgmt_params.hnb_name[hnb_count];
        }

    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/* CSR_00053776_CHANGES_START */    
//#ifdef TDD_MODE_FLAG
/* CSR_00053776_CHANGES_END */    

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_idle_mode_mobility_irat_utra_tdd
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates idle mode mobility
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_update_idle_mode_mobility_irat_utra_tdd( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    sib_type_6_Info_t               *p_sib_type_6_info       = RRM_PNULL;
    U8				     index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_sib_type_6_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_6_Info);

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    if ( RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT & 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask )
    {
        p_sib_type_6_info->presence_bitmask |= 
            SIB_6_CARRIER_FREQ_LIST_UTRA_TDD_PRESENCE_FLAG ;

        /*Filling Utran_FDD_list */
        p_sib_type_6_info->carrier_freq_list_utra_tdd.count =
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers;

        /* Fix for SPR 12929 Start */
        for(index = RRM_ZERO;(index < p_sib_type_6_info->carrier_freq_list_utra_tdd.count 
                    && p_sib_type_6_info->carrier_freq_list_utra_tdd.count 
                    <= RRM_MAX_NUM_UTRA_TDD_CARRIERS); index++)
            /* Fix for SPR 12929 End */
        {
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask = RRM_ZERO;
            /*arfcn_freq*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].carrier_freq =
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].utra_carrier_arfcn;

            /*q_rx_lev_min*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].q_rx_lev_min =
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].q_rx_lev_min;

            /* cell_reselection_priority*/
            if(RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT &
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[index].bitmask)
            {
                p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask |= 
                    CR_FREQ_UTRA_TDD_CELL_RESEL_PRI_PRESENCE_FLAG;

                p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].cell_reselection_priority =
                    p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[index].cell_reselection_priority;
            }

            /* thresh_x_high*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].thresh_x_high =
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].thresh_x_high;

            /*thresh_x_low*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].thresh_x_low =
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].thresh_x_low;

            /*p_max_utra*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].p_max_utra =
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].p_max_utra;

        }
    }

    return RRM_SUCCESS;
}
/* CSR_00053776_CHANGES_START */    
//#endif
/* CSR_00053776_CHANGES_END */    
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_idle_mode_mobility_irat_utra_fdd
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates idle mode mobility irat utra fdd
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_update_idle_mode_mobility_irat_utra_fdd( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL; /*info coming from mif*/
    sib_type_6_Info_t               *p_sib_type_6_info       = RRM_PNULL;/* info goes to rrc */
    U8				     index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /* info going to rrc in sib6 */
    p_sib_type_6_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_6_Info);

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    if ( RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT & 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask )
    {
        p_sib_type_6_info->presence_bitmask |= 
            SIB_6_CARRIER_FREQ_LIST_UTRA_FDD_PRESENCE_FLAG ;

        /*Filling Utran_FDD_list */
        p_sib_type_6_info->carrier_freq_list_utra_fdd.count =
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers;

        /* Fix for SPR 12929 Start */
        for(index = RRM_ZERO;(index < p_sib_type_6_info->carrier_freq_list_utra_fdd.count 
                    && p_sib_type_6_info->carrier_freq_list_utra_fdd.count 
                    <= RRM_MAX_NUM_UTRA_FDD_CARRIERS); index++)
            /* Fix for SPR 12929 End */
        {
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask = RRM_ZERO;
            /*arfcn_freq*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].carrier_freq=
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].utra_carrier_arfcn;

            /*q_rx_lev_min*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].q_rx_lev_min=
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].q_rx_lev_min;

            /*q_qual_min*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].q_qual_min=
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].q_qual_min;

            /* cell_reselection_priority*/
            if(RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT &
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].bitmask)
            {
                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask |= 
                    CR_FREQ_UTRA_FDD_CELL_RESEL_PRI_PRESENCE_FLAG;

                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].cell_reselection_priority =
                    p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].cell_reselection_priority;
            }

            /* thresh_x_high*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].thresh_x_high=
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].thresh_x_high;

            /*thresh_x_low*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].thresh_x_low=
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].thresh_x_low;

            /*p_max_utra*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].p_max_utra=
                p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].p_max_utra;

            /* threshx_q_r9*/
            if(RRMCM_RMIF_THRESHX_Q_R9_PRESENT & 
                    p_reconfig_req_from_mif->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].bitmask)
            {
                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask |= 
                    CR_FREQ_UTRA_FDD_THRESH_X_Q_R9_PRESENCE_FLAG;

                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                    thresh_x_q_r9.thresh_x_high_q_r9=
                    p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].threshx_q_r9.
                    thresh_serving_highq_r9;

                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                    thresh_x_q_r9.thresh_x_low_q_r9 =
                    p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].threshx_q_r9.
                    thresh_serving_lowq_r9;
            }

        }
    }

    return RRM_SUCCESS;
}


/****************************************************************************
 *   FUNCTION NAME  : rrm_update_idle_mod_mob_irat_utra_reselction_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates idle mode mobility irat utra reselection params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_idle_mod_mob_irat_utra_reselction_params( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    sib_type_6_Info_t               *p_sib_type_6_info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_sib_type_6_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_6_Info);
    RRM_ASSERT(RRM_PNULL != p_sib_type_6_info);

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;
    RRM_ASSERT(RRM_PNULL != p_reconfig_req_from_mif);

    p_sib_type_6_info->presence_bitmask |= SIB_6_T_RESELECTION_UTRA_SF_PRESENCE_FLAG;

    p_sib_type_6_info->t_resel_utra =  p_reconfig_req_from_mif->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
        irat_eutra_to_utra_reselection_params.t_reselection_utra;

    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.
            bitmask & RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT )
    {
        switch(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.
                speed_state_scale_factor.t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =
                    p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.
                    speed_state_scale_factor.t_reselection_eutra_sf_medium;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_medium= %d",
                        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.
                        irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;

                break;
        }

        switch(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.
                speed_state_scale_factor.t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = 
                    p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.
                    speed_state_scale_factor.t_reselection_eutra_sf_high;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_high= %d",
                        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.
                        speed_state_scale_factor.t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_idle_mode_mobility_irat_utra_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates idle mode mobility irat utra params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_idle_mode_mobility_irat_utra_params( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;
    RRM_ASSERT(RRM_PNULL != p_reconfig_req_from_mif);

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_6_Info.presence_bitmask = RRM_ZERO;

    ret_val = rrm_update_idle_mod_mob_irat_utra_reselction_params(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from rrm_update_idle_mod_mob_irat_utra_reselction_params");
    }

    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask & 
            RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT)
    {
        rrm_update_idle_mode_mobility_irat_utra_fdd(p_cell_context,
                p_rrc_rrm_cell_reconfig_req );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_idle_mode_mobility_irat_utra_fdd");
        }
    }

    /* update the TDD list */

    /* CSR_00053776_CHANGES_START */    
    //#ifdef TDD_MODE_FLAG
    /* CSR_00053776_CHANGES_END */    
    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask & 
            RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT)
    {
        rrm_update_idle_mode_mobility_irat_utra_tdd(p_cell_context,
                p_rrc_rrm_cell_reconfig_req );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_idle_mode_mobility_irat_utra_tdd");
        }
    }
    /* CSR_00053776_CHANGES_START */    
    //#endif
    /* CSR_00053776_CHANGES_END */    
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_idle_mode_mobility_intra_freq_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates idle mode mobility intra freq params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_idle_mode_mobility_intra_freq_params( rrm_cell_context_t   *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    /*coverity 23137: initialization changed to RRM_SUCCESS: ,rel 1.3*/   
    rrm_return_et ret_val = RRM_SUCCESS;

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    /* Filling parameter in SIB 1 */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.cell_selection_Info.q_rx_lev_min = 
        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_1;

    /* Filling parameter in SIB 1 */
    if(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
            bitmask & RRMCM_RMIF_Q_RX_LEV_MIN_OFFSET_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.cell_selection_Info.
            presence_bitmask |= CELL_SELECT_INFO_Q_RX_LEV_MIN_OFFSET_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.cell_selection_Info.q_rx_lev_min_offset = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.q_rx_lev_min_offset;
    }

    /* Filling parameter in SIB 3 */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.\
        q_rx_lev_min = p_reconfig_req_from_mif->ran_info.mobility_params.\
        idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
        q_rx_lev_min_sib_3;

    /* Filling parameter in SIB 3 */
    if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_P_MAX_SIB3_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.\
            presence_bitmask |= INTRA_FREQ_CELL_RESELECT_P_MAX_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.\
            p_max = p_reconfig_req_from_mif->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            p_max_sib_3;
    }

    /* Filling parameter in SIB 1 */
    if(p_reconfig_req_from_mif->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
            bitmask & RRMCM_RMIF_P_MAX_SIB1_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            presence_bitmask |= SIB_TYPE_1_P_MAX_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.p_max = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.p_max_sib_1;
    }

    /* Filling parameter in SIB 3 */
    if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.\
                idle_mode_mobility_intra_freq_params.bitmask & \
                RRMCM_RMIF_S_INTRA_SEARCH_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.\
            presence_bitmask |= INTRA_FREQ_CELL_RESELECT_INTRA_SEARCH_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.\
            s_intra_search = p_reconfig_req_from_mif->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
            s_intra_search;
    }

    /* Filling parameter in SIB 3 */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.neigh_cell_config = 
        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.neigh_cell_config;

    /* Filling parameter in SIB 3 */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.t_reselec_eutra = 
        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.t_reselection_eutra;

    /* Filling parameter in SIB 3 */
    if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.
            presence_bitmask |= INTRA_FREQ_CELL_RESELECT_EUTRAN_SF_PRESENCE_FLAG ;

        switch(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_medium = RRM_RRC_O_DOT_25;
                break;

            case RRM_OAM_O_DOT_5:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_medium = RRM_RRC_O_DOT_5;
                break;

            case RRM_OAM_O_DOT_75:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_medium = RRM_RRC_O_DOT_75;
                break;

            case RRM_OAM_l_DOT_0:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_medium = RRM_RRC_l_DOT_0;
                break;
            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_medium = RRM_RRC_l_DOT_0;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                        "Incorrect speed_scale_factors.t_reselection_eutra_sf_medium = %u",
                        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;
        }

        switch(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_high = RRM_RRC_O_DOT_25;
                break;

            case RRM_OAM_O_DOT_5:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_high = RRM_RRC_O_DOT_5;
                break;

            case RRM_OAM_O_DOT_75:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_high = RRM_RRC_O_DOT_75;
                break;

            case RRM_OAM_l_DOT_0:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_high = RRM_RRC_l_DOT_0;
                break;
            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.
                    t_reselect_eutra_sf.sf_high = RRM_RRC_l_DOT_0;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                        "Incorrect speed_scale_factors.t_reselection_eutra_sf_medium = %u",
                        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
        }
    }

    /* Filling parameter in SIB 3 */
    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.\
            idle_mode_mobility_intra_freq_params.bitmask & \
            RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.\
            presence_bitmask |= CELL_RESELECT_NON_INTRA_SEARCH_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.s_non_intra_search = 
            p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.s_non_intra_search;
    }

    /* Filling parameter in SIB 3 */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.thresh_serving_low = 
        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.thresh_serving_low;

    /* Filling parameter in SIB 3 */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.cell_reselect_priority =
        p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.\
        cell_reselection_priority;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_mobility_params_intra_inter_freq
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates mobility parameters for reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_update_mobility_params_intra_inter_freq(rrm_cell_context_t   *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req ,
        const rrmcm_rmif_cell_reconfig_req_t
        *p_reconfig_req_from_mif ) 
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            bitmask & RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS )
    {
        sib_presence_bitmask |= RRM_SIB_3_PRESENT;
        sib_presence_bitmask |= RRM_SIB_1_PRESENT;
        /* this function update the intra freq params*/
        ret_val = rrm_update_idle_mode_mobility_intra_freq_params(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_idle_mode_mobility_intra_freq_params");
        }
    }

    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            bitmask & RRMCM_MIF_IDLE_MODE_MOBILITY_INTER_FREQ_PARAMS)
    {
        sib_presence_bitmask |= RRM_SIB_5_PRESENT;
        /* this fucntion update the inter freq params*/
        ret_val = update_reconf_sib_type_5_Info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from update_reconf_sib_type_5_Info");
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_mobility_params_utra_geran_freq
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates mobility parameters for reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_update_mobility_params_utra_geran_freq(rrm_cell_context_t   *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req ,
        const rrmcm_rmif_cell_reconfig_req_t
        *p_reconfig_req_from_mif )
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* SPR 15328 start */
    U8 utra_fdd_count = p_cell_context->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.
        irat_eutran_to_utran_fdd_list.
        num_irat_eutran_to_utran_fdd_carriers;

    U8 utra_tdd_count = p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.
        irat_eutran_to_utran_tdd_list.
        num_irat_eutran_to_utran_tdd_carriers;

    U8 geran_carr_count = p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_irat_geran_params.
        irat_eutran_to_geran_list.
        num_irat_eutran_to_geran_carriers;

    /* SPR 15328 end */

    /* SPR 15328 start */
    if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT) &&
            ((utra_fdd_count > RRM_ZERO) || (utra_tdd_count > RRM_ZERO)))
        /* SPR 15328 end */
    {
        sib_presence_bitmask |= RRM_SIB_6_PRESENT;
        /*update the irat utras params*/
        ret_val = rrm_update_idle_mode_mobility_irat_utra_params(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_idle_mode_mobility_irat_utra_params");
        }
    }

     /* SPR 15328 start */
    if((p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT) &&
            (geran_carr_count > RRM_ZERO))
         /* SPR 15328 end */
    {
        sib_presence_bitmask |= RRM_SIB_7_PRESENT;
        /*this function update the geran list*/
        ret_val = update_reconf_sib_type_7_Info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from update_reconf_sib_type_7_Info");
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_mobility_params_for_reconfig
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates mobility parameters for reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_mobility_params_for_reconfig( rrm_cell_context_t   *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    const rrmcm_rmif_cell_reconfig_req_t    *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    if(p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_3_PRESENT;
        /* this function updates the common params of mobility*/
        ret_val = update_reconf_timecell_reselect_info_comm(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from update_reconf_timecell_reselect_info_comm");
        }
    }

    /*Klockwork_fix_start*/
    ret_val = rrm_update_mobility_params_intra_inter_freq(p_cell_context ,
            p_rrc_rrm_cell_reconfig_req ,p_reconfig_req_from_mif );
    /*Klockwork_fix_end*/

    /*Klockwork_fix_start*/
    ret_val = rrm_update_mobility_params_utra_geran_freq(p_cell_context ,
            p_rrc_rrm_cell_reconfig_req ,p_reconfig_req_from_mif );
    /*Klockwork_fix_end*/


    /* SIB 8 changes Start */
    if(  p_reconfig_req_from_mif->ran_info.mobility_params.idle_mode_mobility_params.
            bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT)
    {
        sib_presence_bitmask |= RRM_SIB_8_PRESENT;

        /* Fix for reconfig 27/06/2013 */
        ret_val = update_reconf_sib_type_8_Info(p_cell_context, 
                p_rrc_rrm_cell_reconfig_req); 
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from update_reconf_sib_type_8_Info");
        }

    }     
    /* SIB 8 changes end */

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_cell_restriction_access_barring_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates cell restriction access barring 
 information
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_cell_restriction_access_barring_info( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    const rrmcm_rmif_cell_reconfig_req_t    *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->ran_info.cell_restriction_params.
            cell_and_access_barring.barring_for_emergency)
    {
        case RRM_FALSE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                access_barring_info.acBarringForEmergency = RRC_FALSE;
            break;

        case RRM_TRUE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                access_barring_info.acBarringForEmergency = RRC_TRUE;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                access_barring_info.acBarringForEmergency = p_reconfig_req_from_mif->ran_info.cell_restriction_params.
                cell_and_access_barring.barring_for_emergency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"Inavlid value of barring_for_emergency: %d",
                    p_reconfig_req_from_mif->ran_info.cell_restriction_params.
                    cell_and_access_barring.barring_for_emergency);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME  : rrm_update_cell_restriction_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates cell restriction params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

/* SPR 10730 Fix Start */
rrm_return_et
rrm_update_cell_restriction_params( rrm_cell_context_t    
        *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req )
{
    const cell_restriction_params_t         *p_cell_restriction_param = RRM_PNULL; /*info coming from mif*/
    const rrmcm_rmif_cell_reconfig_req_t    *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et                           ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = ((rrmcm_rmif_cell_reconfig_req_t *)(p_cell_context->p_new_reconfig_data));

    p_cell_restriction_param = &(p_reconfig_req_from_mif->ran_info.cell_restriction_params);

    sib_presence_bitmask |= RRM_SIB_1_PRESENT;
    sib_presence_bitmask |= RRM_SIB_2_PRESENT;

    switch(p_cell_restriction_param->cell_and_access_barring.cell_barred)
    {
        case RRM_OAM_CELL_BARRED:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.cell_barred = RRM_RRC_CELL_BARRED;
            break;

        case RRM_OAM_CELL_NOT_BARRED:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.cell_barred = RRM_RRC_CELL_NOT_BARRED;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.cell_barred = p_reconfig_req_from_mif->ran_info.cell_restriction_params.
                cell_and_access_barring.cell_barred;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for cell_barred: %d",
                    p_reconfig_req_from_mif->ran_info.cell_restriction_params.
                    cell_and_access_barring.cell_barred);
            ret_val = RRM_FAILURE;
    }

    /* update in sib 2 */
    rrm_update_cell_restriction_access_barring_info(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);

    /*update cell_access_info.intra_frequency_reselection uin SIB 1*/ 
    /* BUG_371 FIX START */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        cell_access_related_info.intra_freq_reselection =
        p_reconfig_req_from_mif->ran_info.cell_restriction_params.
        cell_and_access_barring.cell_access_info.intra_frequency_reselection;
    /* BUG_371 FIX END */
    /*update cell_access_info.intra_frequency_reselection uin SIB 1*/ 
    /* BUG_371 FIX START */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        cell_access_related_info.intra_freq_reselection =
        p_reconfig_req_from_mif->ran_info.cell_restriction_params.
        cell_and_access_barring.cell_access_info.intra_frequency_reselection;
    /* BUG_371 FIX END */
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* SPR 10730 Fix End */


/****************************************************************************
 *   FUNCTION NAME  : rrm_update_and_update_mac_layer_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates mac layer params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_and_update_mac_layer_params( rrm_cell_context_t    
        *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params )
{

    const mac_layer_params_t        *p_mac_layer_params = RRM_PNULL; /* info from mif :*/
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_mac_layer_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.mac_layer_params);

    if(p_mac_layer_params->bitmask & RRMCM_RMIF_MAC_LAYER_PARAM_RACH_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        ret_val = update_reconf_rach_config_common( p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from update_reconf_rach_config_common");
        }
    }
    if( p_mac_layer_params->bitmask & RRMCM_RMIF_MAC_LAYER_PARAM_DRX_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "No Impact on Cell Reconfiguration for DRX modification. Ignoring for Cell Reconfiguration..");
        RRM_MEMCPY(&(p_cell_context->ran_info.mac_layer_params.mac_layer_param_drx),
                &(p_mac_layer_params->mac_layer_param_drx),
                sizeof(drx_t));
/*SPR_18881 Fix start*/
initialize_cell_context_for_drx_resources(p_cell_context);
/*SPR_18881 Fix end*/
    }
    /* BUG_371 FIX START */ 
    p_cell_reconfig_params->non_broadcast_info.mac_reconfig_params.n_gap = 
        p_mac_layer_params->n_gap;
    p_cell_reconfig_params->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_N_GAP_PRESENT;

    p_cell_reconfig_params->non_broadcast_info.mac_reconfig_params.ul_sync_loss_timer = 
        p_mac_layer_params->ul_sync_loss_timer ;
    p_cell_reconfig_params->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_UL_SYNC_LOSS_TIMER_PRESENT;
    p_cell_reconfig_params->presence_bitmask |= CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG;
    /* BUG_371 FIX END */


    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_tdd_config_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates tdd config params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

#ifdef TDD_MODE_FLAG
rrm_return_et
rrm_update_tdd_config_params( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params )
{

    const tdd_frame_structure_t    *p_tdd_frame_struct = RRM_PNULL;/* info cominf from mif */
    tdd_config_t                   *p_tdd_config_rrc = RRM_PNULL; /* info goes to rrc */

    RRM_UT_TRACE_ENTER();
    p_tdd_frame_struct = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure );
    RRM_ASSERT(RRM_PNULL != p_tdd_frame_struct);

    p_tdd_config_rrc = &(p_cell_reconfig_params->broadcast_info.sib_type_1_Info.tdd_config);
    RRM_ASSERT(RRM_PNULL != p_tdd_config_rrc);

    p_cell_reconfig_params->broadcast_info.sib_type_1_Info.presence_bitmask |= SIB_TYPE_1_TDD_CONFIG_PRESENT_FLAG;

    switch(p_tdd_frame_struct->sub_frame_assignment)
    {
        case RRM_OAM_SA0:
            p_tdd_config_rrc->sub_frame_assignment = sa_0;
            break;

        case RRM_OAM_SA1:
            p_tdd_config_rrc->sub_frame_assignment = sa_1;
            break;

        case RRM_OAM_SA2:
            p_tdd_config_rrc->sub_frame_assignment = sa_2;
            break;

        case RRM_OAM_SA3:
            p_tdd_config_rrc->sub_frame_assignment = sa_3;
            break;

        case RRM_OAM_SA4:
            p_tdd_config_rrc->sub_frame_assignment = sa_4;
            break;

        case RRM_OAM_SA5:
            p_tdd_config_rrc->sub_frame_assignment = sa_5;
            break;

        case RRM_OAM_SA6:
            p_tdd_config_rrc->sub_frame_assignment = sa_6;
            break;

        default :
            p_tdd_config_rrc->sub_frame_assignment = sa_2;
    }
    switch(p_tdd_frame_struct->special_sub_frame_patterns)
    {
        case RRM_OAM_SSP0:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_0;
            break;

        case RRM_OAM_SSP1:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_1;
            break;

        case RRM_OAM_SSP2:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_2;
            break;

        case RRM_OAM_SSP3:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_3;
            break;

        case RRM_OAM_SSP4:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_4;
            break;

        case RRM_OAM_SSP5:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_5;
            break;

        case RRM_OAM_SSP6:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_6;
            break;

        case RRM_OAM_SSP7:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_7;
            break;

        case RRM_OAM_SSP8:
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_8;
            break;

        default :
            p_tdd_config_rrc->special_sub_frame_pattern = ssp_6;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
#endif

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_ul_power_control
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical uplink power control
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_phy_ul_power_control( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params)
{
    const uplink_power_control_t           *p_ul_power_ctrl = RRM_PNULL; /* info coming from mif */
    uplink_power_control_common_t          *p_ul_power_ctrl_rrc = RRM_PNULL; /* info goes to rrc*/
    rrm_return_et                           ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_ul_power_ctrl = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_ul_power_control);
    RRM_ASSERT(RRM_PNULL != p_ul_power_ctrl);

    p_ul_power_ctrl_rrc = &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.uplink_power_control_common);
    RRM_ASSERT(RRM_PNULL != p_ul_power_ctrl_rrc);

    p_ul_power_ctrl_rrc->p_zero_nominal_Pusch = p_ul_power_ctrl->p_0_nominal_pusch;
    p_ul_power_ctrl_rrc->alpha = p_ul_power_ctrl->alpha;
    p_ul_power_ctrl_rrc->p_zero_nominal_pucch = p_ul_power_ctrl->p_0_nominal_pucch;

    /* BUG_371 FIX START */ 
    /* BUG_371 FIX END */ 
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_ul_ref_signal
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical uplink ref signal
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_phy_ul_ref_signal( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params)
{
    const ul_reference_signal_t    *p_ul_ref_signal_reconf = RRM_PNULL;/* info coming from mif*/
    pusch_config_common_t          *p_pusch_rrc = RRM_PNULL; /* info goes to rrc */

    RRM_UT_TRACE_ENTER();

    p_ul_ref_signal_reconf = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_ul_reference_signal);
    RRM_ASSERT(RRM_PNULL != p_ul_ref_signal_reconf);

    p_pusch_rrc =  &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.pusch_config_common);
    RRM_ASSERT(RRM_PNULL != p_pusch_rrc);

    p_pusch_rrc->ul_ref_signals_pusch.group_hopping_enabled = 
        p_ul_ref_signal_reconf->group_hopping_enabled;
    p_pusch_rrc->ul_ref_signals_pusch.group_assign_pusch = 
        p_ul_ref_signal_reconf->group_assignment_pusch;
    p_pusch_rrc->ul_ref_signals_pusch.seq_hopping_enabled = 
        p_ul_ref_signal_reconf->sequence_hopping_enabled;
    p_pusch_rrc->ul_ref_signals_pusch.cyclic_shift = 
        p_ul_ref_signal_reconf->cyclic_shift;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_pusch
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical pusch
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_phy_pusch( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params)
{
    const pusch_t                  *p_pusch_reconfig = RRM_PNULL; /* info coming from mif*/
    pusch_config_common_t          *p_pusch_rrc = RRM_PNULL; /* info goes to rrc */
    RRM_UT_TRACE_ENTER();

    p_pusch_reconfig = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_pusch);
    RRM_ASSERT(RRM_PNULL != p_pusch_reconfig);

    p_pusch_rrc =  &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.pusch_config_common);
    RRM_ASSERT(RRM_PNULL != p_pusch_rrc);

    p_pusch_rrc->pusch_config_basic.nsb = p_pusch_reconfig->n_sb;
    p_pusch_rrc->pusch_config_basic.hopping_mode = p_pusch_reconfig->pusch_hopping_mode;
    p_pusch_rrc->pusch_config_basic.pusch_hopping_offset = p_pusch_reconfig->hopping_offset;
    p_pusch_rrc->pusch_config_basic.enable_64_qam = p_pusch_reconfig->enable_64_qam;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_pucch_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical pucch info
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_phy_pucch_info( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params)
{

    const pucch_t                  *p_pucch_reconfig = RRM_PNULL; /* info coming from mif*/
    pucch_config_common_t    *p_pucch_rrc = RRM_PNULL; /* info goes to rrc*/
    pucch_t                  *p_pucch_config = RRM_PNULL; /* info coming from mif*/

    RRM_UT_TRACE_ENTER();
    /* Klocwork changes start 22 may */
    RRM_ASSERT(RRM_PNULL != p_cell_context);
    /* Klocwork changes end 22 may */
    p_pucch_reconfig = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_pucch); 
    RRM_ASSERT(RRM_PNULL != p_pucch_reconfig);

    p_pucch_rrc = &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.pucch_config_common);
    RRM_ASSERT(RRM_PNULL != p_pucch_rrc);

    p_pucch_config = &(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_pucch);
    RRM_ASSERT(RRM_PNULL != p_pucch_config);

    if ((p_pucch_config->delta_pucch_shift != p_pucch_reconfig->delta_pucch_shift) ||
            (p_pucch_config->n_rb_cqi != p_pucch_reconfig->n_rb_cqi) ||
            (p_pucch_config->n_cs_an != p_pucch_reconfig->n_cs_an) ||
            (p_pucch_config->n1_pucch_an != p_pucch_reconfig->n1_pucch_an))
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
    }

    p_pucch_rrc->delta_pucch_shift = p_pucch_reconfig->delta_pucch_shift;
    p_pucch_rrc->n_rb_cqi = p_pucch_reconfig->n_rb_cqi;
    p_pucch_rrc->n_cs_an = p_pucch_reconfig->n_cs_an;
    p_pucch_rrc->n_one_pucch_an = p_pucch_reconfig->n1_pucch_an;

    /* BUG_371 FIX START */ 
    p_cell_reconfig_params->non_broadcast_info.mac_reconfig_params.pucch_cqi_sinr_value = p_pucch_reconfig->pucch_cqi_sinr_value ;
    p_cell_reconfig_params->presence_bitmask |= CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG; 
    p_cell_reconfig_params->non_broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG;
    p_cell_reconfig_params->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_PUCCH_CQI_SINR_THRESHOLD_PRESENT;
    /* BUG_371 FIX END */ 
#ifdef TDD_MODE_FLAG
    if (p_pucch_reconfig->bitmask & PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT)
    {
        p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_pucch.tdd_ack_nack_feedback_mode = 
            p_pucch_reconfig->tdd_ack_nack_feedback_mode;
    }
#endif    

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_prach_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical prach information
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_update_phy_prach_info( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params )
{
    const prach_t		*p_prach_reconfig = RRM_PNULL;/* info coming from mif */
    prach_config_sib_t          *p_prach_sib_2 = RRM_PNULL; /* info goes to rrc */

    RRM_UT_TRACE_ENTER();

    p_prach_reconfig = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_prach);
    RRM_ASSERT(RRM_PNULL != p_prach_reconfig);

    p_prach_sib_2 = &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.prach_config_sib);
    RRM_ASSERT(RRM_PNULL != p_prach_sib_2);

    p_prach_sib_2->root_seq_index = p_prach_reconfig->root_sequence_index;

    p_prach_sib_2->prach_config_info.prach_config_index =
        p_prach_reconfig->configuration_index;

    p_prach_sib_2->prach_config_info.high_speed_flag =
        p_prach_reconfig->high_speed_flag;

    p_prach_sib_2->prach_config_info.zero_cor_zone_config = 
        p_prach_reconfig->zero_correlation_zone_config; 

    p_prach_sib_2->prach_config_info.prach_freq_offset = p_prach_reconfig->frequency_offset;

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_srs_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical srs information
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_phy_srs_info( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params )
{

    const srs_t                    *p_srs_info = RRM_PNULL; /* info coming form mif */
    sounding_rs_ul_config_common_t *p_srs_sib_2 = RRM_PNULL; /* info goes to rrc */

    RRM_UT_TRACE_ENTER();

    p_srs_info =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_srs);
    RRM_ASSERT(RRM_PNULL != p_srs_info);

    /* update in sib2*/
    p_srs_sib_2 = &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.sounding_rs_ul_config_common);
    RRM_ASSERT(RRM_PNULL != p_srs_sib_2);

    p_srs_sib_2->presence_bitmask = RRM_ZERO;
    if (RRM_TRUE == p_srs_info->srsEnabled)
    {
        p_srs_sib_2->presence_bitmask |= SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG;
        p_srs_sib_2->setup.presence_bitmask = RRM_ZERO;
        p_srs_sib_2->setup.srs_bw_config = p_srs_info->srs_bandwidth_config;
        p_srs_sib_2->setup.srs_subframe_config = p_srs_info->srs_subframe_config;
        p_srs_sib_2->setup.ack_nack_srs_simul_trans = p_srs_info->ack_nack_srs_simultaneous_transmission;

#ifdef TDD_MODE_FLAG
        if (p_srs_info->bitmask & RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT)
        {
            /*BUG_931_CHANGES_START*/
            p_srs_sib_2->setup.srs_max_up_pts = RRM_SRS_MAX_UP_PTS_TRUE;
            /*BUG_931_CHANGES_END*/
            p_srs_sib_2->setup.presence_bitmask |= 
                SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG;
        }
#endif
    }


    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/* update in sib2*/
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_phy_pdsch_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical pdsch information
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_phy_pdsch_info( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params )
{

    const pdsch_t                *p_pdsch_info = RRM_PNULL; /* info coming form mif */
    pdsch_config_common_t        *p_pdsh_sib_2 = RRM_PNULL; /* info goes to rrc */
    rrm_return_et                ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    p_pdsch_info =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
            physical_layer_param_pdsch);
    RRM_ASSERT(RRM_PNULL != p_pdsch_info);

    /* update in sib2*/
    p_pdsh_sib_2 = &(p_cell_reconfig_params->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.pdsch_config_common);
    RRM_ASSERT(RRM_PNULL != p_pdsh_sib_2);

    if (p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_pdsch.p_b != p_pdsh_sib_2->pb)
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        switch( p_pdsch_info->p_b)
        {

            case RRM_OAM_PB0:
                p_pdsh_sib_2->pb = RRM_OAM_PB0;
                break;
            case RRM_OAM_PB1:
                p_pdsh_sib_2->pb = RRM_OAM_PB1;
                break;
            case RRM_OAM_PB2:
                p_pdsh_sib_2->pb = RRM_OAM_PB2;
                break;
            case RRM_OAM_PB3:
                p_pdsh_sib_2->pb = RRM_OAM_PB3;
                break;
            default :
                p_pdsh_sib_2->pb = RRM_OAM_PB0;
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for p_b  = %d",p_pdsch_info->p_b);
        } 
    } 

    /* No need to set the bitmask for below 2 params as these are UE specific */
    /* update p_a in cell context */
    p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_pdsch.p_a =
        p_pdsch_info->p_a;

    p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_pdsch.p_a_for_cell_edge_ue =
        p_pdsch_info->p_a_for_cell_edge_ue;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       : rrm_update_prs_reconfig_info
 *   INPUT       : p_cellm_prs_config
 *   OUTPUT      : p_mac_config_info
 *   DESCRIPTION :
 *    		This function Maps the PRS reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *****************************************************************************/
rrm_return_et
rrm_update_prs_reconfig_info
(
 rrm_cell_context_t               *p_cell_context,
 rrc_rrm_cell_reconfig_req_t      *p_rrc_cell_reconfig
 )
{
    rrm_return_et ret_val = RRM_FAILURE;
    prs_t            *p_cellm_prs_config  = RRM_PNULL;
    rrc_mac_reconfig_t *p_mac_config_info = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_cell_context && RRM_PNULL != p_rrc_cell_reconfig)
    {
        p_cellm_prs_config = &(((rrmcm_rmif_cell_reconfig_req_t *)
                    (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params.
                physical_layer_param_prs);
        p_mac_config_info =  &(p_rrc_cell_reconfig->non_broadcast_info.mac_reconfig_params);

        if(p_cellm_prs_config != RRM_PNULL && p_mac_config_info != RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "  prev prs_enable =%d, new  prs_enable =%d",
                    p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable,
                    p_cellm_prs_config->prs_enable);
            if(p_cellm_prs_config->prs_enable == RRM_TRUE)
            {
                /* SPR 8338: code changes start */
                if((p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.num_prs_resource_blocks != 
                            p_cellm_prs_config->num_prs_resource_blocks) ||
                        (p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable == RRM_FALSE))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "  prs_bandwidth reconfigure prev num_prs_resource_blocks =%d, new num_prs_resource_blocks=%d ",
                            p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.num_prs_resource_blocks,
                            p_cellm_prs_config->num_prs_resource_blocks);
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_BANDWIDTH_INFO_PRESENT;
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_bandwidth_info.prs_bandwidth                   =
                        p_cellm_prs_config->num_prs_resource_blocks;
                    ret_val = RRM_SUCCESS;
                }
                /* SPR 8338: code changes end */
                /* SPR 950: code changes start */
                if((p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.num_consecutive_prs_subfames != 
                            p_cellm_prs_config->num_consecutive_prs_subfames) ||
                        (p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable == RRM_FALSE))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "  prs_subframes reconfigure prev num_consecutive_prs_subfames =%d, num_consecutive_prs_subfames=%d ",
                            p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.num_consecutive_prs_subfames,
                            p_cellm_prs_config->num_consecutive_prs_subfames);
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_SUBFRAMES_INFO_PRESENT;
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_subframes_info.prs_subframes                   =
                        p_cellm_prs_config->num_consecutive_prs_subfames;
                    ret_val = RRM_SUCCESS;
                }

                if((p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_configuration_index != 
                            p_cellm_prs_config->prs_configuration_index) ||
                        (p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable == RRM_FALSE))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "  prs_config_index reconfigure prev prs_configuration_index =%d, new prs_configuration_index=%d ",
                            p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_configuration_index,
                            p_cellm_prs_config->prs_configuration_index);
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_CONFIG_INDEX_INFO_PRESENT;
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_config_index_info.prs_config_index             =
                        p_cellm_prs_config->prs_configuration_index;
                    ret_val = RRM_SUCCESS;
                }
                if((p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_transmission_power != 
                            p_cellm_prs_config->prs_transmission_power) ||
                        (p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable == RRM_FALSE))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "  prs_transmission_power reconfigure prev prs_transmission_power =%d, prs_transmission_power=%d ",
                            p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_transmission_power,
                            p_cellm_prs_config->prs_transmission_power);
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_TRANSMISSION_POWER_INFO_PRESENT;
                    p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_transmission_power_info.prs_transmission_power =
                        p_cellm_prs_config->prs_transmission_power;
                    ret_val = RRM_SUCCESS;
                }

                if((RRM_MEMCMP(&(p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration), 
                                &(p_cellm_prs_config->prs_muting_configration),sizeof(rrm_oam_prs_muting_configration_t)) != RRM_ZERO)||
                        (p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable == RRM_FALSE))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "  prs_muting_configration reconfigure ");
                    if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_TWO_PRESENT)
                    {
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                            p_cellm_prs_config->prs_muting_configration.muting_config_two;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N2;

                    }
                    else if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_FOUR_PRESENT)
                    {
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                            p_cellm_prs_config->prs_muting_configration.muting_config_four;

                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N4;
                    }
                    else if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_EIGHT_PRESENT)
                    {
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                            p_cellm_prs_config->prs_muting_configration.muting_config_eight;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N8;
                    }
                    else if(p_cellm_prs_config->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT)
                    {
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                            p_cellm_prs_config->prs_muting_configration.muting_config_sixteen;
                        p_mac_config_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N16;
                    }
                    ret_val = RRM_SUCCESS;
                }
                if(ret_val == RRM_SUCCESS)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            " Change in PRS configuration so Reconfigure PRS info in cell_reconfig");
                    p_mac_config_info->prs_reconfig_info.bitmask |= RRC_RRM_RECONFIG_PRS_CONFIG_PRESENT ;
                    p_mac_config_info->prs_reconfig_info.request_type                  = RRM_TRUE;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            " No change in PRS configuration");
                }
                /* SPR 950: code changes end */
            }
            else
            {
                /* SPR 950: code changes start */
                if(p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable == RRM_TRUE)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            " prs_enable is false releaseing PRS in cell_reconfig");
                    p_mac_config_info->prs_reconfig_info.request_type                  = RRM_FALSE;
                    ret_val = RRM_SUCCESS;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            " previous prs_enable=%d , new prs_enable =%d",
                            p_cell_context->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable,
                            p_cellm_prs_config->prs_enable);
                }
                /* SPR 950: code changes end */
            }
        }
    }
    RRM_UT_TRACE_EXIT(); 
    return ret_val;
}

/* this function chcek the bitmask for every elemnt in side phy params. if its
   is present then it check, which sibs are affected for reconfig of those params*/
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_and_update_phy_layer_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_cell_reconfig_params
 *   DESCRIPTION : This function updates physical layer params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_and_update_phy_layer_params( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_cell_reconfig_params)
{

    const rrm_physical_layer_params_t        *p_phy_layer_params = PNULL;
    rrm_return_et                            ret_val = RRM_SUCCESS;


    RRM_UT_TRACE_ENTER();

    p_phy_layer_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params);

    if( p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT )
    {
        /* Update the PDSCH info in Cell Reconfig API;*/
        ret_val = rrm_update_phy_pdsch_info(p_cell_context,p_cell_reconfig_params);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_pdsch_info");
        }
    }

    if(p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT) 
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        /* Update the SRS info in Cell Reconfig API;*/
        ret_val = rrm_update_phy_srs_info(p_cell_context, p_cell_reconfig_params);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_srs_info");
        }
    }
    if( p_phy_layer_params->bitmask & 
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        /* Update the PRACH info in Cell Reconfig API;*/
        ret_val = rrm_update_phy_prach_info(p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_prach_info");
        }
    }
    if( p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT )
    {
        /* Update the PUCCH info in Cell Reconfig API;*/
        ret_val = rrm_update_phy_pucch_info(p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_pucch_info");
        }
    }
    if( p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        /* Update the PUSCH info in Cell Reconfig API;*/
        rrm_update_phy_pusch( p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_pusch");
        }
    }
    if( p_phy_layer_params->bitmask & 
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        /* Update the UL Reference Signal Info in Cell Reconfig API;*/
        rrm_update_phy_ul_ref_signal( p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_ul_ref_signal");
        }

    }
    if( p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        /* Update the UL Power Control info in Cell Reconfig API;*/
        rrm_update_phy_ul_power_control( p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_phy_ul_power_control");
        }
    }
    if( p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT )
    {
        /* Update the PRS inffo in Cell Reconfig API;*/
        ret_val = rrm_update_prs_reconfig_info( p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_prs_reconfig_info");
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "PRS Reconfiguration filled in rrc reconfig");
            sib_presence_bitmask |= RRM_NON_BROADCAST_INFO_PRESENCE_FLAG;
            sib_presence_bitmask |= RRM_NBROADCAST_MAC_RECONF_PRESENT_FLAG;
            sib_presence_bitmask |= RRM_NBROADCAST_MAC_PRS_RECONF_PRESENT_FLAG;
        }
    }
#ifdef TDD_MODE_FLAG
    if( p_phy_layer_params->bitmask &
            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT )
    {
        sib_presence_bitmask |= RRM_SIB_1_PRESENT;
        /* Update the TDD Config info in Cell Reconfig API;*/
        rrm_update_tdd_config_params( p_cell_context,
                p_cell_reconfig_params );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_tdd_config_params");
        }
    }
#endif

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_rf_params_ul_bandwidth
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req 
 *   DESCRIPTION : This function updates rf params of uplink bandwidth
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_rf_params_ul_bandwidth(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;


    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        freq_info.presence_bitmask |= FREQ_INFO_UL_BW_PRESENCE_FLAG;
    switch(p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.
            ul_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = RRM_RRC_UL_BW_6RB;
            break;

        case RRM_OAM_BW_N_15:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = RRM_RRC_UL_BW_15RB;
            break;

        case RRM_OAM_BW_N_25:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = RRM_RRC_UL_BW_25RB;
            break;

        case RRM_OAM_BW_N_50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = RRM_RRC_UL_BW_50RB;
            break;

        case RRM_OAM_BW_N_75:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = RRM_RRC_UL_BW_75RB;
            break;

        case RRM_OAM_BW_N_100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = RRM_RRC_UL_BW_100RB;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_bandwidth = 
                p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.
                ul_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for ul_bandwidth: %d",
                    p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.
                    ul_bandwidth);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_rf_params_dl_bandwidth
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates rf params of downlink bandwidth
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_rf_params_dl_bandwidth(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    /*coverity 23145: ret_val used at the end of function: , rel 1.3*/
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->ran_info.rf_params.
            rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_6;
            break;

        case RRM_OAM_BW_N_15:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_15;
            break;

        case RRM_OAM_BW_N_25:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_25;
            break;

        case RRM_OAM_BW_N_50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_50;
            break;

        case RRM_OAM_BW_N_75:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_75;
            break;

        case RRM_OAM_BW_N_100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_100;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = p_reconfig_req_from_mif->ran_info.rf_params.
                rf_configurations.dl_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for dl_band_width: %d",
                    p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.dl_bandwidth);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    /*RRM_SUCCESS replaced with ret_val, , rel 1.3*/
    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_rf_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates rf params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_rf_params( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req )
{

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.freq_band_indicator = 
        p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.frequency_band_indicator;

    /* update dl earfcn :*/
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.dl_earfcn = 
        p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.dl_earfcn;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |=
        RRC_RRM_RECONFIG_PHY_CELL_PARAMS_DL_EARFCN_PRESENT ;


    /* update reference_signal_power*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pdsch_config_common.ref_signal_power = 
        p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.reference_signal_power;


    /*update phy cell id*/
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.phys_cell_id = 
        p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.phy_cell_id;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |=
        RRC_RRM_RECONFIG_PHY_CELL_ID;

    /* this fun update the psch_power_offset and ssch_power_offset */
    update_reconf_sync_signals(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    /* Bug 632 Fix Start */
#ifndef TDD_MODE_FLAG
    if(p_reconfig_req_from_mif->ran_info.rf_params.rf_configurations.bitmask & 
            RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT )
    {
        rrm_update_rf_params_ul_bandwidth(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
#endif    
    /* Bug 632 Fix End */

    rrm_update_rf_params_dl_bandwidth(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);

    /* pbch_power_offset NA for reconfig */

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_ran_info_lte_ncl_inter_freq_param
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates ran info lte ncl inter freq param
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_ran_info_lte_ncl_inter_freq_param(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    U16                              carrier_arfcn = RRM_ZERO;
    U8                               inter_freq_list = RRM_ZERO;
    U8                               valid_inter_frq_list = RRM_ZERO;
    U8                               neigh_count = RRM_ZERO;
    U8                               black_count = RRM_ZERO;
    sib_type_5_Info_t                *p_sib_type_5_info = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    p_sib_type_5_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info); 

    valid_inter_frq_list =  p_sib_type_5_info->inter_freq_carrier_freq_list_list.count;

    for( inter_freq_list = RRM_ZERO; inter_freq_list < valid_inter_frq_list ;
            inter_freq_list++  )
    {
        carrier_arfcn =  p_sib_type_5_info->\
                         inter_freq_carrier_freq_list_list.\
                         inter_freq_carrier_freq_list[inter_freq_list].\
                         eutra_dl_carrier_freq;

        if( carrier_arfcn == p_reconfig_req_from_mif->ran_info.ncl_params.
                lte_ncl.inter_freq_cells[inter_freq_list].eutra_carrier_arfcn )
        {
            if( RRM_FALSE == p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                    inter_freq_cells[inter_freq_list].blacklisted )
            {
                p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list].
                    inter_freq_neigh_cell_list.neigh_cell[neigh_count].q_offset_cell =
                    p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                    inter_freq_cells[inter_freq_list].q_offset;

                p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list].
                    inter_freq_neigh_cell_list.neigh_cell[neigh_count].phys_cell_id =
                    p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                    inter_freq_cells[inter_freq_list].phy_cell_id;

                /*setting bitmask*/
                p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list].
                    presence_bitmask |= INTER_FREQ_CARR_NEIGH_CELL_LIST_PRESENCE_FLAG;

                neigh_count++;
            }
            else
            {
                p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list].
                    inter_freq_black_listed_cell_list.
                    black_listed_cell[black_count].presence_bitmask = RRM_ZERO;

                p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list].
                    inter_freq_black_listed_cell_list.
                    black_listed_cell[black_count].start =
                    p_reconfig_req_from_mif->ran_info.ncl_params.lte_ncl.
                    inter_freq_cells[inter_freq_list].phy_cell_id;

                black_count++;

                /*setting bitmask*/
                p_sib_type_5_info->inter_freq_carrier_freq_list_list.
                    inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |=
                    INTER_FREQ_CARR_BLACK_LIST_CELL_LIST_PRESENCE_FLAG;
            }
        }
    }

    p_sib_type_5_info->inter_freq_carrier_freq_list_list.
        inter_freq_carrier_freq_list[inter_freq_list].
        inter_freq_neigh_cell_list.count = neigh_count;

    p_sib_type_5_info->inter_freq_carrier_freq_list_list.
        inter_freq_carrier_freq_list[inter_freq_list].
        inter_freq_black_listed_cell_list.count = black_count; 

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;

}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_ran_info_neighbour_cell
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates ran info neighbour cells 
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_ran_info_neighbour_cell(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    if(p_reconfig_req_from_mif->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT )
    {

        sib_presence_bitmask |= RRM_SIB_4_PRESENT;
        sib_presence_bitmask |= RRM_SIB_5_PRESENT;

        /* NOTE: currently other params of lte ncl like cio,r_stx_power,x2_status,cell_access_mode
           are not being set in cell config  and reconfig */
        /* this function updates the lte's intra freq neighbour cell list info : q_offset,phy_cell_id */
        update_reconf_intra_freq_neigh_black_cell_list(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        /* update inter freq ncls */
        rrm_update_ran_info_lte_ncl_inter_freq_param(p_cell_context,
                p_rrc_rrm_cell_reconfig_req );
    }
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_and_update_ran_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates ran info 
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_and_update_ran_info(rrm_cell_context_t
        *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et        ret_val = RRM_SUCCESS;
    const ran_t          *p_ran_info = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->ran_info);
    RRM_UT_TRACE_ENTER();
    if( p_ran_info->bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT )
    {
        ret_val = rrm_update_and_update_phy_layer_params(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_and_update_phy_layer_params");
        }
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT )
    {
        ret_val = rrm_update_and_update_mac_layer_params(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_and_update_phy_layer_params");
        }
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_RLC_LAYER_PARAMS_PRESENT )
    {
        /* SPR 7841 FIX START*/
        RRM_MEMCPY(&(p_cell_context->ran_info.rlc_layer_params),
                &(p_ran_info->rlc_layer_params),
                sizeof(rlc_layer_params_t));
        /* SPR 7841 FIX END*/
    }
    if((p_ran_info->bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT ) &&
            (p_ran_info->mobility_params.bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT))
    {
        ret_val = rrm_update_mobility_params_for_reconfig(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_mobility_params_for_reconfig");
        }
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT )
    {

        /* this function does not update the some params of 
           timer and constants */
        ret_val = update_reconf_ue_timers_and_constants(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from update_reconf_ue_timers_and_constants");
        }
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT )
    {
        /* bitmask set for SIBS set and unset utilization*/
        sib_presence_bitmask |= RRM_NON_BROADCAST_INFO_PRESENCE_FLAG;
        sib_presence_bitmask |= RRM_MIB_INFO_PRESENT;
        sib_presence_bitmask |= RRM_SIB_1_PRESENT;
        sib_presence_bitmask |= RRM_SIB_2_PRESENT;
        sib_presence_bitmask |= RRM_NBROADCAST_CELL_PARAM_PRESENT_FLAG;
        sib_presence_bitmask |= RRM_NBROADCAST_SYNC_SIGNAL_PRESENT_FLAG;

        /* update RF Parameters indicator*/
        ret_val = rrm_update_rf_params(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_rf_params");
        }
    }
    /* UE Specific */
    if( p_ran_info->bitmask & RRMCM_RMIF_COMMON_EUTRAN_PARAMS_PRESENT)
    {
        RRM_MEMCPY(&(p_cell_context->ran_info.common_eutran_params),
                &(p_ran_info->common_eutran_params),
                sizeof(common_eutran_params_t));
    }
    /* UE Specific */
    if( p_ran_info->bitmask & RRMCM_RMIF_S1AP_PARAMS_PRESENT)
    {
        RRM_MEMCPY(&(p_cell_context->ran_info.s1ap_params),
                &(p_ran_info->s1ap_params),
                sizeof(s1ap_params_t));
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT )
    {
        rrm_update_ran_info_neighbour_cell(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    /* UE Specific */
    if( p_ran_info->bitmask & RRMCM_RMIF_CONNECTED_MODE_MOBILITY_PARAMS_PRESENT)
    {
        RRM_MEMCPY(&(p_cell_context->ran_info.connected_mode_mobility_params),
                &(p_ran_info->connected_mode_mobility_params),
                sizeof(rrm_connected_mode_mobility_params_t));
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT)
    {
        /* SPR 16012 Fix Start */
        if ( CELL_STATE_ALREADY_BLOCKED == p_cell_context->cell_state )
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.cell_barred = RRM_OAM_CELL_BARRED;
        } 
        /* SPR 16012 Fix Stop */


        /*spr_12271_fix_start*/
        sib_presence_bitmask |= RRM_SIB_1_PRESENT;
        /*spr_12271_fix_end*/
        /* SPR 14912 Fix Start */
        if(p_ran_info->cell_restriction_params.cell_and_access_barring.cell_barred != p_cell_context->ran_info.
                cell_restriction_params.cell_and_access_barring.cell_barred)
            /* SPR 14912 Fix End */
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.cell_barred =
                p_ran_info->cell_restriction_params.cell_and_access_barring.cell_barred;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "cell_barred updated [%d]",
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.cell_access_related_info.cell_barred);
        }

        /* SPR 14912 Fix Start */
        if(p_ran_info->cell_restriction_params.cell_and_access_barring.barring_for_emergency!= p_cell_context->ran_info.
                cell_restriction_params.cell_and_access_barring.barring_for_emergency)
        {
            sib_presence_bitmask |= RRM_SIB_2_PRESENT;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                access_barring_info.acBarringForEmergency=
                p_ran_info->cell_restriction_params.cell_and_access_barring.barring_for_emergency;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Barring FoR Emergency [%d]",
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.acBarringForEmergency);
        }
        /* SPR 14912 Fix End */
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_general_epc_info_plmn_list
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates general epc info for plmn list.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_general_epc_info_plmn_list( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;
    U8                              valid_plmn = RRM_ZERO;
    U8                              plmn_count = RRM_ZERO;
    U8                              mcc_digits = RRM_ZERO;
    U8                              mnc_digits = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    valid_plmn = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        cell_access_related_info.plmn_Id_info_list.count =
        p_reconfig_req_from_mif->epc_info.epc_params.general_epc_params.
        num_valid_plmn; 

    /* SPR 10730 Fix Start */
    for(plmn_count = RRM_ZERO; plmn_count < valid_plmn; plmn_count++)
    {
        if(p_reconfig_req_from_mif->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].plmn_id.bitmask & RRMCM_MCC_PRESENCE_BITMASK)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.
                presence_bitmask = RRM_ZERO;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.
                presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

            for(mcc_digits = RRM_ZERO; mcc_digits < MAX_MCC_DIGITS; mcc_digits++)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.
                    plmn_identity_info[plmn_count].plmn_identity.mcc[mcc_digits] =
                    p_reconfig_req_from_mif->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].plmn_id.mcc[mcc_digits];
            }
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.plmn_Id_info_list.
            plmn_identity_info[plmn_count].plmn_identity.mnc.count =
            p_reconfig_req_from_mif->epc_info.epc_params.
            general_epc_params.plmn_list[plmn_count].plmn_id.num_mnc_digit;

        for (mnc_digits = RRM_ZERO; mnc_digits <
                p_reconfig_req_from_mif->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].plmn_id.num_mnc_digit; mnc_digits++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.mnc.mnc[mnc_digits] =
                p_reconfig_req_from_mif->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].plmn_id.mnc[mnc_digits];
        }


        if(p_reconfig_req_from_mif->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].bitmask & RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT)
        {

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].cell_res_for_operator_use =
                p_reconfig_req_from_mif->epc_info.
                epc_params.general_epc_params.plmn_list[plmn_count].cell_reserved_for_operator_use;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Updated parameter cell_reserved_for_operator_use as [%d]",
                    p_reconfig_req_from_mif->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].cell_reserved_for_operator_use);
        }
    } 
    /* SPR 10730 Fix End */


    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_general_epc_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates general epc info.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_general_epc_info(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req )
{
    U8				    eaid_count = RRM_ZERO;
    U8                              tac_size = RRM_ZERO;
    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et                   ret_val = RRM_SUCCESS;
    /*BUG_866_CHANGES_START*/
    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/
    /*BUG_866_CAHNGES_END*/

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)\
                              p_cell_context->p_new_reconfig_data;

    /*BUG_866_CHANGES_START*/
    if(p_reconfig_req_from_mif->epc_info.epc_params.bitmask &
            RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT)
    {
        if(p_reconfig_req_from_mif->epc_info.epc_params.general_epc_params.bitmask &
                RRMCM_RMIF_EA_ID_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->presence_bitmask |=
                CELL_RECONFIG_REQ_API_EMERGENCY_AREA_ID_PRESENCE_FLAG;
            for(eaid_count=RRM_ZERO; eaid_count<MAX_EAID; eaid_count++)
            {
                p_rrc_rrm_cell_reconfig_req->emergency_area_id[eaid_count] =
                    p_reconfig_req_from_mif->epc_info.epc_params.general_epc_params.eaid[eaid_count];
            }
        }

        for(tac_size=RRM_ZERO; tac_size < MAX_TAC_SIZE; tac_size++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.tac[tac_size] =
                p_reconfig_req_from_mif->epc_info.epc_params.general_epc_params.tac[tac_size];
        }

        ret_val = rrm_update_general_epc_info_plmn_list(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from rrm_update_general_epc_info_plmn_list");
        }
    }

    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_reconfig_epc_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates reconfig epc info.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_reconfig_epc_info(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et        ret_val = RRM_SUCCESS;
    /*BUG_866_CHANGES_START*/
    /* Code Deleetd */
    /*BUG_866_CHANGES_END*/

    RRM_UT_TRACE_ENTER();

    /*BUG_866_CHANGES_START*/
    /* Code Deleetd */
    /*BUG_866_CHANGES_END*/
    /* update the general epc params*/
    sib_presence_bitmask |= RRM_SIB_1_PRESENT;
    ret_val = rrm_update_general_epc_info(p_cell_context,
            p_rrc_rrm_cell_reconfig_req); 
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from rrm_update_general_epc_info");
    }
    /*BUG_866_CHANGES_START*/
    /* Code Deleetd */
    /*BUG_866_CHANGES_END*/

    /*qos config params NA for reconfig*/ 
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_operator_info_mac_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info for mac config.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_operator_info_mac_config(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    /* BUG_371 FIX START */ 
    U8        index = RRM_ZERO;
    /* BUG_371 FIX END */ 

    RRM_UT_TRACE_ENTER();
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    /* plz update ue_inactive_time_config QUE : ASK*/
    /* update downlink power control*/
    update_reconf_downlink_power_control_common(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    /* SPS related changes start */
    if (p_reconfig_req_from_mif->operator_info.bitmask & RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.sps_crnti_range.start_sps_crnti = 
            p_reconfig_req_from_mif->operator_info.sps_crnti_range_info.start_sps_crnti_range;

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.sps_crnti_range.end_sps_crnti = 
            p_reconfig_req_from_mif->operator_info.sps_crnti_range_info.end_sps_crnti_range;    

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_SPS_CRNTI_RANGE_PRESENT;
    }
    /* SPS related changes end */
    /* BUG_371 FIX START */ 
    if (p_reconfig_req_from_mif->operator_info.bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT )
    {
        /* BUG_371 FIX START */ 
        /*  p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.n_gap = 
            p_reconfig_req_from_mif->operator_info.rrm_mac_config.n_gap;
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_N_GAP_PRESENT;

            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.ul_sync_loss_timer = 
            p_reconfig_req_from_mif->operator_info.rrm_mac_config.ul_sync_loss_timer ;
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_UL_SYNC_LOSS_TIMER_PRESENT;

            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.pucch_cqi_sinr_value = 
            p_reconfig_req_from_mif->operator_info.rrm_mac_config.pucch_cqi_sinr_value; 
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_PUCCH_CQI_SINR_THRESHOLD_PRESENT;*/

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.dci_format_for_si_msgs = 
            p_reconfig_req_from_mif->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg ;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_DCI_FORMAT_FOR_SI_MESSAGES_PRESENT;

        if (p_reconfig_req_from_mif->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == 
                RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A)
        {
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_RBS_PER_TBS_DCI_1A_PRESENT;
            for(index = RRM_ZERO; index < RBS_FOR_DCI_1A_SIZE; index++)
            {
                p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.num_rbs_per_tbs_dci_1a[index] = 
                     /* + SPR 17665 + */
                    p_reconfig_req_from_mif->operator_info.rrm_mac_config.num_rbs_per_tbs_dci_1a[index];
                     /* - SPR 17665 - */
            }
        }
        else if (p_reconfig_req_from_mif->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == 
                RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C)
        {
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask |= RRC_RRM_RECONFIG_RBS_PER_TBS_DCI_1C_PRESENT;
            for(index = RRM_ZERO; index < RBS_FOR_DCI_1C_SIZE; index++)
            {
                p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.num_rbs_per_tbs_dci_1c[index] =

                    /* + SPR 17665 + */
                    p_reconfig_req_from_mif->operator_info.rrm_mac_config.num_rbs_per_tbs_dci_1c[index];

                /* - SPR 17665 - */
            }
        }

    }
    /* BUG_371 FIX END */ 

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_operator_info_sib_1_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info for sib1 info.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_operator_info_sib_1_info(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    /* this function update the sib_1_info's cell_selection_info
       and ims_imergency_support */
    update_reconf_non_critical_extension( p_cell_context,
            p_rrc_rrm_cell_reconfig_req);

    /* this function update the scheduling info*/ 
    update_reconf_scheduling_info_list( p_cell_context,
            p_rrc_rrm_cell_reconfig_req);

    /* BUG_371 FIX START */
    /* BUG_371 FIX END */

    /*update si_window_length*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_window_length =
        p_reconfig_req_from_mif->operator_info.sib_1_info.si_window_length;

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_operator_sib_2_ul_cyclic_prefix_length
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator sib2 uplink cyclic prefix
 length.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

    rrm_return_et
rrm_update_operator_sib_2_ul_cyclic_prefix_length(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t    *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    switch(p_reconfig_req_from_mif->operator_info.sib_2_info.
            radio_res_config_common_sib.ul_cyclic_prefix_length)
    {
        case RRM_OAM_UL_CYC_PREFIX_LEN_1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.ul_cyc_prefix_len =
                RRM_RRC_UL_CYC_PREFIX_LEN_1;
            break;

        case RRM_OAM_UL_CYC_PREFIX_LEN_2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.ul_cyc_prefix_len =
                RRM_RRC_UL_CYC_PREFIX_LEN_2;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.ul_cyc_prefix_len =
                p_reconfig_req_from_mif->operator_info.sib_2_info.
                radio_res_config_common_sib.ul_cyclic_prefix_length;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of ul_cyclic_prefix_length :=%d",
                    p_reconfig_req_from_mif->operator_info.sib_2_info.
                    radio_res_config_common_sib.ul_cyclic_prefix_length);
            ret_val = RRM_FAILURE;
            break;
    }

    return ret_val;

}

/*SPR_15289_changes_Start*/
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_opeartor_info_sib_2_ac_barring_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info sib2 ac_barring_for_csfb_r10
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
rrm_update_opeartor_info_sib_2_ac_barring_info(rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t  *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et                   ret_val = RRM_FAILURE;

    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    if (p_reconfig_req_from_mif->operator_info.sib_2_info.presence_bitmask & RRMCM_RMIF_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG)
    {
        ret_val = RRM_SUCCESS;
        /* SPR 19753 Fix Start */
        /* Code Deleted */
        /* SPR 19753 Fix End */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |= SIB2_AC_BARRING_FOR_CSFB_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_factor =
            p_reconfig_req_from_mif->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_factor;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_time=
            p_reconfig_req_from_mif->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_time;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_for_special_ac =
            p_reconfig_req_from_mif->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_for_special_ac;
    }
    /* SPR fix 23041 start */
    else
    {
        ret_val = RRM_SUCCESS;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |= SIB2_AC_BARRING_FOR_CSFB_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_factor =
            p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_factor;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_time=
            p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_time;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_for_special_ac =
            p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10.ac_barring_for_special_ac;
    }
    /* SPR fix 23041 stop */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR_15289_changes_End*/

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_opeartor_info_sib_2_radio_res_confi_common 
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info sib2 radio res confi common
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

    rrm_return_et
rrm_update_opeartor_info_sib_2_radio_res_confi_common(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t    *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_access_barring_info_t      *p_access_barring_info = RRM_PNULL;/* info coming from mif */

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;
    /* spr-21287 start */
    if(p_reconfig_req_from_mif->operator_info.sib_2_info.radio_res_config_common_sib.bitmask &
             RRMCM_RMIF_BARRING_INFO_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
            SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
        p_access_barring_info =    &(p_reconfig_req_from_mif->operator_info.sib_2_info.
                radio_res_config_common_sib.access_barring_info);

        if(p_cell_context->cell_state != CELL_STATE_ALREADY_BLOCKED)
        {
            if( p_access_barring_info->bitmask & RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT )
            {
                if(p_access_barring_info->ssac_barring_r9.bitmask &
                        RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT)
                {
                    /*func update  access barring info's ssac barring mmtel voice info*/
                    update_reconf_ssac_barring_for_mmtel_voice_r9(p_cell_context,
                            p_rrc_rrm_cell_reconfig_req);

                    /* SPR-21287 START */
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
                        |= SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG;
                    /* SPR-21287 END */
                }

                if(p_access_barring_info->ssac_barring_r9.bitmask &
                        RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT)
                {
                    /*func update  access barring info's ssac barring mmtel video info*/
                    update_reconf_ssac_barring_for_mmtel_video_r9( p_cell_context,
                            p_rrc_rrm_cell_reconfig_req);

                    /* SPR-21287 START */
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
                        |= SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG;
                    /* SPR-21287 END */
                }
            }
            if(p_access_barring_info->bitmask &
                    RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT)
            {
                /*update the mo signalling*/
                update_reconf_ac_barring_for_mo_signalling(p_cell_context,
                        p_rrc_rrm_cell_reconfig_req);

                /* SPR-21287 START */
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
                    |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask
                    |= AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;
                /* SPR-21287 END */
            }

            if(p_access_barring_info->bitmask &
                    RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
            {
                /*update the mo data :*/
                update_reconf_ac_barring_for_mo_data(p_cell_context,
                        p_rrc_rrm_cell_reconfig_req);

                /* SPR-21287 START */
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
                    |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask
                    |= AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;
                /* SPR-21287 END */
            }
        }
        /* if cell state is CELL_STATE_ALREADY_BLOCKED and reconfig req is received from OAM where access */
        /* barring related parameters have been modified, then don't send these parameters as Cell is barred */
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask &= ~SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask &= ~SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask &= ~AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask &= ~AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;
        }

    }
    /* SPR fix 23041 start */
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
            SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
        /*func update  access barring info's ssac barring mmtel voice info*/
        update_reconf_ssac_barring_for_mmtel_voice_r9(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        /* SPR-21287 START */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
            |= SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG;
        /* SPR-21287 END */
        /*func update  access barring info's ssac barring mmtel video info*/
        update_reconf_ssac_barring_for_mmtel_video_r9( p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        /* SPR-21287 START */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
            |= SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG;
        /* SPR-21287 END */
        /*update the mo signalling*/
        update_reconf_ac_barring_for_mo_signalling(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        /* SPR-21287 START */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
            |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask
            |= AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;
        /* SPR-21287 END */
        /*update the mo data :*/
        update_reconf_ac_barring_for_mo_data(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        /* SPR-21287 START */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask
            |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask
            |= AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;
    }
    /* SPR fix 23041 stop */
    /* spr-21287 stop */
    /* update bcch and pcch*/
    update_reconf_bcch_config(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    update_reconf_pcch_config(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    /*update ul cyclic prefic length */
    rrm_update_operator_sib_2_ul_cyclic_prefix_length(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);


    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* BUG_371 FIX START */ 
rrm_return_et
rrm_update_operator_sib_2_ul_power_ctrl_info
( 
 rrm_cell_context_t           *p_cell_context,
 rrc_rrm_cell_reconfig_req_t  *p_rrc_rrm_cell_reconfig_req
 )
{
    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;
    uplink_power_control_common_t          *p_ul_power_ctrl_rrc = RRM_PNULL; /* info goes to rrc*/
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    p_ul_power_ctrl_rrc = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.uplink_power_control_common);
    RRM_ASSERT(RRM_PNULL != p_ul_power_ctrl_rrc);


    switch(p_reconfig_req_from_mif->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1)
    {
        case RRMC_DELTAF_NEG_TWO:
            p_ul_power_ctrl_rrc->delta_f_list_pucch.delta_f_pucch_format_one = 
                RRM_RRC_DELTAF_NEG_TWO;
            break;

        case RRMC_DELTAF_ZERO:
            p_ul_power_ctrl_rrc->delta_f_list_pucch.delta_f_pucch_format_one = 
                RRM_RRC_DELTAF_ZERO;
            break;

        case RRMC_DELTAF_POS_TWO:
            p_ul_power_ctrl_rrc->delta_f_list_pucch.delta_f_pucch_format_one = 
                RRM_RRC_DELTAF_POS_TWO;
            break;

        default:
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_1:%d",
                    p_reconfig_req_from_mif->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1);
            ret_val  = RRM_FAILURE;
    }
    /*mapping for delta f pucch format 1b*/
    ret_val = update_delta_f_pucch_format_1b_info(p_reconfig_req_from_mif->operator_info.
            rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b,
            p_ul_power_ctrl_rrc
            );

    /*mapping for delta f pucch format 2*/
    ret_val = update_delta_f_pucch_format_2_info(p_reconfig_req_from_mif->operator_info.
            rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2,
            p_ul_power_ctrl_rrc
            );

    /*mapping for delta f pucch format 2a*/
    ret_val = update_delta_f_pucch_format_2a_info(p_reconfig_req_from_mif->operator_info.
            rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a,
            p_ul_power_ctrl_rrc
            );

    /*mapping for delta f pucch format 2b*/ 
    ret_val = update_delta_f_pucch_format_2b_info(p_reconfig_req_from_mif->operator_info.
            rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b,
            p_ul_power_ctrl_rrc
            );

    p_ul_power_ctrl_rrc->delta_preamble_msg_three = 
        p_reconfig_req_from_mif->operator_info.rrm_operator_ul_pwr_ctrl.delta_preamble_msg_3; 

    /* BUG_371 FIX END */ 
    /* CA_Stage3_PUCCH_Format_Enh: Start */
    if (p_reconfig_req_from_mif->operator_info.rrm_operator_ul_pwr_ctrl.bitmask & RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT)
    {
        if( map_delta_f_pucch_format_3_r10_info(p_reconfig_req_from_mif->operator_info.
                    rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_3_r10,
                    &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                        radio_resource_config_common_sib.uplink_power_control_common_v1020))
                == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to Map delta_f_pucch_format_3_r10");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        if( map_delta_f_pucch_format_1b_cs_r10_info(p_reconfig_req_from_mif->operator_info.
                    rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b_cs_r10,
                    &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                        radio_resource_config_common_sib.uplink_power_control_common_v1020))
                == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to Map delta_f_pucch_format_3_r10");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.radio_resource_config_common_sib.presence_bitmask |=
            RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020;
    }
    /* CA_Stage3_PUCCH_Format_Enh: End */


    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_371 FIX END */ 

/****************************************************************************
 *   FUNCTION NAME  : rrm_update_opeartor_info_sib_2
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info sib2
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_operator_info_sib_2_info( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /*update the rrm_freq_info_t*/
    if(p_reconfig_req_from_mif->operator_info.sib_2_info.
            rrm_freq_info.bitmask & RRMCM_RMIF_UL_CARRIER_FREQ_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.presence_bitmask |= FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.ul_carrier_freq = p_reconfig_req_from_mif->operator_info.
            sib_2_info.rrm_freq_info.ul_carrier_freq;
    }

    /*update the additional spectrum emission*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.freq_info.add_spectrum_emission =
        p_reconfig_req_from_mif->operator_info.sib_2_info.rrm_freq_info.additional_spectrum_emission;

    /*update the timer alignment*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.time_align_timer =
        p_reconfig_req_from_mif->operator_info.sib_2_info.time_alignment_timer;


    /*update sib_2 radio res common config*/
    rrm_update_opeartor_info_sib_2_radio_res_confi_common(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    /*SPR_15289_changes_Start*/
    if(rrm_update_opeartor_info_sib_2_ac_barring_info(p_cell_context,p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"In sib_2 ac_barring_info is present");
    }
    else
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"In sib_2 ac_barring_info is not present");
    /*SPR_15289_changes_End*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/* SPR fix 23041 start */
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_opeartor_info_sib_2
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info sib2
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_update_operator_info_sib_2_info_2( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req_from_mif = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /*update the rrm_freq_info_t*/
    if(p_reconfig_req_from_mif->operator_info.sib_2_info.
            rrm_freq_info.bitmask & RRMCM_RMIF_UL_CARRIER_FREQ_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.presence_bitmask |= FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.ul_carrier_freq = p_reconfig_req_from_mif->operator_info.
            sib_2_info.rrm_freq_info.ul_carrier_freq;
    }
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.presence_bitmask |= FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.ul_carrier_freq = p_cell_context->operator_info.
            sib_2_info.rrm_freq_info.ul_carrier_freq;
    }

    /*update the additional spectrum emission*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.freq_info.add_spectrum_emission =
        p_cell_context->operator_info.sib_2_info.rrm_freq_info.additional_spectrum_emission;

    /*update the timer alignment*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.time_align_timer =
        p_cell_context->operator_info.sib_2_info.time_alignment_timer;


    /*update sib_2 radio res common config*/
    rrm_update_opeartor_info_sib_2_radio_res_confi_common(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    /*SPR_15289_changes_Start*/
    if(rrm_update_opeartor_info_sib_2_ac_barring_info(p_cell_context,p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"In sib_2 ac_barring_info is present");
    }
    else
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"In sib_2 ac_barring_info is not present");
    /*SPR_15289_changes_End*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* SPR fix 23041 stop */
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_operator_sib_3_cell_reselection_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info sib3 for cell
 reselection.
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_operator_sib_3_cell_reselection_info(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    if(p_reconfig_req_from_mif->operator_info.sib_3_info.
            intra_freq_reselection_info.bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.presence_bitmask |= INTRA_FREQ_CELL_RESELECT_MEAS_BW_PRESENCE_FLAG;

        /*update the measurement bandwidth*/
        switch(p_reconfig_req_from_mif->operator_info.sib_3_info.
                intra_freq_reselection_info.measurement_bandwidth)
        {
            case RRM_OAM_BW_MEAS_N_6:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_6;
                break;

            case RRM_OAM_BW_MEAS_N_15:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_15;
                break;

            case RRM_OAM_BW_MEAS_N_25:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_25;
                break;

            case RRM_OAM_BW_MEAS_N_50:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_50;
                break;

            case RRM_OAM_BW_MEAS_N_75:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_75;
                break;

            case RRM_OAM_BW_MEAS_N_100:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_100;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = 
                    p_reconfig_req_from_mif->operator_info.sib_3_info.
                    intra_freq_reselection_info.measurement_bandwidth;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "invalid value for measurement_bandwidth: %d",
                        p_reconfig_req_from_mif->operator_info.sib_3_info.
                        intra_freq_reselection_info.measurement_bandwidth);
                ret_val = RRM_FAILURE;
        }

    }
    /* update operators presense antenna port*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.presence_antenna_port_1 = 
        p_reconfig_req_from_mif->operator_info.sib_3_info.intra_freq_reselection_info.presence_antenna_port1;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_reconf_operator_sib_3_info 
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates reconfig operator sib3 info
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_reconf_operator_sib_3_info(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et                   ret_val = RRM_SUCCESS;

    const operator_info_t          *p_operator_info = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->operator_info);

    RRM_UT_TRACE_ENTER();

    if( p_operator_info->sib_3_info.bitmask & RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT)
    {
        update_reconf_sib3_intra_search_v920(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            presence_bitmask |= SIB_3_INTRA_SEARCH_V920_PRESENCE_FLAG;

    }
    if(p_operator_info->sib_3_info.bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT)
    {
        update_reconf_sib3_non_intra_search_v920(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            presence_bitmask |= SIB_3_NON_INTRA_SEARCH_V920_PRESENCE_FLAG;

    }


    if(p_operator_info->sib_3_info.bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.q_qual_min_r9 =
            p_operator_info->sib_3_info.q_qual_min_r9;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            presence_bitmask |= SIB_3_Q_QUAL_MIN_R9_PRESENCE_FLAG;
    }

    if(p_operator_info->sib_3_info.bitmask & RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            thresh_serving_low_q_r9 = p_operator_info->sib_3_info.thresh_serving_lowq_r9;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            presence_bitmask |= SIB_3_THRESH_SERVING_LOW_Q_R9_PRESENCE_FLAG;
    }

    /*func update sib3 cell reselection info */
    rrm_update_operator_sib_3_cell_reselection_info(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_operator_info_for_reconfig
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates operator info for reconfig
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_operator_info_for_reconfig(rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    const operator_info_t          *p_operator_info = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->
            operator_info);
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_operator_info);

    /*BUG_11611_CHANGES_START*/
    if (p_operator_info->bitmask & RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT)
    {
        sib_presence_bitmask |= RRM_NBROADCAST_CELL_PARAM_PRESENT_FLAG ;

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
            cell_parameters.bitmask |= RRC_RRM_RECONFIG_PHY_CELL_PARAMS_RB_SIZE;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
            cell_parameters.rb_size = 
            p_operator_info->cell_params.rb_size;

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
            cell_parameters.bitmask |= RRC_RRM_RECONFIG_PHY_CELL_PARAMS_DL_CYCLIC_PREFIX;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
            cell_parameters.dl_cyclic_prefix =   
            p_operator_info->cell_params.dl_cyclic_prefix; 
    }

    if (p_operator_info->bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT)
    {
    }

    if (p_operator_info->bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT)
    {
        /*update mac config*/
        rrm_update_operator_info_mac_config(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        /*SPR_19066_START*/
        /* Code deleted */
        /*SPR_19066_END*/
    }

    if(p_operator_info->bitmask & RRMCM_RMIF_PHICH_CONFIG_PRESENT)
    {
        sib_presence_bitmask |= RRM_MIB_INFO_PRESENT;
        /*update phich config*/
        ret_val = update_reconf_phich_config(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    /*BUG_11611_CHANGES_END*/

    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
    {

        sib_presence_bitmask |= RRM_SIB_1_PRESENT;
        /* this fucntion update teh sib_1_info of operator*/
        rrm_update_operator_info_sib_1_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }

    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT ;    
        /* update sib2*/
        rrm_update_operator_info_sib_2_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
#if 0
    /* Check Again */
    /* SPR fix 23041 start */
    else
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT ;    
        /* update sib2*/
        rrm_update_operator_info_sib_2_info_2(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    /* SPR fix 23041 stop */
#endif

    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_3_INFO_PRESENT)
    {
        sib_presence_bitmask |= RRM_SIB_3_PRESENT;
        /*update sib 3 info*/
        rrm_update_reconf_operator_sib_3_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    if(p_operator_info->bitmask & RRMCM_RMIF_SIB_4_INFO_PRESENT)
    {
        sib_presence_bitmask |= RRM_SIB_4_PRESENT ;
        /* this func update the sib_4_info*/
        update_reconf_csg_phy_cell_id_range(p_cell_context,
                p_rrc_rrm_cell_reconfig_req); 
    }
    /* BUG_371 FIX START */ 
    if(p_operator_info->bitmask & RRM_RRM_OPERATOR_UL_PWR_CTRL)
    {
        sib_presence_bitmask |= RRM_SIB_2_PRESENT ;    
        /* update sib2*/
        rrm_update_operator_sib_2_ul_power_ctrl_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    /* BUG_371 FIX END*/ 
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_access_mgmt_params_reconfig
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates access mgmt params for reconfig
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_access_mgmt_params_reconfig( rrm_cell_context_t    *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req)
{


    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et                    ret_val = RRM_SUCCESS;
    U8                               csg_octets = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)p_cell_context->p_new_reconfig_data;

    /* set the bitmask for SIB1*/
    sib_presence_bitmask |= RRM_SIB_1_PRESENT;
    /* SPR 14128 Fix Start */ 
    /*update the access mgmt params : hnb name,hnb_name_size*/ 
    update_reconf_sib_type_9_Info(p_cell_context,
            p_rrc_rrm_cell_reconfig_req);
    if(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.presence_bitmask & SIB_9_HNB_ID_PRESENCE_FLAG)
    {
        sib_presence_bitmask |= RRM_SIB_9_PRESENT;
    }
    /* SPR 14128 Fix END */

    /* Fix for CSR 58972 start*/
    /*SPR 16517 Fix Start*/
    if((p_reconfig_req_from_mif->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN) ||
            (p_reconfig_req_from_mif->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
        /* Fix for CSR 58972 end*/
    {
    /*SPR 16517 Fix Stop*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.csg_indication = RRC_FALSE;
    }
    else if(p_reconfig_req_from_mif->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_CLOSE)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.csg_indication = RRC_TRUE;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.presence_bitmask  |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG ;

        for(csg_octets = RRM_ZERO; csg_octets < NUM_CSG_OCTETS; csg_octets++)
        {
            /*update teh csg id */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.csg_identity[csg_octets] =
                p_reconfig_req_from_mif->access_mgmt_params.csg_id[csg_octets];
        } 
    }     
    /*SPR 16517 Fix Start*/
    else if((p_reconfig_req_from_mif->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_HYBRID))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.csg_indication = RRC_FALSE;
        if(p_reconfig_req_from_mif->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.presence_bitmask  |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG;
            for(csg_octets = RRM_ZERO; csg_octets < NUM_CSG_OCTETS; csg_octets++)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.csg_identity[csg_octets] =
                    p_reconfig_req_from_mif->access_mgmt_params.csg_id[csg_octets];
            } 
        }     
    }     
    /*SPR 16517 Fix Stop*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_cell_reconfig_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates cell reconfig params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_cell_reconfig_params( rrm_cell_context_t    
        *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req )
{
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)
        p_cell_context->p_new_reconfig_data;

    if( p_reconfig_req_from_mif->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT)
    {
        /*ran info */
        ret_val = rrm_update_and_update_ran_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    if( p_reconfig_req_from_mif->bitmask & RRMCM_RMIF_EPC_INFO_PRESENT)
    {
        /* epc info  */
        ret_val = rrm_update_reconfig_epc_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    if( p_reconfig_req_from_mif->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT)
    {
        /* operator info */
        ret_val = rrm_update_operator_info_for_reconfig(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    if( p_reconfig_req_from_mif->bitmask & RRMCM_RMIF_RRM_ACCESS_MGMT_PARAMS_PRESENT)
    {
        /* access mgmt params*/
        ret_val = rrm_update_access_mgmt_params_reconfig(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }
    if( p_reconfig_req_from_mif->bitmask & RRMCM_RMIF_RECONFIG_PHY_CELL_PARAMS_PRESENT)
    {
        /*gur30485 : */
    }



    RRM_UT_TRACE_EXIT();

    return ret_val; 
}

/*Cell update start*/
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_cell_update_proc_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates cell proc params
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et
rrm_update_cell_update_proc_params(rrm_cell_context_t    
        *p_cell_context,
        rrc_rrm_cell_reconfig_req_t 
        *p_rrc_rrm_cell_reconfig_req )
{
    rrmcm_rmif_cell_update_req_t    *p_update_req_from_mif = RRM_PNULL;
    U8                              valid_plmn = RRM_ZERO;
    U8                              plmn_count = RRM_ZERO;
    U8                              mcc_digits = RRM_ZERO;
    U8                              mnc_digits = RRM_ZERO;
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_update_req_from_mif = (rrmcm_rmif_cell_update_req_t *)
        p_cell_context->p_new_update_data;

    if(p_update_req_from_mif->bitmask &
            RRMCM_RMIF_PCI_VALUE_PRESENT )
    {
        /* bitmask set for SIBS set and unset utilization*/
        sib_presence_bitmask |= RRM_NON_BROADCAST_INFO_PRESENCE_FLAG;
        sib_presence_bitmask |= RRM_NBROADCAST_CELL_PARAM_PRESENT_FLAG;

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.phys_cell_id =
            p_update_req_from_mif->pci_value;

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |=
            RRC_RRM_RECONFIG_PHY_CELL_ID;
    }

    if(p_update_req_from_mif->bitmask &
            RRMCM_RMIF_UPDATED_PLMN_INFO)
    {
        sib_presence_bitmask |= RRM_SIB_1_PRESENT;
        valid_plmn = p_update_req_from_mif->updated_plmn_info.no_of_valid_plmns;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.plmn_Id_info_list.count = valid_plmn;

        for(plmn_count=RRM_ZERO;plmn_count < valid_plmn; plmn_count++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.mnc.count =
                p_update_req_from_mif->updated_plmn_info.plmn_list[plmn_count].num_mnc_digit;

            for (mnc_digits = RRM_ZERO;( (mnc_digits < p_update_req_from_mif->updated_plmn_info.\
                            plmn_list[plmn_count].num_mnc_digit) && (mnc_digits < MAX_MNC_DIGITS));mnc_digits++)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.
                    plmn_identity_info[plmn_count].plmn_identity.mnc.mnc[mnc_digits] =
                    p_update_req_from_mif->updated_plmn_info.plmn_list[plmn_count].mnc[mnc_digits];
            }
            /*Coverity_fix_start_54973*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.
                presence_bitmask = RRM_ZERO;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.
                presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

            for(mcc_digits = RRM_ZERO; mcc_digits < MAX_MCC_DIGITS; mcc_digits++)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.
                    plmn_identity_info[plmn_count].plmn_identity.mcc[mcc_digits] =
                    p_update_req_from_mif->updated_plmn_info.plmn_list[plmn_count].mcc[mcc_digits];
            }
            /*Coverity_fix_end_54973*/ 
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Cell update end*/
/*DYNAMIC ICIC START*/
rrm_return_et
rrm_update_cell_reconfig_params_for_icic( rrm_cell_context_t    
        *p_cell_context,
        rrc_rrm_cell_reconfig_req_t
        *p_rrc_rrm_cell_reconfig_req )
{
    rrm_cellm_cell_reconfig_params_for_icic_t *p_reconfig_params_for_icic = RRM_PNULL;
    rrm_return_et                    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_reconfig_params_for_icic = (rrm_cellm_cell_reconfig_params_for_icic_t*)
        p_cell_context->p_new_update_data;

    sib_presence_bitmask |= RRM_NON_BROADCAST_INFO_PRESENCE_FLAG;
    sib_presence_bitmask |= RRM_SIB_2_PRESENT;

    /* update reference_signal_power*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pdsch_config_common.ref_signal_power = 
        p_reconfig_params_for_icic->refrence_signal_power;

    RRM_UT_TRACE_EXIT();
    return ret_val; 
}

/*DYNAMIC ICIC END*/
/* MLB Ph2 SSAC Start */
/****************************************************************************
 *   FUNCTION NAME : rrm_cell_fill_ssac_reconfig_params
 *   INPUT       : p_ssac_in,p_ssac_out
 *   OUTPUT      : 
 *   DESCRIPTION :
 *          This function fills the ssac reconfig params.
 *
 *   RETURNS     : none
 *****************************************************************************/

rrm_void_t
rrm_cell_fill_ssac_reconfig_params 
(
 rrm_cellm_ac_barring_ld_info_t  *p_ssac_in,
 access_class_barring_Info_t     *p_ssac_out
 )
{
    RRM_ASSERT(RRM_PNULL != p_ssac_in);
    RRM_ASSERT(RRM_PNULL != p_ssac_out);
    RRM_UT_TRACE_ENTER();
    p_ssac_out->ac_barring_factor           = (U8)p_ssac_in->ac_barring_factor;
    p_ssac_out->ac_barring_time             = (U8)p_ssac_in->ac_barring_time;
    p_ssac_out->ac_barring_for_special_ac   = (U8)p_ssac_in->ac_barring_spec_ac; 
    RRM_UT_TRACE_EXIT();
    return;
}
/****************************************************************************
 *   FUNCTION NAME  : rrm_update_cell_reconfig_params_for_mlb
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION : This function updates cell reconfig params for mlb
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_void_t
rrm_update_cell_reconfig_params_for_mlb
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    /* SPR 16012 Fix Start */
    /* Code Removed */
    /* SPR 16012 Fix Stop */

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_context);
    RRM_ASSERT(RRM_PNULL != p_rrc_rrm_cell_reconfig_req);
    /* SPR 16012 Fix Start */
    /* Code Removed */
    /* SPR 16012 Fix Stop */

    sib_presence_bitmask = RRM_NULL;
    sib_presence_bitmask |= RRM_SIB_2_PRESENT;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    /* SPR 16012 Fix Start */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;
 
    if ( p_cell_context->cell_block_unblock_ongoing == CELL_BLOCK_ONGOING )
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
	    cell_access_related_info.cell_barred = RRM_RRC_CELL_BARRED;   
    }
    else
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
	    cell_access_related_info.cell_barred = RRM_RRC_CELL_NOT_BARRED;   
    }
    /* SPR 16012 Fix Stop */
    RRM_UT_TRACE_EXIT();
    return;
}
/* MLB Ph2 SSAC End */
/****************************************************************************
 *   FUNCTION NAME       :  build_send_rrc_reconfig_req 
 *                         //map_rrc_rrm_cell_reconfig_req
 *   INPUT       :p_cell_context,cell_procedure
 *   OUTPUT      :p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC 
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_send_rrc_reconfig_req
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
 rrm_cell_procedure_et    cell_procedure
 )
{
    U8	eaid_count = RRM_ZERO;
    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/
    /* CSR 00051178 CHANGES START */
    rrm_si_segment_data_t si_segment_data[RRM_MAX_SI_SEGMENTS] = {{RRM_ZERO}};
    U8                    si_window_length_configured = RRM_ZERO;
    /* CSR 00051178 CHANGES END */

    rrm_return_et    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->cell_index = p_cell_context->cell_index;

    p_rrc_rrm_cell_reconfig_req->presence_bitmask = RRM_ZERO;
    map_reconf_broadcast_info(p_cell_context, p_rrc_rrm_cell_reconfig_req, cell_procedure);


    map_reconf_non_broadcast_info(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    if(p_cell_context->epc_info.epc_params.bitmask & 
            RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT)
    {
        if (p_cell_context->epc_info.epc_params.general_epc_params.bitmask &
                RRMCM_RMIF_EA_ID_PRESENT)
        {
            /*BUG_866_CHANGES_START*/
            /*Code Deleted */
            /*BUG_866_CHANGES_END*/
            for(eaid_count=RRM_ZERO; eaid_count<MAX_EAID; eaid_count++)
            {
                p_rrc_rrm_cell_reconfig_req->emergency_area_id[eaid_count] = 
                    p_cell_context->epc_info.epc_params.general_epc_params.eaid[eaid_count];
            }
        }

       /*SPR_19066_START*/
       /* Code deleted */
       /*SPR_19066_END*/
    }
    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT)
    {
        map_reconf_downlink_power_control_common(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        /*BUG_866_CHANGES_START*/
        /*Code Deleted */
        /*BUG_866_CHANGES_END*/

        /*SPR_19066_START*/
        /* Code deleted */
        /*SPR_19066_END*/
        p_rrc_rrm_cell_reconfig_req->contention_free_rach_timer = 
            (U16)p_cell_context->operator_info.contention_free_rach_timer;
        //p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_CONTENTION_FREE_RACH_TIMER_PRESENT;
    }

    /*BUG_866_CHANGES_START*/
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "BitmaskMain:%d, Broadcast[%d], NonBroadcast[%d]",
            p_rrc_rrm_cell_reconfig_req->presence_bitmask,
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask,
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask);
    /*BUG_866_CAHNGES_END*/
    /* Re initialising the bitmask with ZERO as only those SIBs will be searched which are impacted 
     * by change in parameter from OAM.
     */ 
    p_rrc_rrm_cell_reconfig_req->presence_bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask = RRM_ZERO;
    /* SPS related changes start */
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params.bitmask = RRM_ZERO;
    /* SPS related changes end */
    /* SPR-21287 START */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.access_barring_info.presence_bitmask = RRM_ZERO;
    /* SPR-21287 END */

    switch (cell_procedure)
    {
        case CELL_RECONFIG_PROC:
            {
                rrm_update_cell_reconfig_params(p_cell_context, p_rrc_rrm_cell_reconfig_req);
                break;
            }
        case CELL_UPDATE_PROC:
            { 
                rrm_update_cell_update_proc_params(p_cell_context, p_rrc_rrm_cell_reconfig_req);
                break;
            }
        case CELL_MLB_RECONFIG_PROC:
            {
                rrm_update_cell_reconfig_params_for_mlb (p_cell_context, p_rrc_rrm_cell_reconfig_req);
                break;
            }
            /*DYNAMIC ICIC START*/
        case CELL_RECONFIG_FOR_ICIC_PROC:
            { 
                rrm_update_cell_reconfig_params_for_icic(p_cell_context, p_rrc_rrm_cell_reconfig_req);
            }
            break;
            /*DYNAMIC ICIC END*/
        default:
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Invalid cell procedure recvd");
                break;
            }
    }

    /* CSR 00051178 CHANGES START */
    /* BUG_371 FIX START */ 
    if(sib_presence_bitmask != 0x00)
    {
        /* BUG_822 FIX START */ 
        rrm_update_bitmask_for_cell_reconfig(p_cell_context, p_rrc_rrm_cell_reconfig_req, cell_procedure);
        /* BUG_822 FIX END */ 
        si_window_length_configured = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_window_length;

        update_si_segment_data_vd_scheduling_info_configured(&(p_rrc_rrm_cell_reconfig_req->broadcast_info.
                    sib_type_1_Info.scheduling_info_list),
                si_window_length_configured, si_segment_data);
        /*cov fix start 48132*/
        /*cov fix start 64261*/
        rrm_get_collision_free_si_scheduling_list(p_cell_context, si_segment_data, 
                ((rrm_si_window_length_et)p_rrc_rrm_cell_reconfig_req->broadcast_info.
                 sib_type_1_Info.si_window_length));
        /*cov fix end 64261*/
        /*cov fix end 48132*/

        rrm_update_si_segment_data_in_cell_context(p_cell_context->si_segment_data_sib_scheduling,
                si_segment_data);

        /* Update new SI Window in Cell Context and Cell Setup Request API towards L3*/
        if(si_window_length_configured != p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_window_length)
        {
            /* Coverity_ID : 54444 */
            p_cell_context->operator_info.sib_1_info.si_window_length = rrm_map_si_window_length(
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_window_length);
        }

        /*SPR 17777 +-*/
        update_collision_free_sib_scheduling_list_in_sib1_for_cell_reconfig(
                p_cell_context->si_segment_data_sib_scheduling,
                &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list));
        /* CSR 00051178 CHANGES END */

        /*DYNAMIC SIB SCHEDULING END*/
        /*Sending reconfig request to RRC
         */
        /*SPR_18944_FIX_START*/
        if (p_rrc_rrm_cell_reconfig_req->presence_bitmask != RRM_ZERO)
        {
        /*SPR_18944_FIX_END*/
        ret_val = rrm_il_send_rrc_rrm_cell_reconfig_req (p_rrc_rrm_cell_reconfig_req,	
                RRM_CM_MODULE_ID,
                RRC_MODULE_ID,
                p_cell_context->ongoing_trans_id,p_cell_context->cell_index);
        if(ret_val == RRM_SUCCESS)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Send Cell Reconfig Req To RRC For Cell index:%d",
                    p_cell_context->cell_index);
        }
        /*SPR_18944_FIX_START*/
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Cell Reconfig Req not sent For Cell index:%d",
                    p_cell_context->cell_index);
            ret_val = RRM_FAILURE;
        }
        /*SPR_18944_FIX_END*/
    }
    else
    {
        ret_val = RRM_PARTIAL_SUCCESS; 

        RRM_TRACE( g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "No need to send CELL_RECONFIG req  to Lower Layer");
    }
    /* BUG_371 FIX END */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Release 1.2 changes for cell reconfig interface for SON */
/****************************************************************************
 *   FUNCTION NAME       :  build_send_rrc_reconfig_req_for_son 
 *   INPUT       : p_cell_context
 *   OUTPUT      :
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC 
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_send_rrc_reconfig_req_for_son
(
 rrm_cell_context_t *p_cell_context
 )
{
    extern const S8 * CELL_FSM_STATE[];
    rrc_rrm_cell_reconfig_req_t  *p_rrc_rrm_cell_reconfig_req = RRM_PNULL;
    rrm_return_et    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
    if ( p_rrc_rrm_cell_reconfig_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_rrc_rrm_cell_reconfig_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_rrc_rrm_cell_reconfig_req, RRM_ZERO, sizeof(rrc_rrm_cell_reconfig_req_t));

    p_rrc_rrm_cell_reconfig_req->cell_index = p_cell_context->cell_index;

    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */
    p_rrc_rrm_cell_reconfig_req->presence_bitmask = RRM_ZERO;
    ret_val = map_reconf_broadcast_info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    if (RRM_SUCCESS == ret_val)
    {
        /*SPR 17777 +-*/
        update_collision_free_sib_scheduling_list_in_sib1_for_cell_reconfig(
                p_cell_context->si_segment_data_sib_scheduling,
                &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list));
        /*DYNAMIC SIB SCHEDULING END*/
        /* Sending reconfig request to RRC */
            /*SPR_18944_FIX_START*/
            if (p_rrc_rrm_cell_reconfig_req->presence_bitmask != RRM_ZERO)
            {
            /*SPR_18944_FIX_END*/
        ret_val = rrm_il_send_rrc_rrm_cell_reconfig_req (p_rrc_rrm_cell_reconfig_req,	
                RRM_CM_MODULE_ID,
                RRC_MODULE_ID,
                p_cell_context->ongoing_trans_id,p_cell_context->cell_index);

        if(RRM_SUCCESS == ret_val)
        {
            p_cell_context->cell_state = CELL_STATE_W_FOR_CELL_RECONFIG_RESP;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell ReConfig Send To RRC for Cell Index:%d Cell State is:%s[%d]",
                    p_cell_context->cell_index, CELL_FSM_STATE[p_cell_context->cell_state],
                    p_cell_context->cell_state);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to send Cell Reconfig to RRC for Cell index:%d",
                    p_cell_context->cell_index);
        }
            /*SPR_18944_FIX_START*/
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                        "Cell Reconfig Req not sent For Cell index:%d",
                        p_cell_context->cell_index);
                ret_val = RRM_FAILURE;
            }
            /*SPR_18944_FIX_END*/
        }
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

    RRM_MEM_FREE(p_rrc_rrm_cell_reconfig_req);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Release 1.2 changes for cell reconfig interface for SON */

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_downlink_power_control_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig common downlink power control params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_downlink_power_control_common
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    //commenting below written lines..as per new rrc code
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pcfichPowerOffset = 
        p_cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.phichPowerOffset = 
        p_cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pdcchPowerOffset = 
        p_cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pdcchPowerOffset;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pbchTransmissionPower = 
        p_cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pbchTransmissionPower;
    p_rrc_rrm_cell_reconfig_req->downlink_power_control_common.pchTransmissionpower = 
        p_cell_context->operator_info.rrm_mac_config.mac_downlink_power_control_common.pchTransmissionpower;

    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_DOWNLINK_POWER_CONTROL_COMMON_PRESENT;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}


/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_broadcast_info
 *   INPUT       : p_cell_context
 *   OUTPUT      ; p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig broadcast info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_broadcast_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
 rrm_cell_procedure_et cell_procedure
 )
{
    rrm_return_et                    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask = RRM_ZERO;

    /* MIB Info is filled with Cell Config params */
    ret_val = map_reconf_mib_info(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_reconf_mib_info");
    }

    /* Mapping SIB Type 1 Info */
    if (RRM_FAILURE == map_reconf_sib_type_1_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_reconf_sib_type_1_Info");
    }

    /* Mapping SIB Type 2 Info */
    if (RRM_FAILURE == map_reconf_sib_type_2_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_reconf_sib_type_2_Info");
    }

    /* SPR 15328 start */
    U8 utra_fdd_count = p_cell_context->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.
        irat_eutran_to_utran_fdd_list.
        num_irat_eutran_to_utran_fdd_carriers;

    U8 utra_tdd_count = p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.
        irat_eutran_to_utran_tdd_list.
        num_irat_eutran_to_utran_tdd_carriers;

    U8 geran_carr_count = p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_irat_geran_params.
        irat_eutran_to_geran_list.
        num_irat_eutran_to_geran_carriers;

    /* SPR 15328 end */

    /* Mapping SIB Type 3 Info */
    map_reconf_sib_type_3_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    map_reconf_sib_type_4_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_MIF_IDLE_MODE_MOBILITY_INTER_FREQ_PARAMS))
    {
        map_reconf_sib_type_5_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        /*SPR_18944_FIX_START*/
        if (p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.count > RRM_ZERO)
        {
        /*SPR_18944_FIX_END*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_5_INFO_PRESENCE_FLAG;
        /*SPR_18944_FIX_START*/
        }
        /*SPR_18944_FIX_END*/
    }

    /* SPR 15328 start */
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT) &&
             ((utra_fdd_count > RRM_ZERO) || (utra_tdd_count > RRM_ZERO)))
        /* SPR 15328 end */
    {    
        /* TDD Support SON Start */
        map_reconf_sib_type_6_Info(&p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_irat_utra_params, p_rrc_rrm_cell_reconfig_req);
        /* TDD Support SON End */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_6_INFO_PRESENCE_FLAG;
    }

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT) &&
            /* SPR 15328 start */
            geran_carr_count > RRM_ZERO)
        /* SPR 15328 end */
    {    
        map_reconf_sib_type_7_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_7_INFO_PRESENCE_FLAG;
    }

    /* Fix for reconfig 27/06/2013 */
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask &
             RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT))
    {
        /* Start 7514 NRT Fix - SIB 8 */
        map_reconf_sib_type_8_Info(p_cell_context, &p_cell_context->ran_info.ncl_params, p_rrc_rrm_cell_reconfig_req);
        /* End 7514 NRT Fix - SIB 8 */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |=
            CELL_RECONFIG_REQ_API_SIB_8_INFO_PRESENCE_FLAG;
    }


    map_reconf_sib_type_9_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    /* CSR 00051178 CHANGES START */
    /* This check will check if updated sceduling info is present in Cell Reconfig or not.
       In case this is present then new Sceduling info is used else
       Reconfig shall be using the previously stored sceduling info.
       This information has already been copied in function map_reconf_sib_type_1_Info()*/
    if ((RRM_PNULL != p_cell_context->p_new_reconfig_data) &&
            (p_cell_context->p_new_reconfig_data->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT) &&
            (p_cell_context->p_new_reconfig_data->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT) 
       ) 
    {
        rrm_memcpy_rrm_scheduling_info_list((rrm_scheduling_info_list_t *)
                &(p_rrc_rrm_cell_reconfig_req->broadcast_info.
                    sib_type_1_Info.scheduling_info_list),
                &(p_cell_context->p_new_reconfig_data->operator_info.
                    sib_1_info.scheduling_info_list));
        /* CSR 00051178 CHANGES END */
    }
    /*DYNAMIC ICIC START*/
    else if( CELL_MLB_RECONFIG_PROC == cell_procedure)/*For MLB Cell reconfig To config SIB2 SSAC Info */
    {
        rrm_memcpy_rrm_scheduling_info_list((rrm_scheduling_info_list_t *)&(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list),
                &(p_cell_context->operator_info.sib_1_info.scheduling_info_list));
    }
    else
    {
        /*Do Nothing*/
    }
    /*DYNAMIC ICIC END*/
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* Release 1.2 changes for cell reconfig interface for SON */

/* SPR 5676 Fix Start*/
/****************************************************************************
 *   FUNCTION NAME       :  map_sib_type_1_for_son 
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps SIB1 cell reconfig params for SON from cell ctx
 *
 *   RETURNS     : None
 *****************************************************************************/
rrm_void_t
map_sib_type_1_for_son
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    map_sib_type_1(p_cell_context, &p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info);
    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |=
        CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;

    /* SPR 17728 Fix Start */
    /* Code Deleted */
    /* SPR 17728 Fix End */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_value_tag =
        p_cell_context->system_info_tag_counter;

    /* Copy Scheduling Info from Cell context */
    /*BUG 680 FIX START*/
    rrm_map_scheduling_info_list(&(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list),&(p_cell_context->operator_info.sib_1_info.scheduling_info_list));
    /*BUG 680 FIX END */

    if(RRM_TRUE == update_cell_setup_scheduling_info_sib1_for_son(p_cell_context,
                p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask ,
                &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info)))
    {
        /* Save scheduling info to be committed on receipt of Reconfig resp */
        p_cell_context->p_new_reconfig_data = rrm_mem_get(sizeof(rrmcm_rmif_cell_reconfig_req_t));
        if ( p_cell_context->p_new_reconfig_data == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Memory allocation to p_cell_context->p_new_reconfig_data failed" );
            RRM_UT_TRACE_EXIT();
            return ;
        }

        RRM_MEMSET(p_cell_context->p_new_reconfig_data, RRM_ZERO, sizeof(rrmcm_rmif_cell_reconfig_req_t));

        RRM_MEMCPY(&(p_cell_context->p_new_reconfig_data->operator_info.sib_1_info.scheduling_info_list),
                &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list) ,
                sizeof(rrm_scheduling_info_list_t));
    }
    RRM_UT_TRACE_EXIT();
}

/* SPR 5676 Fix End*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_broadcast_info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_broadcast_info_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask = RRM_ZERO;

    if (p_cell_context->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_SERV_CELL_PARAMS_PRESENT)
    {
        /* Mapping SIB Type 3 Info */
        ret_val = map_reconf_sib_type_3_Info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Failure returned from map_reconf_sib_type_3_Info");
        }
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask = CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        }
    }

    if(p_cell_context->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_INTER_FREQ_PARAMS_PRESENT)
    {
        if(RRM_ZERO < p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list)
        {
            /* Mapping SIB Type 5 Info */
            ret_val = map_reconf_sib_type_5_Info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Failure returned from map_reconf_sib_type_5_Info");
            }
            else
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_5_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->presence_bitmask = CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
            }
        }
        else
        {
            ret_val = RRM_SUCCESS;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "SIB 5 to be deleted!!");
        }
    }

    if (p_cell_context->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_UTRA_FREQ_PARAMS_PRESENT)
    {    
        /* Mapping SIB Type 6 Info */
        /* TDD Support SON Start */
        ret_val = map_reconf_sib_type_6_Info(&p_cell_context->p_meas_config_sib_info_for_reconfig->
                utran_params.idle_mode_mobility_irat_utra_params, p_rrc_rrm_cell_reconfig_req);
        /* TDD Support SON End */
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Failure returned from map_reconf_sib_type_6_Info");
        }
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_6_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask = CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        }
    }
    if (p_cell_context->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_GERAN_FREQ_PARAMS_PRESENT)
    {    
        /* Mapping SIB Type 7 Info */
        ret_val = map_reconf_sib_type_7_Info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Failure returned from map_reconf_sib_type_7_Info");
        }
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_7_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask = CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        }
    }


    if (p_cell_context->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_CDMA_FREQ_PARAMS_PRESENT)
    {    
        /* Mapping SIB Type 8 Info */
        ret_val = map_reconf_sib_type_8_Info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Failure returned from map_reconf_sib_type_8_Info");
        }
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_8_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask = CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        }
    }


    /* SPR 5676 Fix Start*/
    /* If any SIB is updated, SIB SI value tag needs to be updated in SIB1 */
    if((p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask) || (ret_val == RRM_SUCCESS))
    {
        map_sib_type_1_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        p_rrc_rrm_cell_reconfig_req->presence_bitmask = CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    }
    /* SPR 5676 Fix End*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Release 1.2 changes for cell reconfig interface for SON */

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_mib_info
 *   INPUT       : p_cell_context
 *   PUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig mib info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_mib_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* Setting CELL_RECONFIG_REQ_API_MIB_INFO_PRESENCE_FLAG bitmask */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_MIB_INFO_PRESENCE_FLAG;
    /* Setting CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG bitmask */
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

    switch(p_cell_context->ran_info.rf_params.
            rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_6;
            break;

        case RRM_OAM_BW_N_15:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_15;
            break;

        case RRM_OAM_BW_N_25:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_25;
            break;

        case RRM_OAM_BW_N_50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_50;
            break;

        case RRM_OAM_BW_N_75:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_75;
            break;

        case RRM_OAM_BW_N_100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width
                = RRM_RRC_BW_N_100;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.dl_band_width = 
                p_cell_context->ran_info.rf_params.
                rf_configurations.dl_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for dl_band_width: %d",
                    p_cell_context->ran_info.rf_params.
                    rf_configurations.dl_bandwidth);
            ret_val = RRM_FAILURE;
    }
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
    ret_val = map_reconf_phich_config(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_END*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_phich_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig phich config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_phich_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->operator_info.phich_config.phich_resource)
    {
        case RRM_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_ONE_SIXTH;
            break;

        case RRM_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_HALF;
            break;

        case RRM_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_ONE;
            break;

        case RRM_THREE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = RRC_RRM_PHICH_R_TWO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_resource = p_cell_context->operator_info.phich_config.phich_resource;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of phich_resource: %d",
                    p_cell_context->operator_info.phich_config.phich_resource);
            ret_val = RRM_FAILURE;
    }

    switch(p_cell_context->operator_info.phich_config.phich_duration)
    {
        case RRM_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_duration = RRM_RRC_PHICH_D_NORMAL;
            break;

        case RRM_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_duration = RRM_RRC_PHICH_D_EXTENDED;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.mib_info.phich_config.
                phich_duration = p_cell_context->operator_info.phich_config.phich_duration;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of phich_duration: %d",
                    p_cell_context->operator_info.phich_config.phich_duration);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_non_critical_extension
 *   INPUT       : p_cell_context
 *   OUTPUT      ; p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function Maps the cell reconfig non critical extensions params coming from MIF to RRC
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_non_critical_extension
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        non_critical_extension.presence_bitmask = RRM_ZERO;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        non_critical_extension.presence_bitmask |= SIB_TYPE_1_V890_IES_NON_CROTICAL_EXTENSION_PRESENT_FLAG;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.presence_bitmask |= 
        SIB_TYPE_1_NON_CRITICAL_EXTENSION_PRESENT_FLAG;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
        non_critical_extension.presence_bitmask = RRM_ZERO;

    if (p_cell_context->operator_info.sib_1_info.ims_emergency_support_r9)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.presence_bitmask |= 
            SIB_TYPE_1_V920_IES_IMS_EMERGENCY_SUPPORT_PRESENT_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.ims_emergency_support = RRM_RRC_TRUE;
    }

    if(p_cell_context->operator_info.sib_1_info.bitmask & RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.cell_selection_info_v920.q_qual_min_r9 = 
            p_cell_context->operator_info.sib_1_info.cell_selection_info.q_qual_min_r9;

        if(p_cell_context->operator_info.sib_1_info.cell_selection_info.bitmask & RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.non_critical_extension.
                cell_selection_info_v920.presence_bitmask = RRM_ZERO;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
                non_critical_extension.cell_selection_info_v920.q_qual_min_offset_r9 = 
                p_cell_context->operator_info.sib_1_info.cell_selection_info.q_qual_min_offset_r9_present;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.non_critical_extension.
                cell_selection_info_v920.presence_bitmask |= CELL_SELECTION_INFO_Q_QUAL_MIN_OFFSET_R9_PRESENT_FLAG;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.non_critical_extension.
            non_critical_extension.presence_bitmask |= SIB_TYPE_1_V920_IES_CELL_SELECTION_INFO_V920_PRESENT_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_1_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 1 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_1_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et               ret_val_final = RRM_SUCCESS;


    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.presence_bitmask = RRM_ZERO;    

    /* 
       Mandatory map_reconf_cell_access_related_info for SIB Type 1 from Cell Config
     */
    if (RRM_FAILURE == map_reconf_cell_access_related_info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_reconf_cell_access_related_info");
        ret_val_final = RRM_FAILURE;
    }

    /* 
       Mandatory cell_selection_info for SIB Type 1 from Cell Config
     */
    if (RRM_FAILURE == map_reconf_cell_selection_info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_reconf_cell_selection_info");
        ret_val_final = RRM_FAILURE;
    }

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS))
    {
        if(p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
                bitmask & RRMCM_RMIF_P_MAX_SIB1_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                presence_bitmask |= SIB_TYPE_1_P_MAX_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.p_max = 
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.p_max_sib_1;
        }
    }
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT) && 
            (p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.freq_band_indicator = 
            p_cell_context->ran_info.rf_params.rf_configurations.frequency_band_indicator;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.si_window_length = 
            p_cell_context->operator_info.sib_1_info.si_window_length;

        /*DYNAMIC SIB SCHEDULING START*/
        map_reconf_scheduling_info_list(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        /*DYNAMIC SIB SCHEDULING end*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;
    }
    /* SPR 5676 Fix Start*/
    /* SPR 22949 fix start */
    /* code removed */
    /* SPR 22949 fix stop */
    /* SPR 5676 Fix End*/

#ifdef TDD_MODE_FLAG
    if (RRM_FAILURE == map_reconf_tdd_config(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "Failure returned from map_reconf_tdd_config");
        ret_val_final = RRM_FAILURE;
    }
#endif

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
    {
        map_reconf_non_critical_extension(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    }

    RRM_UT_TRACE_EXIT();

    return ret_val_final;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_cell_access_related_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig access related params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_cell_access_related_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    U8 tac_size = RRM_ZERO;
    U8 cell_id = RRM_ZERO;
    U8 csg_octets = RRM_ZERO;
    rrm_return_et               ret_val_final = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        cell_access_related_info.presence_bitmask  = RRM_ZERO;

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
            "Bitmask values: B1 %d, B2 %d, B3 %d", 
            p_cell_context->ran_info.bitmask, p_cell_context->operator_info.bitmask, 
            p_cell_context->epc_info.epc_params.bitmask);

    if( (p_cell_context->ran_info.bitmask & RRMCM_RMIF_COMMON_EUTRAN_PARAMS_PRESENT) && 
            (p_cell_context->ran_info.bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT) && 
            (p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)) 
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        for(tac_size=0; tac_size < MAX_TAC_SIZE; tac_size++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.tac[tac_size] = 
                p_cell_context->epc_info.epc_params.general_epc_params.tac[tac_size];
        }

        for(cell_id=0; cell_id<MAX_CELL_IDENTITY_OCTETS; cell_id++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.cell_Id[cell_id] = 
                p_cell_context->ran_info.common_eutran_params.cell_identity[cell_id];
        }
        switch(p_cell_context->ran_info.cell_restriction_params.
                cell_and_access_barring.cell_barred)
        {
            case RRM_OAM_CELL_BARRED:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.cell_barred = RRM_RRC_CELL_BARRED;
                break;

            case RRM_OAM_CELL_NOT_BARRED:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.cell_barred = RRM_RRC_CELL_NOT_BARRED;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.cell_barred = RRM_RRC_CELL_NOT_BARRED;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Invalid value for cell_barred: %d",
                        p_cell_context->ran_info.cell_restriction_params.
                        cell_and_access_barring.cell_barred);
                ret_val_final = RRM_FAILURE;
        }
        /* BUG_371 FIX START */
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.intra_freq_reselection = 
            p_cell_context->ran_info.cell_restriction_params.cell_and_access_barring.cell_access_info.intra_frequency_reselection;
        /* BUG_371 FIX END */
        /* Fix for CSR 58972 start*/
        /*SPR 16517 Fix Start*/
        if((p_cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN) || 
                (p_cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
            /* Fix for CSR 58972 end*/
        /*SPR 16517 Fix Stop*/
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.csg_indication = RRC_FALSE;
        }
        else if(p_cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_CLOSE)
        {
            if (p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.csg_indication = RRC_TRUE;

                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.presence_bitmask  |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG ;

                for(csg_octets = RRM_ZERO; csg_octets < NUM_CSG_OCTETS; csg_octets++)
                {
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                        cell_access_related_info.csg_identity[csg_octets] =
                        p_cell_context->access_mgmt_params.csg_id[csg_octets];
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "CSG Id Bitmask Absent.. [%d]",
                        p_cell_context->access_mgmt_params.bitmask);
                ret_val_final = RRM_FAILURE;
            }
        }
        /*SPR 16517 Fix Start*/
        else if(p_cell_context->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_HYBRID)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.csg_indication = RRC_FALSE;
            if (p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.presence_bitmask  |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG ;

                for(csg_octets = RRM_ZERO; csg_octets < NUM_CSG_OCTETS; csg_octets++)
                {
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                        cell_access_related_info.csg_identity[csg_octets] =
                        p_cell_context->access_mgmt_params.csg_id[csg_octets];
                }
            }
        }    
        /*SPR 16517 Fix Stop*/
        if(RRM_FAILURE == map_reconf_plmn_id_info_list(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_plmn_id_info_list");
        }

    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Many Params which are mandatorily required are not present RAN[%d], EPC[%d], OPERATOR[%d]",
                p_cell_context->ran_info.bitmask,
                p_cell_context->epc_info.epc_params.bitmask,
                p_cell_context->operator_info.bitmask);
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.csg_indication = RRC_FALSE;
        ret_val_final = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val_final;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_plmn_id_info_list
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig plmn id info list coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_plmn_id_info_list
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    U8                               plmn_count = RRM_ZERO;
    U8                               valid_plmn = RRM_ZERO;
    U8                               mcc_digits = RRM_ZERO;
    U8                               mnc_digits = RRM_ZERO;
    rrm_return_et                    ret_val = RRM_SUCCESS;


    RRM_UT_TRACE_ENTER();


    /* SPR 10730 Fix Start */
    valid_plmn = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        cell_access_related_info.plmn_Id_info_list.count = 
        p_cell_context->epc_info.
        epc_params.general_epc_params.num_valid_plmn;

    for(plmn_count=0; plmn_count < valid_plmn; plmn_count++)
    {
        if(p_cell_context->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].bitmask &
                RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT )
        {
            switch(p_cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].cell_reserved_for_operator_use)
            {
                case RRM_OAM_RESERVED_FOR_OPERATOR:
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                        cell_access_related_info.plmn_Id_info_list.
                        plmn_identity_info[plmn_count].
                        cell_res_for_operator_use = RRM_RRC_CELL_RESERVED;
                    break;
                case RRM_OAM_NOT_RESERVED_FOR_OPERATOR:
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                        cell_access_related_info.plmn_Id_info_list.
                        plmn_identity_info[plmn_count].
                        cell_res_for_operator_use = RRM_RRC_CELL_NOT_RESERVED;
                    break;
                default :
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                            "Incorrect value received for"\
                            "cell_reserved_for_operator_use = %u",
                            p_cell_context->epc_info.epc_params.general_epc_params.
                            plmn_list[plmn_count].cell_reserved_for_operator_use);
                    break;
            }
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Reconfig:- cell_reserved_for_operator_use = %u",
                    p_cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].cell_reserved_for_operator_use);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Cell Reconfig: Bitmask for cell_reserved_for_operator_use Not Present[%d]",
                    p_cell_context->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].bitmask);
            ret_val = RRM_FAILURE;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.plmn_Id_info_list.
            plmn_identity_info[plmn_count].plmn_identity.
            presence_bitmask = RRM_ZERO;

        if(p_cell_context->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].plmn_id.bitmask & RRMCM_MCC_PRESENCE_BITMASK)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.
                presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
            for(mcc_digits = RRM_ZERO; mcc_digits < MAX_MCC_DIGITS; mcc_digits++)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.
                    plmn_identity_info[plmn_count].plmn_identity.mcc[mcc_digits] = 
                    p_cell_context->epc_info.epc_params.general_epc_params.
                    plmn_list[plmn_count].plmn_id.mcc[mcc_digits];
            }
        }


        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_access_related_info.plmn_Id_info_list.
            plmn_identity_info[plmn_count].plmn_identity.mnc.count = 
            p_cell_context->epc_info.epc_params.
            general_epc_params.plmn_list[plmn_count].plmn_id.num_mnc_digit;
        for (mnc_digits = RRM_ZERO; mnc_digits < 
                p_cell_context->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].plmn_id.num_mnc_digit; mnc_digits++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_access_related_info.plmn_Id_info_list.
                plmn_identity_info[plmn_count].plmn_identity.mnc.mnc[mnc_digits] = 
                p_cell_context->epc_info.epc_params.
                general_epc_params.plmn_list[plmn_count].plmn_id.mnc[mnc_digits];
        }
    }
    /* SPR 10730 Fix End */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_scheduling_info_list
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig scheduling info list coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_scheduling_info_list
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    U8 scheduling_list = RRM_ZERO;
    U8 sib_mapping = RRM_ZERO;
    U8 valid_scheduling_list = RRM_ZERO;
    U8 valid_sib_mapping_info = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    valid_scheduling_list = 
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        scheduling_info_list.count = 
        p_cell_context->operator_info.sib_1_info.scheduling_info_list.count;

    for(scheduling_list = RRM_ZERO; scheduling_list < valid_scheduling_list; scheduling_list++)
    {
        valid_sib_mapping_info = 
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
            scheduling_info[scheduling_list].sib_mapping_info.count = 
            p_cell_context->operator_info.sib_1_info.scheduling_info_list.
            scheduling_info[scheduling_list].sib_mapping_info.count;
        for(sib_mapping=RRM_ZERO; sib_mapping<valid_sib_mapping_info; sib_mapping++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
                scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping] = 
                p_cell_context->operator_info.sib_1_info.scheduling_info_list.
                scheduling_info[scheduling_list].sib_mapping_info.sib_type[sib_mapping];
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list.
            scheduling_info[scheduling_list].si_periodicity = 
            p_cell_context->operator_info.sib_1_info.scheduling_info_list.
            scheduling_info[scheduling_list].si_periodicity;
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_cell_selection_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig cell selection info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_cell_selection_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et             ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
        cell_selection_Info.presence_bitmask = RRM_ZERO;

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
            cell_selection_Info.q_rx_lev_min = 
            p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_1;

        if(p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
                bitmask & RRMCM_RMIF_Q_RX_LEV_MIN_OFFSET_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_selection_Info.presence_bitmask |= 
                CELL_SELECT_INFO_Q_RX_LEV_MIN_OFFSET_PRESENCE_FLAG;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.
                cell_selection_Info.q_rx_lev_min_offset = 
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
                q_rx_lev_min_offset;
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Bitmask Absent.. RAN[%d], IDLE_MODE[%d]",
                p_cell_context->ran_info.bitmask,
                p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask);
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

#ifdef TDD_MODE_FLAG
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_tdd_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig tdd config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_tdd_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et            ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.presence_bitmask |= SIB_TYPE_1_TDD_CONFIG_PRESENT_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_1_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.tdd_config.sub_frame_assignment =
            p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure.sub_frame_assignment;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.tdd_config.special_sub_frame_pattern =
            p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure.special_sub_frame_patterns;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "TDD Bitmask Absent.. RAN[%d], PHYSICAL[%d]",
                p_cell_context->ran_info.bitmask,
                p_cell_context->ran_info.physical_layer_params.bitmask);
        ret_val = RRM_FAILURE;
    }


    RRM_UT_TRACE_EXIT();

    return ret_val;
}
#endif
/*klock_works_changes_start*/
U8
rrm_get_ac_barring_factor_lower_range
(
 rrm_access_class_barring_info_t *access_class_barring_info
 )
{
    RRM_UT_TRACE_ENTER();

    U8 barring_factor = RRM_ZERO;
    switch(access_class_barring_info->ac_barring_factor)
    {
        case RRM_MIF_AC_BARRING_FACTOR_P00:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P00;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P05:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P05;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P10:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P10;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P15:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P15;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P20:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P20;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P25:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P25;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P30:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P30;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P40:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P40;
            break;
        default:
            barring_factor = access_class_barring_info->ac_barring_factor;
            RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,
                    RRM_WARNING,"Incorrect value received for"
                    " ssac_barring_for_mmtel_voice_r9.ac_barring_factor= %u",
                    access_class_barring_info->ac_barring_factor);
            break;
    }

    RRM_UT_TRACE_EXIT();
    return barring_factor;
}


U8
rrm_get_ac_barring_factor_higher_range
(
 rrm_access_class_barring_info_t *access_class_barring_info
 )
{
    RRM_UT_TRACE_ENTER();

    U8 barring_factor = RRM_ZERO;
    switch(access_class_barring_info->ac_barring_factor)
    {
        case RRM_MIF_AC_BARRING_FACTOR_P50:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P50;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P60:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P60;
            break;


        case RRM_MIF_AC_BARRING_FACTOR_P70:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P70;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P75:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P75;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P80:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P80;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P85:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P85;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P90:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P90;
            break;

        case RRM_MIF_AC_BARRING_FACTOR_P95:
            barring_factor = RRM_RRC_AC_BARRING_FACTOR_P95;
            break;

        default:
            barring_factor = access_class_barring_info->ac_barring_factor;
            RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,
                    RRM_WARNING,"Incorrect value received for"
                    " ssac_barring_for_mmtel_voice_r9.ac_barring_factor= %u",
                    access_class_barring_info->ac_barring_factor);
            break;
    }

    RRM_UT_TRACE_EXIT();
    return barring_factor;
}

/*klock_works_changes_end*/

/****************************************************************************
 *   FUNCTION NAME       :  rrm_get_ac_barring_factor
 *   INPUT       : access_class_barring_info
 *   OUTPUT      :
 *   DESCRIPTION :
 r           This function gets the access barring factor
 *
 *   RETURNS     :
 *       barring_factor
 *****************************************************************************/

U8 
rrm_get_ac_barring_factor
(
 rrm_access_class_barring_info_t *access_class_barring_info
 )
{
    RRM_UT_TRACE_ENTER();

    U8 barring_factor = RRM_ZERO;

    /*klock_works_changes_start*/
    if(access_class_barring_info->ac_barring_factor<=RRM_MIF_AC_BARRING_FACTOR_P40)
    {
        barring_factor=rrm_get_ac_barring_factor_lower_range(access_class_barring_info);
    }
    else
    {
        barring_factor=rrm_get_ac_barring_factor_higher_range(access_class_barring_info);
    }    
    /*klock_works_changes_end*/
    RRM_UT_TRACE_EXIT();
    return barring_factor;
}

/****************************************************************************
 *   FUNCTION NAME       :  rrm_get_ac_barring_time
 *   INPUT       : access_class_barring_info
 *   OUTPUT      :
 *   DESCRIPTION :
 *           This function access barring time
 *
 *   RETURNS     :
 *       barring_time
 *****************************************************************************/

U8
rrm_get_ac_barring_time
(
 rrm_access_class_barring_info_t *access_class_barring_info) 
{

    RRM_UT_TRACE_ENTER();
    U8 barring_time = RRM_ZERO;

    switch(access_class_barring_info->ac_barring_time)
    {
        case RRM_MIF_AC_BARRING_TIME_S4:
            barring_time = RRM_RRC_AC_BARRING_TIME_S4;
            break;

        case RRM_MIF_AC_BARRING_TIME_S8:
            barring_time = RRM_RRC_AC_BARRING_TIME_S8;
            break;

        case RRM_MIF_AC_BARRING_TIME_S16:
            barring_time = RRM_RRC_AC_BARRING_TIME_S16;
            break;

        case RRM_MIF_AC_BARRING_TIME_S32:
            barring_time = RRM_RRC_AC_BARRING_TIME_S32;
            break;

        case RRM_MIF_AC_BARRING_TIME_S64:
            barring_time = RRM_RRC_AC_BARRING_TIME_S64;
            break;

        case RRM_MIF_AC_BARRING_TIME_S128:
            barring_time = RRM_RRC_AC_BARRING_TIME_S128;
            break;

        case RRM_MIF_AC_BARRING_TIME_S256:
            barring_time = RRM_RRC_AC_BARRING_TIME_S256;
            break;

        case RRM_MIF_AC_BARRING_TIME_S512:
            barring_time = RRM_RRC_AC_BARRING_TIME_S512;
            break;

        default:
            barring_time = access_class_barring_info->ac_barring_time;
            RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_WARNING,
                    "Incorrect value received for"
                    "ssac_barring_for_mmtel_voice_r9.ac_barring_time= %u",
                    access_class_barring_info->ac_barring_time);
            break;
    }

    RRM_UT_TRACE_EXIT();
    return barring_time;
}

/****************************************************************************
 *   FUNCTION NAME       :  rrm_get_ac_barring_for_special_ac 
 *   INPUT       : access_class_barring_info
 *   OUTPUT      : 
 *   DESCRIPTION :
 *           This function gets the access barring for special access
 *
 *   RETURNS     :
 *       barring_for_special_ac
 *****************************************************************************/

U8
rrm_get_ac_barring_for_special_ac
(
 rrm_access_class_barring_info_t *access_class_barring_info)
{

    RRM_UT_TRACE_ENTER();
    U8 barring_for_special_ac = RRM_ZERO;

    barring_for_special_ac = access_class_barring_info->ac_barring_for_special_ac;

    RRM_UT_TRACE_EXIT();
    return barring_for_special_ac;

}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ssac_barring_for_mmtel_voice_r9
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function Maps the cell reconfig ssac barring for mmtel voice r9
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_ssac_barring_for_mmtel_voice_r9
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_voice_r9.ac_barring_factor = 
        rrm_get_ac_barring_factor(&(p_cell_context->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.
                    ssac_barring_for_mmtel_voice_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_voice_r9.ac_barring_time = 
        rrm_get_ac_barring_time(&(p_cell_context->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.
                    ssac_barring_for_mmtel_voice_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac = 
        rrm_get_ac_barring_for_special_ac(&(p_cell_context->
                    operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                    ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ssac_barring_for_mmtel_video_r9
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *           This function Maps the cell reconfig ssac barring for mmtel video r9
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_ssac_barring_for_mmtel_video_r9
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_video_r9.ac_barring_factor = 
        rrm_get_ac_barring_factor(&(p_cell_context->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.
                    ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_video_r9.ac_barring_time = 
        rrm_get_ac_barring_time(&(p_cell_context->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.
                    ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac = 
        rrm_get_ac_barring_for_special_ac(&(p_cell_context->
                    operator_info.sib_2_info.radio_res_config_common_sib.
                    access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));

    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_2_Info_operator
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 2 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_sib_type_2_Info_operator(rrm_cell_context_t           *p_cell_context,
        rrc_rrm_cell_reconfig_req_t  *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et             ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if((p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT) &&
            (p_cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |=
            CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |=
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        /*LTE_RRM_KLOCWORK_WARN_4_JULY_12_START*/
        if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT) &&
                (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.bitmask & 
                 RRMCM_RMIF_BARRING_INFO_PRESENT))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "map_reconf_access_barring_info is receieved from OAM");
            if (RRM_FAILURE == map_reconf_access_barring_info(p_cell_context,p_rrc_rrm_cell_reconfig_req))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Failure returned from map_reconf_access_barring_info");
                ret_val = RRM_FAILURE;
            }

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |= 
                SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG; 
        }
        /* SPR fix 23041 start */
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "map_reconf_access_barring_info is not receieved from OAM");
            if (RRM_FAILURE == map_reconf_access_barring_info(p_cell_context,p_rrc_rrm_cell_reconfig_req))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Failure returned from map_reconf_access_barring_info");
                ret_val = RRM_FAILURE;
            }

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |= 
                SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG; 
        }
        /* SPR fix 23041 stop */
        if (RRM_FAILURE == map_reconf_radio_resource_config_common_sib(p_cell_context,p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_radio_resource_config_common_sib");
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Bitmask Absent.. RAN[%d], OPERATOR[%d]",
                p_cell_context->ran_info.bitmask,
                p_cell_context->operator_info.bitmask);
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*Klockwork_fix_end*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_2_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 2 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_2_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et             ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask = RRM_ZERO;

    /* Checking this condition to specifically fill access_barring_info_t and
       radio_resource_config_common_sib_t bitmask. By checking this condition 
       if Mandatory is present then optional can also be set.
     */

    /*Klockwork_fix_start*/
    map_reconf_sib_type_2_Info_operator(p_cell_context ,p_rrc_rrm_cell_reconfig_req);
    /*Klockwork_fix_end*/

    if(p_cell_context->ran_info.bitmask & RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT)
    {
        if (RRM_FAILURE == map_reconf_ue_timers_and_constants(p_cell_context,p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_ue_timers_and_constants");
            ret_val = RRM_FAILURE;
        }


        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    }
    if (RRM_FAILURE == map_reconf_freq_info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_freq_info");
        ret_val = RRM_FAILURE;
    }

    /*bug 9979 Fix - Delete*/

    if((p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT) &&
            (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.bitmask & 
             RRMCM_RMIF_BARRING_INFO_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            time_align_timer = 
            p_cell_context->operator_info.sib_2_info.time_alignment_timer;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        if(p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask & 
                RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                presence_bitmask |= SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG;

            map_reconf_ssac_barring_for_mmtel_voice_r9(p_cell_context, 
                    p_rrc_rrm_cell_reconfig_req);

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                presence_bitmask |= SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG;

            map_reconf_ssac_barring_for_mmtel_video_r9(p_cell_context, 
                    p_rrc_rrm_cell_reconfig_req);
        }
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_access_barring_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig access barring info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_access_barring_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.presence_bitmask = RRM_ZERO;

    if(p_cell_context->ran_info.bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT)
    {
        switch(p_cell_context->ran_info.cell_restriction_params.
                cell_and_access_barring.barring_for_emergency)
        {
            case RRM_FALSE:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    access_barring_info.acBarringForEmergency = RRC_FALSE;
                break;

            case RRM_TRUE:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    access_barring_info.acBarringForEmergency = RRC_TRUE;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    access_barring_info.acBarringForEmergency = RRC_FALSE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Inavlid value of barring_for_emergency: [%d]",
                        p_cell_context->ran_info.cell_restriction_params.
                        cell_and_access_barring.barring_for_emergency);
                ret_val = RRM_FAILURE;
        }
    }

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        if(p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.bitmask & 
                RRMCM_RMIF_BARRING_INFO_PRESENT)
        {
            if(p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                    bitmask & RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT)
            {
                map_reconf_ac_barring_for_mo_signalling(p_cell_context,
                        p_rrc_rrm_cell_reconfig_req);
                /*setting bitmask*/
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    access_barring_info.presence_bitmask |= 
                    AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                    CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                    CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                    SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
            }
            if(p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                    bitmask & RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
            {
                map_reconf_ac_barring_for_mo_data(p_cell_context, p_rrc_rrm_cell_reconfig_req);

                /*setting bitmask*/
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    access_barring_info.presence_bitmask |=
                    AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                    CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                    CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                    SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
            }

            /*SPR_17786_Fix_Start*/
            if(p_cell_context->operator_info.sib_2_info.presence_bitmask & RRMCM_RMIF_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG)
            {
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_factor =
                        rrm_get_ac_barring_factor(&(p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10));
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_time =
                        rrm_get_ac_barring_time(&(p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10));
                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_for_special_ac =
                        rrm_get_ac_barring_for_special_ac(&(p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10));

 
                /*Setting Bitmask*/
                p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                    CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                    CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                    SIB2_AC_BARRING_FOR_CSFB_PRESENCE_FLAG;
            }


            /*SPR_17786_Fix_End*/
        }
        /* SPR fix 23041 start */
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
            map_reconf_ac_barring_for_mo_signalling(p_cell_context,
                    p_rrc_rrm_cell_reconfig_req);
            /*setting bitmask*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                access_barring_info.presence_bitmask |= 
                AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
            map_reconf_ac_barring_for_mo_data(p_cell_context, p_rrc_rrm_cell_reconfig_req);

            /*setting bitmask*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                access_barring_info.presence_bitmask |=
                AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;
            /*SPR_17786_Fix_Start*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_factor =
                rrm_get_ac_barring_factor(&(p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10));
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_time =
                rrm_get_ac_barring_time(&(p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10));
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.ac_barring_for_csfb_r10.ac_barring_for_special_ac =
                rrm_get_ac_barring_for_special_ac(&(p_cell_context->operator_info.sib_2_info.ac_barring_for_csfb_r10));


            /*Setting Bitmask*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.presence_bitmask |=
                SIB2_AC_BARRING_FOR_CSFB_PRESENCE_FLAG;
        }
        /* SPR fix 23041 stop */
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ac_barring_for_mo_signalling
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig access barring for mo signalling
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_ac_barring_for_mo_signalling
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_signalling.
        ac_barring_factor = rrm_get_ac_barring_factor(&
                (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                 access_barring_info.ac_barring_for_mo_signalling));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_signalling.
        ac_barring_time = rrm_get_ac_barring_time(&
                (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                 access_barring_info.ac_barring_for_mo_signalling));

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_signalling.
        ac_barring_for_special_ac =rrm_get_ac_barring_for_special_ac(&
                (p_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.
                 access_barring_info.ac_barring_for_mo_signalling));

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ac_barring_for_mo_data
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig access barring for mo data
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_ac_barring_for_mo_data
(
 rrm_cell_context_t              *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t     *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_data.ac_barring_factor = 
        rrm_get_ac_barring_factor(&(p_cell_context->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_data.ac_barring_time = 
        rrm_get_ac_barring_time(&(p_cell_context->operator_info.
                    sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        access_barring_info.ac_barring_for_mo_data.ac_barring_for_special_ac =
        rrm_get_ac_barring_for_special_ac(&(p_cell_context->
                    operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_radio_resource_config_common_sib
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig radio resource config common sib params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_radio_resource_config_common_sib
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if (RRM_FAILURE == map_reconf_rach_config_common(p_cell_context, p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_rach_config_common");
        ret_val = RRM_FAILURE;
    }

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        if (RRM_FAILURE == map_reconf_bcch_config(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_bcch_config");
            ret_val = RRM_FAILURE;
        }

        if (RRM_FAILURE == map_reconf_pcch_config(p_cell_context, p_rrc_rrm_cell_reconfig_req))        
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_pcch_config");
            ret_val = RRM_FAILURE;
        }
    }

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT))
    {
        map_reconf_prach_config_sib(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    }

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        switch(p_cell_context->operator_info.sib_2_info.
                radio_res_config_common_sib.ul_cyclic_prefix_length)
        {
            case RRM_OAM_UL_CYC_PREFIX_LEN_1:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.ul_cyc_prefix_len =
                    RRM_RRC_UL_CYC_PREFIX_LEN_1;
                break;

            case RRM_OAM_UL_CYC_PREFIX_LEN_2:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.ul_cyc_prefix_len =
                    RRM_RRC_UL_CYC_PREFIX_LEN_2;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.ul_cyc_prefix_len = RRM_RRC_UL_CYC_PREFIX_LEN_1;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Invalid value of ul_cyclic_prefix_length:=%d",
                        p_cell_context->operator_info.sib_2_info.
                        radio_res_config_common_sib.ul_cyclic_prefix_length);
                ret_val = RRM_FAILURE;
                break;
        }
    }

    if(p_cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT)
    {
        map_reconf_pdsch_config_common(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    }
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT))
    {
        if (RRM_FAILURE == map_reconf_pusch_config_common(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_pusch_config_common");
            ret_val = RRM_FAILURE;
        }

    }
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT))
    {
        if (RRM_FAILURE == map_reconf_pucch_config_common(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_pucch_config_common");
            ret_val = RRM_FAILURE;
        }
    }
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)) 
    {
        if (RRM_FAILURE == map_reconf_sounding_rs_ul_config_common(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_sounding_rs_ul_config_common");
            ret_val = RRM_FAILURE;
        }

    }
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT))
    {
        if (RRM_FAILURE == map_reconf_uplink_power_control_common(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_uplink_power_control_common");
            ret_val = RRM_FAILURE;
        }
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_rach_config_common
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_rach_config_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(p_cell_context->ran_info.bitmask & RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT)
    {
        if (RRM_FAILURE == map_reconf_preamble_info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_preamble_info");
            ret_val = RRM_FAILURE;
        }

        if (RRM_FAILURE == map_reconf_power_ramping_params(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_power_ramping_params");
            ret_val = RRM_FAILURE;
        }
        if (RRM_FAILURE == map_reconf_ra_supervision_info(p_cell_context, p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_ra_supervision_info");
            ret_val = RRM_FAILURE;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.rach_config_common.max_harq_msg_3_tx = 
            p_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Bitmask Absent.. RAN[%d]",
                p_cell_context->ran_info.bitmask);
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_preamble_info_lower
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig preamble info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_preamble_info_lower(rrm_cell_context_t            *p_cell_context ,
        rrc_rrm_cell_reconfig_req_t   *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.number_of_ra_preambles)
    {
        case RRM_OAM_RA_PREAMBLE_COUNT_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N4;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N8;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N12;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N16;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N20;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N24;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N28:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N28;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N32:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N32;
            break;
        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count = RRM_OAM_RA_PREAMBLE_COUNT_N12;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for number_of_ra_preambles: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.number_of_ra_preambles);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_preamble_info_higher
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig preamble info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_preamble_info_higher(rrm_cell_context_t            *p_cell_context ,
        rrc_rrm_cell_reconfig_req_t   *p_rrc_rrm_cell_reconfig_req ) 
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.number_of_ra_preambles)
    {

        case RRM_OAM_RA_PREAMBLE_COUNT_N36:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N36;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N40:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N40;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N44:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N44;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N48:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N48;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N52:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N52;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N56:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N56;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N60;
            break;

        case RRM_OAM_RA_PREAMBLE_COUNT_N64:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count= RRM_RRC_RA_PREAMBLE_COUNT_N64;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                ra_preamble_count = RRM_OAM_RA_PREAMBLE_COUNT_N12;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for number_of_ra_preambles: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.number_of_ra_preambles);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_preamble_info
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig preamble info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_preamble_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();
    if(p_cell_context->ran_info.mac_layer_params.bitmask &
            RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.rach_config_common.preamble_info.presence_bitmask = RRM_ZERO;

        /*Klockwork_fix_start*/
        if ((p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.number_of_ra_preambles) <= RRM_OAM_RA_PREAMBLE_COUNT_N32) 
        {
            ret_val = map_reconf_preamble_info_lower(p_cell_context ,p_rrc_rrm_cell_reconfig_req);
        }
        else
        {
            ret_val = map_reconf_preamble_info_higher(p_cell_context ,p_rrc_rrm_cell_reconfig_req); 
        }
        /*Klockwork_fix_end*/


        if(RRM_FAILURE == map_reconf_preambles_group_a_config(p_cell_context,p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_preambles_group_a_config");
            ret_val = RRM_FAILURE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_preambles_group_b_msg_power_offset 
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig preambles group b msg power offset
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_preambles_group_b_msg_power_offset(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
            message_power_offset_group_b)
    {
        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB0;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB5;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB8;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB10;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB12;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB15:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB15;
            break;

        case RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB18:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset =
                RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB18;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config.group_b_msg_power_offset = RRM_RRC_GROUP_B_MSG_POWER_OFFSET_DB0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value of message_power_offset_group_b: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                    message_power_offset_group_b );
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_preambles_group_a_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig preambles group a config
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_preambles_group_a_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    preambles_group_a_config_t      *p_preamble_group_a =  RRM_PNULL;
    rrm_preamble_info_t             *p_rrm_cellm_preamble_info = RRM_PNULL;
    rrm_return_et    ret_val = RRM_SUCCESS;

    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    /*setting bitmask*/
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.rach_config_common.
        preamble_info.presence_bitmask = RRM_ZERO;

    p_rrm_cellm_preamble_info = &(p_cell_context->ran_info.
            mac_layer_params.mac_layer_param_rach.
            preamble_info);
    RRM_ASSERT(RRM_PNULL != p_rrm_cellm_preamble_info);
    if ((p_rrm_cellm_preamble_info->bitmask & RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT)
       )
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.rach_config_common.
            preamble_info.presence_bitmask |= PREAMBLE_INFO_GROUP_A_CONFIG_PRESENCE_FLAG;

        switch(p_cell_context->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a)
        {
            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N4;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N8;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size = RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N12;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N16;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N20;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N24;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N28;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N32;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N36;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N40;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N44;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N48;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N52;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N56;
                break;

            case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size =
                    RRM_RRC_RA_PREAMBLE_GROUP_A_SIZE_N60;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    radio_resource_config_common_sib.rach_config_common.preamble_info.
                    preambles_group_a_config.ra_preambles_group_a_size = RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Invalid value of size_of_ra_group_a: %d",
                        p_cell_context->ran_info.mac_layer_params.
                        mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                        size_of_ra_group_a);
                ret_val = RRM_FAILURE;
        }

        p_preamble_group_a = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.preamble_info.
                preambles_group_a_config);
        switch(p_cell_context->ran_info.mac_layer_params.
                mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.
                message_size_group_a)
        {
            case RRM_OAM_GROUP_A_MSG_SIZE_B56:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B56;
                break;
            case RRM_OAM_GROUP_A_MSG_SIZE_B144:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B144;
                break;
            case RRM_OAM_GROUP_A_MSG_SIZE_B208:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B208;
                break;
            case RRM_OAM_GROUP_A_MSG_SIZE_B256:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B256;
                break;
            default:
                p_preamble_group_a->group_a_msg_size = RRM_RRC_GROUP_A_MSG_SIZE_B56; 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for message_size_group_a = %u",
                        p_cell_context->ran_info.mac_layer_params.\
                        mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.\
                        message_size_group_a);
                ret_val = RRM_FAILURE;
                break;
        }

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        /* 
         ** COMP_WARN_1_FEB:compilation warning removal 
         ** passing p_cell_context instead of p_cell_context 
         */

        if (RRM_FAILURE == map_reconf_preambles_group_b_msg_power_offset(p_cell_context,
                    p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_preambles_group_b_msg_power_offset");
            ret_val = RRM_FAILURE;
        }
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_power_ramping_params
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig power ramping params
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_power_ramping_params
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.power_ramping_step)
    {
        case RRM_OAM_POWER_RAMP_STEP_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =
                RRM_RRC_POWER_RAMP_STEP_DB0;
            break;

        case RRM_OAM_POWER_RAMP_STEP_DB2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =
                RRM_RRC_POWER_RAMP_STEP_DB2;
            break;

        case RRM_OAM_POWER_RAMP_STEP_DB4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step =
                RRM_RRC_POWER_RAMP_STEP_DB4;
            break;

        case RRM_OAM_POWER_RAMP_STEP_DB6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step = 
                RRM_RRC_POWER_RAMP_STEP_DB6;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.power_ramping_step = RRM_RRC_POWER_RAMP_STEP_DB0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for power_ramping_step: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.power_ramping_step);
            ret_val = RRM_FAILURE;
    }

    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_initial_received_target_power)
    {
        case RRM_OAM_PREAMBLE_POWER_DBM_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow = 
                RRM_RRC_PREAMBLE_POWER_DBM_120;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_118:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_118;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_116:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_116;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_114:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_114;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_112:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_112;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_110:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_110;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_108:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_108;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_106:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_106;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_104:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_104;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_102:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_102;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_100;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_98:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_98;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_96:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_96;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_94:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_94;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_92:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_92;
            break;

        case RRM_OAM_PREAMBLE_POWER_DBM_90:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow =
                RRM_RRC_PREAMBLE_POWER_DBM_90;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                power_ramping_params.preamble_init_rec_target_pow = RRM_RRC_PREAMBLE_POWER_DBM_120;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for preamble_initial_received_target_power: %d", 
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_initial_received_target_power);
            ret_val = RRM_FAILURE;
    }	

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_mac_cont_resol_timer
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig mac cont resol timer
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_mac_cont_resol_timer(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();


    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.contention_resolution_timer)
    {
        case RRM_OAM_MAC_CONT_RES_TIMER_SF8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF8;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF16;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF24;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF32:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF32;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF40:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF40;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF48:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF48;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF56:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer = 
                RRM_RRC_MAC_CONT_RES_TIMER_SF56;
            break;

        case RRM_OAM_MAC_CONT_RES_TIMER_SF64:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer =
                RRM_RRC_MAC_CONT_RES_TIMER_SF64;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.mac_cont_resol_timer = RRM_RRC_MAC_CONT_RES_TIMER_SF8;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for contention_resolution_timer: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.contention_resolution_timer);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ra_resp_win_size
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params ra resp win size
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ra_resp_win_size(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();


    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.response_window_size)
    {
        case RRM_OAM_RA_RESP_WIN_SIZE_SF2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF2;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF3;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF4;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF5;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF6;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF7;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF8;
            break;

        case RRM_OAM_RA_RESP_WIN_SIZE_SF10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF10;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.ra_resp_win_size = RRM_RRC_RA_RESP_WIN_SIZE_SF2;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for response_window_size: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.response_window_size); 
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ra_supervision_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params ra supervision info
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ra_supervision_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mac_layer_params.
            mac_layer_param_rach.preamble_trans_max)
    {
        case RRM_OAM_PREAMBLE_TRANS_MAX_N3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N3;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N4;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N5;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N6;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = 
                RRM_RRC_PREAMBLE_TRANS_MAX_N7;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N8;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N10;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N20;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max =
                RRM_RRC_PREAMBLE_TRANS_MAX_N50;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = 
                RRM_RRC_PREAMBLE_TRANS_MAX_N100;
            break;

        case RRM_OAM_PREAMBLE_TRANS_MAX_N200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = 
                RRM_RRC_PREAMBLE_TRANS_MAX_N200;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.rach_config_common.
                ra_supervision_info.preamble_trans_max = RRM_RRC_PREAMBLE_TRANS_MAX_N3;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for preamble_trans_max: %d",
                    p_cell_context->ran_info.mac_layer_params.
                    mac_layer_param_rach.preamble_trans_max);
            ret_val = RRM_FAILURE;
    }

    /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
    if (RRM_FAILURE == map_reconf_ra_resp_win_size(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ra_resp_win_size");
        ret_val = RRM_FAILURE;
    }

    /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

    /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
    if (RRM_FAILURE == map_reconf_mac_cont_resol_timer(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_mac_cont_resol_timer");
        ret_val = RRM_FAILURE;
    }
    /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_bcch_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the cell reconfig bcch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_bcch_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_bcch_config.
            modification_period_coeff)
    {
        case RRM_OAM_MOD_PERIOD_COEFF_N2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                RRM_RRC_MOD_PERIOD_COEFF_N2;
            break;

        case RRM_OAM_MOD_PERIOD_COEFF_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                RRM_RRC_MOD_PERIOD_COEFF_N4;
            break;

        case RRM_OAM_MOD_PERIOD_COEFF_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff =
                RRM_RRC_MOD_PERIOD_COEFF_N8;
            break;

        case RRM_OAM_MOD_PERIOD_COEFF_N16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff = 
                RRM_RRC_MOD_PERIOD_COEFF_N16;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.bcch_config.mod_period_coeff = RRM_RRC_MOD_PERIOD_COEFF_N2;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for modification_period_coeff:%u",
                    p_cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*klock_works_changes_start*/
rrm_return_et
fill_pcch_config_nb_for_radio_rsrc_cmmn_sib
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_pcch_config.nB)
    {
        case RRM_OAM_NB_FOUR_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = RRM_RRC_NB_FOUR_T;
            break;

        case RRM_OAM_NB_TWO_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = 
                RRM_RRC_NB_TWO_T;
            break;

        case RRM_OAM_NB_ONE_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = 
                RRM_RRC_NB_ONE_T;
            break;

        case RRM_OAM_NB_HALF_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_HALF_T;
            break;

        case RRM_OAM_NB_QUARTER_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_QUARTER_T;
            break;

        case RRM_OAM_NB_ONE_EIGHTH_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_EIGHTH_T;
            break;

        case RRM_OAM_NB_ONE_SIXTEENTH_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = 
                RRM_RRC_NB_ONE_SIXTEENTH_T;
            break;

        case RRM_OAM_NB_ONE_THIRTY_SECOND_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_THIRTY_SECOND_T;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = RRM_RRC_NB_FOUR_T;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for nB: %d",
                    p_cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_pcch_config.nB);
            ret_val = RRM_FAILURE;
    }	
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*klock_works_changes_end*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_pcch_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig pcch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_pcch_config
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle)
    {
        case RRM_OAM_DEF_PAG_CYCLE_RF32:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF32;
            break;

        case RRM_OAM_DEF_PAG_CYCLE_RF64:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF64;
            break;

        case RRM_OAM_DEF_PAG_CYCLE_RF128:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF128;
            break;

        case RRM_OAM_DEF_PAG_CYCLE_RF256:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle =
                RRM_RRC_DEF_PAG_CYCLE_RF256;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.default_paging_cycle = RRM_RRC_DEF_PAG_CYCLE_RF32;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for default_paging_cycle: %d",
                    p_cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle);
            ret_val = RRM_FAILURE;
    }

    switch(p_cell_context->operator_info.sib_2_info.
            radio_res_config_common_sib.rrm_pcch_config.nB)
    {
        case RRM_OAM_NB_FOUR_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = RRM_RRC_NB_FOUR_T;
            break;

        case RRM_OAM_NB_TWO_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = 
                RRM_RRC_NB_TWO_T;
            break;

        case RRM_OAM_NB_ONE_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = 
                RRM_RRC_NB_ONE_T;
            break;

        case RRM_OAM_NB_HALF_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_HALF_T;
            break;

        case RRM_OAM_NB_QUARTER_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_QUARTER_T;
            break;

        case RRM_OAM_NB_ONE_EIGHTH_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_EIGHTH_T;
            break;

        case RRM_OAM_NB_ONE_SIXTEENTH_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = 
                RRM_RRC_NB_ONE_SIXTEENTH_T;
            break;

        case RRM_OAM_NB_ONE_THIRTY_SECOND_T:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb =
                RRM_RRC_NB_ONE_THIRTY_SECOND_T;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pcch_config.nb = RRM_RRC_NB_FOUR_T;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for nB: %d",
                    p_cell_context->operator_info.sib_2_info.
                    radio_res_config_common_sib.rrm_pcch_config.nB);
            ret_val = RRM_FAILURE;
    }	

    /*klock_works_changes_start*/
    ret_val=fill_pcch_config_nb_for_radio_rsrc_cmmn_sib(p_cell_context,p_rrc_rrm_cell_reconfig_req);
    /*klock_works_changes_end*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_prach_config_sib
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig prach config sib params coming from MIF to RRC
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_prach_config_sib
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.prach_config_sib.root_seq_index = 
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.root_sequence_index;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.prach_config_sib.prach_config_info.prach_config_index = 
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.configuration_index;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.prach_config_sib.prach_config_info.high_speed_flag = 
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.high_speed_flag;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.prach_config_sib.prach_config_info.zero_cor_zone_config =
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.zero_correlation_zone_config;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.prach_config_sib.prach_config_info.prach_freq_offset = 
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.frequency_offset;

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_pdsch_config_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig pdsch config common params coming from MIF to RRC
 *
 *   RETURNS     : NONE
 *****************************************************************************/
rrm_void_t
map_reconf_pdsch_config_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pdsch_config_common.ref_signal_power = 
        p_cell_context->ran_info.rf_params.rf_configurations.reference_signal_power;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pdsch_config_common.pb = 
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b;

    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_pusch_config_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig pusch config common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_pusch_config_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if (RRM_FAILURE == map_reconf_pusch_config_basic(p_cell_context,p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_pusch_config_basic");
        ret_val = RRM_FAILURE;
    }

    if (RRM_FAILURE == map_reconf_ul_ref_signals_pusch(p_cell_context,p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ul_ref_signals_pusch");
        ret_val = RRM_FAILURE;
    }


    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_pusch_config_basic
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig basic pusch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_pusch_config_basic
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pusch_config_common.pusch_config_basic.nsb = 
        p_cell_context->ran_info.physical_layer_params.physical_layer_param_pusch.n_sb;

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_pusch.pusch_hopping_mode)
    {
        case RRM_OAM_HM_INTER_SF:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                pusch_config_basic.hopping_mode= RRM_RRC_HM_INTER_SF;
            break;

        case RRM_OAM_HM_INTRA_AND_INTER_SF:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                pusch_config_basic.hopping_mode= RRM_RRC_HM_INTRA_AND_INTER_SF;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                pusch_config_basic.hopping_mode = RRM_RRC_HM_INTER_SF;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for pusch_hopping_mode: %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_pusch.pusch_hopping_mode);
            ret_val = RRM_FAILURE;
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pusch_config_common.
        pusch_config_basic.pusch_hopping_offset = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_pusch.hopping_offset;

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_pusch.enable_64_qam)
    {
        case RRM_FALSE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                pusch_config_basic.enable_64_qam= RRC_FALSE;
            break;

        case RRM_TRUE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                pusch_config_basic.enable_64_qam= RRC_TRUE;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                pusch_config_basic.enable_64_qam = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for enable_64_qam: %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_pusch.enable_64_qam);
            ret_val = RRM_FAILURE;
    } 

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_ref_signals_pusch
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul ref signals pusch params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_ref_signals_pusch
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_ul_reference_signal.group_hopping_enabled)
    {
        case RRM_FALSE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                ul_ref_signals_pusch.group_hopping_enabled = RRC_FALSE;
            break;

        case RRM_TRUE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                ul_ref_signals_pusch.group_hopping_enabled = RRC_TRUE;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                ul_ref_signals_pusch.group_hopping_enabled = RRC_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Inalid value for group_hopping_enabled: %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_ul_reference_signal.group_hopping_enabled);
            ret_val = RRM_FAILURE;
    }

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_ul_reference_signal.sequence_hopping_enabled)
    {
        case RRM_FALSE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                ul_ref_signals_pusch.seq_hopping_enabled = RRC_FALSE;
            break;

        case RRM_TRUE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                ul_ref_signals_pusch.seq_hopping_enabled = RRC_TRUE;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pusch_config_common.
                ul_ref_signals_pusch.seq_hopping_enabled = RRC_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for sequence_hopping_enabled:= %d", 
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_ul_reference_signal.sequence_hopping_enabled);
            ret_val = RRM_FAILURE;
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pusch_config_common.
        ul_ref_signals_pusch.group_assign_pusch = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_ul_reference_signal.group_assignment_pusch;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pusch_config_common.
        ul_ref_signals_pusch.cyclic_shift = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_ul_reference_signal.cyclic_shift;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_pucch_config_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig common pucch config params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_pucch_config_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_pucch.delta_pucch_shift)
    {
        case 0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pucch_config_common.delta_pucch_shift = 
                RRM_RRC_DS1;
            break;
        case 1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pucch_config_common.delta_pucch_shift = 
                RRM_RRC_DS2;
            break;
        case 2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pucch_config_common.delta_pucch_shift = 
                RRM_RRC_DS3;
            break;
        default :
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.pucch_config_common.delta_pucch_shift = RRM_RRC_DS1;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for delta_pucch_shift = %u",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_pucch.delta_pucch_shift);
            ret_val = RRM_FAILURE;
            break;
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pucch_config_common.n_rb_cqi = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_pucch.n_rb_cqi;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pucch_config_common.n_cs_an = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_pucch.n_cs_an;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.pucch_config_common.n_one_pucch_an = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_pucch.n1_pucch_an;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sounding_ack_nack_srs_simul_trans
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconf sounding ack nack srs simul trans coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sounding_ack_nack_srs_simul_trans(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_srs.ack_nack_srs_simultaneous_transmission)
    {
        case RRM_FALSE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.ack_nack_srs_simul_trans= RRC_FALSE;
            break;

        case RRM_TRUE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.ack_nack_srs_simul_trans= RRC_TRUE;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.ack_nack_srs_simul_trans = RRC_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for ack_nack_srs_simultaneous_transmission : %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_srs.ack_nack_srs_simultaneous_transmission); 
            ret_val = RRM_FAILURE;
            break;
    }


    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sounding_srs_subframe_config
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sounding srs subframe config coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sounding_srs_subframe_config(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_srs.srs_subframe_config)
    {
        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC0;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC1;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC2;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC3;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC4;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC5;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC6;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC7;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC8;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC9:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC9;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC10;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC11:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC11;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC12;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC13:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC13;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC14:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC14;
            break;

        case RRM_OAM_SRS_SUBFRAME_CONFIG_SC15:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC15;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_subframe_config= RRM_RRC_SRS_SUBFRAME_CONFIG_SC0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for srs_subframe_config: %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_srs.srs_subframe_config);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*klock_works_changes_start*/
rrm_return_et
map_reconf_sounding_rs_ul_config_common_srs_bw_config
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_srs.srs_bandwidth_config)
    {
        case RRM_OAM_SRS_BW_CONFIG_BW0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW0;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW1;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW2;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW3;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW4;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW5;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW6;
            break;

        case RRM_OAM_SRS_BW_CONFIG_BW7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW7;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_bw_config = RRM_RRC_SRS_BW_CONFIG_BW0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid value for srs_bandwidth_config: %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_srs.srs_bandwidth_config);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*klock_works_changes_end*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sounding_rs_ul_config_common
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig sounding srs ul config 
 *      common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sounding_rs_ul_config_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.
        sounding_rs_ul_config_common.presence_bitmask = RRM_ZERO; 
    if(RRM_TRUE == p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_srs.srsEnabled)
    {
        /*setting bitmask*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.
            sounding_rs_ul_config_common.presence_bitmask |= 
            SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            radio_resource_config_common_sib.
            sounding_rs_ul_config_common.setup.presence_bitmask = RRM_ZERO;

        /*klock_works_changes_start*/

        ret_val = map_reconf_sounding_rs_ul_config_common_srs_bw_config(p_cell_context, p_rrc_rrm_cell_reconfig_req);

        /*klock_works_changes_start*/
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        if(RRM_FAILURE == map_reconf_sounding_srs_subframe_config(p_cell_context,
                    p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_sounding_srs_subframe_config");
            ret_val = RRM_FAILURE;
        }
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        if (p_cell_context->ran_info.physical_layer_params.
                physical_layer_param_srs.bitmask &
                RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT)
        {
            /*BUG_931_CHANGES_START*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.sounding_rs_ul_config_common.
                setup.srs_max_up_pts = RRM_SRS_MAX_UP_PTS_TRUE;
            /*BUG_931_CHANGES_END*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.
                sounding_rs_ul_config_common.setup.presence_bitmask |= 
                SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG;
        }
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        if (RRM_FAILURE == map_reconf_sounding_ack_nack_srs_simul_trans(p_cell_context,
                    p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_sounding_ack_nack_srs_simul_trans");
            ret_val = RRM_FAILURE;
        }

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*spr_22528_changes_start*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_3_r10
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 3 R10
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_3_r10(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_3_r10)
    {
        case RRMC_FORMAT_3_R10_DELTA_NEG_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF_1;
            break;

        case RRMC_FORMAT_3_R10_DELTA_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF0;
            break;

        case RRMC_FORMAT_3_R10_DELTA_POS_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF1;
            break;

        case RRMC_FORMAT_3_R10_DELTA_POS_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF2;
            break;

        case RRMC_FORMAT_3_R10_DELTA_POS_THREE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF3;
            break;

        case RRMC_FORMAT_3_R10_DELTA_POS_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF4;
            break;

        case RRMC_FORMAT_3_R10_DELTA_POS_FIVE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF5;
            break;

        case RRMC_FORMAT_3_R10_DELTA_POS_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10
                = DELTAF6;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format3_r10 =
                p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_3_r10; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_3_r10[%d]",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_3_r10); 
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b_cs_r10
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 1B CS R10
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b_cs_r10(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b_cs_r10)
    {
        case RRMC_FORMAT_1B_CS_R10_DELTA_POS_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format1_bcs_r10
                = DELTA_F1;
            break;

        case RRMC_FORMAT_1B_CS_R10_DELTA_POS_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common_v1020.pucch_format1_bcs_r10
                = DELTA_F2;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_b =
                p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b_cs_r10; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_1b_cs_r10[%d]",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b_cs_r10); 
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*spr_22528_changes_end*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_two_b
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 2b RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_two_b(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    /* BUG_371 FIX START */
    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b)
        /* BUG_371 FIX END */
    {
        case RRMC_DELTA_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_NEG_TWO;
            break;

        case RRMC_DELTA_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_ZERO;
            break;

        case RRMC_DELTA_POS_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_b = RRM_RRC_DELTA_POS_TWO;
            break;

        default:
            /* BUG_371 FIX START */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_b =
                p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_2b[%d]",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b); 
            /* BUG_371 FIX END */
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_two_a
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 2a to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_two_a(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    /* BUG_371 FIX START */
    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a)
        /* BUG_371 FIX END */
    {
        case RRMC_DELTA_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_NEG_TWO;
            break;

        case RRMC_DELTA_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_pucch_format_two.delta_f_pucch_format_two_a =
                RRM_RRC_DELTA_ZERO;
            break;

        case RRMC_DELTA_POS_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = RRM_RRC_DELTA_POS_TWO;
            break;

        default:
            /* BUG_371 FIX START */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.
                sib_type_2_Info.radio_resource_config_common_sib.
                uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_a = p_cell_context->operator_info.
                rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_2a[%d]",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a); 
            /* BUG_371 FIX END */
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_two
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 2 to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_two(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* BUG_371 FIX START */
    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2)
        /* BUG_371 FIX END */
    {
        case RRMC_FORMAT2_DELTA_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_pucch_format_two.delta_f_pucch_format_two =
                RRM_RRC_FORMAT2_DELTA_NEG_TWO;
            break;

        case RRMC_FORMAT2_DELTA_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_pucch_format_two.delta_f_pucch_format_two =
                RRM_RRC_FORMAT2_DELTA_ZERO;
            break;

        case RRMC_FORMAT2_DELTA_POS_ONE:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_pucch_format_two.delta_f_pucch_format_two =
                RRM_RRC_FORMAT2_DELTA_POS_ONE;
            break;

        case RRMC_FORMAT2_DELTA_POS_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_pucch_format_two.delta_f_pucch_format_two = 
                RRM_RRC_FORMAT2_DELTA_POS_TWO;
            break;

        default:
            /* BUG_371 FIX START */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_pucch_format_two.delta_f_pucch_format_two =
                p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_2 : %d",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2);
            /* BUG_371 FIX END */
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 1b to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    /* BUG_371 FIX START */
    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b)
        /* BUG_371 FIX END */
    {
        case RRMC_DELTA_F1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one_b= RRM_RRC_DELTA_F1;
            break;

        case RRMC_DELTA_F3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one_b= RRM_RRC_DELTA_F3;
            break;

        case RRMC_DELTA_F5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one_b= RRM_RRC_DELTA_F5;
            break;

        default:
            /* BUG_371 FIX START */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one_b= 
                p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_1b: %d",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b);
            /* BUG_371 FIX END */
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ul_pwrctrl_delta_f_pucch_format_one
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control delta pucch format 1 to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ul_pwrctrl_delta_f_pucch_format_one(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* BUG_371 FIX START */
    switch(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1)
        /* BUG_371 FIX END */
    {
        case RRMC_DELTAF_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one= RRM_RRC_DELTAF_NEG_TWO;
            break;

        case RRMC_DELTAF_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one= RRM_RRC_DELTAF_ZERO;
            break;

        case RRMC_DELTAF_POS_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one= RRM_RRC_DELTAF_POS_TWO;
            break;

        default:
            /* BUG_371 FIX START */
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                delta_f_list_pucch.delta_f_pucch_format_one= 
                p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for delta_f_pucch_format_1: %d",
                    p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1);
            /* BUG_371 FIX END */
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/


/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_uplink_power_control_common
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig ul power control common params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_uplink_power_control_common
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.uplink_power_control_common.
        p_zero_nominal_Pusch = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_ul_power_control.p_0_nominal_pusch;

    /* BUG_371 FIX START */
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.uplink_power_control_common.
        delta_preamble_msg_three = 
        p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_preamble_msg_3;
    /* BUG_371 FIX END */

    switch(p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_ul_power_control.alpha)
    {
        case RRM_OAM_AL_0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0;
            break;

        case RRM_OAM_AL_0_4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0_4;
            break;

        case RRM_OAM_AL_0_5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0_5;
            break;

        case RRM_OAM_AL_0_6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0_6;
            break;

        case RRM_OAM_AL_0_7:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0_7;
            break;

        case RRM_OAM_AL_0_8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0_8;
            break;

        case RRM_OAM_AL_0_9:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_0_9;
            break;

        case RRM_OAM_AL_1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_1;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                radio_resource_config_common_sib.uplink_power_control_common.
                alpha = RRM_RRC_AL_1;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for alpha: %d",
                    p_cell_context->ran_info.physical_layer_params.
                    physical_layer_param_ul_power_control.alpha);
            ret_val = RRM_FAILURE;
    }
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        radio_resource_config_common_sib.uplink_power_control_common.
        p_zero_nominal_pucch = 
        p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_ul_power_control.p_0_nominal_pucch;

/*spr_22528_changes_start*/
p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.radio_resource_config_common_sib.presence_bitmask = RRM_ZERO;
/*spr_22528_changes_end*/

     /* SPR 14912 Fix Start */
    if(RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_one(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
     /* SPR 14912 Fix End */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
        /* Spr 16115 fix start */
                "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_one");
        /* Spr 16115 fix End */
        ret_val = RRM_FAILURE;
    }

    if (RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b");
        ret_val = RRM_FAILURE;
    }
    if (RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_two(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_two");
        ret_val = RRM_FAILURE;
    }
    if (RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_two_a(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_two_a");
        ret_val = RRM_FAILURE;
    }
    if (RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_two_b(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_two_b");
        ret_val = RRM_FAILURE;
    }
    /*spr_22528_changes_start*/
    if(p_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.bitmask & RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT)
    {
        if (RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b_cs_r10(p_cell_context,
                    p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_one_b_cs_r10");
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.radio_resource_config_common_sib.
                presence_bitmask |= RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020;
        }

        if (RRM_FAILURE == map_reconf_ul_pwrctrl_delta_f_pucch_format_3_r10(p_cell_context,
                    p_rrc_rrm_cell_reconfig_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Failure returned from map_reconf_ul_pwrctrl_delta_f_pucch_format_3_r10");
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.radio_resource_config_common_sib.
                presence_bitmask |= RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020;
        }
    }
    /*spr_22528_changes_end*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_ue_timers_and_constants_timer_n311
 *  INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the ue timers and constants for timer n311 for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ue_timers_and_constants_timer_n311(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t                *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rrc_timers_and_constants.
            rrc_constants.n311)
    {
        /* Coverity 69755 Fix Start */
        case RRM_OAM_TIMER_N311_N1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N1;                       
            break;
        
        case RRM_OAM_TIMER_N311_N2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N2;                         
            break;

        case RRM_OAM_TIMER_N311_N3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N3 ;                       
            break;

        case RRM_OAM_TIMER_N311_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N4;                          
            break;

        case RRM_OAM_TIMER_N311_N5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N5;                           
            break;

        case RRM_OAM_TIMER_N311_N6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N6;                            
            break;

        case RRM_OAM_TIMER_N311_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N8;                             
            break;

        case RRM_OAM_TIMER_N311_N10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N10;                             
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n311 = (U8)RRM_RRC_TIMER_N311_N10;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for n311: %d",
                    p_cell_context->ran_info.rrc_timers_and_constants.
                    rrc_constants.n311);
            ret_val = RRM_FAILURE;
        /* Coverity 69755 Fix End */
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_ue_timers_and_constants_timer_n310
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the ue timers and constants for timer n310 for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ue_timers_and_constants_timer_n310(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t                *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    //mismatch in no. of elements of timer_n310 and n310. need to check
    switch(p_cell_context->ran_info.rrc_timers_and_constants.
            rrc_constants.n310)
    {
    /* Coverity 69762  Fix Start */
        case RRM_OAM_TIMER_N310_N1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N1;               
            break;

        case RRM_OAM_TIMER_N310_N2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N2;               
            break;

        case RRM_OAM_TIMER_N310_N3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N3;              
            break;

        case RRM_OAM_TIMER_N310_N4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N4;               
            break;

        case RRM_OAM_TIMER_N310_N6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N6;                 
            break;

        case RRM_OAM_TIMER_N310_N8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N8;                   
            break;

        case RRM_OAM_TIMER_N310_N10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N10;                 
            break;

        case RRM_OAM_TIMER_N310_N20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N20;                 
            break;
        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_n310 = (U8)RRM_RRC_TIMER_N310_N20;                  
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for n310: %d",
                    p_cell_context->ran_info.rrc_timers_and_constants.
                    rrc_constants.n310);
            ret_val = RRM_FAILURE;
    /* Coverity 69762 Fix End */
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/

/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_ue_timers_and_constants_timer_311
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the ue timers and constants for timer 311 for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ue_timers_and_constants_timer_311(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t 		*p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rrc_timers_and_constants.
            rrc_timers.t311)
    {
        case RRM_OAM_TIMER_311_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS1000;
            break;

        case RRM_OAM_TIMER_311_MS3000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS3000;
            break;

        case RRM_OAM_TIMER_311_MS5000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS5000;
            break;

        case RRM_OAM_TIMER_311_MS10000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS10000;
            break;

        case RRM_OAM_TIMER_311_MS15000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS15000;
            break;

        case RRM_OAM_TIMER_311_MS20000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS20000;
            break;

        case RRM_OAM_TIMER_311_MS30000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS30000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_311 = RRM_RRC_TIMER_311_MS30000;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t311: %d",
                    p_cell_context->ran_info.rrc_timers_and_constants.
                    rrc_timers.t311);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;

}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/


/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_ue_timers_and_constants_t301
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the ue timers and constants for timer 310 for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ue_timers_and_constants_timer_310(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rrc_timers_and_constants.
            rrc_timers.t310)
    {
        case RRM_OAM_TIMER_310_MS0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS0;
            break;

        case RRM_OAM_TIMER_310_MS50:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS50;
            break;

        case RRM_OAM_TIMER_310_MS100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS100;
            break;

        case RRM_OAM_TIMER_310_MS200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS200;
            break;

        case RRM_OAM_TIMER_310_MS500:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS500;
            break;

        case RRM_OAM_TIMER_310_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS1000;
            break;

        case RRM_OAM_TIMER_310_MS2000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS2000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_310 = RRM_RRC_TIMER_310_MS2000;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t310: %d",
                    p_cell_context->ran_info.rrc_timers_and_constants.
                    rrc_timers.t310);
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/


/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_ue_timers_and_constants_t301
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the ue timers and constants for timer 301 for cell reconfig
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ue_timers_and_constants_timer_301(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rrc_timers_and_constants.
            rrc_timers.t301)
    {
        case RRM_OAM_TIMER_300_301_MS100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS100;
            break;

        case RRM_OAM_TIMER_300_301_MS200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS200;
            break;

        case RRM_OAM_TIMER_300_301_MS300:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS300;
            break;

        case RRM_OAM_TIMER_300_301_MS400:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS400;
            break;

        case RRM_OAM_TIMER_300_301_MS600:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS600;
            break;

        case RRM_OAM_TIMER_300_301_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS1000;
            break;

        case RRM_OAM_TIMER_300_301_MS1500:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS1500;
            break;

        case RRM_OAM_TIMER_300_301_MS2000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS2000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_301 = RRM_RRC_TIMER_300_301_MS2000;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "inavlid value for t301: %d",
                    p_cell_context->ran_info.rrc_timers_and_constants.
                    rrc_timers.t301);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/


/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_ue_timers_and_constants
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig ue timers and constants
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_ue_timers_and_constants
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.
            rrc_timers_and_constants.rrc_timers.t300)
    {
        case RRM_OAM_TIMER_300_301_MS100:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS100;
            break;

        case RRM_OAM_TIMER_300_301_MS200:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS200;
            break;

        case RRM_OAM_TIMER_300_301_MS300:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS300;
            break;

        case RRM_OAM_TIMER_300_301_MS400:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS400;
            break;

        case RRM_OAM_TIMER_300_301_MS600:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS600;
            break;

        case RRM_OAM_TIMER_300_301_MS1000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS1000;
            break;

        case RRM_OAM_TIMER_300_301_MS1500:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS1500;
            break;

        case RRM_OAM_TIMER_300_301_MS2000:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS2000;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                ue_timers_and_constants.timer_300 = RRM_RRC_TIMER_300_301_MS2000;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "inavlid value for t300: %d",
                    p_cell_context->ran_info.rrc_timers_and_constants.
                    rrc_timers.t300);
            ret_val = RRM_FAILURE;
    }

    if (RRM_FAILURE == map_reconf_ue_timers_and_constants_timer_301(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ue_timers_and_constants_timer_301");
        ret_val = RRM_FAILURE;
    }

    if (RRM_FAILURE == map_reconf_ue_timers_and_constants_timer_310(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ue_timers_and_constants_timer_310");
        ret_val = RRM_FAILURE;
    }
    if (RRM_FAILURE == map_reconf_ue_timers_and_constants_timer_311(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ue_timers_and_constants_timer_311");
        ret_val = RRM_FAILURE;
    }
    if (RRM_FAILURE == map_reconf_ue_timers_and_constants_timer_n310(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ue_timers_and_constants_timer_n310");
        ret_val = RRM_FAILURE;
    }
    if (RRM_FAILURE == map_reconf_ue_timers_and_constants_timer_n311(p_cell_context,
                p_rrc_rrm_cell_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Failure returned from map_reconf_ue_timers_and_constants_timer_n311");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_freq_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig freq info
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_freq_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
        freq_info.presence_bitmask =RRM_ZERO;

    /* Bug 632 Fix Start */
#ifndef TDD_MODE_FLAG 
    /* Bug 632 Fix End */
    /* Bug 602 Fix Start */
    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT) &&
            (p_cell_context->ran_info.rf_params.rf_configurations.bitmask & 
             RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT))
        /* Bug 602 Fix End */
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.presence_bitmask |= FREQ_INFO_UL_BW_PRESENCE_FLAG ;

        switch(p_cell_context->ran_info.rf_params.rf_configurations.
                ul_bandwidth)
        {
            case RRM_OAM_BW_N_6:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_6RB;
                break;

            case RRM_OAM_BW_N_15:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_15RB;
                break;

            case RRM_OAM_BW_N_25:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_25RB;
                break;

            case RRM_OAM_BW_N_50:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_50RB;
                break;

            case RRM_OAM_BW_N_75:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_75RB;
                break;

            case RRM_OAM_BW_N_100:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_100RB;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                    freq_info.ul_bandwidth = RRM_RRC_UL_BW_100RB;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "invalid value for ul_bandwidth: %d",
                        p_cell_context->ran_info.rf_params.rf_configurations.
                        ul_bandwidth);
                ret_val = RRM_FAILURE;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    }
    /* Bug 632 Fix Start */
#endif
    /* Bug 632 Fix End */

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        if(p_cell_context->operator_info.sib_2_info.rrm_freq_info.bitmask & RRMCM_RMIF_UL_CARRIER_FREQ_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.presence_bitmask |= FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
                freq_info.ul_carrier_freq = p_cell_context->operator_info.
                sib_2_info.rrm_freq_info.ul_carrier_freq;		/*optional: dont fill, Nupur*/
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.
            freq_info.add_spectrum_emission = 
            p_cell_context->operator_info.sib_2_info.
            rrm_freq_info.additional_spectrum_emission;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_mbsfn_subframe_config_list
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig mbsfn subframe config list to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

/*For Future Release*/
/*
   rrm_return_et
   map_reconf_mbsfn_subframe_config_list
   (
   rrm_cell_context_t *p_cell_context, 
   rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
   )
   {*/
/*this func doesnt need bitmask to be checked as only ran_t is present and is checked during call*/
/*		U8 mb_sfn_subframe=0, subframe_allocs=0,valid_mb_sfn_subframe=0;

        RRM_UT_TRACE_ENTER();
        valid_mb_sfn_subframe = p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.count = p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.count;

        if(p_reconfig_req_from_mif->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_MBSFN_CONFIG_PRESENT)
        {
        for(mb_sfn_subframe=0; mb_sfn_subframe<valid_mb_sfn_subframe; mb_sfn_subframe++)
        {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].radio_frame_alloc_period = p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.mb_sfn_list[mb_sfn_subframe].radio_frame_allocation_period;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].radio_frame_alloc_offset = p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.mb_sfn_list[mb_sfn_subframe].radio_frame_allocation_offset;

        if(p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.mb_sfn_list[mb_sfn_subframe].radio_frame_allocation_size == RRMCM_RADIO_FRAME_ALLOC_SIZE_1)
        {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].subframe_allocation.presence_bitmask |= SUBFRAME_ALLOCATION_ONE_FRAME;
 */			
/*								p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].subframe_allocation.one_frame[0] = p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.mb_sfn_list[mb_sfn_subframe].sub_frame_allocations[0];

                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].subframe_allocation.presence_bitmask |= SUBFRAME_ALLOCATION_ONE_FRAME;

                                }
                                if(p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.mb_sfn_list[mb_sfn_subframe].radio_frame_allocation_size == SUBFRAME_ALLOCATION_FOUR_FRAMES)
                                {
                                for(subframe_allocs=0; subframe_allocs<MAX_SUBFRAME_ALLOCATIONS; subframe_allocs++)
                                {
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].subframe_allocation.presence_bitmask |= SUBFRAME_ALLOCATION_FOUR_FRAMES ;
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].subframe_allocation.four_frames[subframe_allocs] = p_reconfig_req_from_mif->ran_info.physical_layer_params.physical_layer_param_mb_sfn_configuration.mb_sfn_list[mb_sfn_subframe].sub_frame_allocations[subframe_allocs];

                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_2_Info.mbsfn_subframe_config_list.mbsfn_subframe_config[mb_sfn_subframe].subframe_allocation.presence_bitmask |= SUBFRAME_ALLOCATION_FOUR_FRAMES;

                                }
                                }
                                }

                                p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_2_INFO_PRESENCE_FLAG;
                                p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
                                }

                                RRM_UT_TRACE_EXIT();
                                return RRM_SUCCESS;
                                }
 */

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib3_intra_search_v920
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *           This function Maps the cell reconfig sib3 intra search v920 to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib3_intra_search_v920
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        sib3_intra_search_v920.s_intra_search_p_r9 = 
        p_cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_p_r9;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        sib3_intra_search_v920.s_intra_search_q_r9 = 
        p_cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib3_intra_search_v920_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *           This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib3_intra_search_v920_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_intra_search_v920.s_intra_search_p_r9 = p_cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_p_r9;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_intra_search_v920.s_intra_search_q_r9 = p_cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib3_non_intra_search_v920
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *           This function Maps the cell reconfig sib3 non intra search v920 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib3_non_intra_search_v920
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        sib3_non_intra_search_v920.s_non_intra_search_p_r9 = 
        p_cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_p_r9;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        sib3_non_intra_search_v920.s_non_intra_search_q_r9 = 
        p_cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib3_non_intra_search_v920_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *           This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib3_non_intra_search_v920_for_son
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_non_intra_search_v920.s_non_intra_search_p_r9 = p_cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_p_r9;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.sib3_non_intra_search_v920.s_non_intra_search_q_r9 = p_cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_q_r9;

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_3_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 3 info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_3_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask = RRM_ZERO;

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT) && 
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_RMIF_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT) && 
            (p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.bitmask & 
             RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS) && 
            (p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_3_INFO_PRESENT))
    {
        //DONE
        map_reconf_timecell_reselect_info_comm(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        //DONE
        map_reconf_cell_reselect_serv_freq_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        //DONE
        map_reconf_intra_freq_cell_reselect_info(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);


        if(p_cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT)
        {
            //DONE
            map_reconf_sib3_intra_search_v920(p_cell_context, p_rrc_rrm_cell_reconfig_req);
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= 
                SIB_3_INTRA_SEARCH_V920_PRESENCE_FLAG;
        }

        if(p_cell_context->operator_info.sib_3_info.bitmask & 
                RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT)
        {
            //DONE
            map_reconf_sib3_non_intra_search_v920(p_cell_context, p_rrc_rrm_cell_reconfig_req);
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= 
                SIB_3_NON_INTRA_SEARCH_V920_PRESENCE_FLAG;
        }

        if(p_cell_context->operator_info.sib_3_info.bitmask & 
                RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.q_qual_min_r9 = 
                p_cell_context->operator_info.sib_3_info.q_qual_min_r9;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= 
                SIB_3_Q_QUAL_MIN_R9_PRESENCE_FLAG;
        }

        if(p_cell_context->operator_info.sib_3_info.bitmask & 
                RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                thresh_serving_low_q_r9 = 
                p_cell_context->operator_info.sib_3_info.thresh_serving_lowq_r9;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= 
                SIB_3_THRESH_SERVING_LOW_Q_R9_PRESENCE_FLAG;
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    }

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,"SIB_3  %d",
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask);
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/* Release 1.2 changes for cell reconfig interface for SON */
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_3_Info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_3_Info_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask = RRM_ZERO;

    map_reconf_timecell_reselect_info_comm_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    map_reconf_cell_reselect_serv_freq_info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    map_reconf_intra_freq_cell_reselect_info_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);

    if(p_cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT)
    {
        map_reconf_sib3_intra_search_v920_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= SIB_3_INTRA_SEARCH_V920_PRESENCE_FLAG;
    }

    if(p_cell_context->operator_info.sib_3_info.bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT)
    {
        map_reconf_sib3_non_intra_search_v920_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= SIB_3_NON_INTRA_SEARCH_V920_PRESENCE_FLAG;
    }

    if (p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask &
            RRMCM_SERV_CELL_Q_QUALMIN_R9_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.q_qual_min_r9 = 
            p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.q_qualmin_r9;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= SIB_3_Q_QUAL_MIN_R9_PRESENCE_FLAG;
    }

    if (p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask &
            RRMCM_SERV_CELL_THRESHX_LOWQ_R9_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.thresh_serving_low_q_r9 = 
            p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.threshx_lowq_r9;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask |= SIB_3_THRESH_SERVING_LOW_Q_R9_PRESENCE_FLAG;
    }

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,"DEBUG: SIB_3  %d",
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.presence_bitmask);
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* Release 1.2 changes for cell reconfig interface for SON */

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_t_hyst_normal
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig timecell hyst normal params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_timecell_t_hyst_normal(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t     
        *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();


    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.t_hyst_normal)
    {
        case RRM_OAM_T_HYST_NORMAL_S_30:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_30;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_60;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_120;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_180:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_180;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_240:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_240;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.t_hyst_normal;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t_hyst_normal: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.t_hyst_normal);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_t_hyst_normal_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_timecell_t_hyst_normal_for_son(const rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.t_hyst_normal)
    {
        case RRM_OAM_T_HYST_NORMAL_S_30:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_30;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal = RRM_RRC_T_HYST_NORMAL_S_60;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_120;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_180:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_180;
            break;

        case RRM_OAM_T_HYST_NORMAL_S_240:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =RRM_RRC_T_HYST_NORMAL_S_240;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_hyst_normal =
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.t_hyst_normal;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t_hyst_normal: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.t_hyst_normal);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_q_hyst_sf_high
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig timecell evaluation params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_timecell_t_evaluation(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.t_evaluation)
    {
        case RRM_OAM_T_EVAL_S_30:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_30;
            break;

        case RRM_OAM_T_EVAL_S_60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_60;
            break;

        case RRM_OAM_T_EVAL_S_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_120;
            break;

        case RRM_OAM_T_EVAL_S_180:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_180;
            break;

        case RRM_OAM_T_EVAL_S_240:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_240;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = 
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.t_evaluation;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t_evaluation: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.t_evaluation); 
            ret_val = RRM_FAILURE;
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_q_hyst_sf_high_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_timecell_t_evaluation_for_son(const rrm_cell_context_t  *p_cell_context,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.t_evaluation)
    {
        case RRM_OAM_T_EVAL_S_30:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_30;
            break;

        case RRM_OAM_T_EVAL_S_60:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_60;
            break;

        case RRM_OAM_T_EVAL_S_120:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_120;
            break;

        case RRM_OAM_T_EVAL_S_180:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_180;
            break;

        case RRM_OAM_T_EVAL_S_240:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = RRM_RRC_T_EVAL_S_240;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                mobility_state_params.t_evaluation = 
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.t_evaluation;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for t_evaluation: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.t_evaluation); 
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_q_hyst_sf_high
 *
 *   DESCRIPTION :
 *      This function Maps the cell reconfig timecell hyst sf high params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_timecell_q_hyst_sf_high(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t           *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_high)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_NEG_SIX;
            break;

        case RRM_OAM_Q_HYST_NEG_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high = 
                RRM_RRC_Q_HYST_NEG_FOUR;
            break;

        case RRM_OAM_Q_HYST_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_NEG_TWO;
            break;

        case RRM_OAM_Q_HYST_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.q_hyst_sf_high;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst_sf_high: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.q_hyst_sf_high);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_q_hyst_sf_high_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_timecell_q_hyst_sf_high_for_son(const rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t     *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_high)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_NEG_SIX;
            break;

        case RRM_OAM_Q_HYST_NEG_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high = 
                RRM_RRC_Q_HYST_NEG_FOUR;
            break;

        case RRM_OAM_Q_HYST_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_NEG_TWO;
            break;

        case RRM_OAM_Q_HYST_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_high =
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.q_hyst_sf_high;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst_sf_high: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.q_hyst_sf_high);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_q_hyst_sf_medium
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig timecell hyst sf medium params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_timecell_q_hyst_sf_medium(
        rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t	   *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_medium)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium = 
                RRM_RRC_Q_HYST_NEG_SIX;
            break;

        case RRM_OAM_Q_HYST_NEG_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_NEG_FOUR;
            break;

        case RRM_OAM_Q_HYST_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_NEG_TWO;
            break;

        case RRM_OAM_Q_HYST_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.q_hyst_sf_medium;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst_sf_medium: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.q_hyst_sf_medium);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/


/****************************************************************************
 *   FUNCTION NAME       :  map_reconf_timecell_q_hyst_sf_medium_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
    rrm_return_et
map_reconf_timecell_q_hyst_sf_medium_for_son(const rrm_cell_context_t *p_cell_context,
        rrc_rrm_cell_reconfig_req_t	   *p_rrc_rrm_cell_reconfig_req)
{

    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.
            speed_state_params.q_hyst_sf_medium)
    {
        case RRM_OAM_Q_HYST_NEG_SIX:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium = 
                RRM_RRC_Q_HYST_NEG_SIX;
            break;

        case RRM_OAM_Q_HYST_NEG_FOUR:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_NEG_FOUR;
            break;

        case RRM_OAM_Q_HYST_NEG_TWO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_NEG_TWO;
            break;

        case RRM_OAM_Q_HYST_ZERO:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                RRM_RRC_Q_HYST_ZERO;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.speed_depend_reselect.
                speed_depend_scaling_param_hyst.q_hyst_sf_medium =
                p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.
                speed_state_params.q_hyst_sf_medium;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst_sf_medium: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.
                    speed_state_params.q_hyst_sf_medium);
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_timecell_reselect_info_comm
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig timecell reselect info comm params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_timecell_reselect_info_comm
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    /*coverity 23146:removing "p_reconfig_req_from_mif":, rel 1.3*/
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        timecell_reselect_info_comm.presence_bitmask = RRM_ZERO;

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst)
    {
        case RRM_OAM_Q_HYST_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB0;
            break;

        case RRM_OAM_Q_HYST_DB1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB1;
            break;

        case RRM_OAM_Q_HYST_DB2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB2;
            break;

        case RRM_OAM_Q_HYST_DB3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB3;
            break;

        case RRM_OAM_Q_HYST_DB4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB4;
            break;

        case RRM_OAM_Q_HYST_DB5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB5;
            break;

        case RRM_OAM_Q_HYST_DB6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB6;
            break;

        case RRM_OAM_Q_HYST_DB8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB8;
            break;

        case RRM_OAM_Q_HYST_DB10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB10;
            break;

        case RRM_OAM_Q_HYST_DB12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB12;
            break;

        case RRM_OAM_Q_HYST_DB14:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB14;
            break;

        case RRM_OAM_Q_HYST_DB16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB16;
            break;

        case RRM_OAM_Q_HYST_DB18:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB18;
            break;

        case RRM_OAM_Q_HYST_DB20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB20;
            break;

        case RRM_OAM_Q_HYST_DB22:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB22;
            break;

        case RRM_OAM_Q_HYST_DB24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB24;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst);
            ret_val = RRM_FAILURE;
    }


    if(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.bitmask & 
            RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            timecell_reselect_info_comm.presence_bitmask |= 
            CELL_RESELECT_SPEED_DEPEND_RESELECT_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            timecell_reselect_info_comm.speed_depend_reselect.
            mobility_state_params.n_cell_change_medium = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            n_cell_change_medium;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            timecell_reselect_info_comm.speed_depend_reselect.
            mobility_state_params.n_cell_change_high = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            n_cell_change_high;

        //DONE all func below
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        /*this function map the sub info :  broken code to make modular*/
        map_reconf_timecell_q_hyst_sf_medium(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        map_reconf_timecell_q_hyst_sf_high(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/	
        map_reconf_timecell_t_evaluation(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/

        /*LTE_RRM_KLOCWORK_WARN_10_JULY_START*/
        map_reconf_timecell_t_hyst_normal(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
        /*LTE_RRM_KLOCWORK_WARN_10_JULY_END*/ 
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_timecell_reselect_info_comm_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_timecell_reselect_info_comm_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        timecell_reselect_info_comm.presence_bitmask = RRM_ZERO;

    switch(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst)
    {
        case RRM_OAM_Q_HYST_DB0:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB0;
            break;

        case RRM_OAM_Q_HYST_DB1:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB1;
            break;

        case RRM_OAM_Q_HYST_DB2:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB2;
            break;

        case RRM_OAM_Q_HYST_DB3:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB3;
            break;

        case RRM_OAM_Q_HYST_DB4:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB4;
            break;

        case RRM_OAM_Q_HYST_DB5:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB5;
            break;

        case RRM_OAM_Q_HYST_DB6:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB6;
            break;

        case RRM_OAM_Q_HYST_DB8:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB8;
            break;

        case RRM_OAM_Q_HYST_DB10:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB10;
            break;

        case RRM_OAM_Q_HYST_DB12:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB12;
            break;

        case RRM_OAM_Q_HYST_DB14:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB14;
            break;

        case RRM_OAM_Q_HYST_DB16:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB16;
            break;

        case RRM_OAM_Q_HYST_DB18:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB18;
            break;

        case RRM_OAM_Q_HYST_DB20:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB20;
            break;

        case RRM_OAM_Q_HYST_DB22:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB22;
            break;

        case RRM_OAM_Q_HYST_DB24:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = RRM_RRC_Q_HYST_DB24;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                timecell_reselect_info_comm.q_hyst = p_cell_context->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "invalid value for q_hyst: %d",
                    p_cell_context->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst);
            ret_val = RRM_FAILURE;
    }


    if(p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.bitmask & RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.timecell_reselect_info_comm.presence_bitmask |= CELL_RESELECT_SPEED_DEPEND_RESELECT_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.timecell_reselect_info_comm.speed_depend_reselect.mobility_state_params.n_cell_change_medium = p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.speed_state_params.n_cell_change_medium;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.timecell_reselect_info_comm.speed_depend_reselect.mobility_state_params.n_cell_change_high = p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.speed_state_params.n_cell_change_high;

        map_reconf_timecell_q_hyst_sf_medium_for_son(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        map_reconf_timecell_q_hyst_sf_high_for_son(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        map_reconf_timecell_t_evaluation_for_son(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);

        map_reconf_timecell_t_hyst_normal_for_son(p_cell_context,
                p_rrc_rrm_cell_reconfig_req);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_cell_reselect_serv_freq_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig cell reselect serv freq info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_cell_reselect_serv_freq_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        cell_reselect_serv_freq_info.presence_bitmask = RRM_ZERO;
    /*bitmask*/
    if(p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            cell_reselect_serv_freq_info.presence_bitmask |= 
            CELL_RESELECT_NON_INTRA_SEARCH_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            cell_reselect_serv_freq_info.s_non_intra_search = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.s_non_intra_search;
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        cell_reselect_serv_freq_info.thresh_serving_low = 
        p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.thresh_serving_low;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        cell_reselect_serv_freq_info.cell_reselect_priority = 
        p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.cell_reselection_priority;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_cell_reselect_serv_freq_info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_cell_reselect_serv_freq_info_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        cell_reselect_serv_freq_info.presence_bitmask = RRM_ZERO;

    if(p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.presence_bitmask |= CELL_RESELECT_NON_INTRA_SEARCH_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.s_non_intra_search = p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.s_non_intra_search;
    }
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.thresh_serving_low = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.thresh_serving_low;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.cell_reselect_serv_freq_info.cell_reselect_priority = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.cell_reselection_priority;

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_intra_freq_cell_reselect_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig intra freq cell reselect info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_intra_freq_cell_reselect_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.presence_bitmask = RRM_ZERO;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.q_rx_lev_min = 

        p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_3;

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_P_MAX_SIB3_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.presence_bitmask |= 
            INTRA_FREQ_CELL_RESELECT_P_MAX_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.p_max = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.p_max_sib_3;
    }

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.bitmask & 
                RRMCM_RMIF_S_INTRA_SEARCH_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.presence_bitmask |= 
            INTRA_FREQ_CELL_RESELECT_INTRA_SEARCH_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.s_intra_search = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.s_intra_search;
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
        CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
        CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

    if(p_cell_context->operator_info.sib_3_info.
            intra_freq_reselection_info.bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.presence_bitmask |= 
            INTRA_FREQ_CELL_RESELECT_MEAS_BW_PRESENCE_FLAG;

        switch(p_cell_context->operator_info.sib_3_info.
                intra_freq_reselection_info.measurement_bandwidth)
        {
            case RRM_OAM_BW_MEAS_N_6:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_6;
                break;

            case RRM_OAM_BW_MEAS_N_15:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_15;
                break;

            case RRM_OAM_BW_MEAS_N_25:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_25;
                break;

            case RRM_OAM_BW_MEAS_N_50:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_50;
                break;

            case RRM_OAM_BW_MEAS_N_75:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_75;
                break;

            case RRM_OAM_BW_MEAS_N_100:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_100;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = 
                    p_cell_context->operator_info.sib_3_info.
                    intra_freq_reselection_info.measurement_bandwidth;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "invalid value for measurement_bandwidth: %d",
                        p_cell_context->operator_info.sib_3_info.
                        intra_freq_reselection_info.measurement_bandwidth);
                ret_val = RRM_FAILURE;
        }

    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.presence_antenna_port_1 = 
        p_cell_context->operator_info.sib_3_info.intra_freq_reselection_info.presence_antenna_port1;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.neigh_cell_config = 
        p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.neigh_cell_config;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.t_reselec_eutra = 
        p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.t_reselection_eutra;

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.bitmask & 
                RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.presence_bitmask |= 
            INTRA_FREQ_CELL_RESELECT_EUTRAN_SF_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.t_reselect_eutra_sf.sf_medium = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.t_reselect_eutra_sf.sf_high = 
            p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high;
    }

    #ifdef LTE_EMBMS_SUPPORTED
    if (MBMS_SIB_3_SCHEDULE_BROADCAST & 
        p_cell_context->rrm_cell_embms_data.mbms_broadcast_status)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
            intra_freq_cell_reselect_info.neigh_cell_config =
            p_cell_context->rrm_cell_embms_data.neigh_cell_config;
    }

    #endif
    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_intra_freq_cell_reselect_info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_intra_freq_cell_reselect_info_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
        intra_freq_cell_reselect_info.presence_bitmask = RRM_ZERO;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.q_rx_lev_min = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_3;

    if(p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_P_MAX_SIB3_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.presence_bitmask |= INTRA_FREQ_CELL_RESELECT_P_MAX_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.p_max = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.p_max_sib_3;
    }

    if(p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_S_INTRA_SEARCH_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.presence_bitmask |= INTRA_FREQ_CELL_RESELECT_INTRA_SEARCH_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.s_intra_search = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.s_intra_search;
    }

    if(p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.cell_reselection_info.bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.presence_bitmask |= INTRA_FREQ_CELL_RESELECT_MEAS_BW_PRESENCE_FLAG;

        switch(p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.cell_reselection_info.measurement_bandwidth)
        {
            case RRM_OAM_BW_MEAS_N_6:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_6;
                break;

            case RRM_OAM_BW_MEAS_N_15:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_15;
                break;

            case RRM_OAM_BW_MEAS_N_25:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_25;
                break;

            case RRM_OAM_BW_MEAS_N_50:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_50;
                break;

            case RRM_OAM_BW_MEAS_N_75:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_75;
                break;

            case RRM_OAM_BW_MEAS_N_100:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = RRM_RRC_M_BW_100;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.
                    intra_freq_cell_reselect_info.measure_bw = 
                    p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.cell_reselection_info.measurement_bandwidth;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "invalid value for measurement_bandwidth: %d",
                        p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.cell_reselection_info.measurement_bandwidth);
                ret_val = RRM_FAILURE;
                break;
        }
    }

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.presence_antenna_port_1 = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.cell_reselection_info.presence_antenna_port1;

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.neigh_cell_config = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.neigh_cell_config;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.t_reselec_eutra = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.t_reselection_eutra;

    if (p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.bitmask & RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.presence_bitmask |= INTRA_FREQ_CELL_RESELECT_EUTRAN_SF_PRESENCE_FLAG ;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.t_reselect_eutra_sf.sf_medium = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_medium;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_3_Info.intra_freq_cell_reselect_info.t_reselect_eutra_sf.sf_high = p_cell_context->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params.speed_scale_factors.t_reselection_eutra_sf_high;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_4_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 4 params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_4_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
        CELL_RECONFIG_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
        CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask = RRM_ZERO;

    /*spr 6450 start*/
    /*In this function neigh cell info in cell reconfig data is being populated
      from cell context, not from p_new_reconfig_data which is wrong.
      Neigh cell in sib4 will be populated from p_new_reconfig_data in function
      update_reconf_intra_freq_neigh_black_cell_list  */
    /*spr 6450 end*/

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_4_INFO_PRESENT)
    {
        //DONE
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= 
            SIB_4_PHY_CELL_ID_PRESENCE_FLAG;
        map_reconf_csg_phy_cell_id_range(p_cell_context,p_rrc_rrm_cell_reconfig_req);
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_intra_freq_neigh_black_cell_list
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig intra freq neigh black cell list coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_intra_freq_neigh_black_cell_list
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    U8 valid_cells = RRM_ZERO;
    U8 cell_count = RRM_ZERO;
    U8 neigh_count = RRM_ZERO;
    U8 black_count = RRM_ZERO;

    /*bitmask checking done*/
    RRM_UT_TRACE_ENTER();

    valid_cells = p_cell_context->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell;

    for(cell_count=0; cell_count < valid_cells; cell_count++)

    {
        /* BUG_371 FIX START */
        if ( p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].broadcast_status == RRM_TRUE )
        {
            /* BUG_371 FIX END */
            if(p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].blacklisted == RRM_FALSE)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    intra_freq_neigh_cell_list.neigh_cell[neigh_count].q_offset_cell = 
                    p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].q_offset;

                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    intra_freq_neigh_cell_list.neigh_cell[neigh_count].phys_cell_id = 
                    p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id;

                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= 
                    SIB_4_NEIGH_CELL_LIST_PRESENCE_FLAG;
                neigh_count++;
            }
            else if(p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].blacklisted == RRM_TRUE)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    intra_freq_black_listed_cell_list.black_listed_cell[black_count].start = 
                    p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id;

                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |= 
                    SIB_4_BLACK_LIST_LIST_PRESENCE_FLAG;
                black_count++;
                /* BUG_371 FIX START */
            }
            /* BUG_371 FIX END */
        }
    }
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_neigh_cell_list.count = neigh_count;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.count = black_count;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_csg_phy_cell_id_range
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig csg phy cell id range coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_csg_phy_cell_id_range
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.csg_phy_cell_id_range.presence_bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.csg_phy_cell_id_range.start = 
        p_cell_context->operator_info.sib_4_info.csg_id_range.start;

    if(p_cell_context->operator_info.sib_4_info.csg_id_range.bitmask & RRMCM_RMIF_CELL_ID_RANGE_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
            csg_phy_cell_id_range.presence_bitmask |= PHY_CELL_ID_RANGE ;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
            csg_phy_cell_id_range.range = 
            p_cell_context->operator_info.sib_4_info.csg_id_range.range;
        //no. of elements in enum are not same. need to recheck
        switch(p_cell_context->operator_info.sib_4_info.csg_id_range.range)
        {
            case RRM_OAM_N4:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_4;
                break;

            case RRM_OAM_N8:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_8;
                break;

            case RRM_OAM_N12:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_12;
                break;

            case RRM_OAM_N16:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_16;
                break;

            case RRM_OAM_N24:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_24;
                break;

            case RRM_OAM_N32:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_32;
                break;

            case RRM_OAM_N48:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_48;
                break;

            case RRM_OAM_N64:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_64;
                break;

            case RRM_OAM_N84:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_84;
                break;

            case RRM_OAM_N96:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_96;
                break;

            case RRM_OAM_N128:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_128;
                break;

            case RRM_OAM_N168:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_168;
                break;

            case RRM_OAM_N252:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_252;
                break;

            case RRM_OAM_N504:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = RRM_RRC_RANGE_PCI_N_504;
                break;

            default:
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.
                    csg_phy_cell_id_range.range = p_cell_context->operator_info.sib_4_info.
                    csg_id_range.range;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "invalid value for range: %d",
                        p_cell_context->operator_info.sib_4_info.
                        csg_id_range.range);
                ret_val = RRM_FAILURE;
        }

    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_5_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 8 info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_5_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /*SPR 6293 CODE CHANGES START*/
    map_sib_type_5(p_cell_context, &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info));
    /*SPR 6293 CODE CHANGES END*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_5_Info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_5_Info_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    U8 inter_freq_list, valid_inter_freq_list;
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.count = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list;

    valid_inter_freq_list = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list;

    for(inter_freq_list = RRM_ZERO; (inter_freq_list < valid_inter_freq_list) &&
            (inter_freq_list < MAX_NO_INTER_FREQ) && 
            (inter_freq_list < MAX_EUTRA_CARRIER_FREQ); ++inter_freq_list)
    {

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
            inter_freq_carrier_freq_list_list.
            inter_freq_carrier_freq_list[inter_freq_list].
            presence_bitmask = RRM_ZERO;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].eutra_dl_carrier_freq = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].eutra_carrier_arfcn; 
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].qrx_lev_min = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].q_rx_lev_min_sib_5;

        if(p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].bitmask & RRMCM_RMIF_P_MAX_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_CARR_P_MAX_PRESENCE_FLAG;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].p_max = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].p_max;
        }
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].t_reselection_eutran = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].t_reselection_eutra;

        if(p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].bitmask & RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_CARR_SCALE_PARAM_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].speed_depend_scal_params.sf_medium = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_medium;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].speed_depend_scal_params.sf_high = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].speed_scale_factors.t_reselection_eutra_sf_high;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].thresh_x_high = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].thresh_x_high;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].thresh_x_low = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].thresh_x_low;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].measurement_bandwidth = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.allowed_meas_bandwidth;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_antenna_port_1 =  p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.presence_antenna_port1;

        if(p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].bitmask &  RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_CARR_CELL_RESELCT_PRIOR_PRESENCE_FLAG;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].cell_reselect_priority = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].cell_reselection_priority;
        }

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].neigh_cell_config = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].neigh_cell_config;	

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].q_offset_freq = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].q_offset_freq;

        if(p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].q_qual_min_r9 = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.q_qual_min_r9;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_CARR_Q_QUAL_MIN_R9_PRESENCE_FLAG;
        }

        if(p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.bitmask & RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].thresh_x_q_r9.thresh_x_high_q_r9 = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.threshx_q_r9.thresh_serving_highq_r9;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].thresh_x_q_r9.thresh_x_low_q_r9 = p_cell_context->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params[inter_freq_list].inter_freq_params_op_specific.threshx_q_r9.thresh_serving_lowq_r9;

            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list].presence_bitmask |= INTER_FREQ_THRESH_X_Q_R9_PRESENCE_FLAG;
        }

        /* If req is for Obj removal and some corresponding nbrs were removed */
        if((RRM_TRUE == p_cell_context->p_meas_config_sib_info_for_reconfig->req_for_obj_remove) &&
                (RRM_PNULL != p_cell_context->p_ncl_built_from_updated_nrt_info) )
            /* Start: Enh 317 */
            //            (RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED & p_cell_context->updated_nrt_bitmask)) 
            /* End: Enh 317 */
        {
            map_sib_type_5_ncl_params(&p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                    inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list],
                    &p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl);

        }
        /* If req is NOT for Obj removal or LTE NCL was not changed */
        else if(RRM_NULL < p_cell_context->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell)
        {
            map_sib_type_5_ncl_params(&p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.
                    inter_freq_carrier_freq_list_list.inter_freq_carrier_freq_list[inter_freq_list],
                    &p_cell_context->ran_info.ncl_params.lte_ncl);
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TDD Support SON Start */

/*klock_works_changes_start*/

void map_carrier_freq_list_utra_fdd_list
(
 idle_mode_mobility_irat_utra_params_t *p_idle_mode_mobility_irat_utra_params,
 sib_type_6_Info_t                     *p_sib_type_6_info
 ) 
{   
    U8 index = RRM_ZERO ;
    RRM_UT_TRACE_ENTER();

    if ( RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT & 
            p_idle_mode_mobility_irat_utra_params->bitmask )
    {
        p_sib_type_6_info->presence_bitmask |= 
            SIB_6_CARRIER_FREQ_LIST_UTRA_FDD_PRESENCE_FLAG ;

        /*Filling Utran_FDD_list */
        p_sib_type_6_info->carrier_freq_list_utra_fdd.count =
            p_idle_mode_mobility_irat_utra_params->
            irat_eutran_to_utran_fdd_list.
            num_irat_eutran_to_utran_fdd_carriers;

        /* Fix for SPR 12929 Start */
        /* Start fix for Coverity_ID: 66958 */
        for(index = RRM_ZERO;(index < p_sib_type_6_info->carrier_freq_list_utra_fdd.count
                    && index < RRM_MAX_NUM_UTRA_FDD_CARRIERS ); index++)
            /* End fix for Coverity_ID: 66958 */
            /* Fix for SPR 12929 End */
        {
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask = RRM_ZERO;
            /*arfcn_freq*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].carrier_freq=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].utra_carrier_arfcn;

            /*q_rx_lev_min*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].q_rx_lev_min=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].q_rx_lev_min;

            /*q_qual_min*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].q_qual_min=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].q_qual_min;

            /* cell_reselection_priority*/
            if(RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT &
                    p_idle_mode_mobility_irat_utra_params->
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].bitmask)
            {
                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask |= 
                    CR_FREQ_UTRA_FDD_CELL_RESEL_PRI_PRESENCE_FLAG;

                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                    cell_reselection_priority =
                    p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].cell_reselection_priority;
            }

            /* thresh_x_high*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].thresh_x_high=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].thresh_x_high;

            /*thresh_x_low*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].thresh_x_low=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].thresh_x_low;

            /*p_max_utra*/
            p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].p_max_utra=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].p_max_utra;

            /* threshx_q_r9*/
            if(RRMCM_RMIF_THRESHX_Q_R9_PRESENT & 
                    p_idle_mode_mobility_irat_utra_params->
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].bitmask)
            {
                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].presence_bitmask |= 
                    CR_FREQ_UTRA_FDD_THRESH_X_Q_R9_PRESENCE_FLAG;

                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                    thresh_x_q_r9.thresh_x_high_q_r9=
                    p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].threshx_q_r9.
                    thresh_serving_highq_r9;

                p_sib_type_6_info->carrier_freq_list_utra_fdd.data[index].
                    thresh_x_q_r9.thresh_x_low_q_r9=
                    p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[index].threshx_q_r9.
                    thresh_serving_lowq_r9;
            }

        }
    }
    RRM_UT_TRACE_EXIT();
}   

rrm_return_et
map_irat_eutra_to_utra_reselection_params
(
 idle_mode_mobility_irat_utra_params_t *p_idle_mode_mobility_irat_utra_params,
 sib_type_6_Info_t                     *p_sib_type_6_info
 )
{ 
    rrm_return_et  ret_val  = RRM_SUCCESS; 
    RRM_UT_TRACE_ENTER();

    /* Filling t_resel_utra*/
    p_sib_type_6_info->t_resel_utra=
        p_idle_mode_mobility_irat_utra_params->
        irat_eutra_to_utra_reselection_params.t_reselection_utra;
    if ( RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT &
            p_idle_mode_mobility_irat_utra_params->
            irat_eutra_to_utra_reselection_params.bitmask
       )
    {
        p_sib_type_6_info->presence_bitmask |= 
            SIB_6_T_RESELECTION_UTRA_SF_PRESENCE_FLAG;

        switch(p_idle_mode_mobility_irat_utra_params->
                irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_6_info->t_resel_utra_sf.sf_medium =
                    p_idle_mode_mobility_irat_utra_params->
                    irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                    t_reselection_eutra_sf_medium;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_medium= %d",
                        p_idle_mode_mobility_irat_utra_params->
                        irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;

                break;
        }
        switch(p_idle_mode_mobility_irat_utra_params->
                irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_6_info->t_resel_utra_sf.sf_high = 
                    p_idle_mode_mobility_irat_utra_params->
                    irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                    t_reselection_eutra_sf_high;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_high= %d",
                        p_idle_mode_mobility_irat_utra_params->
                        irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*klock_works_changes_end*/
/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_6_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 6 info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_6_Info
(
 idle_mode_mobility_irat_utra_params_t *p_idle_mode_mobility_irat_utra_params,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                   ret_val                  = RRM_SUCCESS;
    U8                              index                    = RRM_ZERO;
    sib_type_6_Info_t               *p_sib_type_6_info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_sib_type_6_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_6_Info);

    p_sib_type_6_info->presence_bitmask = RRM_ZERO;

    if ( RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT & 
            p_idle_mode_mobility_irat_utra_params->bitmask )
    {
        p_sib_type_6_info->presence_bitmask |= 
            SIB_6_CARRIER_FREQ_LIST_UTRA_TDD_PRESENCE_FLAG ;

        /*Filling Utran_TDD_list */
        p_sib_type_6_info->carrier_freq_list_utra_tdd.count =
            p_idle_mode_mobility_irat_utra_params->
            irat_eutran_to_utran_tdd_list.
            num_irat_eutran_to_utran_tdd_carriers;

        /* Fix for SPR 12929 Start */

        /* Start fix for Coverity_ID: 67020 */
        for(index = RRM_ZERO;(index < p_sib_type_6_info->carrier_freq_list_utra_tdd.count
                    && index < RRM_MAX_NUM_UTRA_TDD_CARRIERS ); index++)
            /* End fix for Coverity_ID: 67020 */
            /* Fix for SPR 12929 End */
        {
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask = RRM_ZERO;
            /*arfcn_freq*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].carrier_freq=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].utra_carrier_arfcn;

            /*q_rx_lev_min*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].q_rx_lev_min=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].q_rx_lev_min;

            /* cell_reselection_priority*/
            if(RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT &
                    p_idle_mode_mobility_irat_utra_params->
                    irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[index].bitmask)
            {
                p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].presence_bitmask |= 
                    CR_FREQ_UTRA_FDD_CELL_RESEL_PRI_PRESENCE_FLAG;

                p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].
                    cell_reselection_priority =
                    p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[index].cell_reselection_priority;
            }

            /* thresh_x_high*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].thresh_x_high=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].thresh_x_high;

            /*thresh_x_low*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].thresh_x_low=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].thresh_x_low;

            /*p_max_utra*/
            p_sib_type_6_info->carrier_freq_list_utra_tdd.data[index].p_max_utra=
                p_idle_mode_mobility_irat_utra_params->irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].p_max_utra;
        }
    }


    /*klock_works_changes_start*/

    map_carrier_freq_list_utra_fdd_list(p_idle_mode_mobility_irat_utra_params, p_sib_type_6_info); 
    ret_val = map_irat_eutra_to_utra_reselection_params(p_idle_mode_mobility_irat_utra_params, p_sib_type_6_info);

    /*klock_works_changes_end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TDD Support SON End */



/****************************************************************************
 *   FUNCTION NAME : map_reconf_sib_type_7_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *           This function Maps the cell setup sib type 7 info params coming from MIF to RRC
 *
 *   RETURNS :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_7_Info
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                   ret_val                  = RRM_SUCCESS;
    U8                              index                    = RRM_ZERO;
    U8                              exp_arfcn_index          = RRM_ZERO;
    U8                              var_bitmap_index         = RRM_ZERO;

    sib_type_7_Info_t               *p_sib_type_7_info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_sib_type_7_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.\
            sib_type_7_Info);

    idle_mode_mobility_irat_geran_params_t  *p_idle_mode_mob_geran = RRM_PNULL;

    p_idle_mode_mob_geran = &(p_cell_context->ran_info.mobility_params.\
            idle_mode_mobility_params.\
            idle_mode_mobility_irat_geran_params);   

    p_sib_type_7_info->presence_bitmask = RRM_ZERO;

    if (RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT &\
            p_idle_mode_mob_geran->bitmask )
    {
        p_sib_type_7_info->presence_bitmask |=\
                                              SIB_7_CR_FREQS_INFO_LST_PRESENCE_FLAG;

        p_sib_type_7_info->carrier_freqs_info_lst.\
            count = p_idle_mode_mob_geran->\
            irat_eutran_to_geran_list.\
            num_irat_eutran_to_geran_carriers;    

        for(index = RRM_ZERO;(index < p_sib_type_7_info->carrier_freqs_info_lst.count
                    && p_sib_type_7_info->carrier_freqs_info_lst.count
                    <= MAX_NO_GERAN_FREQ_GROUUP); index++)
        {
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.\
                presence_bitmask = RRM_ZERO;

            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.ncc_permitted[RRM_ZERO] = p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].ncc_permitted;

            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.q_rx_lev_min =\
                p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].q_rx_lev_min;

            /* cell_reselection_priority*/
            if(RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                    common_info.presence_bitmask |=\
                    CRFI_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                    common_info.cell_reselection_priority =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    cell_reselection_priority;
            }

            if(RRMCM_GERAN_P_MAX_GERAN_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].\
                    common_info.presence_bitmask |=\
                    CRFI_GERAN_P_MAX_GERAN_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].\
                    common_info.p_max_geran = p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].p_max_geran;
            }

            /* thresh_x_high */                            
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.thresh_x_high = p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].threshX_high;

            /* thresh_x_high */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                common_info.thresh_x_low = p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].threshX_low;

            /* geran_carrier_freqs */

            /* starting_arfcn */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].\
                carrier_freqs.starting_arfcn =\
                p_idle_mode_mob_geran->\
                irat_eutran_to_geran_list.\
                irat_eutran_to_geran_carriers[index].\
                geran_car_freqs.starting_arfcn;

            /* band_indicator */
            switch(p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.band_ind)
            {
                case RRM_SON_GERAN_DCS_1800:
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].\
                        carrier_freqs.band_indicator =\
                        RRM_RRC_DCS_1800;
                    break;
                case RRM_SON_GERAN_PCS_1900:
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].\
                        carrier_freqs.band_indicator =\
                        RRM_RRC_PCS_1900;
                    break;
                default:
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].\
                        carrier_freqs.band_indicator =\
                        p_idle_mode_mob_geran->\
                        irat_eutran_to_geran_list.\
                        irat_eutran_to_geran_carriers[index].\
                        geran_car_freqs.band_ind;
                    break;
            }   

            /* explicit_list_of_arfcns */            
            p_sib_type_7_info->carrier_freqs_info_lst.\
                cr_freq_info[index].carrier_freqs.\
                following_arfcns.presence_bitmask = RRM_ZERO;

            if (RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs. following_arfcns.bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.presence_bitmask |=\
                    GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.explicit_list_of_arfcns.count =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.exp_arfcn_list_size;

                for (exp_arfcn_index = RRM_ZERO;
                        exp_arfcn_index < MAX_EXPL_ARFCNS;
                        exp_arfcn_index++)
                {
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].carrier_freqs.\
                        following_arfcns.explicit_list_of_arfcns.\
                        data[exp_arfcn_index] =\
                        p_idle_mode_mob_geran->\
                        irat_eutran_to_geran_list.\
                        irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                        following_arfcns.exp_arfcn_list[exp_arfcn_index];
                }
            }

            /* equally_spaced_arfcns */
            if (RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.presence_bitmask |=\
                    GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.equally_spaced_arfcns.arfcn_spacing =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.arfcn_spacing;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.equally_spaced_arfcns.\
                    num_of_following_arfcns =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.num_of_following_arfcn;
            }

            /* var_bitmap_of_arfcns */
            if (RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT &\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.bitmask)
            {
                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.presence_bitmask |=\
                    GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;

                p_sib_type_7_info->carrier_freqs_info_lst.\
                    cr_freq_info[index].carrier_freqs.\
                    following_arfcns.var_bitmap_of_arfcns.count =\
                    p_idle_mode_mob_geran->\
                    irat_eutran_to_geran_list.\
                    irat_eutran_to_geran_carriers[index].\
                    geran_car_freqs.following_arfcns.arfcn_bmp_list_size;

                for(var_bitmap_index = RRM_ZERO;
                        var_bitmap_index < MAX_VAR_BITMAP_OF_ARFCNS;
                        var_bitmap_index++)
                {
                    p_sib_type_7_info->carrier_freqs_info_lst.\
                        cr_freq_info[index].carrier_freqs.\
                        following_arfcns.var_bitmap_of_arfcns.\
                        data[var_bitmap_index] =\
                        p_idle_mode_mob_geran->\
                        irat_eutran_to_geran_list.\
                        irat_eutran_to_geran_carriers[index].\
                        geran_car_freqs.following_arfcns.arfcn_bmp_list[var_bitmap_index];
                }    
            }
        }
    }

    p_sib_type_7_info->t_reselection_geran = 
        p_idle_mode_mob_geran->\
        irat_eutra_to_geran_reselection_params.t_reselection_geran;

    if ( RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT &\
            p_idle_mode_mob_geran->\
            irat_eutra_to_geran_reselection_params.bitmask
       )
    {
        p_sib_type_7_info->presence_bitmask |=\
                                              SIB_7_T_RESEL_GERAN_SF_PRESENCE_FLAG;

        switch(
                p_idle_mode_mob_geran->\
                irat_eutra_to_geran_reselection_params.\
                speed_state_scale_factor.\
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =\
                                                                  p_idle_mode_mob_geran->\
                                                                  irat_eutra_to_geran_reselection_params.\
                                                                  speed_state_scale_factor.\
                                                                  t_reselection_eutra_sf_medium;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_WARNING, "Incorrect reslection eutra sf_medium= %d",
                        p_idle_mode_mob_geran->\
                        irat_eutra_to_geran_reselection_params.\
                        speed_state_scale_factor.\
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;
                break;
        }

        switch(p_idle_mode_mob_geran->\
                irat_eutra_to_geran_reselection_params.\
                speed_state_scale_factor.\
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high =\
                                                                p_idle_mode_mob_geran->\
                                                                irat_eutra_to_geran_reselection_params.\
                                                                speed_state_scale_factor.\
                                                                t_reselection_eutra_sf_high;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_WARNING, "Incorrect reslection eutra sf_high= %d",
                        p_idle_mode_mob_geran->\
                        irat_eutra_to_geran_reselection_params.speed_state_scale_factor.\
                        t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_start*/
rrm_return_et
map_csfb_support_for_dual_rx_ues_r9
(
 rrmcm_idle_mode_mobility_irat_cdma_params_t *p_idle_mode_mobility_irat_cdma,
 sib_type_8_Info_t                           *p_sib_type_8_Info
 )
{ 
    rrm_return_et     ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG)
    {
        switch(p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9)
        {
            case RRM_FALSE:
                {
                    p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_FALSE;
                    break;
                }
            case RRM_TRUE:
                {
                    p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_TRUE;
                    break;
                }
            default:
                p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 =
                    p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Invalid Value received for Sib-8:csfb_support_for_dual_rx_ues_r9 %d",
                        p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9);
        }
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG;
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG)
    {
        map_ac_barring_config_1_xrtt_r9(
                &(p_idle_mode_mobility_irat_cdma->ac_barring_config_1_xrtt_r9),
                &(p_sib_type_8_Info->ac_barring_config_1_xrtt_r9));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 : ac_barring_config_1_xrtt_r9");
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}    
/*klock_works_changes_end*/

/* Fix for reconfig 27/06/2013 */

/****************************************************************************
 *   FUNCTION NAME : map_reconf_sib_type_8_Info
 *
 *   DESCRIPTION :
 *           This function Maps the cell setup params coming from MIF to RRC
 *
 *   RETURNS :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 ****************************************************************************/
rrm_return_et
map_reconf_sib_type_8_Info
(
 rrm_cell_context_t *p_cell_context,
 /* Start 7514 NRT Fix - SIB 8 */
 ncl_params_t            *p_ncl_params,
 /* End 7514 NRT Fix - SIB 8 */
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{

    rrm_return_et     ret_val = RRM_SUCCESS;
    rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_idle_mode_mobility_irat_cdma = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    sib_type_8_Info_t               *p_sib_type_8_Info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.\
            sib_type_8_Info);


    p_idle_mode_mobility_irat_cdma = &(p_cell_context->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params);

    p_sib_type_8_Info->presence_bitmask = RRM_ZERO;

    /* No need to fill sys_time_info */
    p_sib_type_8_Info->sys_time_info.presence_bitmask = RRM_ZERO;
    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_SEARCH_WIN_SIZE_PRESENCE_FLAG)
    {
        p_sib_type_8_Info->search_window_size =
            p_idle_mode_mobility_irat_cdma->search_window_size;
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_SEARCH_WIN_SIZE_PRESENCE_FLAG;
    }

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT) ||
            /* Start 7514 NRT Fix - SIB 8 */
            ((p_ncl_params->bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT) &&
             p_ncl_params->inter_rat_ncl.num_valid_cdma2000_freq_cells > RRM_ZERO))
    {
        map_params_cdma2000_hrpd_1xrtt(p_cell_context, p_ncl_params, p_sib_type_8_Info);
        /* End 7514 NRT Fix - SIB 8 */
    }

    /*klock_works_changes_start*/

    ret_val=map_csfb_support_for_dual_rx_ues_r9(p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info); 

    /*klock_works_changes_end*/

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG)
    {
        switch(p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920)
        {
            case RRM_RRC_POWER_DOWN_REG_R9_TRUE_8:
                p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                    RRM_RRC_POWER_DOWN_REG_R9_TRUE_8;
                break;
            default :
                p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                    p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Wrong Value received for csfb_registration_param_1xrtt_v920 : %d",
                        p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920);
        }
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_CSFB_REG_PARAM_1_XRTT_R9_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 :csfb_registration_param_1xrtt_v920");
    }

    RRM_UT_TRACE_EXIT();
    /*coverity 23135:type of ret_val changed to rrm_return_et: ,rel 1.3*/
    return ret_val;

}
/* Fix end for reconfig 27/06/2013 */


/* TDD Support SON Delete */

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_7_Info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_7_Info_for_son
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                   ret_val                  = RRM_SUCCESS;
    U8                              index                    = RRM_ZERO;
    sib_type_7_Info_t               *p_sib_type_7_info       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_sib_type_7_info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_7_Info);

    p_sib_type_7_info->presence_bitmask = RRM_ZERO;

    if (RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT & 
            p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.bitmask)
    {
        p_sib_type_7_info->presence_bitmask |= 
            SIB_7_CR_FREQS_INFO_LST_PRESENCE_FLAG;

        /* Fill GERAN list */
        p_sib_type_7_info->carrier_freqs_info_lst.count =
            p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers;

        for(index = RRM_ZERO;(index < p_sib_type_7_info->carrier_freqs_info_lst.count 
                    && index < MAX_GNFG); index++)
        {
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.presence_bitmask = RRM_ZERO;
            /* Fill mandatory parameters */
            /* NCC permitted */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.ncc_permitted[RRM_ZERO] =
                p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].ncc_permitted;
            /* q_rx_lev_min */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.q_rx_lev_min =
                p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].q_rx_lev_min;
            /* thresh_x_high */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.thresh_x_high =
                p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].threshX_high;
            /* thresh_x_low */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.thresh_x_low =
                p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].threshX_low;
            if (p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].bitmask & RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT)
            {
                /* cell_reselection_priority */
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.cell_reselection_priority =
                    p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].cell_reselection_priority;
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.presence_bitmask |=
                    CRFI_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG;
            }
            if (p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].bitmask & RRMCM_GERAN_P_MAX_GERAN_PRESENT)
            {
                /* p_max_geran */
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.p_max_geran =
                    p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].p_max_geran;
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].common_info.presence_bitmask |=
                    CRFI_GERAN_P_MAX_GERAN_PRESENCE_FLAG;
            }
            /* starting_arfcn */
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.starting_arfcn =
                p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.starting_arfcn;
            /* band_indicator */    
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.band_indicator =
                p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.band_ind;
            /* following_arfcns */    
            p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.presence_bitmask = RRM_ZERO;    
            if (p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.bitmask & RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT)
            {
                /* explicit_list_of_arfcns */
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.presence_bitmask |=
                    GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.explicit_list_of_arfcns.count = p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.exp_arfcn_list_size;
                rrm_memcpy_u16(p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.explicit_list_of_arfcns.data, p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.exp_arfcn_list, MAX_EXPL_ARFCNS); 
            }

            if (p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.bitmask & RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT)
            {
                /* equally_spaced_arfcns */
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.presence_bitmask |=
                    GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;
                /* arfcn_spacing */   
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.equally_spaced_arfcns.arfcn_spacing = p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.arfcn_spacing;
                /* num_of_following_arfcns */   
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.equally_spaced_arfcns.num_of_following_arfcns = p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.num_of_following_arfcn;
            }

            if (p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.bitmask & RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT)
            {
                /* var_bitmap_of_arfcns */
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.presence_bitmask |=
                    GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;
                p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.var_bitmap_of_arfcns.count = p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.arfcn_bmp_list_size;
                rrm_memcpy_u8(p_sib_type_7_info->carrier_freqs_info_lst.cr_freq_info[index].carrier_freqs.following_arfcns.var_bitmap_of_arfcns.data, p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[index].geran_car_freqs.following_arfcns.arfcn_bmp_list, MAX_VAR_BITMAP_OF_ARFCNS); 
            }
        }
    }

    /* Filling t_resel_geran */
    p_sib_type_7_info->t_reselection_geran =
        p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
        idle_mode_mobility_irat_geran_params.
        irat_eutra_to_geran_reselection_params.t_reselection_geran;

    if (RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT &
            p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params. 
            idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.bitmask
       )
    {
        p_sib_type_7_info->presence_bitmask |= 
            SIB_7_T_RESEL_GERAN_SF_PRESENCE_FLAG;

        switch(p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.
                irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_medium =
                    p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
                    idle_mode_mobility_irat_geran_params.
                    irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
                    t_reselection_eutra_sf_medium;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_medium = %d",
                        p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
                        idle_mode_mobility_irat_geran_params.
                        irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_medium);
                ret_val = RRM_FAILURE;
                break;
        }

        switch(p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.
                irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = RRM_OAM_l_DOT_0;
                break;
            default:
                p_sib_type_7_info->t_reselect_geran_sf.sf_high = 
                    p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
                    idle_mode_mobility_irat_geran_params.
                    irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
                    t_reselection_eutra_sf_high;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_WARNING, "Incorrect reslection eutra sf_high = %d",
                        p_cell_context->p_meas_config_sib_info_for_reconfig->geran_params.
                        idle_mode_mobility_irat_geran_params.
                        irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
                        t_reselection_eutra_sf_high);
                ret_val = RRM_FAILURE;
                break;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 *   FUNCTION NAME   : map_reconf_sib_type_8_Info_for_son_cdma
 *   INPUT       : p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info
 *   OUTPUT      : None 

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 8 params coming from SON to RRC
 *      for cdma
 *   RETURNS     : None
 *****************************************************************************/
rrm_void_t
map_reconf_sib_type_8_Info_for_son_cdma(rrmcm_idle_mode_mobility_irat_cdma_params_t 
        *p_idle_mode_mobility_irat_cdma,
        sib_type_8_Info_t     *p_sib_type_8_Info)
{
    RRM_UT_TRACE_ENTER();
    switch(p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9)
    {
        case RRM_FALSE:
            {
                p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_FALSE;
                break;
            }
        case RRM_TRUE:
            {
                p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = RRM_TRUE;
                break;
            }
        default:
            p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 = 
                p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid Value received for Sib-8:csfb_support_for_dual_rx_ues_r9 %d", 
                    p_idle_mode_mobility_irat_cdma->csfb_support_for_dual_rx_ues_r9);
    }
    RRM_UT_TRACE_EXIT(); 
}
/****************************************************************************
 *   FUNCTION NAME   : map_reconf_sib_type_8_Info_for_son_cdma_v920
 *   INPUT       : p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info
 *   OUTPUT      : None

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 8 params coming from SON to RRC
 *      for cdma
 *   RETURNS     : None
 *****************************************************************************/
rrm_void_t
map_reconf_sib_type_8_Info_for_son_cdma_v920(rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_idle_mode_mobility_irat_cdma,
        sib_type_8_Info_t    *p_sib_type_8_Info)
{
    RRM_UT_TRACE_ENTER();    
    switch(p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920)
    {
        case RRM_RRC_POWER_DOWN_REG_R9_TRUE_8:
            p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                RRM_RRC_POWER_DOWN_REG_R9_TRUE_8;
            break;
        default :
            p_sib_type_8_Info->csfb_registration_param_1xrtt_v920 =
                p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Wrong Value received for csfb_registration_param_1xrtt_v920 : %d",
                    p_idle_mode_mobility_irat_cdma->csfb_registration_param_1xrtt_v920);
    }
    RRM_UT_TRACE_EXIT();    
}
/*Klockwork_fix_end*/

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_8_Info_for_son
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 8 params coming from SON to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_8_Info_for_son
(
 rrm_cell_context_t *p_cell_context,
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et                   ret_val                  = RRM_SUCCESS;
    sib_type_8_Info_t               *p_sib_type_8_Info       = RRM_PNULL;

    rrmcm_idle_mode_mobility_irat_cdma_params_t  
        *p_idle_mode_mobility_irat_cdma = RRM_PNULL;


    RRM_UT_TRACE_ENTER();

    p_sib_type_8_Info = &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_8_Info);

    p_idle_mode_mobility_irat_cdma = &(p_cell_context->p_meas_config_sib_info_for_reconfig->
            cdma_params.idle_mode_mobility_irat_cdma_params);

    p_sib_type_8_Info->presence_bitmask = RRM_ZERO;

    /* No need to fill sys_time_info */
    p_sib_type_8_Info->sys_time_info.presence_bitmask = RRM_ZERO;

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_SEARCH_WIN_SIZE_PRESENCE_FLAG)
    {
        p_sib_type_8_Info->search_window_size = 
            p_idle_mode_mobility_irat_cdma->search_window_size;
        p_sib_type_8_Info->presence_bitmask |= 
            SIB_8_SEARCH_WIN_SIZE_PRESENCE_FLAG;
    }

    if((p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
                bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT) ||
            (p_cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT))
    {
        rrm_son_map_params_cdma2000_hrpd_1xrtt(p_cell_context, p_sib_type_8_Info);
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG)
    {
        /*Klockwork_fix_start*/
        map_reconf_sib_type_8_Info_for_son_cdma(p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info);
        /*Klockwork_fix_end*/
        p_sib_type_8_Info->presence_bitmask |= 
            SIB_8_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG;
    }

    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG)
    {
        map_ac_barring_config_1_xrtt_r9(
                &(p_idle_mode_mobility_irat_cdma->ac_barring_config_1_xrtt_r9), 
                &(p_sib_type_8_Info->ac_barring_config_1_xrtt_r9));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 : ac_barring_config_1_xrtt_r9");
        p_sib_type_8_Info->presence_bitmask |=
            SIB_8_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG;
    }
    if(p_idle_mode_mobility_irat_cdma->presence_bitmask &
            RRMCM_RMIF_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG)
    {
        /*Klockwork_fix_start*/
        map_reconf_sib_type_8_Info_for_son_cdma_v920(p_idle_mode_mobility_irat_cdma, p_sib_type_8_Info);
        /*Klockwork_fix_end*/
        p_sib_type_8_Info->presence_bitmask |= 
            SIB_8_CSFB_REG_PARAM_1_XRTT_R9_PRESENCE_FLAG;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Setting Bitmask for Sib-8 :csfb_registration_param_1xrtt_v920");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}






/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sib_type_9_Info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sib type 9 info params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sib_type_9_Info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    U8 hnb_count=0;

    if(p_cell_context->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_SIB_9_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.size_of_hnb_id = 
            p_cell_context->access_mgmt_params.hnb_name_size;

        /*setting bitmask*/
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.presence_bitmask = RRM_ZERO;
        p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.presence_bitmask |= SIB_9_HNB_ID_PRESENCE_FLAG;

        for(hnb_count=0; hnb_count < p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.size_of_hnb_id; hnb_count++)
        {
            p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_9_Info.hnb_id[hnb_count] = 
                p_cell_context->access_mgmt_params.hnb_name[hnb_count];
        }

    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_non_broadcast_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig non broadcast info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_non_broadcast_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask = RRM_ZERO;

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT)  ||
            (p_cell_context->operator_info.bitmask & 
             RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT))
    {
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_CELL_PARAMETER_INFO_PRESENCE_FLAG;
        //DONE
        map_reconf_cell_parameters(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    }

    if(p_cell_context->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SYNC_SIGNAL_INFO_PRESENCE_FLAG;
        map_reconf_sync_signals(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
    }
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
        CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG;
    mac_reconfig(p_cell_context, 
            &(p_rrc_rrm_cell_reconfig_req->non_broadcast_info.mac_reconfig_params));

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_cell_parameters
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig cell params coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_cell_parameters
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.dl_earfcn = 
        p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
        RRC_RRM_RECONFIG_PHY_CELL_PARAMS_DL_EARFCN_PRESENT;

    switch(p_cell_context->ran_info.antenna_info.
            antenna_ports_count_number)
    {
        case ANTENNA_PORTS_COUNT_AN1:
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
                cell_parameters.num_of_antennas = ANTENNA_PORTS_COUNT_AN1; //1;
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
                RRC_RRM_RECONFIG_PHY_CELL_PARAMS_NUM_OF_ANTENNAS;
            break;

        case ANTENNA_PORTS_COUNT_AN2:
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
                cell_parameters.num_of_antennas = ANTENNA_PORTS_COUNT_AN2; //2;
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
                RRC_RRM_RECONFIG_PHY_CELL_PARAMS_NUM_OF_ANTENNAS;
            break;

        case ANTENNA_PORTS_COUNT_AN4:
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
                cell_parameters.num_of_antennas = ANTENNA_PORTS_COUNT_AN4; //4;
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
                RRC_RRM_RECONFIG_PHY_CELL_PARAMS_NUM_OF_ANTENNAS;
            break;

        default:
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.
                cell_parameters.num_of_antennas = ANTENNA_PORTS_COUNT_AN1; //1;
            p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
                RRC_RRM_RECONFIG_PHY_CELL_PARAMS_NUM_OF_ANTENNAS;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"for spare value \
                    assigning number of antennas as 1");
            ret_val = RRM_FAILURE;
    }

    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
        CELL_RECONFIG_REQ_API_CELL_PARAMETER_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
        CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;

    if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT)
    {
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.dl_cyclic_prefix = 
            p_cell_context->operator_info.cell_params.dl_cyclic_prefix;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.rb_size = 
            p_cell_context->operator_info.cell_params.rb_size;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
            RRC_RRM_RECONFIG_PHY_CELL_PARAMS_DL_CYCLIC_PREFIX;
        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
            RRC_RRM_RECONFIG_PHY_CELL_PARAMS_RB_SIZE;

        p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= CELL_RECONFIG_REQ_API_CELL_PARAMETER_INFO_PRESENCE_FLAG;
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;
    }

    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.phys_cell_id = 
        p_cell_context->ran_info.rf_params.rf_configurations.phy_cell_id;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
        RRC_RRM_RECONFIG_PHY_CELL_ID;

    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.max_rs_epre =  
        p_cell_context->operator_info.cell_params.max_rs_epre;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.cell_parameters.bitmask |= 
        RRC_RRM_RECONFIG_PHY_CELL_MAX_RS_EPRE_PRESENT;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.presence_bitmask |= 
        CELL_RECONFIG_REQ_API_CELL_PARAMETER_INFO_PRESENCE_FLAG;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
        CELL_RECONFIG_REQ_API_NON_BROADCAST_INFO_PRESENCE_FLAG;

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_sync_signals
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps the cell reconfig sync signals coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_sync_signals
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req
 )
{
    U16 pci;
    U8 n1_count = RRM_ZERO, n2_count = RRM_ZERO, flag = RRM_FALSE;
    U8 pci_values_m1_m2[RRM_MAX_M1_VALUES][RRM_MAX_M2_VALUES] = { {0, 1}/* 0 */, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6},
        {6, 7}, {7, 8}, {8, 9}, {9, 10}, {10, 11}/* 10 */, 
        {11, 12}, {12, 13}, {13, 14}, {14, 15}, {15, 16},
        {16, 17}, {17, 18}, {18, 19}, {19, 20}, {20, 21}/* 20 */, 
        {21, 22}, {22, 23}, {23, 24}, {24, 25}, {25, 26}, 
        {26, 27}, {27, 28}, {28, 29}, {29, 30},	{0, 2}/* 30 */, 
        {1, 3}, {2, 4}, {3, 5}, {4, 6}, {5, 7}, {6, 8}, 
        {7, 9}, {8, 10}, {9, 11}, {10, 12}/* 40 */, 
        {11, 13}, {12, 14}, {13, 15}, {14, 16}, {15, 17},
        {16, 18}, {17, 19}, {18, 20}, {19, 21}, {20, 22}/* 50 */, 
        {21, 23}, {22, 24}, {23, 25}, {24, 26}, {25, 27}, 
        {26, 28}, {27, 29}, {28, 30}, {0, 3}, {1, 4}/* 60 */, 
        {2, 5}, {3, 6}, {4, 7}, {5, 8}, {6, 9}, {7, 10}, 
        {8, 11}, {9, 12}, {10, 13}, {11, 14}/* 70 */, 
        {12, 15}, {13, 16}, {14, 17}, {15, 18}, {16, 19}, 
        {17, 20}, {18, 21}, {19, 22}, {20, 23}, {21, 24}/* 80 */, 
        {22, 25}, {23, 26}, {24, 27}, {25, 28}, {26, 29}, 
        {27, 30}, {0, 4}, {1, 5}, {2, 6}, {3, 7}/* 90 */, 
        {4, 8}, {5, 9}, {6, 10}, {7, 11}, {8, 12}, {9, 13}, 
        {10, 14}, {11, 15}, {12, 16}, {13, 17}/* 100 */, 
        {14, 18}, {15, 19}, {16, 20}, {17, 21}, {18, 22}, 
        {19, 23}, {20, 24}, {21, 25}, {22, 26},	{23, 27}/* 110 */, 
        {24, 28}, {25, 29}, {26, 30}, {0, 5}, {1, 6}, 
        {2, 7}, {3, 8}, {4, 9}, {5, 10}, {6, 11}/* 120 */, 
        {7, 12}, {8, 13}, {9, 14}, {10, 15}, {11, 16}, 
        {12, 17}, {13, 18}, {14, 19}, {15, 20},	{16, 21}/* 130 */, 
        {17, 22}, {18, 23}, {19, 24}, {20, 25}, {21, 26}, 
        {22, 27}, {23, 28}, {24, 29}, {25, 30},	{0, 6}/* 140 */, 
        {1, 7}, {2, 8}, {3, 9}, {4, 10}, {5, 11}, {6, 12}, 
        {7, 13}, {8, 14}, {9, 15}, {10, 16}/* 150 */, 
        {11, 17}, {12, 18}, {13, 19}, {14, 20}, {15, 21}, 
        {16, 22}, {17, 23}, {18, 24}, {19, 25},	{20, 26}/* 160 */, 
        {21, 27}, {22, 28}, {23, 29}, {24, 30}, {0, 7}, {1, 8}, 
        {2, 9} };

    RRM_UT_TRACE_ENTER();

    /* SPR 5014 start */
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.prim_syn_signal_power = 
        (p_cell_context->ran_info.rf_params.rf_configurations.psch_power_offset)/10;
    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.sec_syn_signal_power = 
        (p_cell_context->ran_info.rf_params.rf_configurations.ssch_power_offset)/10;
    /* SPR 5014 end */

    pci = p_cell_context->ran_info.rf_params.rf_configurations.phy_cell_id;

    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
    if(RRM_MAX_PCI_VALUE > pci)
    {
        /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/
        for(n1_count=RRM_ZERO; n1_count<RRM_MAX_N1; n1_count++)	/* value of N1 can be 0,1,2 */
        {
            for(n2_count=RRM_ZERO; n2_count<RRM_MAX_N2; n2_count++)	/*value of N2 can be 0 to 167*/
            {
                if(pci == (RRM_THREE * n1_count + n2_count))
                {
                    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.sec_syn_signal_m_seq1 = pci_values_m1_m2[n2_count][RRM_ZERO];
                    p_rrc_rrm_cell_reconfig_req->non_broadcast_info.sync_signals.sec_syn_signal_m_seq2 = pci_values_m1_m2[n2_count][RRM_ONE];
                    flag = RRM_TRUE;
                    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
                    break;
                    /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/
                }
            }
            if(RRM_TRUE == flag)
            {
                break;
            }
        }	
    }
    /*LTE_RRM_KLOCWORK_WARN_19_JULY_START*/
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Wrong Value of Phy Cell Id received");
    }
    /*LTE_RRM_KLOCWORK_WARN_19_JULY_END*/

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 *   FUNCTION NAME       :   build_send_rrc_del_req
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_del_req

 *   DESCRIPTION :
 *      This function Fills the rrc_rrm_cell_del_req struct from cell_context
 *
 *   RETURNS     :
 *       
 *****************************************************************************/
rrm_return_et
build_send_rrc_del_req
(
 rrm_cell_context_t *p_cell_context
 )
{
    rrc_rrm_cell_del_req_t	rrc_rrm_cell_del_req;
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_del_req.cell_index = p_cell_context->cell_index;
    /* SPR 21369 Start */
    /* SPR 21632 Start */
    rrc_rrm_cell_del_req.bitmask = RRM_ZERO;
    if(RRMCM_RMIF_INSTANCE_RESET_FLAG_PRESENT & p_cell_context->bitmask)
    /* SPR 21632 End */
    {
        rrc_rrm_cell_del_req.bitmask |= RRC_RRM_INSTANCE_RESET_FLAG_PRESENT;
    }
    else
    {
     rrc_rrm_cell_del_req.bitmask =RRM_ZERO;
    }     
    /* SPR 21369 End */
    /*Sending delete request to RRC
     */

    ret_val = rrm_il_send_rrc_rrm_cell_del_req (&rrc_rrm_cell_del_req,
            RRM_CM_MODULE_ID,
            RRC_MODULE_ID,
            p_cell_context->ongoing_trans_id,p_cell_context->cell_index);
    /* SPR 21251 +- */
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   build_send_start_req
 *   INPUT       : U16 transaction_id : transaction id
 *               : U8  cell_index : cell index
 *   OUTPUT      : p_rrc_rrm_cell_start_req

 *   DESCRIPTION :
 *      This function Fills the rrc_rrm_cell_start_req struct from cell_context
 *
 *   RETURNS     :
 *      
 *****************************************************************************/
rrm_return_et
build_send_start_req
(
// rrm_cell_context_t	*p_cell_context,
/* SPR 21660 changes start*/
 U16  transaction_id, 
 U8   cell_index,    
/* SPR 21660 changes end*/

 rrc_rrm_cell_start_req_t	*p_rrc_rrm_cell_start_req
 )
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_start_req->cell_index = cell_index;
    /*Sending start request to RRC
     */
    ret_val = rrm_il_send_rrc_rrm_cell_start_req (p_rrc_rrm_cell_start_req,
            RRM_CM_MODULE_ID,
            RRC_MODULE_ID,
            transaction_id, cell_index);
    if(ret_val == RRM_SUCCESS)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Send Cell Start Req To RRC For Cell index:%d",
                cell_index);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   build_send_stop_req
 *                            //fill_rrc_rrm_cell_stop_req
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_stop_req

 *   DESCRIPTION :
 *      This function Fills the rrc_rrm_cell_stop_req struct from cell_context
 *
 *   RETURNS     :
 *       
 *****************************************************************************/
rrm_return_et
build_send_stop_req
(
// rrm_cell_context_t  *p_cell_context,
/* SPR 21660 changes start_Shivani */
 U16  transaction_id,
 U8   cell_index,   
/* SPR 21660 changes end_Shivani */

 rrc_rrm_cell_stop_req_t	*p_rrc_rrm_cell_stop_req
 )
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_stop_req->cell_index = cell_index;

    /*Sending stop request to RRC
     */
    ret_val = rrm_il_send_rrc_rrm_cell_stop_req (p_rrc_rrm_cell_stop_req,
            RRM_CM_MODULE_ID,
            RRC_MODULE_ID,
            transaction_id, cell_index);
    if(ret_val== RRM_SUCCESS)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Send Cell Stop Req To RRC For Cell index:%d",
                cell_index);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*Cell update start*/
/****************************************************************************
 *   FUNCTION NAME       :  build_send_rrc_update_req
 *   INPUT       : p_cell_context
 *   OUTPUT      : 

 *   DESCRIPTION :
 *      This function internally sends cell reconfig request to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_send_rrc_update_req
(
 rrm_cell_context_t *p_cell_context
 )
{
    rrm_return_et    ret_val = RRM_FAILURE;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
    if ( p_cell_reconfig_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_cell_reconfig_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }


    /*Send request to RRC using reconfiguration API*/
    if (RRM_FAILURE == build_send_rrc_reconfig_req ( p_cell_context,
                p_cell_reconfig_req,
                CELL_UPDATE_PROC ))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed To Send Reconfig Req TO RRC For Cell Index :%d",
                p_cell_context->cell_index);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "successfully send reconfig req for cell :%d",
                p_cell_context->cell_index);
        ret_val = RRM_SUCCESS;
    }

    RRM_MEM_FREE(p_cell_reconfig_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Cell update end*/

/* UPDATED NRT INFO CHANGES START */ 

/* CSR 81662 : SPR 11861 Fix Start */
static rrm_bool_et 
rrm_check_if_pci_already_populated_in_sib_5(
        U16                                 pci,
        inter_freq_carrier_freq_t           *p_reconfig_inter_freq,
        U8                                  black_count,
        U8                                  neigh_count
        )
{
    rrm_bool_et      pci_already_populated = RRM_FALSE;
    U8               populated_nbr_index   = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Search PCI in populated Black-list nbr cells of SIB 5 */
    for(populated_nbr_index = RRM_ZERO; populated_nbr_index < black_count; populated_nbr_index++)
    {
        /* SPR 12424 fix start */
        if(pci == p_reconfig_inter_freq->inter_freq_black_listed_cell_list.
                black_listed_cell[populated_nbr_index].start)
            /* SPR 12424 fix end */
        {
            pci_already_populated = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "PCI = %d already populated in Black-list NCL in SIB 5 at index = %d",
                    pci, populated_nbr_index);
            break;
        }
    }
    if(RRM_FALSE == pci_already_populated)
    {
        /* If not found in Blaclisted NBR list, Search the PCI in populated NON-Black-list nbr cells of SIB 5 */
        for(populated_nbr_index = RRM_ZERO; populated_nbr_index < neigh_count; populated_nbr_index++)
        {
            /* SPR 12424 fix start */
            if(pci == p_reconfig_inter_freq->inter_freq_neigh_cell_list.
                    neigh_cell[populated_nbr_index].phys_cell_id)
                /* SPR 12424 fix end */
            {
                pci_already_populated = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "PCI = %d already populated in NCL in SIB 5 at index = %d",
                        pci, populated_nbr_index);
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return pci_already_populated;
}
/* CSR 81662 : SPR 11861 Fix End */


/****************************************************************************
 *   FUNCTION NAME       :   map_sib_type_5_ncl_params
 *   INPUT       : 
 *   OUTPUT      : p_reconfig_inter_freq

 *   DESCRIPTION :
 *      This function Maps the cell reconfig NCL params coming from updated
 *      NRT info to RRC
 *
 *   RETURNS     : None
 ******************************************************************************/
static rrm_void_t
map_sib_type_5_ncl_params(
        inter_freq_carrier_freq_t   *p_reconfig_inter_freq,
        lte_ncl_t           *p_lte_ncl)
{
    U8              inter_freq_list     = RRM_ZERO;
    U8              neigh_count         = RRM_ZERO;
    U8              black_count         = RRM_ZERO;
    /* CSR 81662 : SPR 11861 Fix Start */
    rrm_bool_et      pci_already_populated = RRM_FALSE;
    /* CSR 81662 : SPR 11861 Fix End */


    RRM_UT_TRACE_ENTER();

    for(inter_freq_list = RRM_ZERO; (inter_freq_list < p_lte_ncl->num_valid_inter_freq_cell) &&
            ((neigh_count < MAX_CELL_INTRA) || (black_count < MAX_CELL_BLACK_LIST)); inter_freq_list++)
    {
        if((p_lte_ncl->inter_freq_cells[inter_freq_list].eutra_carrier_arfcn == 
                    p_reconfig_inter_freq->eutra_dl_carrier_freq) &&
                (RRM_TRUE == p_lte_ncl->inter_freq_cells[inter_freq_list].broadcast_status))
        {
            /* CSR 81662 : SPR 11861 Fix Start */
            pci_already_populated = rrm_check_if_pci_already_populated_in_sib_5(
                    p_lte_ncl->inter_freq_cells[inter_freq_list].phy_cell_id,
                    p_reconfig_inter_freq, black_count, neigh_count);
            /* CSR 81662 : SPR 11861 Fix End */

            /* Nbr Cell */
            if(p_lte_ncl->inter_freq_cells[inter_freq_list].blacklisted == RRM_FALSE)
            {
                if(neigh_count < MAX_CELL_INTRA)
                {
                    /* CSR 81662 : SPR 11861 Fix Start */
                    if(RRM_FALSE == pci_already_populated)
                    {
                        /* CSR 81662 : SPR 11861 Fix End */
                        p_reconfig_inter_freq->inter_freq_neigh_cell_list.
                            neigh_cell[neigh_count].q_offset_cell =
                            p_lte_ncl->inter_freq_cells[inter_freq_list].q_offset;

                        p_reconfig_inter_freq->inter_freq_neigh_cell_list.
                            neigh_cell[neigh_count].phys_cell_id =
                            p_lte_ncl->inter_freq_cells[inter_freq_list].phy_cell_id;

                        neigh_count++;

                        p_reconfig_inter_freq->presence_bitmask |= 
                            INTER_FREQ_CARR_NEIGH_CELL_LIST_PRESENCE_FLAG;
                        /* CSR 81662 : SPR 11861 Fix Start */
                    }
                    /* CSR 81662 : SPR 11861 Fix End */
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Max Nbr cells added for Freq = %d. Can't broadcast pci = %d",
                            p_lte_ncl->inter_freq_cells[inter_freq_list].eutra_carrier_arfcn,
                            p_lte_ncl->inter_freq_cells[inter_freq_list].phy_cell_id);
                }
            }
            /* Blacklisted cell */
            else if(black_count < MAX_CELL_BLACK_LIST)
            {
                /* CSR 81662 : SPR 11861 Fix Start */
                if(RRM_FALSE == pci_already_populated)
                {
                    /* CSR 81662 : SPR 11861 Fix End */
                    p_reconfig_inter_freq->inter_freq_black_listed_cell_list.
                        black_listed_cell[black_count].presence_bitmask = RRM_ZERO;

                    p_reconfig_inter_freq->inter_freq_black_listed_cell_list.
                        black_listed_cell[black_count].start =
                        p_lte_ncl->inter_freq_cells[inter_freq_list].phy_cell_id;

                    black_count++;

                    p_reconfig_inter_freq->presence_bitmask |=
                        INTER_FREQ_CARR_BLACK_LIST_CELL_LIST_PRESENCE_FLAG;
                    /* CSR 81662 : SPR 11861 Fix Start */
                }
                /* CSR 81662 : SPR 11861 Fix End */
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Max Black listed cells added for Freq = %d. Can't broadcast pci = %d",
                        p_lte_ncl->inter_freq_cells[inter_freq_list].eutra_carrier_arfcn,        
                        p_lte_ncl->inter_freq_cells[inter_freq_list].phy_cell_id);
            }
        }
    }
    p_reconfig_inter_freq->inter_freq_neigh_cell_list.count = neigh_count;
    p_reconfig_inter_freq->inter_freq_black_listed_cell_list.count = black_count;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Freq = %d: Nbr cells count = %d, Black listed cells count = %d",
            p_reconfig_inter_freq->eutra_dl_carrier_freq, neigh_count, black_count);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       :  map_sib_type_5_Info_for_ncl 
 *   INPUT       : p_inter_freq_params,p_lte_ncl
 *   OUTPUT      : p_reconfig_inter_freq_list
 *   DESCRIPTION :
 *      This function Maps the cell reconfig SIB 5 Info params coming from updated
 *      NRT info to RRC
 *
 *   RETURNS     : None
 ******************************************************************************/
rrm_void_t
map_sib_type_5_Info_for_ncl(
        idle_mode_mobility_params_t             *p_inter_freq_params,
        inter_freq_carrier_freq_list_list_t     *p_reconfig_inter_freq_list,
        lte_ncl_t                               *p_lte_ncl
#ifdef LTE_EMBMS_SUPPORTED
        ,U8                                     *p_neigh_cell_config
#endif
        )
{
    U8              inter_freq_index    = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_reconfig_inter_freq_list->count = p_inter_freq_params->num_valid_inter_freq_list;

    for(inter_freq_index = RRM_ZERO; 
            inter_freq_index < p_inter_freq_params->num_valid_inter_freq_list;
            inter_freq_index++)
    {
        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].eutra_dl_carrier_freq = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].eutra_carrier_arfcn;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Processing Freq = %d", p_inter_freq_params->
                idle_mode_mobility_inter_freq_params[inter_freq_index].eutra_carrier_arfcn);

        map_sib_type_5_ncl_params(
                &p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index],
                p_lte_ncl);

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].qrx_lev_min = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].q_rx_lev_min_sib_5;

        if(p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].bitmask &  RRMCM_RMIF_P_MAX_PRESENT)
        {
            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].presence_bitmask |= 
                INTER_FREQ_CARR_P_MAX_PRESENCE_FLAG;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].p_max = 
                p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].p_max;
        }

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].t_reselection_eutran = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].t_reselection_eutra;

        if(p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].bitmask &  
                RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1)
        {
            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].presence_bitmask |= 
                INTER_FREQ_CARR_SCALE_PARAM_PRESENCE_FLAG;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].speed_depend_scal_params.sf_medium = 
                p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                speed_scale_factors.t_reselection_eutra_sf_medium;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].speed_depend_scal_params.sf_high = 
                p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                speed_scale_factors.t_reselection_eutra_sf_high;
        }

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].thresh_x_high = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].thresh_x_high;

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].thresh_x_low = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].thresh_x_low;

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].measurement_bandwidth = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
            inter_freq_params_op_specific.allowed_meas_bandwidth;

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].presence_antenna_port_1 = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
            inter_freq_params_op_specific.presence_antenna_port1;

        if(p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].bitmask &  
                RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].presence_bitmask |= 
                INTER_FREQ_CARR_CELL_RESELCT_PRIOR_PRESENCE_FLAG;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].cell_reselect_priority =
                p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].cell_reselection_priority;
        }

#ifndef LTE_EMBMS_SUPPORTED
        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].neigh_cell_config = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].neigh_cell_config;
#else

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].neigh_cell_config = 
            p_neigh_cell_config[inter_freq_index];

#endif

        p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].q_offset_freq = 
            p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].q_offset_freq;

        if(p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                inter_freq_params_op_specific.bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT)
        {
            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].presence_bitmask |= 
                INTER_FREQ_CARR_Q_QUAL_MIN_R9_PRESENCE_FLAG;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].q_qual_min_r9 =
                p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                inter_freq_params_op_specific.q_qual_min_r9;
        }
        if(p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                inter_freq_params_op_specific.bitmask & RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT)
        {
            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].presence_bitmask |= 
                INTER_FREQ_THRESH_X_Q_R9_PRESENCE_FLAG;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].thresh_x_q_r9.
                thresh_x_high_q_r9 = p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                inter_freq_params_op_specific.threshx_q_r9.thresh_serving_highq_r9;

            p_reconfig_inter_freq_list->inter_freq_carrier_freq_list[inter_freq_index].thresh_x_q_r9.
                thresh_x_low_q_r9 = p_inter_freq_params->idle_mode_mobility_inter_freq_params[inter_freq_index].
                inter_freq_params_op_specific.threshx_q_r9.thresh_serving_lowq_r9;
        }
    }

    RRM_UT_TRACE_EXIT();
}

/* CSR 81662 : SPR 11861 Fix Start */
static rrm_bool_et 
rrm_check_if_pci_already_populated_in_sib_4(
        U16                                 pci,
        sib_type_4_Info_t                   *p_sib_type_4_Info,
        U8                                  intra_freq_bl_cell_cnt,
        U8                                  intra_freq_cell_cnt
        )
{
    rrm_bool_et      pci_already_populated = RRM_FALSE;
    U8               populated_nbr_index   = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Search PCI in populated Black-list nbr cells of SIB 4 */
    for(populated_nbr_index = RRM_ZERO; populated_nbr_index < intra_freq_bl_cell_cnt; populated_nbr_index++)
    {
        if(pci == p_sib_type_4_Info->intra_freq_black_listed_cell_list.
                black_listed_cell[populated_nbr_index].start)
        {
            pci_already_populated = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "PCI = %d already populated in Black-list NCL in SIB 4 at index = %d",
                    pci, populated_nbr_index);
            break;
        }
    }
    if(RRM_FALSE == pci_already_populated)
    {
        /* If not found in Blaclisted NBR list, Search the PCI in populated NON-Black-list nbr cells of SIB 4 */
        for(populated_nbr_index = RRM_ZERO; populated_nbr_index < intra_freq_cell_cnt; populated_nbr_index++)
        {
            if(pci == p_sib_type_4_Info->intra_freq_neigh_cell_list.
                    neigh_cell[populated_nbr_index].phys_cell_id)
            {
                pci_already_populated = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "PCI = %d already populated in NCL in SIB 4 at index = %d",
                        pci, populated_nbr_index);
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return pci_already_populated;
}
/* CSR 81662 : SPR 11861 Fix End */

/****************************************************************************
 *   FUNCTION NAME       :   map_reconf_broadcast_info_for_nrt
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req
 *   DESCRIPTION :
 *      This function Maps the updated nrt info coming from MIF to RRC
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
map_reconf_broadcast_info_for_nrt
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
 U16 bit_mask
 )
{
    ncl_params_t *p_ncl_built_from_updated_nrt_info = RRM_PNULL;
    U8 cnt= RRM_ZERO;
    U8 intra_freq_bl_cell_cnt = RRM_ZERO; 
    U8 intra_freq_cell_cnt = RRM_ZERO;
    rrm_return_et    ret_val = RRM_SUCCESS;
    /* CSR 81662 : SPR 11861 Fix Start */
    rrm_bool_et      pci_already_populated = RRM_FALSE;
    /* CSR 81662 : SPR 11861 Fix End */

    RRM_UT_TRACE_ENTER();

    p_ncl_built_from_updated_nrt_info = (ncl_params_t *)p_cell_context->p_ncl_built_from_updated_nrt_info;

    p_rrc_rrm_cell_reconfig_req->cell_index = p_cell_context->cell_index;
    p_rrc_rrm_cell_reconfig_req->presence_bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask = RRM_ZERO;
    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask = RRM_ZERO;

    if(bit_mask & RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED)
    { 
        /*SPR 15525 Fix Start*/
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |=
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
        /*SPR 15525 Fix End*/
                                            
        if(p_ncl_built_from_updated_nrt_info->bitmask & RRMCM_RMIF_LTE_NCL_PRESENT)
        {
            /* Intra frequency neighbor & blacklisted cells updates in sib4 */ 
            for (cnt = RRM_ZERO, intra_freq_bl_cell_cnt = RRM_ZERO, intra_freq_cell_cnt = RRM_ZERO; 
                    cnt < p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell; ++cnt)
            {
                if((RRM_TRUE == p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].broadcast_status)
                        /* Bug_12689_fix: Start */
                        && (RRM_FALSE == p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].is_pci_conflict))
                    /* Bug_12689_fix: End */
                {
                    /* CSR 81662 : SPR 11861 Fix Start */
                    pci_already_populated = rrm_check_if_pci_already_populated_in_sib_4(
                            p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id,
                            &p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info,
                            intra_freq_bl_cell_cnt, intra_freq_cell_cnt);
                    /* CSR 81662 : SPR 11861 Fix End */

                    if (p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].blacklisted)
                    {
                        if(MAX_CELL_BLACK_LIST > intra_freq_bl_cell_cnt)
                        {
                            /* CSR 81662 : SPR 11861 Fix Start */
                            if(RRM_FALSE == pci_already_populated)
                            {
                                /* CSR 81662 : SPR 11861 Fix End */
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.
                                    black_listed_cell[intra_freq_bl_cell_cnt].presence_bitmask = RRM_ZERO;
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.
                                    black_listed_cell[intra_freq_bl_cell_cnt].start = 
                                    p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id;
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                        "Intra-Blacklisted nbr added to Reconfig req. PCI = %d",
                                        p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id);

                                ++intra_freq_bl_cell_cnt;
                                /* CSR 81662 : SPR 11861 Fix Start */
                            }
                            /* CSR 81662 : SPR 11861 Fix End */
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Max Nbr cells added for intra-freq. Can't broadcast pci = %d",
                                    p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id);
                        }
                    }
                    else
                    {
                        if(MAX_CELL_INTRA > intra_freq_cell_cnt)
                        {
                            /* CSR 81662 : SPR 11861 Fix Start */
                            if(RRM_FALSE == pci_already_populated)
                            {
                                /* CSR 81662 : SPR 11861 Fix End */
                                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_neigh_cell_list.
                                    neigh_cell[intra_freq_cell_cnt].phys_cell_id = 
                                    p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id;

                                if (p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].bitmask &
                                        RRMCM_RMIF_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT)
                                {
                                    p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_neigh_cell_list.
                                        neigh_cell[intra_freq_cell_cnt].q_offset_cell = 
                                        p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].q_offset;
                                }
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                        "Intra nbr added to Reconfig req. PCI = %d",
                                        p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id);
                                ++intra_freq_cell_cnt;
                                /* CSR 81662 : SPR 11861 Fix Start */
                            }
                            /* CSR 81662 : SPR 11861 Fix End */
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Max Blacklisted cells added for intra-freq. Can't broadcast pci = %d",
                                    p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id);
                        }
                    }
                }
                else
                {
                    /* Bug_12689_fix: Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Broadcast status = FALSE or PCI is conflicting with Serving Cell, for pci = %d. So not broadcasted",
                            p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[cnt].phy_cell_id);
                    /* Bug_12689_fix: End */
                }
            }
            if (intra_freq_cell_cnt)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |=
                    SIB_4_NEIGH_CELL_LIST_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_neigh_cell_list.count = 
                    intra_freq_cell_cnt;
            }
            if (intra_freq_bl_cell_cnt)
            {
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.presence_bitmask |=
                    SIB_4_BLACK_LIST_LIST_PRESENCE_FLAG;
                p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info.intra_freq_black_listed_cell_list.count = 
                    intra_freq_bl_cell_cnt;
            }
        }
        if (intra_freq_cell_cnt || intra_freq_bl_cell_cnt)
        {
            /*SPR 15525 Fix Start*/
            /*Lines deleted*/
            /*SPR 15525 Fix End*/
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                CELL_RECONFIG_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "No Intra-freq nbr found to be broadcasted");
        }
        if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_SIB_4_INFO_PRESENT)
        {
            csg_phy_cell_id_range_for_sib_4(p_cell_context, &p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_4_Info);
            p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
                CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;
            p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
                CELL_RECONFIG_REQ_API_SIB_4_INFO_PRESENCE_FLAG;
        }
    }
    if (bit_mask & RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED)  
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Populating SIB 5 for Reconfig");

        map_sib_type_5_Info_for_ncl(&p_cell_context->ran_info.mobility_params.idle_mode_mobility_params,
                &p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list,
                &p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl
#ifdef LTE_EMBMS_SUPPORTED
                ,p_cell_context->rrm_cell_embms_data.inter_cell_neigh_cell_config
#endif
                );

        /*SPR_18944_FIX_START*/
        if (p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_5_Info.inter_freq_carrier_freq_list_list.count > RRM_ZERO)
        {
        /*SPR_18944_FIX_END*/
        p_rrc_rrm_cell_reconfig_req->presence_bitmask |= 
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |= 
            CELL_RECONFIG_REQ_API_SIB_5_INFO_PRESENCE_FLAG;
        /*SPR_18944_FIX_START*/
        }
        /*SPR_18944_FIX_END*/
    }
    /* Start 7514 NRT Fix - SIB 8 */
    if (bit_mask & RRM_CDMA_NBRS_UPDATED)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Populating SIB 8 for Reconfig");

        map_reconf_sib_type_8_Info(p_cell_context, p_ncl_built_from_updated_nrt_info, p_rrc_rrm_cell_reconfig_req);

        p_rrc_rrm_cell_reconfig_req->presence_bitmask |=
            CELL_RECONFIG_REQ_API_BROADCAST_INFO_PRESENCE_FLAG;

        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |=
            CELL_RECONFIG_REQ_API_SIB_8_INFO_PRESENCE_FLAG;
    }
    /* End 7514 NRT Fix - SIB 8 */

    /*SPR 15525 Fix Start - If condition modified*/
    if(p_rrc_rrm_cell_reconfig_req->presence_bitmask)
    /*SPR 15525 Fix End*/    
    {
        map_sib_type_1_for_son(p_cell_context, p_rrc_rrm_cell_reconfig_req);
    }

#ifdef LTE_EMBMS_SUPPORTED
    if (MBMS_SIB_3_SCHEDULE_BROADCAST & p_cell_context->rrm_cell_embms_data.mbms_broadcast_status)
    {
        map_reconf_sib_type_3_Info(p_cell_context, p_rrc_rrm_cell_reconfig_req);
        p_rrc_rrm_cell_reconfig_req->broadcast_info.presence_bitmask |=
            CELL_RECONFIG_REQ_API_SIB_3_INFO_PRESENCE_FLAG;

    }
#endif
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :  build_send_rrc_reconfig_req_for_updated_nrt_info
 *   INPUT       : p_cell_context
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function Maps updated nrt info param coming from MIF to RRC 
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_send_rrc_reconfig_req_for_updated_nrt_info
(
 rrm_cell_context_t *p_cell_context, 
 rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
 U16 bit_mask
 )
{
    rrm_return_et    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_req->cell_index = p_cell_context->cell_index;
    ret_val = map_reconf_broadcast_info_for_nrt(p_cell_context, p_rrc_rrm_cell_reconfig_req, bit_mask);

    /*Sending reconfig request to RRC
     */
    if(RRM_SUCCESS == ret_val)
    {
	    /*SPR 17777 +-*/
	    update_collision_free_sib_scheduling_list_in_sib1_for_cell_reconfig(
			    p_cell_context->si_segment_data_sib_scheduling,
			    &(p_rrc_rrm_cell_reconfig_req->broadcast_info.sib_type_1_Info.scheduling_info_list));
	    /*DYNAMIC SIB SCHEDULING END*/
	    /*SPR_18944_FIX_START*/
	    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask != RRM_ZERO)
	    {
		    /*SPR_18944_FIX_END*/
		    ret_val = rrm_il_send_rrc_rrm_cell_reconfig_req (p_rrc_rrm_cell_reconfig_req,	
				    RRM_CM_MODULE_ID,
				    RRC_MODULE_ID,
				    p_cell_context->ongoing_trans_id,p_cell_context->cell_index);
	    }
	    if(ret_val == RRM_SUCCESS)
	    {
		    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				    "Send Cell Reconfig Req To RRC For Cell index:%d",
				    p_cell_context->cell_index);
	    }
	    /*SPR_18944_FIX_START*/
	    else
	    {
		    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
				    "Cell Reconfig Req not sent For Cell index:%d",
				    p_cell_context->cell_index);
		    ret_val = RRM_FAILURE;
	    }
    }
    /*SPR_18944_FIX_END*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* UPDATED NRT INFO CHANGES END */ 
/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_s1ap_rrm_pws_resp
 *   INPUT       : trans_id,p_slap_rrm_pws_response
 *   OUTPUT      : 

 *   DESCRIPTION :
 *      This function builds and sends s1ap_rrm_pws_resp 
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_and_send_s1ap_rrm_pws_resp(
        s1ap_rrm_pws_response_t *p_s1ap_rrm_pws_response,
        U8			trans_id
        )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    rrm_cell_index_t       cell_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if(!(p_s1ap_rrm_pws_response->bitmask & S1AP_RRM_PWS_CONTENTS_LIST_PRESENT))
    { 
        p_s1ap_rrm_pws_response->response = RRM_FAILURE;	
    }

    if(RRM_FAILURE == rrm_il_send_s1ap_rrm_pws_response(p_s1ap_rrm_pws_response, RRM_MODULE_ID,RRC_MODULE_ID, trans_id,cell_index))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Unable to compose message for PWS response");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_update_pws_list_resp
 *   INPUT       : trans_id,p_rrc_rrm_updated_pws_si_list_resp
 *   OUTPUT      : p_rrc_rrm_cell_reconfig_req

 *   DESCRIPTION :
 *      This function builds and sends update pws list response
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_and_send_update_pws_list_resp(
        rrc_rrm_updated_pws_si_list_resp_t *p_rrc_rrm_updated_pws_si_list_resp,
        U8			trans_id
        )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    rrm_cell_index_t  cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(RRM_FAILURE == rrm_il_send_rrc_rrm_updated_pws_si_list_resp(p_rrc_rrm_updated_pws_si_list_resp, RRM_MODULE_ID, RRC_MODULE_ID,trans_id,cell_index))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Unable to compose message for UPDATED PWS LIST response");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_s1ap_rrm_kill_resp
 *   INPUT       :p_s1ap_rrm_kill_response,trans_id
 *   DESCRIPTION :
 *      This function builds and sends s1ap_rrm_kill_resp
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
build_and_send_s1ap_rrm_kill_resp(
        s1ap_rrm_kill_response_t *p_s1ap_rrm_kill_response,
        U8			trans_id
        )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    rrm_cell_index_t  cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(RRM_FAILURE == rrm_il_send_s1ap_rrm_kill_response(p_s1ap_rrm_kill_response, RRM_MODULE_ID,RRC_MODULE_ID, trans_id,cell_index))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Unable to compose message for PWS response");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}



/****************************************************************************
 * Function Name  : rrm_fill_plmn_identity_for_enb_transfer
 * Inputs         : rrm_oam_cell_plmn_info_t *p_rrm_plmn_id
 *                : plmn_identity_t *p_enb_plmn_id
 * Outputs        : None
 * Returns        : None
 * Description    : This function convert the rrm_plmn_id_t to enb_plmn_id_t
 ****************************************************************************/

void
rrm_fill_plmn_identity_for_enb_transfer
(
 rrm_oam_cell_plmn_info_t *p_rrm_plmn_id,
 plmn_identity_t *p_enb_plmn_id
 )
{
    RRM_UT_TRACE_ENTER();

    p_enb_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

    rrm_memcpy_u8((p_enb_plmn_id->mcc), (p_rrm_plmn_id->mcc),sizeof(p_rrm_plmn_id->mcc));

    p_enb_plmn_id->mnc.count = p_rrm_plmn_id->num_mnc_digit;
    rrm_memcpy_u8(((p_enb_plmn_id->mnc).mnc), (p_rrm_plmn_id->mnc), sizeof(p_rrm_plmn_id->mnc));

    RRM_UT_TRACE_EXIT();
}

/* Code for MLB Start */
/****************************************************************************
 *   FUNCTION NAME : rrm_fill_rrm_x2_gb_enb_id
 *   INPUT       : p_rrm_gb_enb_id
 *   OUTPUT      : p_x2_gb_enb_id
 *   DESCRIPTION :
 *          This function fills the rrm_fill_rrm_x2_gb_enb_id.
 *
 *   RETURNS     : none
 *****************************************************************************/

rrm_void_t rrm_fill_rrm_x2_gb_enb_id
(
 x2_gb_enb_id_t     *p_x2_gb_enb_id,
 rrm_x2_gb_enb_id_t *p_rrm_gb_enb_id
 )
{
    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(&p_rrm_gb_enb_id->plmn_identity,
            &p_x2_gb_enb_id->plmn_identity,
            sizeof(p_rrm_gb_enb_id->plmn_identity));

    p_rrm_gb_enb_id->enb_id.presence_bitmask = RRM_ZERO;
    if (S1AP_OAM_MACRO_ENB_ID_PRESENT & p_x2_gb_enb_id->enb_id.presence_bitmask)
    {
        p_rrm_gb_enb_id->enb_id.presence_bitmask |= X2AP_OAM_MACRO_ENB_ID_PRESENT;
        RRM_MEMCPY(p_rrm_gb_enb_id->enb_id.macro_enb_id.eNB_id, p_x2_gb_enb_id->enb_id.macro_enb_id.eNB_id,\
                sizeof (p_rrm_gb_enb_id->enb_id.macro_enb_id.eNB_id));
    }
    else if(S1AP_OAM_HOME_ENB_ID_PRESENT & p_x2_gb_enb_id->enb_id.presence_bitmask)
    {
        p_rrm_gb_enb_id->enb_id.presence_bitmask |= X2AP_OAM_HOME_ENB_ID_PRESENT;
        RRM_MEMCPY(p_rrm_gb_enb_id->enb_id.home_enb_id.eNB_id, p_x2_gb_enb_id->enb_id.home_enb_id.eNB_id,\
                sizeof (p_rrm_gb_enb_id->enb_id.home_enb_id.eNB_id));
    }

    RRM_UT_TRACE_EXIT();
    return;
}
/****************************************************************************
 *   FUNCTION NAME : rrm_fill_rrm_x2_gb_enb_id
 *   INPUT       : p_rrm_gb_enb_id
 *   OUTPUT      : p_x2_gb_enb_id
 *   DESCRIPTION :
 *          This function fills the rrm_fill_rrm_x2_gb_enb_id.
 *
 *   RETURNS     : none
 *****************************************************************************/

rrm_void_t rrm_fill_x2_gb_enb_id
(
 x2_gb_enb_id_t     *p_x2_gb_enb_id,
 rrm_x2_gb_enb_id_t *p_rrm_gb_enb_id
 )
{
    U8 index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /*BUG 680 FIX START*/
    for(index = RRM_ZERO ; index < MAX_PLMN_ID_BYTES ; index++)
    {
        p_x2_gb_enb_id->plmn_identity.plmn_id[index] = p_rrm_gb_enb_id->plmn_identity.plmn_id[index];
    }
    /*BUG 680 FIX END*/
    p_x2_gb_enb_id->enb_id.presence_bitmask = RRM_ZERO;
    if (S1AP_OAM_MACRO_ENB_ID_PRESENT & p_rrm_gb_enb_id->enb_id.presence_bitmask)
    {
        p_x2_gb_enb_id->enb_id.presence_bitmask |= X2AP_OAM_MACRO_ENB_ID_PRESENT;
        RRM_MEMCPY(p_x2_gb_enb_id->enb_id.macro_enb_id.eNB_id, p_rrm_gb_enb_id->enb_id.macro_enb_id.eNB_id,\
                sizeof (p_x2_gb_enb_id->enb_id.macro_enb_id.eNB_id));
    }
    else if(S1AP_OAM_HOME_ENB_ID_PRESENT & p_rrm_gb_enb_id->enb_id.presence_bitmask)
    {
        p_x2_gb_enb_id->enb_id.presence_bitmask |= X2AP_OAM_HOME_ENB_ID_PRESENT;
        RRM_MEMCPY(p_x2_gb_enb_id->enb_id.home_enb_id.eNB_id, p_rrm_gb_enb_id->enb_id.home_enb_id.eNB_id,\
                sizeof (p_x2_gb_enb_id->enb_id.home_enb_id.eNB_id));
    }

    RRM_UT_TRACE_EXIT();
    return;
}
/****************************************************************************
 *   FUNCTION NAME : rrm_fill_rrm_x2_gb_cid
 *   INPUT       : p_rrm_gb_enb_cid
 *   OUTPUT      : p_x2_gb_enb_cid
 *   DESCRIPTION :
 *          This function fills the rrm_fill_rrm_x2_gb_enb_cid.
 *
 *   RETURNS     : none
 *****************************************************************************/

rrm_void_t rrm_fill_x2_gb_cid
(
 rrm_cell_global_id_eutra_t  *p_x2_gb_cid,
 rrm_global_cell_id_t        *p_rrm_gb_cid)
{
    U8 i = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_x2_gb_cid->plmn_identity.presence_bitmask = PLMN_IDENTITY_MCC_PRESENCE_FLAG;

    RRM_MEMCPY(p_x2_gb_cid->plmn_identity.mcc,
            p_rrm_gb_cid->primary_plmn_id.mcc,
            sizeof(p_x2_gb_cid->plmn_identity.mcc));

    p_x2_gb_cid->plmn_identity.mnc.count = RRM_ZERO;
    for (i = RRM_ZERO;
            (i < p_rrm_gb_cid->primary_plmn_id.num_mnc_digit) && (p_x2_gb_cid->plmn_identity.mnc.count < MAX_MNC_OCTET_SIZE);
            i++)
    {
        p_x2_gb_cid->plmn_identity.mnc.mnc[p_x2_gb_cid->plmn_identity.mnc.count]
            = p_rrm_gb_cid->primary_plmn_id.mnc[i];
        p_x2_gb_cid->plmn_identity.mnc.count++;
    }

    RRM_MEMCPY(&p_x2_gb_cid->cell_identity,
            p_rrm_gb_cid->cell_identity,sizeof(p_x2_gb_cid->cell_identity));


    RRM_UT_TRACE_EXIT();
    return;
}
/****************************************************************************
 *   FUNCTION NAME : rrm_setbit
 *   INPUT       : p_bitmap,bit_pos
 *   OUTPUT      : p_x2_gb_enb_cid
 *   DESCRIPTION :
 *          This function sets the bit.
 *
 *   RETURNS     : none
 *****************************************************************************/

rrm_void_t rrm_setbit
(
 U8 *p_bitmap,
 U8 bit_pos
 )
{
    RRM_UT_TRACE_ENTER();
    p_bitmap[bit_pos/RRM_EIGHT] |= (RRM_ONE << (bit_pos % RRM_EIGHT));
    RRM_UT_TRACE_EXIT();
    return;
}

rrm_bool_et
rrm_is_bitset
(
 U8 *p_bitmap,
 U8 bit_pos
 )
{
    return ((p_bitmap[bit_pos/RRM_EIGHT] & (RRM_ONE << (bit_pos % RRM_EIGHT))) ? RRM_TRUE : RRM_FALSE);
}
/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_rrm_x2ap_rrm_rsu_start_req
 *   INPUT       : p_cell_info,report_characteristics,report_periodicity
 *   OUTPUT      : 
 *   DESCRIPTION :
 *      This function build and send rrm_x2ap_rrm_rsu_start_req msg to L3
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et build_and_send_rrm_x2ap_rrm_rsu_start_req
(
 rrm_meas_rpt_config_info_t *p_cell_info,
 U32 report_characteristics,
 U8 report_periodicity
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 cell_id = RRM_ZERO;
    rrm_global_context_t    *p_rrm_gbl_ctx;
    rrm_rsu_trans_info_node_t *p_trans_info = RRM_NULL;
    x2ap_rrm_rsu_rrm_start_req_t x2ap_rrm_rsu_rrm_start_req;
    /*BUG 680 FIX START*/
    U8 index = RRM_ZERO;
    /*BUG 680 FIX END */

    /*SPR 15994 Fix start*/
    rrm_bool_et is_node_inserted   = RRM_FALSE;
    /*SPR 15994 Fix stop*/


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_cell_info != RRM_PNULL);

    x2ap_rrm_rsu_rrm_start_req.report_characteristics = report_characteristics;
    x2ap_rrm_rsu_rrm_start_req.num_cell = RRM_ZERO;
    /*Rel10 CR 393 changes start*/
    x2ap_rrm_rsu_rrm_start_req.bitmask = RRM_ZERO;
    x2ap_rrm_rsu_rrm_start_req.bitmask |= RRM_RSU_START_PARTIAL_SUCC_IND_IS_PRESENT;
    x2ap_rrm_rsu_rrm_start_req.partial_success_indicator = RRM_ZERO;
    /*Rel10 CR 393 changes end*/

    switch (report_periodicity)
    {
        case RRM_RSU_REPORTING_PERIODICITY_1000MS:
            x2ap_rrm_rsu_rrm_start_req.report_periodicity = X2AP_RRM_RSU_REPORTING_PERIODICITY_1000MS;
            break;

        case RRM_RSU_REPORTING_PERIODICITY_2000MS:
            x2ap_rrm_rsu_rrm_start_req.report_periodicity = X2AP_RRM_RSU_REPORTING_PERIODICITY_2000MS;
            break;

        case RRM_RSU_REPORTING_PERIODICITY_5000MS:
            x2ap_rrm_rsu_rrm_start_req.report_periodicity = X2AP_RRM_RSU_REPORTING_PERIODICITY_5000MS;
            break;

        case RRM_RSU_REPORTING_PERIODICITY_10000MS:
            x2ap_rrm_rsu_rrm_start_req.report_periodicity = X2AP_RRM_RSU_REPORTING_PERIODICITY_10000MS;
            break;

        default:
            RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR,
                    "Invalid periodicity [%u] received for RSU start req",
                    report_periodicity);

            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
    }

    p_rrm_gbl_ctx = qvThisContext();


    for (cell_id = RRM_ZERO; cell_id < p_cell_info->num_cell; ++cell_id)
    {
        rrm_fill_plmn_identity_for_enb_transfer (&p_cell_info->cell_info[cell_id].global_cell_id.primary_plmn_id,
                &x2ap_rrm_rsu_rrm_start_req.cell_info[x2ap_rrm_rsu_rrm_start_req.num_cell].plmn_identity);

        /*BUG 680 FIX START*/
        for(index = RRM_ZERO ; index < MAX_CELL_IDENTITY_OCTETS ; index++)
        {
            x2ap_rrm_rsu_rrm_start_req.cell_info[x2ap_rrm_rsu_rrm_start_req.num_cell].cell_identity[index] = 						p_cell_info->cell_info[cell_id].global_cell_id.cell_identity[index];
        }
        /*BUG 680 FIX END*/


        x2ap_rrm_rsu_rrm_start_req.num_cell++;
        if (MAX_SERVED_CELLS == x2ap_rrm_rsu_rrm_start_req.num_cell)
        {
            p_trans_info = rrm_mem_get(sizeof(rrm_rsu_trans_info_node_t));
            if ( p_trans_info == RRM_PNULL)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Memory allocation to  p_trans_info failed" );
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }

            p_trans_info->cell_index = p_cell_info->cell_index;

            p_trans_info->trans_id = rrm_generate_txn_id();
            if (RRM_SUCCESS ==  rrm_il_send_x2ap_rrm_rsu_rrm_start_req (&x2ap_rrm_rsu_rrm_start_req,
                        RRM_MODULE_ID,
                        RRC_MODULE_ID,
                        p_trans_info->trans_id, p_cell_info->cell_index))
            {
                x2ap_rrm_rsu_rrm_start_req.num_cell = RRM_ZERO;
                ylPushTail(&p_rrm_gbl_ctx->rsu_trans_info_list, &p_trans_info->sNode);
                RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_BRIEF,
                        "Successfully sent batch for RSU start req, trxId[%u]",
                        p_trans_info->trans_id);
                ret_val = RRM_SUCCESS;
                /*SPR 15994 Fix start*/
                is_node_inserted = RRM_TRUE;
                /*SPR 15994 Fix stop*/
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR,
                        "Failed to send batch for RSU start req, trxId[%u]",
                        p_trans_info->trans_id);
                /* Coverity fix 54405 */
                RRM_MEM_FREE(p_trans_info);
            }
            x2ap_rrm_rsu_rrm_start_req.num_cell = RRM_ZERO;
        }
    }

    if (RRM_ZERO != (x2ap_rrm_rsu_rrm_start_req.num_cell%MAX_SERVED_CELLS))
    {
        p_trans_info = rrm_mem_get(sizeof(rrm_rsu_trans_info_node_t));
        if ( p_trans_info == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Memory allocation to  p_trans_info failed" );
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        p_trans_info->cell_index = p_cell_info->cell_index;

        p_trans_info->trans_id = rrm_generate_txn_id();
        if (RRM_SUCCESS == rrm_il_send_x2ap_rrm_rsu_rrm_start_req (&x2ap_rrm_rsu_rrm_start_req,
                    RRM_MODULE_ID,
                    RRC_MODULE_ID,
                    p_trans_info->trans_id, p_cell_info->cell_index))
        {
            ylPushTail(&p_rrm_gbl_ctx->rsu_trans_info_list, &p_trans_info->sNode);
            RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_BRIEF,
                    "Successfully sent RSU start req, trxId[%u]",
                    p_trans_info->trans_id);
            ret_val = RRM_SUCCESS;
            /*SPR 15994 Fix start*/
            is_node_inserted = RRM_TRUE;
            /*SPR 15994 Fix stop*/
        }
        else
        {
            RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR,
                    "Failed to send RSU start req, trxId[%u]",
                    p_trans_info->trans_id);
            ret_val = RRM_FAILURE;
        }
    }

    /*  SPR: 15922 Start */
    if((p_trans_info != RRM_PNULL) && 
        /*SPR 15994 Fix start*/
        (RRM_FALSE == is_node_inserted))
        /*SPR 15994 Fix stop*/
    {
        RRM_MEM_FREE(p_trans_info);
    }
    /*  SPR: 15922 End */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_rrm_x2ap_rrm_rsu_stop_req
 *   INPUT       : enb_meas_id,p_gb_enb_id
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_rsu_stop_req msg to L3
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et build_and_send_rrm_x2ap_rrm_rsu_stop_req
(
 U32 enb_meas_id,
 rrm_x2_gb_enb_id_t *p_gb_enb_id
 )
{
    U16 trans_id = RRM_NULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_rrm_stop_req_t x2ap_rrm_rsu_rrm_stop_req;
    rrm_cell_index_t     cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(p_gb_enb_id != RRM_PNULL);
    x2ap_rrm_rsu_rrm_stop_req.enb_meas_id = enb_meas_id;

    rrm_fill_x2_gb_enb_id(&x2ap_rrm_rsu_rrm_stop_req.peer_gb_enb_id, p_gb_enb_id);

    trans_id = rrm_generate_txn_id();
    if (RRM_SUCCESS != rrm_il_send_x2ap_rrm_rsu_rrm_stop_req (&x2ap_rrm_rsu_rrm_stop_req,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                trans_id,cell_index))
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed to send RS STOP REQ for meas Id[%u]", enb_meas_id);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Successfully sent RS STOP REQ for meas Id[%u]", enb_meas_id);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_rrm_x2ap_rrm_rsu_rrm_start_res
 *   INPUT       : enb_meas_id,p_gb_enb_id,resp,p_cause
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_rsu_rrm_start_resp msg to L3
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et build_and_send_rrm_x2ap_rrm_rsu_rrm_start_res
(
 U32 enb_meas_id,
 x2_gb_enb_id_t *p_gb_enb_id,
 rrm_return_et resp,
 x2ap_rrm_cause_t *p_cause,
 x2ap_rrm_rsu_measurement_res_t *p_rrm_rsu_measurement_res_list
 )
{
    U16 trans_id = RRM_NULL;
    rrm_cell_index_t  cell_index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_rrm_start_res_t x2ap_rrm_rsu_rrm_start_resp;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_gb_enb_id != RRM_PNULL);
    RRM_ASSERT(p_cause != RRM_PNULL);

    x2ap_rrm_rsu_rrm_start_resp.bitmask = RRM_ZERO;
    x2ap_rrm_rsu_rrm_start_resp.enb_meas_id = enb_meas_id;

    x2ap_rrm_rsu_rrm_start_resp.peer_gb_enb_id = *p_gb_enb_id;

    if (RRM_SUCCESS == resp)
    {
        x2ap_rrm_rsu_rrm_start_resp.response = RRM_SUCCESS; /* X2AP_SUCCESS;*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Sending RS START RESP for meas Id [%u]", enb_meas_id);
    }
    /*Rel10 CR 393 changes start*/
    else if (RRM_PARTIAL_SUCCESS == resp)
    {
        x2ap_rrm_rsu_rrm_start_resp.bitmask |= ENB_START_PARTIAL_SUCCESS;
        x2ap_rrm_rsu_rrm_start_resp.rrm_rsu_measurement_res_list =
            *p_rrm_rsu_measurement_res_list;
        x2ap_rrm_rsu_rrm_start_resp.response = RRM_SUCCESS; /* X2AP_SUCCESS;*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Sending Partial success RS START RESP for meas Id [%u]", enb_meas_id);
    }
    /*Rel10 CR 393 changes end*/
    else
    {
        x2ap_rrm_rsu_rrm_start_resp.bitmask |= RRM_START_RES_RRM_CAUSE_IS_PRESENT;
        x2ap_rrm_rsu_rrm_start_resp.response = RRM_FAILURE; /*X2AP_FAILURE;*/
        x2ap_rrm_rsu_rrm_start_resp.rrm_cause.type = p_cause->type;
        x2ap_rrm_rsu_rrm_start_resp.rrm_cause.value = p_cause->value;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Sending RS FAILURE for meas Id [%u],Cause[%u],type[%u]",
                enb_meas_id, p_cause->type, p_cause->value);
    }
    trans_id = rrm_generate_txn_id();
    if (RRM_SUCCESS != rrm_il_send_x2ap_rrm_rsu_rrm_start_res (&x2ap_rrm_rsu_rrm_start_resp,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                trans_id,cell_index))
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cannot send message for meas Id [%u]", enb_meas_id);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_rrm_x2ap_rrm_rsu_rrm_stop_req
 *   INPUT       : enb_meas_id,p_gb_enb_id
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_rsu_stop_req msg to L3
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et build_and_send_rrm_x2ap_rrm_rsu_rrm_stop_req 
(
 U32 enb_meas_id,
 rrm_x2_gb_enb_id_t *p_gb_enb_id
 )
{
    U16 trans_id = RRM_ZERO;
    rrm_cell_index_t                cell_index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_rrm_stop_req_t x2ap_rrm_rsu_rrm_stop_req;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_gb_enb_id != RRM_PNULL);

    x2ap_rrm_rsu_rrm_stop_req.enb_meas_id = enb_meas_id;
    rrm_fill_x2_gb_enb_id(&x2ap_rrm_rsu_rrm_stop_req.peer_gb_enb_id, p_gb_enb_id);

    trans_id = rrm_generate_txn_id();

    if (RRM_SUCCESS != (ret_val = rrm_il_send_x2ap_rrm_rsu_rrm_stop_req (&x2ap_rrm_rsu_rrm_stop_req,
                    RRM_MODULE_ID,
                    RRC_MODULE_ID,
                    trans_id,cell_index)))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed to send RS STOP REQ for trxId[%u]", trans_id);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Successfully sent RS STOP REQ for trxId[%u]", trans_id);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_rrm_x2ap_rrm_rsu_rrm_stop_res
 *   INPUT       : enb_meas_id,p_gb_enb_id,resp,p_cause
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_rsu_rrm_stop_resp msg to L3
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et build_and_send_rrm_x2ap_rrm_rsu_rrm_stop_res
(
 U32 enb_meas_id,
 x2_gb_enb_id_t *p_gb_enb_id,
 rrm_return_et resp,
 x2ap_rrm_cause_t *p_cause
 )
{
    U16 trans_id = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_rrm_stop_res_t x2ap_rrm_rsu_rrm_stop_resp;
    rrm_cell_index_t                cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_gb_enb_id != RRM_PNULL);
    RRM_ASSERT(p_cause != RRM_PNULL);

    x2ap_rrm_rsu_rrm_stop_resp.bitmask = RRM_ZERO;
    x2ap_rrm_rsu_rrm_stop_resp.enb_meas_id = enb_meas_id;

    x2ap_rrm_rsu_rrm_stop_resp.peer_gb_enb_id = *p_gb_enb_id;

    /* Fix start for 8012 */
    if (RRM_SUCCESS == resp)
    {
        x2ap_rrm_rsu_rrm_stop_resp.response = RRM_SUCCESS; /* X2AP_SUCCESS;*/
    }
    else
    {
        x2ap_rrm_rsu_rrm_stop_resp.bitmask |= RRM_START_RES_RRM_CAUSE_IS_PRESENT;
        x2ap_rrm_rsu_rrm_stop_resp.response = RRM_FAILURE; /* X2AP_FAILURE; */
        x2ap_rrm_rsu_rrm_stop_resp.rrm_cause.type = p_cause->type;
        x2ap_rrm_rsu_rrm_stop_resp.rrm_cause.value = p_cause->value;
    }
    /* Fix end for 8012 */

    trans_id = rrm_generate_txn_id();

    if (RRM_SUCCESS != rrm_il_send_x2ap_rrm_rsu_rrm_stop_res (&x2ap_rrm_rsu_rrm_stop_resp,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                trans_id,cell_index))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed to send RS STOP RESP for trxId[%u]", trans_id);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Successfully sent RS STOP RESP for trxId[%u]", trans_id);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :  build_and_send_rrm_x2ap_rrm_rsu_rrm_update
 *   INPUT       : p_x2ap_rrm_rsu_rrm_upd
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_rsu_rrm_update msg to L3
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/

rrm_return_et build_and_send_rrm_x2ap_rrm_rsu_rrm_update
(
 x2ap_rrm_rsu_rrm_update_t *p_x2ap_rrm_rsu_rrm_upd
 )
{
    U16 trans_id = RRM_ZERO;
    rrm_cell_index_t  cell_index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_x2ap_rrm_rsu_rrm_upd != RRM_PNULL);

    trans_id = rrm_generate_txn_id();

    if (RRM_SUCCESS != (ret_val = rrm_il_send_x2ap_rrm_rsu_rrm_update (p_x2ap_rrm_rsu_rrm_upd,
                    RRM_MODULE_ID,
                    RRC_MODULE_ID,
                    trans_id,cell_index)))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Successfully sent RS UPDATE for trxId[%u]", trans_id);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Successfully sent RS UPDATE for trxId[%u]", trans_id);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Code For MLB End */

/*IPv6 changes begin*/
/****************************************************************************
 *   FUNCTION NAME : rrm_build_and_send_enb_config_tranfer_resp
 *   INPUT         : p_mme_config_transfer, trans_id
 *   DESCRIPTION   : This function builds and sends the enb_config_transfer_resp
 to RRC.
 *
 *   RETURNS       :
 *                   RRM_SUCCESS     on Success.
 *                   RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et
rrm_build_and_send_enb_config_tranfer_resp
(
 s1ap_rrm_mme_config_transfer_t *p_mme_config_transfer,
 U16 trans_id
 )
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    s1ap_rrm_enb_config_transfer_t enb_config_transfer = {RRM_NULL};
    rrm_cell_index_t                cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if (RRM_PNULL == p_mme_config_transfer)
    {
        RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_ERROR,
                "rrm_build_and_send_enb_config_tranfer_resp: Could not "
                "send enb config resp,p_mme_config_transfer is NULL");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    enb_config_transfer.bitmask = ENB_CONFIGURATION_TRANSFER_RESP;
    enb_config_transfer.mme_id = p_mme_config_transfer->mme_id ;

    RRM_MEMCPY(&enb_config_transfer.gb_enb_id,
            &(p_mme_config_transfer->gb_enb_id),
            sizeof(rrm_gb_enb_id_t));

    RRM_MEMCPY(&enb_config_transfer.target_supp_ta,
            &(p_mme_config_transfer->source_supp_ta),
            sizeof(rrm_supp_ta_t));

    RRM_MEMCPY(&enb_config_transfer.source_supp_ta,
            &(p_mme_config_transfer->target_supp_ta),
            sizeof(rrm_supp_ta_t));

    ret_val = rrm_il_send_s1ap_rrm_enb_config_transfer(&enb_config_transfer,
            RRM_MODULE_ID,RRC_MODULE_ID,trans_id,cell_index );
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 *	FUNCTION NAME   : rrm_get_window_lenth_in_ms 
 *  INPUT		    : si_window_length  
 *  OUTPUT		    : p_si_window_length_in_ms
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function converts the si_window_length in terms of
 *                    miliseconds(subframes).
 *****************************************************************************/
rrm_void_t
rrm_get_window_lenth_in_ms
(
 rrm_si_window_length_et   si_window_length , 
  U8 *p_si_window_length_in_ms
 )
{
    switch(si_window_length)
    {
        case RRM_RRC_SI_WINDOW_LEN_MS_1:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_1_MS;
            break; 

        case RRM_RRC_SI_WINDOW_LEN_MS_2:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_2_MS;
            break;

        case RRM_RRC_SI_WINDOW_LEN_MS_5:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_5_MS;
            break;

        case RRM_RRC_SI_WINDOW_LEN_MS_10:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_10_MS;
            break;

        case RRM_RRC_SI_WINDOW_LEN_MS_15:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_15_MS;
            break;

        case RRM_RRC_SI_WINDOW_LEN_MS_20:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_20_MS;
            break;

        case RRM_RRC_SI_WINDOW_LEN_MS_40:
            *p_si_window_length_in_ms = RRM_SI_WINDOW_LEN_40_MS;
            break;

        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for si window length = %d",si_window_length);
            break;
    }
}
/****************************************************************************
 *	FUNCTION NAME   : rrm_get_rrm_rrc_si_window_length 
 *  INPUT		    : si_window_length_in_ms 
 *  OUTPUT		    : p_si_window_length
 *	RETURNS		    : None
 *	DESCRIPTION	    : This function converts the si_window_length in the form
 *                    required at RRM-RRC interface.
 *****************************************************************************/
rrm_void_t
rrm_get_rrm_rrc_si_window_length
(
  U8 si_window_length_in_ms ,
 rrm_si_window_length_et *p_si_window_length  
 )
{
    switch(si_window_length_in_ms)
    {
        case RRM_SI_WINDOW_LEN_1_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_1;
            break; 

        case RRM_SI_WINDOW_LEN_2_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_2;
            break;

        case RRM_SI_WINDOW_LEN_5_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_5;
            break;

        case RRM_SI_WINDOW_LEN_10_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_10;
            break;

        case RRM_SI_WINDOW_LEN_15_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_15;
            break;

        case RRM_SI_WINDOW_LEN_20_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_20;
            break;

        case RRM_SI_WINDOW_LEN_40_MS:
            *p_si_window_length = RRM_RRC_SI_WINDOW_LEN_MS_40;
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect value received for si window length = %d",si_window_length_in_ms);
            break;
    }
}

/*IPv6 changes end*/
/*RIM changes start*/
/****************************************************************************
 *   FUNCTION NAME       :   rrm_send_rim_req
 *   INPUT       : p_cell_context,p_rrm_rim_info_req
 *   OUTPUT      :
 *   DESCRIPTION :
 *      This function sends rim request
 *
 *   RETURNS     :
 *      
 *****************************************************************************/
rrm_return_et
rrm_send_rim_req
(
 rrm_cell_context_t  *p_cell_context,
 rim_information_req_t    *p_rrm_rim_info_req
 )
{
    U16 trans_id = RRM_ZERO;
    rrm_return_et  ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    trans_id = rrm_generate_txn_id();

    ret_val = rrm_il_send_rim_information_req(p_rrm_rim_info_req,
            RRM_CM_MODULE_ID,
            RRC_MODULE_ID,
            trans_id,p_cell_context->cell_index);
    if(ret_val== RRM_SUCCESS)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Send RIM info Req To RRC For Cell index:%d",
                p_cell_context->cell_index);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 *   FUNCTION NAME       :   rrm_send_rim_ack_to_l3
 *   INPUT       : p_cell_context,p_rrm_rim_info_ack
 *   OUTPUT      :
 *   DESCRIPTION :
 *      This function Fills the p_rrm_rim_info_ack struct from cell_context
 *
 *   RETURNS     :
 *      
 *****************************************************************************/
rrm_return_et
rrm_send_rim_ack_to_l3
(
 rrm_cell_context_t  *p_cell_context,
 rim_information_ack_t    *p_rrm_rim_info_ack
 )
{
    U16 trans_id = RRM_ZERO;
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    trans_id = rrm_generate_txn_id();

    /*Sending RIM ack to RRC
     */
    ret_val = rrm_il_send_rim_information_ack(p_rrm_rim_info_ack,
            RRM_CM_MODULE_ID,
            RRC_MODULE_ID,
            trans_id,p_cell_context->cell_index);
    if(ret_val== RRM_SUCCESS)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Send RIM ack To RRC For Cell index:%d",
                p_cell_context->cell_index);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*RIM changes end*/

/* DYNAMIC ICIC CHANGES START */

/****************************************************************************
 * Function Name  : rrm_fill_plmn_identity_for_enb_load_req
 * Inputs         : rrm_oam_cell_plmn_info_t *p_rrm_plmn_id
 *                : x2ap_plmn_identity_t     *p_enb_plmn_id
 * Outputs        : None
 * Returns        : None
 * Description    : This function convert the rrm_plmn_id_t to enb_plmn_id_t
 ****************************************************************************/

rrm_void_t
rrm_fill_plmn_identity_for_enb_load_req
(
 rrm_oam_cell_plmn_info_t *p_plmn_info,
 U8                       *p_enb_plmn_id
 )
{
    RRM_UT_TRACE_ENTER();

    p_enb_plmn_id[RRM_ZERO] = (U8)((U8)(p_plmn_info->mcc[RRM_ONE] << RRM_FOUR)| p_plmn_info->mcc[RRM_ZERO]);
    p_enb_plmn_id[RRM_ONE] = (U8)(p_plmn_info->mcc[RRM_TWO]);
    if (RRM_THREE == p_plmn_info->num_mnc_digit)
    {
        p_enb_plmn_id[RRM_ONE] = ((U8)(p_plmn_info->mnc[RRM_ZERO] << RRM_FOUR)| p_enb_plmn_id[RRM_ONE]);
        p_enb_plmn_id[RRM_TWO] = (U8)(((U8)(p_plmn_info->mnc[RRM_TWO] << RRM_FOUR))| p_plmn_info->mnc[RRM_ONE]);
    }
    else
    {
        p_enb_plmn_id[RRM_ONE] = (U8)((p_enb_plmn_id[RRM_ONE])|RRM_HIGH_NIBBLE);
        p_enb_plmn_id[RRM_TWO] = (U8)(((U8)(p_plmn_info->mnc[RRM_ONE] << RRM_FOUR))| p_plmn_info->mnc[RRM_ZERO]);
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       : build_and_send_x2ap_rrm_load_information_req 
 *   INPUT       : p_cell_context,num_cell,enodeb_type,p_eutran_global_cell_id
 *   OUTPUT      : 
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_load_information_req_t msg to L3
 *
 *   RETURNS     : None
 *****************************************************************************/

rrm_void_t build_and_send_x2ap_rrm_load_information_req 
(
 rrm_cell_context_t                 *p_cell_context,
 rrm_oam_eutran_global_cell_id_t    *p_eutran_global_cell_id,
 U16                                num_cell,
 rrm_enb_type_et                    enodeb_type
 )
{
    /* Coverity_fix_start_30715 */
    x2ap_rrm_load_information_req_t    *p_x2ap_rrm_load_info_req = RRM_PNULL;
    /* Coverity_fix_end_30715 */
    U8                                 cell_id = RRM_ZERO;
    U16                                cell_counter = RRM_ZERO;
    U16                                prb_count = RRM_ZERO;
    U16                                prb_configured_in_srv_cell = RRM_ZERO;
    /* SPR Fix 18895 Start */
    U8                                 serving_global_cell_id[HOME_ENB_ID_OCTET_SIZE] = {RRM_ZERO};
    /* SPR Fix 18895 End */
    U8                                 target_global_cell_id[HOME_ENB_ID_OCTET_SIZE] = {RRM_ZERO};
    U8                                 hii_prb_array[X2AP_RRM_LI_MAX_HII_PRB_OCTETS] = {RRM_ZERO};
    U8                                 start_rb = RRM_ZERO;
    U8                                 num_of_rb = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_cell_context != RRM_PNULL);
    RRM_ASSERT(p_eutran_global_cell_id != RRM_PNULL);
    /* SPR 21843 Fix Start */
    if(p_cell_context->icic_l1_l2_report_info.bitmask & RRM_CTXT_LOAD_REPORT_IND_PRESENT)
    {
        /* SPR 21843 Fix End */
        /* Coverity_fix_start_62560 */
        p_x2ap_rrm_load_info_req  = (x2ap_rrm_load_information_req_t *) rrm_mem_get (sizeof (x2ap_rrm_load_information_req_t));

        if (p_x2ap_rrm_load_info_req != RRM_PNULL)
        {
            RRM_MEMSET(p_x2ap_rrm_load_info_req, RRM_ZERO, sizeof(x2ap_rrm_load_information_req_t));

            switch(p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth)
            {
                case RRM_OAM_BW_N_6:
                prb_configured_in_srv_cell = PRB_COUNT_6;
                break;
                case RRM_OAM_BW_N_15:
                prb_configured_in_srv_cell = PRB_COUNT_15;
                break;
                case RRM_OAM_BW_N_25:
                prb_configured_in_srv_cell = PRB_COUNT_25;
                break;
                case RRM_OAM_BW_N_50:
                prb_configured_in_srv_cell = PRB_COUNT_50;
                break;
                case RRM_OAM_BW_N_75:
                prb_configured_in_srv_cell = PRB_COUNT_75;
                break;
                case RRM_OAM_BW_N_100:
                prb_configured_in_srv_cell = PRB_COUNT_100;
                break;
                default :
                prb_configured_in_srv_cell = PRB_COUNT_50;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for dl_bandwith = %u",
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth);
            }

            /* Filling up the PLMN Identity of eNB2*/
            rrm_fill_plmn_identity_for_enb_load_req (&p_eutran_global_cell_id[RRM_ZERO].primary_plmn_id,
                    (U8 *)&p_x2ap_rrm_load_info_req->gb_enb_id.plmn_identity.plmn_id);

            /* Filling up the Cell Identity of eNB2*/
            p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask = RRM_ZERO;
            if (enodeb_type == RRM_ENB_TYPE_MACRO)
            {
                RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id[RRM_ZERO].cell_identity,
                        sizeof(HOME_ENB_ID_OCTET_SIZE));
                target_global_cell_id[RRM_THREE] = RRM_ZERO;  /* Coverity CID 41381: '&=' replaced with simple '=' */
                target_global_cell_id[RRM_TWO] &= RRM_HIGH_NIBBLE;
                p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask |= 
                    X2AP_OAM_MACRO_ENB_ID_PRESENT;
                RRM_MEMCPY(&p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.macro_enb_id.eNB_id, 
                        &target_global_cell_id, MACRO_ENB_ID_OCTET_SIZE);
            }
            else if (enodeb_type == RRM_ENB_TYPE_HOME)
            {
                RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id[RRM_ZERO].cell_identity,
                        sizeof(HOME_ENB_ID_OCTET_SIZE));
                /* Home EnodeB id is of only 28 bit so only considering the 28 bits. */
                /* SPR Fix 18895 Start*/
                target_global_cell_id[RRM_THREE] &= RRM_HIGH_NIBBLE;
                /* SPR Fix 18895 End*/
                p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask |= 
                    X2AP_OAM_HOME_ENB_ID_PRESENT;
                RRM_MEMCPY(&p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.home_enb_id.eNB_id, 
                        &target_global_cell_id, HOME_ENB_ID_OCTET_SIZE);
            }

            /* This count is the number of cells in the serving eNodeB.
               RRM design of forwarding the load request is managed at cell level.
               so this count shall always remain as 1. In case of multi cell/single cell.
               */
            p_x2ap_rrm_load_info_req->cell_information_count = RRM_ONE;

            /* Fill API Info */
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask = RRM_ZERO;
            /* Filling up the PLMN Identity of Source eNB*/
            rrm_fill_plmn_identity_for_enb_transfer (&(p_cell_context->global_cell_id.primary_plmn_id),
                    &p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    source_cell_id.plmn_identity);

            /*spr_13531_fix_start*/

            /* SPR Fix 18895 Start*/
            RRM_MEMCPY(&serving_global_cell_id,  p_cell_context->global_cell_id.cell_identity,
                    sizeof(HOME_ENB_ID_OCTET_SIZE));


            RRM_MEMCPY(&p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].source_cell_id.cell_identity, 
                    &serving_global_cell_id,MAX_CELL_IDENTITY_OCTETS);

            /* SPR Fix 18895 End */
            /*spr_13531_fix_end*/

            /*Cov_fix_end_64538*/
            /* Mapping of Overload Indication */
            if (p_cell_context->icic_l1_l2_report_info.bitmask & RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT)
            {
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |=
                    X2AP_LI_CELL_INFO_ITEM_UL_INTF_OVERLOAD_IND_PRESENT;
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].ul_intf_overload_ind.count =
                    p_cell_context->icic_l1_l2_report_info.ul_intf_overload_ind.prb_count;
                for (prb_count = RRM_ZERO; prb_count < p_cell_context->icic_l1_l2_report_info.
                        ul_intf_overload_ind.prb_count; prb_count++)
                {
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                        ul_intf_overload_ind.ul_intf_overload_indication[prb_count] =
                        p_cell_context->icic_l1_l2_report_info.ul_intf_overload_ind.
                        ul_intf_overload_indication[prb_count];
                }
                /* SPR 21843 Fix Start */
                /* Code Removed */
                /* SPR 21843 Fix End */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Filling Overload Indication for PRB Count:[%d]",
                        p_cell_context->icic_l1_l2_report_info.ul_intf_overload_ind.prb_count);
            }

            /* Mapping of RNTP Indication */
            if (p_cell_context->icic_l1_l2_report_info.bitmask & 
                    RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT)
            {
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |=
                    X2AP_LI_CELL_INFO_ITEM_RELATIVE_NARROWBAND_TX_POWER_PRESENT;
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].relative_narrowband_tx_power.prb_count =
                    p_cell_context->icic_l1_l2_report_info.relative_narrowband_tx_power.prb_count;
                /* Below loop will set the interference senstitvity to "1"
                 * in the RNTP Map as bit string of 110 PRBs(As per the cell bandwidth configured from OAM)
                 */
                for (prb_count = RRM_ZERO; prb_count < p_cell_context->icic_l1_l2_report_info.
                        relative_narrowband_tx_power.prb_count; prb_count++)
                {
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                        relative_narrowband_tx_power.rntp_per_prb[prb_count / RRM_EIGHT] |=
                        (U8)(p_cell_context->icic_l1_l2_report_info.relative_narrowband_tx_power.
                                rntp_per_prb[prb_count] << (prb_count % RRM_EIGHT));
                }

                /* Filling RNTP Threshhold */
                if ((p_cell_context->operator_info.bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT) &&
                        (p_cell_context->operator_info.dynamic_icic_info.bitmask & 
                         RRMCM_RMIF_RNTP_REPORT_CONFIG_INFO_PRESENT))
                {
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                        relative_narrowband_tx_power.rntp_threshold = 
                        p_cell_context->operator_info.dynamic_icic_info.rntp_report_config_info.
                        rntp_threshold;
                }

                /* Filling Antenna Port Count */
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    relative_narrowband_tx_power.num_cell_specific_antena_port = 
                    p_cell_context->ran_info.antenna_info.antenna_ports_count_number;

                /* Filling p_b */
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    relative_narrowband_tx_power.p_b = 
                    p_cell_context->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b;

                /* Filling PDCCH Interference Impact*/
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    relative_narrowband_tx_power.pdcch_interference_impact = RRM_ZERO;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Filling RNTP Indication for PRB Count:[%d]",
                        p_cell_context->icic_l1_l2_report_info.ul_intf_overload_ind.prb_count);
                /* SPR 21843 Fix Start */
                /* Code Removed */
                /* SPR 21843 Fix End */
            }

            /* Mapping of High Interference Indication */
            if (p_cell_context->icic_l1_l2_report_info.bitmask & 
                    RRM_CTXT_HIGH_INTF_IND_PRESENT)
            {
                /* SPR 21843 Fix Start */
                /* Code Removed */
                /* SPR 21843 Fix End */
                for (cell_id = RRM_ZERO; cell_id < num_cell; ++cell_id)
                {
                    cell_counter++;
                    /* Mapping of High Interference Indication */
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |=
                        X2AP_LI_CELL_INFO_ITEM_UL_INTF_INFO_PRESENT;

                    /* Filling up the PLMN Identity of target eNodeB i.e eNB2*/
                    rrm_fill_plmn_identity_for_enb_transfer (&p_eutran_global_cell_id[cell_id].primary_plmn_id,
                            &p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                            ul_high_interference_info.ul_high_intf_info[cell_id].
                            target_cell_id.plmn_identity);

                    /* Filling up the Cell Identity of target eNodeB i.e eNB2*/
                    /* SPR 20583 Fix Start */
                    RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id[RRM_ZERO].cell_identity,
                            sizeof(HOME_ENB_ID_OCTET_SIZE));
                    target_global_cell_id[RRM_THREE] &= RRM_HIGH_NIBBLE;
                    /* SPR 20583 Fix End */
                    RRM_MEMCPY(&p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                            ul_high_interference_info.ul_high_intf_info[cell_id].
                            target_cell_id.cell_identity, 
                            &target_global_cell_id, MAX_CELL_IDENTITY_OCTETS);

                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                        ul_high_interference_info.ul_high_intf_info[cell_id].ul_high_intf_ind.prb_count =
                        prb_configured_in_srv_cell;

                    /* Now HII PRBs should be reported to peer. In this case either RRM has done the 
                       repartioning again or no partioning is done by the decision making function.
                       In case a change is done then the new configuration of UL is present in
                       the below mentioned bitmask 
                       Else
                       It should be picked from the Cell Context which is presently ongoing.
                       */
                    if(p_cell_context->icic_l1_l2_report_info.decision_info_stored.bitmask & 
                            RRM_CTXT_UL_PARTIONING_INFO_PRESENT)
                    {
                        start_rb = p_cell_context->icic_l1_l2_report_info.decision_info_stored.
                            ul_resource_partition_info_new.cell_edge_region.start_rb;
                        num_of_rb =
                            p_cell_context->icic_l1_l2_report_info.decision_info_stored.
                            ul_resource_partition_info_new.cell_edge_region.num_of_rb;
                    }
                    else
                    {
                        start_rb = p_cell_context->operator_info.dynamic_icic_info.
                            ul_resource_partition_info.cell_edge_region.start_rb;
                        num_of_rb =
                            p_cell_context->operator_info.dynamic_icic_info.
                            ul_resource_partition_info.cell_edge_region.num_of_rb;
                    }


                    /* Below loop will set the interference senstitvity to "1"
                     * in an array of 110 PRBs(As per the cell bandwidth configured from OAM)
                     */
                    for (prb_count = start_rb; prb_count < (start_rb + num_of_rb); prb_count++)
                    {
                        hii_prb_array[prb_count] =  RRM_ONE;
                    }
                    /* Below loop will set the interference senstitvity to "1"
                     * as the bitstring in the array
                     */
                    for(prb_count = RRM_ZERO; prb_count < prb_configured_in_srv_cell; prb_count++)
                    {
                        p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].ul_high_interference_info.
                            ul_high_intf_info[cell_id].ul_high_intf_ind.hii[prb_count / RRM_EIGHT] |=
                            (U8)(hii_prb_array[prb_count] << (prb_count % RRM_EIGHT));
                    }

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Filling High Interference Indication for PRB Count:[%d]",
                            p_cell_context->icic_l1_l2_report_info.ul_high_interference_info.prb_count);

                    if ((MAX_SERVED_CELLS == cell_counter) &&
                            (RRM_ZERO != p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask))
                    {
                        /* Number of cells for which load information is present */
                        p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                            ul_high_interference_info.ul_high_interference_info_count = MAX_SERVED_CELLS;
                        if (RRM_SUCCESS ==  rrm_il_send_x2ap_rrm_load_information_req(
                                    p_x2ap_rrm_load_info_req,
                                    RRM_MODULE_ID,
                                    RRC_MODULE_ID,
                                    RRM_ZERO,p_cell_context->cell_index))
                        {
                            RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Successfully sent batch for LOAD_INFORMATION_REQ");
                        }
                        else
                        {
                            RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Failed to send batch for LOAD_INFORMATION_REQ");
                        }
                        cell_counter = RRM_ZERO;
                    }
                }
            }
            /*Cov_fix_start_62560*/
            if(RRM_ZERO != p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask)
            {
                if (p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask &
                        X2AP_LI_CELL_INFO_ITEM_UL_INTF_INFO_PRESENT)
                {
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                        ul_high_interference_info.ul_high_interference_info_count = cell_counter;
                }
                if (RRM_SUCCESS == rrm_il_send_x2ap_rrm_load_information_req(
                            p_x2ap_rrm_load_info_req,
                            RRM_MODULE_ID,
                            RRC_MODULE_ID,
                            RRM_ZERO,p_cell_context->cell_index))
                {
                    RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Successfully sent LOAD_INFORMATION_REQ");
                }
                else
                {
                    RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Failed to send LOAD_INFORMATION_REQ");
                }
            }
        }
        else 
        {
            RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Dynamic memory allocation is failed for p_x2ap_rrm_load_info_req");
        }
        /* SPR 21843 Fix Start */
    }
    /* SPR 21843 Fix End */
    /* Coverity_fix_end_62560 */
    RRM_MEM_FREE(p_x2ap_rrm_load_info_req);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 *   FUNCTION NAME       : build_and_send_x2ap_rrm_hii_req 
 *   INPUT       : p_cell_context,num_cell,enodeb_type,p_eutran_global_cell_id
 *   OUTPUT      : 
 *   DESCRIPTION :
 *      This function build and send HII map in 
 x2ap_rrm_load_information_req_t msg to L3
 *
 *   RETURNS     : None
 *****************************************************************************/

rrm_void_t build_and_send_x2ap_rrm_hii_req 
(
 rrm_cell_context_t                 *p_cell_context,
 rrm_oam_eutran_global_cell_id_t    *p_eutran_global_cell_id,
 U16                                num_cell,
 rrm_enb_type_et                    enodeb_type
 )
{
    /* Coverity_fix_start_48303 */
    x2ap_rrm_load_information_req_t    *p_x2ap_rrm_load_info_req;
    /* Coverity_fix_end_48303 */
    U8                                 cell_id = RRM_ZERO;
    U16                                cell_counter = RRM_ZERO;
    U16                                prb_count = RRM_ZERO;
    U8                                 serving_prb_count = RRM_ZERO;
    U8                                 start_rb = RRM_ZERO;
    U8                                 num_of_rb = RRM_ZERO;
    U8                                 serving_global_cell_id[HOME_ENB_ID_OCTET_SIZE] = {RRM_ZERO};
    U8                                 target_global_cell_id[HOME_ENB_ID_OCTET_SIZE] = {RRM_ZERO};
    U8                                 hii_prb_array[X2AP_RRM_LI_MAX_HII_PRB_OCTETS] = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();
    /* Coverity_fix_start_48303 */
    p_x2ap_rrm_load_info_req =  rrm_mem_get(sizeof(x2ap_rrm_load_information_req_t));

    /* Coverity_fix_start_48303 */
    RRM_ASSERT(p_cell_context != RRM_PNULL);
    RRM_ASSERT(p_eutran_global_cell_id != RRM_PNULL);
    /* Coverity_fix_start_62559 */
    if (p_x2ap_rrm_load_info_req != RRM_PNULL)
    {
        RRM_MEMSET(p_x2ap_rrm_load_info_req, RRM_ZERO, sizeof(x2ap_rrm_load_information_req_t));

        switch(p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth)
        {
            case RRM_OAM_BW_N_6:
                serving_prb_count = PRB_COUNT_6;
                break;
            case RRM_OAM_BW_N_15:
                serving_prb_count = PRB_COUNT_15;
                break;
            case RRM_OAM_BW_N_25:
                serving_prb_count = PRB_COUNT_25;
                break;
            case RRM_OAM_BW_N_50:
                serving_prb_count = PRB_COUNT_50;
                break;
            case RRM_OAM_BW_N_75:
                serving_prb_count = PRB_COUNT_75;
                break;
            case RRM_OAM_BW_N_100:
                serving_prb_count = PRB_COUNT_100;
                break;
            default :
                serving_prb_count = PRB_COUNT_50;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "Incorrect value received for dl_bandwith = %u",
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth);
        }

        /* Filling up the PLMN Identity of eNB2*/
        rrm_fill_plmn_identity_for_enb_load_req (&p_eutran_global_cell_id[RRM_ZERO].primary_plmn_id,
                (U8 *)&(p_x2ap_rrm_load_info_req->gb_enb_id.plmn_identity.plmn_id));

        /* Filling up the Cell Identity of eNB2*/
        p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask = RRM_ZERO;
        if (enodeb_type == RRM_ENB_TYPE_MACRO)
        {
            RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id[RRM_ZERO].cell_identity,
                    sizeof(HOME_ENB_ID_OCTET_SIZE));
            target_global_cell_id[RRM_THREE] = RRM_ZERO; /* Coverity CID 41381: '&=' replaced with simple '=' */
            target_global_cell_id[RRM_TWO] &= RRM_HIGH_NIBBLE;
            p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask |= 
                X2AP_OAM_MACRO_ENB_ID_PRESENT;
            RRM_MEMCPY(p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.macro_enb_id.eNB_id, 
                    &target_global_cell_id, MACRO_ENB_ID_OCTET_SIZE);
        }
        else if (enodeb_type == RRM_ENB_TYPE_HOME)
        {
            RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id[RRM_ZERO].cell_identity,
                    sizeof(HOME_ENB_ID_OCTET_SIZE));
            /* Home EnodeB id is of only 28 bit so only considering the 28 bits. */
            target_global_cell_id[RRM_THREE] &= RRM_HIGH_NIBBLE;
            p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask |= 
                X2AP_OAM_HOME_ENB_ID_PRESENT;
            RRM_MEMCPY(p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.home_enb_id.eNB_id, 
                    &target_global_cell_id, HOME_ENB_ID_OCTET_SIZE);
        }
        /* This count is the number of cells in the serving eNodeB.
           RRM design of forwarding the load request is managed at cell level.
           so this count shall always remain as 1. In case of multi cell/single cell.
         */
        p_x2ap_rrm_load_info_req->cell_information_count = RRM_ONE;

        /* Fill API Info */
        p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask = RRM_ZERO;
        /* Filling up the PLMN Identity of Source eNB*/
        rrm_fill_plmn_identity_for_enb_transfer (&(p_cell_context->global_cell_id.primary_plmn_id),
                &(p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    source_cell_id.plmn_identity));

        /* Get the type of Serving eNodeB. Is it macro or Home eNodeb */
        if (p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT)
        {
            RRM_MEMCPY(&serving_global_cell_id,  p_cell_context->global_cell_id.cell_identity,
                    sizeof(HOME_ENB_ID_OCTET_SIZE));
            /* Home EnodeB id is of only 28 bit so only considering the 28 bits. */
            serving_global_cell_id[RRM_THREE] &= RRM_HIGH_NIBBLE;
        }
        else
        {
            RRM_MEMCPY(&serving_global_cell_id,  p_cell_context->global_cell_id.cell_identity,
                    sizeof(MACRO_ENB_ID_OCTET_SIZE));
            /* Macro EnodeB id is of only 20 bit so only considering the 20 bits. */
            serving_global_cell_id[RRM_THREE] = RRM_ZERO;
            serving_global_cell_id[RRM_TWO] &= RRM_HIGH_NIBBLE;
        }
        /* Filling up the Cell Identity of Source eNB*/
        /*Cov_fix_start_64539*/
        RRM_MEMCPY(&(p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].source_cell_id.cell_identity), 
                &serving_global_cell_id, MAX_CELL_IDENTITY_OCTETS);
        /*Cov_fix_end_64539*/
        for (cell_id = RRM_ZERO; cell_id < num_cell; ++cell_id)
        {
            cell_counter++;
            /* Mapping of High Interference Indication */
            //if (p_cell_context->icic_l1_l2_report_info.bitmask & 
            //        RRM_CTXT_HIGH_INTF_IND_PRESENT)
            {
                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |=
                    X2AP_LI_CELL_INFO_ITEM_UL_INTF_INFO_PRESENT;

                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    ul_high_interference_info.ul_high_interference_info_count = num_cell;

                /* Filling up the PLMN Identity of target eNodeB i.e eNB2*/
                rrm_fill_plmn_identity_for_enb_transfer (&p_eutran_global_cell_id[cell_id].primary_plmn_id,
                        &(p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                            ul_high_interference_info.ul_high_intf_info[cell_id].
                            target_cell_id.plmn_identity));

                /* Filling up the Cell Identity of target eNodeB i.e eNB2*/
                RRM_MEMCPY(&(p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                            ul_high_interference_info.ul_high_intf_info[cell_id].
                            target_cell_id.cell_identity), 
                        &target_global_cell_id, MAX_CELL_IDENTITY_OCTETS);

                p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                    ul_high_interference_info.ul_high_intf_info[cell_id].ul_high_intf_ind.prb_count =
                    serving_prb_count;

                /* Below loop will set the interference senstitvity to "1"
                 * in an array of 110 PRBs(As per the cell bandwidth configured from OAM)
                 */
                start_rb = p_cell_context->operator_info.dynamic_icic_info.
                    ul_resource_partition_info.cell_edge_region.start_rb;
                num_of_rb = p_cell_context->operator_info.dynamic_icic_info.
                    ul_resource_partition_info.cell_edge_region.num_of_rb;
                for (prb_count = start_rb;  prb_count < (start_rb + num_of_rb);  prb_count++)
                {
                    hii_prb_array[prb_count] = RRM_ONE;
                }
                /* Below loop will set the interference senstitvity to "1"
                 * as the bitstring in the array
                 */
                for (prb_count = RRM_ZERO; prb_count < serving_prb_count; prb_count++)
                {
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].ul_high_interference_info.
                        ul_high_intf_info[cell_id].ul_high_intf_ind.hii[prb_count / RRM_EIGHT] |= 
                        (U8)(hii_prb_array[prb_count] << (prb_count % RRM_EIGHT));
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Filling High Interference Indication(HII) for PRB Count:[%d]", serving_prb_count);
            }

            if ((MAX_SERVED_CELLS == cell_counter) &&
                    (RRM_ZERO != p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask))
            {
                /* Number of cells for which load information is present */
                p_x2ap_rrm_load_info_req->cell_information_count = MAX_SERVED_CELLS;
                if (RRM_SUCCESS ==  rrm_il_send_x2ap_rrm_load_information_req(
                            p_x2ap_rrm_load_info_req,
                            RRM_MODULE_ID,
                            RRC_MODULE_ID,
                            RRM_ZERO,p_cell_context->cell_index))
                {
                    //ylPushTail(&p_rrm_gbl_ctx->rsu_trans_info_list, &p_trans_info->sNode);
                    RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Successfully sent batch for LOAD_INFORMATION_REQ(HII)");
                }
                else
                {
                    RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Failed to send batch for LOAD_INFORMATION_REQ(HII)");
                }
                cell_counter = RRM_ZERO;
            }
        }

        if ((RRM_ZERO != (cell_counter%MAX_SERVED_CELLS)) &&
                (RRM_ZERO != p_x2ap_rrm_load_info_req->cell_information[0].bitmask))
        {
            if (RRM_SUCCESS == rrm_il_send_x2ap_rrm_load_information_req(
                        p_x2ap_rrm_load_info_req,
                        RRM_MODULE_ID,
                        RRC_MODULE_ID,
                        RRM_ZERO,p_cell_context->cell_index))
            {
                RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Successfully sent LOAD_INFORMATION_REQ(HII)");
            }
            else
            {
                RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to send LOAD_INFORMATION_REQ(HII)");
            }
        }
    }
    else 
    {
        RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Dynamic memory allocation is failed for p_x2ap_rrm_load_info_req");
    }
    /* Coverity_fix_end_62559 */
    rrm_mem_free(p_x2ap_rrm_load_info_req);
    RRM_UT_TRACE_EXIT();
}

/* DYNAMIC ICIC CHANGES END */

/*BUG 680 FIX START*/
/****************************************************************************
 *   FUNCTION NAME       : rrm_map_scheduling_info_list
 *
 *   DESCRIPTION :
 *      This function fills th scheduling_info_list_t of RRC from RRM
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et rrm_map_scheduling_info_list(
        scheduling_info_list_t *p_rrc_scheduling_info_list,
        rrm_scheduling_info_list_t  *p_rrm_scheduling_info_list
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_scheduling_info_list && RRM_PNULL != p_rrm_scheduling_info_list)
    {
        p_rrc_scheduling_info_list->count = p_rrm_scheduling_info_list->count;
        for( index = RRM_ZERO ;index <p_rrm_scheduling_info_list->count ; index++)
        {
            p_rrc_scheduling_info_list->scheduling_info[index].si_periodicity =
                p_rrm_scheduling_info_list->scheduling_info[index].si_periodicity;
            rrm_map_sib_mapping_info(&p_rrc_scheduling_info_list->scheduling_info[index].sib_mapping_info,
                    &p_rrm_scheduling_info_list->scheduling_info[index].sib_mapping_info);
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " p_rrc_scheduling_info_list or p_rrm_scheduling_info_list is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 *   FUNCTION NAME       : rrm_map_sib_mapping_info
 *
 *   DESCRIPTION :
 *      This function fills sib_mapping_info_t structure of RRC from RRM
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
rrm_return_et rrm_map_sib_mapping_info(
        sib_mapping_info_t *p_rrc_sib_mapping_info,
        rrm_sib_mapping_info_t  *p_rrm_sib_mapping_info
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_sib_mapping_info && RRM_PNULL != p_rrm_sib_mapping_info)
    {
        p_rrc_sib_mapping_info->count = p_rrm_sib_mapping_info->count;
        for( index = RRM_ZERO ;index < p_rrm_sib_mapping_info->count ; index++)
        {
            p_rrc_sib_mapping_info->sib_type[index] = p_rrm_sib_mapping_info->sib_type[index];
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "p_rrc_sib_mapping_info or p_rrm_sib_mapping_info is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*BUG 680 FIX END*/

/*bug 9979 Fix -Start */
/****************************************************************************
 *   FUNCTION NAME       : fill_mac_prs_reconfig
 *   INPUT       : cell_context->
 *   OUTPUT      : p_mac_reconfig_info
 *   DESCRIPTION :
 *    		This function Maps the PRS reconfig params coming from MIF to RRC
 *
 *   RETURNS     :
 *****************************************************************************/
rrm_void_t
fill_mac_prs_reconfig
(
 prs_t              *p_cellm_prs_reconfig,
 rrc_mac_reconfig_t   *p_mac_reconfig_info
 )
{
    RRM_UT_TRACE_ENTER();
    if(p_cellm_prs_reconfig != RRM_PNULL && p_mac_reconfig_info != RRM_PNULL)
    {
        if(p_cellm_prs_reconfig->prs_enable == RRM_TRUE)
        {
            p_mac_reconfig_info->bitmask |=RRC_RRM_RECONFIG_PRS_INFO_PRESENT;
            p_mac_reconfig_info ->prs_reconfig_info.bitmask |= RRC_RRM_RECONFIG_PRS_CONFIG_PRESENT;

            p_mac_reconfig_info->prs_reconfig_info.request_type                  = RRM_TRUE;

            p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_SUBFRAMES_INFO_PRESENT; 
            p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_subframes_info.prs_subframes                   =
                p_cellm_prs_reconfig->num_consecutive_prs_subfames;

            p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_CONFIG_INDEX_INFO_PRESENT; 
            p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_config_index_info.prs_config_index             =
                p_cellm_prs_reconfig->prs_configuration_index;


            p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |= RRC_RRM_RECONFIG_PRS_TRANSMISSION_POWER_INFO_PRESENT; 
            p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_transmission_power_info.prs_transmission_power =
                p_cellm_prs_reconfig->prs_transmission_power;

            if(p_cellm_prs_reconfig->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_TWO_PRESENT)
            {
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;

                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_reconfig->prs_muting_configration.muting_config_two;
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N2;

            }
            else if(p_cellm_prs_reconfig->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_FOUR_PRESENT)
            {
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;

                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_reconfig->prs_muting_configration.muting_config_four;

                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N4;
            }
            else if(p_cellm_prs_reconfig->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_EIGHT_PRESENT)
            {
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_reconfig->prs_muting_configration.muting_config_eight;
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N8;
            }
            else if(p_cellm_prs_reconfig->prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT)
            {
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.bitmask |=  RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT;
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.prs_muting_config_index =
                    p_cellm_prs_reconfig->prs_muting_configration.muting_config_sixteen;
                p_mac_reconfig_info->prs_reconfig_info.prs_reconfig.prs_muting_config_info.bits_to_be_read  = RRM_PRS_N16;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "prs_enable is false");
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "One of the Pointer is NULL pointer");
    }
    RRM_UT_TRACE_EXIT(); 
}
/* SPR 20908 Start */

void rrm_copy_ip_addr(U8 *dest, U8 *src, U32 length)
{
    U32 index=0;
    for(; index < length; index++)
    {
        dest[index]=src[index];
    }
}

void rrm_fill_l2_comm_info_params
(
 rrc_lower_layer_comm_info_t *p_cell_setup_l2_comm_info_params,
 rrm_oam_lower_layer_comm_info_t *p_cell_cntxt_l2_comm_info_params 
 )
{
    /* SPR 21371 Start */
    p_cell_setup_l2_comm_info_params->mac_comm_info.bitmask = RRC_RRM_IPV4_ADDRESS_PRESENT;
    p_cell_setup_l2_comm_info_params->mac_comm_info.port=
        p_cell_cntxt_l2_comm_info_params->mac_comm_info.port;

    if(p_cell_cntxt_l2_comm_info_params->mac_comm_info.bitmask & RRMCM_RMIF_DATA_PORT_PRESENT)
    {
        p_cell_setup_l2_comm_info_params->mac_comm_info.data_port=
            p_cell_cntxt_l2_comm_info_params->mac_comm_info.data_port;
        p_cell_setup_l2_comm_info_params->mac_comm_info.bitmask |= RRC_RRM_DATA_PORT_PRESENT;
    }

    rrm_copy_ip_addr(p_cell_setup_l2_comm_info_params->mac_comm_info.ip_addr,
            p_cell_cntxt_l2_comm_info_params->mac_comm_info.ip_addr,RRC_MAX_IP_SIZE);

    p_cell_setup_l2_comm_info_params->rlc_comm_info.bitmask = RRC_RRM_IPV4_ADDRESS_PRESENT;
    p_cell_setup_l2_comm_info_params->rlc_comm_info.port=
        p_cell_cntxt_l2_comm_info_params->rlc_comm_info.port;

    if(p_cell_cntxt_l2_comm_info_params->rlc_comm_info.bitmask & RRMCM_RMIF_DATA_PORT_PRESENT)
    {
        p_cell_setup_l2_comm_info_params->rlc_comm_info.data_port=
            p_cell_cntxt_l2_comm_info_params->rlc_comm_info.data_port;
        p_cell_setup_l2_comm_info_params->rlc_comm_info.bitmask |= RRMCM_RMIF_DATA_PORT_PRESENT;
    }

    rrm_copy_ip_addr(p_cell_setup_l2_comm_info_params->rlc_comm_info.ip_addr,
            p_cell_cntxt_l2_comm_info_params->rlc_comm_info.ip_addr,RRC_MAX_IP_SIZE);


    if(p_cell_cntxt_l2_comm_info_params->bitmask & RRMCM_RMIF_CRAN_PDCP_COMM_INFO_PRESENT)
    {

        p_cell_setup_l2_comm_info_params->cran_pdcp_comm_info.bitmask = RRC_RRM_IPV4_ADDRESS_PRESENT;
        p_cell_setup_l2_comm_info_params->cran_pdcp_comm_info.port=
            p_cell_cntxt_l2_comm_info_params->cran_pdcp_comm_info.port;

        p_cell_setup_l2_comm_info_params->cran_pdcp_comm_info.data_port_to_rlc=
            p_cell_cntxt_l2_comm_info_params->cran_pdcp_comm_info.data_port_to_rlc ;
        p_cell_setup_l2_comm_info_params->cran_pdcp_comm_info.data_port_to_egtpu=
            p_cell_cntxt_l2_comm_info_params->cran_pdcp_comm_info.data_port_to_egtpu ;

        rrm_copy_ip_addr(p_cell_setup_l2_comm_info_params->cran_pdcp_comm_info.ip_addr,
                p_cell_cntxt_l2_comm_info_params->cran_pdcp_comm_info.ip_addr,RRC_MAX_IP_SIZE);
        p_cell_setup_l2_comm_info_params->bitmask |= RRC_RRM_CRAN_PDCP_COMM_INFO_PRESENT ;
    }


    if(p_cell_cntxt_l2_comm_info_params->bitmask & RRMCM_RMIF_NON_CRAN_PDCP_COMM_INFO_PRESENT)
    {

        p_cell_setup_l2_comm_info_params->pdcp_comm_info.bitmask = RRC_RRM_IPV4_ADDRESS_PRESENT;
        p_cell_setup_l2_comm_info_params->pdcp_comm_info.port=
            p_cell_cntxt_l2_comm_info_params->pdcp_comm_info.port;

        rrm_copy_ip_addr(p_cell_setup_l2_comm_info_params->pdcp_comm_info.ip_addr,
                p_cell_cntxt_l2_comm_info_params->pdcp_comm_info.ip_addr,RRC_MAX_IP_SIZE);
        p_cell_setup_l2_comm_info_params->bitmask |= RRC_RRM_NON_CRAN_PDCP_COMM_INFO_PRESENT ;
    }

    p_cell_setup_l2_comm_info_params->egtpu_comm_info.bitmask = RRC_RRM_IPV4_ADDRESS_PRESENT;
    p_cell_setup_l2_comm_info_params->egtpu_comm_info.port=
        p_cell_cntxt_l2_comm_info_params->egtpu_comm_info.port;

    if(p_cell_cntxt_l2_comm_info_params->egtpu_comm_info.bitmask & RRMCM_RMIF_DATA_PORT_PRESENT)
    {
        p_cell_setup_l2_comm_info_params->egtpu_comm_info.data_port=
            p_cell_cntxt_l2_comm_info_params->egtpu_comm_info.data_port;
        p_cell_setup_l2_comm_info_params->egtpu_comm_info.bitmask |= RRC_RRM_DATA_PORT_PRESENT;
    }	
    rrm_copy_ip_addr(p_cell_setup_l2_comm_info_params->egtpu_comm_info.ip_addr,
            p_cell_cntxt_l2_comm_info_params->egtpu_comm_info.ip_addr,RRC_MAX_IP_SIZE);

    p_cell_setup_l2_comm_info_params->phy_comm_info.bitmask = RRC_RRM_IPV4_ADDRESS_PRESENT;
    p_cell_setup_l2_comm_info_params->phy_comm_info.port=
        p_cell_cntxt_l2_comm_info_params->phy_comm_info.port;

    if(p_cell_cntxt_l2_comm_info_params->phy_comm_info.bitmask & RRMCM_RMIF_DATA_PORT_PRESENT)
    {
        p_cell_setup_l2_comm_info_params->phy_comm_info.data_port=
            p_cell_cntxt_l2_comm_info_params->phy_comm_info.data_port;
        p_cell_setup_l2_comm_info_params->phy_comm_info.bitmask |= RRC_RRM_DATA_PORT_PRESENT;
    }
    rrm_copy_ip_addr(p_cell_setup_l2_comm_info_params->phy_comm_info.ip_addr,
            p_cell_cntxt_l2_comm_info_params->phy_comm_info.ip_addr,RRC_MAX_IP_SIZE);
/* SPR 21371 End */
}
/* SPR 20908 End */


/*bug 9979 Fix -End */
/* eICIC_PHASE_1_2_CHANGES_START */
/****************************************************************************
 *   FUNCTION NAME       : rrm_cellm_fill_x2ap_eicic_load_info_ind 
 *   INPUT       : p_cell_context,num_cell,enodeb_type,p_eutran_global_cell_id
 *   OUTPUT      : 
 *   DESCRIPTION :
 *      This function build and send x2ap_rrm_load_information_req_t msg to L3
 *
 *   RETURNS     : None
 *****************************************************************************/

rrm_return_et rrm_cellm_fill_x2ap_eicic_load_info_ind 
(
 rrm_cell_context_t                 *p_cell_context,
 rrm_oam_eutran_global_cell_id_t    *p_eutran_global_cell_id,
 rrm_enb_type_et                     enodeb_type,
 rrm_eicic_load_info_type_et         load_info_type
 )
{
    x2ap_rrm_load_information_req_t    *p_x2ap_rrm_load_info_req = RRM_PNULL;
    U8                                 serving_global_cell_id[HOME_ENB_ID_OCTET_SIZE] = {RRM_ZERO};
    U8                                 target_global_cell_id[HOME_ENB_ID_OCTET_SIZE] = {RRM_ZERO};
    rrm_return_et                      ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_cell_context != RRM_PNULL);
    RRM_ASSERT(p_eutran_global_cell_id != RRM_PNULL);
    p_x2ap_rrm_load_info_req  = (x2ap_rrm_load_information_req_t *) rrm_mem_get (sizeof (x2ap_rrm_load_information_req_t));

    if (p_x2ap_rrm_load_info_req != RRM_PNULL)
    {
        RRM_MEMSET(p_x2ap_rrm_load_info_req, RRM_ZERO, sizeof(x2ap_rrm_load_information_req_t));

        /* Filling up the PLMN Identity of eNB2*/
        rrm_fill_plmn_identity_for_enb_load_req (&p_eutran_global_cell_id->primary_plmn_id,
                (U8 *)&p_x2ap_rrm_load_info_req->gb_enb_id.plmn_identity.plmn_id);

        /* Filling up the Cell Identity of eNB2*/
        p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask = RRM_ZERO;
        if (enodeb_type == RRM_ENB_TYPE_MACRO)
        {
            RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id->cell_identity,
                    HOME_ENB_ID_OCTET_SIZE);
            target_global_cell_id[RRM_THREE] = RRM_ZERO;  /* Coverity CID 41381: '&=' replaced with simple '=' */
            target_global_cell_id[RRM_TWO] &= RRM_HIGH_NIBBLE;
            p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask |= 
                X2AP_OAM_MACRO_ENB_ID_PRESENT;
            RRM_MEMCPY(&p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.macro_enb_id.eNB_id, 
                    &target_global_cell_id, MACRO_ENB_ID_OCTET_SIZE);
        }
        else if (enodeb_type == RRM_ENB_TYPE_HOME)
        {
            RRM_MEMCPY(&target_global_cell_id, p_eutran_global_cell_id->cell_identity,
                    HOME_ENB_ID_OCTET_SIZE);
            /* Home EnodeB id is of only 28 bit so only considering the 28 bits. */
            /* SPR Fix 15571 start */
            target_global_cell_id[RRM_THREE] &= RRM_HIGH_NIBBLE;
            /* SPR Fix 15571 end */
            p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.presence_bitmask |= 
                X2AP_OAM_HOME_ENB_ID_PRESENT;
            RRM_MEMCPY(&p_x2ap_rrm_load_info_req->gb_enb_id.enb_id.home_enb_id.eNB_id, 
                    &target_global_cell_id, HOME_ENB_ID_OCTET_SIZE);
        }

        /* This count is the number of cells in the serving eNodeB.
           RRM design of forwarding the load request is managed at cell level.
           so this count shall always remain as 1. In case of multi cell/single cell.
         */
        p_x2ap_rrm_load_info_req->cell_information_count = RRM_ONE;

        /* Fill API Info */
        p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask = RRM_ZERO;
        /* Filling up the PLMN Identity of Source eNB*/
        rrm_fill_plmn_identity_for_enb_transfer (&(p_cell_context->global_cell_id.primary_plmn_id),
                &p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].
                source_cell_id.plmn_identity);

        /* Get the type of Serving eNodeB. Is it macro or Home eNodeb */


        /* bug_13972_start */  
        RRM_MEMCPY(&serving_global_cell_id,  p_cell_context->global_cell_id.cell_identity,
                sizeof(HOME_ENB_ID_OCTET_SIZE));
        /* bug_13972_end */
        /* Filling up the Cell Identity of Source eNB*/
        /*Cov_fix_start_64538*/
        RRM_MEMCPY(&p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].source_cell_id.cell_identity, 
                &serving_global_cell_id, MAX_CELL_IDENTITY_OCTETS);

        switch(load_info_type)
        {
            case LOAD_INFO_EICIC_INVOKE:
                { 
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Load Information type is INVOKE");
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |= X2AP_LI_INVOKE_INDICATION_PRESENT;
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].invoke_indication.invoke_ind = RRM_ZERO;
                    break;
                }
            case  LOAD_INFO_EICIC_ABS_PATTERN:
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Load Information type is ABS_PATTERN");
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |= X2AP_LI_ABS_INFORMATION_PRESENT ;

#ifndef TDD_MODE_FLAG
                    rrm_fill_abs_pattern_info_fdd( p_x2ap_rrm_load_info_req , p_cell_context );
#else
                    rrm_fill_abs_pattern_info_tdd( p_x2ap_rrm_load_info_req , p_cell_context );
#endif
                    break;
                }
            case  LOAD_INFO_EICIC_ABS_INACTIVE:
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Load Information type is ABS_INACTIVE");
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask |= X2AP_LI_ABS_INFORMATION_PRESENT ;
                    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.bitmask |= X2AP_LI_ABS_INFORMATION_ABS_INACTIVE_PRESENT;
                    break;
                }
            default:
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Invalid_load type of information is found. No need to send X2AP load info");

                    ret_val = RRM_FAILURE;
                }
        }



        if( ( RRM_SUCCESS == ret_val ) &&
                (RRM_ZERO != p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].bitmask))
        {
            if (RRM_SUCCESS == rrm_il_send_x2ap_rrm_load_information_req(
                        p_x2ap_rrm_load_info_req,
                        RRM_MODULE_ID,
                        RRC_MODULE_ID,
                        RRM_ZERO,p_cell_context->cell_index))
            {
                /* SPR 14416 start */
                RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Successfully sent LOAD_INFORMATION_REQ");
                /* SPR 14416 end */
            }
            else
            {
                /* SPR 14416 start */
                RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to send LOAD_INFORMATION_REQ");
                /* SPR 14416 end */
                ret_val = RRM_FAILURE;
            }
        }
    }
    else 
    {
        RRM_LOG(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Dynamic memory allocation is failed for p_x2ap_rrm_load_info_req");
        ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_x2ap_rrm_load_info_req);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

#ifndef TDD_MODE_FLAG
rrm_void_t
rrm_fill_abs_pattern_info_fdd
(
 x2ap_rrm_load_information_req_t    *p_x2ap_rrm_load_info_req , 
 rrm_cell_context_t                 *p_cell_context 
 )
{
    RRM_UT_TRACE_ENTER();
    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.bitmask |= X2AP_LI_ABS_INFORMATION_FDD_PRESENT;
    RRM_MEMCPY( p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.abs_info_fdd.abs_pattern_info,
            p_cell_context->rrm_eicic_cell_info.serving_abs_pattern_applied,X2AP_ABS_PATTERN_SIZE_FDD );
    RRM_MEMCPY( p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.abs_info_fdd.measurement_subset,
            p_cell_context->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,X2AP_MEASUREMENT_SUBSET_SIZE_FDD);

    switch(p_cell_context->ran_info.antenna_info.antenna_ports_count_number)
    {
        case ANTENNA_PORTS_COUNT_AN1:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_fdd.no_cell_specific_antenna_port = X2AP_ONE;
            break;
        case ANTENNA_PORTS_COUNT_AN2:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_fdd.no_cell_specific_antenna_port = X2AP_TWO;
            break;
        case ANTENNA_PORTS_COUNT_AN4:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_fdd.no_cell_specific_antenna_port = X2AP_FOUR;
            break;
        default:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_fdd.no_cell_specific_antenna_port = X2AP_TWO;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Invalid Antenna port count [%d]. Taking default antenna port count as 2",
                    p_cell_context->ran_info.antenna_info.antenna_ports_count_number);
    }
    RRM_UT_TRACE_EXIT();
}
#else
rrm_void_t
rrm_fill_abs_pattern_info_tdd
(
 x2ap_rrm_load_information_req_t    *p_x2ap_rrm_load_info_req , 
 rrm_cell_context_t                 *p_cell_context 
 )
{
    /*EICIC_TDD_CHANGES_START*/
    U8                          abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_context->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = X2AP_ABS_PATTERN_SIZE_TDD;
#endif
    /*EICIC_TDD_CHANGES_END*/        

    p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.bitmask |= X2AP_LI_ABS_INFORMATION_TDD_PRESENT;
    RRM_MEMCPY( p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.abs_info_tdd.abs_pattern_info,
            p_cell_context->rrm_eicic_cell_info.serving_abs_pattern_applied,abs_size);

    rrm_copy_tdd_bits(abs_size, p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.abs_info_tdd.abs_pattern_info);
    RRM_MEMCPY( p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.abs_info_tdd.measurement_subset,
            p_cell_context->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,abs_size);
    rrm_copy_tdd_bits(abs_size, p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.abs_info_tdd.measurement_subset); 

    switch(p_cell_context->ran_info.antenna_info.antenna_ports_count_number)
    {
        case ANTENNA_PORTS_COUNT_AN1:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_tdd.no_cell_specific_antenna_port = X2AP_ONE;
            break;
        case ANTENNA_PORTS_COUNT_AN2:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_tdd.no_cell_specific_antenna_port = X2AP_TWO;
            break;
        case ANTENNA_PORTS_COUNT_AN4:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_tdd.no_cell_specific_antenna_port = X2AP_FOUR;
            break;
        default:
            p_x2ap_rrm_load_info_req->cell_information[RRM_ZERO].abs_infomation.
                abs_info_tdd.no_cell_specific_antenna_port = X2AP_TWO;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Invalid Antenna port count [%d]. Taking default antenna port count as 2",
                    p_cell_context->ran_info.antenna_info.antenna_ports_count_number);
    }



    RRM_UT_TRACE_EXIT();
}
#endif
/* eICIC_PHASE_1_2_CHANGES_END */
