/* vim: ts=4:et:ai:ci:sw=4
*/
/******************************************************************************
 *
 * ARICENT -
 *
 * Copyright (C) 2012 Aricent Inc . All Rights Reserved.
 *
 *******************************************************************************
 *
 * $$Id: rrm_ue_rrc_intf.c $
 *
 *******************************************************************************
 *
 * File Description:This file contains the functions for response filling and
 *                  parsing
 *
 *******************************************************************************
 *Revision Details
 *----------------------
 *   DATE            AUTHOR      REFERENCE       REASON
 *   3 APR 2012      gur30487    Initial
 *   2 MAY 2012      gur30487                    DRX profile selection in the 
 *                                               basis of long drx cycle,
 *                                               Multuplying qci_length with
 *                                               factor 2 in case of NGBR
 *                                               bearer
 *   13 MAY 2012                                 CLPC regarding changes
 *                                              
 *   10 MAY 2012     gur21481                    Added inacivity timer parsing
 *                                               and build and send connection
 *                                               release.
 *   27 MAY 2012     gur30784                    Added rrm_build_and_send_erb_release_ind
 *   7 June 2012     gur29220                    CS-Fallback & Redirection
 *   30 OCT 2012     gur30784    SPR-4367        Added failed list in case of 
 *                                               complete failure in setup/modify
 *   3 Jan 2013      gur29220    SPR-5118        Intra Freq HO failure due
 *                                               to invalid ue index in
 *                                               rrc_rrm_ue_ho_command_response
 *   25 Jan 2013     gur29220    SPR-5195        Fix for : source eNB is not
 *                                               filling plmn ID of the target
 *                                               CellId in handover request message
 *   29 Jan 2013    gur27278                     Added code for SPS feature
 *   11 Feb 2013    gur11056     SPR 314         If same phy cell id is configured  for
 *                                               other RAT then it is trying  handover
 *                                               towards other RAT
 *   18 Apr 2013    gur29220     SPR 5974        RRC rejecting connection release
 *                                               for CDMA2000 CSFB target cell 
 *                                               frequency due to wrong Bitmask
 *   16 Jul 2013    gur11056     SPR 490         Min Bit Rate per QCI
 *   31 Jul 2013    gur11056     SPR 7043        RRM doesn't send all existing ERABs in 
 *                                               dl_fwding_list in RRC_RRM_UE_HO_REQUIRED
 *   16 Apr 2014    gur32417     CA_STG_3        Code added for Carrier Aggregation Stage 3 
 *   28 Apr 2013    gur27356     SPR 10397       Updated for PDCP KPI stat.
 *   3  Jun 2014    gur27356     SPR 11578       HO Failure counter based on UE CONTEXT RELEASE.
 *   6 Jun, 2014     gur29990    11317           OLPC Design Change
 *   17 Jun,2014    gur30784     SPR 11564       DL forwarding list population
 *   28 Apr 2014    gur25767     SPR 10497       Store FDD as well as TDD UE capabilities
 *                                               irrespective of TDD_MODE_FLAG defined or
 *                                               not.
 *    2 May 2014    gur25767     SPR 10538       Queueing implemented for Meas Config CGI 
 *                               /CSR 63989      req. Value of Max report cells made appropriate
 *    6 Jun 2014    gur29990     SPR 11317       OLPC redesigned. 
 *   13 Jun 2014    gur27356     SPR 10489       Support additional causes in RWR. 
 *   25 Apr 2014    gur31824      SPR 10729      RRM is not releasing the UE
 *                                               when RRC sends
 *                                               RRC_RRM_LOCAL_ERROR_IND to
 *                                               RRM for UE with single rabs
 *   29 Apr 2014    gur35095      SPR 10781      RRM was not filling ENB src to trgt container
 *   29 Apr 2014    gur35095      SPR 10779      RRM not doing handover on Intra freq on Inter cell
 *   12 May 2014    gur32417      SPR 11026      RRM not sending Cell Index bitmask when Scell Add
 *   28 May 2014    gur21481      SPR 11284      RRM not updating ca_lc_bandwidth for scell
 *   03 June 2014   gur21481      SPR 11064      RRM was not sending ri_config_index for r10 param
 *   05 Jun 2014    gur25767      SPR 10497      Store FDD as well as TDD UE capabilities
 *                                               irrespective of TDD_MODE_FLAG defined or
 *   06 June 2014   gur26515      SPR 10730      Added code changes for SPR 10730
 *   13 Jun 2014    gur27356      SPR 10489      Support additional causes in RWR.
 *   20 June 2014   gur34951      SPR 10329      Enhancement of GU GROUP ID
 *   01 July 2014   gur21481      SPR 12328      bitmask was removed.
 *   02 July 2014   gur35095      SPR 11907      Broadcast cell_del_req to all cells
 *                                               after resp from all cells, Send
 *                                               cell_del_req to rrc
 *   02 July 2014   gur31824     SPR 11971       RRM not initiating HO_REQUIRED in case of
 *                                               CSFB to CDMA2000 1xrtt.
 *   1  Jul 2014    gur27356     SPR 12327       RRM is not sending HO Required message to RRC 
 *   02 Jul 2014    gur26515     SPR 10450       Implemented DRX Staggering.
 *   30 Jun,2014    gur27356     SPR 11679       CSFB Target Cell selection to take Registered LAC into account.
 *    2 Jul,2014    gur25767     SPR 10498       Inter-freq Daho Support
 *    5 Jul 2014    gur25767     SPR 12396       Fill ho_freq_type in ho_required
 *                                               only in case of intra-lte
 *   1  Jul,2014    gur27356     SPR 12327           RRM is not sending HO Required message to RRC.
 *  14  Jul,2014    gur27356     SPR 12570       RRM should not send “ho_report” to SON for UTRA DAHO cell.
 *   23 June 2014   gur21481     SPR 11535       ue inactivity API handle in HO_ONGOING state
 *    2 Jul,2014    gur25767     SPR 10498       Inter-freq Daho Support
 *   02 Jul 2014    gur26515     SPR 10450       Implemented DRX Staggering.
 *   10 Jul  2014   gur25767     SPR 12351       Configure Meas Config Req for ReportCGI
 *                                               with different report ID
 *   21 Jul  2014   gur13083     SPR 12705       RRM not Updating UTRAN HO
 *                                               FAILURE KPI if Handover Failed by Network
 *   21 Jul 2014    gur29831     SPR 12699       Fix done for spr 12699
 *   23 Jul 2014    gur25767     SPR 12737       Fix done for Get KPI ERB Modify
 *   24 Jul 2014    gur32417     SPR 12781       Scell cell index fix in Intra Cell HO
 *   24 Jul 2014    gur13083     SPR 12797       RRM was not sending the Scell release list
 *   07 Jul 2014    gur13083     SPR 13045       RRM not sending scell parameters in S1 HO
 *    6 Aug 2014    gur29831                     Ho report to son is to be sent to son in too early ho fail 
 *   11 Aug 2014    gur27356     SPR 12963       After PCI Confusion Reported, HO failure for neighbor 2  
 *   19 Aug 2014    gur27356     SPR 13129       RRC is sending "UE CONTEXT RELEASE REQUEST" with cause "cs-fallback-triggered"
 *                                               even scenario is not running for cs fallback.
 *   27 Aug 2014    gur29831     SPR 13344       DAHO cell being selected for ho required
 *   27 Aug 2014    gur27356     SPR 13375       RRM sending HO Failure report with value 0.
 *   06 Nov,2014    gur33103     SPR 13332       Fix regarding Issue in RRM enqueue if Erb delete 
 *                                                 message in between ongoing Meas config procedure
 * 
 ******************************************************************************/
/****************************************************************************
 * Standard Library Includes
 ****************************************************************************/

/****************************************************************************
 * Project Includes
 ****************************************************************************/
#include "l3_api_parser.h"   
#include "s1ap_rrm_parser.h"   
#include "l3_api_composer.h"
#include "s1ap_rrm_composer.h"   
#include "rrc_rrm_intf.h"
#include "rrm_utils.h"
#include "rrm_types.h"
#include "rrm_defines.h"
#include "rrm_ue_context.h"
#include "rrm_ue_mgr.h"
#include "rrm_rrc_ue_intf.h"
#include "rrm_cell_context.h"
#include "rrm_cell_mgr.h"
/* warning removal: Header file "rrm_ue_fsm.h" included, 10/04/2012 */ 
#include "rrm_ue_fsm.h"
#include "rrm_ue_ho_utils.h"
#include "rrm_cell_fsm.h"
#include "rrm_events.h"
/*SPR 11284:start*/
#include "rrm_rrc_cell_intf.h"
/*SPR 11284:end*/
/* DYNAMIC ICIC START*/
extern RRM_TIME_T rrm_get_system_time(void);
/* DYNAMIC ICIC END*/

/***********************************************************************
 * * Global variables
 * ************************************************************************/

rrm_global_context_t *p_g_rrm_cell_ctx;

/***********************************************************************
     Transmission mode Table
***********************************************************************/
rrm_transmission_mode    tx_mode[]={ rrm_fill_tm1,
				     rrm_fill_tm2,
				     rrm_fill_tm3,
				     rrm_fill_tm4,
                                     rrm_fill_tm5,
                                     rrm_fill_tm6,
                                     rrm_fill_tm7,
                                     rrm_fill_tm8};

rrm_scell_transmission_mode    tx_mode_scell[]={ rrm_fill_scell_tm1,
	      			                 rrm_fill_scell_tm2,
					         rrm_fill_scell_tm3,
					         rrm_fill_scell_tm4,
					         rrm_fill_scell_tm5,
					         rrm_fill_scell_tm6,
					         rrm_fill_scell_tm7,
					         rrm_fill_scell_tm8 };

S16
rrmcm_search_cdma_arfcn_in_cell_context_in_ncl_params(
            rrm_cell_context_t              *p_cell_ctx,
            U16                             cdma_arfcn,
            U8                              band_class
            );

void rrm_raise_event_meas_config_periodical_cdma(
        rrc_rrm_meas_config_req_t *p_rrc_rrm_meas_config_req,
        rrm_cell_index_t           cell_index);



rrm_void_t sort_utran_frq_pri_list(
                  rrm_utran_freq_priority_list_info_t*  p_utran_freq_pri_list
                  );
/* BUG_11317_FIX_START */
/* Uplink power starts */
/***********************************************************************
	open loop power control action table
***********************************************************************/
rrm_ue_olpc_action    olpc_action[]={ rrm_olpc_inc_power,
                                      rrm_olpc_dec_pow,
                                      rrm_olpc_no_action };
/* Uplink power end */
/* BUG_11317_FIX_END */

/***********************************************************************
 * * Extern Functions
 * ************************************************************************/
extern rrm_void_t
update_meas_config_status(
            rrm_ue_context_t              *p_rrm_ue_ctx,
            rrm_bool_et                   *p_is_ecid_meas_resp,
            U8                            *p_meas_id,
            rrm_meas_ecid_resp_et         *p_ecid_meas_resp_action
            );
/* Fix for SPR 10310 start */
extern rrm_return_et
rrm_ue_fill_meas_config_req_for_ho(
            rrm_meas_config_t             *p_meas_config,
            rrm_ue_context_t              *p_rrm_ue_ctx          
            );
/* Fix for SPR 10310 end */
    /* eICIC_PHASE_1_2_CHANGES_START */
extern rrm_return_et
rrm_ue_fill_meas_config_req_for_victim_ue(
            rrm_meas_config_t             *p_meas_config,
            rrm_ue_context_t              *p_rrm_ue_ctx          
            );
    /* eICIC_PHASE_1_2_CHANGES_END */

extern U8 get_spid_for_cdma (rrm_cell_index_t cell_index);
#ifdef ENDC_ENABLED
U8 rrm_cellm_get_sgnb_ambr_share(rrm_cell_index_t cell_index);
rrm_bool_t
rrm_check_trigger_to_configure_nr_meas
(
  rrm_ue_context_t           *p_ue_context,
  rrm_nr_meas_trigger_type_et trigger_type
);
#endif

/* SPR 13205 Fix Start */
//static U8 spid_for_cdma;
/* SPR 13205 Fix End */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_ul_am_rlc
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrc_uplink_am_rlc
 *   DESCRIPTION  :
 *                   Fills the rrc_uplink_am_rlc_t
 *   RETURNS      :
 *                   RRM_SUCCESS  on Success
 *                   RRM_FAILURE  on Failure
 ******************************************************************************/



rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_ul_am_rlc(
        rrc_uplink_am_rlc_t *p_rrc_uplink_am_rlc,
        rlc_layer_params_t  *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_uplink_am_rlc->t_poll_retransmit = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].srb_params.
        t_poll_retransmit;
    p_rrc_uplink_am_rlc->poll_pdu = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].srb_params.poll_pdu;
    p_rrc_uplink_am_rlc->poll_byte = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].srb_params.poll_byte;
    p_rrc_uplink_am_rlc->max_retx_threshold = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].srb_params.
        max_retx_threshold;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_dl_am_rlc
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrc_downlink_am_rlc
 *   DESCRIPTION  :
 *                  Fills the rrc_downlink_am_rlc_t
 *   RETURNS      :
 *                   RRM_SUCCESS  on Success
 *                   RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_dl_am_rlc(
        rrc_downlink_am_rlc_t *p_rrc_downlink_am_rlc,
        rlc_layer_params_t    *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_downlink_am_rlc->t_reordering = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].srb_params.t_reordering;
    p_rrc_downlink_am_rlc->t_status_prohibit = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].srb_params.
        t_status_prohibit;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_am_config_explicit
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrc_am_config 
 *   DESCRIPTION  :
 *                  Fills the rrc_am_config_t
 *   RETURNS      :
 *                   RRM_SUCCESS  on Success
 *                   RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_am_config_explicit(
        rrc_am_config_t     *p_rrc_am_config,
        rlc_layer_params_t  *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    rrm_rrc_ue_adm_resp_fill_srb1_ul_am_rlc(&(p_rrc_am_config->ul_am_rlc),
            p_rlc_layer_params);
    rrm_rrc_ue_adm_resp_fill_srb1_dl_am_rlc(&(p_rrc_am_config->dl_am_rlc),
            p_rlc_layer_params);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_am_config
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrm_srb_am_config
 *   DESCRIPTION  :
 *                  Fills the rrm_srb_am_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_am_config(
        rrm_srb_am_config_t *p_rrm_srb_am_config,
        rlc_layer_params_t  *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_srb_am_config->bitmask |= RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT;
    rrm_rrc_ue_adm_resp_fill_srb1_am_config_explicit
        (&(p_rrm_srb_am_config->am_config_explicit),p_rlc_layer_params);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_ul_specific_parameters_explicit
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrm_ul_specific_parameters_explicit
 *   DESCRIPTION  :
 *                  Fills the rrc_ul_specific_parameters_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_ul_specific_parameters_explicit(
        rrc_ul_specific_parameters_t   *p_rrm_ul_specific_parameters_explicit
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_ul_specific_parameters_explicit->priority = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_0_PRIORITY;
    p_rrm_ul_specific_parameters_explicit->prioritized_bit_rate = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_PRIORITIZED_BIT_RATE;
    p_rrm_ul_specific_parameters_explicit->bucket_size_duration = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_BUCKET_SIZE_DURATION;
    p_rrm_ul_specific_parameters_explicit->bitmask |= 
        RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_PRESENT;
    p_rrm_ul_specific_parameters_explicit->logical_channel_group = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_LOGICAL_CHANNEL_GROUP;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
*   FUNCTION NAME: rrm_set_r9_mask
*   INPUT        : p_rrm_ue_context
*   OUTPUT       : p_rrm_logical_channel_config
*   DESCRIPTION  :
*                  Fills the p_rrm_logical_channel_config
*   RETURNS      : none
******************************************************************************/

void
rrm_set_r9_mask(
        rrm_logical_channel_config_t
        *p_rrm_logical_channel_config,
        rrm_ue_context_t
        *p_rrm_ue_context
        )
{

/* BUG 12173 Handling + */
  U32                             feature_group_indicator = RRM_ZERO;
  U32                             sps_fgi_presnt = RRM_ZERO;
    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
     {
      feature_group_indicator =  p_rrm_ue_context->ue_capability_params. rrm_eutra_radio_capability_info. eutra_radio_capability_info_def. feature_group_indicators ;
       sps_fgi_presnt = (feature_group_indicator & (RRM_ONE << (RRM_THIRTY_TWO - RRM_TWENTY_NINE)));
     }
    if(sps_fgi_presnt  &&
/* BUG 12173 Handling - */
    p_rrm_ue_context->ue_capability_params.
			rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
			access_stratum_release == RRM_REL9)
    {
        p_rrm_logical_channel_config->bitmask |=
            RRM_UL_SPECIFIC_PARAMETERS_LC_SR_MASK_R9_PRESENT;
        p_rrm_logical_channel_config->lc_sr_mask_r9 = RRM_ZERO;
    }
}
/*SPR 15713 Fix Start*/
rrm_void_t rrm_calculate_sr_offset(
        U8                 cell_index,
        U16                *p_sr_offset,
        U8                 sr_config_index
        )
{
    U16 sr_periodicity = RRM_ZERO;
    /*SPR 15663 start*/
    U16 n_one_pucch_an = RRM_ZERO;
    /*SPR 15663 end*/
    rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = rrm_cellm_get_cell_context(cell_index);
    /*Cov_fix_87120*/        
    if ( RRM_PNULL != p_rrm_cell_ctx )
    {
        find_sr_periodicity_from_cell_context(p_rrm_cell_ctx, &sr_periodicity, &n_one_pucch_an);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                      "p_rrm_cell_ctx is null ");
        return;
    }
    /*Cov_fix_87120*/        
    switch( sr_periodicity )
    {
        case SR_PERIODICITY_0:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_5MS_START_INDEX;
            break;
        case SR_PERIODICITY_1:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_10MS_START_INDEX;
            break;
        case SR_PERIODICITY_2:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_20MS_START_INDEX;
            break;
        case SR_PERIODICITY_3:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_40MS_START_INDEX;
            break;
        case SR_PERIODICITY_4:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_80MS_START_INDEX;
            break;
            /* SPR 18871 Fix Start */
        case SR_PERIODICITY_5:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_2MS_START_INDEX;
            break;
        case SR_PERIODICITY_6:
            *p_sr_offset = sr_config_index - SR_PERIODICITY_1MS_START_INDEX;
            break;
            /* SPR 18871 Fix Start */

    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            " *p_sr_offset(%d), sr_config_index(%d) sr_periodicity(%d)",
            *p_sr_offset,sr_config_index,sr_periodicity);
    RRM_UT_TRACE_EXIT();
}
/*SPR 15713 Fix End*/

/* SPS - sr_mask_flag CR start */
/******************************************************************************
*   FUNCTION NAME: rrm_set_r9_mask_for_sps 
*   INPUT        : p_rrm_ue_context,qci_val 
*   OUTPUT       : p_rrm_logical_channel_config
*   DESCRIPTION  :
*                  Fills the p_rrm_logical_channel_config 
*   RETURNS      : none
******************************************************************************/
void 
rrm_set_r9_mask_for_sps(
        rrm_logical_channel_config_t  *p_rrm_logical_channel_config,
        rrm_ue_context_t              *p_rrm_ue_context,
        U8                             qci_val
        )
{
    rrm_cell_context_t      *p_cell_context = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*cov_fix_65821_start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /*cov_fix_65821_end*/
    /*+ Coverity CID : 28821 +*/
    if((RRM_ONE <= qci_val) && (qci_val <= RRM_NINE))
    {
        if (RRM_ZERO != p_cell_context->epc_info.epc_params.qos_config_params[qci_val-RRM_ONE].sr_mask_flag)
        {
            p_rrm_logical_channel_config->bitmask |=
                RRM_UL_SPECIFIC_PARAMETERS_LC_SR_MASK_R9_PRESENT;
            p_rrm_logical_channel_config->lc_sr_mask_r9 = RRM_ZERO;
        }
    }
    /*- Coverity CID : 28821 -*/
    else 
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Invalid QCI value [%d]", qci_val);
    }
    RRM_UT_TRACE_EXIT();
}
/* SPS - sr_mask_flag CR end */

/* HO restriction list  */
/*SPR 21848 Start*/
/******************************************************************************
 *   FUNCTION NAME : rrm_release_ho_restriction_list 
 *   INPUT         : ho_restriction_list 
 *   OUTPUT        : none
 *   DESCRIPTION   : Release Memory of ho restriction list
 * 
 *****************************************************************************/
rrm_void_t
rrm_release_ho_restriction_list(rrm_ho_restriction_list_t   * p_ho_restriction_list)
{
    U8 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ho_restriction_list->equiv_plmn_list.p_equiv_plmn)
    {
        RRM_MEM_FREE(p_ho_restriction_list->equiv_plmn_list.p_equiv_plmn);
    }
    if(RRM_PNULL != p_ho_restriction_list->forbidden_ta_list.p_forbidden_ta)
    {
        for(count = RRM_ZERO; count < p_ho_restriction_list->forbidden_ta_list.count; count++)
        {
            if(RRM_PNULL != p_ho_restriction_list->forbidden_ta_list.p_forbidden_ta[count].forbidden_tac.p_forbidden_tac)
            {
                RRM_MEM_FREE(p_ho_restriction_list->forbidden_ta_list.p_forbidden_ta[count].forbidden_tac.p_forbidden_tac);
            }
        }
        RRM_MEM_FREE(p_ho_restriction_list->forbidden_ta_list.p_forbidden_ta);
    }
    if(RRM_PNULL != p_ho_restriction_list->forbidden_la_list.p_forbidden_la)
    {
        for(count = RRM_ZERO; count < p_ho_restriction_list->forbidden_la_list.count; count++)
        {
            if(RRM_PNULL != p_ho_restriction_list->forbidden_la_list.p_forbidden_la[count].forbidden_lacs_list.p_forbidden_lac)
            {
                RRM_MEM_FREE(p_ho_restriction_list->forbidden_la_list.p_forbidden_la[count].forbidden_lacs_list.p_forbidden_lac);
            }
        }
        RRM_MEM_FREE(p_ho_restriction_list->forbidden_la_list.p_forbidden_la);
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME : rrm_ue_fill_ho_restriction_la_list_from_proc_data_to_ue_context
 *   INPUT         : p_rrm_ho_restriction_list
 *   OUTPUT        : p_rrm_ho_restriction_list
 *   DESCRIPTION   : Fill the ho_restriction_la_list into ue_context  from proc_data structure
 *   RETURNS       :  none
*******************************************************************************/
rrm_void_t
rrm_ue_fill_ho_restriction_la_list_from_proc_data_to_ue_context
(
    rrm_ho_restriction_list_t  * p_rrm_ho_restriction_list,
    rrm_ho_restriction_list_t      * p_rrc_ho_restriction_list
)
{
    rrm_forbidden_la_list_t         *p_forbidden_la_list = RRM_PNULL;
    rrm_forbidden_la_list_t     *p_forbidden_la_dst_list = RRM_PNULL;
    rrm_forbidden_lac_list_t        *p_forbidden_lac_list = RRM_PNULL;
    rrm_forbidden_lac_list_t    *p_forbidden_lac_dst_list = RRM_PNULL;
    rrm_plmn_identity_t             *p_plmn_id = RRM_PNULL;
    rrm_plmn_identity_t         *p_rrm_plmn_id = RRM_PNULL;
    U16                         la_count = RRM_ZERO;
    U16                         lac_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_LA_LIST_PRESENT)
        {
            p_forbidden_la_list = &(p_rrc_ho_restriction_list->forbidden_la_list);
            p_forbidden_la_dst_list = &(p_rrm_ho_restriction_list->forbidden_la_list);
            p_forbidden_la_dst_list->count = p_forbidden_la_list->count;
            /*SPR 20589 FIX START*/
            /*SPR 21848 Start*/
            if(RRM_NULL!= p_forbidden_la_dst_list->p_forbidden_la)
            {
                RRM_MEM_FREE(p_forbidden_la_dst_list->p_forbidden_la);
            }
            p_forbidden_la_dst_list->p_forbidden_la=(rrm_forbidden_la_t *)rrm_mem_get(p_forbidden_la_list->count*sizeof(rrm_forbidden_la_t)); 
            /*SPR 21848 End*/

            /*SPR 20589 FIX END*/
            for(la_count = RRM_ZERO; la_count < p_forbidden_la_list->count; la_count++)
            {
            /*SPR 20589 FIX START*/
                p_rrm_plmn_id = &(p_forbidden_la_dst_list->p_forbidden_la[la_count].plmn_identity);
                p_plmn_id = &(p_forbidden_la_list->p_forbidden_la[la_count].plmn_identity);
            /*SPR 20589 FIX END*/
                if(p_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
                {
                    p_rrm_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                    RRM_MEMCPY(p_rrm_plmn_id->mcc,p_plmn_id->mcc,MCC_OCTET_SIZE);
                }
                p_rrm_plmn_id->mnc.count = p_plmn_id->mnc.count;
                RRM_MEMCPY(p_rrm_plmn_id->mnc.mnc, p_plmn_id->mnc.mnc,  MAX_MNC_OCTET_SIZE);

                p_forbidden_lac_list = & (p_forbidden_la_list->p_forbidden_la[la_count].forbidden_lacs_list);
            /*SPR 20589 FIX START*/
                p_forbidden_lac_dst_list = & (p_forbidden_la_dst_list->p_forbidden_la[la_count].forbidden_lacs_list);
                p_forbidden_lac_dst_list->count = p_forbidden_lac_list->count;
                /*SPR 21848 Start*/
                if(RRM_NULL != p_forbidden_lac_dst_list->p_forbidden_lac)
                {
                    RRM_MEM_FREE(p_forbidden_lac_dst_list->p_forbidden_lac);
                }
                /*SPR 21848 End */ 
                p_forbidden_lac_dst_list->p_forbidden_lac=(rrm_forbidden_lac_t *)rrm_mem_get
                                                     (p_forbidden_lac_dst_list->count*sizeof(rrm_forbidden_lac_t)); 
                for(lac_count=RRM_ZERO; lac_count < p_forbidden_lac_dst_list->count; lac_count++)
                {
                    RRM_MEMCPY(p_forbidden_lac_dst_list->p_forbidden_lac[lac_count].lac,p_forbidden_lac_list->p_forbidden_lac[lac_count].lac, RRM_TWO);
            /*SPR 20589 FIX END*/
                }      
            }
        }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME : rrm_ue_fill_ho_restriction_ta_list_from_proc_data_to_ue_context
 *   INPUT         : p_rrm_ho_restriction_list
 *   OUTPUT        : p_rrm_ho_restriction_list
 *   DESCRIPTION   : Fill the ho_restriction_ta_list into ue_context from proc_data structure
 *   RETURNS       :  none
*******************************************************************************/
rrm_void_t
rrm_ue_fill_ho_restriction_ta_list_from_proc_data_to_ue_context
(
    rrm_ho_restriction_list_t  * p_rrm_ho_restriction_list,
    rrm_ho_restriction_list_t      * p_rrc_ho_restriction_list
)
{
    rrm_forbidden_ta_list_t         *p_forbidden_ta_list = RRM_PNULL;
    rrm_forbidden_ta_list_t     *p_forbidden_ta_dst_list = RRM_PNULL;
    rrm_forbidden_tac_list_t        *p_forbidden_tac_list = RRM_PNULL;
    rrm_forbidden_tac_list_t    *p_forbidden_tac_dst_list = RRM_PNULL;
    rrm_plmn_identity_t             *p_plmn_id = RRM_PNULL;
    rrm_plmn_identity_t         *p_rrm_plmn_id = RRM_PNULL;
    U16                         ta_count = RRM_ZERO;
    U16                         tac_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
        if(p_rrc_ho_restriction_list->bitmask &  HO_RESTRICTION_FORBIDDEN_TA_LIST_PRESENT)
        {
            p_forbidden_ta_list = &(p_rrc_ho_restriction_list->forbidden_ta_list);    
            p_forbidden_ta_dst_list = &(p_rrm_ho_restriction_list->forbidden_ta_list);    
            p_forbidden_ta_dst_list->count = p_forbidden_ta_list->count;
            /*SPR 20589 FIX START*/
            /*SPR 21848 Start*/
            if(RRM_NULL != p_forbidden_ta_dst_list->p_forbidden_ta)
            {
                RRM_MEM_FREE(p_forbidden_ta_dst_list->p_forbidden_ta);
            }
            /*SPR 21848 End*/
            p_forbidden_ta_dst_list->p_forbidden_ta=(rrm_forbidden_ta_t *)rrm_mem_get(p_forbidden_ta_dst_list->count*sizeof(rrm_forbidden_ta_t)); 
            for(ta_count = RRM_ZERO; ta_count < p_forbidden_ta_list->count; ta_count++)
            {
                p_rrm_plmn_id = &(p_forbidden_ta_dst_list->p_forbidden_ta[ta_count].plmn_identity);
            /*SPR 20589 FIX END*/
                p_plmn_id = &(p_forbidden_ta_list->p_forbidden_ta[ta_count].plmn_identity);

                if(p_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
                {
                    p_rrm_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                    RRM_MEMCPY(p_rrm_plmn_id->mcc, p_plmn_id->mcc, MCC_OCTET_SIZE);
                }
                p_rrm_plmn_id->mnc.count = p_plmn_id->mnc.count;
                RRM_MEMCPY( p_rrm_plmn_id->mnc.mnc, p_plmn_id->mnc.mnc,MAX_MNC_OCTET_SIZE);

                p_forbidden_tac_list = & (p_forbidden_ta_list-> p_forbidden_ta[ta_count].forbidden_tac);
            /*SPR 20589 FIX START*/
                p_forbidden_tac_dst_list = & (p_forbidden_ta_dst_list-> p_forbidden_ta[ta_count].forbidden_tac);
                p_forbidden_tac_dst_list->count = p_forbidden_tac_list->count;
                /*SPR 21848 Start*/
                if(RRM_NULL != p_forbidden_tac_dst_list->p_forbidden_tac)
                {

                    RRM_MEM_FREE(p_forbidden_tac_dst_list->p_forbidden_tac);
                }

                /*SPR 21848 End*/
                p_forbidden_tac_dst_list->p_forbidden_tac=(rrm_forbidden_tac_t *)rrm_mem_get(p_forbidden_tac_dst_list->count*sizeof(rrm_forbidden_tac_t)); 
                for(tac_count=RRM_ZERO; tac_count < p_forbidden_tac_dst_list->count; tac_count++)
                {
                    RRM_MEMCPY(p_forbidden_tac_dst_list->p_forbidden_tac[tac_count].tac,p_forbidden_tac_list->p_forbidden_tac[tac_count].tac, RRM_TWO);
            /*SPR 20589 FIX END*/
                }      
            }
        }
    RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME : rrm_ue_fill_restriction_list_from_proc_data_to_ue_context
 *   INPUT         : p_rrm_ho_restriction_list
 *   OUTPUT        : p_rrm_ho_restriction_list
 *   DESCRIPTION   : Fill the ho_restriction_list into ue_context from proc_data  structure
 *   RETURNS       :  none
*******************************************************************************/
rrm_void_t
rrm_ue_fill_restriction_list_from_proc_data_to_ue_context
(
rrm_ho_restriction_list_t  * p_rrm_ho_restriction_list,
rrm_ho_restriction_list_t  *p_rrc_ho_restriction_list 
)
{
   rrm_plmn_identity_t             *p_plmn_id = RRM_PNULL;
   rrm_plmn_identity_t         *p_rrm_plmn_id = RRM_PNULL;
   U16                         equiv_count = RRM_ZERO;

   RRM_UT_TRACE_ENTER();

    if( (RRM_PNULL != p_rrm_ho_restriction_list) &&
        (RRM_PNULL != p_rrc_ho_restriction_list))
    {
        p_rrm_ho_restriction_list->bitmask = p_rrc_ho_restriction_list->bitmask;
        if( (p_rrc_ho_restriction_list->serving_plmn_identity.presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG) ||
            (p_rrc_ho_restriction_list->serving_plmn_identity.mnc.count != RRM_ZERO))
        {
                p_rrm_plmn_id = &(p_rrm_ho_restriction_list->serving_plmn_identity);
                p_plmn_id = &(p_rrc_ho_restriction_list->serving_plmn_identity);
                if(p_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
                {
                    p_rrm_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                    RRM_MEMCPY(p_rrm_plmn_id->mcc,p_plmn_id->mcc,MCC_OCTET_SIZE);
                }
                p_rrm_plmn_id->mnc.count = p_plmn_id->mnc.count;
                RRM_MEMCPY(p_rrm_plmn_id->mnc.mnc, p_plmn_id->mnc.mnc,  MAX_MNC_OCTET_SIZE);

        }
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_EQUIV_PLMN_LIST_PRESENT)
        {
            p_rrm_ho_restriction_list->equiv_plmn_list.count = p_rrc_ho_restriction_list->equiv_plmn_list.count;
            /*SPR 20589 FIX START*/
            /*SPR 21848 Start*/
            if(RRM_NULL != p_rrm_ho_restriction_list->equiv_plmn_list.p_equiv_plmn)
            {
                RRM_MEM_FREE(p_rrm_ho_restriction_list->equiv_plmn_list.p_equiv_plmn); 
            }
            /*SPR 21848 End*/
            p_rrm_ho_restriction_list->equiv_plmn_list.p_equiv_plmn=(rrm_equiv_plmn_t *)
                                                                  rrm_mem_get(p_rrm_ho_restriction_list->equiv_plmn_list.count*sizeof(rrm_equiv_plmn_t)); 
            for(equiv_count = RRM_ZERO; equiv_count <p_rrc_ho_restriction_list->equiv_plmn_list.count;equiv_count++)
            {
                p_rrm_plmn_id = &(p_rrm_ho_restriction_list->equiv_plmn_list.p_equiv_plmn[equiv_count].plmn_identity);
            /*SPR 20589 FIX END*/
                p_plmn_id = &(p_rrc_ho_restriction_list->equiv_plmn_list.p_equiv_plmn[equiv_count].plmn_identity);
                if(p_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
                {
                    p_rrm_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                    RRM_MEMCPY(p_rrm_plmn_id->mcc,p_plmn_id->mcc,MCC_OCTET_SIZE);
                }
                p_rrm_plmn_id->mnc.count = p_plmn_id->mnc.count;
                RRM_MEMCPY(p_rrm_plmn_id->mnc.mnc, p_plmn_id->mnc.mnc,  MAX_MNC_OCTET_SIZE);
            }
        }
        /* Klocwork_fix_march_14_start */
        rrm_ue_fill_ho_restriction_la_list_from_proc_data_to_ue_context(p_rrm_ho_restriction_list, p_rrc_ho_restriction_list);
        rrm_ue_fill_ho_restriction_ta_list_from_proc_data_to_ue_context(p_rrm_ho_restriction_list, p_rrc_ho_restriction_list);
        /* Klocwork_fix_march_14_end */
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT)
        {
            p_rrm_ho_restriction_list->forbidden_inter_rat = p_rrc_ho_restriction_list->forbidden_inter_rat;
        }

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                  " p_rrm_ho_restriction_list or p_rrm_ho_restriction_list is NULL ");
    }

   RRM_UT_TRACE_EXIT();
}
/*SPR 21848 End*/
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_ul_specific_parameters
 *   INPUT        : p_rrm_ue_cntxt,p_rlc_layer_params
 *   OUTPUT       : p_rrm_logical_channel_config
 *   DESCRIPTION  :
 *                  Fills the rrm_srb_ul_specific_parameters_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_ul_specific_parameters(
        rrm_logical_channel_config_t *p_rrm_logical_channel_config,
         /*SPR 17777 +-*/
        rrm_ue_context_t   *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_logical_channel_config->bitmask |= 
        RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT;
    rrm_rrc_ue_adm_resp_fill_srb1_ul_specific_parameters_explicit
        (&(p_rrm_logical_channel_config->ul_specific_parameters_explicit));
         /*SPR 17777 +-*/
    rrm_set_r9_mask(p_rrm_logical_channel_config,p_rrm_ue_cntxt);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_mac_lc_config_enb
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrm_mac_lc_config
 *   DESCRIPTION  :
 *                   Fills the rrm_mac_lc_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_mac_lc_config_enb(
        rrm_mac_lc_config_t *p_rrm_mac_lc_config
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_mac_lc_config->bitmask |= RRM_MAC_LC_CONFIG_UL_LC_G_ID_PRESENT;
    p_rrm_mac_lc_config->ul_lc_g_id = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_LOGICAL_CHANNEL_GROUP;
    p_rrm_mac_lc_config->bitmask |= RRM_MAC_LC_CONFIG_DL_PRIORITY_PRESENT;
    p_rrm_mac_lc_config->dl_lch_priority = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_0_PRIORITY;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_config
 *   INPUT        : p_rlc_layer_params,p_rrm_ue_cntxt
 *   OUTPUT       : p_rrm_srb1_config
 *   DESCRIPTION  :
 *                  Fills the rrm_srb_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_config(
        rrm_srb_config_t   *p_rrm_srb1_config,
        rlc_layer_params_t *p_rlc_layer_params,
        rrm_ue_context_t   *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /* Start CSR 00059256 */
    if (p_rlc_layer_params->rlc_layer_param_srb[RRM_ZERO].default_configuration == RRM_FALSE)
    {
        p_rrm_srb1_config->bitmask |= RRM_SRB_CONFIG_AM_CONFIG_PRESENT;
        rrm_rrc_ue_adm_resp_fill_srb1_am_config
            (&(p_rrm_srb1_config->srb_am_config),p_rlc_layer_params);
    }
    /* End CSR 00059256 */
    p_rrm_srb1_config->bitmask |= RRM_SRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT;
    rrm_rrc_ue_adm_resp_fill_srb1_ul_specific_parameters
         /*SPR 17777 +-*/
        (&(p_rrm_srb1_config->logical_channel_config),
           p_rrm_ue_cntxt);
    p_rrm_srb1_config->bitmask |= RRM_SRB_CONFIG_MAC_LC_CONFIG_ENB_PRESENT;
    rrm_rrc_ue_adm_resp_fill_srb1_mac_lc_config_enb
        (&(p_rrm_srb1_config->mac_lc_config_enb));
         /*SPR 17777 +-*/
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_srb1_info
 *   INPUT        : p_rlc_layer_params,p_rrm_ue_cntxt
 *   OUTPUT       : p_rrm_srb_info
 *   DESCRIPTION  :
 *                  filling for srb info of radio_res_config of ue admission response
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_srb1_info(
        rrm_srb_info_t     *p_rrm_srb_info,
        rlc_layer_params_t *p_rlc_layer_params,
        rrm_ue_context_t   *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_srb_info->bitmask |= RRM_SRB_INFO_SRB1_CONFIG_PRESENT;   
    rrm_rrc_ue_adm_resp_fill_srb1_config
        (&(p_rrm_srb_info->srb1_config),p_rlc_layer_params,
         p_rrm_ue_cntxt);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_ue_adm_resp_tti_bundling
 *   INPUT        : tti_bundling_ue_profile,p_rrm_ue_context
 *   OUTPUT       : tti_bundling_adm_resp
 *   DESCRIPTION  :
 *                  filling for tti_bundling of ue admission resp
 *   RETURNS      :
 *                   none 
 ******************************************************************************/

void
fill_ue_adm_resp_tti_bundling(
                                U8                    *tti_bundling_adm_resp
         /*SPR 17777 +-*/
                             )   
{

    RRM_UT_TRACE_ENTER();
   /*Start changes for TTI bundling feature*/
   *tti_bundling_adm_resp = RRM_FALSE; 
   /*End changes for TTI bundling feature*/
   RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_ul_sch_config
 *   INPUT        : p_ue_profile_ul_sch_config,p_rrm_ue_context
 *   OUTPUT       : p_rrc_ul_sch_config
 *   DESCRIPTION  :
 *                  Fills the rrc_ul_sch_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_ul_sch_config(
        rrc_ul_sch_config_t                     *p_rrc_ul_sch_config
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
        
        p_rrc_ul_sch_config->bitmask |= RRC_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT;
        p_rrc_ul_sch_config->max_harq_tx = 
            RRM_DEFINED_DEFAULT_VALUE_FOR_MAX_HARQ_TX_UE_ADMSN;

        p_rrc_ul_sch_config->bitmask |= 
            RRC_UL_SCH_CONFIG_PERIODIC_BSR_TIMER_PRESENT;
        p_rrc_ul_sch_config->periodic_bsr_timer = 
            RRM_DEFINED_DEFAULT_VALUE_FOR_PERIODIC_BSR_TIMER_UE_ADMSN;
    
    p_rrc_ul_sch_config->retx_bsr_timer = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_RETX_BSR_TIMER_UE_ADMSN;

    fill_ue_adm_resp_tti_bundling(&(p_rrc_ul_sch_config->tti_bundling));
         /*SPR 17777 +-*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_ue_adm_resp_time_alignment_timer
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_time_alignment_timer_dedicated
 *   DESCRIPTION  :
 *                  filling for time alignment timer of ue admission resp
 *   RETURNS      : none
 ******************************************************************************/

void
fill_ue_adm_resp_time_alignment_timer(
                                        U8* p_time_alignment_timer_dedicated,
                                        rrm_ue_context_t *p_rrm_ue_context
                                      )
{
    rrm_cell_index_t cell_index;
    RRM_UT_TRACE_ENTER();
    cell_index = p_rrm_ue_context->cell_index;
    *p_time_alignment_timer_dedicated = rrm_cellm_get_time_alignment_timer(cell_index) ;
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_sr_prohibit_timer_r9
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_mac_main_config
 *   DESCRIPTION  :
 *                  filling for sr_prohibit_timer_r9 
 *   RETURNS      :
 *                  none 
 ******************************************************************************/

rrm_return_et
fill_sr_prohibit_timer_r9(
        rrc_mac_main_config_t *p_rrc_mac_main_config,
        rrm_ue_context_t *p_rrm_ue_context
        )
{

/*SPR 5169 start*/
    epc_params_t         *p_epc_params = RRM_NULL;;
    rrm_cell_index_t     cell_index = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t *p_successful_erbs = RRM_NULL;
    U16                  drb_count = RRM_ZERO;
    U16                  qos_count = RRM_ZERO;
    /* SPR 14029 FIX : code deleted */
    U8                   sr_timer_r9_new = RRM_ZERO;
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    cell_index = p_rrm_ue_context->cell_index;
    p_epc_params = rrm_cellm_get_erb_service_profile(cell_index);

    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    if ((RRM_NULL != p_epc_params) &&
                         (RRM_NULL != p_successful_erbs))
    {
        /* Coverity_fix_start_55011 */
        for (drb_count = RRM_ZERO; 
                ((drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE ));
                drb_count++)
        {
        /* Coverity_fix_end_55011 */
            for (qos_count = RRM_ZERO;
                 qos_count < p_epc_params->num_valid_qos_profiles; qos_count++)
            {
                if (p_successful_erbs->erab_item[drb_count].
                    erab_level_qos_params.qci ==
                    p_epc_params->qos_config_params[qos_count].qci)
                {
                    /* SPR 14029 FIX : code deleted */
                    /*Get the r9 timer value for the 1st rab*/
                    if (RRM_ZERO == drb_count)
                    {
                    /* SPR 14029 FIX START */
                        sr_timer_r9_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                                                     mac_config.sr_prohibit_timer_r9);
                    /* SPR 14029 FIX END */
                    }
                    else
                    {
                        /*Minimum value of r9 timer is taken among all QCIs*/
                        if ((sr_timer_r9_new) >
                    /* SPR 14029 FIX START */
                                           (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                    /* SPR 14029 FIX END */
                                                                     mac_config.sr_prohibit_timer_r9))
                        {
                            sr_timer_r9_new =
                    /* SPR 14029 FIX START */
                            p_epc_params->qos_config_params[qos_count].erb_service_profile.mac_config.
                    /* SPR 14029 FIX END */
                                                                           sr_prohibit_timer_r9;
                        }
                    }
                }
            }
        }

        /*Value of sr_prohibit_timer_r9 to be send is minimum of all QCIs,
         *admitted or new. Compare current minimum value with the one sent
         *in response to last admitted rab as well.
         */
        if ((RRM_ZERO != p_rrm_ue_context->drb_configured.num_of_list) &&
            (sr_timer_r9_new > (p_rrm_ue_context->sr_timer_r9_bkp)))
        {
            sr_timer_r9_new = p_rrm_ue_context->sr_timer_r9_bkp;
        }
        /*Update new value in ue context. Replace backup value
         *with the new one on getting successful response from
         *RRC.
         */
        p_rrm_ue_context->sr_timer_r9_new = sr_timer_r9_new;

        p_rrc_mac_main_config->bitmask |=
            RRC_MAC_MAIN_CONFIG_SR_PROHIBIT_TIMER_R9_PRESENT;
        p_rrc_mac_main_config->sr_prohibit_timer_r9 = sr_timer_r9_new;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                  " p_epc_params or p_successful_erbs is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
/*SPR 5169 end*/
}
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_admission_fill_sr_prohibit_timer_r9
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_mac_main_config
 *   DESCRIPTION  :
 *                  filling for sr_prohibit_timer_r9 
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
rrm_void_t
rrm_rrc_ue_admission_fill_sr_prohibit_timer_r9(
        rrc_mac_main_config_t *p_rrc_mac_main_config,
        rrm_ue_context_t *p_rrm_ue_context
        )
{
    RRM_UT_TRACE_ENTER();

    p_rrc_mac_main_config->bitmask |=
        RRC_MAC_MAIN_CONFIG_SR_PROHIBIT_TIMER_R9_PRESENT;
    p_rrc_mac_main_config->sr_prohibit_timer_r9 = RRM_DEFINED_DEFAULT_VALUE_FOR_SR_PROHIBIT_TMR_UE_ADMSN;

    /* Update new value in ue context */
    p_rrm_ue_context->sr_timer_r9_new     = p_rrc_mac_main_config->sr_prohibit_timer_r9;
    p_rrm_ue_context->sr_timer_r9_bkp = p_rrc_mac_main_config->sr_prohibit_timer_r9;

    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME:  rrm_rrc_erb_setup_resp_fill_phr_config_param
 *   INPUT        : p_ue_profilr_phr_config_param
 *   OUTPUT       : p_rrc_phr_config_param
 *   DESCRIPTION  :
 *                  Fills the rrc_phr_config_param_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 *****************************************************************************/
rrm_return_et
rrm_rrc_erb_setup_resp_fill_phr_config_param(
        rrc_phr_config_param_t *p_rrc_phr_config_param,
        rrm_ue_context_t  *p_rrm_ue_ctxt
        )
{
    epc_params_t         *p_epc_params = RRM_NULL;;
    rrm_cell_index_t     cell_index = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t *p_successful_erbs = RRM_NULL;
    U16                  drb_count = RRM_ZERO;
    U16                  qos_count = RRM_ZERO;
    /* SPR 14029 FIX : code deleted */
    U8                   periodic_phr_timer_new = RRM_ZERO;
    U8                   prohibit_phr_timer_new = RRM_ZERO;
    U8                   dl_pathloss_change_new = RRM_ZERO;
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    cell_index = p_rrm_ue_ctxt->cell_index;
    p_epc_params = rrm_cellm_get_erb_service_profile(cell_index);

    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_ctxt->current_procedure.p_erb_success_list);

    if ((RRM_NULL != p_epc_params) &&
                         (RRM_NULL != p_successful_erbs))
    {
        /* Coverity_fix_start_62542 */
        for (drb_count = RRM_ZERO; ((drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE));
                drb_count++)
        {
        /* Coverity_fix_end_62542 */
            for (qos_count = RRM_ZERO;
                    qos_count < p_epc_params->num_valid_qos_profiles; qos_count++)
            {
                if (p_successful_erbs->erab_item[drb_count].
                        erab_level_qos_params.qci ==
                        p_epc_params->qos_config_params[qos_count].qci)
                {
                    /* SPR 14029 FIX : code deleted */
                    /*Get the r9 timer value for the 1st rab*/
                    if (RRM_ZERO == drb_count)
                    {
                    /* SPR 14029 FIX START */
                        periodic_phr_timer_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                phr_config.phr_config_param.periodic_phr_timer);

                        prohibit_phr_timer_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                phr_config.phr_config_param.prohibit_phr_timer);

                        dl_pathloss_change_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                phr_config.phr_config_param.dl_pathloss_change);
                    /* SPR 14029 FIX END */
                    }
                    else
                    {
                        /*Minimum value of r9 timer is taken among all QCIs*/
                        if ((periodic_phr_timer_new ) >
                    /* SPR 14029 FIX START */
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                    /* SPR 14029 FIX END */
                                 phr_config.phr_config_param.periodic_phr_timer))
                        {
                            periodic_phr_timer_new =
                    /* SPR 14029 FIX START */
                                p_epc_params->qos_config_params[qos_count].erb_service_profile.
                    /* SPR 14029 FIX END */
                                phr_config.phr_config_param.periodic_phr_timer;
                        }

                    /* SPR 14029 FIX START */
                        if ((prohibit_phr_timer_new) >
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                 phr_config.phr_config_param.prohibit_phr_timer))
                        {
                            prohibit_phr_timer_new =
                                p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                phr_config.phr_config_param.prohibit_phr_timer;
                        }
                        if ((dl_pathloss_change_new) >
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                 phr_config.phr_config_param.dl_pathloss_change))
                        {
                            dl_pathloss_change_new =
                                p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                phr_config.phr_config_param.dl_pathloss_change;
                    /* SPR 14029 FIX END */
                        }
                    }
                }
            }
        }
        p_rrc_phr_config_param->periodic_phr_timer = periodic_phr_timer_new ;
        p_rrc_phr_config_param->prohibit_phr_timer = prohibit_phr_timer_new ;
        p_rrc_phr_config_param->dl_pathloss_change = dl_pathloss_change_new ;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                  " p_epc_params or p_successful_erbs is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_erb_setup_resp_fill_phr_config 
 *   INPUT        : p_ue_profile_phr_config
 *   OUTPUT       : p_rrc_phr_config
 *   DESCRIPTION  :
 *                  Fills the rrc_phr_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 *****************************************************************************/

rrm_return_et
rrm_rrc_erb_setup_resp_fill_phr_config(
        rrc_phr_config_t  *p_rrc_phr_config,
        rrm_ue_context_t  *p_rrm_ue_ctxt
        )
{
    rrm_return_et  ret_val = RRM_SUCCESS;
    p_rrc_phr_config->bitmask |= RRC_PHR_CONFIG_PARAM_PRESENT;
    rrm_rrc_erb_setup_resp_fill_phr_config_param 
        (&(p_rrc_phr_config->phr_config_param) ,
           p_rrm_ue_ctxt
           );
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_phr_config_param
 *   INPUT        : p_ue_profilr_phr_config_param
 *   OUTPUT       : p_rrc_phr_config_param
 *   DESCRIPTION  :
 *                  Fills the rrc_phr_config_param_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 *****************************************************************************/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_phr_config_param(
        rrc_phr_config_param_t *p_rrc_phr_config_param
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    p_rrc_phr_config_param->periodic_phr_timer =
        RRM_DEFINED_DEFAULT_VALUE_FOR_PERIODIC_PHR_TIMER_UE_ADMSN;
    p_rrc_phr_config_param->prohibit_phr_timer =
        RRM_DEFINED_DEFAULT_VALUE_FOR_PROHIBIT_PHR_TIMER_UE_ADMSN;
    p_rrc_phr_config_param->dl_pathloss_change =
        RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PATHLOSS_CHANGE_UE_ADMSN;
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_phr_config
 *   INPUT        : p_ue_profile_phr_config
 *   OUTPUT       : p_rrc_phr_config
 *   DESCRIPTION  :
 *                  Fills the rrc_phr_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 *****************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_phr_config(
        rrc_phr_config_t *p_rrc_phr_config
        )
{
    rrm_return_et  ret_val = RRM_SUCCESS;
    p_rrc_phr_config->bitmask |= RRC_PHR_CONFIG_PARAM_PRESENT;
    rrm_rrc_ue_adm_resp_fill_phr_config_param
        (&(p_rrc_phr_config->phr_config_param));
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_mac_main_config
 *   INPUT        : p_ue_profile_mac_main_config,p_rrm_ue_cntxt
 *   OUTPUT       : p_rrc_mac_main_config
 *   DESCRIPTION  :
 *                  Fills the rrc_mac_main_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_mac_main_config(
        rrc_mac_main_config_t                    *p_rrc_mac_main_config,
        rrc_mac_main_config_ue_service_profile_t *p_ue_profile_mac_main_config,
        rrm_ue_context_t                         *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    //rrc_drx_config_type_et          drx_config_type_enum;    
    /*SPR_16942_START*/
    /* Code removed */
    /*SPR_16942_END*/
    RRM_UT_TRACE_ENTER();

    /*SPR 13647 changes start */
    if((p_rrm_ue_cntxt->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) && (p_rrm_ue_cntxt->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release > 0)) 
    {
        rrm_rrc_ue_admission_fill_sr_prohibit_timer_r9(p_rrc_mac_main_config,p_rrm_ue_cntxt);
    } 
    /*SPR 13647 changes end */
    /*SPR_16942_START*/
    /* Code removed */
    /*SPR_16942_END*/
    /* p_rrc_mac_main_config->bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;
    drx_config_type_enum = RRC_DRX_CONFIG_TYPE_REL;
    p_rrc_mac_main_config->drx_config.drx_config_type = drx_config_type_enum;*/

/*    if(p_ue_profile_mac_main_config->bitmask &
            RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT) */
    /*SPR_16942_START*/
    if((p_ue_profile_mac_main_config->bitmask &
            RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT) &&
        (p_ue_profile_mac_main_config->phr_config.bitmask &
            RRC_SERVICE_PROFILE_PHR_CONFIG_PARAM_PRESENT)
      )
    /*SPR_16942_END*/
    {
        p_rrc_mac_main_config->bitmask |=
            RRC_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT;
        rrm_rrc_ue_adm_resp_fill_phr_config
            (&(p_rrc_mac_main_config->phr_config));
    }

    if(p_ue_profile_mac_main_config->bitmask &
            RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT)
    {
        p_rrc_mac_main_config->bitmask |=
            RRC_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT;
        rrm_rrc_ue_adm_resp_fill_phr_config
            (&(p_rrc_mac_main_config->phr_config));
    }

    /* LTE_RRM_MALL, CID 11111 */
    if( p_ue_profile_mac_main_config->bitmask & 
            RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT)
    {
        p_rrc_mac_main_config->bitmask |= 
            RRC_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT;
        rrm_rrc_ue_adm_resp_fill_ul_sch_config
            (&(p_rrc_mac_main_config->ul_sch_config));
         /*SPR 17777 +-*/
    }
    fill_ue_adm_resp_time_alignment_timer(
            &(p_rrc_mac_main_config->time_alignment_timer_dedicated),
            p_rrm_ue_cntxt);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_pc_max
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_pc_max
 *   DESCRIPTION  :
 *                  filling for pc_max of erb setup/mdify resp and
 *                  ue adm resp
 *   RETURNS      :
 *                  none 
 ******************************************************************************/

void
fill_pc_max(
                           S8* p_pc_max,
                           rrm_ue_context_t *p_rrm_ue_context
                       )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_index_t            cell_index;
    S8                          p_max_sib1;
    cell_index = p_rrm_ue_context->cell_index;
    if(rrm_cellm_get_p_max_sib1(cell_index,&p_max_sib1) == RRM_SUCCESS)    
    {
        if(p_max_sib1 < MAX_OUTPUT_POWER)
        {
            *p_pc_max = p_max_sib1;
        }
        else
        {
            *p_pc_max = MAX_OUTPUT_POWER;
        }
    }
    else
    {
        *p_pc_max = MAX_OUTPUT_POWER;
    }
    
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_mac_main_config_extensions
 *   INPUT        : p_rrm_ue_cntxt,ul_mcs,dl_mcs
 *   OUTPUT       : p_rrm_mac_main_config_extensions
 *   DESCRIPTION  :
 *                  Fills the rrm_mac_main_config_extensions_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_mac_main_config_extensions(
        rrm_mac_main_config_extensions_t *p_rrm_mac_main_config_extensions,
        rrm_ue_context_t                 *p_rrm_ue_cntxt,
        U8                               ul_mcs,
        U8                               dl_mcs,
        rrc_mac_main_config_ue_service_profile_t *p_ue_profile_mac_main_config
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U8                              num_of_layer= RRM_ZERO; /* Kshitij: CID 16595 */
    /* Bug 21402 Fix starts */
    U8                              dl_bandwidth = RRM_ZERO;
    /* Bug 21402 Fix ends */
    rrm_cell_index_t                cell_index;
    rrmc_mac_config_t               *p_rrmc_mac_config = RRM_PNULL;
    rrm_icic_scheme_type_et         icic_scheme = ICIC_SCHEME_NONE; 
    rrm_cell_context_t              *p_cell_ctx = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    cell_index = p_rrm_ue_cntxt->cell_index;
    p_cell_ctx = rrm_cellm_get_cell_context(cell_index);
    /*cov_fix_65816_start*/
    if (RRM_PNULL == p_cell_ctx )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*cov_fix_65816_end*/
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(cell_index); 

    p_rrm_mac_main_config_extensions->ue_priority = MAC_UE_PRIORITY;
    p_rrm_mac_main_config_extensions->dl_num_harq_process = 
        p_rrmc_mac_config->dl_num_harq_process;
    p_rrm_mac_main_config_extensions->dl_i_mcs = dl_mcs;
    if(rrm_cellm_get_rrmc_band_width(cell_index,&dl_bandwidth) == RRM_SUCCESS)
    {
        p_rrm_mac_main_config_extensions->dl_max_rb = dl_bandwidth;
    }

    if(p_ue_profile_mac_main_config->ul_sch_config.bitmask &
            RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT)
    {
        p_rrm_mac_main_config_extensions->max_ul_harq_tx = p_ue_profile_mac_main_config->ul_sch_config.max_ul_harq_tx;
    }
    p_rrm_mac_main_config_extensions->ul_i_mcs = ul_mcs;

    /* num of layer is selection should done after transmission mode selection
       as this algo has transmission mode input param. if current tx mode is not updated
       so it will be using the last stored tx mode 
     */
    if ( RRM_SUCCESS == rrm_select_num_of_layer_for_ue( p_rrm_ue_cntxt,
                &num_of_layer) )
    {
        p_rrm_mac_main_config_extensions->num_of_layer = num_of_layer;
    }
    /*CODE_BOOK_INDEX value is changed to 0*/
    p_rrm_mac_main_config_extensions->code_book_index = CODE_BOOK_INDEX;   

    p_rrm_mac_main_config_extensions->bitmask |=  RRM_MAC_MAIN_CONFIG_EXT_PC_MAX_PRESENT;
    /*Calculate pcMax as minimum of 23 and Pemax from cell context*/
    fill_pc_max(&(p_rrm_mac_main_config_extensions->pc_max),
            p_rrm_ue_cntxt);

    /* DYNAMIC_ICIC_CHANGES_START */
    icic_scheme = rrm_cellm_get_icic_scheme_configured_in_cell(cell_index);
    if ((ICIC_SCHEME_SFR  == icic_scheme) ||
            (ICIC_SCHEME_FFR  == icic_scheme)
       )
    {
        p_rrm_mac_main_config_extensions->bitmask |=  
            RRM_MAC_MAIN_CONFIG_EXT_USER_LOCATION_TYPE_PRESENT;
        p_rrm_mac_main_config_extensions->user_location_type = 
            p_rrm_ue_cntxt->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position;   
    }
    /* Coverity_ID : 41579 */
    if (ICIC_SCHEME_SFR  == icic_scheme)
    {
        p_rrm_mac_main_config_extensions->bitmask |=  
            RRM_MAC_MAIN_CONFIG_EXT_MIN_UE_POWER_PRESENT;
        p_rrm_mac_main_config_extensions->min_ue_power = p_cell_ctx->rrm_olpc_config_params.min_ue_power;    
    }
    /* DYNAMIC_ICIC_CHANGES_END */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_mac_config
 *   INPUT        : p_ue_profile_mac_config,p_rrm_ue_cntxt,ul_mcs,dl_mcs
 *   OUTPUT       : p_rrm_mac_config
 *   DESCRIPTION  :
 *                  Fills the rrm_mac_config_t

 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_mac_config(
        rrm_mac_config_t                     *p_rrm_mac_config,
        rrm_mac_config_ue_service_profile_t  *p_ue_profile_mac_config,
        rrm_ue_context_t                     *p_rrm_ue_cntxt,
        U8                                   ul_mcs,
        U8                                   dl_mcs
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrm_mac_config->bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;
    rrm_rrc_ue_adm_resp_fill_mac_main_config
        (&(p_rrm_mac_config->mac_main_config),
         &(p_ue_profile_mac_config->mac_main_config),p_rrm_ue_cntxt); 

    rrm_rrc_ue_adm_resp_fill_mac_main_config_extensions
        (&(p_rrm_mac_config->mac_main_config_extensions),p_rrm_ue_cntxt,ul_mcs,dl_mcs,
           &(p_ue_profile_mac_config->mac_main_config)); 
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_pusch_configuration_dedicated
 *   INPUT        : p_ue_profile_phy_pusch_configuration_dedicated
 *   OUTPUT       : p_rrc_phy_pusch_configuration_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_pusch_configuration_dedicated_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_pusch_configuration_dedicated(
        rrc_phy_pusch_configuration_dedicated_t 
        *p_rrc_phy_pusch_configuration_dedicated,
        rrc_phy_pusch_configuration_dedicated_ue_service_profile_t 
        *p_ue_profile_phy_pusch_configuration_dedicated
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_phy_pusch_configuration_dedicated->beta_offset_ack_index = 
        p_ue_profile_phy_pusch_configuration_dedicated->beta_offset_ack_index ;
    p_rrc_phy_pusch_configuration_dedicated->beta_offset_ri_index = 
        p_ue_profile_phy_pusch_configuration_dedicated->beta_offset_ri_index ;
    p_rrc_phy_pusch_configuration_dedicated->beta_offset_cqi_index = 
        p_ue_profile_phy_pusch_configuration_dedicated->beta_offset_cqi_index ;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_pdsch_configuration_dedicated
 *   INPUT        : p_rrm_physical_layer_params
 *   OUTPUT       : p_rrc_phy_pdsch_configuration_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_pdsch_configuration_dedicated_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
/*DYNAMIC ICIC START*/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_pdsch_configuration_dedicated(
        rrc_phy_pdsch_configuration_dedicated_t 
        *p_rrc_phy_pdsch_configuration_dedicated,
        rrm_ue_context_t                                       
        *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*cov_fix_65817_start*/
    if (RRM_PNULL == p_cell_ctx )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*cov_fix_65817_end*/
    /*
     ** Get the p_a value configured from OAM for Cell Center (CC) UE's.
     */
    if( RRM_UE_POSITION_AT_CELL_EDGE == 
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)   
    {
        p_rrc_phy_pdsch_configuration_dedicated->p_a = p_cell_ctx->dynamic_icic_data.pdsch_config_params.
            pdsch_dedicated_config.pa_for_ce_ue; 
    }
    else
    {
        p_rrc_phy_pdsch_configuration_dedicated->p_a = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a; 
    }


    p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured =
        p_rrc_phy_pdsch_configuration_dedicated->p_a;
    p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_past_data.p_a_configured =
        p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured ;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*DYNAMIC ICIC END*/

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_pucch_configuration_dedicated
 *   INPUT        : p_rrm_physical_layer_params
 *   OUTPUT       : p_rrc_phy_pucch_configuration_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_pucch_configuration_dedicated_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_pucch_configuration_dedicated(
        rrc_phy_pucch_configuration_dedicated_t
         /*SPR 17777 +-*/
        *p_rrc_phy_pucch_configuration_dedicated
#ifdef TDD_MODE_FLAG        
        ,rrm_physical_layer_params_t
        *p_rrm_physical_layer_params
#endif        
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_rrc_phy_pucch_configuration_dedicated->bitmask = RRM_ZERO;
#ifdef TDD_MODE_FLAG    
    if(p_rrm_physical_layer_params->physical_layer_param_pucch.bitmask & PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT)
    {
        p_rrc_phy_pucch_configuration_dedicated->bitmask |= RRC_PHY_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;

        switch(p_rrm_physical_layer_params->physical_layer_param_pucch.tdd_ack_nack_feedback_mode)
        {
           case RRM_ZERO:
              p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode =
                      TDD_ACK_NACK_FEEDBACK_MODE_BUNDLING;
              break;
           case RRM_ONE:
              p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode =
                      TDD_ACK_NACK_FEEDBACK_MODE_MULTIPLEXING;
              break;
           default:   
             RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Incorrect TDD_ACK_NACK_FEEDBACK_MODE(%d)..Hardcoding Mode=Bundling",
                p_rrm_physical_layer_params->physical_layer_param_pucch.tdd_ack_nack_feedback_mode);
              p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode =
                      TDD_ACK_NACK_FEEDBACK_MODE_BUNDLING;
        }
    }
#endif        
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 6810 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_erb_setup_modify_resp_fill_pucch_configuration_dedicated
 *
 *   DESCRIPTION:
 *       Fills the rrc_phy_pucch_configuration_dedicated_t
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_erb_setup_modify_resp_fill_pucch_configuration_dedicated(
        rrc_phy_pucch_configuration_dedicated_t
         /*SPR 17777 +-*/
        *p_rrc_phy_pucch_configuration_dedicated
#ifdef TDD_MODE_FLAG        
        ,rrm_physical_layer_params_t
        *p_rrm_physical_layer_params
#endif        
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_rrc_phy_pucch_configuration_dedicated->bitmask = RRM_ZERO;
#ifdef TDD_MODE_FLAG    
    if(p_rrm_physical_layer_params->physical_layer_param_pucch.bitmask & PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT)
    {
        p_rrc_phy_pucch_configuration_dedicated->bitmask |= RRC_PHY_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;

        switch(p_rrm_physical_layer_params->physical_layer_param_pucch.tdd_ack_nack_feedback_mode)
        {
           case RRM_ZERO:
              p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode =
                      TDD_ACK_NACK_FEEDBACK_MODE_BUNDLING;
              break;
           case RRM_ONE:
              p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode =
                      TDD_ACK_NACK_FEEDBACK_MODE_MULTIPLEXING;
              break;
           default:   
             RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Incorrect TDD_ACK_NACK_FEEDBACK_MODE(%d)..Hardcoding Mode=Bundling",
                p_rrm_physical_layer_params->physical_layer_param_pucch.tdd_ack_nack_feedback_mode);
              p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode =
                      TDD_ACK_NACK_FEEDBACK_MODE_BUNDLING;
        }
    }
#endif        
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 6810 End */


/******************************************************************************
*   FUNCTION NAME: fill_p0_ue_pucch 
*   INPUT        : p_ue_profile_p0_ue_pucch
*   OUTPUT       : p_rrc_p0_ue_pucch
*   DESCRIPTION  :
*                  Fills the p_rrc_p0_ue_pucch
*   RETURNS      : none
******************************************************************************/

void
fill_p0_ue_pucch(
        S8 *p_rrc_p0_ue_pucch,
        S8 *p_ue_profile_p0_ue_pucch
        )
{
    *p_rrc_p0_ue_pucch = *p_ue_profile_p0_ue_pucch;
}
/******************************************************************************
*   FUNCTION NAME: fill_p0_ue_pusch
*   INPUT        : p_ue_profile_p0_ue_pusch
*   OUTPUT       : p_rrc_p0_ue_pusch
*   DESCRIPTION  :
*                  Fills the p_rrc_p0_ue_pusch
*   RETURNS      : none
******************************************************************************/

void
fill_p0_ue_pusch(
        S8 *p_rrc_p0_ue_pusch,
        S8 *p_ue_profile_p0_ue_pusch
        )
{
    *p_rrc_p0_ue_pusch = *p_ue_profile_p0_ue_pusch;
}
/******************************************************************************
*   FUNCTION NAME: fill_delta_mcs_enabled
*   INPUT        : p_ur_profile_delta_mcs_enabled
*   OUTPUT       : p_rrc_delta_mcs_enabled
*   DESCRIPTION  :
*                  Fills the p_rrc_delta_mcs_enabled
*   RETURNS      : none
******************************************************************************/

void
fill_delta_mcs_enabled(
        U8 *p_rrc_delta_mcs_enabled,
        U8 *p_ur_profile_delta_mcs_enabled
        )
{
    *p_rrc_delta_mcs_enabled = *p_ur_profile_delta_mcs_enabled;
}
/******************************************************************************
*   FUNCTION NAME: fill_accumulation_enabled
*   INPUT        : p_ue_profile_accumulation_enabled
*   OUTPUT       : p_rrc_accumulation_enabled 
*   DESCRIPTION  :
*                  Fills the p_rrc_accumulation_enabled
*   RETURNS      : none
******************************************************************************/

void
fill_accumulation_enabled(
        U8 *p_rrc_accumulation_enabled,
        U8 *p_ue_profile_accumulation_enabled
        )
{
    *p_rrc_accumulation_enabled = *p_ue_profile_accumulation_enabled;
}
/* Uplink power starts */
/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_olpc_assign_pucch_pusch_p0_val
 *   INPUT        : p_rrm_ue_context,is_pusch_or_pucch_flag,p0_ue_end_range,
 *   OUTPUT       : p0_ue_ctxt_p0_val
 *   DESCRIPTION  :
 *                  To assign pucch and pusch p0_val in
 *                  open loop uplink power control
 *   RETURNS      :
 *                  none
 ******************************************************************************/
rrm_void_t
rrm_olpc_assign_pucch_pusch_p0_val
(
 rrm_ue_context_t   *p_rrm_ue_context,
 U8 is_pusch_or_pucch_flag,
 S8 *p0_ue_end_range,
 S8 *p0_ue_ctxt_p0_val
 )
{
    RRM_UT_TRACE_ENTER();
    if(RRM_ONE == is_pusch_or_pucch_flag)
    {
        *p0_ue_end_range = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->rrm_olpc_config_params.\
                          rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_end;
        *p0_ue_ctxt_p0_val = p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "p0_ue_end_range is %d and p0_ue_ctxt_p0_val is %d for PUSCH",
                *p0_ue_end_range, *p0_ue_ctxt_p0_val);
    }
    else /*for pucch*/
    {
        *p0_ue_end_range = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->rrm_olpc_config_params.\
                         rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_end;
        *p0_ue_ctxt_p0_val = p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "p0_ue_end_range is %d and p0_ue_ctxt_p0_val is %d for PUCCH",
                *p0_ue_end_range, *p0_ue_ctxt_p0_val);
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_olpc_inc_power
 *   INPUT        : p_rrm_ue_context,is_pusch_or_pucch_flag,p_rrm_ue_profile_value
 *   OUTPUT       : p_rrm_olpc_ue_value 
 *   DESCRIPTION  :
 *                  To increase  power of open loop uplink power control
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
rrm_void_t
rrm_olpc_inc_power(rrm_ue_context_t   *p_rrm_ue_context, 
		S8 *p_rrm_olpc_ue_value,S8 *p_rrm_ue_profile_value, U8 is_pusch_or_pucch_flag)
{
    /* BUG_11317_FIX_START */
    S8 p0_ue_end_range = RRM_ZERO;
    /*spr 8495 fix start*/
    S8 p0_ue_ctxt_p0_val = RRM_ZERO;
    S8 final_p0_ue_ctxt_val = RRM_ZERO;
    U8 delta_sinr = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* PUSCH */

    /* Klocwork_fix_march_14_start */
    rrm_olpc_assign_pucch_pusch_p0_val(p_rrm_ue_context, is_pusch_or_pucch_flag,
            &p0_ue_end_range, &p0_ue_ctxt_p0_val);
    /* Klocwork_fix_march_14_end */

    /* Enode-B Measurement Initiated Handover START*/
    if( (p0_ue_ctxt_p0_val >= p0_ue_end_range))
    {
        if(RRM_ONE == is_pusch_or_pucch_flag)
        {
            if((p_rrm_ue_context->meas_req_send_for_olpc != RRM_TRUE) &&
                    (p_rrm_ue_context->meas_status != RRM_MEAS_CONFIG_REQ_SENT))
            {
                /* SPR 16406 8SEP start */
                p_rrm_ue_context->meas_rep_event = MEAS_REP_EVENT_A2;
                /* SPR 16406 8SEP end */
                /* SPR 15232 start */
                p_rrm_ue_context->ho_params.a2_event_received = RRM_TRUE;
                /* SPR 15232 end */

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "eNodeB measurements triggered HO measuremments for [UE:%d].",p_rrm_ue_context->ue_index);
                if (RRM_SUCCESS ==
                        rrm_build_and_send_meas_config_req (p_rrm_ue_context, MEAS_TYPE_HO))
                {
                    /* coverity : CID 30258 */
                    p_rrm_ue_context->action_triggered = RRM_HO_ACTN_ON_UE ;
                    rrm_cellm_increment_dynamic_icic_counter_in_cell(p_rrm_ue_context->cell_index,RRM_CELLM_DYNAMIC_ICIC_HANDOUT_UES);
                    p_rrm_ue_context->meas_req_send_for_olpc = RRM_TRUE;
                }
                /* SPR 16406 8SEP start */
                p_rrm_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
                /* SPR 16406 8SEP end */
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "eNodeB measurements not triggered meas_req_send_for_olpc=%d, meas_status=%d for [UE:%d].",
                        p_rrm_ue_context->meas_req_send_for_olpc,
                        p_rrm_ue_context->meas_status,
                        p_rrm_ue_context->ue_index);
            }
        }
        else
        {
         /*SPR 17777 +-*/
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "max value for p0_pucch is already reached for [UE:%d], not incrementing value"
                    "Unused variable p_rrm_ue_profile_value=%p",p_rrm_ue_context->ue_index,p_rrm_ue_profile_value);
         /*SPR 17777 +-*/
        }
    }
    /*spr 8495 fix end*/
    else
    {
        /* Enode-B Measurement Initiated Handover STOP*/
        /*Start:Bug 966*/
        delta_sinr = rrm_olpc_get_delta_sinr(p_rrm_ue_context, is_pusch_or_pucch_flag);
        /* 
         * Conversion of SINR in dB is done and hence this is divided by 2 
         * because step size is 0.5dB. This output is in dB.
         */
        delta_sinr = delta_sinr / RRM_TWO;

        /*
         * This means Power needs to be increased because still we are not able to 
         * received the Target SINR.
         */
        final_p0_ue_ctxt_val = p0_ue_ctxt_p0_val + delta_sinr;
        /*  if calculate value is greater than end range then assigned pusch or pucch end range value  */
        if(final_p0_ue_ctxt_val < p0_ue_end_range)
        {
            *p_rrm_olpc_ue_value = final_p0_ue_ctxt_val;
        }
        else
        {
            *p_rrm_olpc_ue_value = p0_ue_end_range;
        }
        /*End:Bug 966*/
        /* Enode-B Measurement Initiated Handover START*/
    }
    /* Enode-B Measurement Initiated Handover STOP*/
    RRM_UT_TRACE_EXIT();
    /* BUG_11317_FIX_END */
}

/* BUG_11317_FIX_START */
/* Code Deleted */
/* BUG_11317_FIX_END */
/******************************************************************************
 *   FUNCTION NAME:rrm_olpc_dec_pow 
 *   INPUT        : p_rrm_ue_context,p_rrm_ue_profile_value,is_pusch_or_pucch_flag
 *   OUTPUT       : p_rrm_olpc_ue_value
 *   DESCRIPTION  :
 *                  To decrease power of open loop uplink power control 
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
rrm_void_t
rrm_olpc_dec_pow(rrm_ue_context_t   *p_rrm_ue_context,
                 S8 *p_rrm_olpc_ue_value,S8 *p_rrm_ue_profile_value, U8 is_pusch_or_pucch_flag)
{
    /* BUG_11317_FIX_START */
    S8                                p0_ue_start_range = RRM_NULL;
    S8                                final_p0_ue_ctxt_val = RRM_ZERO;
    U8                                delta_sinr = RRM_ZERO;
    S8                                p0_ue_ctxt_p0_val = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /*Start:Bug 966*/
    if( is_pusch_or_pucch_flag )
    {
        /*spr 8495 fix start*/
        p0_ue_start_range = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->rrm_olpc_config_params.\
                            rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_start;
        /*spr 8495 fix end*/
        p0_ue_ctxt_p0_val = p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch;
    }
    else
    {
        /*spr 8495 fix start*/
        p0_ue_start_range = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->rrm_olpc_config_params.\
                            rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_start;
        /*spr 8495 fix end*/
        p0_ue_ctxt_p0_val = p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch;
    }
    delta_sinr = rrm_olpc_get_delta_sinr(p_rrm_ue_context, is_pusch_or_pucch_flag);
    /* 
     * Conversion of SINR in dB is done and hence this is divided by 2 
     * because step size is 0.5dB. This output is in dB.
     */
    delta_sinr = delta_sinr / RRM_TWO;

    /*
     * This means Power needs to be decreased because we have already  
     * reached the Target SINR.
     */
    final_p0_ue_ctxt_val = p0_ue_ctxt_p0_val - delta_sinr;
    /*  if calculate value is greater than end range then assigned pusch or pucch end range value  */
    if(final_p0_ue_ctxt_val > p0_ue_start_range)
    {
        *p_rrm_olpc_ue_value = final_p0_ue_ctxt_val;
    }
    else
    {
        *p_rrm_olpc_ue_value = p0_ue_start_range;
    }
    /*End:Bug 966*/
         /*SPR 17777 +-*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILEDALL,
            "Unused variable p_rrm_ue_profile_value=%p ",p_rrm_ue_profile_value);/*SPR 17777 +-*/
         /*SPR 17777 +-*/
    RRM_UT_TRACE_EXIT();    
    /* BUG_11317_FIX_END */
}

/* BUG_11317_FIX_START */
/*Start:Bug 966*/
U8
rrm_olpc_get_delta_sinr(
    rrm_ue_context_t   *p_rrm_ue_context,
    U8                 is_pusch_or_pucch_flag
)
{
    U8                     threshold_tgt_for_pathloss = RRM_ZERO;
    U8                     avg_pathloss_of_ue = RRM_ZERO;
    U8                     tgt_sinr = RRM_ZERO;
    U8                     delta_sinr = RRM_ZERO;
    rrm_cell_context_t     *p_cell_ctx = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    /* Coverity 93939 Fix Start */
    if (RRM_PNULL == p_cell_ctx)
    {
    	RRM_UT_TRACE_EXIT();
        return delta_sinr;
    }
    /* Coverity 93939 Fix End */
    threshold_tgt_for_pathloss = p_cell_ctx->rrm_olpc_config_params.ul_pathloss_threshold;
    /* Based on PL, first of all figure out location of UE
     * i.e UE is CC or CE and then fetch the target SINR.
     */

    if (RRM_ONE == is_pusch_or_pucch_flag)
    {
                            /* + SPR 20078 */
        avg_pathloss_of_ue = p_rrm_ue_context->ue_avg_stats.uplinkPathLossValue;
                            /* - SPR 20078 */
        if (avg_pathloss_of_ue > threshold_tgt_for_pathloss)
        {
            tgt_sinr = p_cell_ctx->rrm_olpc_config_params.
                       rrm_olpc_pusch_config_params.
                       olpc_pusch_snr_threshold_for_cell_edge_ue;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "CE UE: Avg PL[%d], Threshold PL[%d], Target SINR[%d]",
                      avg_pathloss_of_ue, threshold_tgt_for_pathloss, tgt_sinr);
        }
        else
        {
            tgt_sinr = p_cell_ctx->rrm_olpc_config_params.
                       rrm_olpc_pusch_config_params.
                       olpc_pusch_snr_threshold_for_cell_center_ue;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "CC UE: Avg PL[%d], Threshold PL[%d], Target SINR[%d]",
                      avg_pathloss_of_ue, threshold_tgt_for_pathloss, tgt_sinr);
        }
    }
    else
    {
        tgt_sinr = p_cell_ctx->rrm_olpc_config_params.
                   rrm_olpc_pucch_config_params.
                   olpc_pucch_snr_threshold;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "PUCCH Target SINR[%d]", tgt_sinr);
    }
    if(p_rrm_ue_context->ue_avg_stats.uplinkSINRValue >= tgt_sinr)
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                   "[UE:%d] , Target sinr[%d] reached already.Current is[%d]",
                    p_rrm_ue_context->ue_index, tgt_sinr, 
                    p_rrm_ue_context->ue_avg_stats.uplinkSINRValue);
         delta_sinr = p_rrm_ue_context->ue_avg_stats.uplinkSINRValue - tgt_sinr;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] , Target sinr[%d] not reached. Current is[%d]",
                p_rrm_ue_context->ue_index, tgt_sinr, 
                p_rrm_ue_context->ue_avg_stats.uplinkSINRValue);
        delta_sinr = tgt_sinr - p_rrm_ue_context->ue_avg_stats.uplinkSINRValue;
    }
    RRM_UT_TRACE_EXIT();
    return delta_sinr;
}
/*Start:Bug 966*/
/* BUG_11317_FIX_END */

/******************************************************************************
 *   FUNCTION NAME: rrm_olpc_no_action
 *   INPUT        : p_rrm_ue_context,p_rrm_ue_profile_value,is_pusch_or_pucch_flag
 *   OUTPUT       : p_rrm_olpc_ue_value
 *   DESCRIPTION  :
 *                  To unchanged power during open loop power control
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
rrm_void_t
rrm_olpc_no_action(rrm_ue_context_t   *p_rrm_ue_context,
                 S8 *p_rrm_olpc_ue_value,S8 *p_rrm_ue_profile_value, U8 is_pusch_or_pucch_flag)
{
    RRM_UT_TRACE_ENTER();
    if(RRM_TRUE == is_pusch_or_pucch_flag)
    {
         /*SPR 17777 +-*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] , set value for p0_ue_pusch [%d],Unused variable p_rrm_ue_profile_value=%p",
                p_rrm_ue_context->ue_index,*p_rrm_olpc_ue_value,p_rrm_ue_profile_value);
         /*SPR 17777 +-*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] , set value for p0_ue_pucch [%d]",
                p_rrm_ue_context->ue_index,*p_rrm_olpc_ue_value);
    }
    RRM_UT_TRACE_EXIT();

}
/* Uplink power end */
/******************************************************************************
 *   FUNCTION NAME: rrm_find_sinr_dep_params_category
 *   INPUT        : p_ue_context
 *   OUTPUT       : uplink_params_type
 *   DESCRIPTION  :
 *                  Find SINR dep params category based on thair average value
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
/*Uplink power control starts*/
rrm_void_t
rrm_find_sinr_dep_params_category
(rrm_ue_context_t *p_ue_context,
 S8 *uplink_params_type, U8 is_pusch_or_pucch_flag)
{
    /* BUG_11317_FIX_START */
    rrm_cell_index_t                cell_index = RRM_ZERO;
    U8                              uplinkPathloss_threshold = RRM_ZERO;
    U8                              uplinkSINR_CC_UE_threshold = RRM_ZERO;
    U8                              uplinkSINR_CE_UE_threshold = RRM_ZERO;
    U8                              uplinkSINR_threshold = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    cell_index = p_ue_context->cell_index;
    /* If is_pusch_or_pucch_flag is true then it is p0_ue_pusch olpc params else p0_ue_pucch */
    if( RRM_TRUE == is_pusch_or_pucch_flag )
    {
        uplinkPathloss_threshold = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.
            ul_pathloss_threshold;
        uplinkSINR_CC_UE_threshold = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.
            rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_center_ue;
        uplinkSINR_CE_UE_threshold = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.
            rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_edge_ue;
                            /* + SPR 20078 */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[UE:%d] PUSCH  UL Pathloss Threshold[%d], SINR Threshold {CC[%d] CE[%d]}"
                "avg uplinkPathLossValue[%d], avg uplinkSINRValue[%d]",
                p_ue_context->ue_index, uplinkPathloss_threshold, uplinkSINR_CC_UE_threshold, uplinkSINR_CE_UE_threshold,
                p_ue_context->ue_avg_stats.uplinkPathLossValue,  p_ue_context->ue_avg_stats.uplinkSINRValue);
                            /* - SPR 20078 */
        /* Here finding olpc category to perform corresponding action configure from rrm.cfg file */
                            /* + SPR 20078 */
        if(p_ue_context->ue_avg_stats.uplinkPathLossValue > 200)
                            /* - SPR 20078 */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "Uplink Pathloss for [UE:%d] is not in range",p_ue_context->ue_index);
            *uplink_params_type = OLPC_TABLE_CATEGORY_2;
        }
                            /* + SPR 20078 */
        else if(p_ue_context->ue_avg_stats.uplinkPathLossValue <= uplinkPathloss_threshold)
                            /* - SPR 20078 */
        {
            /* Cases for Cell Center  UEs */
            if(p_ue_context->ue_avg_stats.uplinkSINRValue <= uplinkSINR_CC_UE_threshold)
            {
                /* This category corresponds to LOW pathloss and LOW SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_1;
            }
            else
            {
                /* This category corresponds to LOW pathloss and HIGH SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_2;
            }
        }
        else
        {
            /* Cases for Cell Edge  UEs */
            if(p_ue_context->ue_avg_stats.uplinkSINRValue <= uplinkSINR_CE_UE_threshold)
            {
                /* This category corresponds to HIGH pathloss and LOW SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_3;
            }
            else
            {
                /* This category corresponds to HIGH pathloss and HIGH SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_4;
            }
        }
    }
    else
    {
        uplinkPathloss_threshold = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.
                                  ul_pathloss_threshold;
        uplinkSINR_threshold = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.
                              rrm_olpc_pucch_config_params.olpc_pucch_snr_threshold;	

                            /* + SPR 20078 */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "[UE:%d] PUCCH uplinkPathloss_threshold [%d], uplinkSINR_threshold[%d]"
                  "avg uplinkPathLossValue[%d],avg uplinkSINRValue[%d]",
                  p_ue_context->ue_index, uplinkPathloss_threshold, uplinkSINR_threshold,
                  p_ue_context->ue_avg_stats.uplinkPathLossValue, p_ue_context->ue_avg_stats.uplinkSINRValue);
                            /* - SPR 20078 */
        /* Here finding olpc category to perform corresponding action configure from rrm.cfg file */
                            /* + SPR 20078 */
        if(p_ue_context->ue_avg_stats.uplinkPathLossValue > 200)
                            /* - SPR 20078 */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "Uplink Pathloss for [UE:%d] is not in range",p_ue_context->ue_index);
            *uplink_params_type = OLPC_TABLE_CATEGORY_2;
        }
                            /* + SPR 20078 */
        else if(p_ue_context->ue_avg_stats.uplinkPathLossValue <= uplinkPathloss_threshold)
                            /* - SPR 20078 */
        {
            /* Cases for Cell Center  UEs */
            if(p_ue_context->ue_avg_stats.uplinkSINRValue <= uplinkSINR_threshold)
            {
                /* This category corresponds to LOW pathloss and LOW SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_1;
            }
            else
            {
                /* This category corresponds to LOW pathloss and HIGH SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_2;
            }
        }
        else
        {
            /* Cases for Cell Edge  UEs */
            if(p_ue_context->ue_avg_stats.uplinkSINRValue <= uplinkSINR_threshold)
            {
                /* This category corresponds to HIGH pathloss and LOW SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_3;
            }
            else
            {
                /* This category corresponds to HIGH pathloss and HIGH SINR */
                *uplink_params_type = OLPC_TABLE_CATEGORY_4;
            }
        }
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
              "[UE:%d] uplink_params_type [%d] to perform corresponding action",
              p_ue_context->ue_index,*uplink_params_type);
    RRM_UT_TRACE_EXIT();
    /* BUG_11317_FIX_END */
}

/*Uplink power control end*/

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_p0_ue_pusch
 *   INPUT        : p_rrm_ue_context,p_ue_profile_p0_ue_pusch
 *   OUTPUT       : p_rrm_p0_ue_pusch
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_uplink_power_control_dedicated_t
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
/*Uplink power control starts*/
rrm_void_t
fill_erb_setup_resp_p0_ue_pusch(
        S8 *p_rrm_p0_ue_pusch,
	S8 *p_ue_profile_p0_ue_pusch,
        rrm_ue_context_t   *p_rrm_ue_context
        )
{
        rrm_cell_index_t                cell_index = RRM_ZERO;
        S8                              olpc_category = RRM_ZERO;
        S8 ulpc_params_category = RRM_ZERO;
        U8 is_pusch_or_pucch_flag = RRM_TRUE;
           
        rrm_find_sinr_dep_params_category
        (p_rrm_ue_context,&ulpc_params_category, is_pusch_or_pucch_flag);

        cell_index = p_rrm_ue_context->cell_index;

        olpc_category = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.\
                rrm_olpc_pusch_config_params.olpc_pusch_supported_table[ulpc_params_category-RRM_ONE];
	
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "[UE:%d] uplink_params_type [%d] to perform olpc_action[%d] ",
        p_rrm_ue_context->ue_index,ulpc_params_category,olpc_category);	

        olpc_action[olpc_category](p_rrm_ue_context,p_rrm_p0_ue_pusch,p_ue_profile_p0_ue_pusch, is_pusch_or_pucch_flag);
	/* To update current uplink power of ue */
	p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch = *p_rrm_p0_ue_pusch;
}

/*Uplink power control end*/

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_p0_ue_pucch
 *   INPUT        : p_rrm_ue_context,p_ue_profile_p0_ue_pucch
 *   OUTPUT       : p_rrm_p0_ue_pucch
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_uplink_power_control_dedicated_t
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
/*Uplink power control starts*/
rrm_void_t
fill_erb_setup_resp_p0_ue_pucch(
        S8 *p_rrm_p0_ue_pucch,
        S8 *p_ue_profile_p0_ue_pucch,
        rrm_ue_context_t   *p_rrm_ue_context
        )
{
    rrm_cell_index_t                cell_index = RRM_ZERO;
    S8 olpc_category = RRM_ZERO;
    S8 ulpc_params_category = RRM_ZERO;
    U8 is_pusch_or_pucch_flag = RRM_FALSE;


	/* Called to find sinr_dep_params_category to decide p0_ue_pucch */
        rrm_find_sinr_dep_params_category
        (p_rrm_ue_context,&ulpc_params_category, is_pusch_or_pucch_flag);

        cell_index = p_rrm_ue_context->cell_index;
        olpc_category = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.\
                rrm_olpc_pucch_config_params.olpc_pucch_supported_table[ulpc_params_category-RRM_ONE];

	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] uplink_params_type [%d] to perform olpc_action[%d] ",
        p_rrm_ue_context->ue_index,ulpc_params_category,olpc_category);

        olpc_action[olpc_category](p_rrm_ue_context,p_rrm_p0_ue_pucch,p_ue_profile_p0_ue_pucch, is_pusch_or_pucch_flag);
	/* To update current uplink power of ue */
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch = *p_rrm_p0_ue_pucch;

}

/*Uplink power control end*/


/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_uplink_power_control_dedicated
 *   INPUT        : p_ue_profile_uplink_power_control_dedicated
 *   OUTPUT       : p_rrc_phy_uplink_power_control_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_uplink_power_control_dedicated_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_uplink_power_control_dedicated(
        rrc_phy_uplink_power_control_dedicated_t                    
        *p_rrc_phy_uplink_power_control_dedicated,
        rrc_phy_uplink_power_control_dedicated_ue_service_profile_t 
        *p_ue_profile_uplink_power_control_dedicated
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    fill_p0_ue_pusch(&(p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch),
            &(p_ue_profile_uplink_power_control_dedicated->p0_ue_pusch));

    fill_delta_mcs_enabled(&(p_rrc_phy_uplink_power_control_dedicated->delta_mcs_enabled),
            &(p_ue_profile_uplink_power_control_dedicated->delta_mcs_enabled));

    fill_accumulation_enabled(&(p_rrc_phy_uplink_power_control_dedicated->accumulation_enabled),
            &(p_ue_profile_uplink_power_control_dedicated->accumulation_enabled));

    fill_p0_ue_pucch(&(p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch),
            &(p_ue_profile_uplink_power_control_dedicated->p0_ue_pucch));

    p_rrc_phy_uplink_power_control_dedicated->p_srs_offset =
        p_ue_profile_uplink_power_control_dedicated->p_srs_offset;
    p_rrc_phy_uplink_power_control_dedicated->filter_coefficient =
        p_ue_profile_uplink_power_control_dedicated->filter_coefficient;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_periodic_sub_wide_band 
 *   INPUT        : p_rrc_phy_cqi_report_periodic_r10_setup, p_rrm_ue_cntxt,
 *                  rrm_freq_selective_sched, ret_val
 *   OUTPUT       : None
 *   DESCRIPTION  :
 *                  Fills periodic sub band wide band in 
 *                  the rrc_phy_cqi_report_periodic_r10_setup_t
 *   RETURNS      : Void
 ******************************************************************************/
rrm_void_t
rrm_rrc_ue_fill_periodic_sub_wide_band
(
    rrc_phy_cqi_report_periodic_r10_setup_t    *p_rrc_phy_cqi_report_periodic_r10_setup,
    rrm_ue_context_t *p_rrm_ue_cntxt,
    rrm_ul_dl_freq_selective_sched_et rrm_freq_selective_sched,
    rrm_return_et    *ret_val
)
{
    rrm_cell_index_t                cell_index;

    RRM_UT_TRACE_ENTER();

    cell_index = p_rrm_ue_cntxt->cell_index;
    if ((RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH == rrm_freq_selective_sched) ||
        (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY == rrm_freq_selective_sched))
    {
        /* Wide Band CQI start */
        p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic.
                bitmask |= RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_PRESENT;
       //Submode only supported for TM-9, TM-9 not supported yet in IPR.
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Wide Band Configured");
    }
    else if ((RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY == rrm_freq_selective_sched) ||
             (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH == rrm_freq_selective_sched))
    {
        if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.rf_params.\
                              rf_configurations.dl_bandwidth == RRM_OAM_BW_N_6)
        {
            /*Aperiodic CQI/PMI/RI reporting are not supported for DL RB's
             *less than 7 (i.e. when Cell bandwidth configured as 1.4 Mhz).
             *Refer spec 36.213 v 9.2.0 sec 7.2.1
             */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "Aperiodic mode not supported for DL RB's less than 7");
            *ret_val = RRM_SUCCESS;
        }
        else
        {
            /*Start:Bug 762*/
            if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_TWO)) == RRM_TRUE)
            /*End:Bug 762*/
            {
                /* Sub Band CQI start */
                p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic.
                    bitmask |= RRC_PHY_CQI_FORMAT_IND_PERIODIC_SUBBAND_CQI_PRESENT;
                p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic.
                    /*SPR 17777 +-*/
                    cqi_format_ind_subband.k = rrm_cellm_get_subband_size();
                //periodicity_factor selection logic selection to be discussed. Stage-2 feature.
               // p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic.
                 //   cqi_format_ind_subband.periodicy_factor = rrm_cellm_get_periodicity_factor(p_rrm_ue_cntxt->cell_index);
                /* Sub Band CQI end */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Sub Band Configured:- k(%d)",
                        p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic.
                        cqi_format_ind_subband.k);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_cqi_reporting_periodic_param_r10 
 *   INPUT        : p_rrc_phy_cqi_report_periodic_r10_setup, p_rrm_ue_cntxt,
 *                  p_ue_profile_phy_cqi_reporting_periodic_param, 
 *                  transmission_mode, rrm_freq_selective_sched
 *   OUTPUT       : None
 *   DESCRIPTION  :
 *                   Fills the rrc_phy_cqi_report_periodic_r10_setup_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_fill_cqi_reporting_periodic_param_r10(
             rrc_phy_cqi_report_periodic_r10_setup_t    *p_rrc_phy_cqi_report_periodic_r10_setup,
             rrc_phy_cqi_reporting_periodic_param_ue_service_profile_t
                    *p_ue_profile_phy_cqi_reporting_periodic_param,
        rrm_ue_context_t
                    *p_rrm_ue_cntxt,
        U8          transmission_mode,
        rrm_ul_dl_freq_selective_sched_et
                    rrm_freq_selective_sched
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_phy_cqi_report_periodic_r10_setup->bitmask = RRM_ZERO;

    p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index =
        p_rrm_ue_cntxt->cqi_params.cqi_pucch_res_index;

    p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pmi_config_index =
        p_rrm_ue_cntxt->cqi_params.cqi_pmi_config_index;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "[UE:%d], Rel-10: PUCCH Resource Index=(%d), CQI-PMI Index(%d)",
                 p_rrm_ue_cntxt->ue_index, p_rrm_ue_cntxt->cqi_params.cqi_pucch_res_index,
                 p_rrm_ue_cntxt->cqi_params.cqi_pmi_config_index);

    p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic.
                bitmask = RRM_ZERO;
    /* Klocwork_fix_march_14_start */
    rrm_rrc_ue_fill_periodic_sub_wide_band (p_rrc_phy_cqi_report_periodic_r10_setup,
                p_rrm_ue_cntxt, rrm_freq_selective_sched, &ret_val);
    /* Klocwork_fix_march_14_end */

    /*Coverity_fix_start_62526*/
    p_rrc_phy_cqi_report_periodic_r10_setup->simultaneous_ack_nack_cqi =
        p_ue_profile_phy_cqi_reporting_periodic_param->simultaneous_ack_nack_and_cqi;
    if ( (TRANSMISSION_MODE_TM3 == transmission_mode) ||
            (TRANSMISSION_MODE_TM4 == transmission_mode) ||
            /*spr 7610 start*/
            (TRANSMISSION_MODE_TM8_V920 == transmission_mode)
            /*spr 7610 end*/
       )
    {
        p_rrc_phy_cqi_report_periodic_r10_setup->bitmask |= RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT;
        p_rrc_phy_cqi_report_periodic_r10_setup->ri_config_index = p_rrm_ue_cntxt->cqi_params.ri_index;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "RI-Index(%d)",
                p_rrc_phy_cqi_report_periodic_r10_setup->ri_config_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "TM mode other than TM3 and TM4, so RI can't be configured");
    }
    /*Coverity_fix_end_62526*/

    /*SPR 21043 Fix Start*/
    if((p_rrm_ue_cntxt->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT) &&
            (RRM_TRUE == rrm_cellm_get_enable_cqi_mask_r9(p_rrm_ue_cntxt->cell_index)))
    {
             p_rrc_phy_cqi_report_periodic_r10_setup->cqi_mask_r9 = CQI_MASK_R9_SETUP;
             p_rrc_phy_cqi_report_periodic_r10_setup->bitmask |=
                 RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], cqi mask r9 is not enabled, not filling cqi_mask_r9",
                p_rrm_ue_cntxt->ue_index);
    }
    /*SPR 21043 Fix Stop*/

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_cqi_periodic_params 
 *   INPUT        : p_rrc_phy_cqi_reporting_periodic_param, p_rrm_ue_cntxt,
 *                  rrm_freq_selective_sched, ret_val
 *   OUTPUT       : None
 *   DESCRIPTION  :
 *                  Fills CQI periodic params in 
 *                  the p_rrc_phy_cqi_reporting_periodic_param
 *   RETURNS      : Void
 ******************************************************************************/
rrm_void_t
rrm_rrc_ue_fill_cqi_periodic_params
(
    rrc_phy_cqi_reporting_periodic_param_t *p_rrc_phy_cqi_reporting_periodic_param,
    rrm_ue_context_t *p_rrm_ue_cntxt,
    rrm_ul_dl_freq_selective_sched_et rrm_freq_selective_sched,
    rrm_return_et    *ret_val
)
{
    rrm_cell_index_t                cell_index;

    RRM_UT_TRACE_ENTER();

    cell_index = p_rrm_ue_cntxt->cell_index;
    if ((RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH == rrm_freq_selective_sched) ||
        (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY == rrm_freq_selective_sched))
    {
        /* Wide Band CQI start */
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Wide Band Configured");
       
    }
    else if ((RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY == rrm_freq_selective_sched) ||
             (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH == rrm_freq_selective_sched))
    {
        if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.rf_params.\
                              rf_configurations.dl_bandwidth == RRM_OAM_BW_N_6)
        {
            /*Aperiodic CQI/PMI/RI reporting are not supported for DL RB's
             *less than 7 (i.e. when Cell bandwidth configured as 1.4 Mhz).
             *Refer spec 36.213 v 9.2.0 sec 7.2.1
             */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "Aperiodic mode not supported for DL RB's less than 7");
            *ret_val = RRM_SUCCESS;
        }
        else
        {
            /*Start:Bug 762*/
            if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_TWO)) == RRM_TRUE)
            /*End:Bug 762*/
            {
                /* Sub Band CQI start */
                p_rrc_phy_cqi_reporting_periodic_param->cqi_format_indicator_periodic.
                    bitmask |= RRC_PHY_SUBBAND_CQI_PARAM_PRESENT;
                p_rrc_phy_cqi_reporting_periodic_param->cqi_format_indicator_periodic.
                    /*SPR 17777 +-*/
                    subband_cqi_param.k = rrm_cellm_get_subband_size();
                /* Sub Band CQI end */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Sub Band Configured:- k(%d)", 
                        p_rrc_phy_cqi_reporting_periodic_param->cqi_format_indicator_periodic.
                        subband_cqi_param.k);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_cqi_reporting_periodic_param 
 *   INPUT        : p_ue_profile_phy_cqi_reporting_periodic_param,p_rrm_ue_cntxt,
 *                  transmission_mode,rrm_freq_selective_sched
 *   OUTPUT       : p_rrc_phy_cqi_reporting_periodic_param
 *   DESCRIPTION  :
 *                   Fills the rrc_phy_cqi_reporting_periodic_param_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_fill_cqi_reporting_periodic_param(
        rrc_phy_cqi_reporting_periodic_param_t                    
                    *p_rrc_phy_cqi_reporting_periodic_param,
        rrc_phy_cqi_reporting_periodic_param_ue_service_profile_t 
                    *p_ue_profile_phy_cqi_reporting_periodic_param,
        rrm_ue_context_t                                          
                    *p_rrm_ue_cntxt,
        U8          transmission_mode,
        rrm_ul_dl_freq_selective_sched_et  
                    rrm_freq_selective_sched
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(p_rrm_ue_cntxt->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator present, checking for bit2",
                p_rrm_ue_cntxt->ue_index);
    }

    p_rrc_phy_cqi_reporting_periodic_param->bitmask = RRM_ZERO; 

    p_rrc_phy_cqi_reporting_periodic_param->cqi_pucch_resource_index = 
        p_rrm_ue_cntxt->cqi_params.cqi_pucch_res_index;
    
    p_rrc_phy_cqi_reporting_periodic_param->cqi_pmi_config_index = 
        p_rrm_ue_cntxt->cqi_params.cqi_pmi_config_index;
    
    p_rrc_phy_cqi_reporting_periodic_param->cqi_format_indicator_periodic.
                bitmask =RRM_ZERO;
    /* Klocwork_fix_march_14_start */
    rrm_rrc_ue_fill_cqi_periodic_params(p_rrc_phy_cqi_reporting_periodic_param,
            p_rrm_ue_cntxt, rrm_freq_selective_sched, &ret_val);
    /* Klocwork_fix_march_14_end */

    p_rrc_phy_cqi_reporting_periodic_param->simultaneous_ack_nack_and_cqi = 
        p_ue_profile_phy_cqi_reporting_periodic_param->
        simultaneous_ack_nack_and_cqi;
    if ( (TRANSMISSION_MODE_TM3 == transmission_mode) ||
         (TRANSMISSION_MODE_TM4 == transmission_mode) ||
         /*spr 7610 start*/
         (TRANSMISSION_MODE_TM8_V920 == transmission_mode)
         /*spr 7610 end*/
       )
    {
       p_rrc_phy_cqi_reporting_periodic_param->bitmask |= RRC_PHY_CQI_RI_CONFIG_INDEX_PRESENT;
       p_rrc_phy_cqi_reporting_periodic_param->ri_config_index = p_rrm_ue_cntxt->cqi_params.ri_index;
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "RI-Index(%d)", 
                 p_rrc_phy_cqi_reporting_periodic_param->ri_config_index);
    }
    else
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "TM mode other than TM3 and TM4, so RI can't be configured");
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[UE:%d], PUCCH Resource Index=(%d), CQI-PMI Index(%d)", 
                 p_rrm_ue_cntxt->ue_index, p_rrm_ue_cntxt->cqi_params.cqi_pucch_res_index,
                 p_rrm_ue_cntxt->cqi_params.cqi_pmi_config_index);

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_cqi_reporting_periodic_r10 
 *   INPUT        : p_rrc_phy_cqi_reporting_periodic_r10, p_rrm_ue_cntxt,
 *                  p_ue_profile_phy_cqi_reporting_periodic_param, 
 *                  transmission_mode, rrm_freq_selective_sched
 *   OUTPUT       : None
 *   DESCRIPTION  :
 *                   Fills the rrc_phy_cqi_report_periodic_r10_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_ue_fill_cqi_reporting_periodic_r10(
rrc_phy_cqi_report_periodic_r10_t                         *p_rrc_phy_cqi_reporting_periodic_r10,
rrc_phy_cqi_reporting_periodic_ue_service_profile_t       *p_ue_profile_phy_cqi_reporting_periodic,
rrm_ue_context_t                                          *p_rrm_ue_cntxt,
U8                                                        transmission_mode,
rrm_ul_dl_freq_selective_sched_et                         rrm_freq_selective_sched)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(p_ue_profile_phy_cqi_reporting_periodic->bitmask &
         RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT)
    {
         p_rrc_phy_cqi_reporting_periodic_r10->bitmask |=
              RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT;
         p_rrc_phy_cqi_reporting_periodic_r10->request_type = RRM_ONE;      /*Setup*/
         rrm_rrc_ue_fill_cqi_reporting_periodic_param_r10
              (&(p_rrc_phy_cqi_reporting_periodic_r10->setup),
              &(p_ue_profile_phy_cqi_reporting_periodic->cqi_reporting_periodic_param),
              p_rrm_ue_cntxt,
              transmission_mode,
              rrm_freq_selective_sched);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_cqi_reporting_periodic
 *   INPUT        : p_ue_profile_phy_cqi_reporting_periodic,p_rrm_ue_cntxt,
 *                  transmission_mode,rrm_freq_selective_sched
 *   OUTPUT       : p_rrc_phy_cqi_reporting_periodic
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_cqi_reporting_periodic_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_fill_cqi_reporting_periodic(
    rrc_phy_cqi_reporting_periodic_t                
                           *p_rrc_phy_cqi_reporting_periodic,
    rrc_phy_cqi_reporting_periodic_ue_service_profile_t 
                           *p_ue_profile_phy_cqi_reporting_periodic,
    rrm_ue_context_t                                    
                           *p_rrm_ue_cntxt,
    U8                     transmission_mode,
    rrm_ul_dl_freq_selective_sched_et  
                           rrm_freq_selective_sched
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(p_ue_profile_phy_cqi_reporting_periodic->bitmask & 
         RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT)
    {
         p_rrc_phy_cqi_reporting_periodic->bitmask |= 
              RRC_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
         rrm_rrc_ue_fill_cqi_reporting_periodic_param
              (&(p_rrc_phy_cqi_reporting_periodic->cqi_reporting_periodic_param),
              &(p_ue_profile_phy_cqi_reporting_periodic->cqi_reporting_periodic_param),
              p_rrm_ue_cntxt,
              transmission_mode, 
              rrm_freq_selective_sched);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_cqi_reporting_r10
 *
 *   DESCRIPTION:
 *       Fills the rrc_phy_cqi_reporting_t
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_fill_cqi_reporting_r10(
rrc_cqi_report_config_r10_t                     *p_rrc_phy_cqi_reporting_r10,
rrc_phy_cqi_reporting_ue_service_profile_t      *p_ue_profile_phy_cqi_reporting,
rrm_ue_context_t                                *p_rrm_ue_cntxt,
U8                                              transmission_mode)
{

    rrm_return_et                   ret_val = RRM_SUCCESS;
    U32                             aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info = RRM_NULL;
    U8 cqi_mode_selected = RRM_DISABLE_CQI_REPORTING;

    RRM_UT_TRACE_ENTER();

    p_rrc_phy_cqi_reporting_r10->bitmask = RRM_ZERO;

    p_rrc_phy_cqi_reporting_r10->nomPDSCH_rs_epre_offset =
        p_ue_profile_phy_cqi_reporting->nom_pdsch_rs_epre_offset;

    /* Select CQI Mode for Cell */
    rrm_select_cqi_mode_for_cell(p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured,
            p_rrm_ue_cntxt,
            &cqi_mode_selected);

	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, "CQI Mode %d selected", cqi_mode_selected);

    /* Aperiodic CQI Reporting */
    if(((rrm_cqi_reporting_mode_et)cqi_mode_selected == RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
            ((rrm_cqi_reporting_mode_et)cqi_mode_selected == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED))
    {
        if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_cntxt->cell_index]->ran_info.rf_params.\
                rf_configurations.dl_bandwidth == RRM_OAM_BW_N_6)
        {
            /*Aperiodic CQI/PMI/RI reporting are not supported for DL RB's
             *less than 7 (i.e. when Cell bandwidth configured as 1.4 Mhz).
             *Refer spec 36.213 v 10.11.0 sec 7.2.1
             */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                    "Aperiodic mode not supported for DL RB's less than 7");
            ret_val = RRM_SUCCESS;
        }
        else
        {
            p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(p_rrm_ue_cntxt->cell_index);
            ret_val = rrm_assign_aperiodic_mode_from_tm_mode_r10(
                    p_rrm_ue_cntxt,
                    p_ue_profile_phy_cqi_reporting->rrm_ul_dl_freq_selective_sched,
                    transmission_mode,
                    &aperiodic_mode,
                    p_rrm_tm_mode_additional_info);

            if(ret_val == RRM_SUCCESS)
            {
                p_rrc_phy_cqi_reporting_r10->bitmask = 
                    RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_APERIODIC_R10_PRESENT; 

                p_rrc_phy_cqi_reporting_r10->cqi_report_aperiodic_r10.bitmask = 
                    RRC_PHY_CQI_REPORT_APERIODIC_R10_SETUP_PRESENT;

                p_rrc_phy_cqi_reporting_r10->cqi_report_aperiodic_r10.request_type = RRM_ONE; /* Setup */

                p_rrc_phy_cqi_reporting_r10->cqi_report_aperiodic_r10.setup.cqi_reporting_mode_aperiodic = aperiodic_mode;

                /* Bug_11964_fix: Start */
                if((p_rrm_ue_cntxt->ue_scell_add_params.count > RRM_ZERO ) &&
                        (p_rrm_ue_cntxt->ue_scell_add_params.count < RRM_MAX_SCELL))
                {
                    ret_val = rrm_fill_aperiodic_csi_trigger
                        ( p_rrm_ue_cntxt,
                          &(p_rrc_phy_cqi_reporting_r10->cqi_report_aperiodic_r10.setup.aperiodic_csi_trigger));

                    if(ret_val == RRM_FAILURE)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to fill the aperiodic_csi_trigger for Pcell!!!");
                        RRM_UT_TRACE_EXIT();
                        return( RRM_FAILURE );
                    }
                    else
                    {
                        p_rrc_phy_cqi_reporting_r10->cqi_report_aperiodic_r10.setup.bitmask =
                            RRC_CQI_REPORT_APERIODIC_R10_SETUP_APERIODIC_CSI_TRIGGER_PRESENT;

                    }
                }
                /* Bug_11964_fix: End */
            } 
            else
            {
                RRM_UT_TRACE_EXIT();
                return( RRM_FAILURE );
            }
        }
    }
    /* Periodic CQI Reporting */
    if(((rrm_cqi_reporting_mode_et)cqi_mode_selected == RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
            ((rrm_cqi_reporting_mode_et)cqi_mode_selected == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED) )
    {
        p_rrc_phy_cqi_reporting_r10->bitmask |=
            RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_PERIODIC_R10_PRESENT;
	    /* SPR 14537 start */
        /* SPR 15301 Fix start */
        if(RRM_FALSE != p_rrm_ue_cntxt->is_csi_pattern_to_release)
        {
            p_rrc_phy_cqi_reporting_r10->bitmask |=
                RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAME_PATTERN_CONFIG_R10_PRESENT;

            p_rrc_phy_cqi_reporting_r10->csi_subframePattern_r10.bitmask = RRM_ZERO;
            p_rrc_phy_cqi_reporting_r10->csi_subframePattern_r10.request_type = RRM_ZERO;
        }
	    /* SPR 14537 end */

        rrm_rrc_ue_fill_cqi_reporting_periodic_r10
            (&(p_rrc_phy_cqi_reporting_r10->cqi_report_periodic_r10),
             &(p_ue_profile_phy_cqi_reporting->cqi_reporting_periodic),
             p_rrm_ue_cntxt, transmission_mode,
             p_ue_profile_phy_cqi_reporting->rrm_ul_dl_freq_selective_sched);
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_cqi_reporting
 *
 *   DESCRIPTION:
 *       Fills the rrc_phy_cqi_reporting_t
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_fill_cqi_reporting(
    rrc_phy_cqi_reporting_t                        *p_rrc_phy_cqi_reporting,
    rrc_phy_cqi_reporting_ue_service_profile_t     *p_ue_profile_phy_cqi_reporting,
    rrm_ue_context_t                               *p_rrm_ue_cntxt,
    U8                                              transmission_mode)

{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U32                             aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;
    rrm_cell_index_t                cell_index;

    RRM_UT_TRACE_ENTER();

    cell_index = p_rrm_ue_cntxt->cell_index;

    p_rrc_phy_cqi_reporting->bitmask = RRM_ZERO;

    p_rrc_phy_cqi_reporting->nom_pdsch_rs_epre_offset = 
        p_ue_profile_phy_cqi_reporting->nom_pdsch_rs_epre_offset;

    /* Periodic + Aperiodic CQI Reporting */
    if((p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
       (p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED) )
    
    {
       if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.rf_params.\
                              rf_configurations.dl_bandwidth == RRM_OAM_BW_N_6)
       {
           /*Aperiodic CQI/PMI/RI reporting are not supported for DL RB's
            *less than 7 (i.e. when Cell bandwidth configured as 1.4 Mhz).
            *Refer spec 36.213 v 9.2.0 sec 7.2.1
            */
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                     "Aperiodic mode not supported for DL RB's less than 7");
           ret_val = RRM_SUCCESS;
       }
       else {
           ret_val = assign_aperiodic_mode_from_tm_mode(
                                              p_rrm_ue_cntxt,
                                              &(p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic),
                                               p_ue_profile_phy_cqi_reporting->rrm_ul_dl_freq_selective_sched,
                                               transmission_mode, 
                                               &aperiodic_mode);
           if(RRM_SUCCESS == ret_val)
           {
               p_rrc_phy_cqi_reporting->bitmask |= 
                     RRC_PHY_CQI_REPORTING_MODE_APERIODIC_PRESENT;
               p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic = aperiodic_mode; 
           }
       }
    }
    /* Periodic CQI Reporting */
    if((p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
       (p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED) )
    {
        p_rrc_phy_cqi_reporting->bitmask |= 
            RRC_PHY_CQI_REPORTING_PERIODIC_PRESENT;
        rrm_rrc_ue_fill_cqi_reporting_periodic
            (&(p_rrc_phy_cqi_reporting->cqi_reporting_periodic),
             &(p_ue_profile_phy_cqi_reporting->cqi_reporting_periodic),
             p_rrm_ue_cntxt, transmission_mode, 
             p_ue_profile_phy_cqi_reporting->rrm_ul_dl_freq_selective_sched);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_assign_wb_aperiodic_mode_from_tm_mode 
 *   INPUT        : p_rrm_ue_cntxt, transmission_mode, p_aperiodic_mode,
 *                : is_fgi_present
 *   OUTPUT       : p_aperiodic_mode                 
 *   DESCRIPTION  :
 *                  Fills the Assigns Paeriodic mode on the basis of TM Mode 
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_assign_wb_aperiodic_mode_from_tm_mode
(
    rrm_ue_context_t                  *p_rrm_ue_cntxt,
    U8                                transmission_mode,
    U32                               *p_aperiodic_mode,
    rrm_bool_et                       is_fgi_present
)
{
    rrm_return_et       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /*spr 8182 start*/
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info = RRM_NULL;
    p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(p_rrm_ue_cntxt->cell_index);
    /*spr 8182 end*/
    /* Check if FGI is present or not */
    if (RRM_FALSE == is_fgi_present)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "1. Feature Group Indicator not present");
        /* Selection of CQI at time of  UE Admission Resp. UE CAPABILITY has not received yet */
        *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;  //0xFFFFFFFF;
        /* COMP_WARN_1_FEB:compilation warning removal */
        ret_val = RRM_FAILURE;
    }
    else
    {
        /*spr 8182 start*/
        switch(transmission_mode)
        {
            case TRANSMISSION_MODE_TM1:
            case TRANSMISSION_MODE_TM2:
            case TRANSMISSION_MODE_TM3:
            case TRANSMISSION_MODE_TM5:
            case TRANSMISSION_MODE_TM7:
                {
                    /* For TM 1, 2, 3, 5 and 7 aperiodic reporting
                       mode is not supported*/
                    *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;   //0xFFFFFFFF;
                    ret_val = RRM_FAILURE;
                    break;
                }
            case TRANSMISSION_MODE_TM4:
            case TRANSMISSION_MODE_TM6:
                {
                    /* For TM 4 and 6 mode 1-2 is selected*/
                    /* Refer to 3gpp Spec table 7.2.1-1 */
                    *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM12;
                    ret_val = RRM_SUCCESS;
                    break;
                }
            case TRANSMISSION_MODE_TM8_V920:
                /* For TM 8, if pmi_ri_report is configured mode 1-2 is selected.
                   Otherwise aperiodic reporting mode is not supported*/
                if(RRM_TRUE == p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9)
                {
                    *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM12;
                    ret_val = RRM_SUCCESS;
                }
                else
                {
                    *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;   //0xFFFFFFFF;
                    ret_val = RRM_FAILURE;
                }
                break;
            default:
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Invalid TM Mode %d", transmission_mode+RRM_ONE);
        }
        /*spr 8182 end*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "WideBand Aperiodic Mode selected is %d", *p_aperiodic_mode);
        /* COMP_WARN_1_FEB:compilation warning removal */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_start*/
rrm_return_et
process_mode_tm8_v920
(
 U8                                 transmission_mode,
 U32                               *p_aperiodic_mode,
 rrm_ue_context_t                  *p_rrm_ue_cntxt
)
{
    rrm_return_et       ret_val = RRM_SUCCESS;
    U8                  tm_mode_and_aperiodic_mode_map
        [MAX_TM_MODE_SUPPORTED][MAX_APERIODIC_MODE] =
        /*Aperiodic Modes */
        {
            /* Transmission Mode */
            /* TRANSMISSION_MODE_TM1*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM2*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM3*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM4*/     {CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31},
            /* TRANSMISSION_MODE_TM5*/     {CQI_REPORTING_MODE_APERIODIC_RM31, 0xFF, 0xFF},
            /* TRANSMISSION_MODE_TM6*/     {CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31},
            /* TRANSMISSION_MODE_TM7*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF}
        };

    RRM_UT_TRACE_ENTER();

    /*spr 8182 start*/
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info = RRM_NULL;
    p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(p_rrm_ue_cntxt->cell_index);
    /*spr 8182 end*/

    if(RRM_TRUE == p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9)
    {
        /* FGI is present */
        /*Start:Bug 762*/
        if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
            /*End:Bug 762*/
        {
            /* For TM 4, UE selected Mode 2-2 is selected */
            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
        }
        /* FGI is absent */
        else
        {
            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_TWO];
        }
    }
    else
    {
        /* FGI is present */
        /*Start:Bug 762*/
        if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
            /*End:Bug 762*/
        {
            /* For TM 1, 2 and 3, UE selected Mode 2-0 is selected */
            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ZERO];
        }
        /* FGI is absent */
        else
        {
            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*klock_works_changes_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_assign_sb_aperiodic_mode_from_tm_mode 
 *   INPUT        : p_rrm_ue_cntxt, transmission_mode, p_aperiodic_mode,
 *                : is_fgi_present
 *   OUTPUT       : p_aperiodic_mode                 
 *   DESCRIPTION  :
 *                  Fills the Assigns Paeriodic mode on the basis of TM Mode 
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_assign_sb_aperiodic_mode_from_tm_mode
(
 rrm_ue_context_t                  *p_rrm_ue_cntxt,
 U8                                 transmission_mode,
 U32                               *p_aperiodic_mode,
 rrm_bool_et                        is_fgi_present
 )
{
    rrm_return_et       ret_val = RRM_SUCCESS;
    U8                  tm_mode_and_aperiodic_mode_map
        [MAX_TM_MODE_SUPPORTED][MAX_APERIODIC_MODE] = 
        /*Aperiodic Modes */  
        { 
            /* Transmission Mode */
            /* TRANSMISSION_MODE_TM1*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM2*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM3*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM4*/     {CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31},
            /* TRANSMISSION_MODE_TM5*/     {CQI_REPORTING_MODE_APERIODIC_RM31, 0xFF, 0xFF},
            /* TRANSMISSION_MODE_TM6*/     {CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31},
            /* TRANSMISSION_MODE_TM7*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF}
        };

    RRM_UT_TRACE_ENTER();



    /* Check if FGI is present or not */
    if (RRM_FALSE == is_fgi_present)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,


                "2. Feature Group Indicator not present");
        *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;   //0xFFFFFFFF;
        /* COMP_WARN_1_FEB:compilation warning removal */
        ret_val = RRM_FAILURE;
    }
    else
    {
        /*spr 8182 start*/
        switch(transmission_mode)
        {
            case TRANSMISSION_MODE_TM1:
            case TRANSMISSION_MODE_TM2:
            case TRANSMISSION_MODE_TM3:
            case TRANSMISSION_MODE_TM7:
                {
                    /* FGI is present */
                    /*Start:Bug 762*/
                    if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
                        /*End:Bug 762*/
                    {
                        /* For TM 1, 2 and 3, UE selected Mode 2-0 is selected */
                        *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ZERO];
                    }
                    /* FGI is absent */
                    else
                    {
                        *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
                    }
                    break;
                }               
            case TRANSMISSION_MODE_TM4:
            case TRANSMISSION_MODE_TM6:
                {
                    /* FGI is present */
                    /*Start:Bug 762*/
                    if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
                        /*End:Bug 762*/
                    {
                        /* For TM 4, UE selected Mode 2-2 is selected */
                        *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
                    }
                    /* FGI is absent */
                    else
                    {
                        *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_TWO];
                    }
                    break;
                }
            case TRANSMISSION_MODE_TM5:
                *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM31;
                break;
            case TRANSMISSION_MODE_TM8_V920:

                /*klock_works_changes_start*/
                ret_val=process_mode_tm8_v920(transmission_mode, p_aperiodic_mode, p_rrm_ue_cntxt);
                /*klock_works_changes_End*/ 
                /*Coverity ID 82151 Fix Start*/  
                if(ret_val == RRM_FAILURE)
                {    
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Failure:process_mode_tm8_v920");
                }
                /*Coverity ID 82151 Fix End*/  
                break;

            default:
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "2. Invalid TM Mode %d", transmission_mode+RRM_ONE);
        }
        /*spr 8182 end*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "SubBand Aperiodic Mode selected is %d", *p_aperiodic_mode);

        /* COMP_WARN_1_FEB:compilation warning removal */
        ret_val = RRM_SUCCESS;     
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME: assign_aperiodic_mode_from_tm_mode 
 *   INPUT        : p_rrm_ue_cntxt,freq_selective_sched,transmission_mode,
                    p_aperiodic_mode
 *   OUTPUT       : p_rrc_reporting_mode_aperiodic                 
 *   DESCRIPTION  :
 *                  Fills the Assigns Paeriodic mode on the basis of TM Mode 
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et assign_aperiodic_mode_from_tm_mode(rrm_ue_context_t                *p_rrm_ue_cntxt, 
                                               U8                                *p_rrc_reporting_mode_aperiodic,
                                               rrm_ul_dl_freq_selective_sched_et  freq_selective_sched,
                                               U8                                 transmission_mode,
                                               U32                               *p_aperiodic_mode)
{
    rrm_bool_et         is_fgi_present = RRM_FALSE;
    rrm_return_et       ret_val = RRM_SUCCESS;

    RRM_ASSERT(p_rrc_reporting_mode_aperiodic != RRM_PNULL);
    RRM_ASSERT(p_rrm_ue_cntxt != RRM_PNULL);

    RRM_UT_TRACE_ENTER();
    /*KLOC FIX */    
    if(RRM_PNULL == p_rrm_ue_cntxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "UE CONTEXT IS NULL ");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;

    }

    if(RRM_PNULL == p_rrc_reporting_mode_aperiodic)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "RRC REPORTING MODE APERIODIC IS NULL ");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* klocwork_27Mar: Start */
    /* moved line from 'spr 8182' tag so that p_rrm_ue_cntxt NULL check is done before accessing value from p_rrm_ue_cntxt */
    /* Moved line from here */
    /* klocwork_27Mar: End */
    if(p_rrm_ue_cntxt->ue_capability_params.bitmask)
    {
        if(p_rrm_ue_cntxt->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Feature Group Indicator present" );
            /* flag was getting set before entering this leg */
            is_fgi_present = RRM_TRUE;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Feature Group Indicator not present");
       *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;  //0xFFFFFFFF;
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;     
    }
    /* Wideband:- Identified by logic:- Either Freq Selective scheduling is disabled in both UL/DL
                                        OR     Freq Selective scheduling is enabled in UL Only
    */
    if ((RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH == freq_selective_sched) ||
        (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY == freq_selective_sched))
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "WideBand Selection is done for TM Mode %d", transmission_mode+RRM_ONE);
       /* Klocwork_fix_march_14_start */
       ret_val = rrm_assign_wb_aperiodic_mode_from_tm_mode (p_rrm_ue_cntxt, transmission_mode,
                                                            p_aperiodic_mode, is_fgi_present);
       /* Klocwork_fix_march_14_end */
    }
    /* Subband:- Identified by logic:- Either  Freq Selective scheduling is enabled in both UL/DL
                                        OR     Freq Selective scheduling is enabled in DL Only
    */
    else if ((RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH == freq_selective_sched) ||
             (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY == freq_selective_sched))
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "SubBand Selection is done for TM Mode %d", transmission_mode+RRM_ONE);
       /* Klocwork_fix_march_14_start */
       ret_val = rrm_assign_sb_aperiodic_mode_from_tm_mode (p_rrm_ue_cntxt, transmission_mode,
                                                            p_aperiodic_mode, is_fgi_present);
       /* Klocwork_fix_march_14_end */
    }
 
    RRM_UT_TRACE_EXIT();
    return ret_val;     
}
/* SUB Band CQI end */

/******************************************************************************
 *   FUNCTION NAME: rrm_assign_aperiodic_mode_from_tm_mode_r10
 *   INPUT        : p_rrm_ue_cntxt,freq_selective_sched,transmission_mode,
                    p_aperiodic_mode
 *   OUTPUT       : p_aperiodic_mode                 
 *   DESCRIPTION  :
 *                  Fills the Assigns Aperiodic mode for cell on the basis of 
 *                  TM Mode of that cell.
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et 
rrm_assign_aperiodic_mode_from_tm_mode_r10(rrm_ue_context_t                    *p_rrm_ue_cntxt, 
                                       rrm_ul_dl_freq_selective_sched_et    freq_selective_sched,
                                       U8                                   transmission_mode,
                                       U32                                 *p_aperiodic_mode,
                                       const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info)
{
    rrm_bool_et         is_fgi_present = RRM_FALSE;
    rrm_return_et       ret_val = RRM_SUCCESS;
    U8                  tm_mode_and_aperiodic_mode_map
        [MAX_TM_MODE_SUPPORTED][MAX_APERIODIC_MODE] = 
        /*Aperiodic Modes */  
        { 
            /* Transmission Mode */
            /* TRANSMISSION_MODE_TM1*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM2*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM3*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM4*/     {CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31},
            /* TRANSMISSION_MODE_TM5*/     {CQI_REPORTING_MODE_APERIODIC_RM31, 0xFF, 0xFF},
            /* TRANSMISSION_MODE_TM6*/     {CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31},
            /* TRANSMISSION_MODE_TM7*/     {CQI_REPORTING_MODE_APERIODIC_RM20,CQI_REPORTING_MODE_APERIODIC_RM30, 0xFF},
            /* TRANSMISSION_MODE_TM8_V920*/{CQI_REPORTING_MODE_APERIODIC_RM12,CQI_REPORTING_MODE_APERIODIC_RM22, CQI_REPORTING_MODE_APERIODIC_RM31}
        };

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_rrm_ue_cntxt != RRM_PNULL);

    if(p_rrm_ue_cntxt->ue_capability_params.bitmask)
    {
        if(p_rrm_ue_cntxt->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.bitmask &
                RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Feature Group Indicator present" );
            is_fgi_present = RRM_TRUE;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Feature Group Indicator not present");
        *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;  //0xFFFFFFFF;
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;     
    }
    /* Wideband:- Identified by logic:- Either Freq Selective scheduling is disabled in both UL/DL
       OR     Freq Selective scheduling is enabled in UL Only
       */
    if ((RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH == freq_selective_sched) ||
            (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY == freq_selective_sched))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "WideBand Selection is done for TM Mode %d", transmission_mode+RRM_ONE);
        /* Check if FGI is present or not */
        if (RRM_FALSE == is_fgi_present)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "1. Feature Group Indicator not present");
            /* Selection of CQI at time of  UE Admission Resp. UE CAPABILITY has not received yet */
            *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;  //0xFFFFFFFF;
            RRM_UT_TRACE_EXIT();
            ret_val = RRM_FAILURE;
        }
        else
        {
            switch(transmission_mode)
            {
                case TRANSMISSION_MODE_TM1:
                case TRANSMISSION_MODE_TM2:
                case TRANSMISSION_MODE_TM3:
                case TRANSMISSION_MODE_TM5:
                case TRANSMISSION_MODE_TM7:
                    {
                        /* For TM 1, 2, 3, 5 and 7 aperiodic reporting
                           mode is not supported*/
                        *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;   //0xFFFFFFFF;
                        ret_val = RRM_FAILURE;
                        break;
                    }
                case TRANSMISSION_MODE_TM4:
                case TRANSMISSION_MODE_TM6:
                    {
                        /* For TM 4 and 6 mode 1-2 is selected*/
                        /* Refer to 3gpp Spec table 7.2.1-1 */
                        *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM12;
                        ret_val = RRM_SUCCESS;
                        break;
                    }
                case TRANSMISSION_MODE_TM8_V920:
                    /* For TM 8, if pmi_ri_report is configured mode 1-2 is selected.
                       Otherwise aperiodic reporting mode is not supported*/
                if(RRM_TRUE == p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9)
                {
                    *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM12;
                    ret_val = RRM_SUCCESS;
                }
                else
                {
                    *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;   //0xFFFFFFFF;
                    ret_val = RRM_FAILURE;
                }
                break;
                default:
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Invalid TM Mode %d", transmission_mode+RRM_ONE);
            }
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "WideBand Aperiodic Mode selected is %d", *p_aperiodic_mode);
        }
    }
    /* Subband:- Identified by logic:- Either  Freq Selective scheduling is enabled in both UL/DL
       OR     Freq Selective scheduling is enabled in DL Only
       */
    else if ((RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH == freq_selective_sched) ||
            (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY == freq_selective_sched))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "SubBand Selection is done for TM Mode %d", transmission_mode+RRM_ONE);
        /* Check if FGI is present or not */
        if (RRM_FALSE == is_fgi_present)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "2. Feature Group Indicator not present");
            *p_aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;   //0xFFFFFFFF;
            ret_val = RRM_FAILURE;
        }
        else
        {
            switch(transmission_mode)
            {
                case TRANSMISSION_MODE_TM1:
                case TRANSMISSION_MODE_TM2:
                case TRANSMISSION_MODE_TM3:
                case TRANSMISSION_MODE_TM7:
                    {
                        /* FGI is present */
                        if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
                        {
                            /* For TM 1, 2 and 3, UE selected Mode 2-0 is selected */
                            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ZERO];
                        }
                        /* FGI is absent */
                        else
                        {
                            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
                        }
                        break;
                    }               
                case TRANSMISSION_MODE_TM4:
                case TRANSMISSION_MODE_TM6:
                    {
                        /* FGI is present */
                        if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
                        {
                            /* For TM 4, UE selected Mode 2-2 is selected */
                            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
                        }
                        /* FGI is absent */
                        else
                        {
                            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_TWO];
                        }
                        break;
                    }
                case TRANSMISSION_MODE_TM5:
                    *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM31;
                    break;
                case TRANSMISSION_MODE_TM8_V920:
                    if(RRM_TRUE == p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9)
                    {
                        /* FGI is present */
                        if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
                        {
                            /* For TM 8, UE selected Mode 2-2 is selected */
                            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_ONE];
                        }
                        /* FGI is absent */
                        else
                        {   /* For TM 8, Higher Layer selected Mode 3-1 is selected */
                            *p_aperiodic_mode = tm_mode_and_aperiodic_mode_map[transmission_mode][RRM_TWO];
                        }
                    }
                    else
                    {
                        /* FGI is present */
                        if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_ONE)) == RRM_TRUE)
                        {
                            /* For TM 8, UE selected Mode 2-0 is selected if UE Selected & No PMI*/
                            *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM20;
                        }
                        /* FGI is absent */
                        else
                        {
                            /* For TM 8, UE selected Mode 3-0 is selected if Subband Higher Layer Selected & No PMI*/
                            *p_aperiodic_mode = CQI_REPORTING_MODE_APERIODIC_RM30;
                        }
                    }
                    break;
                default:
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "2. Invalid TM Mode %d", transmission_mode+RRM_ONE);
            }
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "SubBand Aperiodic Mode selected is %d", *p_aperiodic_mode);

            ret_val = RRM_SUCCESS;     
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;     
}

/* SRS Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_sounding_reference_signal
 *   INPUT        : p_rrm_ue_cntxt
 *   OUTPUT       : p_rrc_phy_sounding_rs_ul_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the  sounding_reference_signal dedicated parameters
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 *****************************************************************************/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_sounding_reference_signal
(
    rrc_phy_sounding_rs_ul_config_dedicated_t 
                        *p_rrc_phy_sounding_rs_ul_config_dedicated,
    rrm_ue_context_t    *p_rrm_ue_cntxt   
)
{
    rrm_return_et       ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    p_rrc_phy_sounding_rs_ul_config_dedicated->bitmask |= RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PARAM_PRESENT;
    /* srs_bandwidth shall be 0 as of now if hopping is enabled then it can 
       be changed in the range ( 0 to 3 )*/
    
    /* SRS_FREQ_HOPPING_START */
    
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.srs_bandwidth = 
                                                                 p_rrm_ue_cntxt->srs_params.srs_bandwidth;
    /* srs_hopping_bandwidth shall be FALSE currently RRM doesn't support
       hopping because applying SRS only for wideband */
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.srs_hopping_bandwidth = 
                                                            p_rrm_ue_cntxt->srs_params.srs_hopping_bandwidth;
    /** As of now keeping frequency domain position as zero */
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.frequency_domain_position = 
                                                                p_rrm_ue_cntxt->srs_params.frequency_domain_position;
    /** Duration can periodic or aperiodic right now supportin periodic */
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.duration = 
                                                      p_rrm_ue_cntxt->srs_params.duration;

    /* SRS_FREQ_HOPPING_END */
    
    /** SRS configuration index from UE context */
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.srs_configuration_index =
        p_rrm_ue_cntxt->srs_params.srs_configuration_index;
    /** Transmission comb selected from srs table assigned from ue context */
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.transmission_comb =
        p_rrm_ue_cntxt->srs_params.transmission_comb;
    /** Cyclic shift from UE context */
    p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param.cyclic_shift = 
        p_rrm_ue_cntxt->srs_params.cyclic_shift;
    /*spr_19392_changes_start*/
    ret_val = RRM_SUCCESS;
    /*spr_19392_changes_end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SRS end */

/* SPR 16906 Fix Start */
/* Dead Code Removed */
/* SPR 16906 Fix End */

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_ue_transmit_antenna_selection
 *   INPUT        : p_ue_profile_ue_transmit_antenna_selection
 *   OUTPUT       : p_rrc_phy_ue_transmit_antenna_selection
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_ue_transmit_antenna_selection_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_ue_transmit_antenna_selection(
        rrc_phy_ue_transmit_antenna_selection_t 
        *p_rrc_phy_ue_transmit_antenna_selection,
        rrc_phy_ue_transmit_antenna_selection_ue_service_profile_t 
        *p_ue_profile_ue_transmit_antenna_selection
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if(p_ue_profile_ue_transmit_antenna_selection->bitmask & 
            RRC_SERVICE_PROFILE_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT)   
    {
        p_rrc_phy_ue_transmit_antenna_selection->bitmask |= 
            RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT;
        p_rrc_phy_ue_transmit_antenna_selection->
            ue_transmit_antenna_selection_type = 
            p_ue_profile_ue_transmit_antenna_selection->
            ue_transmit_antenna_selection_type;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_antenna_information
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_phy_antenna_information
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_antenna_information_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_antenna_information(
        rrm_ue_context_t *p_rrm_ue_context,
        rrc_phy_physical_config_dedicated_t    *p_phy_config_dedicated
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrm_bool_et			    antenna_info_match = RRM_TRUE;

    RRM_UT_TRACE_ENTER();
    /* R-10 Changes : Start*/
    /* SPR-16135 START */
    if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
        eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_phy_config_dedicated->antenna_info_r10.bitmask |=
                            RRC_ANTENNA_INFO_R10_EXPLICIT_VALUE_PRESENT;
    }
    else
    {
    p_phy_config_dedicated->antenna_information.bitmask |= 
                            RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT;
    }
    /* R-10 Changes : End */

	/*LTE_RRM_TM_SWITCH_START*/
    ret_val = rrm_fill_transmission_mode( p_rrm_ue_context,
                                          p_phy_config_dedicated,  
                                          &antenna_info_match );
	        
	/*LTE_RRM_TM_SWITCH_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_scheduling_request_config_param
 *   INPUT        : p_rrm_ue_cntxt,_ue_profile_scheduling_request_config_param
 *   OUTPUT       : p_rrc_phy_scheduling_request_config_param
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_scheduling_request_config_param_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_scheduling_request_config_param(
        rrc_phy_scheduling_request_config_param_t 
        *p_rrc_phy_scheduling_request_config_param,
        rrm_ue_context_t   *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_rrc_phy_scheduling_request_config_param->sr_pucch_resource_index = 
        p_rrm_ue_cntxt->sr_params.sr_pucch_res_index;

    p_rrc_phy_scheduling_request_config_param->sr_configuration_index = 
        p_rrm_ue_cntxt->sr_params.sr_configuration_index;
    
    /* CHANGES_FRM_XML_TO_CFG START */
    p_rrc_phy_scheduling_request_config_param->dsr_trans_max = RRM_DEFINED_DEFAULT_VALUE_FOR_SR_MAX_TRANS_UE_ADMSN;  
    /* CHANGES_FRM_XML_TO_CFG END */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_scheduling_request_config
 *   INPUT        : p_ue_profile_phy_scheduling_request_config,p_rrm_ue_cntxt
 *   OUTPUT       : p_rrc_phy_scheduling_request_config
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_scheduling_request_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_scheduling_request_config(
        rrc_phy_scheduling_request_config_t                    
        *p_rrc_phy_scheduling_request_config,
        rrm_ue_context_t                                       
        *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_phy_scheduling_request_config->bitmask |= 
        RRC_PHY_SCHEDULING_REQUEST_CONFIG_PARAM_PRESENT;
    rrm_rrc_ue_adm_resp_fill_scheduling_request_config_param
        (&(p_rrc_phy_scheduling_request_config->
           scheduling_request_config_param),
         p_rrm_ue_cntxt);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_param for pucch
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_phy_tpc_pdcch_config_param_pucch
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_tpc_pdcch_config_param_t for pucch
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
void
rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_param_pucch(
        rrc_phy_tpc_pdcch_config_param_t
        *p_rrc_phy_tpc_pdcch_config_param_pucch,
        rrm_ue_context_t
        *p_rrm_ue_context
        )
{

    U16 tpc_rnti = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    tpc_rnti = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch << RRM_EIGHT;
    p_rrc_phy_tpc_pdcch_config_param_pucch->tpc_rnti[RRM_ONE] =
        tpc_rnti >> RRM_EIGHT;
    p_rrc_phy_tpc_pdcch_config_param_pucch->tpc_rnti[RRM_ZERO] =
        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch >> RRM_EIGHT;

    if(p_rrm_ue_context->rrm_ue_clpc_params.
            dci_format_pucch == RRM_DCI_FORMAT_3)
    {
       p_rrc_phy_tpc_pdcch_config_param_pucch->tpc_index.bitmask |=
           TPC_INDEX_FORMAT_3_PRESENT;
       p_rrc_phy_tpc_pdcch_config_param_pucch->tpc_index.index_of_format3 =
           p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pucch;
    }
    else if(p_rrm_ue_context->rrm_ue_clpc_params.
            dci_format_pucch == RRM_DCI_FORMAT_3A)
    {
        p_rrc_phy_tpc_pdcch_config_param_pucch->tpc_index.bitmask |=
            TPC_INDEX_FORMAT_3A_PRESENT;
        p_rrc_phy_tpc_pdcch_config_param_pucch->tpc_index.index_of_format3a =
            p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pucch;
    }
    RRM_UT_TRACE_EXIT();

}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pucch
 *   INPUT        : p_rrm_ue_cntxt
 *   OUTPUT       : p_rrc_phy_tpc_pdcch_configuration_pucch
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_tpc_pdcch_configuration_t for pucch
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pucch(
        rrc_phy_tpc_pdcch_configuration_t
        *p_rrc_phy_tpc_pdcch_configuration_pucch,
        rrm_ue_context_t
        *p_rrm_ue_cntxt
        )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_rrc_phy_tpc_pdcch_configuration_pucch->bitmask |=   
        RRC_PHY_TPC_PDCCH_CONFIG_PARAM_PRESENT;
    rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_param_pucch(
            &(p_rrc_phy_tpc_pdcch_configuration_pucch->tpc_pdcch_config_param),
            p_rrm_ue_cntxt);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_param for pusch
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_phy_tpc_pdcch_config_param_pusch
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_tpc_pdcch_config_param_t for pusch
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_param_pusch(
        rrc_phy_tpc_pdcch_config_param_t
        *p_rrc_phy_tpc_pdcch_config_param_pusch,
        rrm_ue_context_t
        *p_rrm_ue_context
        )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    U16 tpc_rnti = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    tpc_rnti = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch << RRM_EIGHT;
    p_rrc_phy_tpc_pdcch_config_param_pusch->tpc_rnti[RRM_ONE] =
        tpc_rnti >> RRM_EIGHT;
    p_rrc_phy_tpc_pdcch_config_param_pusch->tpc_rnti[RRM_ZERO] =
        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch >> RRM_EIGHT;
    /* SPR 18621 Changes Start */
    if(p_rrm_ue_context->rrm_ue_clpc_params.
            dci_format_pusch == RRM_DCI_FORMAT_3)
    {
       p_rrc_phy_tpc_pdcch_config_param_pusch->tpc_index.bitmask |=
           TPC_INDEX_FORMAT_3_PRESENT;
       p_rrc_phy_tpc_pdcch_config_param_pusch->tpc_index.index_of_format3 =
           p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch;
    }
    else if(p_rrm_ue_context->rrm_ue_clpc_params.
            dci_format_pusch == RRM_DCI_FORMAT_3A)
    {
        p_rrc_phy_tpc_pdcch_config_param_pusch->tpc_index.bitmask |=
            TPC_INDEX_FORMAT_3A_PRESENT;
        p_rrc_phy_tpc_pdcch_config_param_pusch->tpc_index.index_of_format3a =
            p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch;
    }

    /* SPR 18621 Changes Stop */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pusch
 *   INPUT        : p_rrm_ue_cntxt
 *   OUTPUT       : p_rrc_phy_tpc_pdcch_configuration_pusch
 *   DESCRIPTION  :
 *                   Fills the rrc_phy_tpc_pdsch_configuration_t for pusch
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pusch(
        rrc_phy_tpc_pdcch_configuration_t
        *p_rrc_phy_tpc_pdcch_configuration_pusch,
        rrm_ue_context_t
        *p_rrm_ue_cntxt
        )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_rrc_phy_tpc_pdcch_configuration_pusch->bitmask |=
        RRC_PHY_TPC_PDCCH_CONFIG_PARAM_PRESENT;
    rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_param_pusch(
            &(p_rrc_phy_tpc_pdcch_configuration_pusch->tpc_pdcch_config_param),
            p_rrm_ue_cntxt);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_adm_resp_fill_physical_config_dedicated
 *   INPUT        : p_ue_profile_physical_config_dedicated,p_rrm_ue_context
 *                  ul_mcs,dl_mcs
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_physical_config_dedicated_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_rrc_ue_adm_resp_fill_physical_config_dedicated(
        rrc_phy_physical_config_dedicated_t                    
        *p_rrc_phy_physical_config_dedicated,
        rrc_phy_physical_config_dedicated_ue_service_profile_t 
        *p_ue_profile_physical_config_dedicated,
        rrm_ue_context_t                                       
        *p_rrm_ue_context,
        U8
        *ul_mcs,
        U8
        *dl_mcs
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrm_physical_layer_params_t     *p_rrm_physical_layer_params = RRM_NULL;
    admission_control_info_t        *p_admission_control_info = RRM_NULL;
    rrm_cell_index_t                 cell_index = p_rrm_ue_context->cell_index;
    
    RRM_UT_TRACE_ENTER();
    p_rrm_physical_layer_params = 
        rrm_cellm_get_physical_layer_params(cell_index);
     p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);

    if(p_rrm_physical_layer_params != RRM_NULL)   
    {
       p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_PDSCH_CONFIGURATION_DEDICATED_PRESENT;
        /*DYNAMIC ICIC START*/
        rrm_rrc_ue_adm_resp_fill_pdsch_configuration_dedicated
            (&(p_rrc_phy_physical_config_dedicated->
               pdsch_configuration_dedicated), p_rrm_ue_context );

                  
        /*DYNAMIC ICIC END*/
       
	p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_PUCCH_CONFIGURATION_DEDICATED_PRESENT;
        rrm_rrc_ue_adm_resp_fill_pucch_configuration_dedicated
            (&(p_rrc_phy_physical_config_dedicated->
         /*SPR 17777 +-*/
               pucch_configuration_dedicated)
#ifdef TDD_MODE_FLAG             
             ,p_rrm_physical_layer_params
#endif             
             );
         /*SPR 17777 +-*/
    }

    //no support pucch_configuration_dedicated
    *ul_mcs =  p_admission_control_info->snr_map.
        snr_dep_params.uplink_snr_dep_params.ul_mcs;

    if( p_admission_control_info->snr_map.snr_dep_params.
            uplink_snr_dep_params.bitmask & PUSCH_INFO_SNR_MAP_PRESENT )
    {
        p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT;
        rrm_rrc_ue_adm_resp_fill_pusch_configuration_dedicated
            (&(p_rrc_phy_physical_config_dedicated->
               pusch_configuration_dedicated),
             &(p_admission_control_info->snr_map.
                 snr_dep_params.uplink_snr_dep_params.
                 pusch_config_dedicated));
    }

    if( p_admission_control_info->snr_map.snr_dep_params.
            uplink_snr_dep_params.bitmask &
            UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT )
    {
        p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;
        rrm_rrc_ue_adm_resp_fill_uplink_power_control_dedicated
            (&(p_rrc_phy_physical_config_dedicated->
               uplink_power_control_dedicated),\
             &(p_admission_control_info->snr_map.
                 snr_dep_params.uplink_snr_dep_params.\
                 uplink_pow_control));
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch = 
            p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.
            uplink_pow_control.p0_ue_pusch;
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch = 
            p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.
            uplink_pow_control.p0_ue_pucch;
    }
    
    /*spr 8495 fix start*/
    p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch=
			p_rrc_phy_physical_config_dedicated->uplink_power_control_dedicated.p0_ue_pusch;
    
    p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch=
			p_rrc_phy_physical_config_dedicated->uplink_power_control_dedicated.p0_ue_pucch;
    /*spr 8495 fix end*/
    
    //fill antenna information from downlink snr param
    *dl_mcs = p_admission_control_info->snr_map.
        snr_dep_params.downlink_snr_dep_params.dl_mcs;
  
    //no support sounding_rs_ul_config_dedicated

     p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_ANTENNA_INFORMATION_PRESENT;
        
     rrm_rrc_ue_adm_resp_fill_antenna_information( p_rrm_ue_context,
             					   p_rrc_phy_physical_config_dedicated );
               					  
    

    if(p_ue_profile_physical_config_dedicated->bitmask & 
            RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT)
    {
        p_rrc_phy_physical_config_dedicated->bitmask |= 
            RRC_PHY_CQI_REPORTING_PRESENT;
        p_rrc_phy_physical_config_dedicated->cqi_reporting.bitmask = RRM_ZERO;

      /* LTE_RRM_CONFIG_START */
       p_rrc_phy_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset = RRM_ZERO;
      /*LTE_RRM_CONFIG_END*/

    }

    p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated.bitmask = RRM_ZERO;
    if(RRM_TRUE == rrm_cellm_get_srs_status(p_rrm_ue_context->cell_index))
    {
    /* Filling the sounding reference signal parameters */
    /* SRS start */ 
    p_rrc_phy_physical_config_dedicated->bitmask |=
        RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;

        /*spr_19392_changes_start*/
        ret_val = rrm_rrc_ue_adm_resp_fill_sounding_reference_signal
        (&(p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated),
         p_rrm_ue_context);
        if(RRM_SUCCESS == ret_val)
        {
            p_rrc_phy_physical_config_dedicated->bitmask |=
                 RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;
        }
        /*spr_19392_changes_end*/

    }
    /* SRS end */

    p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT;
    rrm_rrc_ue_adm_resp_fill_scheduling_request_config(&(p_rrc_phy_physical_config_dedicated->scheduling_request_config),\
            					        p_rrm_ue_context);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_fill_ue_adm_resp_radio_res_config
 *   INPUT        : p_rrm_ue_cntxt,p_ue_profile_ue_adm_radio_res_config
 *   OUTPUT       : p_rrm_ue_adm_radio_res_config
 *   DESCRIPTION  :
 *                  filling for radio_res_config of ue admission response 
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_ue_adm_resp_fill_radio_res_config(
        rrm_ue_adm_radio_res_config_t                     
        *p_rrm_ue_adm_radio_res_config,
        rrm_ue_adm_radio_res_config_ue_service_profile_t  
        *p_ue_profile_ue_adm_radio_res_config,
        rrm_ue_context_t                                  
        *p_rrm_ue_cntxt
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rlc_layer_params_t              *p_rlc_layer_params = RRM_NULL;
    rrm_cell_index_t                cell_index = p_rrm_ue_cntxt->cell_index;
    U8                              ul_mcs = RRM_ZERO;
    U8                              dl_mcs = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    p_rlc_layer_params = rrm_cellm_get_srb_info(cell_index);
    if(p_rlc_layer_params != RRM_NULL)
    { 
        /* Start CSR 00059256 */       
        if (p_rlc_layer_params->num_valid_srb_info != RRM_ZERO)
        /* End CSR 00059256 */
        {
            p_rrm_ue_adm_radio_res_config->bitmask |= 
                RRM_UE_ADM_RADIO_RESP_SRB_INFO_PRESENT;
            rrm_rrc_ue_adm_resp_fill_srb1_info
                (&(p_rrm_ue_adm_radio_res_config->srb_info),p_rlc_layer_params,
                 p_rrm_ue_cntxt);
        }
    }
   
    //no support sps_config

    if ( p_ue_profile_ue_adm_radio_res_config->bitmask & 
            RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT )
    { 
        p_rrm_ue_adm_radio_res_config->bitmask |= 
            RRM_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT;
        rrm_rrc_ue_adm_resp_fill_physical_config_dedicated
            (&(p_rrm_ue_adm_radio_res_config->physical_config_dedicated),\
             &(p_ue_profile_ue_adm_radio_res_config->physical_config_dedicated)
             ,p_rrm_ue_cntxt,&ul_mcs,&dl_mcs);
    }

    p_rrm_ue_adm_radio_res_config->bitmask |=
            RRM_UE_ADM_RADIO_RESP_MAC_CONFIG_PRESENT;
    rrm_rrc_ue_adm_resp_fill_mac_config
        (&(p_rrm_ue_adm_radio_res_config->mac_config),
         &(p_ue_profile_ue_adm_radio_res_config->mac_config),
         p_rrm_ue_cntxt,ul_mcs,dl_mcs);

    //no support meas_config
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_adm_resp_wait_time
 *   INPUT        : wait_time_ue_profile,p_rrm_ue_context,wait_time_adm_resp
 *   OUTPUT       : response
 *   DESCRIPTION  :
 *                  filling for wait time of ue adm resp
 *   RETURNS      :
 *                   none 
 ******************************************************************************/

void
fill_adm_resp_wait_time(
                           U8                     *wait_time_adm_resp,
                           U8                     wait_time_ue_profile
         /*SPR 17777 +-*/
                        )
{
    RRM_UT_TRACE_ENTER();
    /**Need to decide in the basis of establishment cause stored in ue context         and response code */
    *wait_time_adm_resp = wait_time_ue_profile;
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_fill_ue_admission_resp
 *   INPUT        : cell_index,ue_index,p_rrm_ue_cntxt,p_rrc_rrm_ue_admission_resp
 *   OUTPUT       : response
 *   DESCRIPTION  :
 *                  Get the UE context identifier
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et 
rrm_rrc_fill_ue_admission_resp(
        /*SPR_15323 start*/
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
        /*SPR_15323 end*/
        rrc_rrm_ue_admission_resp_t *p_rrc_rrm_ue_admission_resp, 
        rrm_ue_context_t *p_rrm_ue_cntxt, 
        rrm_ue_response_et response,
        /*SPR 15439 Fix Start*/
        rrc_ue_adm_resp_fail_cause_et ue_adm_fail_cause
        /*SPR 15439 Fix End*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = NULL;

    RRM_UT_TRACE_ENTER();
    do
    {
        RRM_MEMSET(p_rrc_rrm_ue_admission_resp, RRM_ZERO,
                (sizeof(rrc_rrm_ue_admission_resp_t)));
       
/*BUG 585 FIX START*/
        p_rrc_rrm_ue_admission_resp->response = response;

        /*SPR 15439 Fix Start*/
        if(response == RRM_UE_FAILURE)
         {
             p_rrc_rrm_ue_admission_resp->bitmask |= RRM_UE_ADM_RESP_API_FAIL_CAUSE_PRESENT;
             p_rrc_rrm_ue_admission_resp->fail_cause = ue_adm_fail_cause;
         }
         /*SPR 15439 Fix End*/
        /*SPR_15323 start*/
        p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_rrc_msg->cell_index);
        p_rrc_rrm_ue_admission_resp->ue_index = p_rrm_ue_rrc_msg->ue_index;
        /*SPR_15323 end*/

        if(p_ue_service_profile == RRM_NULL)
            break;
        
        fill_adm_resp_wait_time(&(p_rrc_rrm_ue_admission_resp->wait_time),
                                  p_ue_service_profile->wait_time);
         /*SPR 17777 +-*/

        /*Rel10 CR 588 changes start*/
        /*SPR_15323 start*/
        if( RRM_UE_ESTAB_CAUSE_DELAYTOLERANTACCESS_V1020 == *((rrm_ue_establishment_cause_et*)p_rrm_ue_rrc_msg->p_msg_data))
        {
        /*SPR_15323 end*/
            if (RRM_SERVICE_PROFILE_UE_ADM_EXTENDED_WAIT_TIME_PRESENT & p_ue_service_profile->bitmask)
            {
                p_rrc_rrm_ue_admission_resp->bitmask |=
                    RRM_UE_ADM_RESP_API_UE_ADM_EXTENDED_WAIT_TIME_PRESENT;
                p_rrc_rrm_ue_admission_resp->extended_wait_time =
                    p_ue_service_profile->extended_wait_time;
            }
        }
        /*Rel10 CR 588 changes end*/

        if(response == RRM_UE_FAILURE) /*Kshitij 14195 rel1.3*/
        {
            break;
        }

        p_rrc_rrm_ue_admission_resp->bitmask |= 
            RRM_UE_ADM_RESP_API_UE_ADM_RADIO_RESP_PRESENT;
        rrm_rrc_ue_adm_resp_fill_radio_res_config
            (&(p_rrc_rrm_ue_admission_resp->radio_res_config),
             &(p_ue_service_profile->radio_res_config),p_rrm_ue_cntxt);

    }while(0);
    RRM_UT_TRACE_EXIT();
    return ret_val;   
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_rohc_profile
 *   INPUT        : p_rrm_ue_pdcp_rohc_profile,p_erb_profile_rohc_profile
 *   OUTPUT       : p_rrc_pdcp_rohc_profile
 *   DESCRIPTION  :
 *                  Fills the rrc_pdcp_rohc_profile_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_rohc_profile(
        rrc_pdcp_rohc_profile_t                     
        *p_rrc_pdcp_rohc_profile,
        rrm_ue_pdcp_rohc_profile_t
        *p_rrm_ue_pdcp_rohc_profile,
        rrc_pdcp_rohc_profile_erb_service_profile_t
        *p_erb_profile_rohc_profile)
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0001 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0001 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0001 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0001;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0002 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0002 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0002 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0002;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0003 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0003 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0003 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0003;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0004 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0004 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0004 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0004;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0006 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0006 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0006 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0006;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0101 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0101 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0101 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0101;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0102 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0102 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0102 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0102;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0103 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0103 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0103 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0103;
    }
    if((p_rrm_ue_pdcp_rohc_profile->profile0x0104 == RRM_ONE)
            && (p_erb_profile_rohc_profile->profile0x0104 == RRM_ONE))
    {
        p_rrc_pdcp_rohc_profile->profile0x0104 = 
            p_rrm_ue_pdcp_rohc_profile->profile0x0104;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_rohc_max_cid
 *   INPUT        : max_rohc_ctxt_session 
 *   OUTPUT       : none
 *   DESCRIPTION  : This Function allocates the max cid value based on max cid 
 *                  received in the UE capbility ind mesage.
 *
 *   RETURNS      :  U16
 *       
 ******************************************************************************/
U16 rrm_uem_fill_rohc_max_cid(
      rrm_ue_max_num_rohc_context_session_et  max_rohc_ctxt_session)
{
  U16 cid = RRM_ZERO;

  RRM_UT_TRACE_ENTER();
 
  switch(max_rohc_ctxt_session)
  {
    case RRM_UE_CS2:
      cid = RRM_UE_CS_2;
      break;
    case RRM_UE_CS4:
      cid = RRM_UE_CS_4;
      break;
    case RRM_UE_CS8:
      cid = RRM_UE_CS_8;
      break;
    case RRM_UE_CS12:
      cid = RRM_UE_CS_12;
      break;
    case RRM_UE_CS16:
      cid = RRM_UE_CS_16;
      break;
    case RRM_UE_CS24:
      cid = RRM_UE_CS_24;
      break;
    case RRM_UE_CS32:
      cid = RRM_UE_CS_32;
      break;
    case RRM_UE_CS48:
      cid = RRM_UE_CS_48;
      break;
    case RRM_UE_CS64:
      cid = RRM_UE_CS_64;
      break;
    case RRM_UE_CS128:
      cid = RRM_UE_CS_128;
      break;
    case RRM_UE_CS256:
      cid = RRM_UE_CS_256;
      break;
    case RRM_UE_CS512:
      cid = RRM_UE_CS_512;
      break;
    case RRM_UE_CS1024:
      cid = RRM_UE_CS_1024;
      break;
    case RRM_UE_CS16384:
      cid = RRM_UE_CS_16384;
      break;
    case RRM_UE_SPARE2:
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
	        "RRM_UE_SPARE2");
      break;
    case RRM_UE_SPARE1:
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
	        "RRM_UE_SPARE1");
      break;

    default:
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
	        "Invalid max_cid [%d]", max_rohc_ctxt_session);
      break;
  }/*switch case ends*/  

  RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Max Context id [%d]", cid);
  RRM_UT_TRACE_EXIT(); 
  return cid;
}


/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_max_cid
 *   INPUT        : max_cid_from_conf_file,p_max_cid_to_rrc,ue_capa_max_cid
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *                  Fills the max_cid
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
fill_erb_setup_modify_resp_max_cid(
     U16                                       *p_max_cid_to_rrc,
     rrm_ue_max_num_rohc_context_session_et     ue_capa_max_cid,
     U16                                        max_cid_from_conf_file)
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    max_cid_from_conf_file = rrm_uem_fill_rohc_max_cid((rrm_ue_max_num_rohc_context_session_et)max_cid_from_conf_file);

    *p_max_cid_to_rrc = rrm_uem_fill_rohc_max_cid(ue_capa_max_cid);

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "Config Fi;e [%d], UE Capab [%d] ", max_cid_from_conf_file, *p_max_cid_to_rrc);

    if (*p_max_cid_to_rrc > max_cid_from_conf_file)
    {
        *p_max_cid_to_rrc = max_cid_from_conf_file;
    }

    if (*p_max_cid_to_rrc > RRM_FIFTEEN)
    {
        *p_max_cid_to_rrc = RRM_FIFTEEN;
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Allocated Max Cid [%d] ", *p_max_cid_to_rrc);

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_rohc_config
 *   INPUT        : p_rrm_ue_pdcp_parameters,p_erb_profile_rohc_config
 *   OUTPUT       : p_rrc_pdcp_rohc_config
 *   DESCRIPTION  :
 *                  Fills the rrc_pdcp_rohc_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
fill_erb_setup_modify_resp_rohc_config(
           rrc_pdcp_rohc_config_t                      *p_rrc_pdcp_rohc_config,
           rrm_ue_pdcp_parameters_t                    *p_rrm_ue_pdcp_parameters,
           rrc_pdcp_rohc_config_erb_service_profile_t  *p_erb_profile_rohc_config)
{
  rrm_return_et   ret_val = RRM_SUCCESS;

  RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_rrc_pdcp_rohc_config != RRM_PNULL);
    RRM_ASSERT(p_rrm_ue_pdcp_parameters != RRM_PNULL);
    RRM_ASSERT(p_erb_profile_rohc_config != RRM_PNULL);

  fill_erb_setup_modify_resp_rohc_profile(
            &(p_rrc_pdcp_rohc_config->rohc_profile),
            &(p_rrm_ue_pdcp_parameters->rohc_profile),
            &(p_erb_profile_rohc_config->rohc_profile));

  RRM_UT_TRACE_EXIT();
  return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_header_compression
 *   INPUT        : p_ue_capability_params,p_erb_profile_rohc_config
 *   OUTPUT       : p_rrc_pdcp_header_compression_config
 *   DESCRIPTION  :
 *                  Fills the rrc_pdcp_header_compression_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_header_compression(
        rrc_pdcp_header_compression_config_t 
        *p_rrc_pdcp_header_compression_config,
        rrm_ue_capability_params_t
        *p_ue_capability_params,
        rrc_pdcp_rohc_config_erb_service_profile_t
        *p_erb_profile_rohc_config
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    rrm_ue_pdcp_rohc_profile_t          *p_rohc_profile = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* klocwork_27Mar: Start */
    if(RRM_PNULL == p_ue_capability_params )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                " UA CAPABILITY PARAMS NULL");
        return RRM_FAILURE;
    }
    /* klocwork_27Mar: End */
    /*SPR 19961 Start*/ 
    if (p_ue_capability_params->bitmask & 
            RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT )
    /*SPR 19961 End*/ 
    {
        /* FIX for ROHC profile starts. This check is done in order to see
         * if any of the profile from profile0x0001 to profile0x0104 is supported
         * from UE or not. In case above mentioned no profile is set in UE capability
         * then RRM shall configure ROHC as not used
         */  
      p_rohc_profile = &p_ue_capability_params->rrm_eutra_radio_capability_info.
        eutra_radio_capability_info_def.pdcp_parameters.rohc_profile;
      RRM_ASSERT(RRM_PNULL != p_rohc_profile);

      if (((p_rohc_profile->profile0x0001) && (p_erb_profile_rohc_config->rohc_profile.profile0x0001)) ||
          ((p_rohc_profile->profile0x0002) && (p_erb_profile_rohc_config->rohc_profile.profile0x0002)) ||
          ((p_rohc_profile->profile0x0003) && (p_erb_profile_rohc_config->rohc_profile.profile0x0003)) ||
          ((p_rohc_profile->profile0x0004) && (p_erb_profile_rohc_config->rohc_profile.profile0x0004)) ||
          ((p_rohc_profile->profile0x0006) && (p_erb_profile_rohc_config->rohc_profile.profile0x0006)) ||
          ((p_rohc_profile->profile0x0101) && (p_erb_profile_rohc_config->rohc_profile.profile0x0101)) ||
          ((p_rohc_profile->profile0x0102) && (p_erb_profile_rohc_config->rohc_profile.profile0x0102)) ||
          ((p_rohc_profile->profile0x0103) && (p_erb_profile_rohc_config->rohc_profile.profile0x0103)) ||
          ((p_rohc_profile->profile0x0104) && (p_erb_profile_rohc_config->rohc_profile.profile0x0104)))           
        {
            p_rrc_pdcp_header_compression_config->bitmask |= 
                      RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_PRESENT;
            fill_erb_setup_modify_resp_rohc_config
                        (&(p_rrc_pdcp_header_compression_config->rohc_config),
                         &(p_ue_capability_params->
                                 rrm_eutra_radio_capability_info.
                                 eutra_radio_capability_info_def.
                                 pdcp_parameters),p_erb_profile_rohc_config);
        }
        else
        {
           p_rrc_pdcp_header_compression_config->bitmask = RRM_ZERO;
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                     "ROHC Not Configured as no profile is supported from UE");
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_pdcp_config
 *   INPUT        : p_erb_profile_pdcp_config,p_qos_config_params,p_rrm_ue_context
                    pdcp_sn_size_enum,data_transfer_mode,erab_id
 *   OUTPUT       : p_rrc_pdcp_config
 *   DESCRIPTION  :
 *                  Fills the rrc_pdcp_config_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_pdcp_config(
        rrc_pdcp_config_t                     *p_rrc_pdcp_config,
        rrc_pdcp_config_erb_service_profile_t *p_erb_profile_pdcp_config,
        qos_config_params_t                   *p_qos_config_params,
        rrm_ue_context_t                      *p_rrm_ue_context,
         /*SPR 17777 +-*/
        U8                                     data_transfer_mode,
        /* MAX_CID Changes Start*/
        U8                                     erab_id
        /* MAX_CID Changes End*/
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if (p_erb_profile_pdcp_config->bitmask & 
            RRC_PDCP_CONFIG_DISCARD_TIMER_ERB_SERVICE_PROFILE_PRESENT)
    {
        p_rrc_pdcp_config->bitmask |= RRC_PDCP_CONFIG_DISCARD_TIMER_PRESENT;
        p_rrc_pdcp_config->discard_timer = 
            p_erb_profile_pdcp_config->discard_timer;
    }

    if(data_transfer_mode == AM_MODE)
    {
           p_rrc_pdcp_config->bitmask |= 
               RRC_PDCP_CONFIG_RLC_AM_STATUS_REPORT_REQ_PRESENT;
           p_rrc_pdcp_config->rlc_am_status_report_required = 
               p_erb_profile_pdcp_config->rlc_am_status_report_required;

           p_rrc_pdcp_config->bitmask |=
                RRC_PDCP_CONFIG_RLC_AM_ENB_STATUS_REPORT_REQ_PRESENT;
           p_rrc_pdcp_config->rlc_am_enb_status_report_required =
              p_erb_profile_pdcp_config->rlc_am_enb_status_report_required ;

       
    }
    else /**UM MODE*/
    {
           p_rrc_pdcp_config->bitmask |= 
               RRC_PDCP_CONFIG_RLC_UM_PDCP_SN_SIZE_PRESENT;
	/*Changes for RRM SN configuration selection -START */
           p_rrc_pdcp_config->rlc_um_pdcp_sn_size = p_erb_profile_pdcp_config->rlc_um_pdcp_sn_size;
	/* Changes for RRM SN configuration selection -END */
    }


    /* MAX_CID Changes Starts */
    /* Klocwork_fix_march_14_start */
    /* SPR 18912 Fix Start */
    //rrm_check_and_fill_min_value_of_cid (p_rrm_ue_context, p_qos_config_params);
    /* SPR 18912 Fix End */
    /* Klocwork_fix_march_14_end */
    /* MAX_CID Changes End */
    if(p_qos_config_params->erb_service_profile.enable_rohc == RRM_TRUE)
    {
       fill_erb_setup_modify_resp_header_compression
           (&(p_rrc_pdcp_config->header_compression),
            &(p_rrm_ue_context->ue_capability_params),
            &(p_qos_config_params->erb_service_profile.
            pdcp_config.header_compression.rohc_config));
       /* MAX_CID Changes Starts */
       /* Check if RoHC is enabled or not */
       if (p_rrc_pdcp_config->header_compression.bitmask & 
		       RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_PRESENT)
       {
	       /* SPR 18912 Fix Start */

	       /* Assign new value of max_cid */
	       if (RRM_ZERO == p_rrm_ue_context->map_data_drb_rohc.total_drb_count)
	       {
		       /* This block shall check for the minimum value of max_cid configured from
			  rrm configuration file and the rohc sessions reported from UE.
			  The minimum of both is taken and the value is again distributed per DRB
			  basis.*/

		       p_rrm_ue_context->map_data_drb_rohc.cid_from_config = p_qos_config_params->erb_service_profile.\
									     pdcp_config.header_compression.\
									     rohc_config.max_cid;

		       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated =
			       p_rrm_ue_context->map_data_drb_rohc.\
			       max_cid_allocation_per_drb *
			       p_rrm_ue_context->map_data_drb_rohc.\
			       max_count_drbs_rohc_enabled;  

		       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				       "MAX_CID [%d] is conigured by operator and UE configured MAX_CID is [%d]",
				       p_rrm_ue_context->map_data_drb_rohc.cid_from_config, p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated);

		       if(p_rrm_ue_context->map_data_drb_rohc.cid_from_config < p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated)
		       {
			       p_rrc_pdcp_config->header_compression.\
				       rohc_config.max_cid = p_rrm_ue_context->map_data_drb_rohc.cid_from_config;

			       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated =
				       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated - p_rrm_ue_context->map_data_drb_rohc.cid_from_config;

			       p_rrm_ue_context->map_data_drb_rohc.from_ue = RRM_FALSE;
		       }
		       else
		       {
			       p_rrm_ue_context->map_data_drb_rohc.cid_from_config -=
				       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated;

			       p_rrc_pdcp_config->header_compression.\
				       rohc_config.max_cid = p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated;

			       p_rrm_ue_context->map_data_drb_rohc.from_ue = RRM_TRUE;
		       }
	       }
	       else
	       {
		       if (RRM_TRUE !=  p_rrm_ue_context->map_data_drb_rohc.from_ue)
		       {
			       if(p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated != RRM_ZERO)
			       {
				       p_rrc_pdcp_config->header_compression.\
					       rohc_config.max_cid = p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated;

				       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated -=
					       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated;

			       }
			       else
			       {
				       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						       "MAX_CID [%d] is configured disabling header compression for rab_id [%d]",
						       p_rrm_ue_context->map_data_drb_rohc.cid_from_config,erab_id);
				       p_rrc_pdcp_config->header_compression.bitmask = RRM_ZERO;
			       }
		       }
		       else
		       {
			       if(p_rrm_ue_context->map_data_drb_rohc.cid_from_config != RRM_ZERO)
			       {
				       if ( p_rrm_ue_context->map_data_drb_rohc.cid_from_config >
						       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated )
				       {
					       p_rrm_ue_context->map_data_drb_rohc.cid_from_config -=
						       p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated;

					       p_rrc_pdcp_config->header_compression.\
						       rohc_config.max_cid = p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated;
				       }
				       else
				       {	
					       p_rrc_pdcp_config->header_compression.\
						       rohc_config.max_cid = p_rrm_ue_context->map_data_drb_rohc.cid_from_config;				       		
					       p_rrm_ue_context->map_data_drb_rohc.cid_from_config = RRM_ZERO;
				       }
			       }
			       else
			       {
				       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						       "MAX_CID [%d] is configured disabling header compression for rab_id [%d]",
						       p_rrm_ue_context->map_data_drb_rohc.cid_from_config,erab_id);
				       p_rrc_pdcp_config->header_compression.bitmask = RRM_ZERO;
			       }

		       }
	       }
	       /* Increment the count of DRBs allocated the max_cid*/
	       if(((p_rrm_ue_context->map_data_drb_rohc.cid_from_config != RRM_ZERO) ||
				       (p_rrm_ue_context->map_data_drb_rohc.max_cid_allocated!= RRM_ZERO)) &&
			       (p_rrc_pdcp_config->header_compression.bitmask & RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_PRESENT))
	       {
		       p_rrm_ue_context->map_data_drb_rohc.count_drbs_cid_allocated++;

		       /* Enable the rohc profile is configured for the particular DRB so
			* that at the timeof release properly data structure can be cleared
			*/
		       p_rrm_ue_context->map_data_drb_rohc.total_drb_count++;

		       p_rrm_ue_context->map_data_drb_rohc.map_data_rohc[
			       p_rrm_ue_context->map_data_drb_rohc.total_drb_count - RRM_ONE].rab_id = erab_id;

		       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				       "RAB_ID [%d] and total ROHC enabled rabs[%d] and MAX_CID is [%d]",
				       p_rrm_ue_context->map_data_drb_rohc.map_data_rohc[
				       p_rrm_ue_context->map_data_drb_rohc.total_drb_count - RRM_ONE].rab_id,
				       p_rrm_ue_context->map_data_drb_rohc.total_drb_count,
				       p_rrc_pdcp_config->header_compression.rohc_config.max_cid);

		       p_rrm_ue_context->map_data_drb_rohc.map_data_rohc[
			       p_rrm_ue_context->map_data_drb_rohc.total_drb_count - RRM_ONE].is_rohc_enable = RRM_TRUE;
	       }
	       else
	       {
		       p_rrc_pdcp_config->header_compression.bitmask = RRM_ZERO;
	       }
	       /* SPR 18912 Fix End */

       }
       /* MAX_CID Changes End */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_ul_am_rlc
 *   INPUT        : p_erb_profile_uplink_am_rlc
 *   output       : p_rrc_uplink_am_rlc
 *   DESCRIPTION  :
 *                  Fills the rrc_uplink_am_rlc_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_ul_am_rlc(
        rrc_uplink_am_rlc_t *p_rrc_uplink_am_rlc,
        rrc_uplink_am_rlc_erb_service_profile_t *p_erb_profile_uplink_am_rlc
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_uplink_am_rlc->t_poll_retransmit = 
        p_erb_profile_uplink_am_rlc->t_poll_retransmit;
    p_rrc_uplink_am_rlc->poll_pdu = p_erb_profile_uplink_am_rlc->poll_pdu;
    p_rrc_uplink_am_rlc->poll_byte = p_erb_profile_uplink_am_rlc->poll_byte;
    p_rrc_uplink_am_rlc->max_retx_threshold = 
        p_erb_profile_uplink_am_rlc->max_retx_threshold;
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_dl_am_rlc
 *   INPUT        : p_erb_profile_downlink_am_rlc
 *   OUTPUT       : p_rrc_downlink_am_rlc
 *   DESCRIPTION  :
 *                  Fills the rrc_downlink_am_rlc_t
 *
 *   RETURNS      : 
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_dl_am_rlc(
        rrc_downlink_am_rlc_t *p_rrc_downlink_am_rlc,
        rrc_downlink_am_rlc_erb_service_profile_t *p_erb_profile_downlink_am_rlc
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_downlink_am_rlc->t_reordering = 
        p_erb_profile_downlink_am_rlc->t_reordering;
    p_rrc_downlink_am_rlc->t_status_prohibit = 
        p_erb_profile_downlink_am_rlc->t_status_prohibit;
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_am_config
 *   INPUT        : p_erb_profile_am_config
 *   OUTPUT       : p_rrc_am_config
 *   DESCRIPTION  :
 *                  Fills the rrc_am_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_am_config(
        rrc_am_config_t *p_rrc_am_config,
        rrc_am_config_erb_service_profile_t *p_erb_profile_am_config
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    fill_erb_setup_modify_resp_ul_am_rlc
        (&(p_rrc_am_config->ul_am_rlc),&(p_erb_profile_am_config->ul_am_rlc));
    fill_erb_setup_modify_resp_dl_am_rlc
        (&(p_rrc_am_config->dl_am_rlc),&(p_erb_profile_am_config->dl_am_rlc));
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_ul_um_rlc
 *   INPUT        : p_erb_profile_uplink_um_rlc,rlc_sn_size_enum
 *   OUTPUT       : p_rrc_uplink_um_rlc
 *   DESCRIPTION  :
 *                  Fills the rrc_uplink_um_rlc_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_ul_um_rlc(
        rrc_uplink_um_rlc_t *p_rrc_uplink_um_rlc,
        rrc_uplink_um_rlc_erb_service_profile_t *p_erb_profile_uplink_um_rlc
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /* Changes for RRM SN configuration selection -START */
    /* p_rrc_uplink_um_rlc->sn_field_length = rlc_sn_size_enum;*/
    p_rrc_uplink_um_rlc->sn_field_length = p_erb_profile_uplink_um_rlc->sn_field_length;
    /* Changes for RRM SN configuration selection -END */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_dl_um_rlc
 *   INPUT        : p_erb_profile_downlink_um_rlc,rlc_sn_size_enum
 *   OUTPUT       : p_rrc_downlink_um_rlc
 *   DESCRIPTION  :
 *                  Fills the rrc_downlink_um_rlc_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_dl_um_rlc(
        rrc_downlink_um_rlc_t 
        *p_rrc_downlink_um_rlc,
        rrc_downlink_um_rlc_erb_service_profile_t
        *p_erb_profile_downlink_um_rlc
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /* Changes for RRM SN configuration selection -START */
    /*p_rrc_downlink_um_rlc->sn_field_length = rlc_sn_size_enum; */
    p_rrc_downlink_um_rlc->sn_field_length = p_erb_profile_downlink_um_rlc->sn_field_length;
     /* Changes for RRM SN configuration selection -END */
    p_rrc_downlink_um_rlc->t_reordering = 
        p_erb_profile_downlink_um_rlc->t_reordering;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_um_bi_directional_config
 *   INPUT        : p_erb_profile_um_bi_directional_config,rlc_sn_size_enum
 *   OUTPUT       : p_rrc_um_bi_directional_config
 *   DESCRIPTION  :
 *                  Fills the rrc_um_bi_directional_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_um_bi_directional_config(
        rrc_um_bi_directional_config_t *p_rrc_um_bi_directional_config,
        rrc_um_bi_directional_config_erb_service_profile_t 
        *p_erb_profile_um_bi_directional_config
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS; 

    RRM_UT_TRACE_ENTER();
    fill_erb_setup_modify_resp_ul_um_rlc
        (&(p_rrc_um_bi_directional_config->ul_um_rlc),
         &(p_erb_profile_um_bi_directional_config->ul_um_rlc));
         /*SPR 17777 +-*/
    fill_erb_setup_modify_resp_dl_um_rlc
        (&(p_rrc_um_bi_directional_config->dl_um_rlc),
         &(p_erb_profile_um_bi_directional_config->dl_um_rlc));
         /*SPR 17777 +-*/
    RRM_UT_TRACE_EXIT(); 

    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_ue_rlc_config
 *   INPUT        : p_erb_profile_rlc_config,p_qos_config_params,data_transfer_mode
 *                  data_transfer_mode
 *   OUTPUT       : p_rrc_rlc_config
 *   DESCRIPTION  :
 *                  Fills the rrc_rlc_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_ue_rlc_config(
        rrc_rlc_config_t *p_rrc_rlc_config,
        rrc_rlc_config_erb_service_profile_t *p_erb_profile_rlc_config,
         /*SPR 17777 +-*/
        U8                          data_transfer_mode
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if(data_transfer_mode == AM_MODE)
    {
           p_rrc_rlc_config->bitmask |= 
               RRC_RLC_CONFIG_AM_CONFIG_PRESENT;
           fill_erb_setup_modify_resp_am_config
               (&(p_rrc_rlc_config->am_config),
               &(p_erb_profile_rlc_config->am_config));
     
    }
    else /**UM MODE*/
    {
           p_rrc_rlc_config->bitmask |= 
               RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_PRESENT;
           fill_erb_setup_modify_resp_um_bi_directional_config
               (&(p_rrc_rlc_config->um_bi_directional_config),
               &(p_erb_profile_rlc_config->um_bi_directional_config));
         /*SPR 17777 +-*/
       
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Klocwork_fix_march_14_start */
/*klock_works_changes_start*/
rrm_void_t
fill_packet_delay_budget_lower_range
(
 qos_config_params_t *p_qos_config_params,
 U16   *packet_delay_budget
 )
{
    RRM_UT_TRACE_ENTER();
    switch(p_qos_config_params->packet_delay_budget)
    {
        case RRM_OAM_PACKET_DELAY_BUDGET_MS50:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS50;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS100:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS100;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS150:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS150;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS200:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS200;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS300:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS300;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS400:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS400;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS500:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS500;
             break;
        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Not of any valid packet delay budget");
            break;
    }

    RRM_UT_TRACE_EXIT();

}

rrm_void_t
fill_packet_delay_budget_higher_range
(
 qos_config_params_t *p_qos_config_params,
 U16   *packet_delay_budget
 )
{
    RRM_UT_TRACE_ENTER();

    switch(p_qos_config_params->packet_delay_budget)
    {
        case RRM_OAM_PACKET_DELAY_BUDGET_MS600:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS600;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS700:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS700;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS800:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS800;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS900:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS900;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS1000:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS1000;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS1500:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS1500;
             break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS2000:
            *packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS2000;
             break;
        default:     
             RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "Not of any valid packet delay budget");
            break;
    }

    RRM_UT_TRACE_EXIT();
}

/*klock_works_changes_end*/




/******************************************************************************

 *   FUNCTION NAME: rrm_find_packet_delay_budget
 *   INPUT        : p_qos_config_params, packet_delay_budget
 *   OUTPUT       : packet_delay_budget
 *   DESCRIPTION  :
 *                  This function used to find packet_delay_budget 
 *
 *   RETURNS      :
 *                  none 
 ******************************************************************************/
rrm_void_t
rrm_find_packet_delay_budget
(
 qos_config_params_t *p_qos_config_params,
 U16   *packet_delay_budget
 )
{
    RRM_UT_TRACE_ENTER();
    /*klock_works_changes_start*/

    if(p_qos_config_params->packet_delay_budget<=RRM_OAM_PACKET_DELAY_BUDGET_MS500)
    {
        fill_packet_delay_budget_lower_range(p_qos_config_params, packet_delay_budget);
    }
    else
    {
        fill_packet_delay_budget_higher_range(p_qos_config_params, packet_delay_budget);
    }

    /*klock_works_changes_end*/

 
    RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_qci_length
 *   INPUT        : p_rrm_ue_erab_setup_item,p_qos_config_params,p_rrm_ue_context
 *   OUTPUT       : p_qci_length
 *   DESCRIPTION  :
 *                  filling for qci_length of erb setup resp 
 *
 *   RETURNS      :
 *                  none 
 ******************************************************************************/

void
fill_erb_setup_resp_qci_length(
                                 U32* p_qci_length,
                                 rrm_ue_erab_setup_item_t   
                                 *p_rrm_ue_erab_setup_item,
                                 qos_config_params_t        
                                 *p_qos_config_params,
                                 rrm_ue_context_t 
                                 *p_rrm_ue_context
                              )
{

    U8    bearer_type = RRM_NULL;
    U16   packet_delay_budget = RRM_NULL;
    float factor = RRM_ZERO;
    U64 minimum_bitrate =  rrm_cellm_get_minimum_bitrate(p_rrm_ue_context->cell_index);
     
    
    if((p_rrm_ue_erab_setup_item->erab_level_qos_params.qci >= RRM_ONE) && 
            (p_rrm_ue_erab_setup_item->erab_level_qos_params.qci <= RRM_FOUR))
    {
        bearer_type = RRM_GBR;
    }
    else if((p_rrm_ue_erab_setup_item->erab_level_qos_params.qci >=RRM_FIVE) &&
            (p_rrm_ue_erab_setup_item->erab_level_qos_params.qci <= RRM_NINE))
    {
        bearer_type = RRM_NON_GBR;
    }
    /* Klocwork_fix_march_14_start */
    rrm_find_packet_delay_budget (p_qos_config_params, &packet_delay_budget);
    /* Klocwork_fix_march_14_end */
   
    factor = p_qos_config_params->erb_service_profile.rlc_config.buffer_factor;
    if(bearer_type == RRM_GBR)
    {
        /*Calculate  qci_length = mbr_dl * pdb * factor(gbr) */
        *p_qci_length = ((p_rrm_ue_erab_setup_item->erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl)*
                       packet_delay_budget*factor)/(RRM_ONE_THOUSAND_MS*RRM_EIGHT);
    }
    else if(bearer_type == RRM_NON_GBR)
    {
        /* SPR_13815_fix: start */
        /* Lines deleted */
        /* SPR_13815_fix: end */
            /*Calculate  qci_length = ambr_dl * pdb * factor(ngbr) */
            *p_qci_length = ((p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl)*
                            packet_delay_budget*factor*RRM_TWO)/(RRM_ONE_THOUSAND_MS*RRM_EIGHT);
        /* SPR_13815_fix: start */
        /* Lines deleted */
        /* SPR_13815_fix: end */                
    }
    /*Retrieving min bitrate configured from rrm_oam.cfg to avoid sending qci_length as 0*/
    if(*p_qci_length < minimum_bitrate || p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl == RRM_ZERO)
    {
        *p_qci_length = minimum_bitrate;
    }
                               
    /* SPR 10795 Fix Start */
    if( *p_qci_length > RRM_MAX_SUPPORTED_RLC_QUEUE_SIZE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Calculated QCI LENGTH [%u] is > [%u], so caping the value",*p_qci_length, RRM_MAX_SUPPORTED_RLC_QUEUE_SIZE);
        *p_qci_length = RRM_MAX_SUPPORTED_RLC_QUEUE_SIZE;
    }
    /* SPR 10795 Fix End */
                               
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
              "[UE:%d], Erab Id[%d],QCI LENGTH=%d",\
              p_rrm_ue_context->ue_index,p_rrm_ue_erab_setup_item->erab_id,
              *p_qci_length);

}
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_rlc_config
 *   INPUT        : data_transfer_mode,rlc_sn_size_enum,p_rrm_ue_context
 *                  p_qos_config_params,p_rrm_ue_erab_setup_item
 *                  p_erb_profile_rlc_config
 *   OUTPUT       : p_rrc_rlc_config_enb
 *   DESCRIPTION  :
 *                  Fills the rrc_rlc_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_rlc_config(
        rrc_rlc_config_enb_t *p_rrc_rlc_config_enb,
        rrc_rlc_config_erb_service_profile_t *p_erb_profile_rlc_config,
        rrm_ue_erab_setup_item_t   *p_rrm_ue_erab_setup_item,
        qos_config_params_t        *p_qos_config_params,
        rrm_ue_context_t           *p_rrm_ue_context,
         /*SPR 17777 +-*/
        U8                          data_transfer_mode
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if(data_transfer_mode == AM_MODE)
    {   
           p_rrc_rlc_config_enb->rlc_config.bitmask |= 
               RRC_RLC_CONFIG_AM_CONFIG_PRESENT;
           fill_erb_setup_modify_resp_am_config
               (&(p_rrc_rlc_config_enb->rlc_config.am_config),
               &(p_erb_profile_rlc_config->am_config));
       
    }
    else /**UM MODE*/
    {
           p_rrc_rlc_config_enb->rlc_config.bitmask |= 
               RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_PRESENT;
           fill_erb_setup_modify_resp_um_bi_directional_config
               (&(p_rrc_rlc_config_enb->rlc_config.um_bi_directional_config),
               &(p_erb_profile_rlc_config->um_bi_directional_config));
         /*SPR 17777 +-*/
       
    }

    
    p_rrc_rlc_config_enb->bitmask = RRC_RLC_CONFIG_QCI_LENGTH_PRESENT; 
    /*Calculate QCI length from a formula*/   
    fill_erb_setup_resp_qci_length(&(p_rrc_rlc_config_enb->qci_length),
                                    p_rrm_ue_erab_setup_item,
                                    p_qos_config_params,p_rrm_ue_context);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_ul_specific_parameters
 *   INPUT        : p_erb_profile_ul_specific_parameters
 *   OUTPUT       : p_rrc_ul_specific_parameters
 *   DESCRIPTION  :
 *                  Fills the rrc_ul_specific_parameters_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_ul_specific_parameters(
        rrc_ul_specific_parameters_t *p_rrc_ul_specific_parameters,
        rrc_ul_specific_parameters_erb_service_profile_t *p_erb_profile_ul_specific_parameters  
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_ul_specific_parameters->priority = 
        p_erb_profile_ul_specific_parameters->priority;
    p_rrc_ul_specific_parameters->prioritized_bit_rate = 
        p_erb_profile_ul_specific_parameters->prioritized_bit_rate;
    p_rrc_ul_specific_parameters->bucket_size_duration = 
        p_erb_profile_ul_specific_parameters->bucket_size_duration;
    if (p_erb_profile_ul_specific_parameters->bitmask & 
        RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_ERB_SERVICE_PROFILE_PRESENT)
    {
        p_rrc_ul_specific_parameters->bitmask |= 
            RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_PRESENT;
        p_rrc_ul_specific_parameters->logical_channel_group = 
            p_erb_profile_ul_specific_parameters->logical_channel_group;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_mac_lc_config_enb
 *   INPUT        : p_erb_profile_ul_specific_parameters,priority
 *   OUTPUT       : p_rrm_mac_lc_config
 *   DESCRIPTION  :
 *                  Fills the rrm_mac_lc_config_t
 *
 *   RETURNS       :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_mac_lc_config_enb(
        rrm_mac_lc_config_t *p_rrm_mac_lc_config,
        rrc_ul_specific_parameters_erb_service_profile_t 
        *p_erb_profile_ul_specific_parameters,
        U8 priority
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if (p_erb_profile_ul_specific_parameters->bitmask & 
        RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_ERB_SERVICE_PROFILE_PRESENT)
    {
        p_rrm_mac_lc_config->bitmask |= RRM_MAC_LC_CONFIG_UL_LC_G_ID_PRESENT;
        p_rrm_mac_lc_config->ul_lc_g_id = 
            p_erb_profile_ul_specific_parameters->logical_channel_group;
    }

    p_rrm_mac_lc_config->bitmask |= RRM_MAC_LC_CONFIG_DL_PRIORITY_PRESENT;
    p_rrm_mac_lc_config->dl_lch_priority = priority;
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_s1u_config
 *   INPUT        : p_rrm_erab_level_qos_params,p_qos_config_params
 *   OUTPUT       : p_rrm_s1u_config
 *   DESCRIPTION  :
 *                  Fills the rrm_s1u_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_s1u_config(
        rrm_s1u_config_t *p_rrm_s1u_config,
        rrm_ue_erab_level_qos_params_t *p_rrm_erab_level_qos_params,
        qos_config_params_t        *p_qos_config_params
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    U8                                  valid_qos_profile_data_size = RRM_ZERO;
    U8                                  count_qos_profile_data_size = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_rrm_s1u_config->qos_profile.allocation_retention_priority = 
           p_rrm_erab_level_qos_params->alloc_and_reten_prior.priority_level;
    p_rrm_s1u_config->qos_profile.qos_profile_data_size = 
           RRM_DEFINED_DEFAULT_VALUE_FOR_QOS_PROFILE_DATA_SIZE;

    count_qos_profile_data_size = p_rrm_s1u_config->qos_profile.qos_profile_data_size;

    for(valid_qos_profile_data_size = RRM_ZERO; 
               valid_qos_profile_data_size < count_qos_profile_data_size;
               valid_qos_profile_data_size++)
    {
        p_rrm_s1u_config->qos_profile.qos_profile_data[valid_qos_profile_data_size] =
            RRM_DEFINED_DEFAULT_VALUE_FOR_QOS_PROFILE_DATA;
    }
    
    p_rrm_s1u_config->qos_id = p_qos_config_params->dscp;
    p_rrm_s1u_config->sap_flags = SAP_FLAGS;
    p_rrm_s1u_config->seq_flag = p_qos_config_params->erb_service_profile.
                rrm_s1u_config_erb_service_profile.seq_flag;
    p_rrm_s1u_config->reordering_reqd = p_qos_config_params->erb_service_profile.
                    rrm_s1u_config_erb_service_profile.reordering_reqd;
    /**No other value is required*/
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_decide_pdcp_rlc_sn_size
 *   INPUT        : p_pdcp_sn_size_enum,p_rlc_sn_size_enum,p_rrm_ue_context
 *                  p_ue_gbr_qos_info,bearer_type
 *   OUTPUT       : none
 *   DESCRIPTION  : 
 *                   Decides rlc and pdcp sn size
 *
 *   RETURNS      :
 *                   none 
 ******************************************************************************/
void
rrm_decide_pdcp_rlc_sn_size(
        rrc_pdcp_sn_size_et    *p_pdcp_sn_size_enum,
        rrc_sn_field_length_et *p_rlc_sn_size_enum,
        rrm_ue_context_t       *p_rrm_ue_context,
        rrm_ue_gbr_qos_info_t  *p_ue_gbr_qos_info,
        rrc_bearer_type_et      bearer_type
        )
{

    RRM_UT_TRACE_ENTER();


    /* FGI Feature Start */
    /* FGI Feature End */

    /*If both bit3 and bit7 is set to 1*/
    /*Start:Bug 762*/
    if((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_THREE))
        &&(rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_SEVEN)))
    /*End:Bug 762*/
    {
        if(bearer_type == BEARER_TYPE_GBR) 
        {
           if(p_ue_gbr_qos_info->
                   erab_guar_bit_rate_ul < RRM_THIRTY_TWO*1000 )
           { 
               *p_rlc_sn_size_enum =  RRC_SN_FIELD_LEN_5;
           }
           else
           {
               *p_rlc_sn_size_enum =  RRC_SN_FIELD_LEN_10;
           }
        }
        else /*BEARER_TYPE_NON_GBR*/
        {
            /* FGI Feature Start */ 
            if(p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl <
                 RRM_THIRTY_TWO * 1000 )
            /* FGI Feature End */
            {
                *p_rlc_sn_size_enum =  RRC_SN_FIELD_LEN_5;
            }
            else
            {
                *p_rlc_sn_size_enum =  RRC_SN_FIELD_LEN_10;
            }
        }
        *p_pdcp_sn_size_enum = RRC_PDCP_SN_SIZE_7_BITS;
    }
    else
    {
       *p_rlc_sn_size_enum =  RRC_SN_FIELD_LEN_10;
       *p_pdcp_sn_size_enum = RRC_PDCP_SN_SIZE_12_BITS;
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_modify_resp_drb_config
 *   INPUT        : p_qos_config_params,p_rrm_ue_erab_setup_item,p_rrm_ue_context
                    data_transfer_mode
 *   OUTPUT       : p_rrm_drb_config
 *   DESCRIPTION  :
 *                  Fills the rrm_drb_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_modify_resp_drb_config(
        rrm_drb_config_t           *p_rrm_drb_config,
        qos_config_params_t        *p_qos_config_params,
        rrm_ue_erab_setup_item_t   *p_rrm_ue_erab_setup_item,
        rrm_ue_context_t           *p_rrm_ue_context,
        U8                          data_transfer_mode
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    rrc_bearer_type_et                  rrc_bearer_type_enum;
    rrc_pdcp_sn_size_et                 pdcp_sn_size_enum;
    rrc_sn_field_length_et              rlc_sn_size_enum;

    RRM_UT_TRACE_ENTER();
    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_BEARED_ID_PRESENT;
    p_rrm_drb_config->erab_id = p_rrm_ue_erab_setup_item->erab_id;
    p_rrm_drb_config->drb_id = p_rrm_ue_erab_setup_item->drb_id;
    p_rrm_drb_config->bitmask |= 
        RRM_DRB_CONFIG_LOGICAL_CHANNEL_IDENTITY_PRESENT;
    p_rrm_drb_config->logical_channel_identity =
        p_rrm_ue_erab_setup_item->lc_id;

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_BEARER_TYPE_PRESENT;
    /*Fill Bearer type - GBR/Non-GBR on the basis of qci*/
    if((p_rrm_ue_erab_setup_item->erab_level_qos_params.qci >= RRM_ONE) &&
           ( p_rrm_ue_erab_setup_item->erab_level_qos_params.qci <= RRM_FOUR))
    {
        rrc_bearer_type_enum = BEARER_TYPE_GBR;
        p_rrm_drb_config->bearer_type = rrc_bearer_type_enum;
    }
    else if((p_rrm_ue_erab_setup_item->erab_level_qos_params.qci >= RRM_FIVE) &&
            (p_rrm_ue_erab_setup_item->erab_level_qos_params.qci <= RRM_NINE))
    {
        rrc_bearer_type_enum = BEARER_TYPE_NON_GBR;
        p_rrm_drb_config->bearer_type = rrc_bearer_type_enum;
    }

    if(p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask & 
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {
        rrm_decide_pdcp_rlc_sn_size(&pdcp_sn_size_enum,&rlc_sn_size_enum,
                p_rrm_ue_context,
                &(p_rrm_ue_erab_setup_item->
                    erab_level_qos_params.gbr_qos_info),
       /* coverity : 16543 ,rel 2.0.1 */
               (rrc_bearer_type_et)( p_rrm_drb_config->bearer_type));
    }
    else
    {
       /* coverity : 16546 ,rel 2.0.1 */
        pdcp_sn_size_enum =(rrc_pdcp_sn_size_et)( p_qos_config_params->erb_service_profile.
            pdcp_config.rlc_um_pdcp_sn_size);
       /* coverity : 16548 ,rel 2.0.1 */
        rlc_sn_size_enum =(rrc_sn_field_length_et)( p_qos_config_params->erb_service_profile.
            rlc_config.um_bi_directional_config.ul_um_rlc.sn_field_length);
    }

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_PDCP_CONFIG_PRESENT;
    fill_erb_setup_modify_resp_pdcp_config
        (&(p_rrm_drb_config->pdcp_config),
         &(p_qos_config_params->erb_service_profile.pdcp_config),
         p_qos_config_params,
         /*SPR 17777 +-*/
         p_rrm_ue_context,
         /*SPR 17777 +-*/
         data_transfer_mode,
         /* MAX_CID Changes Start*/
         p_rrm_ue_erab_setup_item->erab_id
         /* MAX_CID Changes End*/
         );

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_RLC_CONFIG_PRESENT;
    p_rrm_drb_config->rlc_config_enb.bitmask |= RRC_RLC_CONFIG_QCI_LENGTH_PRESENT;
    fill_erb_setup_resp_qci_length(&(p_rrm_drb_config->rlc_config_enb.qci_length),
            p_rrm_ue_erab_setup_item,
            p_qos_config_params,p_rrm_ue_context);

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT;
    
    /* SPS - sr_mask_flag CR start */
    U8                    qci_val = RRM_ZERO;
    qci_val = p_rrm_ue_erab_setup_item->erab_level_qos_params.qci;

    rrm_set_r9_mask_for_sps(&(p_rrm_drb_config->logical_channel_config),
                p_rrm_ue_context, qci_val);
    /* SPS - sr_mask_flag CR end */

    p_rrm_drb_config->logical_channel_config.bitmask |=
        RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT;
    fill_erb_setup_modify_resp_ul_specific_parameters
        (&(p_rrm_drb_config->logical_channel_config.
           ul_specific_parameters_explicit),
         &(p_qos_config_params->erb_service_profile.ul_specific_parameters));

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_S1U_CONFIG_PRESENT;
    fill_erb_setup_modify_resp_s1u_config
        (&(p_rrm_drb_config->s1u_config),
         &(p_rrm_ue_erab_setup_item->erab_level_qos_params),
         p_qos_config_params
        );
        
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_drb_config
 *   INPUT        : p_qos_config_params,p_rrm_ue_erab_setup_item,p_rrm_ue_context
 *                  data_transfer_mode
 *   OUTPUT       : p_rrm_drb_config
 *   DESCRIPTION  :
 *                  Fills the rrm_drb_config_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_modify_resp_drb_config( 
        rrm_drb_config_t           *p_rrm_drb_config,
        qos_config_params_t        *p_qos_config_params,
        rrm_ue_erab_setup_item_t   *p_rrm_ue_erab_setup_item,
        rrm_ue_context_t           *p_rrm_ue_context,
        U8                          data_transfer_mode
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    rrc_bearer_type_et                  rrc_bearer_type_enum;
    rrc_pdcp_sn_size_et                 pdcp_sn_size_enum;
    rrc_sn_field_length_et              rlc_sn_size_enum;

    RRM_UT_TRACE_ENTER();
    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_BEARED_ID_PRESENT;
    p_rrm_drb_config->erab_id = p_rrm_ue_erab_setup_item->erab_id;
    p_rrm_drb_config->drb_id = p_rrm_ue_erab_setup_item->drb_id;

    #ifdef ENDC_ENABLED
    /*OPTION3X CHANGES START*/
    if(RRC_ZERO != p_rrm_ue_erab_setup_item->lc_id &&
            DRB_TYPE_SN_TERMINATED_SCG != p_rrm_ue_erab_setup_item->drb_type
      )
    {
        p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_LOGICAL_CHANNEL_IDENTITY_PRESENT;
        p_rrm_drb_config->logical_channel_identity = 
            p_rrm_ue_erab_setup_item->lc_id;
    }
    /*OPTION3X CHANGES STOP*/
    #endif

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_BEARER_TYPE_PRESENT;
    /*Fill Bearer type - GBR/Non-GBR on the basis of qci*/
    if((p_rrm_ue_erab_setup_item->erab_level_qos_params.qci >= RRM_ONE) &&
            (p_rrm_ue_erab_setup_item->erab_level_qos_params.qci <= RRM_FOUR))
    {
        rrc_bearer_type_enum = BEARER_TYPE_GBR;
        p_rrm_drb_config->bearer_type = rrc_bearer_type_enum;
    }
    else if((p_rrm_ue_erab_setup_item->erab_level_qos_params.qci >= RRM_FIVE) &&
            (p_rrm_ue_erab_setup_item->erab_level_qos_params.qci <= RRM_NINE))
    {
        rrc_bearer_type_enum = BEARER_TYPE_NON_GBR;
        p_rrm_drb_config->bearer_type = rrc_bearer_type_enum;
    }

    /* if bearer is SN terminated bearer. PDCP param is not required */
#ifdef ENDC_ENABLED
    if (DRB_TYPE_SN_TERMINATED_SCG != p_rrm_ue_erab_setup_item->drb_type)
#endif
    {
        if(p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.bitmask & RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
        {
            rrm_decide_pdcp_rlc_sn_size(&pdcp_sn_size_enum,&rlc_sn_size_enum,
                    p_rrm_ue_context,
                    &(p_rrm_ue_erab_setup_item->
                        erab_level_qos_params.gbr_qos_info),
                    /* coverity : 16541 ,rel 2.0.1 */
                    (rrc_bearer_type_et)( p_rrm_drb_config->bearer_type));
        }
        else
        {
            /* coverity : 16547 ,rel 2.0.1 */
            pdcp_sn_size_enum = (rrc_pdcp_sn_size_et)(p_qos_config_params->erb_service_profile.pdcp_config.rlc_um_pdcp_sn_size);
            /* coverity id :16549 ,rel 2.0.1 */
            rlc_sn_size_enum =(rrc_sn_field_length_et)( p_qos_config_params->erb_service_profile.rlc_config.um_bi_directional_config.ul_um_rlc.sn_field_length);
        }

        p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_PDCP_CONFIG_PRESENT;
        fill_erb_setup_modify_resp_pdcp_config
            (&(p_rrm_drb_config->pdcp_config),
             &(p_qos_config_params->erb_service_profile.pdcp_config),
             p_qos_config_params,
             /*SPR 17777 +-*/
             p_rrm_ue_context,
             /*SPR 17777 +-*/
             data_transfer_mode,
             /* MAX_CID Changes Start*/
             p_rrm_ue_erab_setup_item->erab_id
             /* MAX_CID Changes End*/
            );
    }
    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_RLC_CONFIG_PRESENT;
    fill_erb_setup_modify_resp_rlc_config
        (&(p_rrm_drb_config->rlc_config_enb),
         &(p_qos_config_params->erb_service_profile.rlc_config),
         p_rrm_ue_erab_setup_item,p_qos_config_params,
         /*SPR 17777 +-*/
         p_rrm_ue_context,
         /*SPR 17777 +-*/
         data_transfer_mode);


    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT; 

    /* SPS - sr_mask_flag CR start */
    U8                    qci_val = RRM_ZERO;
    qci_val = p_rrm_ue_erab_setup_item->erab_level_qos_params.qci;

    rrm_set_r9_mask_for_sps(&(p_rrm_drb_config->logical_channel_config),
            p_rrm_ue_context, qci_val);
    /* SPS - sr_mask_flag CR end */

    p_rrm_drb_config->logical_channel_config.bitmask |= 
        RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT;
    fill_erb_setup_modify_resp_ul_specific_parameters
        (&(p_rrm_drb_config->logical_channel_config.
           ul_specific_parameters_explicit),
         &(p_qos_config_params->erb_service_profile.ul_specific_parameters));

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_S1U_CONFIG_PRESENT;
    fill_erb_setup_modify_resp_s1u_config
        (&(p_rrm_drb_config->s1u_config),
         &(p_rrm_ue_erab_setup_item->erab_level_qos_params),
         p_qos_config_params
        );

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_RLC_CONFIG_UE_PRESENT;
    fill_erb_setup_modify_resp_ue_rlc_config
        (&(p_rrm_drb_config->rlc_config_ue),
         &(p_qos_config_params->erb_service_profile.rlc_config),
         /*SPR 17777 +-*/
         data_transfer_mode);

    p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_MAC_LC_CONFIG_ENB_PRESENT;
    fill_erb_setup_modify_resp_mac_lc_config_enb
        (&(p_rrm_drb_config->mac_lc_config_enb),
         &(p_qos_config_params->erb_service_profile.ul_specific_parameters),
         p_qos_config_params->priority);

#ifdef ENDC_ENABLED
    if (RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG & p_rrm_ue_erab_setup_item->bitmask)
    {
        switch (p_rrm_ue_erab_setup_item->drb_type)
        {
            /*NR_DC Code Change Start*/
            case DRB_TYPE_SN_TERMINATED_SCG:

            p_rrm_drb_config->dc_bearer_type = SN_TERMINATED_SCG_BEARER;

            p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT;

            break;
            /*NR_DC Code Change Stop*/
            default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "DRB type is [%d]",p_rrm_ue_erab_setup_item->drb_type);

        }
    }
#endif

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_modify_resp_drb_to_add_list
 *   INPUT        : p_rrm_ue_context,p_epc_params
 *   OUTPUT       : p_rrm_drb_to_add_info_list
 *   DESCRIPTION  :
 *                  Fills the rrm_drb_to_add_info_list_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
fill_erb_modify_resp_drb_to_add_list(
        rrm_drb_to_add_info_list_t *p_rrm_drb_to_add_info_list,
        rrm_ue_context_t           *p_rrm_ue_context,
        epc_params_t               *p_epc_params
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    U16                                 drb_count;
    U16                                 drb_to_add_count = RRM_NULL;
    U16                                 qos_count;
    rrm_ue_erab_setup_item_list_t       *p_successful_erbs = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);
    /* Coverity_fix_start_55008 */
    for (drb_count = RRM_ZERO ; ((drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE));
            drb_count++)
    {
        /* Coverity_fix_end_55008 */
        for (qos_count = RRM_ZERO ;
                qos_count < p_epc_params->num_valid_qos_profiles ; qos_count++)
        {
            /* Klocwork changes start 27 may */
            if ((drb_to_add_count < MAX_LC_COUNT) && (p_successful_erbs->erab_item[drb_count].
                    erab_level_qos_params.qci ==
                    p_epc_params->qos_config_params[qos_count].qci))
            /* Klocwork changes end 27 may */
            {
                    fill_erb_modify_resp_drb_config(
                            &(p_rrm_drb_to_add_info_list->
                                drb_config[drb_to_add_count]),
                            &(p_epc_params->qos_config_params[qos_count]),
                            &(p_successful_erbs->erab_item[drb_count]),
                            p_rrm_ue_context,
                            p_epc_params->qos_config_params[qos_count].
                            erb_service_profile.data_transfer_mode);

                    p_successful_erbs->erab_item[drb_count].
                         data_transfer_mode =  p_epc_params->qos_config_params[qos_count].
                         erb_service_profile.data_transfer_mode;
                    drb_to_add_count++;
            }
        }
    }
    p_rrm_drb_to_add_info_list->drb_count = drb_to_add_count;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_modify_resp_drb_to_add_list
 *   INPUT        : p_rrm_ue_context,p_epc_params
 *   OUTPUT       : p_rrm_drb_to_add_info_list
 *   DESCRIPTION  :
 *                  Fills the rrm_drb_to_add_info_list_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
fill_erb_setup_modify_resp_drb_to_add_list(
        rrm_drb_to_add_info_list_t *p_rrm_drb_to_add_info_list,
        rrm_ue_context_t           *p_rrm_ue_context,
        epc_params_t               *p_epc_params
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    U16                                 drb_count;
    U16                                 drb_to_add_count = RRM_NULL;
    U16                                 qos_count;
    rrm_ue_erab_setup_item_list_t       *p_successful_erbs = RRM_PNULL;   
        
    RRM_UT_TRACE_ENTER();

    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    for (drb_count = RRM_ZERO ; (drb_count < p_successful_erbs->num_of_list)  
            /* Coverity 19oct Start : 54993 */
            && (drb_count < RRM_MAX_NUM_DRB_PER_UE);
            /* Coverity 19oct End : 54993 */
            drb_count++)
    {	
        for (qos_count = RRM_ZERO ; 
                (qos_count < p_epc_params->num_valid_qos_profiles) && (drb_to_add_count < MAX_LC_COUNT) ; qos_count++)
        {
            /* Klocwork changes start 27 may */
            if (p_successful_erbs->erab_item[drb_count].
                    erab_level_qos_params.qci == 
                    p_epc_params->qos_config_params[qos_count].qci)
            /* Klocwork changes end 27 may */
            {
                   fill_erb_setup_modify_resp_drb_config(
                        &(p_rrm_drb_to_add_info_list->
                            drb_config[drb_to_add_count]),
                        &(p_epc_params->qos_config_params[qos_count]),
                        &(p_successful_erbs->erab_item[drb_count]),
                         p_rrm_ue_context,
                         p_successful_erbs->erab_item[drb_count].
			 data_transfer_mode);

                   drb_to_add_count++;
            }
        }
    }
    p_rrm_drb_to_add_info_list->drb_count = drb_to_add_count;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPS related changes start */

/*klock_works_changes_start*/
rrm_return_et
fill_p_n1_pucch_an_persist_list
(
 rrc_n1_pucch_an_persist_list_t  *p_n1_pucch_an_persist_list,
 rrm_ue_context_t                *p_rrm_ue_context
 )
{
    U16                  index = RRM_ZERO;
    U16                  n1_pucch_an_left_for_sps = RRM_ZERO;
    rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;
    U8   pucch_free_index = RRM_ZERO;
    rrm_return_et        ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65837:start*/
    if (RRM_PNULL != p_cell_ctx)
    {
    p_n1_pucch_an_persist_list->count = RRM_ZERO;
            n1_pucch_an_left_for_sps = 
                (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an + RRM_ONE) +
                (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an *
                 (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift + RRM_ONE))
                -
                p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx;

            
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "PUCCH resources left for SPS are [%d] and Total N1 PUCCH resources configured are [%d] and "
                        "last index for SR resources is [%d]", 
                        n1_pucch_an_left_for_sps, 
                        p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an, 
                        p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx);
            /* SPR_8597_FIX_END*/
            for (index = 0; (index < n1_pucch_an_left_for_sps) && 
                (RRM_PNULL != &( p_cell_ctx->sps_n1_pucch_an_marked_st[index])); index++)
            {
        if(p_cell_ctx->operator_info.ca_config.is_ca_eligible )
	            {
            /*if index n+1 is not available free index n.search new index n and n+1*/
            if((RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_marked_st[index]) &&
                    (RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_marked_st[index+RRM_ONE]))
            {
                p_cell_ctx->sps_n1_pucch_an_marked_st[index] = RRM_ONE;
                p_cell_ctx->sps_n1_pucch_an_marked_st[index+ RRM_ONE ] = RRM_ONE;
                p_n1_pucch_an_persist_list->n1_pucch_an_persist[RRM_ZERO] =
                    p_cell_ctx->sps_n1_pucch_an_start_indx + index;
                p_n1_pucch_an_persist_list->count++;
                p_rrm_ue_context->ue_sps_data.pucch_an_list_resource_index = index;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "SPS resource at index n[%d] allocated for CA ",
                        p_n1_pucch_an_persist_list->n1_pucch_an_persist[RRM_ZERO]);

                p_n1_pucch_an_persist_list->n1_pucch_an_persist[RRM_ONE] =
                    p_cell_ctx->sps_n1_pucch_an_start_indx + index +RRM_ONE;
                p_n1_pucch_an_persist_list->count++;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "SPS resource at index n+1[%d] allocated for CA ",
                        p_n1_pucch_an_persist_list->n1_pucch_an_persist[RRM_ONE]);
                ret_val = RRM_SUCCESS;
                break;
            }
        }
        else  if (RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_marked_st[index])
        {
            /* SPR 8053 Fix end */
            p_n1_pucch_an_persist_list->count = RRM_ONE ;
            /* SPR_8597_FIX_START*/
            p_n1_pucch_an_persist_list->n1_pucch_an_persist[pucch_free_index] =
                p_cell_ctx->sps_n1_pucch_an_start_indx + index;
            p_cell_ctx->sps_n1_pucch_an_marked_st[index] = RRM_ONE;
            p_rrm_ue_context->ue_sps_data.pucch_an_list_resource_index = index;
            ret_val = RRM_SUCCESS;
            break;
        }
    }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /*CID 65837:end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/

/******************************************************************************
 *   FUNCTION NAME: fill_sps_dl_pucch_list
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_n1_pucch_an_persist_list
 *   DESCRIPTION  :
 *                  Fills the required n1-pucch_an_persist_list in case of SPS
 *   RETURNS      :  none
 ******************************************************************************/
rrm_return_et
fill_sps_dl_pucch_list(
    rrc_n1_pucch_an_persist_list_t  *p_n1_pucch_an_persist_list,
    rrm_ue_context_t                *p_rrm_ue_context
    )
{
    rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;
    rrm_return_et        ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65838:start*/
    if (RRM_PNULL == p_cell_ctx )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65838:end*/
    
    if(p_n1_pucch_an_persist_list == RRM_PNULL)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "NULL pointer for p_n1_pucch_an_persist_list");
    }
    else
    {
        /* SPR 8053 Fix start */
        if(RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_start_indx)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        "Pucch resources have not been allocated for SPS");
        }
        else
        {
            /*klock_works_changes_start*/
            ret_val=fill_p_n1_pucch_an_persist_list(p_n1_pucch_an_persist_list, p_rrm_ue_context);
            /*klock_works_changes_end*/
        }
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/******************************************************************************
 *   FUNCTION NAME: fill_sps_config
 *   INPUT        : p_epc_params,qci_val,p0_ue_pusch,p_rrm_ue_context
 *   OUTPUT       : sps_config
 *   DESCRIPTION  :
 *                  Fills the sps_config_t
 *   RETURNS      :  none
 ******************************************************************************/
rrm_return_et
fill_sps_config(
        rrc_sps_config_t          *sps_config,
        epc_params_t              *p_epc_params,
        U8                         qci_val,
        S8                         p0_ue_pusch,
        rrm_ue_context_t          *p_rrm_ue_context
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();

    sps_config->bitmask |= RRM_ZERO;
    sps_config->sps_config_dl.bitmask |= RRM_ZERO;
    sps_config->sps_config_ul.bitmask |= RRM_ZERO;
    /* Coverity_fix_start_55005 */
    if((qci_val != RRM_ZERO) && (qci_val <= RRM_MAX_QCI))
    {
    if (p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.bitmask & RRMCM_RMIF_SPS_CONFIG_DL_PRESENT)
    {
        sps_config->bitmask |= RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT;

        sps_config->sps_config_dl.sps_config_dl_param.semi_persist_sched_interval_dl = 
            p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_dl.semi_persist_sched_interval_dl;

        sps_config->sps_config_dl.sps_config_dl_param.number_of_conf_sps_processes = 
            p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_dl.number_of_conf_sps_processes;

        sps_config->sps_config_dl.max_sps_harq_retx = 
            p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_dl.max_sps_harq_retx;

        sps_config->sps_config_dl.bitmask |= RRC_SPS_CONFIG_DL_PARAM_MAX_SPS_HARQ_RETX;

        sps_config->sps_config_dl.expilcit_release_after = 
            p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_dl.explicit_release_after;

        sps_config->sps_config_dl.bitmask |= RRC_SPS_CONFIG_DL_PARAM_EXPLICIT_RELEASE_AFTER;
    
            ret_val = fill_sps_dl_pucch_list (&sps_config->sps_config_dl.sps_config_dl_param.n1_pucch_an_persist_list, 
                                p_rrm_ue_context);
            if (RRM_SUCCESS == ret_val)
            {
        sps_config->sps_config_dl.bitmask |= RRC_SPS_CONFIG_DL_PARAM_PRESENT;
    }
        }

    if (p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.bitmask & RRMCM_RMIF_SPS_CONFIG_UL_PRESENT)
    {
        sps_config->bitmask |= RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT;

        sps_config->sps_config_ul.sps_config_ul_param.semi_persist_sched_interval_ul =
            p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_ul.semi_persist_sched_interval_ul;

        sps_config->sps_config_ul.sps_config_ul_param.implicit_release_after =
            p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_ul.implicit_release_after;

        if ( p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_ul.bitmask & 
                RRMCM_RMIF_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT )
        {
            sps_config->sps_config_ul.sps_config_ul_param.p_zero_persistent.p_zero_nominal_pusch_persistent = 
                p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_ul.p_zero_nominal_pusch_persistent;

            sps_config->sps_config_ul.sps_config_ul_param.p_zero_persistent.p_zero_ue_pusch_persistent = 
                p0_ue_pusch;

            sps_config->sps_config_ul.sps_config_ul_param.bitmask |= RRC_SPS_CONFIG_UL_P_0_PERSISTENT_PRESENT;
        }

        /* + SPS_TDD_Changes */
#ifdef TDD_MODE_FLAG
        if (p_epc_params->qos_config_params[(qci_val - RRM_ONE)].sps_data.sps_config_ul.bitmask &
                RRMCM_RMIF_TWO_INTERVAL_CONFIG)
        {
            sps_config->sps_config_ul.sps_config_ul_param.two_intervals_config = 
                p_epc_params->qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_ul.two_intervals_config;
            sps_config->sps_config_ul.sps_config_ul_param.bitmask |= RRC_SPS_CONFIG_UL_TWO_INTERVALS_CONFIG_PRESENT;
    }
#endif
        /* - SPS_TDD_Changes */
        sps_config->sps_config_ul.bitmask |= RRC_SPS_CONFIG_UL_PARAM_PRESENT;
    }
    }
    /* Coverity_fix_end_55005 */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_reqd_drx_params_for_sps
 *   INPUT        : p_cell_context,qci_val,p_drx_config 
 *   OUTPUT       : p_rrc_drx_config_param
 *   DESCRIPTION  :
 *                  Fills the required DRX params in case of SPS
 *   RETURNS      : none
 ******************************************************************************/
rrm_void_t
fill_reqd_drx_params_for_sps(
        rrc_drx_config_param_t  *p_rrc_drx_config_param,
/* SPR 10450 Fix Start */
        rrm_cell_drx_res_per_profile_t            *p_drx_config,
/* SPR 10450 Fix End */
        rrm_cell_context_t      *p_cell_context,
        U8                       qci_val
        )
{
    RRM_UT_TRACE_ENTER();

    /* Initialising the parameters */
    p_rrc_drx_config_param->bitmask = RRM_ZERO;  /* Short Cycle not configured for SPS */
    p_rrc_drx_config_param->on_duration_timer = RRM_ZERO;
    p_rrc_drx_config_param->drx_inactivity_timer = RRM_ZERO;
    p_rrc_drx_config_param->long_drx_cycle_start_offset.bitmask = RRM_ZERO;
    p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_20 = RRM_ZERO;
    p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_40 = RRM_ZERO;
    /* Coverity_fix_start_55009 */
    if((qci_val != RRM_ZERO ) && (qci_val <= RRM_MAX_QCI))
    {
    if((p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].bitmask & RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT) &&
       (p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_config_enabled == RRM_TRUE))
    {
            if (p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_data.\
                bitmask & RRMCM_RMIF_SPS_CONFIG_DL_PRESENT)
            {
                if ( RRM_OAM_SPS_PROFILE_20_INTERVAL ==
                        p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_data.\
                        sps_config_dl.semi_persist_sched_interval_dl)
            {
                if ( (p_drx_config->on_duration_timer > RRM_FOUR) &&
                     (p_drx_config->on_duration_timer <= RRM_EIGHT) )
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        p_drx_config->on_duration_timer;
                }
                else
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        RRM_OAM_SPS_PROFILE_20_DRX_ON_DURATION;
                }

                if( (p_drx_config->drx_inactivity_timer > RRM_ZERO) &&
                    (p_drx_config->drx_inactivity_timer <= RRM_EIGHT) )
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        p_drx_config->drx_inactivity_timer;
                }
                else
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        RRM_OAM_SPS_PROFILE_20_DRX_INACTIVITY_TIMER;
                }

                p_rrc_drx_config_param->long_drx_cycle_start_offset.bitmask |=
                    RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT;
                
                /*SPR 17777 +-*/
                
                p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_20 = 
                            p_cell_context->sps_long_drx_cycle_start_offset;
            }

            /* SPR 8978 start */
            else if (RRM_OAM_SPS_PROFILE_40_INTERVAL ==
                        p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_data.\
                        sps_config_dl.semi_persist_sched_interval_dl)
            /* SPR 8978 end */
            {
                if ( (p_drx_config->on_duration_timer > RRM_FOUR) &&
                     (p_drx_config->on_duration_timer <= RRM_FIFTEEN) )
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        p_drx_config->on_duration_timer;
                }
                else
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        RRM_OAM_SPS_PROFILE_40_DRX_ON_DURATION;
                }

                if( (p_drx_config->drx_inactivity_timer > RRM_ZERO) &&
                    (p_drx_config->drx_inactivity_timer <= RRM_FIFTEEN) )
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        p_drx_config->drx_inactivity_timer;
                }
                else
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        RRM_OAM_SPS_PROFILE_40_DRX_INACTIVITY_TIMER;
                }

                p_rrc_drx_config_param->long_drx_cycle_start_offset.bitmask |= 
                    RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT;

                /*SPR 17777 +-*/

                p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_40 =
                    p_cell_context->sps_long_drx_cycle_start_offset;
            }
            /* SPR 8978 start */
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        "SPS_INTERVAL is[%d] and interval other than 20ms and 40ms is not supported "
                        "so DRX params not being filled",
                            p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-1)].sps_data.\
                            sps_config_dl.semi_persist_sched_interval_dl);
            }
            /* SPR 8978 end */
        }
    }
    }
    /* Coverity_fix_end_55009 */
    RRM_UT_TRACE_EXIT();
}
 
/******************************************************************************
 *   FUNCTION NAME: modify_reqd_drx_params_for_sps
 *   INPUT      : drx_config,p_cell_context,qci_val
 *   OUTPUT     : p_rrc_drx_config_param
 *   DESCRIPTION: Modifies the DRX params in case of HO of SPS UE
 *   RETURNS    :  none
 ******************************************************************************/
rrm_void_t
modify_reqd_drx_params_for_sps(
        rrc_drx_config_param_t    *p_rrc_drx_config_param,
        rrm_drx_config_t          *drx_config,
        rrm_cell_context_t        *p_cell_context,
        U8                         qci_val
        )
{
    RRM_UT_TRACE_ENTER();

    /* Initialising the parameters */
    p_rrc_drx_config_param->bitmask = RRM_ZERO;  /* Short Cycle not configured for SPS */
    p_rrc_drx_config_param->on_duration_timer = RRM_ZERO;
    p_rrc_drx_config_param->drx_inactivity_timer = RRM_ZERO;
    p_rrc_drx_config_param->long_drx_cycle_start_offset.bitmask = RRM_ZERO;
    p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_20 = RRM_ZERO;
    p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_40 = RRM_ZERO;

    if((p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].bitmask & RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT) &&
       (p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_config_enabled == RRM_TRUE))
    {
        if (p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_data.bitmask & RRMCM_RMIF_SPS_CONFIG_DL_PRESENT)
        {
            if ( RRM_OAM_SPS_PROFILE_20_INTERVAL ==
                    p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_dl.semi_persist_sched_interval_dl)
            {
                if ( (drx_config->on_duration_timer > RRM_FOUR) &&
                     (drx_config->on_duration_timer <= RRM_EIGHT) )
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        drx_config->on_duration_timer;
                }
                else
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        RRM_OAM_SPS_PROFILE_20_DRX_ON_DURATION;
                }

                if( (drx_config->drx_inactivity_timer > RRM_ZERO) &&
                    (drx_config->drx_inactivity_timer <= RRM_EIGHT) )
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        drx_config->drx_inactivity_timer;
                }
                else
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        RRM_OAM_SPS_PROFILE_20_DRX_INACTIVITY_TIMER;
                }

                p_rrc_drx_config_param->long_drx_cycle_start_offset.bitmask |=
                    RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT;

                /*SPR 17777 +-*/

                p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_20 =
                            p_cell_context->sps_long_drx_cycle_start_offset;
            }

            if (RRM_OAM_SPS_PROFILE_40_INTERVAL ==
                    p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_data.sps_config_dl.semi_persist_sched_interval_dl)
            {
                if ( (drx_config->on_duration_timer > RRM_FOUR) &&
                     (drx_config->on_duration_timer <= RRM_FIFTEEN) )
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        drx_config->on_duration_timer;
                }
                else
                {
                    p_rrc_drx_config_param->on_duration_timer =
                        RRM_OAM_SPS_PROFILE_40_DRX_ON_DURATION;
                }

                if( (drx_config->drx_inactivity_timer > RRM_ZERO) &&
                    (drx_config->drx_inactivity_timer <= RRM_FIFTEEN) )
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        drx_config->drx_inactivity_timer;
                }
                else
                {
                    p_rrc_drx_config_param->drx_inactivity_timer =
                        RRM_OAM_SPS_PROFILE_40_DRX_INACTIVITY_TIMER;
                }

                p_rrc_drx_config_param->long_drx_cycle_start_offset.bitmask |=
                    RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT;

                /*SPR 17777 +-*/

                p_rrc_drx_config_param->long_drx_cycle_start_offset.sf_40 =
                    p_cell_context->sps_long_drx_cycle_start_offset;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/*SPR 17777 +-*/

/* SPS related changes end */
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_pusch_configuration_dedicated
 *   INPUT      : p_snr_phy_pusch_configuration_dedicated
 *   OUTPUT     : p_rrc_phy_pusch_configuration_dedicated
 *   DESCRIPTION:
 *       Fills the rrc_phy_pusch_configuration_dedicated_t
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_pusch_configuration_dedicated(
        rrc_phy_pusch_configuration_dedicated_t 
        *p_rrc_phy_pusch_configuration_dedicated,
        rrc_phy_pusch_configuration_dedicated_ue_service_profile_t 
        *p_snr_phy_pusch_configuration_dedicated
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_phy_pusch_configuration_dedicated->beta_offset_ack_index = 
        p_snr_phy_pusch_configuration_dedicated->beta_offset_ack_index;
    p_rrc_phy_pusch_configuration_dedicated->beta_offset_ri_index = 
        p_snr_phy_pusch_configuration_dedicated->beta_offset_ri_index;
    p_rrc_phy_pusch_configuration_dedicated->beta_offset_cqi_index = 
        p_snr_phy_pusch_configuration_dedicated->beta_offset_cqi_index;
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_uplink_power_control_dedicated
 *   INPUT        : p_snr_uplink_power_control_dedicated,p_rrm_ue_context
 *   OUTPUT       : p_rrc_phy_uplink_power_control_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_uplink_power_control_dedicated_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
/*Uplink power control starts*/
rrm_return_et
fill_erb_setup_resp_uplink_power_control_dedicated(
        rrc_phy_uplink_power_control_dedicated_t
        *p_rrc_phy_uplink_power_control_dedicated,
	rrc_phy_uplink_power_control_dedicated_ue_service_profile_t
        *p_snr_uplink_power_control_dedicated,
	rrm_ue_context_t   *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /*spr 8495 fix start*/
    p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch=
	p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch;  
    /*spr 8495 fix end*/

    /* Start :SPR 9263 */
    if( p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE )
    {
        fill_erb_setup_resp_p0_ue_pusch(&(p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch),
                &(p_snr_uplink_power_control_dedicated->p0_ue_pusch),p_rrm_ue_context);
    }
    /* SPR 21251 +- */
    /* End :SPR 9263 */

    fill_delta_mcs_enabled(&(p_rrc_phy_uplink_power_control_dedicated->delta_mcs_enabled),
            &(p_snr_uplink_power_control_dedicated->delta_mcs_enabled));
    fill_accumulation_enabled(&(p_rrc_phy_uplink_power_control_dedicated->accumulation_enabled),
            &(p_snr_uplink_power_control_dedicated->accumulation_enabled));
    /*spr 8495 fix start*/
    p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch=
	p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch;  
    /*spr 8495 fix end*/

    /* Start :SPR 9263 */
    if( p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE )
    {
        fill_erb_setup_resp_p0_ue_pucch(&(p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch),
                &(p_snr_uplink_power_control_dedicated->p0_ue_pucch),p_rrm_ue_context);
    }
    /* SPR 21251 +- */
    /* End :SPR 9263 */

    p_rrc_phy_uplink_power_control_dedicated->p_srs_offset =
        p_snr_uplink_power_control_dedicated->p_srs_offset;
    p_rrc_phy_uplink_power_control_dedicated->filter_coefficient =
        p_snr_uplink_power_control_dedicated->filter_coefficient;

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Uplink power control end*/
/******************************************************************************
 *   FUNCTION NAME: fill_ue_reconfig_for_tpc_rnti_pucch
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_rrm_ue_reconfig_req
 *   DESCRIPTION  :
 *                  Fills the ue_reconfig_req for tpc_rnti_pucch
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
void
fill_ue_reconfig_for_tpc_rnti_pucch(
        rrc_rrm_ue_reconfig_req_t *p_rrc_rrm_ue_reconfig_req,
        rrm_ue_context_t *p_rrm_ue_context
        )
{
    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_ue_reconfig_req->bitmask |= 
        RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;

    p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig.presence_bitmask |=
                 RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;

    p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
            RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT;

    rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pucch
        (&(p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
           rrc_rrm_ue_reconfig_physical_config_dedicated.
           tpc_pdcch_config_pucch),p_rrm_ue_context);
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_ue_reconfig_for_tpc_rnti_pusch
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrc_rrm_ue_reconfig_req
 *   DESCRIPTION  :
 *                  Fills the ue_reconfig_req for tpc_rnti_pusch
 *
 *   RETURNS      :
 *                  none 
      
 ******************************************************************************/
void
fill_ue_reconfig_for_tpc_rnti_pusch(
          rrc_rrm_ue_reconfig_req_t *p_rrc_rrm_ue_reconfig_req,  
          rrm_ue_context_t *p_rrm_ue_context
          )
{
    /*need to add for ue_reconfig api*/
    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_ue_reconfig_req->bitmask |=
        RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;

    p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig.presence_bitmask |=
        RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;

    p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
        RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT;

    rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pusch
        (&(p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
           rrc_rrm_ue_reconfig_physical_config_dedicated.
           tpc_pdcch_config_pusch),p_rrm_ue_context);
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: fill_tpc_pdcch_pucch_for_release
 *   INPUT        : p_rrc_phy_physical_config_dedicated
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *                  Fills the tpc_pdcch_pucch for release
 *
 *   RETURNS      :
 *                  none 
 *****************************************************************************/

void
fill_tpc_pdcch_pucch_for_release(
        rrc_phy_physical_config_dedicated_t 
        *p_rrc_phy_physical_config_dedicated
        )
{
    p_rrc_phy_physical_config_dedicated->bitmask |=
        RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT;
        
} 

/******************************************************************************
 *   FUNCTION NAME: fill_tpc_pdcch_pusch_for_release
 *   INPUT        : p_rrc_phy_physical_config_dedicated
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *                  Fills the tpc_pdicch_pusch for release
 *
 *   RETURNS      : none
 *****************************************************************************/
void
fill_tpc_pdcch_pusch_for_release(
        rrc_phy_physical_config_dedicated_t
        *p_rrc_phy_physical_config_dedicated
        )
{
        p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT;

}

/* LTE_RRM_CONFIG_START */
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_physical_config_antenna_info_v920
 *   INPUT        : p_codebook_subset_restriction_v90
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  : fills the erb setup response physical antenna info v920
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 *****************************************************************************/
rrm_return_et
fill_erb_setup_resp_physical_config_antenna_info_v920(
				rrc_phy_physical_config_dedicated_t 
						*p_rrc_phy_physical_config_dedicated,
				const rrc_phy_codebook_subset_restriction_v90_ue_service_profile_t 
						*p_codebook_subset_restriction_v90)
{

    rrm_return_et               ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_ANTENNA_INFO_V920_PRESENT;

    p_rrc_phy_physical_config_dedicated->antenna_info_v920.bitmask = RRM_ZERO;

    p_rrc_phy_physical_config_dedicated->antenna_info_v920.bitmask |= 
        RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_V920_PRESENT;
    /*set the code book type and its value*/
    p_rrc_phy_physical_config_dedicated->antenna_info_v920.
        codebook_subset_restriction_v920.type = p_codebook_subset_restriction_v90->type;
    p_rrc_phy_physical_config_dedicated->antenna_info_v920.
        codebook_subset_restriction_v920.value[RRM_ZERO] = 
            p_codebook_subset_restriction_v90->value[RRM_ZERO];

    p_rrc_phy_physical_config_dedicated->antenna_info_v920.
        codebook_subset_restriction_v920.value[RRM_ONE] = 
            p_codebook_subset_restriction_v90->value[RRM_ONE];

    p_rrc_phy_physical_config_dedicated->antenna_info_v920.
        codebook_subset_restriction_v920.value[RRM_TWO] = 
            p_codebook_subset_restriction_v90->value[RRM_TWO];

    p_rrc_phy_physical_config_dedicated->antenna_info_v920.
        codebook_subset_restriction_v920.value[RRM_THREE] = 
            p_codebook_subset_restriction_v90->value[RRM_THREE];

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/* LTE_RRM_CONFIG_END */


/******************************************************************************
 *   FUNCTION NAME: rrm_fill_cqi_report_config_v920
 *   INPUT        : p_rrm_ue_context,antenna_information
 *   OUTPUT       : cqi_report_config_v920
 *   DESCRIPTION  :
 *                  Fills the cqi_report_config_v920
 *
 *   RETURNS      :
 *                  void 
 ******************************************************************************/
void
rrm_fill_cqi_report_config_v920
(
    rrc_phy_physical_config_dedicated_t 
    *p_rrc_phy_physical_config_dedicated,
    rrm_ue_context_t
    *p_rrm_ue_context
)
{
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(p_rrm_ue_context != RRM_PNULL);
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info = RRM_NULL;
    p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(p_rrm_ue_context->cell_index);
    /**if transmission mode is TM8 and pmi_ri_reporting enable
       then enable pmi_ri_report*/
       /* SPR-16135 START */
    if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
	    eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
	if((TRANSMISSION_MODE_TM8_V920 == p_rrc_phy_physical_config_dedicated->antenna_info_r10.
                                         explicit_value.transmission_mode) &&
		(RRM_TRUE == p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9))
	{
	       p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.bitmask |= RRC_PHY_CQI_REPORT_CONFIG_R10_PMI_RI_REPORT_R9_PRESENT;
               p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.cqi_report_pmi_ri_report_r10 = PMI_RI_REPORT_R9_SETUP;
        }
    }
    else
    {
    if((TRANSMISSION_MODE_TM8_V920 == p_rrc_phy_physical_config_dedicated->antenna_information.
       antenna_information_explicit_value.transmission_mode) &&
       (RRM_TRUE == p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9))
    {
        p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_CQI_REPORT_CONFIG_V920_PRESENT;
        p_rrc_phy_physical_config_dedicated->cqi_report_config_v920.bitmask |=
                    RRC_PHY_PMI_RI_REPORT_R9_PRESENT;
        p_rrc_phy_physical_config_dedicated->cqi_report_config_v920.pmi_ri_report_r9 = 
                    PMI_RI_REPORT_R9_SETUP;
    }
    }
    RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tpc_pdcch_config_pucch
 *   INPUT        : *p_rrc_phy_physical_config_dedicated, *p_rrmc_mac_config,
 *                  *p_rrm_ue_context, tpc_rnti_pucch_old,
 *                  *rrc_rrm_ue_reconfig_req, *is_re_config_ue
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_physical_config_dedicated_t
 *
 *   RETURNS      : VOID
 ******************************************************************************/
rrm_void_t
rrm_fill_tpc_pdcch_config_pucch
(
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
    rrmc_mac_config_t                   *p_rrmc_mac_config,
    rrm_ue_context_t                    *p_rrm_ue_context,
    U16                                 tpc_rnti_pucch_old,
    rrc_rrm_ue_reconfig_req_t           *rrc_rrm_ue_reconfig_req,
    rrm_bool_et                         *is_re_config_ue
)
{
    RRM_UT_TRACE_ENTER();

    if((p_rrmc_mac_config->mac_power_control_enable.cqiSinrClpcPucchEnable ==
                RRM_TRUE) || (p_rrmc_mac_config->mac_power_control_enable.harqBlerClpcPucchEnable
                    == RRM_TRUE))
    {
        if((p_rrmc_mac_config->mac_power_control_enable.tpc_pdcch_ConfigPUCCH_enabled == RRM_TRUE) 
                && (p_rrm_ue_context->rrm_ue_clpc_params.
                    tpc_rnti_pucch != RRM_NULL))
        {	
            /**No tpc rnti was provided*/
            if(tpc_rnti_pucch_old == RRM_NULL)
            {
                p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT;
                rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pucch
                    (&(p_rrc_phy_physical_config_dedicated->
                       tpc_pdcch_config_pucch),p_rrm_ue_context);
            }
            else
            {
                if(tpc_rnti_pucch_old != p_rrm_ue_context->rrm_ue_clpc_params.
                        tpc_rnti_pucch)
                {
                    /**fill tpc pdcch pucch for release*/ 
                    fill_tpc_pdcch_pucch_for_release(
                            p_rrc_phy_physical_config_dedicated
                            );
                    /**fill ue reconfig for tpc pucch*/ 
                    rrc_rrm_ue_reconfig_req->ue_index = 
                        p_rrm_ue_context->ue_index;

                    fill_ue_reconfig_for_tpc_rnti_pucch(
                            rrc_rrm_ue_reconfig_req,
                            p_rrm_ue_context);
                    *is_re_config_ue = RRM_TRUE;
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d], tpc_pdcch_config_pucch is disabled,"
                    "or tpc_pdcch_config_pucch could not be allocated",
                    p_rrm_ue_context->ue_index);
        }			
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d],pucch clpc is disabled",
                p_rrm_ue_context->ue_index);
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tpc_pdcch_config_pusch
 *   INPUT        : *p_rrc_phy_physical_config_dedicated, *p_rrmc_mac_config,
 *                  *p_rrm_ue_context, tpc_rnti_pusch_old,
 *                  *rrc_rrm_ue_reconfig_req, *is_re_config_ue
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_physical_config_dedicated_t
 *
 *   RETURNS      : VOID
 ******************************************************************************/
rrm_void_t
rrm_fill_tpc_pdcch_config_pusch
(
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
    rrmc_mac_config_t                   *p_rrmc_mac_config,
    rrm_ue_context_t                    *p_rrm_ue_context,
    U16                                 tpc_rnti_pusch_old,
    rrc_rrm_ue_reconfig_req_t           *rrc_rrm_ue_reconfig_req,
    rrm_bool_et                         *is_re_config_ue,
    U8                                  accumulation_enabled
)
{
    RRM_UT_TRACE_ENTER();

    if((p_rrmc_mac_config->mac_power_control_enable.clpcPuschEnable == RRM_TRUE)
            && (accumulation_enabled == RRM_TRUE))
    {
        if((p_rrmc_mac_config->mac_power_control_enable.tpc_pdcch_ConfigPUSCH_enabled ==
                    RRM_TRUE) && (p_rrm_ue_context->rrm_ue_clpc_params.
                        tpc_rnti_pusch != RRM_NULL))
        {

            if(tpc_rnti_pusch_old == RRM_NULL)
            {
                p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT;
                rrm_rrc_ue_adm_resp_fill_tpc_pdcch_config_pusch
                    (&(p_rrc_phy_physical_config_dedicated->
                       tpc_pdcch_config_pusch),p_rrm_ue_context);
            }
            else
            {
                if(tpc_rnti_pusch_old != p_rrm_ue_context->rrm_ue_clpc_params.
                        tpc_rnti_pusch)
                {
                    /**fill tpc pdcch pucch for release*/
                    fill_tpc_pdcch_pusch_for_release(
                            p_rrc_phy_physical_config_dedicated
                            );
                    /**fill ue reconfig for tpc pusch*/
                    rrc_rrm_ue_reconfig_req->ue_index =
                        p_rrm_ue_context->ue_index;

                    fill_ue_reconfig_for_tpc_rnti_pusch(
                            rrc_rrm_ue_reconfig_req,
                            p_rrm_ue_context);
                    *is_re_config_ue = RRM_TRUE;
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d], tpc_pdcch_config_pusch is disabled,"
                    "or tpc_pdcch_config_pusch could not be allocated",
                    p_rrm_ue_context->ue_index);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d], tpc_pdcch_config_pusch could not be"
                "provided because either pusch clpc is disabled"
                "or accumulation is disabled",
                p_rrm_ue_context->ue_index);
    }	
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_set_antenna_info_v920
 *   INPUT        : *p_rrc_phy_physical_config_dedicated,
 *                  *p_ue_profile_physical_config_dedicated
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the antenna info in rrc_phy_physical_config_dedicated_t
 *
 *   RETURNS      : VOID
 ******************************************************************************/
rrm_void_t
rrm_set_antenna_info_v920
(
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
    rrc_phy_physical_config_dedicated_ue_service_profile_t
                                    *p_ue_profile_physical_config_dedicated
)
{
    RRM_UT_TRACE_ENTER();
    if ( (p_ue_profile_physical_config_dedicated->bitmask & 
             RRC_SERVICE_PROFILE_PHY_ANTENNA_INFORMATION_PRESENT))
    {
        if (p_ue_profile_physical_config_dedicated->antenna_information.bitmask & 
                   RRC_SERVICE_PROFILE_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT)
        {
            if (p_ue_profile_physical_config_dedicated->antenna_information.antenna_information_explicit_value.bitmask & 
                  RRC_SERVICE_PROFILE_PHY_CODEBOOK_SUBSET_RESTRICTION_V90_PRESENT)
            {
                 /* R10 */
                 fill_erb_setup_resp_physical_config_antenna_info_v920(
                                           p_rrc_phy_physical_config_dedicated,
                                        &(p_ue_profile_physical_config_dedicated->
                                          antenna_information.antenna_information_explicit_value.
                                                         codebook_subset_restriction_v90));
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_cqi_report_config
 *   INPUT        : *p_rrm_ue_context, rrm_enable_cqi_mask_r9,
 *                  *p_rrc_phy_physical_config_dedicated,
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the cqi report config in 
 *                  rrc_phy_physical_config_dedicated_t
 *
 *   RETURNS      : VOID
 ******************************************************************************/
rrm_void_t
rrm_fill_cqi_report_config
(
    rrm_ue_context_t                    *p_rrm_ue_context,
    rrm_bool_et                         rrm_enable_cqi_mask_r9,
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated
)
{
    RRM_UT_TRACE_ENTER();
    if((p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
    /*spr 16886 start*/
            (RRM_REL9 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
        eutra_radio_capability_info_def.access_stratum_release) )
    /*spr 16886 end*/
    {
       if(RRM_TRUE == rrm_enable_cqi_mask_r9)
       {
           /* SPR 14221 FIX START */
           p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_CQI_REPORT_CONFIG_V920_PRESENT;
           /* SPR 14221 FIX END */
           p_rrc_phy_physical_config_dedicated->cqi_report_config_v920.bitmask |=
                    RRC_PHY_CQI_MASK_R9_PRESENT;
           p_rrc_phy_physical_config_dedicated->cqi_report_config_v920.cqi_mask_r9=
                        CQI_MASK_R9_SETUP;
            /*spr 16886 start*/
            p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_CQI_REPORT_CONFIG_V920_PRESENT;
            /*spr 16886 end*/

       }
       else
       {
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                   "[UE:%d], cqi mask r9 is not enabled, not filling cqi_mask_r9",
                   p_rrm_ue_context->ue_index);
       }
    }
    /* SPR-16135 START */
    else if((p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
            (RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release))
        /* SPR-16135 END */
    {
        if(RRM_TRUE == rrm_enable_cqi_mask_r9)
        {
            /*SPR 11064:start*/
            p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.cqi_report_periodic_r10.setup.bitmask |= 
                RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT;
            /*SPR 11064:end*/
            p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.cqi_report_periodic_r10.setup.cqi_mask_r9 = 
                CQI_MASK_R9_SETUP;
        }
            /*SPR 11064:start*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] rrm_enable_cqi_mask_r9[%d] bitmask[%d]",
                p_rrm_ue_context->ue_index,rrm_enable_cqi_mask_r9,
                p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.cqi_report_periodic_r10.setup.bitmask);
        /*SPR 11064:end*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d], UE is not rel9, not filling cqi_mask_r9",
                p_rrm_ue_context->ue_index);
    }
    RRM_UT_TRACE_EXIT();
}

/*klock_works_changes_start*/
rrm_return_et
fill_rrc_phy_physical_config_dedicated
(
 rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
 rrm_ue_context_t                    *p_rrm_ue_context,
 rrc_phy_physical_config_dedicated_ue_service_profile_t *p_ue_profile_physical_config_dedicated

 )
{
    rrm_return_et  ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

#ifndef LTE_EMBMS_SUPPORTED
    if(RRM_DISABLE_CQI_REPORTING !=
            p_ue_profile_physical_config_dedicated->cqi_reporting.
            rrm_cqi_reporting_mode_configured)
#else
    if((RRM_DISABLE_CQI_REPORTING !=
            p_ue_profile_physical_config_dedicated->cqi_reporting.
            rrm_cqi_reporting_mode_configured) &&
       ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
    {   /*R-10 Changes : Start*/
        if(p_ue_profile_physical_config_dedicated->bitmask &
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT)
        {
            /* SPR-16135 START */
            if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.access_stratum_release)
                /* SPR-16135 END */
            {
                p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;
                rrm_rrc_ue_fill_cqi_reporting_r10
                    (&(p_rrc_phy_physical_config_dedicated->cqi_report_config_r10),
                     &(p_ue_profile_physical_config_dedicated->cqi_reporting),
                     p_rrm_ue_context,
                     p_rrc_phy_physical_config_dedicated->antenna_info_r10.
                     explicit_value.transmission_mode);
            }
            else
        {
            p_rrc_phy_physical_config_dedicated->bitmask |= 
                RRC_PHY_CQI_REPORTING_PRESENT;
            rrm_rrc_ue_fill_cqi_reporting
                (&(p_rrc_phy_physical_config_dedicated->cqi_reporting),
                 &(p_ue_profile_physical_config_dedicated->cqi_reporting),
                 p_rrm_ue_context,
                 p_rrc_phy_physical_config_dedicated->antenna_information.
                 antenna_information_explicit_value.transmission_mode);
        }
        }
        /* Store UE's updated CQI information in Context */
        /* SPR-16135 START */
        if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
            /* SPR-16135 END */
        {
            rrm_set_cqi_information_for_ue_r10(p_rrm_ue_context,
                    &(p_rrc_phy_physical_config_dedicated->cqi_report_config_r10));
        }
        else
        {
            rrm_set_cqi_information_for_ue(p_rrm_ue_context,
                    &(p_rrc_phy_physical_config_dedicated->cqi_reporting));
        }
    }
    else
    {
        /* SPR-16135 START */
        if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
            /* SPR-16135 END */
        {
            p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;

            p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.bitmask = RRM_ZERO;
            p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.nomPDSCH_rs_epre_offset =
                p_ue_profile_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset;
        }
    else
    {
        p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_CQI_REPORTING_PRESENT;
        p_rrc_phy_physical_config_dedicated->cqi_reporting.bitmask = RRM_ZERO;
        p_rrc_phy_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset =
            p_ue_profile_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset;
        }
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d], CQI rreporting is disabled",
                p_rrm_ue_context->ue_index);
    }
   
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/

/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_physical_config_dedicated
 *   INPUT        : p_admission_control_info,ul_mcs,dl_mcs,p_rrm_ue_context,
 *                  tpc_rnti_pucch_old,tpc_rnti_pusch_old
 *   OUTPUT       : p_rrc_phy_physical_config_dedicated
 *   DESCRIPTION  :
 *                  Fills the rrc_phy_physical_config_dedicated_t
 *
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_physical_config_dedicated(
        rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
        admission_control_info_t            *p_admission_control_info,
        U8                                  *ul_mcs,
        U8 							        *dl_mcs,
        rrm_ue_context_t                    *p_rrm_ue_context,
        U16                                  tpc_rnti_pucch_old,
        /*spr_19392_changes_start*/
        U16                                  tpc_rnti_pusch_old,
        rrm_erab_procedure_et                current_procedure
        /*spr_19392_changes_end*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrmc_mac_config_t               *p_rrmc_mac_config = RRM_NULL;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = RRM_PNULL;
    rrc_phy_physical_config_dedicated_ue_service_profile_t
        *p_ue_profile_physical_config_dedicated = RRM_PNULL;
    rrm_bool_et                      is_re_config_ue = RRM_FALSE;
    /*ue reconfig*/
    rrc_rrm_ue_reconfig_req_t        rrc_rrm_ue_reconfig_req;
    U8                               accumulation_enabled = RRM_ZERO;
         /*SPR 17777 +-*/
#ifdef TDD_MODE_FLAG    
    /*SPR 6810 Start */ 
    rrm_physical_layer_params_t     *p_rrm_physical_layer_params = RRM_NULL;
    /*SPR 6810 End */ 
#endif    
         /*SPR 17777 +-*/
	rrm_cell_context_t		         *p_cell_ctx = RRM_PNULL;
    /*spr 7984 start*/
    rrm_bool_et rrm_enable_cqi_mask_r9 = rrm_cellm_get_enable_cqi_mask_r9(p_rrm_ue_context->cell_index);
    /*spr 7984 end*/
    /*BUG 13332:start*/
    U16                             transaction_id = RRM_ZERO;
    /*BUG 13332:end*/
    
    RRM_UT_TRACE_ENTER();
    RRM_MEMSET(&rrc_rrm_ue_reconfig_req,RRM_ZERO,sizeof(rrc_rrm_ue_reconfig_req_t));
    
    p_cell_ctx = rrm_cellm_get_cell_context(
                                    p_rrm_ue_context->cell_index);
    p_rrmc_mac_config = 
        rrm_cellm_get_rrmc_mac_config(p_rrm_ue_context->cell_index);
         /*SPR 17777 +-*/
#ifdef TDD_MODE_FLAG    
    /*SPR 6810 Start */ 
    p_rrm_physical_layer_params = 
        rrm_cellm_get_physical_layer_params(p_rrm_ue_context->cell_index);
    /*SPR 6810 End */ 
#endif    
         /*SPR 17777 +-*/
    p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_PDSCH_CONFIGURATION_DEDICATED_PRESENT;
    /*
     ** Get the p_a value configured from OAM for Cell Center (CC) UE's.
     */
    /*CID 65836:start*/
    if ( RRM_PNULL != p_cell_ctx)
    {
        if( RRM_UE_POSITION_AT_CELL_EDGE == 
                p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)   
        {
            p_rrc_phy_physical_config_dedicated->pdsch_configuration_dedicated.p_a = 
                p_cell_ctx->dynamic_icic_data.pdsch_config_params.
                pdsch_dedicated_config.pa_for_ce_ue; 
        }
        else
        {
            p_rrc_phy_physical_config_dedicated->pdsch_configuration_dedicated.p_a = 
                p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a; 
        }
        /*Read p_a from file*/
        //fill_erb_setup_resp_p_a(&(p_rrc_phy_physical_config_dedicated->pdsch_configuration_dedicated.p_a));

        p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_PUCCH_CONFIGURATION_DEDICATED_PRESENT;
        p_rrc_phy_physical_config_dedicated->pucch_configuration_dedicated.bitmask = RRM_ZERO;

        /*SPR 6810 Start */ 
        rrm_rrc_erb_setup_modify_resp_fill_pucch_configuration_dedicated
            (&(p_rrc_phy_physical_config_dedicated->
         /*SPR 17777 +-*/
               pucch_configuration_dedicated)
#ifdef TDD_MODE_FLAG             
             ,p_rrm_physical_layer_params
#endif             
             );
         /*SPR 17777 +-*/
        /*SPR 6810 End */ 

        *ul_mcs =  p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs;

        accumulation_enabled = p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
            accumulation_enabled;

        if( p_admission_control_info->snr_map.snr_dep_params.
                uplink_snr_dep_params.bitmask & PUSCH_INFO_SNR_MAP_PRESENT )
        {
            p_rrc_phy_physical_config_dedicated->bitmask |= 
                RRC_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT;
            fill_erb_setup_resp_pusch_configuration_dedicated
                (&(p_rrc_phy_physical_config_dedicated->
                   pusch_configuration_dedicated),
                 &(p_admission_control_info->snr_map.
                     snr_dep_params.uplink_snr_dep_params.
                     pusch_config_dedicated));
        }

        if( p_admission_control_info->snr_map.snr_dep_params.
                uplink_snr_dep_params.bitmask & 
                UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT )
        {
            p_rrc_phy_physical_config_dedicated->bitmask |= 
                RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;
            fill_erb_setup_resp_uplink_power_control_dedicated
                (&(p_rrc_phy_physical_config_dedicated->
                   uplink_power_control_dedicated),\
                 &(p_admission_control_info->snr_map.
                     snr_dep_params.uplink_snr_dep_params.\
                     uplink_pow_control),p_rrm_ue_context);
        }

        *dl_mcs = p_admission_control_info->snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs;
        /* R-10 Changes : Start */  
         /* SPR-16135 START */
    /*spr_19392_changes_start*/
    if(ERAB_HO_ADM == current_procedure)
    {
        p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated.bitmask = RRM_ZERO;
        if(RRM_TRUE == rrm_cellm_get_srs_status(p_rrm_ue_context->cell_index))
        {
            /* Filling the sounding reference signal parameters */
            /* SRS start */

            ret_val = rrm_rrc_ue_adm_resp_fill_sounding_reference_signal
                (&(p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated),
                 p_rrm_ue_context);
            if(RRM_SUCCESS == ret_val)
            {
                p_rrc_phy_physical_config_dedicated->bitmask |=
                    RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;
            }
        }
    }
    /*spr_19392_changes_end*/

        if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
         /* SPR-16135 END */
        {
            p_rrc_phy_physical_config_dedicated->bitmask |=
                RRC_PHY_ANTENNA_INFO_R10_PRESENT;
        }
        else
        {
            p_rrc_phy_physical_config_dedicated->bitmask |=
                RRC_PHY_ANTENNA_INFORMATION_PRESENT;
        }
        /* R-10 Changes : End */
        rrm_rrc_ue_adm_resp_fill_antenna_information( p_rrm_ue_context,
                p_rrc_phy_physical_config_dedicated);

        /*TM mode 7-8 start*/ /*R-10 Changes : Start*/
        rrm_fill_cqi_report_config_v920(p_rrc_phy_physical_config_dedicated,
                p_rrm_ue_context);
        /*TM mode 7-8 end*/ /*R-10 Changes : End*/

        p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);
        p_ue_profile_physical_config_dedicated = &(p_ue_service_profile->radio_res_config.physical_config_dedicated);

        /*klock_works_changes_start*/
        ret_val= fill_rrc_phy_physical_config_dedicated(p_rrc_phy_physical_config_dedicated, p_rrm_ue_context, p_ue_profile_physical_config_dedicated);
        /*klock_works_changes_end*/

        /*R-10 Changes : End*/
        /**CLPC_MR_START*/
        /**Fill tpc_pdcch_config_pucch*/
        /* Klocwork_fix_march_14_start */
        rrm_fill_tpc_pdcch_config_pucch(p_rrc_phy_physical_config_dedicated,
                p_rrmc_mac_config, p_rrm_ue_context,
                tpc_rnti_pucch_old, &rrc_rrm_ue_reconfig_req,
                &is_re_config_ue);
        /* Klocwork_fix_march_14_end */

        /**Fill tpc_pdcch_config_pusch*/
        /* Klocwork_fix_march_14_start */
        rrm_fill_tpc_pdcch_config_pusch(p_rrc_phy_physical_config_dedicated,
                p_rrmc_mac_config, p_rrm_ue_context,
                tpc_rnti_pusch_old, &rrc_rrm_ue_reconfig_req,
                &is_re_config_ue, accumulation_enabled);
        /* Klocwork_fix_march_14_end */

        if(is_re_config_ue == RRM_TRUE)
        {
            /*enqueue ue_reconfig*/
            rrm_ue_procedure_queue_t    proc_queue;
            proc_queue.api_id = RRC_RRM_UE_RECONFIG_REQ;
            proc_queue.p_proc_data =
                (rrc_rrm_ue_reconfig_req_t *)rrm_mem_get
                (sizeof(rrc_rrm_ue_reconfig_req_t));
            /*BUG 13332:start*/
            proc_queue.trans_id = transaction_id;
            /*BUG 13332:end*/


            /*Kshitij_start CID:16298*/
            if(RRM_PNULL == proc_queue.p_proc_data)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "fill_erb_setup_resp_physical_config_dedicated: Mem allocation failed");
                return RRM_FAILURE;
            }
            /* Kshitij_end*/

            RRM_MEMCPY((rrc_rrm_ue_reconfig_req_t*)proc_queue.
                    p_proc_data,&rrc_rrm_ue_reconfig_req,
                    sizeof(rrc_rrm_ue_reconfig_req_t));
            /**Enqueue ue reconfig request */
            /*SPR 18241 START*/
            rrm_ue_mgr_enqueue_req( &proc_queue,p_rrm_ue_context,RRM_FALSE);
            /*SPR 18241 END*/
        /* SPR 15441 start */
        RRM_MEM_FREE(proc_queue.p_proc_data);
        /* SPR 15441 end */
        }
        /**CLPC_MR_END*/       

        //no support sounding_rs_ul_config_dedicated

        p_rrc_phy_physical_config_dedicated->bitmask |= 
            RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT;
        rrm_rrc_ue_adm_resp_fill_scheduling_request_config
            (&(p_rrc_phy_physical_config_dedicated->scheduling_request_config),\
             p_rrm_ue_context);

        /* LTE_RRM_CONFIG_START set the antenna info v920, read from rrm_oam.cfg*/
        /* Klocwork_fix_march_14_start */
        rrm_set_antenna_info_v920(p_rrc_phy_physical_config_dedicated,
                p_ue_profile_physical_config_dedicated);    
        /* Klocwork_fix_march_14_end */
        /* LTE_RRM_CONFIG_END */

        /*spr 7984 start*/
        /* Klocwork_fix_march_14_start */
        rrm_fill_cqi_report_config (p_rrm_ue_context, rrm_enable_cqi_mask_r9,
                p_rrc_phy_physical_config_dedicated);
        /* Klocwork_fix_march_14_end */
        /*spr 7984 end*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65836:end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb2_ul_am_rlc
 *   INPUT        : p_rlc_layer_params
 *   OUTPUT       : p_rrc_uplink_am_rlc
 *   DESCRIPTION  :
 *                  Fills the rrc_uplink_am_rlc_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
//fill srb2 specific values
rrm_return_et
fill_erb_setup_resp_fill_srb2_ul_am_rlc(
        rrc_uplink_am_rlc_t *p_rrc_uplink_am_rlc,
        rlc_layer_params_t  *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    /** srb2 specific default config values */
    RRM_UT_TRACE_ENTER();
    p_rrc_uplink_am_rlc->t_poll_retransmit = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].srb_params.
        t_poll_retransmit;
    p_rrc_uplink_am_rlc->poll_pdu = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].srb_params.poll_pdu;
    p_rrc_uplink_am_rlc->poll_byte = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].srb_params.poll_byte;
    p_rrc_uplink_am_rlc->max_retx_threshold = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].srb_params.
        max_retx_threshold;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb2_dl_am_rlc
 *   INPUT      : p_rlc_layer_params
 *   OUTPUT     : p_rrc_downlink_am_rlc
 *   DESCRIPTION:
 *                Fills the rrc_downlink_am_rlc_t
 *
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

//fill srb2 specific values
rrm_return_et
fill_erb_setup_resp_fill_srb2_dl_am_rlc(
        rrc_downlink_am_rlc_t *p_rrc_downlink_am_rlc,
        rlc_layer_params_t    *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    /** srb1 specific default config values */
    RRM_UT_TRACE_ENTER();
    p_rrc_downlink_am_rlc->t_reordering = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].srb_params.t_reordering;
    p_rrc_downlink_am_rlc->t_status_prohibit = 
        p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].srb_params.
        t_status_prohibit;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb2_am_config_explicit
 *   INPUT      : p_rrc_am_config
 *   OUTPUT     : p_rlc_layer_params
 *   DESCRIPTION:
 *                Fills the rrc_am_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_fill_srb2_am_config_explicit(
        rrc_am_config_t     *p_rrc_am_config,
        rlc_layer_params_t  *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    fill_erb_setup_resp_fill_srb2_ul_am_rlc
        (&(p_rrc_am_config->ul_am_rlc),p_rlc_layer_params);
    fill_erb_setup_resp_fill_srb2_dl_am_rlc
        (&(p_rrc_am_config->dl_am_rlc),p_rlc_layer_params);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb1_am_config
 *   INPUT      : p_rlc_layer_params
 *   OUTPUT     : p_rrm_srb_am_config
 *   DESCRIPTION:
 *                Fills the rrm_srb_am_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_fill_srb2_am_config(
        rrm_srb_am_config_t *p_rrm_srb_am_config,
        rlc_layer_params_t  *p_rlc_layer_params
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_srb_am_config->bitmask |= RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT;
    fill_erb_setup_resp_fill_srb2_am_config_explicit
        (&(p_rrm_srb_am_config->am_config_explicit),p_rlc_layer_params);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb2_ul_specific_parameters_explicit
 *   INPUT      : p_rlc_layer_params
 *   OUTPUT     : p_rrm_ul_specific_parameters_explicit
 *   DESCRIPTION:
 *                Fills the rrc_ul_specific_parameters_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

//srb2 specific values
rrm_return_et
fill_erb_setup_resp_fill_srb2_ul_specific_parameters_explicit(
        rrc_ul_specific_parameters_t       
        *p_rrm_ul_specific_parameters_explicit
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_ul_specific_parameters_explicit->priority = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_1_PRIORITY;
    p_rrm_ul_specific_parameters_explicit->prioritized_bit_rate = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_PRIORITIZED_BIT_RATE;
    p_rrm_ul_specific_parameters_explicit->bucket_size_duration = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_BUCKET_SIZE_DURATION;
    p_rrm_ul_specific_parameters_explicit->bitmask |= 
        RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_PRESENT;
    p_rrm_ul_specific_parameters_explicit->logical_channel_group = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_LOGICAL_CHANNEL_GROUP;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb2_mac_lc_config_enb
 *   INPUT      : p_rlc_layer_params
 *   OUTPUT     : p_rrm_mac_lc_config
 *   DESCRIPTION:
 *                Fills the rrm_mac_lc_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_fill_srb2_mac_lc_config_enb(
        rrm_mac_lc_config_t *p_rrm_mac_lc_config
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_mac_lc_config->bitmask |= RRM_MAC_LC_CONFIG_UL_LC_G_ID_PRESENT;
    p_rrm_mac_lc_config->ul_lc_g_id = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_LOGICAL_CHANNEL_GROUP;
    p_rrm_mac_lc_config->bitmask |= RRM_MAC_LC_CONFIG_DL_PRIORITY_PRESENT;
    p_rrm_mac_lc_config->dl_lch_priority = 
        RRM_DEFINED_DEFAULT_VALUE_FOR_SRB_1_PRIORITY;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_return_et
fill_erb_setup_resp_fill_srb2_logical_channel_config(
        rrm_logical_channel_config_t *p_rrm_logical_channel_config,
         /*SPR 17777 +-*/
        rrm_ue_context_t   *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    rrm_set_r9_mask(p_rrm_logical_channel_config,
                               p_rrm_ue_context);
    
    p_rrm_logical_channel_config->bitmask |= 
        RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT;
    /* SPR Fix 17928 Start */
    fill_erb_setup_resp_fill_srb2_ul_specific_parameters_explicit
        (&(p_rrm_logical_channel_config->ul_specific_parameters_explicit));
    /* SPR Fix 17928 End */ 
	/*SPR 17777 +-*/
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_fill_srb2_config
 *   INPUT      : p_rlc_layer_params,p_rrm_ue_context
 *   OUTPUT     : p_rrm_srb2_config
 *   DESCRIPTION:
 *                Fills the rrm_srb_config_t
 *   RETURNS     :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_fill_srb2_config(
        rrm_srb_config_t   *p_rrm_srb2_config,
        rlc_layer_params_t *p_rlc_layer_params,
        rrm_ue_context_t   *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /* Start CSR 00059256 */
    if(p_rlc_layer_params->rlc_layer_param_srb[RRM_ONE].default_configuration == RRM_FALSE)
    {
        p_rrm_srb2_config->bitmask |= RRM_SRB_CONFIG_AM_CONFIG_PRESENT;
        fill_erb_setup_resp_fill_srb2_am_config
            (&(p_rrm_srb2_config->srb_am_config),p_rlc_layer_params);
    }
    /* End CSR 00059256 */
    p_rrm_srb2_config->bitmask |= RRM_SRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT;
    fill_erb_setup_resp_fill_srb2_logical_channel_config
         /*SPR 17777 +-*/
        (&(p_rrm_srb2_config->logical_channel_config),
         p_rrm_ue_context);
    p_rrm_srb2_config->bitmask |= RRM_SRB_CONFIG_MAC_LC_CONFIG_ENB_PRESENT;
    fill_erb_setup_resp_fill_srb2_mac_lc_config_enb
        (&(p_rrm_srb2_config->mac_lc_config_enb));
         /*SPR 17777 +-*/
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_srb2_info
 *   INPUT      : p_rlc_layer_params,p_rrm_ue_context
 *   OUTPUT     : p_rrm_srb_info
 *   DESCRIPTION:
 *                Fills the rrm_srb_info_t
 *
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_srb2_info(
        rrm_srb_info_t      *p_rrm_srb_info,
        rlc_layer_params_t  *p_rlc_layer_params,
        rrm_ue_context_t    *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrm_srb_info->bitmask |= RRM_SRB_INFO_SRB2_CONFIG_PRESENT;
    fill_erb_setup_resp_fill_srb2_config
        (&(p_rrm_srb_info->srb2_config),p_rlc_layer_params,
         p_rrm_ue_context);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*Start changes for TTI bundling feature*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tti_bundling
 *   INPUT      : tti_bundling_erb_setup_resp,p_rrm_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                filling for tti_bundling of erb setup resp
 *
 *   RETURNS    :
 *                none 
 ******************************************************************************/
void
rrm_fill_tti_bundling( U8*                  tti_bundling,
                       rrm_ue_context_t     *p_rrm_ue_context
                      ) 
{
    /* SPR 18641_18843 fix start */
    /* Code removed */

    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /* SPR 19838 : CID 109337 Fix Start */
    if(RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context is NULL");
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /* SPR 19838 : CID 109337 Fix End */

  /*Coverity CID 109337 Fix Start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
    }
    /*Coverity CID 109337 Fix End*/

	if(PNULL != p_cell_context)
	{
    if( (RRC_SERVICE_PROFILE_UL_SCH_CONFIG_TTI_BUNDLING_INFO_PRESENT & p_cell_context->operator_info.bitmask) && 
        ((p_rrm_ue_context->ue_avg_stats.uplinkSINRValue < p_cell_context->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti) &&
            (RRM_TRUE == p_rrm_ue_context->support_tti_bundling) && p_rrm_ue_context->tti_bundling_enabled == RRM_FALSE) )

    {
                            /* + SPR 20078 */
        if (p_rrm_ue_context->ue_avg_stats.uplinkPRB < p_cell_context->operator_info.tti_bundling_info.rrm_ue_used_rb_threshold)
                            /* - SPR 20078 */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                     "[UE:%d] TTI Bundling Feature enable, rrm_ue_used_rb_threshold[%d], ul_sinr_threshold_to_actv_tti[%d]",
                      p_rrm_ue_context->ue_index,
                      p_cell_context->operator_info.tti_bundling_info.rrm_ue_used_rb_threshold,
                      p_cell_context->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti);
            *tti_bundling = RRM_ONE;
        }
        else
        {
                            /* + SPR 20078 */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d] RB used by UE[%d] is more than rrm_ue_used_rb_threshold[%d]",
		    p_rrm_ue_context->ue_index,p_rrm_ue_context->ue_avg_stats.uplinkPRB,
            p_cell_context->operator_info.tti_bundling_info.rrm_ue_used_rb_threshold);
                            /* - SPR 20078 */
        }
    }
    else if( (RRC_SERVICE_PROFILE_UL_SCH_CONFIG_TTI_BUNDLING_INFO_PRESENT & p_cell_context->operator_info.bitmask) && 
             ((p_rrm_ue_context->ue_avg_stats.uplinkSINRValue < p_cell_context->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti) &&
                    (RRM_TRUE == p_rrm_ue_context->support_tti_bundling) && p_rrm_ue_context->tti_bundling_enabled == RRM_TRUE) )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "[UE:%d] TTI Bundling Feature enabled because SINR is less than deactivate threshold, ul_sinr_threshold_to_deactv_tti[%d]"
                ,p_rrm_ue_context->ue_index,
                p_cell_context->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti);
        *tti_bundling = RRM_ONE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "[UE:%d] TTI Bundling Feature disable, ul_sinr_threshold_to_deactv_tti[%d], uplinkSINRValue[%d]"
                ,p_rrm_ue_context->ue_index,
                p_cell_context->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti,
                p_rrm_ue_context->ue_avg_stats.uplinkSINRValue);
        *tti_bundling = RRM_ZERO;
		}
    }
    /* SPR 18641_18843 fix end */
    /* SPR 18640 Fix End */

    RRM_UT_TRACE_EXIT();

}
/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_determine_support_tti_bundling
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                rrm_determine support_tti_bundling for a UE
 *
 *   RETURNS    :
 *                none 
 ******************************************************************************/
rrm_void_t
rrm_determine_support_tti_bundling
(
    rrm_ue_context_t     *p_rrm_ue_context
)
{
    rrm_cell_context_t		         *p_cell_context = RRM_PNULL;
    U16					 	         index   = RRM_ZERO;
    U8					 	         qci = RRM_ZERO;
    U8						         qci_count = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* 
     ** TTI bundling shall be consider if the 28th bit of FGI is set to 1 for Rel 9 UE
     ** or Bit 3 is ON for Rel 8 UE.
     */
    /*Start:Bug 762*/

    /* SPR 19037 Fix Start */
    if (((RRM_REL9 <= p_rrm_ue_context->ue_capability_params.\
                rrm_eutra_radio_capability_info.\
                eutra_radio_capability_info_def.\
                access_stratum_release) &&
            (RRM_TRUE  == (rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_TWENTY_EIGHT)))) ||
            ((RRM_REL8 == p_rrm_ue_context->ue_capability_params.\
                   rrm_eutra_radio_capability_info.\
                   eutra_radio_capability_info_def.\
                   access_stratum_release) &&
            
            (RRM_TRUE  == (rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_THREE)))))
        /* SPR 19037 Fix End */
        /*End:Bug 762*/
    /* SPR 19037 Fix End */
    {
        p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
            (p_rrm_ue_context->current_procedure.p_erb_success_list);

        p_cell_context = rrm_cellm_get_cell_context(
                p_rrm_ue_context->cell_index);
        /*cov_fix_65823_start*/
        if (RRM_PNULL == p_cell_context )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
            RRM_UT_TRACE_EXIT();
            return ;
        }
        /*cov_fix_65823_end*/
        /*qci check for existing erab*/
        for( index = RRM_ZERO ; ( index < p_successful_erbs->num_of_list ) && 
                ( index < RRM_MAX_NUM_DRB_PER_UE ) ; index++ )
        {
            qci = p_successful_erbs->erab_item[index].erab_level_qos_params.qci;
            for(qci_count=RRM_ZERO;qci_count < RRM_MAX_QCI; qci_count++)
            {
                if((RRM_TRUE == p_cell_context->epc_info.epc_params.\
                            qos_config_params[qci_count].erb_service_profile.rrc_ul_sch_config_profile.tti_bundling))
                {
                    if(qci == p_cell_context->epc_info.epc_params.\
                            qos_config_params[qci_count].qci)
                    {
                        /* SPR 18640 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "TTI bundling enabled for rab id [%d] and qci [%d] is established",
                                p_successful_erbs->erab_item[index].erab_id ,qci);
                        /* SPR 18640 Fix End */
                        /* This ERAB needs TTI bundling feature */
                        p_rrm_ue_context->support_tti_bundling = RRM_TRUE;
                        p_rrm_ue_context->num_tti_bundling_erb++;
                        break;
                    }
                }
            }
        }

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] FGI bit28 (TTI bundling) is off",
                p_rrm_ue_context->ue_index);
    }
    RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_end */
/******************************************************************************
 *   FUNCTION NAME: rrm_determine_erb_setup_resp_tti_bundling
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                rrm_determine tti_bundling of erb setup resp for a UE
 *
 *   RETURNS    :
 *                none 
 ******************************************************************************/
void
rrm_determine_erb_setup_resp_tti_bundling(
                                       rrm_ue_context_t     *p_rrm_ue_context
                                     ) 
{

    RRM_UT_TRACE_ENTER();

    /*Check for bit28 only if fgi is present*/
    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {
        
        /* SPR 21251 +- */

        /* Klocwork_fix_march_14_start */
        rrm_determine_support_tti_bundling (p_rrm_ue_context);
        /* Klocwork_fix_march_14_end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "[UE:%d] FGI bits not present",
                 p_rrm_ue_context->ue_index);
    }

    RRM_UT_TRACE_EXIT();

}
/*End changes for TTI bundling feature*/
    
rrm_return_et
rrm_rrc_fill_periodic_retx_bsr_timer
( 
  rrc_ul_sch_config_t *p_rrc_ul_sch_config,
  rrm_ue_context_t *p_rrm_ue_context
)
{
    epc_params_t         *p_epc_params = RRM_NULL;
    rrm_ue_erab_setup_item_list_t *p_successful_erbs = RRM_NULL;
    U16                  drb_count = RRM_ZERO;
    U16                  qos_count = RRM_ZERO;
    /* SPR 14029 FIX : code deleted */
    U8                   retx_bsr_timer_new = RRM_ZERO;
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_epc_params = rrm_cellm_get_erb_service_profile(p_rrm_ue_context->cell_index);
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    if ((RRM_NULL != p_epc_params) &&
                         (RRM_NULL != p_successful_erbs))
    {
        /* Coverity_fix_start_62541 */
        for (drb_count = RRM_ZERO; ((drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE ));
                drb_count++)
        {
        /* Coverity_fix_end_62541 */
            for (qos_count = RRM_ZERO;
                    qos_count < p_epc_params->num_valid_qos_profiles; qos_count++)
            {
                if (p_successful_erbs->erab_item[drb_count].
                        erab_level_qos_params.qci ==
                        p_epc_params->qos_config_params[qos_count].qci)
                {
                    /* SPR 14029 FIX : code deleted */
                    /*Get the r9 timer value for the 1st rab*/
                    if (RRM_ZERO == drb_count)
                    {
                    /* SPR 14029 FIX START */
                        retx_bsr_timer_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                rrc_ul_sch_config_profile.retx_bsr_timer);
                    /* SPR 14029 FIX END */
                    }
                    else
                    {
                        /*Minimum value of r9 timer is taken among all QCIs*/
                        /* SPR 14029 FIX START */
                        if ((retx_bsr_timer_new) >
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                 rrc_ul_sch_config_profile.retx_bsr_timer))
                        {
                            retx_bsr_timer_new =
                                p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                rrc_ul_sch_config_profile.retx_bsr_timer;
                        /* SPR 14029 FIX END */
                        }
                    }
                }
            }
        }
        
        /*Value of sr_prohibit_timer_r9 to be send is minimum of all QCIs,
         *admitted or new. Compare current minimum value with the one sent
         *in response to last admitted rab as well.
         */
        /* SPR 9948 fix start */
        if ((RRM_ZERO != p_rrm_ue_context->drb_configured.num_of_list) &&
            (retx_bsr_timer_new > (p_rrm_ue_context->ul_sch_config.retx_bsr_timer_past)))
        {
            retx_bsr_timer_new = p_rrm_ue_context->ul_sch_config.retx_bsr_timer_past;
        }
        /*Update new value in ue context. Replace backup value
         *with the new one on getting successful response from
         *RRC.
         */
        p_rrm_ue_context->ul_sch_config.retx_bsr_timer_present = retx_bsr_timer_new;

        p_rrc_ul_sch_config->retx_bsr_timer = retx_bsr_timer_new; 
        /* SPR 9948 fix end */
            
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                  " p_epc_params or p_successful_erbs is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_return_et
rrm_rrc_fill_periodic_bsr_timer
( 
  rrc_ul_sch_config_t *p_rrc_ul_sch_config,
  rrm_ue_context_t *p_rrm_ue_context
)
{
    epc_params_t         *p_epc_params = RRM_NULL;
    rrm_ue_erab_setup_item_list_t *p_successful_erbs = RRM_NULL;
    U16                  drb_count = RRM_ZERO;
    U16                  qos_count = RRM_ZERO;
    /* SPR 14029 FIX : code deleted */
    U8                   periodic_bsr_timer_new = RRM_ZERO;
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_epc_params = rrm_cellm_get_erb_service_profile(p_rrm_ue_context->cell_index);
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    if ((RRM_NULL != p_epc_params) &&
                         (RRM_NULL != p_successful_erbs))
    {
        /* Coverity_fix_start_62540 */
        for (drb_count = RRM_ZERO; ((drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE));
                drb_count++)
        {
        /* Coverity_fix_end_62540 */
            for (qos_count = RRM_ZERO;
                    qos_count < p_epc_params->num_valid_qos_profiles; qos_count++)
            {
                if (p_successful_erbs->erab_item[drb_count].
                        erab_level_qos_params.qci ==
                        p_epc_params->qos_config_params[qos_count].qci)
                {
                    /* SPR 14029 FIX : code deleted */
                    /*Get the r9 timer value for the 1st rab*/
                    if (RRM_ZERO == drb_count)
                    {
                    /* SPR 14029 FIX START */
                        periodic_bsr_timer_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                rrc_ul_sch_config_profile.periodic_bsr_timer);
                    /* SPR 14029 FIX END */
                    }
                    else
                    {
                        /*Minimum value of r9 timer is taken among all QCIs*/
                    /* SPR 14029 FIX START */
                        if ((periodic_bsr_timer_new) >
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                 rrc_ul_sch_config_profile.periodic_bsr_timer))
                        {
                            periodic_bsr_timer_new =
                                p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                rrc_ul_sch_config_profile.periodic_bsr_timer;
                    /* SPR 14029 FIX END */
                        }
                    }
                }
            }
        }
        p_rrc_ul_sch_config->bitmask |= RRC_UL_SCH_CONFIG_PERIODIC_BSR_TIMER_PRESENT;
        p_rrc_ul_sch_config->periodic_bsr_timer = periodic_bsr_timer_new; 
            
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                  " p_epc_params or p_successful_erbs is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_return_et
rrm_rrc_fill_max_harq_tx
( 
  rrc_ul_sch_config_t *p_rrc_ul_sch_config,
  rrm_ue_context_t *p_rrm_ue_context
)
{
    epc_params_t         *p_epc_params = RRM_NULL;
    rrm_ue_erab_setup_item_list_t *p_successful_erbs = RRM_NULL;
    U16                  drb_count = RRM_ZERO;
    U16                  qos_count = RRM_ZERO;
    /* SPR 14029 FIX : code deleted */
    U8                   max_harq_tx_new = RRM_ZERO;
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_epc_params = rrm_cellm_get_erb_service_profile(p_rrm_ue_context->cell_index);
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    if ((RRM_NULL != p_epc_params) &&
                         (RRM_NULL != p_successful_erbs))
    {
        /* Coverity_fix_start_62539 */
        for (drb_count = RRM_ZERO; ((drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE));
                drb_count++)
        /* Coverity_fix_end_62539 */
        {
            for (qos_count = RRM_ZERO;
                    qos_count < p_epc_params->num_valid_qos_profiles; qos_count++)
            {
                if (p_successful_erbs->erab_item[drb_count].
                        erab_level_qos_params.qci ==
                        p_epc_params->qos_config_params[qos_count].qci)
                {
                    /* SPR 14029 FIX : code deleted */
                    /*Get the r9 timer value for the 1st rab*/
                    if (RRM_ZERO == drb_count)
                    {
                    /* SPR 14029 FIX START */
                        max_harq_tx_new = (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                rrc_ul_sch_config_profile.max_harq_tx);
                    /* SPR 14029 FIX END */
                    }
                    else
                    {
                        /*Minimum value of r9 timer is taken among all QCIs*/
                    /* SPR 14029 FIX START */
                        if ((max_harq_tx_new) >
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                 rrc_ul_sch_config_profile.max_harq_tx))
                        {
                            max_harq_tx_new =
                                p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                rrc_ul_sch_config_profile.max_harq_tx;
                    /* SPR 14029 FIX END */
                        }
                    }
                }
            }
        }
        p_rrc_ul_sch_config->bitmask |= RRC_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT;
        p_rrc_ul_sch_config->max_harq_tx = max_harq_tx_new; 
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                  " p_epc_params or p_successful_erbs is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_ul_sch_config
 *   INPUT      : p_rrm_ue_context,p_ue_service_profile
 *   OUTPUT     : p_rrc_ul_sch_config
 *   DESCRIPTION:
 *                Fills the rrc_ul_sch_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_ul_sch_config(
        rrc_ul_sch_config_t *p_rrc_ul_sch_config,
        rrm_ue_context_t   *p_rrm_ue_context
         /*SPR 17777 +-*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    
    rrm_rrc_fill_max_harq_tx(p_rrc_ul_sch_config,
                              p_rrm_ue_context );
    
    rrm_rrc_fill_periodic_bsr_timer(p_rrc_ul_sch_config,
                                     p_rrm_ue_context );

    rrm_rrc_fill_periodic_retx_bsr_timer(p_rrc_ul_sch_config,
                                     p_rrm_ue_context );

    /*Start changes for TTI bundling feature*/
    rrm_determine_erb_setup_resp_tti_bundling(p_rrm_ue_context);

    if(p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE)
    {
        rrm_fill_tti_bundling(&(p_rrc_ul_sch_config->tti_bundling),
                p_rrm_ue_context);
    }
    else if(p_rrm_ue_context->tti_bundling_enabled)
    {
        p_rrc_ul_sch_config->tti_bundling = RRM_ONE;
    }
    else
    {
        p_rrc_ul_sch_config->tti_bundling = RRM_ZERO;
    }

    if (RRM_ONE == p_rrc_ul_sch_config->tti_bundling)
    {
        p_rrm_ue_context->tti_bundling_enabled = RRM_TRUE;
    }
    /*End changes for TTI bundling feature*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*clock_works_changes_start*/
rrm_return_et
fill_long_drx_cycle_start_offset_lower_range
(
 rrc_long_drx_cycle_start_offset_t     *p_rrc_long_drx_cycle_start_offset,
 rrm_oam_long_drx_cycle_start_offset_et long_drx_cycle,
 U16                                    drx_start_offset
 )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(long_drx_cycle)
    {
        case RRM_OAM_SF10:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_10_PRESENT;

            p_rrc_long_drx_cycle_start_offset->sf_10 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF20:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_20 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF32:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_32_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_32 = 
                drx_start_offset;
            break;
        case RRM_OAM_SF40:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_40 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF64:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_64_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_64 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF80:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_80_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_80 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF128:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_128_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_128 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF160:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_160_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_160 = 
                drx_start_offset;
            break;

        default :
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_return_et
fill_long_drx_cycle_start_offset_higher_range
(
 rrc_long_drx_cycle_start_offset_t     *p_rrc_long_drx_cycle_start_offset,
 rrm_oam_long_drx_cycle_start_offset_et long_drx_cycle,
 U16                                    drx_start_offset
 )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(long_drx_cycle)
    {
        case RRM_OAM_SF256:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_256_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_256 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF320:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_320_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_320 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF512:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_512_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_512 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF640:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_640_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_640 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF1024:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1024_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_1024 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF1280:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1280_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_1280 = 
                drx_start_offset;

            break;
        case RRM_OAM_SF2048:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2048_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_2048 = 
                drx_start_offset;
            break;
        case RRM_OAM_SF2560:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2560_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_2560 = 
                drx_start_offset;

            break;
        default :
            break;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*clock_works_changes_end*/




/* Fix for CSR: 00059124 start */
/******************************************************************************
 *   FUNCTION NAME: file_erb_setup_resp_long_drx_cycle_start_offset
 *   INPUT        : p_drx_config
 *   OUTPUT       : p_rrc_long_drx_cycle_start_offset
 *   DESCRIPTION  :
 *                  Fills the rrc_long_drx_cycle_start_offset_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
file_erb_setup_resp_long_drx_cycle_start_offset
(
    rrc_long_drx_cycle_start_offset_t     *p_rrc_long_drx_cycle_start_offset,
    rrm_oam_long_drx_cycle_start_offset_et long_drx_cycle, 
    U16                                    drx_start_offset
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /*clock_works_changes_start*/
    if(long_drx_cycle<=RRM_OAM_SF160)
    {
        ret_val=fill_long_drx_cycle_start_offset_lower_range(p_rrc_long_drx_cycle_start_offset, long_drx_cycle, drx_start_offset);
    }
    else
    {
        ret_val= fill_long_drx_cycle_start_offset_higher_range(p_rrc_long_drx_cycle_start_offset, long_drx_cycle, drx_start_offset);
    }
    /*clock_works_changes_end*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Fix for CSR: 00059124 end */

#ifdef ENDC_ENABLED
rrm_return_et
fill_long_drx_cycle_start_offset_lower_range_r15
(
    rrc_long_drx_cycle_start_offset_r15_t     *p_rrc_long_drx_cycle_start_offset,
    rrm_oam_long_drx_cycle_start_offset_r15_et long_drx_cycle,
    U16                                        drx_start_offset
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch ( long_drx_cycle )
    {
        case RRM_OAM_R15_SF10:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_10_PRESENT;

            p_rrc_long_drx_cycle_start_offset->sf_10 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF20:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_20 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF32:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_32_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_32 = 
                drx_start_offset;
            break;
        case RRM_OAM_R15_SF40:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_40 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF64:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_64_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_64 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF80:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_80_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_80 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF128:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_128_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_128 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF160:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_160_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_160 = 
                drx_start_offset;
            break;

        case RRM_OAM_R15_SF256:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_256_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_256 = 
                drx_start_offset;
            break;

        default :
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_return_et
fill_long_drx_cycle_start_offset_higher_range_r15
(
    rrc_long_drx_cycle_start_offset_r15_t     *p_rrc_long_drx_cycle_start_offset,
    rrm_oam_long_drx_cycle_start_offset_r15_et long_drx_cycle,
    U16                                        drx_start_offset
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(long_drx_cycle)
    {
        case RRM_OAM_R15_SF320:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_320_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_320 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF512:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_512_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_512 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF640:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_640_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_640 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF1024:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_1024_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_1024 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF1280:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_1280_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_1280 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF2048:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_2048_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_2048 = 
                drx_start_offset;
            break;
        case RRM_OAM_R15_SF2560:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_2560_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_2560 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF5120:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_5120_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_5120 = 
                drx_start_offset;

            break;
        case RRM_OAM_R15_SF10240:
            p_rrc_long_drx_cycle_start_offset->bitmask |= 
                RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_10240_PRESENT;
            p_rrc_long_drx_cycle_start_offset->sf_10240 = 
                drx_start_offset;

            break;
        default :
            break;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: file_erb_setup_resp_long_drx_cycle_start_offset_r15
 *   INPUT        : p_drx_config
 *   OUTPUT       : p_rrc_long_drx_cycle_start_offset
 *   DESCRIPTION  : Fills the rrc_long_drx_cycle_start_offset_r15_t
 *   RETURNS      :
 *                  RRM_SUCCESS  on Success
 *                  RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
file_erb_setup_resp_long_drx_cycle_start_offset_r15
(
    rrc_long_drx_cycle_start_offset_r15_t     *p_rrc_long_drx_cycle_start_offset,
    rrm_oam_long_drx_cycle_start_offset_r15_et long_drx_cycle, 
    U16                                        drx_start_offset
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if ( long_drx_cycle <= RRM_OAM_R15_SF256 )
    {
        ret_val = fill_long_drx_cycle_start_offset_lower_range_r15(
            p_rrc_long_drx_cycle_start_offset, long_drx_cycle, drx_start_offset);
    }
    else
    {
        ret_val = fill_long_drx_cycle_start_offset_higher_range_r15(
            p_rrc_long_drx_cycle_start_offset, long_drx_cycle, drx_start_offset);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
#endif

/******************************************************************************
 *   FUNCTION NAME: file_erb_setup_resp_long_short_drx
 *   INPUT      : p_drx_config
 *   OUTPUT     : p_rrc_short_drx
 *   DESCRIPTION:
 *                Fills the rrc_short_drx_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

/* SPR 10450 Fix Start */
rrm_return_et
file_erb_setup_resp_long_short_drx(
        rrc_short_drx_t *p_rrc_short_drx,
        rrm_cell_drx_res_per_profile_t *p_drx_config
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_short_drx->short_drx_cycle = p_drx_config->short_drx_cycle_config.short_drx_cycle;
    p_rrc_short_drx->short_drx_cycle_timer = 
        p_drx_config->short_drx_cycle_config.drx_short_cycle_timer;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 10450 Fix End */
/* CSR_00053551_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME  : rrm_find_on_duration_timer_value_in_ms
 *   INPUT          : on_duration_timer
 *   OUTPUT         : None
 *   DESCRIPTION    :
 *                    Find On duration timer value in milli second
 *   RETURNS        : U16
 ******************************************************************************/
U16
rrm_find_on_duration_timer_value_in_ms(
rrm_oam_on_duration_timer_et        on_duration_timer
)
{
    U16                 on_duration_timer_value_in_ms = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    switch (on_duration_timer)
    {
        case RRM_OAM_ON_DURATION_TIMER_PSF_1:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_1;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_2:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_2;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_3:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_3;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_4:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_4;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_5:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_5;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_6:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_6;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_8:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_8;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_10:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_10;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_20:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_20;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_30:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_30;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_40:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_40;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_50:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_50;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_60:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_60;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_80:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_80;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_100:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_100;
            break;
        case RRM_OAM_ON_DURATION_TIMER_PSF_200:
            on_duration_timer_value_in_ms = RRM_ON_DURATION_TIMER_PSF_200;
            break;
        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Invalid on_duration_timer[%d] in drx configuration from OAM ", on_duration_timer);

    }
    if (RRM_ZERO != on_duration_timer_value_in_ms)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "on_duration_timer in drx configuration is %d ms ", on_duration_timer_value_in_ms);
    }
    RRM_UT_TRACE_EXIT();

    return on_duration_timer_value_in_ms;
}
/******************************************************************************
 *   FUNCTION NAME  : fill_drx_mac_ce_cmd_trigger_info
 *   INPUT          : p_drx_mac_ce_cmd_trigger_info
 *   OUTPUT         : p_drx_config_param
 *   DESCRIPTION    :
 *                    Fill the rrc_drx_mac_ce_cmd_trigger_info_t
 *   RETURNS        : VOID
 ******************************************************************************/
rrm_void_t
fill_drx_mac_ce_cmd_trigger_info
(
  rrc_drx_config_param_t              *p_drx_config_param,
  rrm_drx_mac_ce_cmd_trigger_info_t   *p_drx_mac_ce_cmd_trigger_info,
/* SPR 10450 Fix Start */
rrm_cell_drx_res_per_profile_t         *p_drx_config,
/* SPR 10450 Fix Start */
  rrm_ue_context_t                    *p_rrm_ue_context
)
{
    U8                                  drb_count = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t       *p_ongoing_successful_erbs = RRM_PNULL;
    rrc_bearer_type_et                  rrm_check_current_bearer_type = BEARER_TYPE_NON_GBR;
    U16                                 on_duration_timer_value_in_ms = RRM_ZERO;
    U16                                 drx_mac_ce_timer_value = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_drx_config_param);
    RRM_ASSERT(RRM_PNULL != p_drx_mac_ce_cmd_trigger_info);
    RRM_ASSERT(RRM_PNULL != p_drx_config);
    RRM_ASSERT(RRM_PNULL != p_rrm_ue_context);

    p_ongoing_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);
    RRM_ASSERT(RRM_PNULL != p_ongoing_successful_erbs);


    if(RRM_TRUE == p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_command_enable)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                "DRX mac ce cmd params configured from OAM are drx_mac_ce_timer_percentage(%d), "
                "drx_mac_ce_cmd_threshold value(%d)",p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer_percentage,\
                p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold);
        /* Coverity_fix_start_55010 */
        for (drb_count = RRM_ZERO; ((drb_count < p_ongoing_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE ));
                drb_count++)
        {
            /* Coverity_fix_end_55010 */
            /* Cheking whether ongoing rabs are non-gbr or gbr */
            if((p_ongoing_successful_erbs->erab_item[drb_count].erab_level_qos_params.qci >= RRM_ONE) &&
                    (p_ongoing_successful_erbs->erab_item[drb_count].erab_level_qos_params.qci <= RRM_FOUR))
            {
                rrm_check_current_bearer_type = BEARER_TYPE_GBR;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "One of the ongoing rab is GBR so drx mac ce cmd params will be not filled.");
                break;
            }
        }
        /* GBR Check is done on Previously existing RABs for this UE */
        if (BEARER_TYPE_NON_GBR == rrm_check_current_bearer_type)
        {
            for (drb_count = RRM_ZERO; drb_count < p_rrm_ue_context->drb_configured.num_of_list;
                    drb_count++)
            {
                /* Cheking whether exiting rabs are non-gbr or gbr */
                if ((p_rrm_ue_context->drb_configured.erab_item[drb_count].erab_level_qos_params.qci >= RRM_ONE)
                        && (p_rrm_ue_context->drb_configured.erab_item[drb_count].erab_level_qos_params.qci <=
                            RRM_FOUR))
                {
                    rrm_check_current_bearer_type = BEARER_TYPE_GBR;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "One of the existing rab is GBR so drx mac ce cmd params will be not filled.");
                    break;
                }
            }
            /* Filling drx_mac_ce_cmd_trigger_info params only if ongoing and exiting rab are non-gbr */
            if (BEARER_TYPE_NON_GBR == rrm_check_current_bearer_type)
            {
                /* Finding On duration timer value in milli second */
                if (RRM_ZERO != (on_duration_timer_value_in_ms = rrm_find_on_duration_timer_value_in_ms(
                                p_drx_config->on_duration_timer)))
                {
                    drx_mac_ce_timer_value = ((on_duration_timer_value_in_ms *
                                p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer_percentage)/RRM_PERCENTAGE);
                    /* SPR 8515 FIX START */
                    if ((drx_mac_ce_timer_value > RRM_TWO) && ((on_duration_timer_value_in_ms -
                                    drx_mac_ce_timer_value) >= p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold))
                    {
                        /* SPR 8515 FIX END */
                        p_drx_config_param->drx_mac_ce_cmd_trigger_info.drx_mac_ce_timer =
                            drx_mac_ce_timer_value;
                        p_drx_config_param->drx_mac_ce_cmd_trigger_info.drx_mac_ce_cmd_threshold =
                            p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold;
                        p_drx_config_param->bitmask |=
                            RRC_DRX_CONFIG_DRX_MAC_CE_CMD_TRIGGER_INFO_PRESENT;
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                "DRX mac ce cmd params to RRC are drx_mac_ce_timer = %d, drx_mac_ce_cmd_threshold = %d",
                                p_drx_config_param->drx_mac_ce_cmd_trigger_info.\
                                drx_mac_ce_timer,p_drx_config_param->drx_mac_ce_cmd_trigger_info.drx_mac_ce_cmd_threshold);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                "DRX mac ce cmd bitmask is not set because either drx_mac_ce_timer_value(%d) is "
                                "less than Lower limit of drx_mac_ce_timer_value(2) or difference between "
                                "on_duration_timer_value and drx_mac_ce_timer_value(%d) is greater than drx_mac_ce_cmd_threshold(%d)",
                                drx_mac_ce_timer_value,
                                (on_duration_timer_value_in_ms - drx_mac_ce_timer_value),
                                p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold);
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                            "DRX mac ce cmd bitmask is not set because on_duration_timer_value_in_ms(%d) is invalid",
                            on_duration_timer_value_in_ms);
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                "DRX_MAC_CE_ENABLE_CMD is [%d] ", p_drx_mac_ce_cmd_trigger_info->drx_mac_ce_command_enable);

    }
    RRM_UT_TRACE_EXIT();
}
/* CSR_00053551_CHANGES_END */           


/*klock_works_changes_start*/
rrm_return_et
check_requested_rab_is_for_decided_sps
(
 rrm_cell_context_t            *p_cell_context,
 rrm_ue_erab_setup_item_list_t *p_successful_erbs,
/* SPR 10450 Fix Start */
 rrm_cell_drx_res_per_profile_t            *p_drx_config,
/* SPR 10450 Fix End */
 rrm_ue_context_t              *p_rrm_ue_context,
 rrc_drx_config_param_t        *p_rrc_drx_config_param
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8            qci_val = RRM_ZERO;
    U8            index   = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if ( (RRM_FALSE != p_cell_context->sps_on) &&
            /*Start:Bug 762*/
            (RRM_TRUE  == (rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_TWENTY_NINE))) &&
            (RRM_TRUE  == (rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_SEVEN))) )
        /*End:Bug 762*/
    {
        /* Coverity_fix_start_55009 */
        for (index = RRM_ZERO; ((index < p_successful_erbs->num_of_list) && (index  < RRM_MAX_NUM_DRB_PER_UE)); index++)
        {
            /* Coverity_fix_end_55009 */
            if ( (p_rrm_ue_context->ue_sps_data.sps_erab_id) ==
                    (p_successful_erbs->erab_item[index].erab_id) )   /* Check whether the requested RAB is the one decided for SPS */
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "DRX parameters being sent for erab_id[%d] of [UE:%d]",
                        p_successful_erbs->erab_item[index].erab_id,  p_rrm_ue_context->ue_index);

                qci_val = p_successful_erbs->erab_item[index].erab_level_qos_params.qci;

                /* SPR 8978 : code removed */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "DRX parameters being filled for RRC_RRM_ERAB_SETUP_RESP of [UE:%d]",
                        p_rrm_ue_context->ue_index);

                fill_reqd_drx_params_for_sps(p_rrc_drx_config_param, p_drx_config, p_cell_context, qci_val);
            }
        }
    }
    /* SPS related changes end */
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/

/******************************************************************************
 *   FUNCTION NAME: file_erb_setup_resp_drx_config_param
 *   INPUT      : p_drx_config,p_rrm_ue_context
 *   OUTPUT     : p_rrc_drx_config_param
 *   DESCRIPTION:
 *                Fills the rrc_drx_config_param_t
 *
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

/* SPR 10450 Fix Start */
rrm_void_t
rrm_find_free_drx_offset_frm_drx_res_tree
(
  drx_res_alloc_tree_per_ue_t *p_drx_res_tree,
  U8                           total_drx_offset,
  U16                         *p_drx_start_offset
)
{
   U8 drx_counter = RRM_ZERO;
   RRM_UT_TRACE_ENTER();

   *p_drx_start_offset = RRM_ZERO;
   for(drx_counter = RRM_ZERO ; drx_counter < total_drx_offset ; drx_counter++)
   {
       if(p_drx_res_tree[drx_counter].res_status == RRM_RES_FREE )
       {
              *p_drx_start_offset = p_drx_res_tree[drx_counter].drx_start_offset;
              p_drx_res_tree[drx_counter].res_status = RRM_RES_BUSY;
              break;
       }
   }

   RRM_UT_TRACE_EXIT();
}

rrm_return_et
/*SPR 16893 changes start*/
fill_erb_setup_resp_drx_config_param(
/*SPR 16893 changes end*/
        rrc_drx_config_param_t *p_rrc_drx_config_param,
        rrm_cell_drx_res_per_profile_t     *p_drx_config,
        rrm_ue_context_t   *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    /* SPS related changes start */
    rrm_cell_context_t               *p_cell_context = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs = RRM_PNULL;
    /* SPS related changes end */
    U16                              drx_start_offset = RRM_ZERO;
   /*SPR 15713 Fix Start*/
    U16 sr_offset = RRM_ZERO;
    U16 cqi_offset = RRM_ZERO;
    rrm_bool_et collision_resolved = RRM_FALSE;
    rrm_ue_sr_paramas_t sr_param_temp = {RRM_ZERO};
    U8            sr_res_index      = INVALID_SR_CFG_INDEX;
    U8            sr_config_index   = INVALID_SR_CFG_INDEX;
    U8            row_num           = INVALID_FRAME;
    U16           col_num           = INVALID_SLOT;
    /* SPR 16893 Fix +- */ 
    U16           meas_gap_offset = RRM_ZERO;
    U16           long_drx_cycle_value = RRM_ZERO;
/* SPR 16893 Fix Start */ 
    rrm_meas_config_info_t *p_cell_meas_config_info = RRM_NULL;
    U8 gap_offset_type = RRM_ZERO;
    rrm_bool_et   sr_change_req = RRM_FALSE;
/* SPR 16893 Fix Stop */ 
    /*SPR 15713 Fix End*/

    RRM_UT_TRACE_ENTER();

    /* SPR 16427 fix start */
    rrm_bool_et is_sr_cqi_collide = RRM_FALSE;
    U8 cqi_periodicity_ms = RRM_ZERO;
    U8 sr_periodicity_ms = RRM_ZERO;
    /* SPR 16427 fix end */

    /* CSR_00053551_CHANGES_START */
    p_rrc_drx_config_param->bitmask = RRM_ZERO;
    /* CSR_00053551_CHANGES_END */
    /* SPR_15313_Fix_Start */
    rrm_cqi_reporting_mode_et rrm_enable_cqi_reporting      = RRM_DISABLE_CQI_REPORTING;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = RRM_PNULL;
    /* SPR_15313_Fix_End */

    /* SPR 16427 fix start */
    /* Get the cell context */
    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /* SPR 16427 fix end */
    /*SPR 22347 Fix Start*/
    U8 gap_value = RRM_ZERO;
    /*SPR 22347 Fix Stop*/
    /*Coverity 65822 Fix Start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*Coverity 65822 Fix End*/

    p_rrc_drx_config_param->on_duration_timer = p_drx_config->on_duration_timer;
    p_rrc_drx_config_param->drx_inactivity_timer = 
        p_drx_config->drx_inactivity_timer;
    p_rrc_drx_config_param->drx_retransmission_timer = 
        p_drx_config->drx_retransmission_timer;

    /* SPR_15313_Fix_Start */
    p_ue_service_profile     = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);
    rrm_enable_cqi_reporting = p_ue_service_profile->radio_res_config.
        physical_config_dedicated.cqi_reporting.
        rrm_cqi_reporting_mode_configured;
    if (RRM_DISABLE_CQI_REPORTING == rrm_enable_cqi_reporting)
    {
    rrm_find_free_drx_offset_frm_drx_res_tree(p_drx_config->drx_res_tree,p_drx_config->total_drx_offset,
                                                   &drx_start_offset);
    }
    else
    {
        /*SPR 15663 start*/
        #ifdef ENDC_ENABLED
        if ( RRM_OAM_R15_SF2560 >=
            p_drx_config->long_drx_cycle_r15 )
        {
            rrm_find_drx_offset_cqi_based(p_rrm_ue_context,p_drx_config->long_drx_cycle,
                    &drx_start_offset,&cqi_offset);
        }
        else
        {
            rrm_find_drx_offset_cqi_based_r15(p_rrm_ue_context,p_drx_config->long_drx_cycle_r15,
                    &drx_start_offset,&cqi_offset);
        }
        #else
        rrm_find_drx_offset_cqi_based(p_rrm_ue_context,p_drx_config->long_drx_cycle,
                &drx_start_offset,&cqi_offset);
        #endif
        /*SPR 15663 end*/

        /* SPR 16427 fix start */
        /* Get the CQI periodicity of the UE */
        rrm_get_cqi_periodicity_in_ms( p_cell_context, &cqi_periodicity_ms);
        /* SPR 16427 fix end */
    }

    /*SPR 15713 Fix Start*/
    #ifdef ENDC_ENABLED
    if ( RRM_OAM_R15_SF2560 >=
        p_drx_config->long_drx_cycle_r15 )
    {
        long_drx_cycle_value = rrm_convert_drx_sf_in_ms(p_drx_config->long_drx_cycle);
    }
    else
    {
        long_drx_cycle_value = rrm_convert_drx_sf_in_ms_r15(p_drx_config->long_drx_cycle_r15);
    }
    #else
    long_drx_cycle_value = rrm_convert_drx_sf_in_ms(p_drx_config->long_drx_cycle);
    #endif
    RRM_MEMCPY(&sr_param_temp, &(p_rrm_ue_context->sr_params), sizeof(rrm_ue_sr_paramas_t));
    sr_config_index = p_rrm_ue_context->sr_params.sr_configuration_index;
    row_num = p_rrm_ue_context->sr_params.sr_res_row;
    col_num = p_rrm_ue_context->sr_params.sr_res_col;
    sr_res_index = p_rrm_ue_context->sr_params.sr_pucch_res_index;
    /* SPR 16893 Fix Start */ 
    p_cell_meas_config_info = (rrm_meas_config_info_t*)rrm_cellm_get_meas_config_info(p_rrm_ue_context->cell_index);
    gap_offset_type = p_cell_meas_config_info->meas_gap_config.eutran_gap_offset_type;
    if (RRM_MEAS_GAP_TYPE_0 == gap_offset_type)
    {
        meas_gap_offset = (drx_start_offset + long_drx_cycle_value - RRM_SIX ) % RRM_MEAS_GP0_PERIODICITY;
        /*SPR 22347 Fix Start*/
        gap_value = RRM_MEAS_GP0_PERIODICITY;
        /*SPR 22347 Fix Stop*/
    }
    else
    {
        meas_gap_offset = (drx_start_offset + long_drx_cycle_value - RRM_SIX ) % RRM_MEAS_GP1_PERIODICITY;
        /*SPR 22347 Fix Start*/
        gap_value = RRM_MEAS_GP1_PERIODICITY;
        /*SPR 22347 Fix Stop*/
    }
    /* Coverity_fix_94894_start */
    p_rrm_ue_context->meas_gap_offset = meas_gap_offset;
    /* Coverity_fix_94894_end */
    /* SPR 16893 Fix Stop */ 

    do
    {
        rrm_calculate_sr_offset(p_rrm_ue_context->cell_index,&sr_offset,sr_config_index);
        /*Coverity 116215 Fix Start*/
        rrm_get_sr_periodicity_in_ms( p_cell_context, &sr_periodicity_ms );
        /*Coverity 116215 Fix Stop*/
        /* SPR 16427 fix start */
        if (RRM_DISABLE_CQI_REPORTING != rrm_enable_cqi_reporting)
        {
            is_sr_cqi_collide = rrm_is_sr_cqi_collide(sr_offset, sr_periodicity_ms, cqi_offset,
                    cqi_periodicity_ms);
        }
        /* SPR 16427 fix end */
        /* SPR 16893 Fix Start */ 
        /* Code removed */
        /*SPR 22347 Fix Start*/
        sr_change_req = rrm_is_sr_measgap_collide(sr_offset,
                sr_periodicity_ms,
                meas_gap_offset,
                gap_value);
        /*SPR 22347 Fix Stop*/

        if((RRM_FALSE == is_sr_cqi_collide) &&
                (RRM_FALSE == sr_change_req))
            /* SPR 16427 fix end */
        {
        /* SPR 16893 Fix Stop */ 
            /*No need to change the sr_config_index of UE*/
            /*Cov_fix_86441*/
            /*Cov_fix_86441*/
            /*Need to free resources for which
             * mark_sr_as_free is TRUE*/
            /*SPR 16893 Fix start*/
            collision_resolved = RRM_TRUE;
            /*SPR 16893 Fix Stop*/
            rrm_ue_rac_release_sr_res_index(p_rrm_ue_context);
            /*SPR 15713 Fix Start*/
            rrm_cell_mark_sr_index_busy(p_rrm_ue_context->cell_index,row_num,col_num,RRM_FALSE);
            /*SPR 15713 Fix End*/
            p_rrm_ue_context->sr_params.sr_pucch_res_index     = sr_res_index;
            p_rrm_ue_context->sr_params.sr_configuration_index = sr_config_index;
            p_rrm_ue_context->sr_params.sr_res_row             = row_num;
            p_rrm_ue_context->sr_params.sr_res_col             = col_num;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "sr_res_index(%d), sr_config_index(%d), row_num(%d), col_num(%d), meas_gap_offset(%d)",
                    sr_res_index,sr_config_index, row_num, col_num,meas_gap_offset);
            break;
        }
        else
        {
            /*Need to select new sr_config_index
             * for UE */

            ret_val = rrm_cellm_get_sr_resources(p_rrm_ue_context->cell_index,
                    &sr_res_index, &sr_config_index,
                    &row_num, &col_num, RRM_TRUE);
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "sr_res_index(%d), sr_config_index(%d), row_num(%d), col_num(%d),meas_gap_offset(%d)",
                    sr_res_index,sr_config_index, row_num, col_num,meas_gap_offset);

        }
    /*Cov_fix_86423*/
            /*SPR 16893 Fix start*/
    }while (collision_resolved == RRM_FALSE);      /* coverity_fix 86423 +- */
            /*SPR 16893 Fix end*/
    /*Cov_fix_86423*/
     /*SPR 15713 Fix End*/

    /* SPR_15313_Fix_End */
    p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_offset_val = drx_start_offset;
    p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_long_drx_cycle = p_drx_config->long_drx_cycle;

    #ifdef ENDC_ENABLED
    p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_long_drx_cycle_r15 = p_drx_config->long_drx_cycle_r15;
    #endif
                 

    RRM_MEMCPY(&(p_rrm_ue_context->ue_phy_config_information.ue_backup_applied_drx_config),
               &(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config),
               sizeof(rrm_ue_applied_drx_config_t));

    file_erb_setup_resp_long_drx_cycle_start_offset
        (&(p_rrc_drx_config_param->long_drx_cycle_start_offset),
         p_drx_config->long_drx_cycle, 
         drx_start_offset);
         
#ifdef ENDC_ENABLED
    if ( p_drx_config->bitmask & RRMCM_LONG_DRX_CYCLE_R15_PRESENT )
    {
        file_erb_setup_resp_long_drx_cycle_start_offset_r15
            (&(p_rrc_drx_config_param->long_drx_cycle_start_offset_r15),
             p_drx_config->long_drx_cycle_r15, 
             drx_start_offset);
        p_rrc_drx_config_param->bitmask |= RRC_DRX_CONFIG_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
     //   p_rrm_ue_context->is_drx_configured = RRM_TRUE;
        RRM_MEMCPY(&p_rrm_ue_context->long_drx_cycle_start_offset_r15,
                &p_rrc_drx_config_param->long_drx_cycle_start_offset_r15,
                sizeof(rrc_long_drx_cycle_start_offset_r15_t));
    }
#endif

    

    /* SPS related changes start */
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
            (p_rrm_ue_context->current_procedure.p_erb_success_list);
    /* SPR 16427 fix start */
    /*Code removed*/
    /* SPR 16427 fix end */
    /*CID 65822:start*/
    if (RRM_PNULL != p_cell_context )
    {
        // SPS configuration will be sent if the 29th bit of FGI is set to 1
        /* SPS related changes end */
        /*DRX parameters will be given if bit 4 of
          feature group indicator is set as one*/


        if(p_rrm_ue_context->ue_capability_params.
                rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.bitmask &
                RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d] Feature Group Indicator present, "
                    "checking for bit4"
                    ,p_rrm_ue_context->ue_index);
            /*Check for bit4 only if fgi is present*/
            /*Start:Bug 762*/
            if((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FOUR)) == RRM_TRUE)
                /*End:Bug 762*/
            {
                if(p_drx_config->bitmask & RRMCM_SHORT_DRX_CONFIG_PRESENT)
                {
                    p_rrc_drx_config_param->bitmask |= RRC_DRX_CONFIG_SHORT_DRX_PRESENT;
                    file_erb_setup_resp_long_short_drx
                        (&(p_rrc_drx_config_param->short_drx),p_drx_config);
                    #ifdef ENDC_ENABLED
                    p_rrm_ue_context->is_short_drx_configured = RRM_TRUE;
                    RRM_MEMCPY(&p_rrm_ue_context->short_drx,
                        &p_rrc_drx_config_param->short_drx,
                        sizeof(rrc_short_drx_t));
                    #endif
                }
            }

            /* SPS related changes start */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Checking for sps provision of [UE:%d]",
                    p_rrm_ue_context->ue_index);

            /*klock_works_changes_start*/

            check_requested_rab_is_for_decided_sps(p_cell_context, p_successful_erbs, p_drx_config, p_rrm_ue_context, p_rrc_drx_config_param);

            /*klock_works_changes_end*/

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                    "[UE:%d] Feature Group Indicator not present, "
                    "not checking for bit4"
                    ,p_rrm_ue_context->ue_index);
            /*No need to check bit4 if fgi bit is not present*/
            if(p_drx_config->bitmask & RRMCM_SHORT_DRX_CONFIG_PRESENT)
            {
                p_rrc_drx_config_param->bitmask |= RRC_DRX_CONFIG_SHORT_DRX_PRESENT;
                file_erb_setup_resp_long_short_drx
                    (&(p_rrc_drx_config_param->short_drx),p_drx_config);
#ifdef ENDC_ENABLED
                p_rrm_ue_context->is_short_drx_configured = RRM_TRUE;
                RRM_MEMCPY(&p_rrm_ue_context->short_drx,
                        &p_rrc_drx_config_param->short_drx,
                        sizeof(rrc_short_drx_t));
#endif
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65822:end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 10450 Fix End */

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_time_alignment_timer
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_time_alignment_timer_dedicated
 *   DESCRIPTION:
 *                filling for time_alignment_timer of erb setup resp
 *   RETURNS    :
 *                 none 
 ******************************************************************************/

void
fill_erb_setup_resp_time_alignment_timer(
                                           U8* p_time_alignment_timer_dedicated,
                                           rrm_ue_context_t *p_rrm_ue_context
                                           
                                        )
{
   rrm_cell_index_t cell_index;
   RRM_UT_TRACE_ENTER();
   cell_index = p_rrm_ue_context->cell_index;
   *p_time_alignment_timer_dedicated = rrm_cellm_get_time_alignment_timer(cell_index) ;
   RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_mac_main_config
 *   INPUT      : p_mac_layer_params,p_rrm_ue_context,applicable_drx_index
 *                p_ue_service_profile
 *   OUTPUT     : p_rrc_mac_main_config
 *   DESCRIPTION:
 *                Fills the rrc_mac_main_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_mac_main_config(
        rrc_mac_main_config_t *p_rrc_mac_main_config,
        mac_layer_params_t *p_mac_layer_params,
        rrm_ue_context_t   *p_rrm_ue_context,
        U8                 applicable_drx_index,
/* SPR 10450 Fix Start */
        rrc_rrm_ue_service_profile_t    *p_ue_service_profile,
        rrm_cell_drx_config_resources_t  *p_cell_drx_config_res
/* SPR 10450 Fix End */
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_drx_config_type_et          drx_config_type_enum;
    /*SPR 15713 Fix Start*/
    rrm_meas_config_info_t *p_cell_meas_config_info =RRM_NULL;
    U8 gap_offset_type = RRM_ZERO;
    /*SPR 15713 Fix End*/
    RRM_UT_TRACE_ENTER();

    p_rrc_mac_main_config->bitmask |= RRC_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT;
    fill_erb_setup_resp_ul_sch_config
        (&(p_rrc_mac_main_config->ul_sch_config),p_rrm_ue_context);
         /*SPR 17777 +-*/

    /*SPR 15713 Fix Start*/
    if((p_mac_layer_params->mac_layer_param_drx.drx_enabled == RRM_TRUE)&&
            (RRM_UE_CDRX_DISABLED == p_rrm_ue_context->cdrx_status) &&
            (applicable_drx_index != NO_DRX_PROFILE))
        /*SPR 15713 Fix End*/
    {
        /* If CDRX is applied, DRX will be applied by ANR upon receipt pending PCI/CGI reports */
        if(RRM_UE_CDRX_DISABLED == p_rrm_ue_context->cdrx_status)
        {
            if(applicable_drx_index != NO_DRX_PROFILE)
            {
                #ifdef ENDC_ENABLED
                p_rrm_ue_context->is_drx_configured = RRM_TRUE;
                #endif
                p_rrc_mac_main_config->bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;
                drx_config_type_enum = RRC_DRX_CONFIG_TYPE_SETUP;
                p_rrc_mac_main_config->drx_config.drx_config_type =
                    drx_config_type_enum;
                p_rrc_mac_main_config->drx_config.bitmask |=
                    RRC_DRX_CONFIG_PARAM_PRESENT; 
                /* SPR 10450 Fix Start */
                /*SPR 16893 changes start*/
                fill_erb_setup_resp_drx_config_param
                /*SPR 16893 changes end*/
                    (&(p_rrc_mac_main_config->drx_config.drx_config_param),
                     &(p_cell_drx_config_res->drx_res_arr[applicable_drx_index]),p_rrm_ue_context);

                /* SPR 10450 Fix End */

                /* CSR_00053551_CHANGES_START */
                /* Fill function of drx_mac_ce_cmd_trigger_info params */
                fill_drx_mac_ce_cmd_trigger_info(
                        &(p_rrc_mac_main_config->drx_config.drx_config_param),
                        &(p_mac_layer_params->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info),
                        /* SPR 10450 Fix Start */
                        &(p_cell_drx_config_res->drx_res_arr[applicable_drx_index]),
                        /* SPR 10450 Fix End */
                        p_rrm_ue_context);
                /* CSR_00053551_CHANGES_END */
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "[UE:%d],drx is already applied for the ue not applying again",
                        p_rrm_ue_context->ue_index);
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "CDRX is applied. CDRX status = %d", p_rrm_ue_context->cdrx_status);		
        }
    }
    else
    {
        /*SPR 15713 Fix Start*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[UE:%d],Either DRX is false[%d] or cdrx_status[%d] or no applicable drx profile[%d]",
                p_rrm_ue_context->ue_index,p_mac_layer_params->mac_layer_param_drx.drx_enabled,
                p_rrm_ue_context->cdrx_status,applicable_drx_index);
        /*SPR 15713 Fix:End*/
       #ifdef ENDC_ENABLED
       p_rrm_ue_context->is_drx_configured = RRM_FALSE;
       #endif

       /*SPR_16942_START*/
        if ((p_mac_layer_params->mac_layer_param_drx.drx_enabled == RRM_FALSE) ||
                (NO_DRX_PROFILE == p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index))
        {
            p_rrc_mac_main_config->bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;
            /*SPR_16942_END*/

      // p_rrc_mac_main_config->bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;
       #ifdef ENDC_ENABLED
       p_rrm_ue_context->is_drx_configured = RRM_FALSE;
       #endif

       drx_config_type_enum = RRC_DRX_CONFIG_TYPE_REL;
       p_rrc_mac_main_config->drx_config.drx_config_type = drx_config_type_enum;
        /*SPR 15713 Fix Start*/
        p_cell_meas_config_info = (rrm_meas_config_info_t*)rrm_cellm_get_meas_config_info(p_rrm_ue_context->cell_index);
        if(p_cell_meas_config_info->bitmask & RRMCM_RMIF_MEAS_GAP_CONFIG_PRESENT &&
                (p_rrm_ue_context->meas_gap_config.meas_gap_added & MEAS_GAP_ADDED_FOR_PRS) == RRM_FALSE)
        {
            gap_offset_type = p_cell_meas_config_info->meas_gap_config.eutran_gap_offset_type;
            if (RRM_MEAS_GAP_TYPE_0 == gap_offset_type)
            {
                p_rrm_ue_context->meas_gap_offset= rrm_ue_assign_gap_offset(
                        p_rrm_ue_context, RRM_MEAS_GAP_TYPE_0);
            }
            else if  (RRM_MEAS_GAP_TYPE_1 == gap_offset_type)
            {

                p_rrm_ue_context->meas_gap_offset = rrm_ue_assign_gap_offset(
                        p_rrm_ue_context, RRM_MEAS_GAP_TYPE_1);
            }
        }
        /*SPR 15713 Fix End*/
	/*SPR_16942_START*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "DRX profile applied index[%d]",
                    p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index);
        }
        /*CSR 102888:End*/
    /*SPR_16942_END*/

    }
    /*SPR_16942_START*/
    if((p_ue_service_profile->radio_res_config.mac_config.mac_main_config.bitmask &
                RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT) &&
            (p_ue_service_profile->radio_res_config.mac_config.mac_main_config.phr_config.bitmask &
             RRC_SERVICE_PROFILE_PHR_CONFIG_PARAM_PRESENT))
    /*SPR_16942_END*/
    {
        p_rrc_mac_main_config->bitmask |=
            RRC_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT;
        rrm_rrc_erb_setup_resp_fill_phr_config
           (&(p_rrc_mac_main_config->phr_config),
             p_rrm_ue_context);
    }
    fill_erb_setup_resp_time_alignment_timer(
            &(p_rrc_mac_main_config->time_alignment_timer_dedicated),
             p_rrm_ue_context);
   
    /* SPR 13647 changes start */  
    if((p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) && (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release > 0)) 
    { 
        fill_sr_prohibit_timer_r9(p_rrc_mac_main_config,
                p_rrm_ue_context);
    }
    /*SPR 13647 changes end */

    /* SPR 21958 PUSCH RAT1 Support Start */
    /* Check if eNB and UE both supports the uplink RAT1 resource allocation */
    if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        if((RRM_TRUE == p_mac_layer_params->is_uplink_rat1_supported) &&
                (RRM_TRUE == rrm_check_is_ue_support_uplink_rat1(p_rrm_ue_context)))
        { 
            p_rrc_mac_main_config->is_uplink_rat1_supported = RRM_TRUE;
            p_rrc_mac_main_config->bitmask |= 
                RRC_MAC_MAIN_CONFIG_UPLINK_RAT1_SUPPORT_INFO_PRESENT;
        }
        else
        {
			/* In case RAT 1 support is disabled from operator or UE is not capable for RAT 1 support
			 * or both ,setting is_uplink_rat1_supported as false */
           p_rrc_mac_main_config->is_uplink_rat1_supported = RRM_FALSE;
			/* SPR 22531 Fix Start */
			/* mac main config bitmask was wrongly reset leading to other IEs not configured
			 * so removed the reset statement */
			/* SPR 22531 Fix End */
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					" Either Uplink RAT1 policy is not enabled at eNB or UE doesnt Support or both");
        }
    }
    else
    {
		/* resetting is_uplink_rat1_supported in case eutra radio capability is absent */
        p_rrc_mac_main_config->is_uplink_rat1_supported = RRM_FALSE;
		/* SPR 22531 Fix Start */
		/* mac main config bitmask was wrongly reset leading to other IEs not configured
		 * so removed the reset statement */
		/* SPR 22531 Fix End */
    }
    /* SPR 21958 PUSCH RAT1 Support End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_mac_main_config_extensions
 *   INPUT      : ul_mcs,dl_mcs,p_rrm_ue_context,p_ue_service_profile
 *   OUTPUT     : p_rrm_mac_main_config_extensions
 *   DESCRIPTION:
 *                Fills the rrm_mac_main_config_extensions_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_mac_main_config_extensions(
        rrm_mac_main_config_extensions_t *p_rrm_mac_main_config_extensions,
        U8                 ul_mcs,
        U8                 dl_mcs,
        rrm_ue_context_t   *p_rrm_ue_context,
        rrc_rrm_ue_service_profile_t    *p_ue_service_profile
        )
{
    rrm_cell_index_t                cell_index = p_rrm_ue_context->cell_index;
    U8                              dl_bandwidth;
    U8                              num_of_layer= RRM_ZERO; /* Kshitij Coverity CID 16593 */
    rrmc_mac_config_t               *p_rrmc_mac_config = RRM_PNULL;
    rrm_cell_context_t              *p_cell_ctx = RRM_PNULL;
    rrm_icic_scheme_type_et          icic_scheme_type = ICIC_SCHEME_NONE;/* coverity fix */ 

    RRM_UT_TRACE_ENTER();
    p_cell_ctx = rrm_cellm_get_cell_context(cell_index);
    /*cov_fix_65820_start*/
    if (RRM_PNULL == p_cell_ctx )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*cov_fix_65820_end*/
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(cell_index); 
    p_rrm_mac_main_config_extensions->ue_priority = MAC_UE_PRIORITY;
    p_rrm_mac_main_config_extensions->dl_num_harq_process = 
        p_rrmc_mac_config->dl_num_harq_process;

    if(rrm_cellm_get_rrmc_band_width(cell_index,&dl_bandwidth) == RRM_SUCCESS)
    {
        p_rrm_mac_main_config_extensions->dl_max_rb = dl_bandwidth;
    }

    if(p_ue_service_profile->radio_res_config.mac_config.
            mac_main_config.ul_sch_config.bitmask &
            RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT)
    {
        p_rrm_mac_main_config_extensions->max_ul_harq_tx = p_ue_service_profile->radio_res_config.
            mac_config.mac_main_config.ul_sch_config.max_ul_harq_tx;
    }


    /* num of layer is selection should done after transmission mode selection
       as this algo has transmission mode input param. if current tx mode is not updated
       so it will be using the last stored tx mode  */
    if ( RRM_SUCCESS == rrm_select_num_of_layer_for_ue( p_rrm_ue_context,
                &num_of_layer) )
    {
        /* filling the number of layer configuration */
        p_rrm_mac_main_config_extensions->num_of_layer = num_of_layer;
    }
    p_rrm_mac_main_config_extensions->code_book_index = CODE_BOOK_INDEX;
    p_rrm_mac_main_config_extensions->dl_i_mcs = dl_mcs;
    p_rrm_mac_main_config_extensions->ul_i_mcs = ul_mcs;   
    p_rrm_mac_main_config_extensions->bitmask = 
        RRM_MAC_MAIN_CONFIG_EXT_PC_MAX_PRESENT;
    fill_pc_max(&(p_rrm_mac_main_config_extensions->pc_max),
            p_rrm_ue_context); 
    /* DYNAMIC_ICIC_CHANGES_START */
    /* coverity fix : assigning the icic scheme type in relevant enum variable*/
    icic_scheme_type = rrm_cellm_get_icic_scheme_configured_in_cell(cell_index); 
    if ( ICIC_SCHEME_SFR  == icic_scheme_type )
    {
        p_rrm_mac_main_config_extensions->bitmask |=  
            RRM_MAC_MAIN_CONFIG_EXT_MIN_UE_POWER_PRESENT;
        p_rrm_mac_main_config_extensions->min_ue_power = p_cell_ctx->rrm_olpc_config_params.min_ue_power;    
    }
    /* DYNAMIC_ICIC_CHANGES_END */
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS; /*coverity : rrm_return_et ret_val not used any where, so returning RRM_SUCCESS */ 
}

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_mac_config
 *   INPUT      : p_mac_layer_params,p_rrm_ue_context,ul_mcs,dl_mcs,
                  applicable_drx_index
 *   OUTPUT     : p_rrm_mac_config
 *   DESCRIPTION:
 *                Fills the rrm_mac_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_mac_config(
        rrm_mac_config_t   *p_rrm_mac_config,
        mac_layer_params_t *p_mac_layer_params,
        rrm_ue_context_t   *p_rrm_ue_context,
        U8                 ul_mcs,
        U8                 dl_mcs,
        U8                applicable_drx_index
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = NULL;
    rrm_cell_index_t                cell_index;
rrm_icic_scheme_type_et          icic_scheme_type = ICIC_SCHEME_NONE;

    /* SPR 10450 Fix Start */
    rrm_cell_drx_config_resources_t *p_cell_drx_config_res = RRM_PNULL;
    /* SPR 10450 Fix Start */
    
    RRM_UT_TRACE_ENTER();
    cell_index = p_rrm_ue_context->cell_index;
    p_ue_service_profile = rrm_cellm_get_ue_service_profile(cell_index);
    /* SPR 10450 Fix Start */
    p_cell_drx_config_res = rrm_cellm_get_drx_config_resource(cell_index);
    p_rrm_mac_config->bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;
    fill_erb_setup_resp_mac_main_config
        (&(p_rrm_mac_config->mac_main_config),p_mac_layer_params,
         p_rrm_ue_context,applicable_drx_index,p_ue_service_profile,p_cell_drx_config_res);
    /* SPR 10450 Fix End */

    /* SPR_14372_start */
    p_ue_service_profile->radio_res_config.mac_config.mac_main_config.ul_sch_config.max_ul_harq_tx =
        p_rrm_mac_config->mac_main_config.ul_sch_config.max_harq_tx;
    /* SPR_14372_stop */
    fill_erb_setup_resp_mac_main_config_extensions
        (&(p_rrm_mac_config->mac_main_config_extensions),
         ul_mcs,dl_mcs,p_rrm_ue_context,p_ue_service_profile);
    /* Start fix for bug 8381 */
    /* DYNAMIC_ICIC_CHANGES_START */
	icic_scheme_type = rrm_cellm_get_icic_scheme_configured_in_cell(cell_index);
    if( (ICIC_SCHEME_SFR  == icic_scheme_type ) ||
	     (ICIC_SCHEME_FFR  == icic_scheme_type))
	{
	   p_rrm_mac_config->mac_main_config_extensions.bitmask |=
                  RRM_MAC_MAIN_CONFIG_EXT_USER_LOCATION_TYPE_PRESENT;
       p_rrm_mac_config->mac_main_config_extensions.user_location_type =
                  p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position;
	}
    /* DYNAMIC_ICIC_CHANGES_END */
    /* End fix for bug 8381 */

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*SPR 17370 START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_check_for_common_cause_in_failed_list
 *   INPUT      : p_failed_erbs
 *   DESCRIPTION: check the common cause in failed list
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_check_for_common_cause_in_failed_list(
        rrm_ue_erab_failed_item_list_t    *p_failed_erbs
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U16                             failed_count =  RRM_ZERO;
    U8                              type = RRM_ZERO; 
    U16                             value = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    type  = p_failed_erbs->erab_to_be_release_item[RRM_ZERO].cause.type;
    value = p_failed_erbs->erab_to_be_release_item[RRM_ZERO].cause.value;
    for ( failed_count = RRM_ZERO ; 
            failed_count < p_failed_erbs->num_of_list; failed_count++ )
    {
        if((p_failed_erbs->erab_to_be_release_item[failed_count].cause.type != type)||
                (p_failed_erbs->erab_to_be_release_item[failed_count].cause.value != value))
        {
            ret_val = RRM_FAILURE; 
            break;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 17370 END*/

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_drb_failed_to_add_list
 *   INPUT      : p_failed_erbs
 *   OUTPUT     : p_rrm_drb_failed_to_add_info_list
 *   DESCRIPTION:
 *                Fills the rrm_drb_failed_to_add_info_list_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_drb_failed_to_add_list(
        rrm_drb_failed_to_add_info_list_t *p_rrm_drb_failed_to_add_info_list,
        rrm_ue_erab_failed_item_list_t    *p_failed_erbs
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U16                             drb_failed_count;

    RRM_UT_TRACE_ENTER();
    for ( drb_failed_count = 0 ; 
            drb_failed_count < p_failed_erbs->num_of_list; drb_failed_count++ )
    {
        p_rrm_drb_failed_to_add_info_list->drb_failed_to_add[drb_failed_count].
            erab_id = p_failed_erbs->erab_to_be_release_item[drb_failed_count].
            erab_id;	                   
        p_rrm_drb_failed_to_add_info_list->drb_failed_to_add[drb_failed_count].
            cause.type = 
            p_failed_erbs->erab_to_be_release_item[drb_failed_count].cause.type;
        p_rrm_drb_failed_to_add_info_list->drb_failed_to_add[drb_failed_count].
            cause.value = 
            p_failed_erbs->erab_to_be_release_item[drb_failed_count].cause.
            value;
    }
    p_rrm_drb_failed_to_add_info_list->count = p_failed_erbs->num_of_list;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_find_drx_profile_to_send
 *   INPUT      : p_rrm_ue_context,p_mac_layer_params
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                Decides the drx profile to be sent 
 *   RETURNS    :
 *                Drx profile index
 *****************************************************************************/
/* SPR 10450 Fix Start */
U8
rrm_find_drx_profile_to_send(
        rrm_ue_context_t *p_rrm_ue_context
        )
{
    rrm_ue_erab_setup_item_list_t       *p_successful_erbs = RRM_PNULL;
    U32                                 drb_count = RRM_ZERO;
    /*CID 65763:start*/
    U8                                 drx_profile_index = RRM_ZERO;
    /*CID 65763:end*/

    #ifdef ENDC_ENABLED
    rrm_oam_long_drx_cycle_start_offset_r15_et
        least_long_drx_cycle;
    /**Initialize least long drx cycle as the highest value*/
    least_long_drx_cycle = RRM_OAM_R15_SF10240;
    #else
    rrm_oam_long_drx_cycle_start_offset_et
        least_long_drx_cycle;
    /**Initialize least long drx cycle as the highest value*/
    least_long_drx_cycle = RRM_OAM_SF2560;
    #endif

    U8                                 applicable_drx_index = NO_DRX_PROFILE;
    rrm_cell_drx_config_resources_t *p_cell_drx_config_res = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_cell_drx_config_res = rrm_cellm_get_drx_config_resource(p_rrm_ue_context->cell_index); 
    /*Cov_fix_start_55005_55015_65132_55012*/
    if(RRM_PNULL != p_rrm_ue_context->current_procedure.p_erb_success_list)
    {
        p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
            (p_rrm_ue_context->current_procedure.p_erb_success_list);

    if(p_successful_erbs->num_of_list >= RRM_MAX_NUM_DRB_PER_UE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                  "For [UE:%d],successful ERBS list count is [%d]",p_rrm_ue_context->ue_index,p_successful_erbs->num_of_list);
         p_successful_erbs->num_of_list = RRM_MAX_NUM_DRB_PER_UE - RRM_ONE;
    }
    for (drb_count = RRM_NULL ; drb_count < p_successful_erbs->num_of_list ;
            drb_count++)
    {
            drx_profile_index = p_successful_erbs->erab_item[drb_count].erab_level_qos_params.qci - RRM_ONE;
            /*klok_fix_start_8535*/
            /*CID 65763:start*/
            if (( drx_profile_index < RRM_OAM_MAX_NUM_QCI_CLASSES ) 
                  && (RRM_TRUE == p_cell_drx_config_res->drx_res_arr[drx_profile_index].drx_enabled ))
            /*CID 65763:end*/
            {
            /*klok_fix_end_8535*/   
                #ifdef ENDC_ENABLED
                if( p_cell_drx_config_res->drx_res_arr[drx_profile_index].long_drx_cycle_r15
                        <= least_long_drx_cycle )
                {
                    least_long_drx_cycle =
                        p_cell_drx_config_res->drx_res_arr[drx_profile_index].long_drx_cycle_r15;
                    applicable_drx_index = drx_profile_index;
                }
                #else 
                if( p_cell_drx_config_res->drx_res_arr[drx_profile_index].long_drx_cycle
                        <= least_long_drx_cycle )
                {
                    least_long_drx_cycle =
                        p_cell_drx_config_res->drx_res_arr[drx_profile_index].long_drx_cycle;
                    applicable_drx_index = drx_profile_index;
                }
                #endif
            }
        }

        /*Cov_fix_start_65131*/
        if( (NO_DRX_PROFILE != applicable_drx_index) && (applicable_drx_index < RRM_OAM_MAX_NUM_QCI_CLASSES))
        {
    /**If no drx profile is given, apply the latest drx profile*/
            if(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index == NO_DRX_PROFILE)
            {
                p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index = applicable_drx_index;

    }
    /**If drx cycle of drx profile already applied is less,
      do no send any drx profile*/
            #ifdef ENDC_ENABLED
            else if( ( p_cell_drx_config_res->
                        drx_res_arr[p_rrm_ue_context->
                        applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].long_drx_cycle_r15 <= 
                        p_cell_drx_config_res->drx_res_arr[applicable_drx_index].long_drx_cycle_r15))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                        "Last applied DRX profile [%d] is already having the least Long Drx Cycle.",
                        p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index );
        applicable_drx_index = NO_DRX_PROFILE;
    }
    /**If drx cycle of drx profile already applied is not less,
      send latest drx profile*/
            else if(p_cell_drx_config_res->
                    drx_res_arr[p_rrm_ue_context->
                    applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].long_drx_cycle_r15 > 
                    p_cell_drx_config_res->drx_res_arr[applicable_drx_index].long_drx_cycle_r15)
            {
                p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index = applicable_drx_index;
            }
            #else
            else if( ( p_cell_drx_config_res->
                        drx_res_arr[p_rrm_ue_context->
                        applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].long_drx_cycle <= 
                        p_cell_drx_config_res->drx_res_arr[applicable_drx_index].long_drx_cycle))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                        "Last applied DRX profile [%d] is already having the least Long Drx Cycle.",
                        p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index );
        applicable_drx_index = NO_DRX_PROFILE;
    }
    /**If drx cycle of drx profile already applied is not less,
      send latest drx profile*/
            else if(p_cell_drx_config_res->
                    drx_res_arr[p_rrm_ue_context->
                    applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].long_drx_cycle > 
                    p_cell_drx_config_res->drx_res_arr[applicable_drx_index].long_drx_cycle)
            {
                p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index = applicable_drx_index;
            }
            #endif

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "Chosen DRX profile index is [%d]",applicable_drx_index);
        }
        /*Cov_fix_end_65131*/
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "No DRX profile is chosen ");

        }
    }
    else 
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "p_erb_success_list is empty");
    }
    /*Cov_fix_end_55005_55015_65132_55012*/
     RRM_UT_TRACE_EXIT();
         return applicable_drx_index;
}
/* SPR 10450 Fix End */
/******************************************************************************
 *   FUNCTION NAME: rrm_return_start_tpc_rnti_pusch
 *   INPUT      : p_cell_index
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                returns start tpc rnti pusch
 *   RETURNS    :
 *                returns start tpc rnti pusch
 *****************************************************************************/
U16
rrm_return_start_tpc_rnti_pusch(
        rrm_cell_index_t cell_index
        )
{
    rrmc_mac_config_t *p_rrmc_mac_config = RRM_PNULL;
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(cell_index);
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return  p_rrmc_mac_config->mac_tpc_rnti_range.startTpcRntiPusch;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_return_start_tpc_rnti_pucch
 *   INPUT      : cell_index
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                returns start tpc rnti pucch
 *   RETURNS    :
 *                returns start tpc rnti pucch
 ******************************************************************************/
U16
rrm_return_start_tpc_rnti_pucch(
        rrm_cell_index_t cell_index
        )
{
    rrmc_mac_config_t *p_rrmc_mac_config = RRM_PNULL;
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(cell_index);
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return p_rrmc_mac_config->mac_tpc_rnti_range.startTpcRntiPucch;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_return_end_tpc_rnti_pucch
 *   INPUT       : cell_index
 *   OUTPUT      : none
 *   DESCRIPTION :
 *                 returns end tpc rnti pucch
 *   RETURNS     :
 *                 returns end tpc rnti pucch
 *****************************************************************************/
U16
rrm_return_end_tpc_rnti_pucch(
        rrm_cell_index_t cell_index
        )
{
    rrmc_mac_config_t *p_rrmc_mac_config = RRM_NULL;
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(cell_index);
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return p_rrmc_mac_config->mac_tpc_rnti_range.endTpcRntiPucch;

}

/******************************************************************************
 *   FUNCTION NAME: rrm_return_end_tpc_rnti_pusch
 *   INPUT      : cell_index
 *   OUTPUT     : none
 *   DESCRIPTION:
 *               returns end tpc rnti pusch
 *
 *   RETURNS    :
 *                returns end tpc rnti pusch
 *****************************************************************************/
U16
rrm_return_end_tpc_rnti_pusch(
        rrm_cell_index_t cell_index
        )
{
    rrmc_mac_config_t *p_rrmc_mac_config = RRM_NULL;
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(cell_index);
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return p_rrmc_mac_config->mac_tpc_rnti_range.endTpcRntiPusch;

}


/******************************************************************************
 *   FUNCTION NAME: rrm_create_new_entry_for_pusch
 *   INPUT      : p_rrm_ue_tpc_rnti_tbl_pusch,drx_prof_index_applicable,p_rrm_ue_context
 *                start_tpc_rnti_pusch,end_tpc_rnti_pusch,sps_applicable
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                Creates new table entry for tpc rnti
 *                allocation table pusch
 *   RETURNS    :
 *                none 
 ******************************************************************************/
void
rrm_create_new_entry_for_pusch(
        rrm_ue_tpc_rnti_tbl_pusch_t *p_rrm_ue_tpc_rnti_tbl_pusch,
        U8 drx_prof_index_applicable,
	/* SPR 18621 Changes Start */
	rrm_dci_format_et dci_format_applicable,
	/* SPR 18621 Changes Stop */
        rrm_ue_context_t *p_rrm_ue_context,
        U16 start_tpc_rnti_pusch,
        U16 end_tpc_rnti_pusch,
        /* SPS related changes start */
        rrm_bool_et  sps_applicable
        /* SPS related changes end */
        )
{
    U8 row_count = RRM_ZERO;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /*Start:SPR 8715*/
    U8 num_tpc_id_dci_3=rrm_cm_get_num_tpc_id_dci3(p_rrm_ue_context->cell_index);
    /* SPR 18621 Changes Start */
    U8 num_tpc_id_dci_3a=rrm_cm_get_num_tpc_id_dci3a(p_rrm_ue_context->cell_index);
    /* SPR 18621 Changes Stop */
    /*End:SPR 8715*/
    row_count = p_rrm_ue_tpc_rnti_tbl_pusch->num_of_row;
    if(row_count < (end_tpc_rnti_pusch-start_tpc_rnti_pusch)+RRM_ONE)
    {
        /*allocate new row*/
        p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count] =
            (rrm_ue_tpc_rnti_row_pusch_t*)
            rrm_mem_get(sizeof(rrm_ue_tpc_rnti_row_pusch_t));
        if(RRM_PNULL == p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count])
        {
          RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,\
              "Mem allocationp_rrm_ue_tpc_rnti_tbl_pusch->"
            "p_p_rrm_ue_tpc_rnti_row_pusch[row_count] failed");
         return ;
        }
	/* SPR 18621 Changes Start */
    	if(RRM_DCI_FORMAT_3 == dci_format_applicable)
    	{
        	p_rrm_ue_tpc_rnti_tbl_pusch->
            		p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id =
            	/*Start:SPR 8715*/
            	(U32*)rrm_mem_get(sizeof(U32)*num_tpc_id_dci_3); 
        	/*End:SPR 8715*/

        	if ( p_rrm_ue_tpc_rnti_tbl_pusch->
                	p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id == RRM_PNULL)
        	{
            		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,\
                    		"Memory allocation to p_rrm_ue_tpc_rnti_tbl_pusch->"
                    	"p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id failed" );
            		RRM_MEM_FREE(p_rrm_ue_tpc_rnti_tbl_pusch->p_p_rrm_ue_tpc_rnti_row_pusch[row_count]);
            	}
        }
        else if(RRM_DCI_FORMAT_3A == dci_format_applicable)
        {
            	p_rrm_ue_tpc_rnti_tbl_pusch->
                	p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id =
                /*Start:SPR 8715*/
                (U32*)rrm_mem_get(sizeof(U32)*num_tpc_id_dci_3a);
            	/*End:SPR 8715*/

            	if ( p_rrm_ue_tpc_rnti_tbl_pusch->
                    p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id == RRM_PNULL)
            	{
                	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,\
                        	"Memory allocation to p_rrm_ue_tpc_rnti_tbl_pusch->"
                        	"p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id failed" );
                	RRM_MEM_FREE(p_rrm_ue_tpc_rnti_tbl_pusch->p_p_rrm_ue_tpc_rnti_row_pusch[row_count]);
            	}
        }
	/* SPR 18621 Changes Stop */
        /*initialize the row*/
        p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->busy_field=
            RRM_RNTI_FREE;

	/* SPR 18621 Changes Start */
        p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->dci_format=
            dci_format_applicable;
        /* SPR 18621 Changes Stop */

	p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->drx_prof_indx=
            drx_prof_index_applicable;

       /* SPS related changes start */
       p_rrm_ue_tpc_rnti_tbl_pusch->
        p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->sps_enabled =
            sps_applicable;
       /* SPS related changes end */
        p_rrm_ue_tpc_rnti_tbl_pusch->
                p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->occupied_tpc_id_count=
                    RRM_ZERO;

	/* SPR 18621 Changes Start */
        if(RRM_DCI_FORMAT_3 == dci_format_applicable)
        {

            /*Start:SPR 8715*/
            for(index = RRM_ZERO ; index < num_tpc_id_dci_3 ; index++)
                /*End:SPR 8715*/
            {
                p_rrm_ue_tpc_rnti_tbl_pusch->
                    p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->
                    p_tpc_id[index] = RRM_RNTI_FREE;
            }
        }
        else if(RRM_DCI_FORMAT_3A == dci_format_applicable)
        {
            /*Start:SPR 8715*/
            for(index = RRM_ZERO ; index < num_tpc_id_dci_3a ; index++)
                /*End:SPR 8715*/
            {
                p_rrm_ue_tpc_rnti_tbl_pusch->
                    p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->
                    p_tpc_id[index] = RRM_RNTI_FREE;
            }
        }
	/* SPR 18621 Changes Stop */


        /*Assign tpc rnti*/
        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch =
            row_count+start_tpc_rnti_pusch;
        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch =
            RRM_ONE;
	/* SPR 18621 Changes Start */
        p_rrm_ue_context->rrm_ue_clpc_params.dci_format_pusch =
            dci_format_applicable;
	/* SPR 18621 Changes Stop */
        p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->p_tpc_id[RRM_ZERO] =
            RRM_RNTI_BUSY;

        p_rrm_ue_tpc_rnti_tbl_pusch->
            p_p_rrm_ue_tpc_rnti_row_pusch[row_count]->
            occupied_tpc_id_count += RRM_ONE;

        p_rrm_ue_tpc_rnti_tbl_pusch->num_of_row +=RRM_ONE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED
        ,"[UE:%d], All configured TPC RNTI for pusch "
        "are exhausted,can't create new bucket",
        p_rrm_ue_context->ue_index);
    }
    RRM_UT_TRACE_ENTER();
}

/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_find_is_drx_enable_and_sps_appl_pusch
 *   INPUT      : p_rrm_ue_context, is_drx_enabled_by_fgi, sps_applicable
 *   OUTPUT     : is_drx_enabled_by_fgi, sps_applicable
 *   DESCRIPTION:
 *                This function is use to find whether drx enable and sps
 *                applicable
 *   RETURNS    :
 *                 Void 
 *****************************************************************************/
rrm_void_t
rrm_find_is_drx_enable_and_sps_appl_pusch
(
    rrm_ue_context_t      *p_rrm_ue_context,
    rrm_bool_et *is_drx_enabled_by_fgi,
    rrm_bool_et *sps_applicable,
    /* SPR 18621 Changes Start */ 
    rrm_dci_format_et *dci_format_applicable
    /* SPR 18621 Changes Stop */
)
{
    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {


        /* SPS related changes start */
        /* SPS configuration will be sent if the 29th bit of FGI is set to 1 */
        /* SPS related changes end */

	/* SPR 18621 Changes Start */
        if((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_ONE)) ==RRM_TRUE)
        {
            *dci_format_applicable = RRM_DCI_FORMAT_3A;
        }
        else
        {
            *dci_format_applicable = RRM_DCI_FORMAT_3;
        }
	/* SPR 18621 Changes Stop */

        /*Start:Bug 762*/
        if((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) ==RRM_TRUE)
        /*End:Bug 762*/
        {
            *is_drx_enabled_by_fgi = RRM_TRUE;
        }
        else
        {
            *is_drx_enabled_by_fgi = RRM_FALSE;
        }

        /* SPS related changes start */
        /*Start:Bug 762*/
        /* SPR_13793_start */
        if( ( (( RRM_REL8 == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            eutra_radio_capability_info_def.access_stratum_release ) &&
                        ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_THREE)) == RRM_TRUE)) ||
                    ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_TWENTY_NINE)) == RRM_TRUE)
            ) &&
                (p_rrm_ue_context->ue_sps_data.is_sps_erab_established == RRM_TRUE)
          )
        /* SPR_13793_end */    
        /*End:Bug 762*/
        {
            *sps_applicable = RRM_TRUE;
        }
        else
        {
            *sps_applicable = RRM_FALSE;
        }
        /* SPS related changes end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator not present, "
                "drx is enabled"
                ,p_rrm_ue_context->ue_index);
        /* SPR 18621 Changes Start */
	*dci_format_applicable = RRM_DCI_FORMAT_3;
	/* SPR 18621 Changes Stop */
        *is_drx_enabled_by_fgi = RRM_TRUE;
        /* SPS related changes start */
        *sps_applicable = RRM_FALSE;
        /* SPS related changes end */
    }  
    RRM_UT_TRACE_EXIT();
}


/*klock_works_changes_start*/
/*Cov_fix_start_65037*/
rrm_bool_et allocate_ue_tpc_rnti_tbl_pusch
(
 U8                           applicable_drx_index,
 rrm_ue_tpc_rnti_tbl_pusch_t  *p_rrm_ue_tpc_rnti_tbl_pusch,
 U8                           num_tpc_id_dci_3,
 /* SPR 18621 Changes Start */
 U8                           num_tpc_id_dci_3a,
 rrm_dci_format_et            dci_format_applicable,
 /* SPR 18621 Changes Stop */
 rrm_bool_et                  sps_applicable,
 rrm_ue_context_t             *p_rrm_ue_context,
 U16                          start_tpc_rnti_pusch
 )
{

    U8 tpc_id_index          = RRM_ZERO;
    U8 row                   = RRM_ZERO;
    rrm_bool_et tpc_id_found = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

            for(row = RRM_ZERO ; row < p_rrm_ue_tpc_rnti_tbl_pusch->num_of_row ;
                    row++)
            {
                if((p_rrm_ue_tpc_rnti_tbl_pusch->
                        p_p_rrm_ue_tpc_rnti_row_pusch[row]->busy_field
                        == RRM_RNTI_FREE) &&
                        (p_rrm_ue_tpc_rnti_tbl_pusch->
                        p_p_rrm_ue_tpc_rnti_row_pusch[row]->drx_prof_indx
                        == applicable_drx_index) &&
			/* SPR 18621 Changes Start */
                       ( p_rrm_ue_tpc_rnti_tbl_pusch->
                        p_p_rrm_ue_tpc_rnti_row_pusch[row]->dci_format
                        == dci_format_applicable)&&
			/* SPR 18621 Changes Stop */
                        /* SPS related changes start */
                        (p_rrm_ue_tpc_rnti_tbl_pusch->
                        p_p_rrm_ue_tpc_rnti_row_pusch[row]->sps_enabled
                        == sps_applicable))
                        /* SPS related changes end */
                {
                    for(tpc_id_index = RRM_ZERO; 
                            /*Start:SPR 8715*/
			    /* SPR 18621 Changes Start */
                            tpc_id_index < num_tpc_id_dci_3a;
                            /* SPR 18621 Changes Stop */
                            /*End:SPR 8715*/
                            tpc_id_index++)
                    {
                        if(p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                p_tpc_id[tpc_id_index] == RRM_RNTI_FREE)
                        {
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                tpc_rnti_index_pusch =
                                tpc_id_index +RRM_ONE;
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                tpc_rnti_pusch =
                                row + start_tpc_rnti_pusch;
			    /* SPR 18621 Changes Start */
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                dci_format_pusch =
                                dci_format_applicable;
			    /* SPR 18621 Changes Stop */
                            /* SPS related changes start */
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                sps_enabled_pusch =
                                sps_applicable;
                            /* SPS related changes end */
                            p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                            p_tpc_id[tpc_id_index] =
                                RRM_RNTI_BUSY;
                            p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                    occupied_tpc_id_count
                                        +=RRM_ONE;
                            tpc_id_found = RRM_TRUE;
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                                    RRM_INFO,
                                    "[UE:%d], tpc_rnti_index_pusch:%d, tpc_rnti_pusch:%d",
                                    p_rrm_ue_context->ue_index, p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch,
                                    p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch);
                    break;
                }
            }
        }

                if(tpc_id_found == RRM_TRUE)
                {
                    /*if all tpc id are exhausted mark busy field as busy*/
		    /* SPR 18621 Changes Start */
                    if(dci_format_applicable == RRM_DCI_FORMAT_3) 
                    {
                        if(p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                /*Start:SPR 8715*/
                                occupied_tpc_id_count == num_tpc_id_dci_3) 
                                /*End:SPR 8715*/
                        {
                            p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                busy_field = RRM_RNTI_BUSY;
                        }
                    } 
                    else if(dci_format_applicable == RRM_DCI_FORMAT_3A)
                    {
                        if(p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                /*Start:SPR 8715*/
                                occupied_tpc_id_count == num_tpc_id_dci_3a)
                                /*End:SPR 8715*/
                        {
                            p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                busy_field = RRM_RNTI_BUSY;
                        }
                    } 
                    break;
                }
		/* SPR 18621 Changes Stop */
            }


    RRM_UT_TRACE_EXIT();
    return tpc_id_found;
}
/*Cov_fix_end_65037*/
/*klock_works_changes_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_allocate_tpc_rnti_dep_drx
 *   INPUT      : applicable_drx_index,p_rrm_ue_context,
 *              : p_rrm_ue_tpc_rnti_tbl_pusch, sps_applicable
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                allocates tpc rnti for pusch depending upon drx grouping
 *   RETURNS    :
 *                 Void 
 *****************************************************************************/
rrm_void_t
rrm_allocate_tpc_rnti_dep_drx
(
    U8 applicable_drx_index,
    rrm_ue_context_t *p_rrm_ue_context,
    rrm_ue_tpc_rnti_tbl_pusch_t *p_rrm_ue_tpc_rnti_tbl_pusch,
    rrm_bool_et sps_applicable
)
{
    U8 tpc_id_index = RRM_ZERO;
    rrm_bool_et tpc_id_found = RRM_FALSE;
    U16 start_tpc_rnti_pusch = RRM_ZERO;
    U16 end_tpc_rnti_pusch = RRM_ZERO;
    /* SPR 18621 Changes Start */
    rrm_dci_format_et dci_format_applicable = RRM_DCI_FORMAT_3;
    /* SPR 18621 Changes Stop */
    /*Start:SPR 8715*/
    U8 num_tpc_id_dci_3=rrm_cm_get_num_tpc_id_dci3(p_rrm_ue_context->cell_index);
    /* SPR 18621 Changes Start */
    U8 num_tpc_id_dci_3a=rrm_cm_get_num_tpc_id_dci3a(p_rrm_ue_context->cell_index);
    /* SPR 18621 Changes Stop */
    /*End:SPR 8715*/

    RRM_UT_TRACE_ENTER();
    start_tpc_rnti_pusch = rrm_return_start_tpc_rnti_pusch(
                            p_rrm_ue_context->cell_index);
    end_tpc_rnti_pusch = rrm_return_end_tpc_rnti_pusch(
                            p_rrm_ue_context->cell_index);
        if(applicable_drx_index != NO_DRX_PROFILE)
        {
            /*if already a tpc rnti provided to the ue
              de-assign it and group it with proper drx
              profile*/
            if(p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch != RRM_ZERO)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                        RRM_INFO,
                        "[UE:%d], de-assign already assigned tpc rnti index: %d",
                        p_rrm_ue_context->ue_index,
                        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch);
                for(tpc_id_index = RRM_ZERO ; 
                        /*Start:SPR 8715*/
			/* SPR 18621 Changes Start */
                    	tpc_id_index < num_tpc_id_dci_3a;
			/* SPR 18621 Changes Stop */
                        /*End:SPR 8715*/
                        tpc_id_index ++)
                {
                    if(p_rrm_ue_context->rrm_ue_clpc_params.
                            tpc_rnti_index_pusch ==
                            tpc_id_index +RRM_ONE)
                    {

                        p_rrm_ue_tpc_rnti_tbl_pusch->
                            p_p_rrm_ue_tpc_rnti_row_pusch[
                            p_rrm_ue_context->rrm_ue_clpc_params.
                            tpc_rnti_pusch -
                            start_tpc_rnti_pusch]->
                            p_tpc_id[tpc_id_index]= RRM_RNTI_FREE;

                        p_rrm_ue_tpc_rnti_tbl_pusch->
                            p_p_rrm_ue_tpc_rnti_row_pusch[
                            p_rrm_ue_context->rrm_ue_clpc_params.
                            tpc_rnti_pusch -
                            start_tpc_rnti_pusch]->
                            busy_field = RRM_RNTI_FREE;
                    }
                }
            }


            /*klock_works_changes_start*/

            tpc_id_found=allocate_ue_tpc_rnti_tbl_pusch(applicable_drx_index,
                    p_rrm_ue_tpc_rnti_tbl_pusch,
                    num_tpc_id_dci_3,
		    /* SPR 18621 Changes Start */
	            num_tpc_id_dci_3a,
		    dci_format_applicable,
                    /* SPR 18621 Changes Stop */
                    sps_applicable,
                    p_rrm_ue_context,
                    start_tpc_rnti_pusch);

            /*klock_works_changes_end*/

            if(tpc_id_found == RRM_FALSE)
            {
                /*Create new entry*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                        RRM_INFO,
                        "[UE:%d], Free tpc rnti with proper "
                        "drx grouping not found, "
                        "creating new tpc rnti bucket",
                        p_rrm_ue_context->ue_index);
                rrm_create_new_entry_for_pusch(
                        p_rrm_ue_tpc_rnti_tbl_pusch,
                        applicable_drx_index,
			/* SPR 18621 Changes Start */
                        dci_format_applicable,
			/* SPR 18621 Changes Stop */
                        p_rrm_ue_context,
                        start_tpc_rnti_pusch,
                        end_tpc_rnti_pusch,
                        /* SPS related changes start */
                        sps_applicable
                        /* SPS related changes end */
                        );
            }
        }
        RRM_UT_TRACE_EXIT();
}
/* Klocwork_fix_march_14_end */


/*klock_works_changes_start*/

rrm_bool_et
check_busy_field_of_tpc_rnti_tbl_pusch
(
 rrm_ue_tpc_rnti_tbl_pusch_t *p_rrm_ue_tpc_rnti_tbl_pusch,
 U8                           num_tpc_id_dci_3,
 /* SPR 18621 Changes Start */
 U8			      num_tpc_id_dci_3a,
 rrm_dci_format_et 	      dci_format_applicable,
 /* SPR 18621 Changes Stop */
 rrm_ue_context_t            *p_rrm_ue_context,
 U16                          start_tpc_rnti_pusch,
 rrm_bool_et                 *sps_applicable
)
{
    U8 tpc_id_index = RRM_ZERO;
    rrm_bool_et tpc_id_found = RRM_FALSE;
    U8 row = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for(row = RRM_ZERO ; row < p_rrm_ue_tpc_rnti_tbl_pusch->num_of_row ;
            row++)
    {
	/* SPR 18621 Changes Start */
        if((p_rrm_ue_tpc_rnti_tbl_pusch->
                p_p_rrm_ue_tpc_rnti_row_pusch[row]->busy_field
                == RRM_RNTI_FREE)&&
                (p_rrm_ue_tpc_rnti_tbl_pusch->
                 p_p_rrm_ue_tpc_rnti_row_pusch[row]->dci_format
                 == dci_format_applicable))
	/* SPR 18621 Changes Stop */
        {
            for(tpc_id_index = RRM_ZERO;
                    /*Start:SPR 8715*/
		    /* SPR 18621 Changes Start */
                    tpc_id_index < num_tpc_id_dci_3a;
                    /* SPR 18621 Changes Stop */
                    /*End:SPR 8715*/
                    tpc_id_index++)
            {
                if(p_rrm_ue_tpc_rnti_tbl_pusch->
                        p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                        p_tpc_id[tpc_id_index] == RRM_RNTI_FREE)


                        {
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                tpc_rnti_index_pusch =
                                tpc_id_index +RRM_ONE;
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                tpc_rnti_pusch =
                                row + start_tpc_rnti_pusch;
			    /* SPR 18621 Changes Start */
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                dci_format_pusch =
                                dci_format_applicable;
			    /* SPR 18621 Changes Stop */
                            /* SPS related changes start */
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                sps_enabled_pusch =
                                    *sps_applicable;
                            /* SPS related changes end */
                            p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                p_tpc_id[tpc_id_index] = RRM_RNTI_BUSY;
                            p_rrm_ue_tpc_rnti_tbl_pusch->
                                p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                                    occupied_tpc_id_count
                                        +=RRM_ONE;
                            tpc_id_found
                                         =
                                    RRM_TRUE;
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                                    RRM_INFO,
                                    "[UE:%d], tpc_rnti_index_pusch"
                                    "tpc_rnti_pusch: %d"
                                    ,p_rrm_ue_context->ue_index
                                    ,p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch,
                                    p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch);
                            break;
                        }
                    }
                }
                if(tpc_id_found == RRM_TRUE)
                {
                    /*if all tpc id are exhausted mark busy field as busy*/
		  /* SPR 18621 Changes Start */
                  if(dci_format_applicable == RRM_DCI_FORMAT_3)
                  {
                      if(p_rrm_ue_tpc_rnti_tbl_pusch->
                              p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                              /*Start:SPR 8715*/
                              occupied_tpc_id_count == num_tpc_id_dci_3)
                              /*End:SPR 8715*/
                      {
                          p_rrm_ue_tpc_rnti_tbl_pusch->
                              p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                              busy_field = RRM_RNTI_BUSY;
                      }
                  }
                  else if(dci_format_applicable == RRM_DCI_FORMAT_3A)
                  {
                      if(p_rrm_ue_tpc_rnti_tbl_pusch->
                              p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                              /*Start:SPR 8715*/
                              occupied_tpc_id_count == num_tpc_id_dci_3a)
                              /*End:SPR 8715*/
                      {
                          p_rrm_ue_tpc_rnti_tbl_pusch->
                              p_p_rrm_ue_tpc_rnti_row_pusch[row]->
                              busy_field = RRM_RNTI_BUSY;
                      }
                  }
                  break;
              }
		/* SPR 18621 Changes Stop */
            }
    RRM_UT_TRACE_EXIT();
    return tpc_id_found;
}

/*klock_works_changes_end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_allocate_tpc_rnti_pusch
 *   INPUT      : applicable_drx_index,p_rrm_ue_context,p_mac_layer_params
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                allocates tpc rnti for pusch
 *   RETURNS    :
 *                 none 
 *****************************************************************************/

void
rrm_allocate_tpc_rnti_pusch(
        U8                    applicable_drx_index,
        rrm_ue_context_t      *p_rrm_ue_context,
        mac_layer_params_t    *p_mac_layer_params
        )
{
    U16 start_tpc_rnti_pusch = RRM_ZERO;
    U16 end_tpc_rnti_pusch = RRM_ZERO;
    rrm_bool_et tpc_id_found = RRM_FALSE;
    rrm_ue_tpc_rnti_tbl_pusch_t 
        *p_rrm_ue_tpc_rnti_tbl_pusch = RRM_PNULL;
    /* SPR 18621 Changes Start */	
    rrm_dci_format_et dci_format_applicable = RRM_DCI_FORMAT_3;
    /* SPR 18621 Changes Stop*/
    rrm_bool_et is_drx_enabled_by_fgi = RRM_FALSE;
    /* SPS related changes start */
    rrm_bool_et sps_applicable = RRM_FALSE;
    /* SPS related changes end */

    /*Start:SPR 8715*/
    U8 num_tpc_id_dci_3=rrm_cm_get_num_tpc_id_dci3(p_rrm_ue_context->cell_index);
    /* SPR 18621 Changes Start */
    U8 num_tpc_id_dci_3a=rrm_cm_get_num_tpc_id_dci3a(p_rrm_ue_context->cell_index);
    /* SPR 18621 Changes Stop */

    /*End:SPR 8715*/

    RRM_UT_TRACE_ENTER();
    start_tpc_rnti_pusch = rrm_return_start_tpc_rnti_pusch(
                            p_rrm_ue_context->cell_index);
    end_tpc_rnti_pusch = rrm_return_end_tpc_rnti_pusch(
                            p_rrm_ue_context->cell_index);
    p_rrm_ue_tpc_rnti_tbl_pusch =
        rrm_cellm_get_tpc_rnti_allocation_table_pusch(
                p_rrm_ue_context->cell_index);


    /* Klocwork_fix_march_14_start */
    /* SPR 18621 Changes Start */ 
    rrm_find_is_drx_enable_and_sps_appl_pusch (p_rrm_ue_context,
            &is_drx_enabled_by_fgi, &sps_applicable, &dci_format_applicable);
    /* SPR 18621 Changes Stop */
    /* Klocwork_fix_march_14_end */

    if((p_mac_layer_params->mac_layer_param_drx.drx_enabled == RRM_TRUE)
            && is_drx_enabled_by_fgi == RRM_TRUE)
    {
        /*new tpc rnti is to be allocated as drx is changed
          otherwise provide same as previous*/

        /* Klocwork_fix_march_14_start */
        rrm_allocate_tpc_rnti_dep_drx (applicable_drx_index, p_rrm_ue_context,
                                        p_rrm_ue_tpc_rnti_tbl_pusch, sps_applicable);
        /* Klocwork_fix_march_14_end */

    }
    else /*drx is disabled by fgi or configuration*/
    {
        /**in case of drx disabled provide tpc rnti to ue if not
          already provided,tpc rnti reconfig will not be required
          in this case**/
        if(p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch == RRM_ZERO)
        {

            /*klock_works_changes_start*/
	    /* SPR 18621 Changes Start */
            tpc_id_found=check_busy_field_of_tpc_rnti_tbl_pusch(p_rrm_ue_tpc_rnti_tbl_pusch, num_tpc_id_dci_3, num_tpc_id_dci_3a, dci_format_applicable, p_rrm_ue_context, start_tpc_rnti_pusch, &sps_applicable);
	    /* SPR 18621 Changes Stop */
            /*klock_works_changes_end*/   

            if(tpc_id_found == RRM_FALSE)
            {
                /*Create new entry*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                        RRM_INFO,
                        "[UE:%d], Free tpc rnti "
                        "not found, "
                        "creating new tpc rnti bucket"
                        ,p_rrm_ue_context->ue_index);
                	rrm_create_new_entry_for_pusch(
                        p_rrm_ue_tpc_rnti_tbl_pusch,
                        NO_DRX_PROFILE,
			/* SPR 18621 Changes Start */
                        dci_format_applicable,
			/* SPR 18621 Changes Stop */
                        p_rrm_ue_context,
                        start_tpc_rnti_pusch,
                        end_tpc_rnti_pusch,
                        /* SPS related changes start */
                        sps_applicable
                        /* SPS related changes end */
                        );
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_check_dci_format_applicable
 *   INPUT      : p_rrm_ue_tpc_rnti_tbl_pucch, dci_format_applicable
 *                num_tpc_id_dci_3, num_tpc_id_dci_3a, row_count
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                This function is use to find tpc id based on
 *                dci format
 *
 *   RETURNS    :
 *                RRM_SUCCESS/RRM_FAILURE 
 ******************************************************************************/
rrm_return_et
rrm_check_dci_format_applicable
(
    rrm_ue_tpc_rnti_tbl_pucch_t *p_rrm_ue_tpc_rnti_tbl_pucch,
    rrm_dci_format_et dci_format_applicable,
    U8 num_tpc_id_dci_3,
    U8 num_tpc_id_dci_3a,
    U8 row_count
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /*allocate tpc ids within the row*/
    if(RRM_DCI_FORMAT_3 == dci_format_applicable)
    {
        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id =
            /*Start:SPR 8715*/
            (U32*)rrm_mem_get(sizeof(U32)*num_tpc_id_dci_3); 
        /*End:SPR 8715*/

        if ( p_rrm_ue_tpc_rnti_tbl_pucch->
                p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,\
                    "Memory allocation to p_rrm_ue_tpc_rnti_tbl_pucch->"
                    "p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id failed" );
            RRM_MEM_FREE(p_rrm_ue_tpc_rnti_tbl_pucch->p_p_rrm_ue_tpc_rnti_row_pucch[row_count]);
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
            }
        }
        else if(RRM_DCI_FORMAT_3A == dci_format_applicable)
        {
            p_rrm_ue_tpc_rnti_tbl_pucch->
                p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id =
                /*Start:SPR 8715*/
                (U32*)rrm_mem_get(sizeof(U32)*num_tpc_id_dci_3a);
            /*End:SPR 8715*/

            if ( p_rrm_ue_tpc_rnti_tbl_pucch->
                    p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id == RRM_PNULL)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,\
                        "Memory allocation to p_rrm_ue_tpc_rnti_tbl_pucch->"
                        "p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id failed" );
                RRM_MEM_FREE(p_rrm_ue_tpc_rnti_tbl_pucch->p_p_rrm_ue_tpc_rnti_row_pucch[row_count]);
                RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
            }
        }
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/* Klocwork_fix_march_14_end */

/******************************************************************************
 *   FUNCTION NAME: rrm_create_new_entry_for_pucch
 *   INPUT      : p_rrm_ue_tpc_rnti_tbl_pucch,drx_prof_index_applicable,dci_format_applicable
 *                p_rrm_ue_context,start_tpc_rnti_pucch,end_tpc_rnti_pucch,sps_applicable
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                Creates new table entry for tpc rnti
 *                allocation table pucch
 *
 *   RETURNS    :
 *                none 
 ******************************************************************************/
void 
rrm_create_new_entry_for_pucch(
        rrm_ue_tpc_rnti_tbl_pucch_t *p_rrm_ue_tpc_rnti_tbl_pucch,
        U8 drx_prof_index_applicable,
        rrm_dci_format_et dci_format_applicable,
        rrm_ue_context_t *p_rrm_ue_context,
        U16 start_tpc_rnti_pucch,
        U16 end_tpc_rnti_pucch,
        /* SPS related changes start */
        rrm_bool_et sps_applicable
        /* SPS related changes end */
        )
{
    U8 row_count = RRM_ZERO;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /*Start:SPR 8715*/
    U8 num_tpc_id_dci_3=rrm_cm_get_num_tpc_id_dci3(p_rrm_ue_context->cell_index);
    U8 num_tpc_id_dci_3a=rrm_cm_get_num_tpc_id_dci3a(p_rrm_ue_context->cell_index);
    /*End:SPR 8715*/
    row_count = p_rrm_ue_tpc_rnti_tbl_pucch->num_of_row;
    if(row_count < (end_tpc_rnti_pucch-start_tpc_rnti_pucch)+RRM_ONE)
    {
        /*allocate new row*/
        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count] = 
            (rrm_ue_tpc_rnti_row_pucch_t*)
            rrm_mem_get(sizeof(rrm_ue_tpc_rnti_row_pucch_t));

        if(RRM_PNULL == p_rrm_ue_tpc_rnti_tbl_pucch->
                p_p_rrm_ue_tpc_rnti_row_pucch[row_count] )
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,\
                    "Mem allocation p_rrm_ue_tpc_rnti_tbl_pucch->"
                    "p_p_rrm_ue_tpc_rnti_row_pucch[row_count] failed");
            return ;
        }

        /* Klocwork_fix_march_14_start */
        if (RRM_FAILURE == rrm_check_dci_format_applicable(p_rrm_ue_tpc_rnti_tbl_pucch,
                    dci_format_applicable, num_tpc_id_dci_3, num_tpc_id_dci_3a, row_count))
        {
            RRM_UT_TRACE_EXIT();
            return;
        }
        /* Klocwork_fix_march_14_end */


        /*initialize the row*/
        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->busy_field=
            RRM_RNTI_FREE;

        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->dci_format=
            dci_format_applicable;

        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->drx_prof_indx=
            drx_prof_index_applicable;

        /* SPS related changes start */
        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->sps_enabled=
            sps_applicable;
        /* SPS related changes end */

        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->occupied_tpc_id_count=
            RRM_ZERO;

        if(RRM_DCI_FORMAT_3 == dci_format_applicable)
        {

            /*Start:SPR 8715*/
            for(index = RRM_ZERO ; index < num_tpc_id_dci_3 ; index++)
                /*End:SPR 8715*/
            {
                p_rrm_ue_tpc_rnti_tbl_pucch->
                    p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->
                    p_tpc_id[index] = RRM_RNTI_FREE;
            }
        }
        else if(RRM_DCI_FORMAT_3A == dci_format_applicable)
        {
            /*Start:SPR 8715*/
            for(index = RRM_ZERO ; index < num_tpc_id_dci_3a ; index++)
                /*End:SPR 8715*/
            {
                p_rrm_ue_tpc_rnti_tbl_pucch->
                    p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->
                    p_tpc_id[index] = RRM_RNTI_FREE;
            }
        }
        /*Assign tpc rnti*/ 
        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch =
            row_count+start_tpc_rnti_pucch;
        p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pucch = 
            RRM_ONE;
        p_rrm_ue_context->rrm_ue_clpc_params.dci_format_pucch =
            dci_format_applicable;
        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->p_tpc_id[RRM_ZERO] =
            RRM_RNTI_BUSY;

        p_rrm_ue_tpc_rnti_tbl_pucch->
            p_p_rrm_ue_tpc_rnti_row_pucch[row_count]->
            occupied_tpc_id_count += RRM_ONE;

        p_rrm_ue_tpc_rnti_tbl_pucch->num_of_row +=RRM_ONE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING
                ,"[UE:%d], All configured TPC RNTI for pucch are "
                "exhausted,can't create new bucket",
                p_rrm_ue_context->ue_index);
    }
    RRM_UT_TRACE_EXIT();
}

/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_find_is_drx_enable_and_sps_appl_pucch
 *   INPUT      : p_rrm_ue_context, is_drx_enabled_by_fgi, sps_applicable,
 *              : dci_format_applicable
 *   OUTPUT     : is_drx_enabled_by_fgi, sps_applicable
 *              : dci_format_applicable
 *   DESCRIPTION:
 *                This function is use to find whether drx enable, sps
 *                applicable and dci format applicable
 *   RETURNS    :
 *                Void 
 *****************************************************************************/
rrm_void_t
rrm_find_is_drx_enable_and_sps_appl_pucch
(
    rrm_ue_context_t      *p_rrm_ue_context,
    rrm_bool_et *is_drx_enabled_by_fgi,
    rrm_bool_et *sps_applicable,
    rrm_dci_format_et *dci_format_applicable
)
{
    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context->ue_capability_params.
       rrm_eutra_radio_capability_info.
       eutra_radio_capability_info_def.bitmask & 
       RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {


        /* SPS related changes start */
        /* SPS configuration will be sent if the 29th bit of FGI is set to 1 */
        /* SPS related changes end */

        /*Start:Bug 762*/
        if((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_ONE)) ==RRM_TRUE)
        /*End:Bug 762*/
        {
            *dci_format_applicable = RRM_DCI_FORMAT_3A;
        }
        else
        {
            *dci_format_applicable = RRM_DCI_FORMAT_3;
        }

        /*Start:Bug 762*/
        if((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE)
        /*End:Bug 762*/
        {
            *is_drx_enabled_by_fgi = RRM_TRUE;
        }
        else
        {
            *is_drx_enabled_by_fgi = RRM_FALSE;
        }

        /* SPS related changes start */
        /*Start:Bug 762*/
        /* SPR_13793_start */
        if( ( (( RRM_REL8 == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            eutra_radio_capability_info_def.access_stratum_release ) &&
                        ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_THREE)) ==RRM_TRUE)) ||
                    ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_TWENTY_NINE)) ==RRM_TRUE)
            ) &&
                (p_rrm_ue_context->ue_sps_data.is_sps_erab_established == RRM_TRUE)
          )
        /* SPR_13793_end */    
        /*End:Bug 762*/
        {
            *sps_applicable = RRM_TRUE;
        }
        else
        {
            *sps_applicable = RRM_FALSE;
        }
        /* SPS related changes end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator not present, "
                "applying DCI FORMAT 3 for PUCCH"
                ,p_rrm_ue_context->ue_index);
        *dci_format_applicable = RRM_DCI_FORMAT_3;
        *is_drx_enabled_by_fgi = RRM_TRUE;
       /* SPS related changes start */
        *sps_applicable = RRM_FALSE;
        /* SPS related changes end */
    }
    RRM_UT_TRACE_EXIT();
}

/* Klocwork_fix_march_14_end */

/******************************************************************************
 *   FUNCTION NAME: rrm_allocate_tpc_rnti_pucch
 *   INPUT      : applicable_drx_index,p_rrm_ue_context,p_mac_layer_params
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                allocates tpc rnti for pucch
 *   RETURNS    :
 *                none 
 *****************************************************************************/
void
rrm_allocate_tpc_rnti_pucch(
        U8                    applicable_drx_index,
        rrm_ue_context_t      *p_rrm_ue_context,
        mac_layer_params_t    *p_mac_layer_params
        )
{
    U16 start_tpc_rnti_pucch = RRM_ZERO;
    U16 end_tpc_rnti_pucch = RRM_ZERO;
    U8 tpc_id_index = RRM_ZERO;
    rrm_bool_et tpc_id_found = RRM_FALSE;
    rrm_ue_tpc_rnti_tbl_pucch_t 
        *p_rrm_ue_tpc_rnti_tbl_pucch = RRM_PNULL;
    /* coverity id :16551 ,rel 2.0.1 */
    rrm_dci_format_et dci_format_applicable = RRM_DCI_FORMAT_3;
    U8 row = RRM_ZERO;
    rrm_bool_et is_drx_enabled_by_fgi = RRM_FALSE;
    /* SPS related changes start */
    rrm_bool_et sps_applicable = RRM_FALSE;
    /* SPS related changes end */
    /*Start:SPR 8715*/
    U8 num_tpc_id_dci_3=rrm_cm_get_num_tpc_id_dci3(p_rrm_ue_context->cell_index);
    U8 num_tpc_id_dci_3a=rrm_cm_get_num_tpc_id_dci3a(p_rrm_ue_context->cell_index);
    /*End:SPR 8715*/

    RRM_UT_TRACE_ENTER();
    start_tpc_rnti_pucch = rrm_return_start_tpc_rnti_pucch(
                                p_rrm_ue_context->cell_index);
    end_tpc_rnti_pucch = rrm_return_end_tpc_rnti_pucch(
                                p_rrm_ue_context->cell_index);
    p_rrm_ue_tpc_rnti_tbl_pucch =
        rrm_cellm_get_tpc_rnti_allocation_table_pucch(
                p_rrm_ue_context->cell_index);

    /* Klocwork_fix_march_14_start */
    rrm_find_is_drx_enable_and_sps_appl_pucch (p_rrm_ue_context,
            &is_drx_enabled_by_fgi, &sps_applicable, &dci_format_applicable);
    /* Klocwork_fix_march_14_end */

    if((p_mac_layer_params->mac_layer_param_drx.drx_enabled == RRM_TRUE)
            && (is_drx_enabled_by_fgi == RRM_TRUE)) 
    {
        /*new tpc rnti is to be allocated as drx is changed
          otherwise provide same as previous*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d], DRX is enabled, allocating tpc rnti "
                "depending upon drx grouping",
                p_rrm_ue_context->ue_index);
        if(applicable_drx_index != NO_DRX_PROFILE)
        {
            /*if already a tpc rnti provided to the ue
              de-assign it and group it with proper drx
              profile*/
            if(p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch != RRM_ZERO)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                        RRM_DETAILED,
                        "[UE:%d], de-assign already assigned tpc rnti", 
                        p_rrm_ue_context->ue_index);
                for(tpc_id_index = RRM_ZERO ; 
                    /*Start:SPR 8715*/
                    tpc_id_index < num_tpc_id_dci_3a;
                    /*End:SPR 8715*/
                    tpc_id_index ++)
                {
                    if(p_rrm_ue_context->rrm_ue_clpc_params.
                            tpc_rnti_index_pucch == 
                            tpc_id_index +RRM_ONE)
                    {

                        p_rrm_ue_tpc_rnti_tbl_pucch->
                            p_p_rrm_ue_tpc_rnti_row_pucch[
                            p_rrm_ue_context->rrm_ue_clpc_params.
                            tpc_rnti_pucch - 
                            start_tpc_rnti_pucch]->
                            p_tpc_id[tpc_id_index]= RRM_RNTI_FREE;

                        p_rrm_ue_tpc_rnti_tbl_pucch->
                            p_p_rrm_ue_tpc_rnti_row_pucch[
                            p_rrm_ue_context->rrm_ue_clpc_params.
                            tpc_rnti_pucch -
                            start_tpc_rnti_pucch]->
                            busy_field = RRM_RNTI_FREE;
                    }
                }
            }

            for(row = RRM_ZERO ; row < p_rrm_ue_tpc_rnti_tbl_pucch->num_of_row ;
                    row++) 
            {
                if((p_rrm_ue_tpc_rnti_tbl_pucch->
                        p_p_rrm_ue_tpc_rnti_row_pucch[row]->busy_field 
                        == RRM_RNTI_FREE) && 
                        (p_rrm_ue_tpc_rnti_tbl_pucch->
                        p_p_rrm_ue_tpc_rnti_row_pucch[row]->drx_prof_indx
                        == applicable_drx_index) &&
                       ( p_rrm_ue_tpc_rnti_tbl_pucch->
                        p_p_rrm_ue_tpc_rnti_row_pucch[row]->dci_format
                        == dci_format_applicable)&&
                       /* SPS related changes start */
                       ( p_rrm_ue_tpc_rnti_tbl_pucch->
                        p_p_rrm_ue_tpc_rnti_row_pucch[row]->sps_enabled
                        == sps_applicable))
                       /* SPS related changes end */
                {
                    for(tpc_id_index = RRM_ZERO; 
                        /*Start:SPR 8715*/
                        tpc_id_index < num_tpc_id_dci_3a;
                        /*End:SPR 8715*/
                        tpc_id_index++)
                    {
                        if(p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                p_tpc_id[tpc_id_index] == RRM_RNTI_FREE)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                                    RRM_DETAILED,
                                    "[UE:%d], Free tpc rnti with proper "
                                    "drx grouping and dci format found, "
                                    "allocating tpc rnti",
                                    p_rrm_ue_context->ue_index);
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                tpc_rnti_index_pucch =
                                tpc_id_index +RRM_ONE;
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                tpc_rnti_pucch = 
                                row + start_tpc_rnti_pucch;
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                dci_format_pucch =
                                dci_format_applicable;
                            /* SPS related changes start */
                            p_rrm_ue_context->rrm_ue_clpc_params.
                                sps_enabled_pucch =
                                sps_applicable;
                            /* SPS related changes end */
                            p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                p_tpc_id[tpc_id_index] = RRM_RNTI_BUSY;
                            p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                occupied_tpc_id_count +=RRM_ONE;
                            tpc_id_found = RRM_TRUE;
                            break;
                        }
                    }
                }
                if(tpc_id_found == RRM_TRUE)
                {
                    /*if all tpc id are exhausted mark busy field as busy*/
                    if(dci_format_applicable == RRM_DCI_FORMAT_3) 
                    {
                        if(p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                /*Start:SPR 8715*/
                                occupied_tpc_id_count == num_tpc_id_dci_3) 
                                /*End:SPR 8715*/
                        {
                            p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                busy_field = RRM_RNTI_BUSY;
                        }
                    } 
                    else if(dci_format_applicable == RRM_DCI_FORMAT_3A)
                    {
                        if(p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                /*Start:SPR 8715*/
                                occupied_tpc_id_count == num_tpc_id_dci_3a)
                                /*End:SPR 8715*/
                        {
                            p_rrm_ue_tpc_rnti_tbl_pucch->
                                p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                                busy_field = RRM_RNTI_BUSY;
                        }
                    } 
                    break;
                }
            }
            if(tpc_id_found == RRM_FALSE)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "[UE:%d], Free tpc rnti with proper "
                        "drx grouping and dci format not found, "
                        "creating new tpc rnti bucket",
                        p_rrm_ue_context->ue_index);
                /*Create new entry*/
                rrm_create_new_entry_for_pucch(
                        p_rrm_ue_tpc_rnti_tbl_pucch,
                        applicable_drx_index,
                        dci_format_applicable,
                        p_rrm_ue_context,
                        start_tpc_rnti_pucch,
                        end_tpc_rnti_pucch,
                        /* SPS related changes start */
                        sps_applicable
                        /* SPS related changes end */
                        );
            }
        } 
    }
    else /*drx is disabled by fgi or configuration*/
    {
        
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d], DRX is disabled, allocating tpc rnti "
                "without drx grouping" 
                ,p_rrm_ue_context->ue_index);
       /**in case of drx disabled provide tpc rnti to ue if not 
       already provided,tpc rnti reconfig will not be required 
       in this case**/
      if(p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch == RRM_ZERO) 
      {
          for(row = RRM_ZERO ; row < p_rrm_ue_tpc_rnti_tbl_pucch->num_of_row ;
                  row++)
          {
              if((p_rrm_ue_tpc_rnti_tbl_pucch->
                      p_p_rrm_ue_tpc_rnti_row_pucch[row]->busy_field
                      == RRM_RNTI_FREE) &&
                      (p_rrm_ue_tpc_rnti_tbl_pucch->
                      p_p_rrm_ue_tpc_rnti_row_pucch[row]->dci_format
                      == dci_format_applicable))
              {
                  for(tpc_id_index = RRM_ZERO; 
                      /*Start:SPR 8715*/
                      tpc_id_index < num_tpc_id_dci_3a;
                      /*End:SPR 8715*/
                      tpc_id_index++)
                  {
                      if(p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              p_tpc_id[tpc_id_index] == RRM_RNTI_FREE)
                      {
                          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                                  RRM_DETAILED,
                                  "[UE:%d], Free tpc rnti with "
                                  "proper dci format found, allocating tpc rnti"
                                  ,p_rrm_ue_context->ue_index);
                          p_rrm_ue_context->rrm_ue_clpc_params.
                              tpc_rnti_index_pucch =
                              tpc_id_index +RRM_ONE;
                          p_rrm_ue_context->rrm_ue_clpc_params.
                              tpc_rnti_pucch =
                              row + start_tpc_rnti_pucch;
                          p_rrm_ue_context->rrm_ue_clpc_params.
                              dci_format_pucch =
                              dci_format_applicable;
                          /* SPS related changes start */
                          p_rrm_ue_context->rrm_ue_clpc_params.
                              sps_enabled_pucch =
                              sps_applicable;
                          /* SPS related changes end */
                          p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              p_tpc_id[tpc_id_index] = RRM_RNTI_BUSY;
                          p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              occupied_tpc_id_count +=RRM_ONE;
                          tpc_id_found = RRM_TRUE;
                          break;
                      }
                  }
              }
              if(tpc_id_found == RRM_TRUE)
              {
                  /*if all tpc id are exhausted mark busy field as busy*/
                  if(dci_format_applicable == RRM_DCI_FORMAT_3)
                  {
                      if(p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              /*Start:SPR 8715*/
                              occupied_tpc_id_count == num_tpc_id_dci_3)
                              /*End:SPR 8715*/
                      {
                          p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              busy_field = RRM_RNTI_BUSY;
                      }
                  }
                  else if(dci_format_applicable == RRM_DCI_FORMAT_3A)
                  {
                      if(p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              /*Start:SPR 8715*/
                              occupied_tpc_id_count == num_tpc_id_dci_3a)
                              /*End:SPR 8715*/
                      {
                          p_rrm_ue_tpc_rnti_tbl_pucch->
                              p_p_rrm_ue_tpc_rnti_row_pucch[row]->
                              busy_field = RRM_RNTI_BUSY;
                      }
                  }
                  break;
              }
          }
          if(tpc_id_found == RRM_FALSE)
          {
              RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                      RRM_DETAILED,
                      "[UE:%d], Free tpc rnti with proper "
                      "dci format grouping not found, "
                      "creating new tpc rnti bucket"
                      ,p_rrm_ue_context->ue_index);
              /*Create new entry*/
              rrm_create_new_entry_for_pucch(
                      p_rrm_ue_tpc_rnti_tbl_pucch,
                      NO_DRX_PROFILE,
                      dci_format_applicable,
                      p_rrm_ue_context,
                      start_tpc_rnti_pucch,
                      end_tpc_rnti_pucch,
                      /* SPS related changes start */
                      sps_applicable
                      /* SPS related changes end */
                      );
          }
      }
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_eutra_capability_v920_ies
 *   INPUT      : p_rrm_ue_eutra_radio_capability_info,p_admission_control_info
 *   OUTPUT     : p_rrc_proximity_config
 *   DESCRIPTION:
 *                Fills the rrm_report_proximity_config_r9_t
 *   RETURNS    :
 *                None 
 ******************************************************************************/
/*SPR 22842 FIXED START*/
rrm_return_et
rrm_ue_fill_eutra_capability_v920_ies(
      rrm_report_proximity_config_r9_t
      *p_rrc_proximity_config,
      rrm_ue_eutra_radio_capability_info_t
      *p_rrm_ue_eutra_radio_capability_info
     )
{

    rrm_return_et                   ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();

    if((p_rrm_ue_eutra_radio_capability_info->ue_eutra_capability_v920_ies.
                csg_proximity_indication_parameters_r9.rrm_intra_freq_proximity_indication_supported_r9 == RRC_TRUE) ||
            (p_rrm_ue_eutra_radio_capability_info->ue_eutra_capability_v920_ies.
             csg_proximity_indication_parameters_r9.rrm_inter_freq_proximity_indication_supported_r9 == RRC_TRUE))
    {

        p_rrc_proximity_config->bitmask |= RRM_PROXIMITY_IND_EUTRA_PRESENT;
        p_rrc_proximity_config->proximity_ind_eutra = RRM_ZERO;
        ret_val =  RRM_SUCCESS;
    }

    if((p_rrm_ue_eutra_radio_capability_info->ue_eutra_capability_v920_ies.
                csg_proximity_indication_parameters_r9.rrm_utran_proximity_indication_supported_r9 == RRC_TRUE))
    {

        p_rrc_proximity_config->bitmask  |= RRM_PROXIMITY_IND_UTRA_PRESENT;
        p_rrc_proximity_config->proximity_ind_utra = RRM_ZERO; 
        ret_val = RRM_SUCCESS;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;          
}
/*SPR 22842 FIXED END*/


/*SPR_19066_START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_ue_inactivity
 *   INPUT      : p_erb_setup_resp, p_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION: Fill the Inactivity time of the UE according to the QCI
 *   RETURNS    : RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
rrm_return_et
rrm_fill_ue_inactivity(
      U32               *p_ue_inactive_time_config, 
      rrm_ue_context_t  *p_ue_context
     )
{
    U32 max_value_of_inactive_timer = RRM_ZERO; /* Time infinite */
    U8  qos_index                   = RRM_ZERO;
    U8  drb_index                   = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t *p_successful_erbs = RRM_NULL;
    rrm_cell_context_t              *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* SPR 22492 Fix Start */
    U8 is_zero_inactivity_timer_received = RRM_FALSE;
    /* SPR 22492 Fix End */

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    if(RRM_PNULL != p_cell_context)
    {
        for (qos_index = RRM_ZERO;
                (qos_index < p_cell_context->epc_info.epc_params.num_valid_qos_profiles) && 
                (qos_index < RRM_MAX_QCI) ; qos_index++)
        {
            if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].bitmask &
                    RRMCM_RMIF_UE_INACTIVE_TIMER_PRESENT)
            {
                /* Checking in already established RABs */
                for (drb_index = RRM_ZERO; (drb_index < p_ue_context->drb_configured.num_of_list) &&
                        (drb_index < RRM_MAX_NUM_DRB_PER_UE ); drb_index++)
                {
                    if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].qci == p_ue_context->drb_configured.erab_item[drb_index].erab_level_qos_params.qci)
                    {
                        /* SPR 22492 Fix Start */
                        if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config == RRM_ZERO)
                        {
                                max_value_of_inactive_timer = RRM_ZERO;
                                is_zero_inactivity_timer_received = RRM_TRUE;
                                break;
                        }
                        else if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config >
                                max_value_of_inactive_timer)
                        {
                            /* SPR 22492 Fix End */
                            max_value_of_inactive_timer =
                                p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config;
                        }
                    }
                }
                 /* SPR 22492 Fix Start */
                /* If zero inactivity timer is received for the established rab ,
                 * then no need to iterate for remaining qos profiles, as in this case
                 * inactivity timer for the ue will be configured as 0 only ie-infinity
                 * */
                if(RRM_TRUE == is_zero_inactivity_timer_received)
                 break;
                /* SPR 22492 Fix End */

                /* Checking in new RABs getting established */
                p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
                    (p_ue_context->current_procedure.p_erb_success_list);
                if (RRM_PNULL != p_successful_erbs)
                {
                    for (drb_index = RRM_ZERO; (drb_index < p_successful_erbs->num_of_list) && (drb_index < RRM_MAX_NUM_DRB_PER_UE); drb_index++)
                    {
                        if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].qci == p_successful_erbs->erab_item[drb_index].erab_level_qos_params.qci)
                        {
                            /* SPR 22492 Fix Start */
                            /* This special handling is done in order to consider the UE inactivity timer 
                             * being configured in the cases of new RABs being admitted with ZERO(i.e. infinite timer value) and NON-ZERO 
                             * values subsequently. Since maximum inactivity timer value
                             * could be infinite, hence max_value_of_inactive_timer is updated with value ZERO and break from the loop */
                            if(p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config == RRM_ZERO)
                            {
                                max_value_of_inactive_timer = RRM_ZERO;
                                is_zero_inactivity_timer_received = RRM_TRUE;
                                break;
                            }
                            else if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config >
                                    max_value_of_inactive_timer)
                            {
                                /* SPR 22492 Fix End */
                                max_value_of_inactive_timer =
                                    p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config;
                            }
                        }
                    }
                }

                /* SPR 22492 Fix Start */
                if(RRM_TRUE == is_zero_inactivity_timer_received)
                 break;
                /* SPR 22492 Fix End */
            }
        }
        *p_ue_inactive_time_config = (max_value_of_inactive_timer * (RRM_ONE_THOUSAND_MS));
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*SPR_19066_END*/

/* Klocwork_fix_march_14_start */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_radio_rsource_config
 *   INPUT      : p_rrm_erab_setup_radio_res_config,p_epc_params,p_rrm_ue_context,
 *              : p_mac_layer_params, applicable_drx_index, p_successful_erbs
 *   OUTPUT     : applicable_drx_index, p_rrm_erab_setup_radio_res_config
 *   DESCRIPTION:
 *                Fills the rrm_erab_setup_radio_res_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_fill_radio_rsource_config
(
    rrm_erab_setup_radio_res_config_t *p_rrm_erab_setup_radio_res_config,
    epc_params_t                    *p_epc_params,
    rrm_ue_context_t                  *p_rrm_ue_context,
    mac_layer_params_t              *p_mac_layer_params,
    U8                              *applicable_drx_index,
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    /* SPS related changes start */
    U8                               qci_val = RRM_ZERO;
    rrm_cell_context_t               *p_cell_context = RRM_PNULL;
    U8                               index = RRM_ZERO;

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65839:start*/    
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
         RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65839:end*/    

    // SPS configuration will be sent if the 29th bit of FGI is set to 1
    /* SPS related changes end */

    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {
        
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator present, "
                "checking for bit5"
                ,p_rrm_ue_context->ue_index);
        /*Check for fgi bit5 if fgi present*/
#ifndef LTE_EMBMS_SUPPORTED
        if((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE) && 
                /*Start:Bug 762*/
                ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE))
                /*End:Bug 762*/
#else
        if(( (p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE) && 
                ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE)) &&
            ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
        {
            *applicable_drx_index = 
/* SPR 10450 Fix Start */
               rrm_find_drx_profile_to_send(p_rrm_ue_context);
/* SPR 10450 Fix End */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d],drx is disabled from oam or BIT 5 IS OFF"
                    ,p_rrm_ue_context->ue_index);
        }

        /* SPS related changes start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Checking for sps provision of [UE:%d]",
                p_rrm_ue_context->ue_index); 
        /* SPR_13793_start */
        if(RRM_REL8 == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
        {
            if ( (RRM_FALSE != p_cell_context->sps_on) &&
                 ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_THREE)) == RRM_TRUE) &&
                    ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_SEVEN)) == RRM_TRUE))
            {
                /*CID 55015*/
                for (index = RRM_ZERO; (index < p_successful_erbs->num_of_list) && (index <RRM_MAX_NUM_DRB_PER_UE ); index++)
                {
                    /* Check whether the requested RAB is the one decided for SPS */
                    if ( (p_rrm_ue_context->ue_sps_data.sps_erab_id) ==
                            (p_successful_erbs->erab_item[index].erab_id) )
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "SPS configuration being sent for erab_id[%d] of [UE:%d]",
                                p_successful_erbs->erab_item[index].erab_id,  p_rrm_ue_context->ue_index);

                        qci_val = p_successful_erbs->erab_item[index].erab_level_qos_params.qci;

                        p_rrm_erab_setup_radio_res_config->bitmask |=
                            RRM_ERAB_SETUP_RADIO_RES_CONFIG_SPS_CONFIG_PRESENT;

                        fill_sps_config(&(p_rrm_erab_setup_radio_res_config->sps_config),
                                p_epc_params, qci_val, p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch,
                                p_rrm_ue_context);
                    }
                }
            }
        }
        else
        {
            if ( (RRM_FALSE != p_cell_context->sps_on) && 
                    /*Start:Bug 762*/
                    (RRM_TRUE  == (rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_TWENTY_NINE))) && 
                    (RRM_TRUE  == (rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_SEVEN))) )
                /*End:Bug 762*/
            {
                /*CID 55015*/
                for (index = RRM_ZERO; (index < p_successful_erbs->num_of_list) && (index <RRM_MAX_NUM_DRB_PER_UE ); index++)
                {
                    if ( (p_rrm_ue_context->ue_sps_data.sps_erab_id) == 
                            (p_successful_erbs->erab_item[index].erab_id) )   /* Check whether the requested RAB is the one decided for SPS */
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "SPS configuration being sent for erab_id[%d] of [UE:%d]", 
                                p_successful_erbs->erab_item[index].erab_id,  p_rrm_ue_context->ue_index);

                        qci_val = p_successful_erbs->erab_item[index].erab_level_qos_params.qci;

                        p_rrm_erab_setup_radio_res_config->bitmask |=
                            RRM_ERAB_SETUP_RADIO_RES_CONFIG_SPS_CONFIG_PRESENT;

                        ret_val = fill_sps_config(&(p_rrm_erab_setup_radio_res_config->sps_config),
                                p_epc_params, qci_val, p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch, 
                                p_rrm_ue_context);
                        if(RRM_FAILURE == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "SPS configuration is not filled successfully erab_id[%d] of [UE:%d]", 
                                    p_successful_erbs->erab_item[index].erab_id,  p_rrm_ue_context->ue_index);
                            break;
                        }
                    }
                }
            }
        }
        /* SPR_13793_end */
        /* SPS related changes end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator not present, "
                "not checking for bit5"
                ,p_rrm_ue_context->ue_index);
        /*no need to check fgi bit5 if bit5 is not present*/
#ifndef LTE_EMBMS_SUPPORTED
        if((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE)) 
#else
        if(((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE)) &&
            ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
        {
            *applicable_drx_index =
/* SPR 10450 Fix Start */
               rrm_find_drx_profile_to_send(p_rrm_ue_context);
/* SPR 10450 Fix End */
        }
    }
    return ret_val;
}
/* Klocwork_fix_march_14_end */

/******************************************************************************
 *   FUNCTION NAME: fill_erb_setup_resp_radio_rsource_config
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_erab_setup_radio_res_config
 *   DESCRIPTION:
 *                Fills the rrm_erab_setup_radio_res_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_setup_resp_radio_rsource_config(
        rrm_erab_setup_radio_res_config_t *p_rrm_erab_setup_radio_res_config,
        rrm_ue_context_t                  *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    epc_params_t                    *p_epc_params = RRM_PNULL;
    admission_control_info_t        *p_admission_control_info = RRM_NULL;
    rlc_layer_params_t              *p_rlc_layer_params = RRM_NULL;
    mac_layer_params_t              *p_mac_layer_params = RRM_NULL;
    U8                              applicable_drx_index = NO_DRX_PROFILE;                              
    rrm_cell_index_t                cell_index = p_rrm_ue_context->cell_index;
    U8                              ul_mcs = RRM_NULL;
    U8                              dl_mcs = RRM_NULL;
    rrm_ue_erab_failed_item_list_t  *p_failed_erbs = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs = RRM_PNULL;
    rrm_cell_context_t               *p_cell_context = RRM_PNULL;
    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */
    /* BLR MEAS CHANGES START */
    rrm_common_params_for_eutra_t   *p_rrm_common_params_for_eutra = RRM_PNULL;
    U16                              tpc_rnti_pucch_old = RRM_NULL;
    U16                              tpc_rnti_pusch_old = RRM_NULL;
    rrm_enable_ue_measurement_et     rrm_enable_ue_measurement = RRM_UE_MEASURMENT_ENABLE;
    /* BLR MEAS CHANGES END */
    /*TM mode 7-8 start*/
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info=
        rrm_cm_get_mrrm_tm_mode_additional_info(cell_index);
    /*TM mode 7-8 end*/
    RRM_UT_TRACE_ENTER();
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);
    p_mac_layer_params = rrm_cellm_mac_layer_params(cell_index);
    /* Coverity 19oct Start : 54990 */
    RRM_ASSERT(RRM_PNULL != p_mac_layer_params);
    /* Coverity 19oct End : 54990 */
    p_epc_params = rrm_cellm_get_erb_service_profile(cell_index);
    p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);
    p_rlc_layer_params = rrm_cellm_get_srb_info(cell_index);
    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */
    p_rrm_common_params_for_eutra =  
        rrm_cellm_get_connected_mode_common_params(cell_index);
    rrm_enable_ue_measurement = get_enable_ue_measurement(cell_index);

    /*SPR 16944 START*/
    if(p_successful_erbs != RRM_PNULL)
    {
        /*SPR 16944 END*/
        if((p_epc_params != RRM_PNULL) && 
                (p_successful_erbs->num_of_list > RRM_ZERO))
        {
            p_rrm_erab_setup_radio_res_config->bitmask |=
                RRM_ERAB_SETUP_RADIO_RES_CONFIG_DRB_TO_ADD_LIST_PRESENT;
            fill_erb_setup_modify_resp_drb_to_add_list
                (&(p_rrm_erab_setup_radio_res_config->drb_to_add_list),
                 p_rrm_ue_context,p_epc_params);

        }
        /* SPR 19078: CID 61087 Fix Start */
        else if(p_epc_params == RRM_PNULL)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_epc_params is null");
            ret_val = RRM_FAILURE;
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /* SPR 19078: CID 61087 Fix End */
        /*SPR 16944 START*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_erb_success_list is NULL");
        /* Coverity 94896 Fix Start */ 
        ret_val = RRM_FAILURE;
        RRM_UT_TRACE_EXIT();
        return ret_val;
        /* Coverity 94896 Fix End */
    }
    /*SPR 16944 END*/

    
    /* Klocwork_fix_march_14_start */
    ret_val = rrm_fill_radio_rsource_config (p_rrm_erab_setup_radio_res_config, p_epc_params,
            p_rrm_ue_context, p_mac_layer_params, &applicable_drx_index, p_successful_erbs);
    /* Klocwork_fix_march_14_end */

    /*DRX parameters will be given if bit 5 of 
     feature group indicator is set as one*/
    /* Bug 3961 Fix Start */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);
    /*Coverity 98730 Fix : START*/
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell context is NULL at cell_index [%d]",cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*Coverity 98730 Fix : END*/
    /* Bug 3961 Fix End */

                        ret_val = RRM_SUCCESS;
    
    if (RRM_SUCCESS == ret_val )
    {
    tpc_rnti_pucch_old = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch;
    tpc_rnti_pusch_old = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch;

   
    /*Coverity 54990 Fix Start*/
    if(p_mac_layer_params != RRM_PNULL)
    {
        rrm_allocate_tpc_rnti_pucch(applicable_drx_index,
                p_rrm_ue_context,p_mac_layer_params);

        rrm_allocate_tpc_rnti_pusch(applicable_drx_index,
                p_rrm_ue_context,p_mac_layer_params);
        /* SPR 16775 start */
        /* Code deleted */
        /* SPR 16775 end */

        /**CLPC_MR_END*/
        /*Coverity 54990 Fix End*/
        p_rrm_erab_setup_radio_res_config->bitmask |= 
            RRM_ERAB_SETUP_RADIO_RES_CONFIG_MAC_CONFIG_PRESENT;
        fill_erb_setup_resp_mac_config
            (&(p_rrm_erab_setup_radio_res_config->mac_config),
             p_mac_layer_params,p_rrm_ue_context,
             ul_mcs,dl_mcs,applicable_drx_index
             );
        /*TM mode 7-8 start*/
        if(p_rrm_erab_setup_radio_res_config->physical_config_dedicated.
           antenna_information.bitmask & RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT)
        {
           if(TRANSMISSION_MODE_TM7 == p_rrm_erab_setup_radio_res_config->physical_config_dedicated.
              antenna_information.antenna_information_explicit_value.transmission_mode)
           {
               p_rrm_erab_setup_radio_res_config->mac_config.
               mac_main_config_extensions.bitmask |= RRM_MAC_MAIN_CONFIG_EXT_PDSCH_EPRE_TO_UE_RS_RATIO_PRESENT;
               p_rrm_erab_setup_radio_res_config->mac_config.mac_main_config_extensions.pdsch_epre_to_ue_rs_ratio
                  = p_rrm_tm_mode_additional_info->pdsch_epre_to_ue_rs_ratio;
           }
        }
        /*TM mode 7-8 end*/
    }
   /*SPR 15713 Fix Start*/
    /*Function call position change*/
    if(p_admission_control_info != RRM_PNULL)
    {
        p_rrm_erab_setup_radio_res_config->bitmask |=
            RRM_ERAB_SETUP_RADIO_RES_CONFIG_PHY_CONFIG_DED_PRESENT;
        fill_erb_setup_resp_physical_config_dedicated
            (&(p_rrm_erab_setup_radio_res_config->physical_config_dedicated),
             p_admission_control_info,&ul_mcs,
             &dl_mcs,p_rrm_ue_context,tpc_rnti_pucch_old,
             /*spr_19392_changes_start*/
             tpc_rnti_pusch_old, ERAB_SETUP);
            /*spr_19392_changes_end*/
        /*SPR 17732 Start*/
	/*CID 97305 Start*/
        if(RRM_FAILURE!=rrm_select_num_of_layer_for_ue(p_rrm_ue_context,&(p_rrm_erab_setup_radio_res_config->mac_config.mac_main_config_extensions.num_of_layer)))
	{
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILEDALL,"num of Layer = %d ",p_rrm_erab_setup_radio_res_config->mac_config.mac_main_config_extensions.num_of_layer);
	}
	/*CID 97305 End*/
        /*SPR 17732 End*/

    }
    /*SPR 15713 Fix End*/

    /* Start CSR 00059256 */
    if(p_rlc_layer_params != RRM_PNULL)
    /* End CSR 00059256 */
    {
        p_rrm_erab_setup_radio_res_config->bitmask |= 
            RRM_ERAB_SETUP_RADIO_RES_CONFIG_SRB_INFO_PRESENT;
        fill_erb_setup_resp_srb2_info
            (&(p_rrm_erab_setup_radio_res_config->srb_info),p_rlc_layer_params,
             p_rrm_ue_context);
    }

    p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
        (p_rrm_ue_context->current_procedure.p_erb_failed_list); 
    if(p_failed_erbs->num_of_list > RRM_ZERO)
    {
        p_rrm_erab_setup_radio_res_config->bitmask |= 
            RRM_ERAB_SETUP_RADIO_RES_CONFIG_DRB_FAILED_TO_ADD_LIST_PRESENT;
        fill_erb_setup_resp_drb_failed_to_add_list
            (&(p_rrm_erab_setup_radio_res_config->drb_failed_to_add_list),
             p_failed_erbs);
    }

    /* SPR 16406 8SEP start */
    /* Code deleted */
    /* SPR 16406 8SEP end */
    if(RRM_UE_MEASURMENT_ENABLE == rrm_enable_ue_measurement)
    {
        /* MC,MR & HO START*/
        if ( p_rrm_common_params_for_eutra !=RRM_PNULL)
        {
            if(!(p_rrm_ue_context->ho_params.bitmask & \
                        RRM_UE_CSFB_RECD))
            {
            /* SPR_15501_fix: Start */
            if(!(p_rrm_ue_context->ho_params.bitmask & \
                        RRM_UE_CSFB_RECD) &&
                    !(p_rrm_ue_context->ho_params.bitmask & \
                        RRM_UE_PRIMARY_MEAS_OBJ_CONFIGURED))
                /* SPR_15501_fix: End */
            {
                 
                rrm_ue_fill_meas_config_req_for_ho(&(p_rrm_erab_setup_radio_res_config->
                            meas_config),p_rrm_ue_context);
                /*SPR 6533 START */
                if( RRM_ZERO != p_rrm_erab_setup_radio_res_config->meas_config.bitmask )
                {
                    p_rrm_erab_setup_radio_res_config->bitmask |=
                        RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_CONFIG_PRESENT;
                }
                /*SPR 6533 End */
            }

        }
    }
    /* MC,MR & HO END*/

    /*csg start*/
    /*start fill report_proximity_config*/
    if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) 
    {
      
        /* SPR 22842 FIXED START*/
        if(p_admission_control_info != RRM_PNULL)   
        {

            if((p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)&& 
                    (p_admission_control_info->bitmask & RRMCM_RMIF_PROXIMITY_IND_STATUS_PRESENT)&&
                    (p_admission_control_info->proximity_indication_status ==  RRM_TRUE))
            {


                if(RRM_SUCCESS == rrm_ue_fill_eutra_capability_v920_ies(
                            &(p_rrm_erab_setup_radio_res_config->proximity_config),
                            &(p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info)))
                {
                    p_rrm_erab_setup_radio_res_config->bitmask |= 
                        RRM_ERAB_SETUP_RADIO_RES_CONFIG_PROXIMITY_PRESENT;
                }

            }

        }
        /* SPR 22842 FIXED END*/


    }
    /*end fill report_proximity_config*/
    /*csg end*/
    /* Bug 3961 Fix Start */
    /* Filling MeasSubframePatternPCell_r10 IE during attach */
    if((RRM_TRUE == rrm_is_set_fgi_bit(p_rrm_ue_context, RRM_HUNDRED_FIFTEEN)) && 
     (RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release) &&
     (RRM_TRUE == rrm_cellm_is_victim_node(p_cell_context)))
    {
	if((p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT) && (RRM_FALSE == rrm_check_absPattern_is_null(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset)))
  	{
		p_rrm_erab_setup_radio_res_config->bitmask |= RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT;
      		p_rrm_erab_setup_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.bitmask |= MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT; 
      		p_rrm_erab_setup_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.
                	meas_subframe_pattern_r10_setup.bitmask |= RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;
      		RRM_MEMCPY(p_rrm_erab_setup_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                	    subframe_pattern_fdd_r10.data,p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset, MAX_SUBFRAME_PATTERN_FDD);
  	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
               		" Victim Meas Subset is null, not setting bitmask ");
	}
    }
    /* Bug 3961 Fix End */
    }
        /* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
        if( RRM_TRUE == rrm_check_trigger_to_configure_nr_meas(p_rrm_ue_context,TRIGGER_TYPE_QCI))
        {
            if( RRM_SUCCESS == 
                 fill_eutra_nr_meas_info(&(p_rrm_erab_setup_radio_res_config->\
                                  meas_config), p_rrm_ue_context))
            {
                p_rrm_erab_setup_radio_res_config->bitmask |=
                    RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_CONFIG_PRESENT;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Measurements are configured successfully on UE[%d]\n",p_rrm_ue_context->ue_index);
                p_rrm_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_stats.\
                    nr_meas_req_status = RRM_NR_MEAS_REQ_FILLED;
            }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Unable to configure measurements for UE[%d] \n",p_rrm_ue_context->ue_index);

        }
        }
#endif
/* ENDC_MEAS_CHANGES_END */

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

#ifdef ENDC_ENABLED
/******************************************************************************
*   FUNCTION NAME: rrm_calculate_sgnb_ue_aggr_max_bit_rate
*   INPUT        : p_rrm_ue_context,p_sgnb_add_param
*   OUTPUT       : p_sgnb_add_param
*   DESCRIPTION  : Fills the UE aggregated maximum bit rate for SgNB
*   RETURNS      : NONE
******************************************************************************/
rrm_void_t
rrm_calculate_sgnb_ue_aggr_max_bit_rate
(
    rrc_rrm_sgnb_add_param_t    *p_sgnb_add_param,
    rrm_ue_context_t            *p_rrm_ue_context
)
{
    U8  SgNBAMBRShare = rrm_cellm_get_sgnb_ambr_share(
            p_rrm_ue_context->cell_index);

    if ( SgNBAMBRShare)
    {
        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_ul =
            (((p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul) *
              SgNBAMBRShare) / RRM_HUNDRED);

        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_dl =
            (((p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl) *
              SgNBAMBRShare) / RRM_HUNDRED);

    }
    else if ( (RRM_THREE_HUNDRED * RRM_MEGA) >
            p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl )
    {
        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_ul =
            (((p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul) *
              RRM_FIFTY ) / RRM_HUNDRED);


        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_dl =
            (((p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl) *
              RRM_FIFTY ) / RRM_HUNDRED);
    }
    else if ( ( (RRM_THREE_HUNDRED * RRM_MEGA) <
                p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl ) &&
            ( (RRM_SIX_HUNDRED * RRM_MEGA) >
              p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl )
            )
    {
        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_ul =
            (p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul -
             (RRM_ONE_FIFTY * RRM_MEGA));

        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_dl =
            (p_rrm_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl -
             (RRM_ONE_FIFTY * RRM_MEGA));
    }
    else
    {
        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_ul = (RRM_SIX_HUNDRED * RRM_MEGA);

        p_sgnb_add_param->ue_agg_max_bit_rate_sgnb.
            ue_agg_max_bit_rate_dl = (RRM_SIX_HUNDRED * RRM_MEGA);
    }
}

/******************************************************************************
*   FUNCTION NAME: rrm_populate_drx_config_mn
*   INPUT        : p_rrm_ue_context,p_sgnb_add_param
*   OUTPUT       : p_sgnb_add_param
*   DESCRIPTION  : Fills the DRX info for SgNB
*   RETURNS      : NONE
******************************************************************************/
rrm_void_t
rrm_populate_drx_config_mn
(
    rrc_rrm_sgnb_add_param_t    *p_sgnb_add_param,
    rrm_ue_context_t            *p_rrm_ue_context
)
{
    RRM_UT_TRACE_ENTER();

    p_sgnb_add_param->cg_config_info.bitmask |=
        NR_CG_CONFIG_INFO_DRX_INFO_MCG_PRESENT;

    if ( RRM_TRUE == p_rrm_ue_context->is_drx_configured )
    {
        p_sgnb_add_param->cg_config_info.drx_config_mcg.drx_config_type =
            RRC_DRX_CONFIG_TYPE_SETUP;

        p_sgnb_add_param->cg_config_info.drx_config_mcg.bitmask |=
            RRC_DRX_CONFIG_PARAM_PRESENT; 

        if ( RRM_TRUE == p_rrm_ue_context->is_short_drx_configured )
        {
            p_sgnb_add_param->cg_config_info.drx_config_mcg.
                drx_config_param.bitmask |=
                RRC_DRX_CONFIG_SHORT_DRX_PRESENT;

            RRM_MEMCPY(&p_sgnb_add_param->cg_config_info.drx_config_mcg.
                    drx_config_param.short_drx,
                    &p_rrm_ue_context->short_drx,
                    sizeof(rrc_short_drx_t));
        }
        RRM_MEMCPY(&p_sgnb_add_param->cg_config_info.drx_config_mcg.drx_config_param.long_drx_cycle_start_offset_r15,
            &p_rrm_ue_context->long_drx_cycle_start_offset_r15,
            sizeof(rrc_long_drx_cycle_start_offset_r15_t));
    }
    else
    {
        p_sgnb_add_param->cg_config_info.bitmask |=
            NR_CG_CONFIG_INFO_DRX_INFO_MCG_PRESENT;

        p_sgnb_add_param->cg_config_info.drx_config_mcg.drx_config_type =
            RRC_DRX_CONFIG_TYPE_REL;
    }

    RRM_UT_TRACE_EXIT();
}

/*NR_DC Code Changes Start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_nr_cg_config_info 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : 
 *   DESCRIPTION:
 *                 Fills NR CG CONFIG INFO in ERAB SETUP RESP 
 *   RETURNS    :
 ******************************************************************************/
rrm_void_t 
rrm_fill_nr_cg_config_info
(
       rrm_ue_context_t         *p_rrm_ue_context,
 rrc_rrm_sgnb_add_param_t   *p_sgnb_add_param,
 rrm_x2_gb_gnb_id_t         *p_selected_gnb_id,
 rrm_meas_result_nr_neighbour_list_r15_t  *p_meas_result_nr
)
{
    U32                         cell_count       = RRM_ZERO;
    YLNODE                      *p_node          = RRM_PNULL;
    rrm_x2ap_enb_node_t         *p_x2ap_enb_node        = RRM_PNULL;
    rrc_rrm_meas_result_list2_nr_t *p_mn_candid_cell_info  = RRM_PNULL;    
    meas_result_nr_t            *p_meas_result_nr_srv = RRM_PNULL; 
    U16                         band_count       = RRM_ZERO; 
    U8                        meas_count = RRM_ZERO; 
    rrm_meas_result_neighbour_nr_cell_r15_t *p_meas_result_nr_neighbr = RRM_PNULL;
    U8                        index = RRM_ZERO; 
    /* NR_REP_CONFIG_FIX_START */
    rrm_cellm_endc_info_t           *p_endc_info = RRM_PNULL;
    rrm_cell_context_t              *p_cell_ctxt = RRM_PNULL;
    rrm_cellm_peer_gnb_pci_list_t *p_configured_pci_list = RRM_PNULL;
    rrc_rrm_meas_result2_nr_t   *p_meas_res2_nr = RRM_PNULL;
    rrc_rrm_meas_cell_results_t *p_nr_meas_cell_res = RRM_PNULL;
    U8                           pci_count = RRM_ZERO;
    /* NR_REP_CONFIG_FIX_END */ 

    /*calculate the 60% of the UE Aggregated bitrate for SgNB */
   rrm_calculate_sgnb_ue_aggr_max_bit_rate(p_sgnb_add_param,p_rrm_ue_context);
    p_sgnb_add_param->bitmask |= 0x00;
    if(RRM_PNULL != p_selected_gnb_id)
    {
        RRM_MEMCPY(p_sgnb_add_param->gnb_id.plmn_identity.plmn_id,
                   p_selected_gnb_id->plmn_identity.plmn_id, 
                   sizeof(U8) * MAX_PLMN_ID_BYTES);
        RRM_MEMCPY(p_sgnb_add_param->gnb_id.x2_en_gnb_id.x2_gnb_id,
                   p_selected_gnb_id->gNB_id,
                   sizeof(U8)*NR_GNB_ID_OCTET_SIZE);
        p_sgnb_add_param->bitmask |= RRC_SGNB_ADD_PARAM_GNB_ID_PRESENT;
    }

    /*update the Config Restrict Info SCG*/
    p_sgnb_add_param->cg_config_info.bitmask |= 
        NR_CG_CONFIG_INFO_CONFIG_RESTRICT_INFO_PRESENT;

    p_sgnb_add_param->cg_config_info.config_restrict_info_scg.bitmask |=
        NR_CG_CONFIG_RESTRICT_INFO_SCG_SERV_CELL_INDEX_PRESENT;

    /*hard code the low bound to 8 and up bound to 15*/
    p_sgnb_add_param->cg_config_info.config_restrict_info_scg.\
        scg_serv_cell_index_range.low_bound_cell_index = 8;

    p_sgnb_add_param->cg_config_info.config_restrict_info_scg.\
        scg_serv_cell_index_range.up_bound_cell_index = 15;

    for ( band_count = RRM_ZERO; band_count < p_rrm_ue_context->
            allowed_bc_list_mrdc.band_comb_count; band_count++ )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "NR_CG_CONFIG_RESTRICT_INFO_ALLOWED_BC_LIST_PRESENT");
        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.bitmask |=
            NR_CG_CONFIG_RESTRICT_INFO_ALLOWED_BC_LIST_PRESENT;

        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.allowed_bc_list_mrdc.
            band_comb_count =
            p_rrm_ue_context->allowed_bc_list_mrdc.band_comb_count;

        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.allowed_bc_list_mrdc.
            band_comb_index[band_count] =
            p_rrm_ue_context->allowed_bc_list_mrdc.band_comb_index[band_count];
    }

    p_endc_info = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->operator_info.endc_info);

        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.\
            bitmask |=
            NR_CG_CONFIG_RESTRICT_INFO_MAX_MEAS_FREQ_SCG_NR_PRESENT;

        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.\
            max_meas_freq_scg_nr =
            p_endc_info->max_meas_freq_scg_nr;

        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.\
            bitmask |=
            NR_CG_CONFIG_RESTRICT_INFO_MAX_MEAS_ID_SCG_NR_PRESENT;

        p_sgnb_add_param->cg_config_info.config_restrict_info_scg.\
            max_meas_id_scg_nr =
            p_endc_info->max_meas_id_scg_nr;

    /*update the MN Candid Cell Info*/
    /* NR_REP_CONFIG_FIX_START */
    if( RRM_PNULL != p_meas_result_nr )
    {
        p_sgnb_add_param->cg_config_info.bitmask |=
            NR_CG_CONFIG_INFO_MN_CANDID_CELL_INFO_PRESENT;

        p_mn_candid_cell_info = 
            &(p_sgnb_add_param->cg_config_info.candidate_cell_info_list_mn);

        p_mn_candid_cell_info->count = p_meas_result_nr->count; 

        for(meas_count = RRM_ZERO ; (meas_count < p_meas_result_nr->count) &&
                (meas_count < RRM_MAX_CELLS_REPORTED); meas_count++)
        {
            p_meas_res2_nr = &(p_mn_candid_cell_info->rrc_rrm_meas_result2_nr[meas_count]);

            p_meas_res2_nr->bitmask = RRM_ZERO;
            p_meas_res2_nr->bitmask |= RRC_RRM_MEAS_RESULT2_NR_MEAS_RES_SERVING_PRESENT;

            p_meas_result_nr_srv = &(p_meas_res2_nr->meas_result_serving_cell);
            p_meas_result_nr_neighbr = 
                &(p_meas_result_nr->meas_result_neighbour_nr_cell_r15[meas_count]);

            p_meas_result_nr_srv->phy_cell_id = (U16)p_meas_result_nr_neighbr->pci_r15;

            /* Get arfcn value for this pci in selected SgNB */

            p_node = ylFirst(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));
            while(p_node)
            {
                p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;

                if(p_x2ap_enb_node->link_up_data.bitmask &
                        RRM_NR_CELL_INFO_PRESENT)
                {
                    if((RRM_PNULL != p_selected_gnb_id) &&( RRM_ZERO == 
                            RRM_MEMCMP(&(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id),
                                p_selected_gnb_id, sizeof(rrm_x2_gb_gnb_id_t))))
                    {
                        for(cell_count = RRM_ZERO; 
                                cell_count < MAX_CELL_REPORT && 
                                cell_count < p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                num_served_nr_cell;
                                cell_count++)
                        {
                            for(index = RRM_ZERO; 
                                    index < p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                    cell_info[cell_count].served_cell_info.meas_timing_config_len;
                                    index++)
                            {
                                if( p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[cell_count].\
                                        served_cell_info.nr_pci == p_meas_result_nr_srv->phy_cell_id)
                                {
                                    p_meas_res2_nr->bitmask |= 
                                        RRC_RRM_MEAS_RESULT2_NR_REF_FREQ_CSI_RS_PRESENT;

                                    p_meas_res2_nr->ref_freq_csi_rs = 
                                        p_x2ap_enb_node->link_up_data.\
                                        nr_cell_info.cell_info[cell_count].\
                                        served_cell_info.meas_timing_config[index].\
                                        carrier_freq;
                                    break;
                                }
                            }
                        }
                    }
                }
                p_node = ylNext(p_node);
            }

            p_meas_result_nr_srv->bitmask = RRM_ZERO;
            p_meas_result_nr_srv->bitmask |= 
                RRC_RRM_MEAS_RESULT_NR_PHY_CELL_ID_PRESENT;

            p_nr_meas_cell_res = &(p_meas_result_nr_srv->rrc_rrm_meas_result.\
                    meas_cell_results);

            p_nr_meas_cell_res->bitmask = RRM_ZERO;
            p_nr_meas_cell_res->bitmask |=
                RRC_RRM_MEAS_CELL_RESULT_CSI_RS_RESULT_PRESENT;

            p_nr_meas_cell_res->result_csi_rs_cell.bitmask = RRM_ZERO;

            if( p_meas_result_nr_neighbr->meas_result_nr_r15.bitmask &
                    MEAS_RESULT_NR_RSRP_PRESENT)
            {
                p_nr_meas_cell_res->result_csi_rs_cell.bitmask |= 
                    RRC_RRM_MEAS_QUANTITY_RES_RSRP_PRESENT;
                p_nr_meas_cell_res->result_csi_rs_cell.rsrp =
                    (rsrp_result_nr_r15_t)p_meas_result_nr_neighbr->\
                    meas_result_nr_r15.rsrp_result_nr_r15;
            }

            if( p_meas_result_nr_neighbr->meas_result_nr_r15.bitmask &
                    MEAS_RESULT_NR_RSRQ_PRESENT)
            {
                p_nr_meas_cell_res->result_csi_rs_cell.bitmask |= 
                    RRC_RRM_MEAS_QUANTITY_RES_RSRQ_PRESENT; 
                p_nr_meas_cell_res->result_csi_rs_cell.rsrq = \
                                                              (rsrq_result_nr_r15_t) p_meas_result_nr_neighbr->\
                                                              meas_result_nr_r15.rsrq_result_nr_r15;
            }

            if( p_meas_result_nr_neighbr->meas_result_nr_r15.bitmask &
                    MEAS_RESULT_NR_RS_SINR_PRESENT)
            {
                p_nr_meas_cell_res->result_csi_rs_cell.bitmask |=
                    RRC_RRM_MEAS_QUANTITY_RES_SINR_PRESENT;
                p_nr_meas_cell_res->result_csi_rs_cell.sinr = \
                                                              (rs_sinr_result_r15_t) p_meas_result_nr_neighbr->\
                                                              meas_result_nr_r15.rs_sinr_result_r15;
            }
        }
    }
    else /* it's a case of database assisted sgnb addition */
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
        if (RRM_PNULL == p_cell_ctxt )
        {
            RRM_UT_TRACE_EXIT();
            return ;
        }
        p_sgnb_add_param->cg_config_info.bitmask |=
            NR_CG_CONFIG_INFO_MN_CANDID_CELL_INFO_PRESENT;

        p_mn_candid_cell_info = 
            &(p_sgnb_add_param->cg_config_info.candidate_cell_info_list_mn);

        p_configured_pci_list = &(p_cell_ctxt->operator_info.endc_info.peer_gnb_pci_list);
        //p_mn_candid_cell_info->count = p_configured_pci_list->count;

        for(pci_count = RRM_ZERO ; (pci_count < p_configured_pci_list->count) &&
                (pci_count < RRM_MAX_CELLS_REPORTED); pci_count++)
        {
            p_meas_res2_nr = &(p_mn_candid_cell_info->\
                    rrc_rrm_meas_result2_nr[meas_count]);
            if( RRM_ONE == 
                    p_configured_pci_list->peer_gnb_pci[pci_count].is_valid )
            {
                p_meas_res2_nr->bitmask = RRM_ZERO;
                p_meas_res2_nr->bitmask |= RRC_RRM_MEAS_RESULT2_NR_MEAS_RES_SERVING_PRESENT;

                p_meas_result_nr_srv = &(p_meas_res2_nr->meas_result_serving_cell);

                p_meas_result_nr_srv->bitmask = RRM_ZERO;
                p_meas_result_nr_srv->phy_cell_id =
                    p_configured_pci_list->peer_gnb_pci[pci_count].nr_pci;
                p_meas_result_nr_srv->bitmask |= RRC_RRM_MEAS_RESULT_NR_PHY_CELL_ID_PRESENT;

                p_meas_result_nr_srv->rrc_rrm_meas_result.\
                    meas_cell_results.bitmask = RRM_ZERO;
                meas_count++;
            }
        }
        p_mn_candid_cell_info->count = meas_count;
    }
    /* NR_REP_CONFIG_FIX_END */

/* OPTION3X Changes Start */
    /* Update MCG RB Config needs to be done in the calling function and here only
     * bitmask will be set based on the count of drb_To_AddMod_List
     */

    /* Set bitmask if alteast one entry is present in DRB_to_AddMod List */
    if(RRM_ZERO <
            p_sgnb_add_param->cg_config_info.mcg_rb_config.drb_to_add_mod_list.count)
    {
        /*Set DRB to add mod list bitmask*/
        p_sgnb_add_param->cg_config_info.mcg_rb_config.bitmask |=
            RADIO_BEARER_CONFIG_DRB_TO_ADD_MOD_LIST_PRESENT;

        /* Set bitmask for MCG Radio Bearer Config Present */
        p_sgnb_add_param->cg_config_info.bitmask |=
            NR_CG_CONFIG_INFO_MCG_RB_CONFIG_PRESENT;
    }
    /* OPTION3X Changes End */

    /* populate the DRX config for SgNB */
    rrm_populate_drx_config_mn(p_sgnb_add_param,p_rrm_ue_context);
}
/*NR_DC Code Changes Stop*/
#endif

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rbc_fill_erb_setup_resp 
 *   INPUT      : p_rrm_ue_context,response
 *   OUTPUT     : p_erb_setup_resp
 *   DESCRIPTION:
 *                 Fills the erab setup response 
 *   RETURNS    :
 *                 RRM_SUCCESS  on Success
 *                 RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et 
    rrm_ue_rbc_fill_erb_setup_resp 
(rrm_ue_context_t              *p_rrm_ue_context, 
 rrc_rrm_erb_setup_resp_t       *p_erb_setup_resp, 
 rrm_ue_response_et              response
 )
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    rrm_ue_erab_failed_item_list_t  *p_failed_erbs = RRM_PNULL;
    /*spr 7466 start*/
    U8 index=RRM_ZERO;
    /*spr 7466 end*/
    RRM_UT_TRACE_ENTER();
    do
    {

        RRM_MEMSET(p_erb_setup_resp, RRM_ZERO,(sizeof(rrc_rrm_erb_setup_resp_t)));
        p_erb_setup_resp->bitmask = RRM_ZERO;
        p_erb_setup_resp->ue_index = p_rrm_ue_context->ue_index;
        p_erb_setup_resp->response = response;

        /* fill erb setup resp only if response is other than failure*/  
        if (RRM_UE_FAILURE != response)
        {
            p_erb_setup_resp->bitmask |=
                RRM_ERB_SETUP_RESP_API_ADM_RADIO_RES_PRESENT;
            ret_val = fill_erb_setup_resp_radio_rsource_config
                (&(p_erb_setup_resp->radio_rsource_config),p_rrm_ue_context);
            /*SPR_19066_START*/
            if (RRM_SUCCESS == rrm_fill_ue_inactivity(&p_erb_setup_resp->ue_inactive_time_config, p_rrm_ue_context))
            {
                p_erb_setup_resp->bitmask |=
                    RRM_ERB_SETUP_RESP_API_UE_INACTIVE_TIME_PRESENT;
            }
            /*SPR_19066_END*/
#ifdef ENDC_ENABLED
            /*NR_DC Code Change Start*/
            /*check if is_sgnb_param_reqd then update cg_config_info*/
            if(p_rrm_ue_context->is_sgnb_param_reqd)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Fill cg config info");
                p_erb_setup_resp->bitmask |=
                    RRM_ERB_SETUP_RESP_API_SGNB_ADD_PARAM_PRESENT;
                rrm_fill_nr_cg_config_info(p_rrm_ue_context,
                        &( p_erb_setup_resp->sgnb_add_param),RRM_PNULL,RRM_PNULL);
                p_rrm_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_INITIATED;
            }
            /*NR_DC Code Change Stop*/
#endif
        }

        /* SPR 17600 Fix Start */
         /* Code Removed */
        /* SPR 17600 Fix Stop */
        else
        {
            p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
                (p_rrm_ue_context->current_procedure.p_erb_failed_list);
            
            /*SPR 16944 START*/
            if(p_failed_erbs != RRM_PNULL)
            {
            p_erb_setup_resp->bitmask |=
                RRM_ERB_SETUP_RESP_API_ADM_RADIO_RES_PRESENT;

            p_erb_setup_resp->bitmask |=
                RRM_ERB_SETUP_RESP_API_FAIL_CAUSE_PRESENT;
                /*SPR 16944 END*/
            if(p_failed_erbs->num_of_list > RRM_ZERO)
            {
                p_erb_setup_resp->radio_rsource_config.bitmask |=
                    RRM_ERAB_SETUP_RADIO_RES_CONFIG_DRB_FAILED_TO_ADD_LIST_PRESENT;
                fill_erb_setup_resp_drb_failed_to_add_list
                    (&(p_erb_setup_resp->radio_rsource_config.drb_failed_to_add_list),
                     p_failed_erbs);
            }
                /*SPR 16944 START*/
            }
            else
            {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_erb_failed_list is NULL");
            }
            /*SPR 16944 END*/
        }
        /*SPR 17370 START*/
        if(RRM_UE_FAILURE == response)
        {
            p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
                (p_rrm_ue_context->current_procedure.p_erb_failed_list);
            if(p_failed_erbs != RRM_PNULL)
            {
                if(p_failed_erbs->num_of_list > RRM_ZERO)
                {
                    if(RRM_SUCCESS == rrm_check_for_common_cause_in_failed_list(p_failed_erbs))
                    {
                        p_erb_setup_resp->bitmask |= RRM_ERB_SETUP_RESP_API_FAIL_CAUSE_PRESENT;
                        p_erb_setup_resp->fail_cause.type   = p_failed_erbs->erab_to_be_release_item[RRM_ZERO].cause.type;
                        p_erb_setup_resp->fail_cause.value  = p_failed_erbs->erab_to_be_release_item[RRM_ZERO].cause.value;
                    }
                    else
                    {
                        p_erb_setup_resp->bitmask |= RRM_ERB_SETUP_RESP_API_FAIL_CAUSE_PRESENT;
                        p_erb_setup_resp->fail_cause.type   = RADIO_NETWORK_LAYER_TYPE;
                        p_erb_setup_resp->fail_cause.value  = UNSPECIFIED;
                    }
                }
            }
            else
            {       
                p_erb_setup_resp->bitmask |= RRM_ERB_SETUP_RESP_API_FAIL_CAUSE_PRESENT;
                p_erb_setup_resp->fail_cause.type   = RADIO_NETWORK_LAYER_TYPE;
                p_erb_setup_resp->fail_cause.value  = UNSPECIFIED;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "p_erb_failed_list is NULL");
            }
        }
        /*SPR 17370 END*/
        /*spr 7466 start*/
        p_erb_setup_resp->erab_to_be_released_item_list.count =
            p_rrm_ue_context->erab_to_be_released_item_list.num_of_list;
        for(index=RRM_ZERO;index<p_rrm_ue_context->erab_to_be_released_item_list.num_of_list
                ;index++)
        {
            p_erb_setup_resp->erab_to_be_released_item_list.erab_to_be_release_item[index].
                erab_id = p_rrm_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].erab_id;

            p_erb_setup_resp->erab_to_be_released_item_list.erab_to_be_release_item[index].
                cause.type = p_rrm_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].cause.type;

            p_erb_setup_resp->erab_to_be_released_item_list.erab_to_be_release_item[index].
                cause.value = p_rrm_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].cause.value;
        }
        /*spr 7466 additional fix start*/
        if(p_erb_setup_resp->erab_to_be_released_item_list.count > RRM_ZERO)
        {
            p_erb_setup_resp->bitmask |= RRM_ERB_SETUP_RESP_API_ERAB_TO_BE_RELEASED_ITEM_LIST_PRESENT;
        }
        /*spr 7466 additional fix end*/
        p_rrm_ue_context->erab_to_be_released_item_list.num_of_list=RRM_ZERO;
        /*spr 7466 end*/

    } while(0);
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTIOb NAME: fill_erb_modify_resp_radio_rsource_config
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_erab_modify_radio_res_config
 *   DESCRIPTION:
 *                Fills the rrm_erab_modify_radio_res_config_t
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_erb_modify_resp_radio_rsource_config(
        rrm_erab_modify_radio_res_config_t *p_rrm_erab_modify_radio_res_config,
        rrm_ue_context_t                  *p_rrm_ue_context
        )
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    epc_params_t                             *p_epc_params = RRM_PNULL;   
    mac_layer_params_t                       *p_mac_layer_params = RRM_NULL;
    admission_control_info_t                 *p_admission_control_info 
                                             = RRM_NULL;
    rrm_ue_erab_failed_item_list_t           *p_failed_erbs = RRM_PNULL;
    U8                                       applicable_drx_index = 
                                                NO_DRX_PROFILE;
    U8                                       ul_mcs = RRM_ZERO;
    U8                                       dl_mcs = RRM_ZERO;
    rrm_cell_index_t                         cell_index = 
                                             p_rrm_ue_context->cell_index;
    rrm_ue_erab_setup_item_list_t            *p_successful_erbs = RRM_PNULL;
    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */
    rrmc_mac_config_t                        *p_rrmc_mac_config = RRM_NULL;
    U16                                       tpc_rnti_pucch_old = RRM_NULL;
    U16                                       tpc_rnti_pusch_old = RRM_NULL;
    rrm_bool_et                               is_re_config_ue = RRM_FALSE;
    U8 					      accumulation_enabled = RRM_ZERO;	
    p_rrmc_mac_config =
                 rrm_cellm_get_rrmc_mac_config(p_rrm_ue_context->cell_index);

    RRM_UT_TRACE_ENTER();
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);
    p_epc_params = rrm_cellm_get_erb_service_profile(cell_index);
    p_mac_layer_params = rrm_cellm_mac_layer_params(cell_index);
    /* Coverity 19oct Start : 54989 */
    RRM_ASSERT(RRM_PNULL != p_mac_layer_params);
    /* Coverity 19oct End : 54989 */
    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */
    p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);
    if(p_epc_params != RRM_PNULL && p_successful_erbs->num_of_list > RRM_ZERO )
    {
        p_rrm_erab_modify_radio_res_config->bitmask |= 
            RRM_ERAB_MODIFY_RADIO_RES_CONFIG_DRB_TO_MODIFY_LIST_PRESENT;
        fill_erb_modify_resp_drb_to_add_list
            (&(p_rrm_erab_modify_radio_res_config->drb_to_modify_list),
             p_rrm_ue_context,p_epc_params);
    }

    if(p_admission_control_info != RRM_PNULL)
    {

        ul_mcs =  p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs;

        accumulation_enabled = p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
            accumulation_enabled;

        dl_mcs = p_admission_control_info->snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs;
    }

    /*DRX parameters will be given if bit 5 of
      feature group indicator is set as one*/


    /**CLPC_MR_START*/
    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator present, "
                "checking for bit5"
                ,p_rrm_ue_context->ue_index);
        /*Check for fgi bit5 if fgi present*/
#ifndef LTE_EMBMS_SUPPORTED
        if((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE) &&
                /*Start:Bug 762*/
                ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE))
                /*End:Bug 762*/
#else
        if(((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE) &&
                ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE)) &&
            ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
        {
            applicable_drx_index = 
/* SPR 10450 Fix Start */
               rrm_find_drx_profile_to_send(p_rrm_ue_context);
/* SPR 10450 Fix End */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d], drx is disabled from oam or BIT 5 IS OFF"
                    ,p_rrm_ue_context->ue_index);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator not present, "
                "not checking for bit5"
                ,p_rrm_ue_context->ue_index);
        /*no need to check fgi bit5 if fgi is not present*/
#ifndef LTE_EMBMS_SUPPORTED
        if((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE))
#else
        if(((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE)) &&
            ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
        {
            applicable_drx_index =
/* SPR 10450 Fix Start */
               rrm_find_drx_profile_to_send(p_rrm_ue_context);
/* SPR 10450 Fix End */
        }
    }

    tpc_rnti_pucch_old = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch;
    tpc_rnti_pusch_old = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch;

    /* SPR:757- Coverity fix start */
    if(p_mac_layer_params != RRM_PNULL)
    {
    rrm_allocate_tpc_rnti_pucch(applicable_drx_index,
            p_rrm_ue_context,p_mac_layer_params);

    rrm_allocate_tpc_rnti_pusch(applicable_drx_index,
                        p_rrm_ue_context,p_mac_layer_params);
    }
    /* SPR:757- Coverity fix end */
    
    if((p_rrmc_mac_config->mac_power_control_enable.cqiSinrClpcPucchEnable ==
                RRM_TRUE) || (p_rrmc_mac_config->mac_power_control_enable.harqBlerClpcPucchEnable
                    == RRM_TRUE))
    {
        if((p_rrmc_mac_config->mac_power_control_enable.tpc_pdcch_ConfigPUCCH_enabled == RRM_TRUE)
                && (p_rrm_ue_context->rrm_ue_clpc_params.
                    tpc_rnti_pucch != RRM_NULL))
        {
            if(tpc_rnti_pucch_old != p_rrm_ue_context->rrm_ue_clpc_params.
                    tpc_rnti_pucch)
            {
                /**fill ue_reconfig for tpc pucch*/
                is_re_config_ue = RRM_TRUE;
            }
        }	
    }

    if((p_rrmc_mac_config->mac_power_control_enable.clpcPuschEnable == RRM_TRUE)
            && (accumulation_enabled == RRM_TRUE))
    {
        if((p_rrmc_mac_config->mac_power_control_enable.tpc_pdcch_ConfigPUSCH_enabled ==
                    RRM_TRUE) && (p_rrm_ue_context->rrm_ue_clpc_params.
                        tpc_rnti_pusch != RRM_NULL))
        {    
            if(tpc_rnti_pusch_old != p_rrm_ue_context->rrm_ue_clpc_params.
                    tpc_rnti_pusch)
            {
                /**fill ue reconfig for tpc pusch*/
                is_re_config_ue = RRM_TRUE;
            }
        }
    }

    /**CLPC_MR_END*/
    if(is_re_config_ue == RRM_TRUE)
    {
       /**build and send ue_reconfig_release for tpc rnti*/ 
       /**build and send ue_reconfig_setup for tpc rnti*/ 
    }

    if(p_mac_layer_params != RRM_PNULL)
    {
        p_rrm_erab_modify_radio_res_config->bitmask |= 
            RRM_ERAB_MODIFY_RADIO_RES_CONFIG_MAC_CONFIG_PRESENT;
        fill_erb_setup_resp_mac_config
            (&(p_rrm_erab_modify_radio_res_config->mac_config),
             p_mac_layer_params,p_rrm_ue_context,
             ul_mcs,dl_mcs,applicable_drx_index);
    }

    p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
        (p_rrm_ue_context->current_procedure.p_erb_failed_list);
    if(p_failed_erbs->num_of_list > RRM_ZERO)
    {
        p_rrm_erab_modify_radio_res_config->bitmask |= 
            RRM_ERAB_MODIFY_RADIO_RES_CONFIG_DRB_FAILED_TO_MODIFY_LIST_PRESENT;
        fill_erb_setup_resp_drb_failed_to_add_list
            (&(p_rrm_erab_modify_radio_res_config->drb_failed_to_modify_list),
             p_failed_erbs);
    }

    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rbc_fill_erb_modify_resp 
 *   INPUT      : p_rrm_ue_context,response
 *   OUTPUT     : p_erb_modify_resp
 *   DESCRIPTION:
 *                Fills the erab modify response 
 *
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et 
    rrm_ue_rbc_fill_erb_modify_resp 
(rrm_ue_context_t              *p_rrm_ue_context, 
 rrc_rrm_erab_modify_resp_t    *p_erb_modify_resp, 
 rrm_ue_response_et             response
)
{

    rrm_return_et                            ret_val = RRM_SUCCESS;
    rrm_ue_erab_failed_item_list_t           *p_failed_erbs = RRM_PNULL;
    /*SPR 22036 Fix Start*/
    U8 index =  RRM_ZERO;
    /*SPR 22036 Fix Stop*/

    RRM_UT_TRACE_ENTER();
    /*SPR 22036 Fix Start*/
        RRM_MEMSET(p_erb_modify_resp, RRM_ZERO,(sizeof(rrc_rrm_erab_modify_resp_t)));
        p_erb_modify_resp->ue_index = p_rrm_ue_context->ue_index;
        p_erb_modify_resp->response = response;

        if (RRM_UE_FAILURE != response)
        {
          p_erb_modify_resp->bitmask |=  
            RRM_ERB_MODIFY_RESP_API_ADM_RADIO_RES_PRESENT;
            fill_erb_modify_resp_radio_rsource_config
                (&(p_erb_modify_resp->radio_rsource_config),p_rrm_ue_context);
        }
        else
        {
            p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
                (p_rrm_ue_context->current_procedure.p_erb_failed_list);
            p_erb_modify_resp->bitmask |=
                            RRM_ERB_MODIFY_RESP_API_ADM_RADIO_RES_PRESENT;
            if(p_failed_erbs->num_of_list > RRM_ZERO)
            {
                p_erb_modify_resp->radio_rsource_config.bitmask |=
                    RRM_ERAB_MODIFY_RADIO_RES_CONFIG_DRB_FAILED_TO_MODIFY_LIST_PRESENT;
                fill_erb_setup_resp_drb_failed_to_add_list
                    (&(p_erb_modify_resp->radio_rsource_config.drb_failed_to_modify_list),
                     p_failed_erbs);
            }
        }

    p_erb_modify_resp->erab_to_be_released_item_list.count =
        p_rrm_ue_context->erab_to_be_released_item_list.num_of_list;
    for(index = RRM_ZERO; index<p_rrm_ue_context->erab_to_be_released_item_list.num_of_list; index++)
    {
        p_erb_modify_resp->erab_to_be_released_item_list.erab_to_be_release_item[index].erab_id = 
            p_rrm_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].erab_id;

        p_erb_modify_resp->erab_to_be_released_item_list.erab_to_be_release_item[index].cause.type = 
            p_rrm_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].cause.type;

        p_erb_modify_resp->erab_to_be_released_item_list.erab_to_be_release_item[index].cause.value = 
            p_rrm_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].cause.value;
    }
    if(p_erb_modify_resp->erab_to_be_released_item_list.count > RRM_ZERO)
    {
        p_erb_modify_resp->bitmask |= RRM_ERB_MODIFY_RESP_API_ERAB_TO_BE_RELEASED_ITEM_LIST_PRESENT;
    }
    p_rrm_ue_context->erab_to_be_released_item_list.num_of_list=RRM_ZERO;
    /*SPR 22036 Fix Stop*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rbc_fill_erb_release_resp 
 *   INPUT      : p_rrm_ue_context,response
 *   OUTPUT     : p_erb_release_resp
 *   DESCRIPTION:
 *                Fills the erab release response 
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 *****************************************************************************/

rrm_return_et 
    rrm_ue_rbc_fill_erb_release_resp 
                     (rrm_ue_context_t              *p_rrm_ue_context, 
                      rrc_rrm_erb_release_resp_t    *p_erb_release_resp, 
                      rrm_ue_response_et             response)
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    rrm_ue_erab_failed_item_list_t           *p_failed_erbs = RRM_PNULL;
    U16                                      drb_failed_count;
    rrm_ue_erab_setup_item_list_t            *p_successful_erbs = RRM_PNULL;
    /*SPR_19066_START*/
    U16                                      drb_count = RRM_ZERO;
    rrm_cell_context_t                       *p_cell_context = RRM_PNULL;
    U8                                       qos_index = RRM_ZERO;
    U8                                       drb_index = RRM_ZERO;
    U32                                      max_value_of_inactive_timer = RRM_ZERO;
    /*SPR_19066_END*/

    RRM_UT_TRACE_ENTER();
    do 
    {
        RRM_MEMSET(p_erb_release_resp,RRM_ZERO,sizeof(rrc_rrm_erb_release_resp_t));
        p_erb_release_resp->ue_index = p_rrm_ue_context->ue_index;
        p_erb_release_resp->response = response;
        p_successful_erbs = (rrm_ue_erab_setup_item_list_t*)
            (p_rrm_ue_context->current_procedure.p_erb_success_list);
        if( p_successful_erbs->num_of_list > RRM_ZERO )
        {
            p_erb_release_resp->bitmask |= 
                RRC_RRM_DRB_RELEASE_ITEM_LIST_PRESENT;
        }
        /*SPR_19066_START*/
        p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
        if (RRM_PNULL != p_cell_context)
        {
            for (drb_index = RRM_ZERO; (drb_index < p_rrm_ue_context->drb_configured.num_of_list) &&
                    (drb_index < RRM_MAX_NUM_DRB_PER_UE ) ; drb_index++)
            {
                for( (drb_count = RRM_ZERO);
                        (drb_count < p_successful_erbs->num_of_list) && (drb_count < RRM_MAX_NUM_DRB_PER_UE); 
                        (drb_count++))
                {
                    if (p_successful_erbs->erab_item[drb_count].erab_id == p_rrm_ue_context->drb_configured.erab_item[drb_index].erab_id)
                    {
                        p_erb_release_resp->drb_release_item_list.
                            drb_release_item[drb_count].erab_id = 
                            p_successful_erbs->erab_item[drb_count].erab_id;
                    }
                    else
                    {
                        for (qos_index = RRM_ZERO;
                                (qos_index < p_cell_context->epc_info.epc_params.num_valid_qos_profiles) &&
                                (qos_index < RRM_MAX_QCI) ; qos_index++)
                        {
                            if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].bitmask &
                                    RRMCM_RMIF_UE_INACTIVE_TIMER_PRESENT)
                            {
                                if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].qci == 
                                        p_rrm_ue_context->drb_configured.erab_item[drb_index].erab_level_qos_params.qci)
                                {
                                    if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config >
                                            max_value_of_inactive_timer)
                                    {
                                        max_value_of_inactive_timer =
                                            p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        p_erb_release_resp->ue_inactive_time_config = (max_value_of_inactive_timer * (RRM_ONE_THOUSAND_MS));
        p_erb_release_resp->bitmask |= RRM_RRM_ERB_RELEASE_RESP_UE_INACTIVE_TIME_PRESENT;
        /*SPR_19066_END*/
        p_erb_release_resp->drb_release_item_list.num_of_list = drb_count;

        p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
            (p_rrm_ue_context->current_procedure.p_erb_failed_list);
        if( p_failed_erbs->num_of_list > RRM_ZERO )
        {   
            p_erb_release_resp->bitmask |= 
                RRC_RRM_DRB_FAILED_TO_RELEASE_ITEM_LIST_PRESENT;
        }
        /*CID 55016*/
        /* Klocwork changes start 22 may */
        for ( drb_failed_count = RRM_ZERO ;(drb_failed_count < MAX_ERAB_COUNT)&&
                (drb_failed_count < p_failed_erbs->num_of_list) && 
                ( drb_failed_count < RRM_MAX_NUM_DRB_PER_UE) ; 
                drb_failed_count++ )
            /* Klocwork changes end 22 may */
        {
            p_erb_release_resp->drb_failed_to_release_item_list.
                drb_failed_to_release_item[drb_failed_count].erab_id = 
                p_failed_erbs->erab_to_be_release_item[drb_failed_count].
                erab_id;
            p_erb_release_resp->drb_failed_to_release_item_list.
                drb_failed_to_release_item[drb_failed_count].cause.type = 
                p_failed_erbs->erab_to_be_release_item[drb_failed_count].cause.
                type;

            p_erb_release_resp->drb_failed_to_release_item_list.
                drb_failed_to_release_item[drb_failed_count].cause.value = 
                p_failed_erbs->erab_to_be_release_item[drb_failed_count].cause.
                value;  
        }	   
        p_erb_release_resp->drb_failed_to_release_item_list.num_of_list = 
            drb_failed_count;

    }while(RRM_ZERO);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rbc_fill_ue_release_resp
 *   INPUT      : cell_index,ue_index,response
 *   OUTPUT     : p_ue_release_resp
 *   DESCRIPTION:
 *                Fills the ue release response
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 *****************************************************************************/

rrm_return_et 
    rrm_ue_rbc_fill_ue_release_resp 
(
         /*SPR 17777 +-*/
 rrm_ue_index_t                ue_index, 
 rrc_rrm_ue_release_resp_t     *p_ue_release_resp, 
 rrm_ue_response_et            response
 )
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    do
    {
        p_ue_release_resp->ue_index = ue_index;
        p_ue_release_resp->response = response;
    } while(RRM_ZERO);
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
*   FUNCTION NAME: rrm_rrc_process_ue_transmission_mode_selection
*   INPUT       : p_rrm_ue_context,p_rrm_antenna_information
*   OUTPUT      : none
*   DESCRIPTION:
*                 Select the UE transmission mode
*   RETURNS     :
*                 RRM_SUCCESS on Success
*                 RRM_FAILURE on Failure
******************************************************************************/
rrm_return_et
rrm_rrc_process_ue_transmission_mode_selection(
        const   rrm_ue_context_t                *p_rrm_ue_context,
        rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information)
{
   rrm_return_et       ret_val = RRM_SUCCESS;
   U8                  port = RRM_NULL;
   rrm_ue_category_et  ue_category = UE_CATEGORY_NONE;

   RRM_UT_TRACE_ENTER();

   do
   {
     if((RRM_NULL == p_rrm_antenna_information) || (RRM_NULL == p_rrm_ue_context))
     {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "NULL pointer "
        "for UE Context,Failed to select the Transmission Mode");

	ret_val = RRM_FAILURE;
	break;
     }

     /*get antenna port*/
     if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_rrm_ue_context->cell_index,&port))
     {
   	if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
   	{
                /* coverity : 16540 , rel2.0.1 */
	    /* ue category */ /* R-10 Change : Start */
	    ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_rrm_ue_context);
	    /* ue category */ /* R-10 Change : End */
   	} 


	p_rrm_antenna_information->bitmask = RRM_ZERO; /*code book subset restriction is not present*/
        p_rrm_antenna_information->ue_transmit_antenna_selection.bitmask = RRM_ZERO;
   	/*check for number of antenna*/
   	if(ANTENNA_PORTS_COUNT_AN1 == port)
   	{
        	/*set transmission mode to 1*/
        	p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM1;
		
   	}
   	else if(ANTENNA_PORTS_COUNT_AN2 == port)
   	{
           	if((ue_category >= UE_CATEGROY_2) && (ue_category <= UE_CATEGORY_8))						  
           	{
                	/*set the trenamission mode to 3*/
                	p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM3;

                	p_rrm_antenna_information->bitmask |= RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;
                	
                        p_rrm_antenna_information->codebook_subset_restriction.type = N2_TX_ANTENNA_TM3;
		
                	RRM_MEMSET(p_rrm_antenna_information->codebook_subset_restriction.\
			value,RRM_NULL,sizeof(p_rrm_antenna_information->codebook_subset_restriction.value));
                	p_rrm_antenna_information->codebook_subset_restriction.value[RRM_ZERO] = RRM_CODEBOOK_SUBSET_VAL << RRM_TWO;

           	}
           	else if((ue_category == UE_CATEGORY_1) || (UE_CATEGORY_NONE == ue_category))
	        {
                	p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM2;
        	}

   	}
   	else if(ANTENNA_PORTS_COUNT_AN4 == port)
   	{
        	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Antenna Port[%d] for [UE:%d]"
	        "not supported,Failed to select the Transmission Mode",port,p_rrm_ue_context->ue_index);	
   	}
     }
     else
     {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Select Transmossion Mode"
	"for [UE:%d]" ,p_rrm_ue_context->ue_index);
     }

   }while(RRM_ZERO);

   RRM_UT_TRACE_EXIT();

   return ret_val;

}



/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_admission_resp
 *   INPUT      : cell_index,ue_index,p_rrm_ue_cntxt,transaction_id
 *   OUTPUT     : 
 *   DESCRIPTION:
 *                Fills and sends ue admission response
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_ue_admission_resp(
        /*SPR_15323 start*/
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
        /*SPR_15323 end*/
        rrm_ue_response_et  response,
        rrm_ue_context_t *p_rrm_ue_cntxt,
        U16              transaction_id,
        /*SPR 15439 Fix Start*/
        rrc_ue_adm_resp_fail_cause_et ue_adm_fail_cause
        /*SPR 15439 Fix End*/
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_admission_resp_t     *p_rrc_rrm_ue_admission_resp = RRM_PNULL;
    rrm_cell_context_t              *p_cell_ctxt = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ue_admission_resp = (rrc_rrm_ue_admission_resp_t*)
        rrm_mem_get(sizeof(rrc_rrm_ue_admission_resp_t));
    if (RRM_PNULL == p_rrc_rrm_ue_admission_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }
    /*SPR_15323 start*/
    /*SPR 15439 Fix Start - Last parameter added*/
    rrm_rrc_fill_ue_admission_resp
        (p_rrm_ue_rrc_msg, p_rrc_rrm_ue_admission_resp,
         p_rrm_ue_cntxt,response,ue_adm_fail_cause);
    /*SPR 15439 Fix End*/
    /*SPR_15323 end*/
    /*KPI: start ue_adm fail*/
    if (RRM_UE_FAILURE == response)
    {
        /*SPR_15323 start*/
        p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_rrc_msg->cell_index);
        /*SPR_15323 end*/
        /*cov_fix_65818_start*/
        if (RRM_PNULL == p_cell_ctxt )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Don't update num_of_ue_admission_fail counter beacuse p_cell_ctxt is null");
            /*CID 66689:start*/
            RRM_MEM_FREE(p_rrc_rrm_ue_admission_resp); 
            /*CID 66689:end*/
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /*cov_fix_65818_end*/
        p_cell_ctxt->kpi_stat.kpi.num_of_ue_admission_fail += RRM_ONE;
    }
    /*KPI: end ue_adm fail*/
    /*SPR_15323 start*/
    ret_val = rrm_il_send_rrc_rrm_ue_admission_resp
        (p_rrc_rrm_ue_admission_resp,
         RRM_MODULE_ID,RRC_MODULE_ID,transaction_id, p_rrm_ue_rrc_msg->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d]\
                Failed to send UE ADMISSION RESPONSE",p_rrm_ue_rrc_msg->ue_index);

    }
    else
    {
        /*SPR 17083 START*/
        /*Code deleted*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"Successfully send UE ADMISSION RESPONSE with response = [%d]",response);
        /*SPR 17083 END*/
    }
    /* SPR 15323 end */
    RRM_MEM_FREE(p_rrc_rrm_ue_admission_resp);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_erb_setup_resp
 *   INPUT      : p_rrm_ue_cntxt,transaction_id
 *   OUTPUT     : response
 *   DESCRIPTION:
 *                 Fills and sends erb setup response
 *
 *   RETURNS    :
 *                 RRM_SUCCESS  on Success
 *                 RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_erb_setup_resp(
        rrm_ue_response_et response,
        rrm_ue_context_t *p_rrm_ue_cntxt,
        U16              transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    /* Fix for coverity, CID:11212 [Prasant]*/
    rrc_rrm_erb_setup_resp_t       *p_rrc_rrm_erb_setup_resp = RRM_PNULL;
    
    /* UE Positioning start */
    rrm_bool_et             is_ecid_meas_resp     = RRM_FALSE;
    rrm_meas_ecid_resp_et   ecid_meas_resp_action = RRM_ECID_MEAS_CONTINUE;
    U8                      meas_id               = RRM_ZERO;
    /* UE Positioning end */

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_erb_setup_resp  = (rrc_rrm_erb_setup_resp_t *)\
                                  rrm_mem_get(sizeof(rrc_rrm_erb_setup_resp_t));
    if (RRM_PNULL == p_rrc_rrm_erb_setup_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory "
                "for RRC_RRM_ERAB_SETUP_RESP");
        return RRM_FAILURE;
    }




    ret_val = rrm_ue_rbc_fill_erb_setup_resp(p_rrm_ue_cntxt,
            p_rrc_rrm_erb_setup_resp,response);

    /* Raise Event - RRM_EVENT_LOCAL_EVENT_ERAB_SETUP_INFO  Start*/
     rrm_raise_event_erab_setup_info(p_rrm_ue_cntxt);
    /* Raise Event - RRM_EVENT_LOCAL_EVENT_ERAB_SETUP_INFO  Ends*/


    ret_val = rrm_il_send_rrc_rrm_erb_setup_resp(p_rrc_rrm_erb_setup_resp,
                          RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_rrm_ue_cntxt->cell_index);
  
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d], Failed to send ERB "
                  "SETUP RESPONSE" ,p_rrm_ue_cntxt->ue_index);
        p_rrm_ue_cntxt->meas_status = RRM_MEAS_CONFIG_RESP_FAILED;
        if (p_rrc_rrm_erb_setup_resp->radio_rsource_config.bitmask & \
                           RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_CONFIG_PRESENT)
        {
            update_meas_config_status(p_rrm_ue_cntxt,
                                     &is_ecid_meas_resp,
                                     &meas_id,
                                     &ecid_meas_resp_action);
        }

    }
    else
    {  
        /*SPR 18241 START*/
        if(response != RRM_UE_FAILURE)
        {    
            RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_cntxt->current_procedure, RRM_UE_ERB_SETUP_ONGOING);
        }
        /*SPR 18241 END*/

        /* Raise Event - RRM_EVENT_LOCAL_ERAB_SETUP_READY START */
        rrm_raise_event_erab_setup_ready(p_rrm_ue_cntxt);
        /* Raise Event - RRM_EVENT_LOCAL_ERAB_SETUP_READY END */

        p_rrm_ue_cntxt->meas_status = RRM_MEAS_CONFIG_RESP_SUCCESS;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"[UE:%d], Successfully sent ERB "
                  "SETUP RESPONSE" ,p_rrm_ue_cntxt->ue_index);
        if (p_rrc_rrm_erb_setup_resp->radio_rsource_config.bitmask & \
                           RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_CONFIG_PRESENT)
        {
            update_meas_config_status(p_rrm_ue_cntxt,
                                     &is_ecid_meas_resp,
                                     &meas_id,
                                     &ecid_meas_resp_action);
        }
    }

    RRM_MEM_FREE(p_rrc_rrm_erb_setup_resp);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*SPR 5690 - lossy ho start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_erab_lossy_ho_list
 *   INPUT      : p_ue_context,p_rrc_rrm_ho_cmd_resp
 *   OUTPUT     : none
 *   DESCRIPTION: 
 *                Fills lossy ho erab list
 *   RETURNS    : none
 ******************************************************************************/
rrm_void_t
rrm_ue_fill_erab_lossy_ho_list
(
rrc_rrm_ue_ho_command_response_t  *p_rrc_rrm_ho_cmd_resp,
rrm_ue_context_t                  *p_ue_context
)
{
    RRM_UT_TRACE_ENTER();
    U8 index = RRM_ZERO;
    U8 erab_count = RRM_ZERO;
    U8 qos_count = RRM_ZERO;
    U8 qci = RRM_ZERO;
    epc_params_t *p_epc_params = RRM_PNULL;
    p_epc_params = rrm_cellm_get_erb_service_profile(p_ue_context->cell_index);
    for(index = RRM_ZERO;
        index < p_ue_context->drb_configured.num_of_list;
        index++)
    {
        if(UM_MODE == p_ue_context->drb_configured.erab_item[index].data_transfer_mode)
        {
           qci = p_ue_context->drb_configured.erab_item[index].
                 erab_level_qos_params.qci;
           for(qos_count = RRM_ZERO ;
               qos_count < p_epc_params->num_valid_qos_profiles; qos_count++)
           {
               if(qci == p_epc_params->qos_config_params[qos_count].qci)
               {
                   if(RRMCM_RMIF_LOSSLESS_HO_REQ_PRESNET &
                      p_epc_params->qos_config_params[qos_count].bitmask )
                   {
                       if(RRM_FALSE ==
                          p_epc_params->qos_config_params[qos_count].lossless_ho_required)
                       {
                           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                   "ERAB_ID[%d], filled in lossy ho list",
                                           p_ue_context->drb_configured.erab_item[index].erab_id);
                           p_rrc_rrm_ho_cmd_resp->ho_command_response.erab_lossy_ho_list.
                           erab_id[erab_count++]=
                           p_ue_context->drb_configured.erab_item[index].erab_id;
                       }
                   }
                   else /*if lossless_ho_required is not present consider it as lossy*/
                   {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                               "ERAB_ID[%d], filled in lossy ho list",
                                      p_ue_context->drb_configured.erab_item[index].erab_id);
                        p_rrc_rrm_ho_cmd_resp->ho_command_response.erab_lossy_ho_list.
                        erab_id[erab_count++]=
                        p_ue_context->drb_configured.erab_item[index].erab_id;
                   }
               }
           }
        }
    }
    if(RRM_ZERO != erab_count)
    {
        p_rrc_rrm_ho_cmd_resp->ho_command_response.erab_lossy_ho_list.count = erab_count;
        p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |= HO_RESPONSE_ERAB_LOSSY_HO_LIST_PRESENT;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "No lossy erab found");
    }
    RRM_UT_TRACE_EXIT();
}
/*SPR 5690 - lossy ho end*/
/*klock_works_changes_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_command_resp_params 
 *   INPUT      :   p_rrm_proc_ho_cmd_req,p_rrc_rrm_ho_cmd_resp,p_ue_context
 *   OUTPUT     : 
 *   DESCRIPTION:   Fills the ho command response 
 *   RETURNS    :   None
 ******************************************************************************/
rrm_void_t
rrm_ue_fill_ho_command_resp_params
(
 rrm_ue_proc_ho_command_request_t    *p_rrm_proc_ho_cmd_req,
 rrc_rrm_ue_ho_command_response_t    *p_rrc_rrm_ho_cmd_resp,
 rrm_ue_context_t                    *p_ue_context
)
{

    idle_mode_mobility_params_t                  *p_idle_mode = RRM_PNULL;
    inter_rat_ncl_t          *p_irat_ncl = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_idle_mode_cdma = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_freq_cells = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

            /* CDMA2000 changes start */
            /* Index : 0-1XRTT 1-HRPD */
            /* Check if HO has been sent for both (1XRTT, HRPD Cell) 
               if sent for both i.e. Concurrent HO, then Check for status*/
            if(p_ue_context->cdma2000_capabilities.is_ecsfb_conc_ho_present)
            {
                if((RRM_TRUE == p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
                        ho_required_sent_status) && (RRM_TRUE == p_ue_context->cdma2000_ho_cmd_resp.
                            cdma2000_hrpd_params.ho_required_sent_status))
            {
                if((CDMA2000_HO_SUCCESS == p_rrm_proc_ho_cmd_req->cdma2000_ho_status[RRM_ZERO]) &&
                        (CDMA2000_HO_FAILURE == p_rrm_proc_ho_cmd_req->cdma2000_ho_status[RRM_ONE]))
                {
                    if((RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == 
                                p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.ho_req_identifier) &&
                            (RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == 
                             p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_req_identifier))
                    {
                        /* 1XRTT-Success HRPD-Failure */
                        p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                            band_class = p_ue_context->cdma2000_ho_cmd_resp.
                            cdma2000_1xrtt_params.band_class;
                        p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                            arfcn = p_ue_context->cdma2000_ho_cmd_resp.
                            cdma2000_1xrtt_params.arfcn;

                        p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |=
                            HO_RESPONSE_CARRIER_FREQ_CDMA2000_PRESENT;
                    }
                    else if((RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL == 
                                p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.ho_req_identifier) &&
                            (RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL == 
                             p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_req_identifier))
                    {
                        /* Checked if sent for DAHO Cell */
                        p_idle_mode = rrm_cellm_get_idle_mode_params(p_ue_context->cell_index);
                        p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);
                        p_idle_mode_cdma = &(p_idle_mode->idle_mode_mobility_irat_cdma_params);

                        p_cdma2000_freq_cells = rrm_ue_match_hrpd_daho_cell_from_ncl(p_ue_context,
                                p_irat_ncl, p_idle_mode_cdma);

			/*coverity 25203, rel2.0.1 aditya*/
                        if(RRM_PNULL != p_cdma2000_freq_cells)
                        {
                            p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                                band_class = p_cdma2000_freq_cells->band_class;
                            p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                                arfcn = p_cdma2000_freq_cells->arfcn;

                            p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |=
                                HO_RESPONSE_CARRIER_FREQ_CDMA2000_PRESENT;
                        }
                    }
                }
              }
              else if((RRM_TRUE == p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
                        ho_required_sent_status) && (RRM_FALSE == p_ue_context->cdma2000_ho_cmd_resp.
                            cdma2000_hrpd_params.ho_required_sent_status))
              {
                  if((RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == 
                              p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.ho_req_identifier) &&
                          (RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == 
                           p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_req_identifier))
                  {
                      /* 1XRTT-Success HRPD-Failure */
                      p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                          band_class = p_ue_context->p_meas_obj_cdma2000_info->
                          meas_obj_cdma2000_cell_info_hrpd[RRM_ZERO].cdma2000_ncl_info_list[RRM_ZERO].
                          band_class;
                      p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                          arfcn = p_ue_context->p_meas_obj_cdma2000_info->
                          meas_obj_cdma2000_cell_info_hrpd[RRM_ZERO].cdma2000_ncl_info_list[RRM_ZERO].
                          arfcn;

                      p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |=
                          HO_RESPONSE_CARRIER_FREQ_CDMA2000_PRESENT;
                  }
                  else if((RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL == 
                              p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.ho_req_identifier) &&
                          (RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL == 
                           p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_req_identifier))
                  {
                      /* Checked if sent for DAHO Cell */
                      p_idle_mode = rrm_cellm_get_idle_mode_params(p_ue_context->cell_index);
                      p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);
                      p_idle_mode_cdma = &(p_idle_mode->idle_mode_mobility_irat_cdma_params);

                      p_cdma2000_freq_cells = rrm_ue_match_hrpd_daho_cell_from_ncl(p_ue_context,
                              p_irat_ncl, p_idle_mode_cdma);
		      
		      /*coverity 25203, check for null corrected, aditya rel1.3.1*/
                      if(RRM_PNULL != p_cdma2000_freq_cells)
                      {
                          p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                              band_class = p_cdma2000_freq_cells->band_class;
                          p_rrc_rrm_ho_cmd_resp->ho_command_response.carrier_freq_cdma2000.
                              arfcn = p_cdma2000_freq_cells->arfcn;

                          p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |=
                              HO_RESPONSE_CARRIER_FREQ_CDMA2000_PRESENT;
                      }
		      else
		      {
			 RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "p_cdma2000_freq_cells is NULL");
		      }
                  }
              }
            }
    RRM_UT_TRACE_EXIT();
}
/*klock_works_changes_end*/

/*MC, MR & HO  START */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_command_resp 
 *   INPUT      : p_rrm_proc_ho_cmd_req,p_rrc_rrm_ho_cmd_resp,p_ue_context, response
 *   OUTPUT     : 
 *   DESCRIPTION:
 *               Fills the ho command response 
 *   RETURNS    :
 *                RRM_SUCCESS  on Success
 *                RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et 
    rrm_ue_fill_ho_command_resp
(
 rrm_ue_proc_ho_command_request_t    *p_rrm_proc_ho_cmd_req, 
 rrc_rrm_ue_ho_command_response_t  *p_rrc_rrm_ho_cmd_resp, 
 rrm_response_t              response,
 rrm_ue_context_t					*p_ue_context
 )
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    U8						erab_index = RRM_ZERO;
    U8						erab_id = RRM_ZERO;
    U8						ue_erb_index = RRM_ZERO;
    rrm_ue_ho_erab_info_list_t	*p_erb_sub_fwd_list = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t *p_erb_configured_list = RRM_PNULL;
    rrc_erab_info_list_t     *p_cmd_rsp_erb_list = RRM_PNULL;
    U8						accepted_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    do
    {

        RRM_MEMSET(p_rrc_rrm_ho_cmd_resp, RRM_ZERO,(sizeof(rrc_rrm_ue_ho_command_response_t)));
        /* SPR-5118 start */
        p_rrc_rrm_ho_cmd_resp->ue_index = p_rrm_proc_ho_cmd_req->ue_index;
        /* SPR-5118 end */
        p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask = RRM_ZERO;

        p_rrc_rrm_ho_cmd_resp->ho_command_response.response = response.response;
        if(p_rrc_rrm_ho_cmd_resp->ho_command_response.response == RRM_FAILURE)
        {
            p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask = HO_RESPONSE_CAUSE_PRESENT;
            p_rrc_rrm_ho_cmd_resp->ho_command_response.rrm_cause.type = response.cause.type; 
            p_rrc_rrm_ho_cmd_resp->ho_command_response.rrm_cause.value= response.cause.value; 
        }
        else
        {
            if(p_rrm_proc_ho_cmd_req->bitmask & \
                    RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT)
            {

                /* Loss-less data transfer changes start */
                p_erb_sub_fwd_list = \
                                     &(p_rrm_proc_ho_cmd_req->erab_sub_to_fwd_list);

                p_cmd_rsp_erb_list = \
                                     &(p_rrc_rrm_ho_cmd_resp->ho_command_response.\
                                             erab_sub_to_fwd_list);

                for(;erab_index < p_erb_sub_fwd_list->erab_count; erab_index++)
                {
                    erab_id = p_erb_sub_fwd_list->drb_sub_to_fwd[erab_index].erab_id;
                    p_erb_configured_list = &(p_ue_context->drb_configured);
                    for(ue_erb_index=RRM_ZERO; ue_erb_index < p_erb_configured_list->num_of_list; \
                            ue_erb_index++)
                    {
                        /* Bug-10188 Fix: Start */
                        if((erab_id == p_erb_configured_list->\
                                    erab_item[ue_erb_index].erab_id))
                        /* Bug-10188 Fix: End */
                        {
                            p_cmd_rsp_erb_list->drb_sub_to_fwd[accepted_count].\
                                erab_id = erab_id;

                            p_cmd_rsp_erb_list->drb_sub_to_fwd[accepted_count].\
                                forward_direction = p_erb_sub_fwd_list->\
                                drb_sub_to_fwd[erab_index].forward_direction;

                            accepted_count++;

                        } /*If erab_id matches && dl_fwding is set */
                    } /*For each DRB configured */
                } /*For each erab subjected to FWD list */
                if(accepted_count)
                {
                    p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |= \
                                                                          ERAB_LIST_PRESENT;

                    p_cmd_rsp_erb_list->erab_count = accepted_count;
                }
                /*RRM_MEMCPY(&p_rrc_rrm_ho_cmd_resp->ho_command_response.erab_sub_to_fwd_list,
                  &p_rrm_proc_ho_cmd_req->erab_sub_to_fwd_list,
                  sizeof(rrc_erab_info_list_t));*/
                /* Loss-less data transfer changes end */

                /*raise the event RRM_EVENT_LOCAL_HO_OUT_EXEC_INFO */

                rrm_raise_event_ho_out_exec_info(p_ue_context);

                /* end of raising event RRM_EVENT_LOCAL_HO_OUT_EXEC_INFO */
            }
            if(p_ue_context->ue_context_mod_req.bitmask & RRM_UEM_CTX_CSF_INDICATOR_PRESENT)
            {
                p_rrc_rrm_ho_cmd_resp->ho_command_response.bitmask |= 
                          HO_RESPONSE_CS_FALLBACK_INDICATOR_PRESENT;
	            p_rrc_rrm_ho_cmd_resp->ho_command_response.cs_fallback_indicator 
                    = p_ue_context->ue_context_mod_req.csf_indicator;
            }

            /*klock_works_changes_start*/
             rrm_ue_fill_ho_command_resp_params( p_rrm_proc_ho_cmd_req, p_rrc_rrm_ho_cmd_resp, p_ue_context);            
            /*klock_works_changes_end*/
            

            /*SPR 5690 - lossy ho start*/
            rrm_ue_fill_erab_lossy_ho_list(p_rrc_rrm_ho_cmd_resp,
                                           p_ue_context);
            /*SPR 5690 - lossy ho end*/
        }
    } while(0);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ho_cancel_req
 *   INPUT      : p_ue_context,ue_index,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho cancel request 
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_ho_cancel_req(
	rrm_ue_context_t *p_ue_context,
        U16 ue_index,
        U8 transaction_id
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ho_cancel_req_t         rrc_rrm_ho_cancel_req;
    RRM_UT_TRACE_ENTER();

    

   /* SPR 14486 Fix - Removed sending scell reactivation */

    rrc_rrm_ho_cancel_req.ue_index = ue_index;
    rrc_rrm_ho_cancel_req.rrm_cause.type = RADIO_NETWORK_LAYER_TYPE;
    /*SPR 16609 FIX START*/
    if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
         (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
           (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
    {
        rrc_rrm_ho_cancel_req.rrm_cause.value = RRM_X2AP_UNSPECIFIED;
    }
    else
    {
        rrc_rrm_ho_cancel_req.rrm_cause.value = HANDOVER_CANCELLED;
    }
    /*SPR 16609 FIX END*/
    
    ret_val = rrm_il_send_rrc_rrm_ho_cancel_req(&rrc_rrm_ho_cancel_req,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_update_kpi_ho_fail_stats
 *   INPUT      : p_ue_context, p_cell_ctxt
 *   OUTPUT     : None
 *   DESCRIPTION: Update the KPI for HO fail
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_void_t
rrm_update_kpi_ho_fail_stats(rrm_ue_context_t    *p_ue_context,
                      rrm_cell_context_t  *p_cell_ctxt)
{
    RRM_UT_TRACE_ENTER();
    switch(p_ue_context->ho_typ)
    {
        /* SPR 12705 start */
        case RRM_HANDOVER_TYPE_LTE_TO_UTRAN:
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_utran_ho_fail += RRM_ONE;
            }
            break;
        case RRM_HANDOVER_TYPE_LTE_TO_GERAN:
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_geran_ho_fail += RRM_ONE;
            }
            break;
        case RRM_HANDOVER_TYPE_UTRAN_TO_LTE:
        case RRM_HANDOVER_TYPE_GERAN_TO_LTE:
            break;
        case RRM_HANDOVER_TYPE_INTRA_CELL:
        case RRM_HANDOVER_TYPE_INTRA_LTE_X2:
        case RRM_HANDOVER_TYPE_INTER_CELL:
        case RRM_HANDOVER_TYPE_INTRA_LTE_S1:
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_eutran_ho_fail++;
            }
            break;
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT:
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD:
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD:
        case RRM_HANDOVER_TYPE_CCO:
            break;
        default:
            break;
            /* SPR 12705 end */
    }
   RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_update_kpi_ho_attempt_stats
 *   INPUT      : p_ue_context, p_cell_ctxt
 *   OUTPUT     : None
 *   DESCRIPTION: Update the KPI for HO fail
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_void_t
rrm_update_kpi_ho_attempt_stats(rrm_ue_context_t    *p_ue_context,
                      rrm_cell_context_t  *p_cell_ctxt)
{
    RRM_UT_TRACE_ENTER();
    /* SPR 12705 start */
    switch(p_ue_context->ho_typ)
    {
        case RRM_HANDOVER_TYPE_LTE_TO_UTRAN:
        {
            p_cell_ctxt->kpi_stat.kpi.num_of_utran_ho_attempt += RRM_ONE;
        }
        break;
        case RRM_HANDOVER_TYPE_LTE_TO_GERAN:
        {
            p_cell_ctxt->kpi_stat.kpi.num_of_geran_ho_attempt += RRM_ONE;
        }
        break;
        case RRM_HANDOVER_TYPE_UTRAN_TO_LTE:
        case RRM_HANDOVER_TYPE_GERAN_TO_LTE:
            break;
        case RRM_HANDOVER_TYPE_INTRA_CELL:
        case RRM_HANDOVER_TYPE_INTRA_LTE_X2:
        case RRM_HANDOVER_TYPE_INTER_CELL:
        case RRM_HANDOVER_TYPE_INTRA_LTE_S1:
        {
            p_cell_ctxt->kpi_stat.kpi.num_of_eutran_ho_attempt++;
        }
        break;
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT:
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD:
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD:
        case RRM_HANDOVER_TYPE_CCO:
            break;
        default:
            break;
            /* SPR 12705 end */
    }
   RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ho_cmd_resp
 *   INPUT      : p_rrm_proc_ho_cmd_req,transaction_id,p_ue_context, response
 *   OUTPUT     : p_response
 *   DESCRIPTION:
 *       Fills and sends ho cmd response
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_ho_cmd_resp(
        rrm_response_t response,
        rrm_ue_proc_ho_command_request_t    *p_rrm_proc_ho_cmd_req,
        U8 transaction_id,
	rrm_ue_context_t *p_ue_context
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_ho_command_response_t  rrc_rrm_ho_cmd_resp;
    rrm_cell_context_t              *p_cell_ctxt= RRM_PNULL; 

    RRM_UT_TRACE_ENTER();

    rrm_ue_fill_ho_command_resp(p_rrm_proc_ho_cmd_req,
            &rrc_rrm_ho_cmd_resp,response,p_ue_context);
    /*KPI:start ho success and fail */
    p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /*cov_fix_65777_start*/
    if (RRM_PNULL == p_cell_ctxt )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*cov_fix_65777_end*/
    /*Klockwork_fix_start*/
    /* SPR 12705 start */
    if (RRM_FAILURE == response.response)
    {
        rrm_update_kpi_ho_fail_stats(p_ue_context,p_cell_ctxt);
    }
    /* SPR 12705 end */
    /*Klockwork_fix_end*/
    /*KPI:end*/
    ret_val = rrm_il_send_rrc_rrm_ue_ho_command_response(&rrc_rrm_ho_cmd_resp,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d]Failed to send HO COMMAND "
                "RESPONSE" ,p_rrm_proc_ho_cmd_req->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"[UE:%d]Successfully sent HO "
                "COMMAND RESPONSE" ,p_rrm_proc_ho_cmd_req->ue_index);

        /*Raising event LOCAL_HO_OUT_EXEC_ATTEMPT-START 
          When an outgoing handover execution UE task is requested*/
        rrm_raise_event_ho_out_exec_attempt();
         /*SPR 17777 +-*/
        /*Raising event LOCAL_HO_OUT_EXEC_ATTEMPT-END*/
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_rrc_container 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_rrc_container
 *   DESCRIPTION:
 *       Fills the rrc container 
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et 
    rrm_ue_fill_rrc_container 
(
    rrm_rrc_container_t           *p_rrm_rrc_container,
    rrm_ue_context_t              *p_rrm_ue_context 
)
{

    rrm_return_et                            ret_val = RRM_SUCCESS;
    U8                                       count=RRM_ZERO;
    RRM_UT_TRACE_ENTER();
 
    p_rrm_rrc_container->bitmask = RRM_RRC_CONTAINER_TARGET_CELL_IDENTITY_LIST_PRESENT;
    p_rrm_rrc_container->target_cell_identity_list.target_cell_count = RRM_ONE;

    for(count = RRM_ZERO;count <CELL_ID_OCTET_SIZE;count++) {
         p_rrm_rrc_container->target_cell_identity_list.
                    target_cell_identity[RRM_ZERO].target_cell_Id[count] = 
                         p_rrm_ue_context->ho_params.target_cell_identity[count];
    }

     
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CSR 55938: code changes start */
/****************************************************************************
 * Function Name  : rrm_add_source_eutran_cell_info_in_ue_history
 * Inputs         : p_ue_history
 *                : UE context information
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : Updates the history information
 ****************************************************************************/
void rrm_add_source_eutran_cell_info_in_ue_history
(
 ue_history_t     *p_ue_history,
 rrm_ue_context_t *p_ue_context
 )
{
    U8         count        = RRM_ZERO;
    signed int elapsed_time = RRM_ZERO;
    U8         loop         = RRM_ZERO;
    U8         num_mnc_digit= RRM_ZERO;

    rrm_cell_context_t                      *p_cell_ctxt = RRM_PNULL;

    last_visited_e_utran_cell_information_t  eutra_cell;

    RRM_UT_TRACE_ENTER();
    if (NULL ==  p_ue_context )
    {
        RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
                RRM_ERROR,
                "UE Context is NULL");
        return;
    }
    if (NULL ==  p_ue_history )
    {
        RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
                RRM_ERROR,
                "p_ue_history is NULL");
        return;
    }
    RRM_MEMSET(&eutra_cell, RRM_ZERO, sizeof(last_visited_e_utran_cell_information_t));
    p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /*cov_fix_65805_start*/
    if (RRM_PNULL == p_cell_ctxt )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /*cov_fix_65805_end*/
    eutra_cell.global_cell_id.plmn_identity.presence_bitmask =
        PLMN_IDENTITY_MCC_PRESENCE_FLAG;
    RRM_MEMCPY(&eutra_cell.global_cell_id.plmn_identity.mcc,
            &p_cell_ctxt->global_cell_id.primary_plmn_id.mcc,
            MAX_MCC_DIGITS);

    num_mnc_digit = p_cell_ctxt->global_cell_id.primary_plmn_id.num_mnc_digit;

    if (num_mnc_digit > MAX_MNC_OCTET_SIZE) {
        RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
                RRM_ERROR,
                "[UE:%d] Invalid MNC Digit count (%d),"
                "Should be less than %d, Dropping the remaining digits",
                p_ue_context->ue_index,
                num_mnc_digit,MAX_MNC_OCTET_SIZE);
        num_mnc_digit = MAX_MNC_OCTET_SIZE;
    }

    for( loop =RRM_ZERO;loop< num_mnc_digit;
            loop++)
    {
        eutra_cell.global_cell_id.plmn_identity.mnc.mnc[loop] =\
                                                               p_cell_ctxt->global_cell_id.primary_plmn_id.mnc[loop];
    }

    eutra_cell.global_cell_id.plmn_identity.mnc.count = num_mnc_digit;
    RRM_MEMCPY(&eutra_cell.global_cell_id.cell_identity,
            p_cell_ctxt->global_cell_id.cell_identity,
            MAX_CELL_IDENTITY_OCTETS);

    eutra_cell.cell_type.cell_size = EUTRAN_CELL_SIZE_SMALL;

    elapsed_time = uerrm_get_ue_elapsed_time (p_ue_context);

    /* SPR-21497 START */
    if(elapsed_time < RRM_ZERO )
    {
        elapsed_time = RRM_ZERO;
        eutra_cell.time_ue_stayed_in_cell = RRM_ZERO;
    }
    else
    {
        if (elapsed_time > UERRM_MAX_TIME_FOR_UE_IN_CELL)
        {
            eutra_cell.time_ue_stayed_in_cell=(U16)UERRM_MAX_TIME_FOR_UE_IN_CELL;
        }
        else
        {
            eutra_cell.time_ue_stayed_in_cell = (U16)elapsed_time;
        }
    }
    /* SPR-21497 END */

    RRM_TRACE ( g_uem_log_on_off, p_rrm_uem_facility_name,
            RRM_DETAILED,
            "Calculated Elapsed time for [UE:%d]=%d (actual=%d)\n"
            "Number of Eutra cell count (%d)",
            p_ue_context->ue_index,
            eutra_cell.time_ue_stayed_in_cell,
            elapsed_time,
            p_ue_history->last_visited_cell_list.count);

    count = p_ue_history->last_visited_cell_list.count;
    if (count == MAX_NO_OF_CELLS_UE_HISTORY)
    {
        /* Shift the ue history so that last entry is available */
        RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
                RRM_DETAILED,
                "[UE:%d] history has reached max (%d), dropping first",
                p_ue_context->ue_index,
                MAX_NO_OF_CELLS_UE_HISTORY);
	/* SPR 16763 Fix Start */
        RRM_MEMMOVE (&(p_ue_history->last_visited_cell_list.\
                    last_visited_cell_info[RRM_ONE]),
                    &(p_ue_history->last_visited_cell_list.\
                    last_visited_cell_info[RRM_ZERO]),
                ((MAX_NO_OF_CELLS_UE_HISTORY-RRM_ONE) *
                 sizeof(last_visited_cell_info_t)));
	/* SPR 16763 Fix Stop */

    }
    /* SPR 16763 Fix Start */
    else
    {
        RRM_MEMMOVE (&(p_ue_history->last_visited_cell_list.\
                               last_visited_cell_info[RRM_ONE]),
                    &(p_ue_history->last_visited_cell_list.\
                               last_visited_cell_info[RRM_ZERO]),
                    (count * sizeof(last_visited_cell_info_t)));
    }

    p_ue_history->last_visited_cell_list.\
        last_visited_cell_info[RRM_ZERO].bitmask = \
        LAST_VISITED_CELL_INFO_E_UTRAN_CELL_INFORMATION_PRESENT;

    RRM_MEMCPY(&(p_ue_history->last_visited_cell_list.\
                last_visited_cell_info[RRM_ZERO].last_visited_e_utran_cell_information),\
            &eutra_cell, sizeof(last_visited_e_utran_cell_information_t));
    /* SPR 16763 Fix Stop */

    if( p_ue_history->last_visited_cell_list.count < MAX_NO_OF_CELLS_UE_HISTORY)
    {
        p_ue_history->last_visited_cell_list.count++;
    }
    RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
            RRM_DETAILED,
            "last_visited_list.count=%d for [UE:%d]",
            p_ue_history->last_visited_cell_list.count,
            p_ue_context->ue_index);

    RRM_UT_TRACE_EXIT();
    return;
}
/* CSR 55938: code changes end */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_srcenb_to_tgtenb_trans_container 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_srcenb_to_tgtenb_container
 *   DESCRIPTION:
 *       Fills the source enb to target enb transparent container
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et 
    rrm_ue_fill_srcenb_to_tgtenb_trans_container 
(
    rrm_sourceenb_to_targetenb_transparent_cotainer_t  *p_rrc_rrm_srcenb_to_tgtenb_container,
    rrm_ue_context_t              *p_rrm_ue_context 
)
{

    rrm_return_et                            ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    rrm_ue_fill_rrc_container(&p_rrc_rrm_srcenb_to_tgtenb_container->rrc_container,p_rrm_ue_context);  
 
    /* SPR-12327-fix start */
    /* Code deleted */
    /* SPR-12327-fix end */ 
    
    RRM_MEMCPY(&(p_rrc_rrm_srcenb_to_tgtenb_container->ue_histroy),&(p_rrm_ue_context->ue_history),
                sizeof(p_rrm_ue_context->ue_history));
    /* CSR 55938: code changes start */
    /* Adding cell info in the last_visited_list */
    rrm_add_source_eutran_cell_info_in_ue_history(&(p_rrc_rrm_srcenb_to_tgtenb_container->ue_histroy),p_rrm_ue_context);
    /* CSR 55938: code changes end */
 
  /* SPR 22553 FIXED START*/ 
    if(p_rrm_ue_context->rrm_sub_profile_id_info.sub_profile_id)
    {    
        p_rrc_rrm_srcenb_to_tgtenb_container->bitmask |= SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_SUB_PROFILE_ID_PRESENT;
        p_rrc_rrm_srcenb_to_tgtenb_container->sub_profile_id = p_rrm_ue_context->rrm_sub_profile_id_info.sub_profile_id;
    }
    /* SPR 22553 FIXED END*/
  
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*CA HARDENING CHANGES 6.3.0 START*/
/* Inter RAT changes start */
/******************************************************************************
 *   FUNCTION NAME: fill_target_id_with_daho_info 
 *   INPUT      : p_cell_index,ho_type
 *   OUTPUT     : p_target_id
 *   DESCRIPTION:
 *       Fills the target_id required for HO with DAHO cell information based on
 *       HO_TYPE param 
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
static rrm_return_et fill_target_id_with_daho_info(
    	rrm_target_id_t   *p_target_id, /* OUT: Target info corresponding to phy cell id */
    	rrm_cell_index_t  cell_index,
        rrc_handover_type_et ho_type
)
{
	rrm_daho_cell_config_info_t			*p_daho_cell  = RRM_PNULL;
	/* SPR 18757 Fix Start */
	rrm_eutran_inter_freq_daho_cell_config_info_t   *p_eutra_inter_freq_daho_cell = RRM_PNULL;
	/* SPR 18757 Fix End */
	rrm_eutran_daho_cell_config_info_t 	*p_eutra_daho_cell = RRM_PNULL;
	rrm_utran_daho_cell_config_info_t 	*p_utra_daho_cell = RRM_PNULL;
	/* GERAN-HO changes start */
	rrm_geran_daho_cell_config_info_t 	*p_geran_daho_cell = RRM_PNULL;
	/* GERAN-HO changes end */
	rrm_return_et						ret_val = RRM_FAILURE;

	p_daho_cell = rrm_cellm_get_daho_cell_config_info_params(cell_index);
    /*daho clean up(condition added for presence of daho cell)*/
    if((RRM_PNULL != p_daho_cell) && 
            (p_daho_cell->bitmask & EUTRA_DAHO_CELL_PRESENT))
	    {
		    p_eutra_daho_cell = &(p_daho_cell->eutran_daho_cell_config_info);
	    }
    
    /* SPR 18757 Fix Start */
    if((RRM_PNULL != p_daho_cell) && 
	    (p_daho_cell->bitmask & EUTRA_INTER_FREQ_DAHO_CELL_PRESENT))
	    {
		    p_eutra_inter_freq_daho_cell = &(p_daho_cell->eutran_inter_freq_daho_cells_config_info_list.
                    	rrm_eutran_inter_freq_daho_cell_config_info[0]);
	    }  
    /* SPR 18757 Fix End */
    /*daho clean up(condition added for presence of daho cell)*/
    if((RRM_PNULL != p_daho_cell) &&
       (p_daho_cell->bitmask & UTRAN_DAHO_CELL_PRESENT))
    {
	  p_utra_daho_cell = &(p_daho_cell->utran_daho_cell_config_info);
    }
    /* SPR 19838 : CID 12771 Fix Start */
    /* Code Deleted */ 
    /* SPR 19838 : CID 12771 Fix End */

	if((ho_type == HANDOVER_TYPE_INTRA_LTE_X2) || \
			(ho_type == HANDOVER_TYPE_INTRA_LTE_S1))	
	{
        if(RRM_PNULL != p_eutra_daho_cell)
         {
             p_target_id->bitmask = RRM_TARGET_ID_ENB_ID_PRESENT; 
             p_target_id->enb_id.global_enb_id.plmn_identity.presence_bitmask =\
                                                                               PLMN_IDENTITY_MCC_PRESENCE_FLAG;
             RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mcc,
                     p_eutra_daho_cell->plmn_id.mcc,
                     MAX_MCC_DIGITS);
             p_target_id->enb_id.global_enb_id.plmn_identity.mnc.count = \
                                                                         p_eutra_daho_cell->plmn_id.num_mnc_digit;

             /* Fix for SPR 5195 */
             RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mnc.mnc,
                     p_eutra_daho_cell->plmn_id.mnc,
                     p_eutra_daho_cell->plmn_id.num_mnc_digit);
             /* Fix for SPR 5195 */

             RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.cell_identity,
                     p_eutra_daho_cell->cell_identity,
                     MAX_CELL_IDENTITY_OCTETS);
             p_target_id->enb_id.global_enb_id.cell_type = MACRO_ENB_ID;  
             RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.plmn_identity,
                     &p_target_id->enb_id.global_enb_id.plmn_identity,
                     sizeof(p_target_id->enb_id.global_enb_id.plmn_identity)); 
             RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.tracking_area_code,
                     &p_eutra_daho_cell->tac,MAX_TAC_SIZE);

             /* Filling the ECGI value */
             p_target_id->enb_id.global_enb_id.bitmask = EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT;
             RRM_MEMCPY(&(p_target_id->enb_id.global_enb_id.ecgi[0]),
                     p_eutra_daho_cell->cell_identity,
                     MAX_CELL_IDENTITY_OCTETS);
             /* Inter RAT changes start */
             ret_val = RRM_SUCCESS; 
             /* Inter RAT changes end */
        }
	/* SPR 18757 Fix Start */
        else if(RRM_PNULL != p_eutra_inter_freq_daho_cell)
         {
             p_target_id->bitmask = RRM_TARGET_ID_ENB_ID_PRESENT; 
             p_target_id->enb_id.global_enb_id.plmn_identity.presence_bitmask =\
                                                                               PLMN_IDENTITY_MCC_PRESENCE_FLAG;
             RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mcc,
                     p_eutra_inter_freq_daho_cell->cell_id.primary_plmn_id.mcc,
                     MAX_MCC_DIGITS);
             p_target_id->enb_id.global_enb_id.plmn_identity.mnc.count = \
                                                                        p_eutra_inter_freq_daho_cell->cell_id.primary_plmn_id.num_mnc_digit;

             RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mnc.mnc,
                     p_eutra_inter_freq_daho_cell->cell_id.primary_plmn_id.mnc,
                     p_eutra_inter_freq_daho_cell->cell_id.primary_plmn_id.num_mnc_digit);

             RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.cell_identity,
                     p_eutra_inter_freq_daho_cell->cell_id.cell_identity,
                     MAX_CELL_IDENTITY_OCTETS);
             p_target_id->enb_id.global_enb_id.cell_type = MACRO_ENB_ID;  
             RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.plmn_identity,
                     &p_target_id->enb_id.global_enb_id.plmn_identity,
                     sizeof(p_target_id->enb_id.global_enb_id.plmn_identity)); 
             RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.tracking_area_code,
                     &p_eutra_inter_freq_daho_cell->tac,MAX_TAC_SIZE);

             p_target_id->enb_id.global_enb_id.bitmask = EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT;
             RRM_MEMCPY(&(p_target_id->enb_id.global_enb_id.ecgi[0]),
                     p_eutra_inter_freq_daho_cell->cell_id.cell_identity,
                     MAX_CELL_IDENTITY_OCTETS);
             ret_val = RRM_SUCCESS; 
        }
	/* SPR 18757 Fix End */
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "Eutra DAHO cell not present, cannot fill");
        }
	}
	else if(ho_type == HANDOVER_TYPE_LTE_TO_UTRAN)
	{
        if(RRM_PNULL != p_utra_daho_cell)
        {
            p_target_id->bitmask |= RRM_TARGET_ID_RNC_ID_PRESENT; 
            if(p_utra_daho_cell->uc_id.bitmask & RRM_UTRAN_EXTN_RNC_ID_PRESENT)
            {
                p_target_id->rnc_id.bitmask |= \
                                               RRM_RNC_EXTENDED_RNC_ID_PRESENT;
                p_target_id->rnc_id.extended_rnc_id = \
                                                      p_utra_daho_cell->uc_id.extended_rnc_id;
            }
            p_target_id->rnc_id.bitmask |= \
                                           RRM_RNC_ROUTING_AREA_CODE_PRESENT;
            p_target_id->rnc_id.routing_area_code = \
                                                    p_utra_daho_cell->rai.rac;

            p_target_id->rnc_id.rnc_id = p_utra_daho_cell->uc_id.rnc_id;
            RRM_MEMCPY(&(p_target_id->rnc_id.lai), \
                    &(p_utra_daho_cell->rai.lai), sizeof(p_target_id->rnc_id.lai));
            ret_val = RRM_SUCCESS;
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "utra DAHO cell not present, cannot fill");
        }
	}
	/* GERAN-HO changes start */
	else if(ho_type == HANDOVER_TYPE_LTE_TO_GERAN)
	{
        /*daho clean up(condition added for presence of daho cell)*/
        if((RRM_PNULL != p_daho_cell) &&
           (p_daho_cell->bitmask & GERAN_DAHO_CELL_PRESENT))
        {
            p_geran_daho_cell = &(p_daho_cell->geran_daho_cell_config_info);
            p_target_id->bitmask |= RRM_TARGET_ID_CGI_PRESENT;
            RRM_MEMCPY(
                    &(p_target_id->cgi.plmn_identity), 
                    &(p_geran_daho_cell->lai.plmn_identity),
                    sizeof(plmn_identity_t));
            RRM_MEMCPY(
                    p_target_id->cgi.location_area_code, 
                    &(p_geran_daho_cell->lai.lac),
                    RRM_OAM_MAX_NUM_LAC_OCTETS);
            /*spr_20246_changes_start*/
            p_target_id->cgi.ci_info[RRM_ZERO] = (U8)(p_geran_daho_cell->cell_id >> RRM_EIGHT);
            p_target_id->cgi.ci_info[RRM_ONE] = (U8)(p_geran_daho_cell->cell_id & RRM_U16_LOW_BYTE_MASK);
            /*spr_20246_changes_end*/
            ret_val = RRM_SUCCESS;
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "geran DAHO cell not present, cannot fill");
        }

	}
	/* GERAN-HO changes end */
	return ret_val;
}
/*CA HARDENING CHANGES 6.3.0 END*/

/* SPR 20635 Fix - SRVCC to GERAN - Starts */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_irat_meas_config_info_params 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_irat_meas_config_info
 *   DESCRIPTION:
 *       Fills the IRAT mesurement configuration information parameters for 
 *       IRAT HO to UTRAN/GERAN
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et rrm_ue_fill_irat_meas_config_info_params 
(
    irat_meas_param_t   *p_irat_meas_param,
    rrm_ue_context_t    *p_rrm_ue_context
)
{
    U8                      index = RRM_NULL;
    U8                      eutra_list_count = RRM_NULL;
    rrm_sib_type_3_info_t   *p_sib_3_info = RRM_PNULL;
    rf_params_t             *p_rf_params = RRM_PNULL;
    rrm_cell_context_t      *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_sib_3_info = rrm_cellm_get_sib3_info(p_rrm_ue_context->cell_index);
    p_rf_params = rrm_cellm_get_rf_params(p_rrm_ue_context->cell_index);
    p_cell_context =  rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);

    /* Fill meas_duration, If present with Non-Zero Value, Else send failure */
    if(RRM_PNULL != p_cell_context)
    {
        if(RRMCM_RMIF_HO_CONFIG_PARAMS_PRESENT &
            p_cell_context->operator_info.bitmask)
        {
            /* SPR 22311 Changes - Starts */
            if(RRM_NULL != p_cell_context->operator_info.ho_config_params.
                        ue_meas_duration_for_ho)
            {
                p_irat_meas_param->meas_duration = p_cell_context->
                    operator_info.ho_config_params.ue_meas_duration_for_ho;
            }
            /* SPR 22311 Changes - Ends */
            else
            {
                /* Return Failure to Ignore the Measurement Configuration */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ue_meas_duration_for_ho == 0 ");
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
        }
        else
        {
            /* Return Failure to Ignore the Measurement Configuration */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_HO_CONFIG_PARAMS_NOT_PRESENT ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }
    else
    {
        /* Return Failure to Ignore the Measurement Configuration */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Cell Context NULL ");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /* Fill IRAT_MEAS_PARAM_EUTRA_FREQ_LIST */
    /* Set Bitmask and Count */
    p_irat_meas_param->bitmask |= IRAT_MEAS_PARAM_EUTRA_FREQ_LIST_PRESENT;
    p_irat_meas_param->eutra_freq_list.count = eutra_list_count = RRM_1;

    for(index = RRM_NULL; index < eutra_list_count; index++)
    {
        p_irat_meas_param->eutra_freq_list.eutra_freq[index].e_arfcn =
            p_rf_params->rf_configurations.dl_earfcn;
        p_irat_meas_param->eutra_freq_list.eutra_freq[index].measurement_bandwidth
            = p_sib_3_info->intra_freq_reselection_info.measurement_bandwidth;
        p_irat_meas_param->eutra_freq_list.eutra_freq[index].bitmask |=
            E_UTRA_FREQ_MEASUREMENT_BAND_WIDTH_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_irat_meas_config_information 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_irat_meas_config_info
 *   DESCRIPTION:
 *       Fills the IRAT mesurement configuration information for IRAT HO 
 *       to UTRAN/GERAN
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et rrm_ue_fill_irat_meas_config_information 
(
    rrm_old_bss_to_new_bss_irat_meas_config_t   *p_irat_meas_config,
    rrm_ue_context_t                            *p_rrm_ue_context
)
{
    rrm_return_et           ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    do
    {
        /* REP_QUANT : 0 (RSRP) : 1 (RSRQ) */
        if(p_rrm_ue_context->trigger_quantity == RRM_RRC_RSRP)
        {
            p_irat_meas_config->rep_quant = RRM_FALSE;

            if(RRM_SIXTY_FOUR > p_rrm_ue_context->meas_result_serv_cell.rsrp_result)
            {
                /* REPORTING_THRESHOLD : Serving Cell RSSI */
                p_irat_meas_config->reporting_threshold =
                    p_rrm_ue_context->meas_result_serv_cell.rsrp_result;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[rrm_ue_fill_irat_meas_config_information - Return Failure]"
                    " Serving Cell RSSI > RRM_SIXTY_FOUR ");
                /* Set Failure to Ignore the Measurement Configuration */
                ret_val = RRM_FAILURE;
                break;
            }
        }
        else
        {
            p_irat_meas_config->rep_quant = RRM_TRUE;
            /* REPORTING_THRESHOLD : Serving Cell RSSI */
            p_irat_meas_config->reporting_threshold =
                p_rrm_ue_context->meas_result_serv_cell.rsrq_result;
        }

        /* IRAT Measurement Configuration */
        ret_val = rrm_ue_fill_irat_meas_config_info_params(
                &p_irat_meas_config->irat_meas_param,
                p_rrm_ue_context);
    }while(0);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 20635 Fix - SRVCC to GERAN - Ends */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_srcrnc_to_tgtrnc_container 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rnc_transparent_container
 *   DESCRIPTION:
 *       Fills the source rnc to target rnc transparent container for IRAT HO 
 *       to UTRAN
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et rrm_ue_fill_srcrnc_to_tgtrnc_container 
(
    rrm_source_rnc_to_target_rnc_transparent_container_t    *p_rnc_transparent_container,
    rrm_ue_context_t                                        *p_rrm_ue_context
)
{
    rrm_return_et   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* Fill only the Mandatory params */
    /* SRVCC SUPPORT START */
    if((RRM_UEM_SRVCC_HO_INDICATION_PRESENT & p_rrm_ue_context->srvcc_config_info.bitmask) &&
        (RRM_SRVCC_CS_PS_TYPE == p_rrm_ue_context->srvcc_config_info.srvcc_ho_indication))
    {
        p_rnc_transparent_container->number_of_Iu_instances = RRM_TWO;
    }
    else
    {
        p_rnc_transparent_container->number_of_Iu_instances = RRM_ONE;
    }
    /* SRVCC SUPPORT END */

    /* HO command will be sent over Air interface so set the relocation type to UE_INVLOLVED */
    p_rnc_transparent_container->relocation_type = UE_INVOLVED;

	RRM_MEMCPY(&(p_rnc_transparent_container->ue_histroy_info), \
			&(p_rrm_ue_context->ue_history), sizeof(ue_history_t));
    /* CSR 55938: code changes start */
    /* Adding cell info in the last_visited_list */
    rrm_add_source_eutran_cell_info_in_ue_history(
        &(p_rnc_transparent_container->ue_histroy_info),p_rrm_ue_context);
    /* CSR 55938: code changes end */

    /* Since the Relocaton type is UE_INVOLVED the Target Cell Id must be filled */
    p_rnc_transparent_container->bitmask |= \
        RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_TARGET_CELL_ID_PRESENT;
    /* SPR 22553 FIXED START*/
    if(p_rrm_ue_context->rrm_sub_profile_id_info.sub_profile_id)
    {
        p_rnc_transparent_container->bitmask |= \
            RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SUB_PROF_ID_FOR_RAT_OR_FREQ_PRI_PRESENT;
        p_rnc_transparent_container->subscriber_profile_id_for_rat_or_frequency_priority 
            = p_rrm_ue_context->rrm_sub_profile_id_info.sub_profile_id;
    }
    /* SPR 22553 FIXED END*/
    /*CSFB Changes begin*/
    if (p_rrm_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
    {
        p_rnc_transparent_container->bitmask |=\
            RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_CSFB_INFO_PRESENT;
        p_rnc_transparent_container->csfb_info =\
            p_rrm_ue_context->ue_context_mod_req.csf_indicator;
    }
    /*CSFB Changes end*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Inter RAT changes end */
/* GERAN-HO changes start */
/*SPR 17777 +-*/
/* SPR 20635 Fix - SRVCC to GERAN - Starts */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_oldbss_to_newbss_information 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_oldbss_newbss_container
 *   DESCRIPTION:
 *       Fills the old bss to new bss information container for IRAT HO 
 *       to GERAN
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et rrm_ue_fill_oldbss_to_newbss_information 
(
    rrm_old_bss_to_new_bss_information_t    *p_oldbss_newbss_info,
    rrm_ue_context_t                        *p_rrm_ue_context
)
{
    RRM_UT_TRACE_ENTER();

    /* Set Bitmask Null by default */
    p_oldbss_newbss_info->bitmask = RRM_NULL;

    /* Fill Extra Information */
    {
        /* Set Null by default */
        p_oldbss_newbss_info->extra_information.bitmask = RRM_NULL;

        /* Set Pre-emption Recommendation */
        if(RRM_TRUE == rrm_is_ue_special_previledge(p_rrm_ue_context))
        {
            p_oldbss_newbss_info->extra_information.bitmask |=
                RRM_BSS_EXTRA_INFORMATION_PRE_EMPTION_RECOMMEDATION_PRESENT;
        }

        /* Check Bit 8 and 27 of featureGroupIndicators, If both set then Set UE-prob */
        /* Set UE-prob = support of handover to UMTS */
        if(RRM_TRUE == rrm_check_if_utran_ho_is_possible(p_rrm_ue_context))
        {
            p_oldbss_newbss_info->extra_information.bitmask |=
                RRM_BSS_EXTRA_INFORMATION_UMTS_HO_SUPPORT_PRESENT;
        }

        /* Set EXTRA_INFO_PRESENT bitmask on Non-Zero Value */
        if(RRM_NULL != p_oldbss_newbss_info->extra_information.bitmask)
        {
            /* Set Bitmask for Extra Information */
            p_oldbss_newbss_info->bitmask |= 
                RRM_OLD_BSS_TO_NEW_BSS_INFO_EXTRA_INFO_PRESENT;
        }
    }

    /* Fill Target Cell Radio Information - GERAN RSSI */
    if(RRM_SIXTY_FOUR > p_rrm_ue_context->ho_params.target_geran_cell_rssi)
    {
        p_oldbss_newbss_info->target_cell_rxlev =
            p_rrm_ue_context->ho_params.target_geran_cell_rssi;
        /* Set Bitmask for Target Cell Radio Information */
        p_oldbss_newbss_info->bitmask |= 
            RRM_OLD_BSS_TO_NEW_BSS_INFO_TARGET_CELL_RADIO_INFO_PRESENT;
    }

    /* Fill PS Indication - RRM_TRUE by Default */
    p_oldbss_newbss_info->bitmask |= 
        RRM_OLD_BSS_TO_NEW_BSS_INFO_PS_INDICATION_PRESENT;
    p_oldbss_newbss_info->old_bss_to_new_bss_ps_indication = RRM_TRUE;

    /* Fill IRAT Measurement Configuration */
    /* + coverity 111532 */
    if( RRM_SUCCESS == rrm_ue_fill_irat_meas_config_information(
        &p_oldbss_newbss_info->irat_meas_config,
        p_rrm_ue_context) )
        /* - coverity 111532 */
    {
        /* Reset Bitmask for Meas Configuration Information */
        p_oldbss_newbss_info->bitmask |= 
            RRM_OLD_BSS_TO_NEW_BSS_INFO_IRAT_MEAS_CONFIG_INFO_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* SPR 20635 Fix - SRVCC to GERAN - Ends */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_src_target_container 
 *   INPUT      : p_rrm_ue_context,ho_type
 *   OUTPUT     : p_rrc_rrm_src_tgt_container
 *   DESCRIPTION:
 *       Fills the source to target container 
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et rrm_ue_fill_src_target_container 
(
    rrm_soruce_to_target_transparent_container_t    *p_rrc_rrm_src_tgt_container,
    rrm_ue_context_t                                *p_rrm_ue_context,
    rrc_handover_type_et                            ho_type
)
{
    rrm_return_et   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /* Inter RAT changes start */
    /* INTRA_CELL_HO changes start*/
    if((ho_type == HANDOVER_TYPE_INTRA_LTE_S1) || \
        (ho_type == HANDOVER_TYPE_INTRA_LTE_X2) ||\
        (ho_type == HANDOVER_TYPE_INTRA_LTE_X2) || \
        (ho_type == HANDOVER_TYPE_INTRA_CELL) || \
        /* SPR 10781 start */
        (ho_type == HANDOVER_TYPE_INTER_CELL))
        /* SPR 10781 end */
        /*INTRA_CELL_HO changes stop*/  
    {
        /* Inter RAT changes end */
        p_rrc_rrm_src_tgt_container->bitmask = \
            SOURCE_TO_TARGET_TRANSPARENT_ENB_CONTAINER_PRESENT;
        rrm_ue_fill_srcenb_to_tgtenb_trans_container(
            &p_rrc_rrm_src_tgt_container->eNBContainer,
            p_rrm_ue_context);    
    }
    /* Inter RAT changes start */
    else if(ho_type == HANDOVER_TYPE_LTE_TO_UTRAN)
    {
        p_rrc_rrm_src_tgt_container->bitmask = \
            SOURCE_TO_TARGET_TRANSPARENT_RNC_CONTAINER_PRESENT;
        rrm_ue_fill_srcrnc_to_tgtrnc_container(
            &p_rrc_rrm_src_tgt_container->rncContainer,
            p_rrm_ue_context);    
    }
    /* Inter RAT changes end */
    /* GERAN-HO changes start */
    else if(ho_type == HANDOVER_TYPE_LTE_TO_GERAN)
    {
        /* SPR 20635 Fix - SRVCC to GERAN - Starts */
        /* IF CS_ONLY SRVCC to GERAN then Fill OLD BSS to NEW BSS Information
         * Otherwise, Fill Source BSS to Target BSS Transparent Container */
        if((RRM_UEM_SRVCC_HO_INDICATION_PRESENT & 
            p_rrm_ue_context->srvcc_config_info.bitmask) &&
            (RRM_SRVCC_CS_ONLY_TYPE == 
            p_rrm_ue_context->srvcc_config_info.srvcc_ho_indication))
        {
            /* Fill src-bss to tgt-bss container */
            p_rrc_rrm_src_tgt_container->bitmask |= \
                OLD_TO_NEW_TRANSPARENT_BSS_CONTAINER_PRESENT;

            rrm_ue_fill_oldbss_to_newbss_information(
                &p_rrc_rrm_src_tgt_container->old_to_new_bssContainer,
                p_rrm_ue_context);
        }
        else
        {
            /* Fill src-bss to tgt-bss container */
            p_rrc_rrm_src_tgt_container->bitmask |= \
                SOURCE_TO_TARGET_TRANSPARENT_BSS_CONTAINER_PRESENT;
            /* SPR 19446 start */
            p_rrc_rrm_src_tgt_container->bssContainer.bitmask = 
                RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_PS_INDICATION_PRESENT;
            p_rrc_rrm_src_tgt_container->bssContainer.ps_handover_indication = RRM_TRUE;
            /* SPR 19446 end */
            /*SPR 17777 +-*/
            /* Fill IRAT Measurement Configuration */
            ret_val = rrm_ue_fill_irat_meas_config_information(
                &p_rrc_rrm_src_tgt_container->bssContainer.irat_meas_config,
                p_rrm_ue_context);
            /* Check the value of ret_val */
            if(RRM_SUCCESS == ret_val)
            {
                /* Reset Bitmask for Meas Configuration Information */
                p_rrc_rrm_src_tgt_container->bssContainer.bitmask |= 
                    RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_IRAT_MEAS_CONFIG_PRESENT;
            }
        }
        /* SPR 20635 Fix - SRVCC to GERAN - Ends */
    }
    /* GERAN-HO changes end */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_check_for_cco
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION: Check if CCO is supported by UE in CSFB case
 *   RETURNS: TRUE if CCO supported else FALSE
 *****************************************************************************/
/* SPR 15674 Start */
rrm_bool_et rrm_ue_check_for_cco(
        rrm_ue_context_t        *p_ue_context,
        /* SPR 19364 start */
        /* Code removed */
        /* SPR 19364 end */
        phy_cell_id_info_t *p_phy_cell_id_info
        /* SPR_14067_Fix_End */
        )
/* SPR 15674 End */
{
    /*CA HARDENING 6.3.0 Changes*/
    U32    feature_group_indicators = (U32)-RRM_ONE;
    /* SPR 19364 start */
    /* Code deleted */
    /* SPR 19364 end */
    
    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */
      RRM_UT_TRACE_ENTER();
      /*Presently CCO is supported only in case of CSFB*/
      if ((RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT &
              p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
               eutra_radio_capability_info_def.bitmask) &&
               (p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD) &&
               (GERAN_CELL == p_ue_context->target_cell_type))
      {
        feature_group_indicators = p_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.feature_group_indicators;

          /* SPR 19364 start */
        /* SPR_14067_Fix_Start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "Target GERAN cell DTM Supported = %d",
                  ((p_phy_cell_id_info->bitmask & RRM_CELL_DTM_SUPPORTED) == RRM_CELL_DTM_SUPPORTED) ? RRM_TRUE: RRM_FALSE);
        /* SPR_14067_Fix_End */
          /* SPR 19364 end */

          /* SPR 19364 start */
        if((feature_group_indicators & (RRM_ONE <<(RRM_THIRTY_TWO - RRM_TEN)))&&
                /* SPR_14067_Fix_Start */
                  (p_phy_cell_id_info->bitmask & RRM_CELL_DTM_SUPPORTED))
            /* SPR_14067_Fix_End */
              /* SPR 19364 end */
            {
                 RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                              "CCO supported for CS fallback ");
                 RRM_UT_TRACE_EXIT();
                 return RRM_TRUE;
            }
      }
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                     "CCO NOT supported for CS fallback ");
      RRM_UT_TRACE_EXIT();
      return RRM_FALSE;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_cco_params_for_daho_cell
 *   INPUT      : p_cco_params
 *   OUTPUT     : p_daho_cell
 *   DESCRIPTION: fill CCO params required in HO REQUIRED for DAHO Cell
 *   RETURNS: none 
 *****************************************************************************/
rrm_void_t rrm_ue_fill_cco_params_for_daho_cell(
   cco_parameters_t *p_cco_params,
   rrm_daho_cell_config_info_t   *p_daho_cell)
{

    rrm_geran_daho_cell_config_info_t       *p_geran_daho_cell = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    if((RRM_PNULL == p_daho_cell) || (RRM_PNULL == p_cco_params))
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Pointer to DAHO or CCO container is NULL.Failure in filling CCO info");
       RRM_UT_TRACE_EXIT();
       return;
    }
    /*daho clean up(condition added for presence of daho cell)*/
    if(p_daho_cell->bitmask & GERAN_DAHO_CELL_PRESENT)
    {
       p_geran_daho_cell = &(p_daho_cell->geran_daho_cell_config_info);
    }
    else
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                 "geran daho cell is not present, Failure in filling CCO info");
       RRM_UT_TRACE_EXIT();
       return;
    }
    /*Currently CCO is supported only in CSFB scenario*/
    /*Note SI/PSI is not filled as  presently donot exist for of DAHO configuration*/
    p_cco_params->cs_fallback_indicator = RRM_TRUE;
    p_cco_params->target_rat_params.bitmask |=
                       RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_PRESENT;
    /* SPR_14067_Fix_Start */
    p_cco_params->target_rat_params.geran_params.pci_geran.network_colour_code =\
                     (U8)(p_geran_daho_cell->pci & RRM_NCC_MASK)>> RRM_THREE;
    /* SPR_14067_Fix_End */                 
    p_cco_params->target_rat_params.geran_params.pci_geran.base_station_colour_code=\
                      (p_geran_daho_cell->pci & RRM_BSCC_MASK);
    p_cco_params->target_rat_params.geran_params.carr_freq.arfcn =\
                                      p_geran_daho_cell->bcch_arfcn;
    p_cco_params->target_rat_params.geran_params.carr_freq.band_indicator =
                                              p_geran_daho_cell->band_indicator;
    /* SPR_14067_Fix_Start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                 "CCO info for DAHO cell filled in Ho required");
    /* SPR_14067_Fix_End */

   RRM_UT_TRACE_EXIT();
   return;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_cco_params
 *   INPUT      : p_cco_params
 *   OUTPUT     : p_geran_cell
 *   DESCRIPTION: fill CCO params required in HO REQUIRED
 *   RETURNS: none 
 *****************************************************************************/
rrm_void_t rrm_ue_fill_cco_params(
   cco_parameters_t   *p_cco_params,
   geran_freq_ncl_t   *p_geran_cell)
{
    U8 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /*Currently CCO is supported only in CSFB scenario*/
    p_cco_params->cs_fallback_indicator = RRM_TRUE;
    p_cco_params->target_rat_params.bitmask |=
                       RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_PRESENT;
    /* SPR_14067_Fix_Start */
    p_cco_params->target_rat_params.geran_params.pci_geran.network_colour_code =\
                     (U8)(p_geran_cell->pci & RRM_NCC_MASK) >> RRM_THREE;
    /* SPR_14067_Fix_End */                 
    p_cco_params->target_rat_params.geran_params.pci_geran.base_station_colour_code=\
                        (p_geran_cell->pci & RRM_BSCC_MASK);
    p_cco_params->target_rat_params.geran_params.carr_freq.arfcn = p_geran_cell->bcch_arfcn;
    p_cco_params->target_rat_params.geran_params.carr_freq.band_indicator =
                                                  p_geran_cell->band_indicator;
    if (RRM_GERAN_FREQ_CELL_NW_CONTROL_ORDER_PRESENT == p_geran_cell->bitmask)
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                       "GERAN Network Control Order present");
         p_cco_params->target_rat_params.geran_params.bitmask |=\
                            RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_NCO_PRESENT;
         p_cco_params->target_rat_params.geran_params.nco = p_geran_cell->nw_ctrl_order;
    }
    if ((p_geran_cell->rim_geran_info != RRM_NULL) &&
        (RRM_GERAN_SI_PRESENT == p_geran_cell->rim_geran_info->bitmask))
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                          "GERAN SI present");

         p_cco_params->target_rat_params.geran_params.si_list.bitmask |=\
                                             SYSTEM_INFO_LIST_GERAN_SI_PRESENT;
         p_cco_params->target_rat_params.geran_params.bitmask |=
                                        RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_SI_PSI_PRESENT;
         p_cco_params->target_rat_params.geran_params.si_list.si.count =\
                                              p_geran_cell->rim_geran_info->num_si_psi;
         for (count =0;count <p_geran_cell->rim_geran_info->num_si_psi;count++)
         {
             p_cco_params->target_rat_params.geran_params.si_list.si.\
                         system_info_geran_elem[count].bitmask |=
                                RRC_RRM_SYS_INFO_CONTAINER_ENCODED_PRESENT;
             p_cco_params->target_rat_params.geran_params.si_list.si.\
                        system_info_geran_elem[count].sys_info_container_encoded_si_info.length =
                                     RIM_MAX_SI_PSI_PAYLOAD_INDIV;
             RRM_MEMCPY(&(p_cco_params->target_rat_params.geran_params.si_list.si.\
                            system_info_geran_elem[count].sys_info_container_encoded_si_info.data),
                             &(p_geran_cell->rim_geran_info->geran_si_psi),
                              RIM_MAX_SI_PSI_PAYLOAD_INDIV);
         }
    }
    if ((p_geran_cell->rim_geran_info != RRM_NULL) &&
        (RRM_GERAN_PSI_PRESENT == p_geran_cell->rim_geran_info->bitmask))
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                    "GERAN PSI present");

         p_cco_params->target_rat_params.geran_params.si_list.bitmask |=
                                              SYSTEM_INFO_LIST_GERAN_PSI_PRESENT;
         p_cco_params->target_rat_params.geran_params.bitmask |=
                                        RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_SI_PSI_PRESENT;
         p_cco_params->target_rat_params.geran_params.si_list.psi.count =
                                              p_geran_cell->rim_geran_info->num_si_psi;
         for (count =0;count <p_geran_cell->rim_geran_info->num_si_psi;count++)
         {
             p_cco_params->target_rat_params.geran_params.si_list.psi.\
                         system_info_geran_elem[count].bitmask |=
                              RRC_RRM_SYS_INFO_CONTAINER_ENCODED_PRESENT;
             p_cco_params->target_rat_params.geran_params.si_list.psi.\
                       system_info_geran_elem[count].sys_info_container_encoded_si_info.length =\
                                     RIM_MAX_SI_PSI_PAYLOAD_INDIV;
             RRM_MEMCPY(&(p_cco_params->target_rat_params.geran_params.si_list.psi.\
                         system_info_geran_elem[count].sys_info_container_encoded_si_info.data),
                          &(p_geran_cell->rim_geran_info->geran_si_psi),
                           RIM_MAX_SI_PSI_PAYLOAD_INDIV);
          }
    }
    RRM_UT_TRACE_EXIT();
}
/*CCO changes end*/

/* SPR 15674 Start */
/* SPR_15636_Fix: Start */
/******************************************************************************
 *  FUNCTION NAME: rrm_is_s1ho_reqd_for_csg_status_of_src_and_tgt_for_intra 
 *  INPUT      : p_ue_context,p_lte_intra_ncl 
 *  OUTPUT     : 
 *  DESCRIPTION:
 *  RETURNS:   RRM_TRUE-> If HO Type need to be changed from X2-HO to S1-HO.
 *             RRM_FALSE-> If HO Type need not be changed.
 *******************************************************************************/
rrm_bool_et
   rrm_is_s1ho_reqd_for_csg_status_of_src_and_tgt_for_intra 
(
 rrm_ue_context_t *p_ue_context,
 intra_freq_cells_t *p_lte_intra_ncl
 )
{
    rrm_bool_et ret_val = RRM_FALSE;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ue_context)
    {
        p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);

        if((RRM_PNULL != p_cell_context) && (RRM_PNULL != p_lte_intra_ncl))
        {
            if((p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                    ((RRM_OAM_ACCESS_MODE_OPEN == p_lte_intra_ncl->cell_access_mode) ||
                    (RRM_OAM_ACCESS_MODE_OPEN_FEMTO == p_lte_intra_ncl->cell_access_mode)))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Target is Open. S1-HO is not mandatory.");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }

            /* Compare the CSG status of Source & target */
            /* If Source is OPEN & Target is CLOSED/HYBRID then return TRUE so that S1-HO could be changed if 
               originally HO Type was X2-HO */
            if(HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type)
            {
                if((RRM_OAM_ACCESS_MODE_OPEN == p_cell_context->access_mgmt_params.access_mode) ||
                        (RRM_OAM_ACCESS_MODE_OPEN_FEMTO == p_cell_context->access_mgmt_params.access_mode))
                {
                    if((p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                            ((p_lte_intra_ncl->cell_access_mode == RRM_OAM_ACCESS_MODE_CLOSE) ||
                             (p_lte_intra_ncl->cell_access_mode == RRM_OAM_ACCESS_MODE_HYBRID)))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "Source is Open & Target is Closed. So S1-HO will be triggered.");
                        ret_val = RRM_TRUE;
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Source is Open & Target is Open. So X2-HO will be triggered.");
                    }

                }
                else if(RRM_OAM_ACCESS_MODE_CLOSE == p_cell_context->access_mgmt_params.access_mode) 
                {
                    if((p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                            ((RRM_OAM_ACCESS_MODE_CLOSE == p_lte_intra_ncl->cell_access_mode) ||
                             (RRM_OAM_ACCESS_MODE_HYBRID == p_lte_intra_ncl->cell_access_mode)))
                    {
                        if(( p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT) && 
                                (p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT))
                        {
                            if(RRM_MEMCMP(&(p_cell_context->access_mgmt_params.csg_id),
                                        &(p_lte_intra_ncl->csg_identity),
                                        RRM_OAM_MAX_NUM_CSG_OCTETS))
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                        "Source & Target CSG ID not matched S1HO will be triggered");
                                ret_val = RRM_TRUE;
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Source or Target CSG ID not present.");
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                " Source is Closed & Target is Open.");
                    }
                }
                /* IF Source was Hybrid & UE was attached as MEMBER then only we should check for target's Access Mode & CSG ID */
                else if(RRM_OAM_ACCESS_MODE_HYBRID == p_cell_context->access_mgmt_params.access_mode)
                {
                    if(RRM_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
                    {
                        if((p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                                ((RRM_OAM_ACCESS_MODE_CLOSE == p_lte_intra_ncl->cell_access_mode) ||
                                 (RRM_OAM_ACCESS_MODE_HYBRID == p_lte_intra_ncl->cell_access_mode)))
                        {
                            if(( p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT) && 
                                    (p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT))
                            {
                                if(RRM_MEMCMP(&(p_cell_context->access_mgmt_params.csg_id),
                                            &(p_lte_intra_ncl->csg_identity),
                                            RRM_OAM_MAX_NUM_CSG_OCTETS))
                                {
                                    ret_val = RRM_TRUE;
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                            "Hybrid Cell: Source & Target CSG ID not matched S1HO will be triggered");
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Either Source's or target's CSG ID not present.");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Cell Access mode of Target is Open");
                        }
                    }
                    /* In case UE is Non-Member on the Source Hybrid cell, If target is also Hybrid cell & CSG ID matches then 
                       X2-HO could be done & if Target is Hybrid & CSG IDs are different then S1-HO should be done.*/
                    else if(RRM_NOT_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
                    {
                        if((p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                                ((RRM_OAM_ACCESS_MODE_CLOSE == p_lte_intra_ncl->cell_access_mode) ||
                                 (RRM_OAM_ACCESS_MODE_HYBRID == p_lte_intra_ncl->cell_access_mode)))
                        {
                            if(( p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT) && 
                                    (p_lte_intra_ncl->bitmask & RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT))
                            {
                                if(RRM_MEMCMP(&(p_cell_context->access_mgmt_params.csg_id),
                                            &(p_lte_intra_ncl->csg_identity),
                                            RRM_OAM_MAX_NUM_CSG_OCTETS))
                                {
                                    ret_val = RRM_TRUE;
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                            "Source & Target CSG ID not matched S1HO will be triggered");
                                }
                                /* In case the CSG ID matches & Cell is closed then UE should not be done X2-HO as if the target is
                                   Closed so it'll reject the UE's HO. */
                                else
                                {
                                    if(RRM_OAM_ACCESS_MODE_CLOSE == p_lte_intra_ncl->cell_access_mode)
                                    {
                                        ret_val = RRM_TRUE;
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                                "Target is Closed Cell with CSG ID same as Source cell so doing the X2-HO may not be successful will trigger S1HO");
                                    }
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Either Source's or target's CSG ID not present.");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Cell Access mode of Target is Open");
                        }
                    }
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Cell context or UE context or the LTE cell is NULL");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 * FUNCTION NAME:rrm_is_s1ho_reqd_for_csg_status_of_src_and_tgt_for_inter
 * INPUT      : p_ue_context,p_lte_intra_ncl 
 * OUTPUT     : 
 * DESCRIPTION:
 * RETURNS:  RRM_TRUE-> If HO Type need to be changed from X2-HO to S1-HO.
 *           RRM_FALSE-> If HO Type need not be changed.
 *******************************************************************************/
rrm_bool_et
   rrm_is_s1ho_reqd_for_csg_status_of_src_and_tgt_for_inter 
(
 rrm_ue_context_t *p_ue_context,
 inter_freq_cells_t *p_lte_inter_ncl
 )
{
    rrm_bool_et ret_val = RRM_FALSE;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_ue_context)
    {
        p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);

        if((RRM_PNULL != p_cell_context) && (RRM_PNULL != p_lte_inter_ncl))
        {
            /* If Target is Open then we should do the HO as selected earlier */
            if((p_lte_inter_ncl->bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT) &&
                    ((RRM_OAM_ACCESS_MODE_OPEN == p_lte_inter_ncl->cell_access_mode) ||
                    (RRM_OAM_ACCESS_MODE_OPEN_FEMTO == p_lte_inter_ncl->cell_access_mode)))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Target is Open. S1-HO is not mandatory.");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
            /* Compare the CSG status of Source & target */
            /* If Source is OPEN & Target is CLOSED/HYBRID then return TRUE so that S1-HO could be changed if 
               originally HO Type was X2-HO */
            if(HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type)
            {
                if((RRM_OAM_ACCESS_MODE_OPEN == p_cell_context->access_mgmt_params.access_mode) ||
                        (RRM_OAM_ACCESS_MODE_OPEN_FEMTO == p_cell_context->access_mgmt_params.access_mode))
                {
                    if((p_lte_inter_ncl->bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT) &&
                            ((p_lte_inter_ncl->cell_access_mode == RRM_OAM_ACCESS_MODE_CLOSE) ||
                             (p_lte_inter_ncl->cell_access_mode == RRM_OAM_ACCESS_MODE_HYBRID)))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Source is Open & Target is Closed. So S1-HO will be triggered.");
                        ret_val = RRM_TRUE;
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Source is Open & Target is Open. So X2-HO will be triggered.");
                    }
                }
                else if(RRM_OAM_ACCESS_MODE_CLOSE == p_cell_context->access_mgmt_params.access_mode) 
                {
                    if((p_lte_inter_ncl->bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT) &&
                            ((RRM_OAM_ACCESS_MODE_CLOSE == p_lte_inter_ncl->cell_access_mode) ||
                             (RRM_OAM_ACCESS_MODE_HYBRID == p_lte_inter_ncl->cell_access_mode)))
                    {
                        if(( p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT) && 
                                (p_lte_inter_ncl->bitmask & RRMCM_RMIF_CSG_ID_PRESENT))
                        {
                            if(RRM_MEMCMP(&(p_cell_context->access_mgmt_params.csg_id),
                                        &(p_lte_inter_ncl->csg_identity),
                                        RRM_OAM_MAX_NUM_CSG_OCTETS))
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Source & Target CSG ID not matched.");
                                ret_val = RRM_TRUE;
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Source & Target CSG ID matched. X2 HO possible.");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Source or Target CSG ID not present.");
                        }
                    }
                }
                /* IF Source was Hybrid & UE was attached as MEMBER then only we should check for target's Access Mode & CSG ID */ 
                else if(RRM_OAM_ACCESS_MODE_HYBRID == p_cell_context->access_mgmt_params.access_mode)
                {
                    if(RRM_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
                    {
                        if((p_lte_inter_ncl->bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT) &&
                                ((RRM_OAM_ACCESS_MODE_CLOSE == p_lte_inter_ncl->cell_access_mode) ||
                                 (RRM_OAM_ACCESS_MODE_HYBRID == p_lte_inter_ncl->cell_access_mode)))
                        {
                            if(( p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT) && 
                                    (p_lte_inter_ncl->bitmask & RRMCM_RMIF_CSG_ID_PRESENT))
                            {
                                if(RRM_MEMCMP(&(p_cell_context->access_mgmt_params.csg_id),
                                            &(p_lte_inter_ncl->csg_identity),
                                            RRM_OAM_MAX_NUM_CSG_OCTETS))
                                {
                                    ret_val = RRM_TRUE;
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                            "Source & Target CSG ID not matched.");
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Either Source's or target's CSG ID not present.");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Cell Access mode of Target is Open");
                        }
                    }
                    /* In case UE is Non-Member on the Source Hybrid cell, If target is also Hybrid cell & CSG ID matches then 
                       X2-HO could be done & if Target is Hybrid & CSG IDs are different then S1-HO should be done. */
                    else if(RRM_NOT_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
                    {
                        if((p_lte_inter_ncl->bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT) &&
                                ((RRM_OAM_ACCESS_MODE_CLOSE == p_lte_inter_ncl->cell_access_mode) ||
                                 (RRM_OAM_ACCESS_MODE_HYBRID == p_lte_inter_ncl->cell_access_mode)))
                        {
                            if(( p_cell_context->access_mgmt_params.bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT) && 
                                    (p_lte_inter_ncl->bitmask & RRMCM_RMIF_CSG_ID_PRESENT))
                            {
                                if(RRM_MEMCMP(&(p_cell_context->access_mgmt_params.csg_id),
                                            &(p_lte_inter_ncl->csg_identity),
                                            RRM_OAM_MAX_NUM_CSG_OCTETS))
                                {
                                    ret_val = RRM_TRUE;
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                            "Source & Target CSG ID not matched.");
                                }
                                /* In case the CSG ID matches & Cell is closed then UE should not be done X2-HO as if the target is
                                   Closed so it'll reject the UE's HO*/
                                else
                                {
                                    if(RRM_OAM_ACCESS_MODE_CLOSE == p_lte_inter_ncl->cell_access_mode)
                                    {
                                        ret_val = RRM_TRUE;
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                "Target is Closed Cell with CSG ID same as Source cell so doing the X2-HO may not be successful.");
                                    }
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Either Source's or target's CSG ID not present.");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Cell Access mode of Target is Open");
                        }
                    }
                }

            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Cell context or UE context or the LTE cell is NULL");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR_15636_Fix: End */

/* SPR_21459 Fix - Start */
/******************************************************************************
 * FUNCTION NAME  : rrm_fill_gummei_info_in_ho_required
 * INPUT          : p_rrc_rrm_ho_required, p_gu_group_id_node, 
 * OUTPUT         : None
 * DESCRIPTION    : Fills the GUMMEI information in RRC RRM HO REQUIRED message.
 * RETURNS        : Void
 ******************************************************************************/
void rrm_fill_gummei_info_in_ho_required
(
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
    rrm_gu_group_id_node_t  *p_gu_group_id_node
)
{
    rrm_connected_mme_node_t    *p_mme_id_node = RRM_PNULL;
    rrm_bool_t                  is_matched = RRM_FALSE;
    U8                          served_gummei_index = RRM_ZERO;
    U8                          served_plmn_index = RRM_ZERO;
    U8                          temp_plmnid_1[MAX_PLMN_ID_BYTES] = {RRM_ZERO};
    rrm_oam_cell_plmn_info_t    *p_input_plmn = RRM_PNULL;

    /* Fill GUMMEI information in HO Required as per stored Group Info */
    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_REQUIRED_GUMMEI_INFO_PRESENT;

    /* Fill PLMN Identity */
    p_rrc_rrm_ho_required->gummei_info.plmn_identity.presence_bitmask
        |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
    RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.plmn_identity.mcc,
        &p_gu_group_id_node->mme_group_id_key.plmn_id.mcc,
        MAX_MCC_DIGITS);
    p_rrc_rrm_ho_required->gummei_info.plmn_identity.mnc.count =
        p_gu_group_id_node->mme_group_id_key.plmn_id.num_mnc_digit;

    RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.plmn_identity.mnc.mnc,
        &p_gu_group_id_node->mme_group_id_key.plmn_id.mnc,
        p_gu_group_id_node->mme_group_id_key.plmn_id.num_mnc_digit);

    /* Fill MME Group ID */
    RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.mme_group_id,
        &p_gu_group_id_node->mme_group_id_key.mme_group_id,
        MAX_MME_GRP_BYTES);

    /* Find and fill MMEC */
    p_mme_id_node = (rrm_connected_mme_node_t *)
        ylFirst(&p_g_rrm_cell_ctx->enb_context.connected_mme_list);
    is_matched = RRM_FALSE;
    while (p_mme_id_node)
    {
        for (served_gummei_index = RRM_ZERO;
            (served_gummei_index < p_mme_id_node->connected_gummei_info.num_served_group_ids)
                && (RRM_TRUE != is_matched);
            served_gummei_index++)
        {
            if (!(RRM_MEMCMP(&p_mme_id_node->connected_gummei_info.
                served_group_id[served_gummei_index].mmegi,
                &p_gu_group_id_node->mme_group_id_key.mme_group_id,
                MAX_MME_GRP_BYTES)))
            {
                for (served_plmn_index = RRM_ZERO;
                    served_plmn_index < p_mme_id_node->connected_gummei_info.num_served_plmns;
                    served_plmn_index++)
                {
                    p_input_plmn = (rrm_oam_cell_plmn_info_t *)
                        &p_gu_group_id_node->mme_group_id_key.plmn_id;

                    /* Decode the plmnid received S1AP RRM MME INFO */
                    rrm_plmnid_from_mcc_mnc(temp_plmnid_1, p_input_plmn);
                    if(!RRM_MEMCMP(temp_plmnid_1,
                        p_mme_id_node->connected_gummei_info.plmn_identity[served_plmn_index].plmn_id,
                        MAX_PLMN_ID_BYTES))
                    {
                        RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.mmec,
                            &p_mme_id_node->connected_gummei_info.served_mmec[RRM_ZERO].mmec,
                            sizeof(U8));
                        is_matched = RRM_TRUE;
                        break;
                    }
                }
            }
        }
        if(RRM_TRUE == is_matched)
        {
            break;
        }
        p_mme_id_node = (rrm_connected_mme_node_t *)ylNext(&p_mme_id_node->s_node);
    }
}
/* SPR_21459 Fix - End */

/******************************************************************************
 *   FUNCTION NAME: rrm_get_target_id_from_phy_cell_id 
 *   INPUT      : p_cell_index,target_cell_type,p_cco_params,p_ue_context
 *   OUTPUT     : p_target_id
 *   DESCRIPTION:
 *       Fills the target_id and linkup flag and interrat flag message
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et rrm_get_target_id_from_phy_cell_id
(
    phy_cell_id_info_t	    phy_cell_id_info,	/*Physical cell_id and earfcn info */
    rrm_cell_index_t        cell_index,
    rrm_target_id_t         *p_target_id, /* OUT: Target info corresponding to phy cell id */
    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */
    rrm_temp_cell_info_t    *p_rrm_temp_cell_info,  /*OUT: csg_id and access mode info of the cell*/
    rrm_cell_type_t         target_cell_type, /* SPR 314 */
    /* SPR 12396 Fix Start */
    /*CCO change begin*/
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
    rrm_ue_context_t        *p_ue_context
    /*CCO change end*/
    /* SPR 12396 Fix Stop */
)
{
    rrm_return_et             		ret_val = RRM_FAILURE;
    U8                      		intra_count=RRM_ZERO;
    U8                      		inter_count=RRM_ZERO;
    lte_ncl_t              			*p_ncl_params = RRM_PNULL;        
    inter_rat_ncl_t        			*p_irat_ncl   = RRM_PNULL;        
    rrm_daho_cell_config_info_t		*p_daho_cell  = RRM_PNULL;
    rrm_cell_context_t              *p_cell_context = RRM_PNULL;

    U16                             daho_utra_pci = INVALID_PHYSICAL_CELL_ID;
    /*coverity 23148:removing "daho_utra_pci":simerjit , rel 1.3*/	
    U16								daho_eutra_pci = INVALID_PHYSICAL_CELL_ID;
    /* GERAN-HO changes start */
    U16								daho_geran_pci = INVALID_PHYSICAL_CELL_ID;
    /* GERAN-HO changes end */
    /* SPR 10137 Start */
    U16                             cell_identity = RRM_ZERO;
    /* SPR 10137 End */
    /* SPR 12396 Fix Start */
    cco_parameters_t                *p_cco_params = RRM_PNULL;
    /* SPR 12396 Fix Stop */
    /* Fix for CSR 58972 start*/
    /* SPR 16406 18sep Start */
    /* Code Removed */
    /* SPR 16406 18sep End */
    /*SPR 15180 Fix Start*/
    rrmcm_rmif_cell_x2_status_et    x2_up_status = X2_PROHIBITED;
    /*CID 65856 :delete*/
    rrm_gu_group_id_node_t          *p_gu_group_id_node = RRM_PNULL;
    /*SPR 15180 Fix Stop*/
    /* SPR 19364 start */
    rrc_timers_t                    *p_rrc_timers = RRM_PNULL;
    /* SPR 19364 end */
    /* SPR 16406 18sep Start */
    /* Code Removed */
    /* SPR 16406 18sep End */
    /* Fix for CSR 58972 end*/

    /*coverity 23149:removing "p_gen_epc_params":simerjit, rel 1.3*/        
    RRM_UT_TRACE_ENTER();
    p_cell_context = rrm_cellm_get_cell_context(cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "Cell Context not found");
        return RRM_FAILURE;
    }
    /* SPR 12396 Fix Start */
    p_cco_params = &p_rrc_rrm_ho_required->cco_params;
    RRM_ASSERT(RRM_PNULL != p_cco_params);
    /* SPR 12396 Fix Stop */

    p_ncl_params = rrm_cellm_get_ncl_params(cell_index); 

    p_daho_cell = rrm_cellm_get_daho_cell_config_info_params(cell_index);
    if(p_daho_cell != RRM_PNULL)
    {
        /*daho clean up(condition added for presence of daho cell)*/
        if(p_daho_cell->bitmask & EUTRA_DAHO_CELL_PRESENT)
        {
            daho_eutra_pci = p_daho_cell->eutran_daho_cell_config_info.phy_cell_id;
        }
        /*SPR 19075 Start*/
        /* SPR 18757 Fix Start */
        else if(p_daho_cell->bitmask & EUTRA_INTER_FREQ_DAHO_CELL_PRESENT)
        {
            for(inter_count = RRM_ZERO; inter_count < p_daho_cell->eutran_inter_freq_daho_cells_config_info_list.count; inter_count++)
            {
                if(phy_cell_id_info.phy_cell_id == p_daho_cell->eutran_inter_freq_daho_cells_config_info_list.
                    rrm_eutran_inter_freq_daho_cell_config_info[inter_count].phy_cell_id)
                {
                    daho_eutra_pci = p_daho_cell->eutran_inter_freq_daho_cells_config_info_list.
                        rrm_eutran_inter_freq_daho_cell_config_info[inter_count].phy_cell_id; 
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UEM: Daho_eutra_pci= %u", daho_eutra_pci);
                }
            }
        }
        /* SPR 18757 Fix End */
        else if(p_daho_cell->bitmask & UTRAN_DAHO_CELL_PRESENT)
        {
            daho_utra_pci = p_daho_cell->utran_daho_cell_config_info.pci;
        }
        /*daho clean up(condition added for presence of daho cell)*/
        else if(p_daho_cell->bitmask & GERAN_DAHO_CELL_PRESENT)
        {
            daho_geran_pci = p_daho_cell->geran_daho_cell_config_info.pci;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "NO DAHO CELL IS CONFIGURED");
        }
        /*SPR 19075 End*/
    }
    /* coverity id :16550 ,rel 2.0.1 */
    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */
    /* SPR 314 start */
    /* SPR 19431 Fix Start */
    /* SPR 16406 Start */
    if(target_cell_type == EUTRA_CELL) 
        /* SPR 314 end */
    {
        if(phy_cell_id_info.carr_earfcn == p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
        {
            if (p_ncl_params != RRM_PNULL)
            {
                for(intra_count = RRM_ZERO; intra_count < p_ncl_params->num_valid_intra_freq_cell; intra_count++) 
                {
                    if((phy_cell_id_info.phy_cell_id == p_ncl_params->intra_freq_cells[intra_count].phy_cell_id)
                        && (!(p_ue_context->ho_params.eutra_known_cell_selection_list.bitmask & RRM_UE_BLIND_CELL_HO_TRIGGERED)))
                    {
                        /* SPR_22194 Fix - Start */
                        /* Fix for CSR 58972 start*/
                        /* SPR 16406 18sep Start */
                        if ((phy_cell_id_info.bitmask & RRM_PHY_CELL_ID_INFO_CGI_PRESENT )
                            &&
                            (RRM_SUCCESS != compare_global_cell_id(&(phy_cell_id_info.cgi),
                                &(p_ncl_params->intra_freq_cells[intra_count].cell_id))))
                        /* SPR 16406 18sep End */
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Continue - Confused Intra Cell - Comparision Global Cell Id Fails"
                                " PCI[%d]", phy_cell_id_info.phy_cell_id);
                            continue;
                        }
                        /* Fix for CSR 58972 end*/
                        /* SPR_22194 Fix - End */

                        /* SPR 17564 Fix Start */
                        if(RRM_TRUE == rrm_is_eutran_cell_restricted(   p_ue_context,
                            /* SPR 17564 Fix End */
                            p_ncl_params->intra_freq_cells[intra_count].cell_id.primary_plmn_id,
                            p_ncl_params->intra_freq_cells[intra_count].tac,
                            &p_ue_context->ho_restriction_list))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                                    "Intra frequency Neighbor cell PCI[%d] Earfcn[%d], is restricted",
                                    phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Physical cell id [%d] Earfcn[%d] found in the intra frequency neighbour list"
                                ,phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                            p_target_id->bitmask = RRM_TARGET_ID_ENB_ID_PRESENT; 
                            p_target_id->enb_id.global_enb_id.plmn_identity.presence_bitmask =\
                                PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                            RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mcc,
                                &p_ncl_params->intra_freq_cells[intra_count].cell_id.primary_plmn_id.mcc,
                                MAX_MCC_DIGITS);
                            p_target_id->enb_id.global_enb_id.plmn_identity.mnc.count = \
                                p_ncl_params->intra_freq_cells[intra_count].cell_id.primary_plmn_id.num_mnc_digit;
                            RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mnc.mnc,
                                &p_ncl_params->intra_freq_cells[intra_count].cell_id.primary_plmn_id.mnc,
                                sizeof(p_ncl_params->intra_freq_cells[intra_count].\
                                cell_id.primary_plmn_id.mnc));
                            RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.cell_identity,
                                &p_ncl_params->intra_freq_cells[intra_count].cell_id.cell_identity,
                                MAX_CELL_IDENTITY_OCTETS);
                            /* Fix for CSR 58972 start*/
                            p_target_id->enb_id.global_enb_id.cell_type = rrm_get_enb_type_from_access_mode(
                                p_ncl_params->intra_freq_cells[intra_count].cell_access_mode);
                            /* Fix for CSR 58972 end*/
                            RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.plmn_identity,
                                &p_target_id->enb_id.global_enb_id.plmn_identity,
                                sizeof(p_target_id->enb_id.global_enb_id.plmn_identity));
                            /* SPR 5193: Filling TAC from NCL list */
                            RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.tracking_area_code,
                                &p_ncl_params->intra_freq_cells[intra_count].tac, MAX_TAC_SIZE);

                            /* Filling the ECGI value */
                            p_target_id->enb_id.global_enb_id.bitmask = EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT;
                            RRM_MEMCPY(&(p_target_id->enb_id.global_enb_id.ecgi[RRM_ZERO]),
                                &p_ncl_params->intra_freq_cells[intra_count].cell_id.cell_identity,
                                MAX_CELL_IDENTITY_OCTETS);
                            /*SPR 15180 Fix Start*/
                            /*CID 65856:start*/
                            /* If TRUE means x2_link is up */
                            /*SPR 17777 +-*/
                            /* SPR 19791 Fix Start */
                            if((RRM_TRUE == is_phy_cell_support_x2_neighbour(p_ncl_params,intra_count,phy_cell_id_info,&x2_up_status, RRM_TRUE)) &&
                                (X2_ALLOWED == x2_up_status || X2_ALLOWED_CONNECTED == x2_up_status || X2_LOCALLY_CONNECTED_CELL == x2_up_status))
                                /* SPR 19791 Fix Stop */
                                /*SPR 17777 +-*/
                                /*CID 65856:end*/
                            {
                                /* SPR 21446 start */
                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_DIRECT_FORWARD_PATH_AVAILABLE_PRESENT;
                                p_rrc_rrm_ho_required->direct_fwd_path_available = RRM_FALSE;
                                /* SPR 21446 end */
                                /*SPR 19596 Fix Start*/
                                if(X2_LOCALLY_CONNECTED_CELL == x2_up_status)
                                {
                                    /* Bug 881 Fix Start */
                                    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                    p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                    /* Bug 881 Fix Stop */
                                    p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTER_CELL;
                                    /*KPI:start*/
                                    p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTER_CELL;
                                    /*KPI:end*/
                                    /* SPR 21571 Fix Start */
                                    if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                        (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                        rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                        (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                    {
                                        p_rrc_rrm_ho_required->cause.value = RRM_X2AP_HO_DESIRABLE_FOR_RADIO_REASONS;
                                    }
                                    else
                                    { 
                                        p_rrc_rrm_ho_required->cause.value = RRM_X2AP_TIME_CRITICAL_HO;
                                    }
                                    /* SPR 21571 Fix End */
                                    p_ue_context->ho_type = HANDOVER_TYPE_INTER_CELL;
                                }
                                else
                                {
                                    /*SPR 19596 Fix End*/
                                    if(p_ue_context->is_gu_grp_info_present == RRM_TRUE)
                                    {
                                        if(RRM_NULL != p_ncl_params->intra_freq_cells[intra_count].p_enb_gu_group_id)
                                        {
                                            p_gu_group_id_node = find_gu_group_id_in_ncl_list(
                                                &p_ncl_params->intra_freq_cells[intra_count].\
                                                p_enb_gu_group_id->gu_group_id_list,&(p_ue_context->gu_group_id));
                                            if(PNULL != p_gu_group_id_node)
                                            {
                                                /* Bug 881 Fix Start */
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                                /* Bug 881 Fix Stop */
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                /*KPI:start*/
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_X2;
                                                /*KPI:end*/
                                                /* SPR_21459 Fix - Start */
                                                rrm_fill_gummei_info_in_ho_required(
                                                    p_rrc_rrm_ho_required, p_gu_group_id_node);
                                                /* SPR_21459 Fix - End */
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                    /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_HO_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_TIME_CRITICAL_HO;
                                                }
                                                /* SPR 17002 Fix End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "Gummei matched for Intra freq pci[%d] go for X2HO",
                                                    p_ncl_params->intra_freq_cells[intra_count].phy_cell_id);
                                            }
                                            else
                                            {
                                                /* Bug 881 Fix Start */
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                                /* Bug 881 Fix Stop */
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                /* SPR_13939_Fix_Start */
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                    /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                                }
                                                /* SPR 17002 Fix End */
                                                /* SPR_13939_Fix_End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                        "Gummei did not match for Intra freq pci[%d] go for S1HO",
                                                        p_ncl_params->intra_freq_cells[intra_count].phy_cell_id);
                                            }
                                        }
                                        else
                                        {
                                            /* Bug 881 Fix Start */
                                            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                            p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                            /* Bug 881 Fix Stop */
                                            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                            /* SPR_13939_Fix_Start */
                                            /* SPR 17002 Fix Start */
                                            /* SPR 17774_Fix_Start */
                                            if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                /* SPR 17774_Fix_Stop */
                                            {
                                                p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                            }
                                            else
                                            {
                                                p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                            }
                                            /* SPR 17002 Fix End */
                                            /* SPR_13939_Fix_End */
                                            p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                            p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "No GU Group Information for pci[%d] go for S1HO",
                                                    p_ncl_params->intra_freq_cells[intra_count].phy_cell_id);
                                        }
                                    }
                                    else
                                    {
                                        /* SPR 16477 Fix Start */
                                        /* SPR 16406 18sep Start */
                                        if(RRM_NULL != p_ncl_params->intra_freq_cells[intra_count].p_enb_gu_group_id)
                                        {
                                            /* SPR 16406 18sep End */
                                            /* SPR_21459 Fix - Start */
                                            /* MME ID is always present in UE Context as it provided by RRC
                                             * either during Attach or during HandIN scenarios */
                                            if(RRM_TRUE == rrm_checks_for_x2_ho_based_on_gummei_info(
                                                &p_ncl_params->intra_freq_cells[intra_count].p_enb_gu_group_id->gu_group_id_list,
                                                &p_g_rrm_cell_ctx->enb_context.connected_mme_list,
                                                p_rrc_rrm_ho_required,
                                                p_ue_context->mme_id))
                                                /* SPR_21459 Fix - End */
                                            {
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_X2;
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))

                                                /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_HO_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                { 
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_TIME_CRITICAL_HO;
                                                }
                                                /* SPR 17002 Fix End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "Gummei matched for Intra freq pci[%d] go for X2HO",
                                                    p_ncl_params->intra_freq_cells[intra_count].phy_cell_id);
                                            }
                                            /* SPR 16477 Fix Stop */
                                            else
                                            { 
                                                /* Bug 881 Fix Start */
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                                /* Bug 881 Fix Stop */
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                /* SPR_13939_Fix_Start */
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                { 
                                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                                }
                                                /* SPR 17002 Fix End */
                                                /* SPR_13939_Fix_End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "GU group info not present for Intra freq pci[%d] go for S1HO",
                                                    p_ncl_params->intra_freq_cells[intra_count].phy_cell_id);
                                                /* SPR 16477 Fix Start */
                                            }
                                            /* SPR 16406 18sep Start */
                                        }
                                        /* SPR 16406 18sep End */
                                    }
                                    /* SPR 16477 Fix Stop */
                                }
                                /*SPR 19596 Fix Start*/
                            }
                            /*SPR 19596 Fix End*/
                            else
                            {
                                /* Bug 881 Fix Start */
                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                                /* Bug 881 Fix Stop */
                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                /* SPR_13939_Fix_Start */
                                /* SPR 17002 Fix Start */
                                /* SPR 17774_Fix_Start */
                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                    /* SPR 17774_Fix_Stop */
                                {
                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                }
                                else
                                {
                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                }
                                /* SPR 17002 Fix End */
                                /* SPR_13939_Fix_End */
                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;

                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                        "Go for S1HO for Intra freq pci[%d]",
                                        p_ncl_params->intra_freq_cells[intra_count].phy_cell_id);
                            }
                            /*SPR 15180 Fix Stop*/
                            /* Inter RAT changes start */
                            /*csg start*/
                            /* SPR_15636_Fix: Start */
                            /* Check the CSG status of the target cell selected & decide whether to do X2 based HO or S1 based HO
                             * 1. If Source is Open Cell & Target is CSG, then Source does not know wheather the UE will be member on the target.
                             *    So S1 HO should be done so that MME could check the UE's membership applicability on the Target.
                             * 2. If Source is CSG/Hybrid Cell & UE is member on the cell based on the Source's CSG ID. eNB only gets the info from
                             *    the MME about Member or Non-Member not the UE's CSG ID, Hence eNB cannot compare the UE's CSG ID to the Target's
                             *    CSG ID and therefore check the UE's Membership status on the Target. So S1-HO need to be done.
                             */
                            /* Function will return TRUE if the HO Type set was X2-HO on the basis of GUMMEID & needs to be changed to S1-HO*/
                            if(RRM_TRUE == rrm_is_s1ho_reqd_for_csg_status_of_src_and_tgt_for_intra(p_ue_context,
                                &(p_ncl_params->intra_freq_cells[intra_count])))
                            {
                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                /* SPR_13939_Fix_Start */
                                /* SPR 17002 Fix Start */
                                /* SPR 17774_Fix_Start */
                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                    /* SPR 17774_Fix_Stop */
                                {
                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                }
                                else
                                { 
                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                }
                                /* SPR 17002 Fix End */
                                /* SPR_13939_Fix_End */
                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                            }
                            /* SPR_15636_Fix: End */
                            if(p_ncl_params->intra_freq_cells[intra_count].bitmask & RRM_OAM_INTRA_FREQ_CSG_ID_PRESENT)      
                            {
                                p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CSG_ID_PRESENT;
                                RRM_MEMCPY(p_rrm_temp_cell_info->csg_id,p_ncl_params->intra_freq_cells[intra_count].csg_identity,
                                    NUM_CSG_OCTETS);
                            }
                            if(p_ncl_params->intra_freq_cells[intra_count].bitmask & RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT)
                            {
                                p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CELL_ACCESS_MODE_PRESENT;
                                /*coverity 23139: typecast to rrm_oam_access_mode_et: simerjit, rel 1.3*/
                                p_rrm_temp_cell_info->cell_access_mode = (rrm_oam_access_mode_et)p_ncl_params->intra_freq_cells[intra_count].cell_access_mode;
                            }
                            /* SPR 12396 Fix Start */
                            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                            p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                            /* SPR 12396 Fix Stop */

                            /* SPR_22194 Fix - Start */
                             return RRM_SUCCESS ;
                            /* Code to check Handover on Confused Cell moved to Start of the for loop */
                            /* SPR_22194 Fix - End */
                            /* Inter RAT changes end */
                        }
                    }
                }
            }
            if(daho_eutra_pci == phy_cell_id_info.phy_cell_id)
            {
                ret_val = fill_target_id_with_daho_info(p_target_id,cell_index,HANDOVER_TYPE_INTRA_LTE_X2);

                /* SPR 12396 Fix Start */
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
                /* SPR 12396 Fix Stop */
                return RRM_SUCCESS;
            }
        }
        /* SPR 16406 End */

        /* SPR 16406 Start */
        if(phy_cell_id_info.carr_earfcn != p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
        {
            if (p_ncl_params != RRM_PNULL)
            {
                for(inter_count = RRM_ZERO; inter_count < p_ncl_params->num_valid_inter_freq_cell; inter_count++) 
                {
                    if((phy_cell_id_info.phy_cell_id == p_ncl_params->inter_freq_cells[inter_count].phy_cell_id)
                        && (p_ncl_params->inter_freq_cells[inter_count].eutra_carrier_arfcn == phy_cell_id_info.carr_earfcn)
                        && (!(p_ue_context->ho_params.eutra_known_cell_selection_list.bitmask & RRM_UE_BLIND_CELL_HO_TRIGGERED)))
                    {
                        /* SPR_22194 Fix - Start */
                        /* Fix for CSR 58972 start*/
                        /* SPR 16406 18sep Start */
                        if ((phy_cell_id_info.bitmask & RRM_PHY_CELL_ID_INFO_CGI_PRESENT )
                            &&
                            (RRM_SUCCESS != compare_global_cell_id(&(phy_cell_id_info.cgi),
                                &(p_ncl_params->inter_freq_cells[inter_count].cell_id))))
                        /* SPR 16406 18sep End */
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Continue - Confused Inter Cell - Comparision Global Cell Id Fails"
                                " PCI[%d]", phy_cell_id_info.phy_cell_id);
                            continue;
                        }
                        /* Fix for CSR 58972 end*/
                        /* SPR_22194 Fix - End */

                        /* ho_restriction at meas config */
                        /* SPR 17564 Fix Start */
                        if(RRM_TRUE == rrm_is_eutran_cell_restricted(   p_ue_context,
                            /* SPR 17564 Fix End */
                            p_ncl_params->inter_freq_cells[inter_count].cell_id.primary_plmn_id,
                            p_ncl_params->inter_freq_cells[inter_count].tac,
                            &p_ue_context->ho_restriction_list))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Inter frequency Neighbor cell PCI[%d] Earfcn[%d], is restricted",
                                phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Physical cell id [%d] Earfcn[%d] found in the inter frequency neighbour list"
                                ,phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                            p_target_id->bitmask = RRM_TARGET_ID_ENB_ID_PRESENT; 
                            p_target_id->enb_id.global_enb_id.plmn_identity.presence_bitmask =\
                                PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                            RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mcc,
                                &p_ncl_params->inter_freq_cells[inter_count].cell_id.primary_plmn_id.mcc,
                                MAX_MCC_DIGITS);
                            p_target_id->enb_id.global_enb_id.plmn_identity.mnc.count = \
                                p_ncl_params->inter_freq_cells[inter_count].cell_id.primary_plmn_id.num_mnc_digit;
                            RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.plmn_identity.mnc.mnc,
                                &p_ncl_params->inter_freq_cells[inter_count].cell_id.primary_plmn_id.mnc,
                                sizeof(p_ncl_params->inter_freq_cells[inter_count].\
                                cell_id.primary_plmn_id.mnc));
                            RRM_MEMCPY(&p_target_id->enb_id.global_enb_id.cell_identity,
                                &p_ncl_params->inter_freq_cells[inter_count].cell_id.cell_identity,
                                MAX_CELL_IDENTITY_OCTETS);
                            /* Fix for CSR 58972 start*/
                            p_target_id->enb_id.global_enb_id.cell_type = rrm_get_enb_type_from_access_mode(
                                p_ncl_params->inter_freq_cells[inter_count].cell_access_mode);
                            /* Fix for CSR 58972 end*/  
                            RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.plmn_identity,
                                &p_target_id->enb_id.global_enb_id.plmn_identity,
                                sizeof(p_target_id->enb_id.global_enb_id.plmn_identity));
                            /* SPR 5193: Filling TAC from NCL list */
                            RRM_MEMCPY(&p_target_id->enb_id.tracking_area_id.tracking_area_code,
                                &p_ncl_params->inter_freq_cells[inter_count].tac, MAX_TAC_SIZE);
                            /* Filling the ECGI value */
                            p_target_id->enb_id.global_enb_id.bitmask = EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT;
                            RRM_MEMCPY(&(p_target_id->enb_id.global_enb_id.ecgi[RRM_ZERO]),
                                &p_ncl_params->inter_freq_cells[inter_count].cell_id.cell_identity,
                                MAX_CELL_IDENTITY_OCTETS);
                            /* Inter RAT changes start */
                            /* CID 115527 +- */
                            /*SPR 15180 Fix Start*/
                            /*CID 65856:start*/
                            /* If TRUE means x2_link is up */
                            /*SPR 17777 +-*/
                            /* SPR 21571 Fix Start */
                            if(RRM_TRUE ==  is_phy_cell_support_x2_neighbour(p_ncl_params,inter_count,phy_cell_id_info,&x2_up_status, RRM_FALSE) &&
                                (X2_ALLOWED == x2_up_status || X2_ALLOWED_CONNECTED == x2_up_status || X2_LOCALLY_CONNECTED_CELL == x2_up_status))
                                /*SPR 17777 +-*/
                                /*CID 65856:end*/
                            {
                                if(X2_LOCALLY_CONNECTED_CELL == x2_up_status)
                                {
                                    /* Bug 881 Fix Start */
                                    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                    p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                    /* Bug 881 Fix Stop */
                                    p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTER_CELL;
                                    /*KPI:start*/
                                    p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTER_CELL;
                                    /*KPI:end*/
                                    /* SPR 21571 Fix Start */
                                    if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                 rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                            (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                    {
                                        p_rrc_rrm_ho_required->cause.value = RRM_X2AP_HO_DESIRABLE_FOR_RADIO_REASONS;
                                    }
                                    else
                                    { 
                                        p_rrc_rrm_ho_required->cause.value = RRM_X2AP_TIME_CRITICAL_HO;
                                    }
                                    /* SPR 21571 Fix End */
                                    p_ue_context->ho_type = HANDOVER_TYPE_INTER_CELL;
                                }
                                else
                                {
                                    if(p_ue_context->is_gu_grp_info_present == RRM_TRUE)
                                    {
                                        if(RRM_NULL != p_ncl_params->inter_freq_cells[inter_count].p_enb_gu_group_id)
                                        {
                                            p_gu_group_id_node = find_gu_group_id_in_ncl_list(&p_ncl_params->inter_freq_cells[inter_count].\
                                                p_enb_gu_group_id->gu_group_id_list,&(p_ue_context->gu_group_id));
                                            if(RRM_PNULL != p_gu_group_id_node)
                                            {
                                                /* Bug 881 Fix Start */
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                                /* Bug 881 Fix Stop */
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                /*KPI:start*/
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_X2;
                                                /*KPI:end*/
                                                /* SPR_21459 Fix - Start */
                                                rrm_fill_gummei_info_in_ho_required(
                                                    p_rrc_rrm_ho_required, p_gu_group_id_node);
                                                /* SPR_21459 Fix - End */
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_HO_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                { 
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_TIME_CRITICAL_HO;
                                                }
                                                /* SPR 17002 Fix End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "Gummei matched for frequency[%d] and pci[%d] go for X2HO",
                                                    p_ncl_params->inter_freq_cells[inter_count].eutra_carrier_arfcn,
                                                    p_ncl_params->inter_freq_cells[inter_count].phy_cell_id);
                                            }
                                            else
                                            {
                                                /* Bug 881 Fix Start */
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                                /* Bug 881 Fix Stop */
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                /* SPR_13939_Fix_Start */
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                { 
                                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                                }
                                                /* SPR 17002 Fix End */
                                                /* SPR_13939_Fix_End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "Gummei did not match for frequency[%d] and pci[%d] go for S1HO",
                                                    p_ncl_params->inter_freq_cells[inter_count].eutra_carrier_arfcn,
                                                    p_ncl_params->inter_freq_cells[inter_count].phy_cell_id);
                                            }
                                        }
                                        else
                                        {
                                            /* Bug 881 Fix Start */
                                            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                            p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                            /* Bug 881 Fix Stop */
                                            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                            /* SPR_13939_Fix_Start */
                                            /* SPR 17002 Fix Start */
                                            /* SPR 17774_Fix_Start */
                                            if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                            /* SPR 17774_Fix_Stop */
                                            {
                                                p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                            }
                                            else
                                            {
                                                p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                            }
                                            /* SPR 17002 Fix End */
                                            /* SPR_13939_Fix_End */
                                            p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                            p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                                            /* SPR_15636_Fix: Start */
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                                "NO ENB node in NCL for ho_typ [%d] frequency[%d] and pci[%d] ",
                                                p_ue_context->ho_typ,
                                                p_ncl_params->inter_freq_cells[inter_count].eutra_carrier_arfcn,
                                                p_ncl_params->inter_freq_cells[inter_count].phy_cell_id);
                                            /* SPR_15636_Fix: End */
                                        }
                                    }
                                    else
                                    {
                                        /* SPR 16406 18sep Start */
                                        if(RRM_NULL != p_ncl_params->inter_freq_cells[inter_count].p_enb_gu_group_id)
                                        {
                                            /* SPR 16406 18sep End */
                                            /* SPR_21459 Fix - Start */
                                            /* MME ID is always present in UE Context as it provided by RRC
                                             * either during Attach or during HandIN scenarios */
                                            /* SPR 16477 Fix Start */
                                            if(RRM_TRUE ==  rrm_checks_for_x2_ho_based_on_gummei_info(
                                                &p_ncl_params->inter_freq_cells[inter_count].p_enb_gu_group_id->gu_group_id_list,
                                                &p_g_rrm_cell_ctx->enb_context.connected_mme_list,
                                                p_rrc_rrm_ho_required,
                                                p_ue_context->mme_id))
                                            /* SPR_21459 Fix - End */
                                            {
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_X2;
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received ))
                                                /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_HO_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = RRM_X2AP_TIME_CRITICAL_HO;
                                                }
                                                /* SPR 17002 Fix End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "Gummei matched for and pci[%d] EARFCN[%d] go for X2HO",
                                                    p_ncl_params->inter_freq_cells[inter_count].phy_cell_id,
													p_ncl_params->inter_freq_cells[inter_count].eutra_carrier_arfcn);
                                            }
                                            /* SPR 16477 Fix Stop */
                                            else
                                            {
                                                /* Bug 881 Fix Start */
                                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                                /* Bug 881 Fix Stop */
                                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                /* SPR_13939_Fix_Start */
                                                /* SPR 17002 Fix Start */
                                                /* SPR 17774_Fix_Start */
                                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                                /* SPR 17774_Fix_Stop */
                                                {
                                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                                }
                                                else
                                                { 
                                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                                }
                                                /* SPR 17002 Fix End */
                                                /* SPR_13939_Fix_End */
                                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                                                    "GU group info not present in ue context for frequency[%d] and pci[%d] go for S1HO",
                                                    p_ncl_params->inter_freq_cells[inter_count].eutra_carrier_arfcn,
                                                    p_ncl_params->inter_freq_cells[inter_count].phy_cell_id);
                                            }
                                            /* SPR 16406 18sep Start */
                                        }
                                        /* SPR 16406 18sep End */
                                    }
                                    /* SPR 21571 Fix Start */
                                }
                                /* SPR 21571 Fix End */
                            }
                            else
                            {
                                /* Bug 881 Fix Start */
                                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                                /* Bug 881 Fix Stop */
                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                /* SPR_13939_Fix_Start */
                                /* SPR 17002 Fix Start */
                                /* SPR 17774_Fix_Start */
                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                /* SPR 17774_Fix_Stop */
                                {
                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                }
                                else
                                { 
                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                }
                                /* SPR 17002 Fix End */
                                /* SPR_13939_Fix_End */
                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                            }

                            /*SPR 15180 Fix Stop*/
                            /*csg start*/
                            /* SPR_15636_Fix: Start */
                            /* Check the CSG status of the target cell selected & decide whether to do X2 based HO or S1 based HO
                             * 1. If Source is Open Cell & Target is CSG, then Source does not know wheather the UE will be member on the target.
                             *    So S1 HO should be done so that MME could check the UE's membership applicability on the Target.
                             * 2. If Source is CSG/Hybrid Cell & UE is member on the cell based on the Source's CSG ID. eNB only gets the info from
                             *    the MME about Member or Non-Member not the UE's CSG ID, Hence eNB cannot compare the UE's CSG ID to the Target's
                             *    CSG ID and therefore check the UE's Membership status on the Target. So S1-HO need to be done.
                             */
                            /* Function will return TRUE if the HO Type set was X2-HO on the basis of GUMMEID & needs to be changed to S1-HO*/
                            if(RRM_TRUE == rrm_is_s1ho_reqd_for_csg_status_of_src_and_tgt_for_inter(p_ue_context,
                                &(p_ncl_params->inter_freq_cells[inter_count])))
                            {
                                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                /* SPR_13939_Fix_Start */
                                /* SPR 17002 Fix Start */
                                /* SPR 17774_Fix_Start */
                                if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) &&
                                    (RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                    rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                                    (RRM_FALSE == p_ue_context->ho_params.a2_event_received))
                                /* SPR 17774_Fix_Stop */
                                {
                                    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
                                }
                                else
                                { 
                                    p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
                                }
                                /* SPR 17002 Fix End */
                                /* SPR_13939_Fix_End */
                                p_ue_context->ho_type = HANDOVER_TYPE_INTRA_LTE_S1;
                                p_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_LTE_S1;
                            }
                            /* SPR_15636_Fix: End */
                            if(p_ncl_params->inter_freq_cells[inter_count].bitmask & RRMCM_RMIF_CSG_ID_PRESENT)
                            {
                                p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CSG_ID_PRESENT;
                                RRM_MEMCPY(p_rrm_temp_cell_info->csg_id,p_ncl_params->inter_freq_cells[inter_count].csg_identity,
                                    NUM_CSG_OCTETS);
                            }
                            if(p_ncl_params->inter_freq_cells[inter_count].bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT)
                            {
                                p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CELL_ACCESS_MODE_PRESENT;
                                /*coverity 23140: typecast to rrm_oam_access_mode_et: simerjit, rel 1.3*/
                                p_rrm_temp_cell_info->cell_access_mode = (rrm_oam_access_mode_et)p_ncl_params->inter_freq_cells[inter_count].cell_access_mode;
                            }
                            /* SPR 12396 Fix Start */
                            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                            p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                            /* SPR 12396 Fix Stop */

                            /* SPR_22194 Fix - Start */
                            return RRM_SUCCESS ;
                            /* Code to check Handover on Confused Cell moved to Start of the for loop */
                            /* SPR_22194 Fix - End */
                        }
                    }
                }
            }
            /* SPR 20007 : CID 93954 Fix Start */
            /* SPR 19431 Fix Stop */
            if(daho_eutra_pci == phy_cell_id_info.phy_cell_id)
            {
                ret_val = fill_target_id_with_daho_info(p_target_id,cell_index,HANDOVER_TYPE_INTRA_LTE_S1);

                /* SPR 12396 Fix Start */
                /* SPR 19075 Start */
                /* EUTRAN DAHO is inter-freq */
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
                p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTER_FREQ;
                /* SPR 19075 End */
                /* SPR 12396 Fix Stop */

                return RRM_SUCCESS;
            }
        }
        /* SPR 20007 : CID 93954 Fix End */
        /* SPR 16406 End */
        /* Inter RAT changes start */
    }
    p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(cell_index);
    /* SPR 314 start */
    if((p_irat_ncl != RRM_PNULL) && ((target_cell_type == UTRA_CELL) || (target_cell_type == GERAN_CELL)))
        /* SPR 314 end */    
    {
        /* Inter RAT changes end */
        /* SPR 314 start */
        for(inter_count = RRM_ZERO; \
            (inter_count < p_irat_ncl->num_valid_utran_freq_cell)&& (target_cell_type == UTRA_CELL) ; inter_count++)
        /* SPR 314 end */
        {
            if((phy_cell_id_info.phy_cell_id == p_irat_ncl->utran_freq_cells[inter_count].pcpich_scrambling_code) 
                && (p_irat_ncl->utran_freq_cells[inter_count].uarfcndl == phy_cell_id_info.carr_earfcn))
            {
                utran_freq_cells_t *p_utra_cell = &(p_irat_ncl->\
                    utran_freq_cells[inter_count]);
                /* ho_restriction : code changes start */
                /* SPR 17564 Fix Start */
                if(RRM_TRUE == rrm_is_inter_rat_cell_restricted(p_ue_context,
                    /* SPR 17564 Fix End */
                    p_utra_cell->rai.lai.plmn_identity,
                    p_utra_cell->rai.lai.lac,
                    UTRA_CELL,
                    &p_ue_context->ho_restriction_list) )
                {
                    RRM_TRACE ( g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_WARNING,
                            "UTRAN PCI [%d] Earfcn [%d] is restricted",
                            phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                }
                /* ho_restriction : code changes end */
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                            "Physical cell id [%d] Earfcn [%d] found in the UTRA neighbour list"
                            ,phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);

                    p_target_id->bitmask |= RRM_TARGET_ID_RNC_ID_PRESENT; 
                    if(p_utra_cell->uc_id.bitmask & RRM_UTRAN_EXTN_RNC_ID_PRESENT)
                    {
                        p_target_id->rnc_id.bitmask |= \
                            RRM_RNC_EXTENDED_RNC_ID_PRESENT;
                        p_target_id->rnc_id.extended_rnc_id = \
                            p_utra_cell->uc_id.extended_rnc_id;
                    }
                    p_target_id->rnc_id.bitmask |= \
                        RRM_RNC_ROUTING_AREA_CODE_PRESENT;
                    p_target_id->rnc_id.routing_area_code = \
                        p_utra_cell->rai.rac;

                    p_target_id->rnc_id.rnc_id = p_utra_cell->uc_id.rnc_id;
                    /*BUG 680 FIX START*/
                    rrm_map_lai_info(&(p_target_id->rnc_id.lai),&(p_utra_cell->rai.lai));
                    /*BUG 680 FIX END*/
                    /* SPR 19364 start */
                    /* Code removed */
                    /* SPR 19364 end */
                    /*csg start*/
                    if(p_irat_ncl->utran_freq_cells[inter_count].bitmask & RRM_OAM_UTRAN_FREQ_CSG_ID_PRESENT)
                    {
                        p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CSG_ID_PRESENT;
                        RRM_MEMCPY(p_rrm_temp_cell_info->csg_id,p_irat_ncl->utran_freq_cells[inter_count].csg_identity,
                            NUM_CSG_OCTETS);
                    }
                    if(p_irat_ncl->utran_freq_cells[inter_count].bitmask & RRM_OAM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT)
                    {
                        p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CELL_ACCESS_MODE_PRESENT;
                        /*coverity 23141:typecast to rrm_oam_access_mode_et: simerjit, rel 1.3*/
                        p_rrm_temp_cell_info->cell_access_mode = (rrm_oam_access_mode_et)p_irat_ncl->utran_freq_cells[inter_count].cell_access_mode;
                    }
                    /* Fix 10029 Start */
                    p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CELL_ID_PRESENT; 

                    /* SPR 10137 Start */
                    RRM_MEMSET(&p_rrm_temp_cell_info->cell_id, RRM_ZERO, sizeof(U32));

                    if(RRM_OAM_EXTENDED_RNC_ID & p_irat_ncl->utran_freq_cells[inter_count].uc_id.bitmask)
                    {
                        RRM_MEMCPY(&p_rrm_temp_cell_info->cell_id, &p_irat_ncl->utran_freq_cells[inter_count].uc_id.extended_rnc_id,
                            sizeof(U16));
                        p_rrm_temp_cell_info->cell_id = (p_rrm_temp_cell_info->cell_id << RRM_UMTS_CID_MIN_NUM_BITS);
                        RRM_MEMCPY(&cell_identity, &p_irat_ncl->utran_freq_cells[inter_count].uc_id.cell_id[1], sizeof(U8));
                        cell_identity = (cell_identity & 0x0F) << RRM_BYTE_SIZE_IN_BITS;
                        cell_identity |= p_irat_ncl->utran_freq_cells[inter_count].uc_id.cell_id[0];
                    }
                    else
                    {
                        RRM_MEMCPY(&p_rrm_temp_cell_info->cell_id, &p_irat_ncl->utran_freq_cells[inter_count].uc_id.rnc_id,
                            sizeof(U16));
                        p_rrm_temp_cell_info->cell_id = (p_rrm_temp_cell_info->cell_id << 16);
                        RRM_MEMCPY(&cell_identity, &p_irat_ncl->utran_freq_cells[inter_count].uc_id.cell_id[1], sizeof(U8));
                        cell_identity = (cell_identity << RRM_BYTE_SIZE_IN_BITS);
                        cell_identity |= p_irat_ncl->utran_freq_cells[inter_count].uc_id.cell_id[0];
                    }	
                    p_rrm_temp_cell_info->cell_id |= cell_identity;
                    /* SPR 10137 End */
                    /* Fix 10029 End */
                    /*csg end*/
                    return RRM_SUCCESS;
                }
            }
        }
        /* Inter RAT changes end */
        /* GERAN-HO changes start */
        /* SPR 314 start */
        for(inter_count = RRM_ZERO; (inter_count < p_irat_ncl->num_valid_geran_cell) && (target_cell_type == GERAN_CELL); \
            inter_count++)
        /* SPR 314 end */
        {
            /* SPR 16406 Start */
            if((phy_cell_id_info.phy_cell_id == p_irat_ncl->geran_freq_cells[inter_count].pci)
                && (p_irat_ncl->geran_freq_cells[inter_count].bcch_arfcn == phy_cell_id_info.carr_earfcn)
                && (!(p_ue_context->ho_params.geran_known_cell_selection_list.bitmask && RRM_UE_BLIND_CELL_HO_TRIGGERED)))
            /* SPR 16406 End */
            {
                geran_freq_ncl_t *p_geran_cells = &(p_irat_ncl->\
                    geran_freq_cells[inter_count]);
                /* SPR 17564 Fix Start */
                if(RRM_TRUE == rrm_is_inter_rat_cell_restricted(p_ue_context,
                    /* SPR 17564 Fix End */
                    p_irat_ncl->geran_freq_cells[inter_count].lai.plmn_identity,
                    p_irat_ncl->geran_freq_cells[inter_count].lai.lac,
                    GERAN_CELL,
                    &p_ue_context->ho_restriction_list) )
                {
                    RRM_TRACE (g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_WARNING,
                            "selected GERAN PCI [%d] Earfcn [%d] is restricted",
                            phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                            "Physical cell id [%d] Earfcn [%d] found in the GERAN neighbour list"
                            ,phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                    p_target_id->bitmask |= RRM_TARGET_ID_CGI_PRESENT;
                    RRM_MEMCPY(
                        &(p_target_id->cgi.plmn_identity),
                        &(p_geran_cells->lai.plmn_identity),
                        sizeof(plmn_identity_t));
                    RRM_MEMCPY(
                        p_target_id->cgi.location_area_code,
                        &(p_geran_cells->lai.lac),
                        RRM_OAM_MAX_NUM_LAC_OCTETS);
                    /* Fill Cell Identity and RAC if present */
                    /*gur2615*/
                    /*spr_20246_changes_start*/
                    p_target_id->cgi.ci_info[RRM_ZERO] = p_geran_cells->cell_id >> RRM_EIGHT;
                    p_target_id->cgi.ci_info[RRM_ONE] = p_geran_cells->cell_id & RRM_U16_LOW_BYTE_MASK;
                    /*spr_20246_changes_end*/
                    /* SPR 15393 Fix Start */
                    if (p_geran_cells->bitmask & RRM_GERAN_FREQ_CELL_RAC_PRESENT)
                    {
                        p_target_id->cgi.routing_area_code = p_geran_cells->rac;
                        p_target_id->cgi.bitmask |=	RRM_CGI_INFO_ROUTING_AREA_CODE;
                    }
                    /* SPR 15393 Fix Stop */
                    /* SPR 19364 start */
                    /* Code removed */
                    /* SPR 19364 end */
                    /* Start :SPR 8948 */
                    /*CCO changes begin*/
                    /* SPR_14067_Fix_Start */
                    /* SPR 19364 start */
                    if ( ! ((RRM_TRUE == rrm_cellm_get_ps_ho_flag(p_ue_context->cell_index)) &&
                        (phy_cell_id_info.bitmask & RRM_CELL_DTM_HO_SUPPORTED)))
                    /* SPR 19364 end */
                    {
                        /* SPR 19364 start */
                        if (RRM_TRUE == rrm_ue_check_for_cco(p_ue_context, &phy_cell_id_info))
                        /* SPR 19364 end */
                        /* SPR_14067_Fix_End */
                        {
                            rrm_ue_fill_cco_params(p_cco_params,
                                &(p_irat_ncl->geran_freq_cells[inter_count]));
                            /* SPR 19364 start */
                            p_rrc_timers = rrm_cellm_get_timer_info(cell_index);
                            if(RRM_PNULL != p_rrc_timers)
                            {
                                /*SPR 19647 FIX START*/
                                p_rrc_rrm_ho_required->mobility_control_info.t304_timer = p_rrc_timers->t304_irat;
                            }
                            /*SPR 19647 FIX END*/
                            p_rrc_rrm_ho_required->bitmask |=RRC_RRM_UE_HO_CCO_PARAMS_PRESENT;/*Akhilesh*/
                            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_MOBILITY_CONTROL_INFO_PRESENT;
                            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_CCO;
                            p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;
                            /*KPI:start*/
                            p_ue_context->ho_typ = RRM_HANDOVER_TYPE_CCO;
                            /*KPI:end*/
                            /* SPR 19364 end */
                            /* SPR 19364 start */
                        }
                        /* SPR 19364 end */  
                        /* SPR 19364 start */
                        else
                        {
                            p_rrc_rrm_ho_required->band_indicator = p_irat_ncl->\
                                geran_freq_cells[inter_count].band_indicator;
                            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_BAND_INDICATOR_PRESENT;
                        }
                        /* SPR 19364 end */  
                    }
                    /* SPR 19364 start */
                    else
                    {
                        p_rrc_rrm_ho_required->band_indicator = p_irat_ncl->\
                            geran_freq_cells[inter_count].band_indicator;
                        p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_BAND_INDICATOR_PRESENT;
                    }
                    /* SPR 19364 end */  
                    /*CCO changes end*/
                    /* End :SPR 8948 */
                    RRM_UT_TRACE_EXIT();
                    return RRM_SUCCESS;
                }
            }
        } 
        /* GERAN-HO changes end */
    }

    if(daho_utra_pci == phy_cell_id_info.phy_cell_id)
    {
        ret_val = fill_target_id_with_daho_info(p_target_id,cell_index,HANDOVER_TYPE_LTE_TO_UTRAN);

        /* SPR 10272 Start */
        if(RRM_SUCCESS == ret_val)
        {
            rrm_utran_daho_cell_config_info_t   *p_utra_daho_cell = RRM_PNULL;

            p_utra_daho_cell = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.
                daho_cell_config_info.utran_daho_cell_config_info);
            p_rrm_temp_cell_info->bitmask |= RRM_UEM_TEMP_CELL_ID_PRESENT;

            RRM_MEMSET(&p_rrm_temp_cell_info->cell_id, RRM_ZERO, sizeof(U32));

            if(RRM_OAM_EXTENDED_RNC_ID & p_utra_daho_cell->uc_id.bitmask)
            {
                RRM_MEMCPY(&p_rrm_temp_cell_info->cell_id, &p_utra_daho_cell->uc_id.extended_rnc_id,
                    sizeof(U16));
                p_rrm_temp_cell_info->cell_id = (p_rrm_temp_cell_info->cell_id << RRM_UMTS_CID_MIN_NUM_BITS);
                RRM_MEMCPY(&cell_identity, &p_utra_daho_cell->uc_id.cell_id[1], sizeof(U8));
                cell_identity = (cell_identity & 0x0F) << RRM_BYTE_SIZE_IN_BITS;
                cell_identity |= p_utra_daho_cell->uc_id.cell_id[0];
            }
            else
            {
                RRM_MEMCPY(&p_rrm_temp_cell_info->cell_id, &p_utra_daho_cell->uc_id.rnc_id,
                    sizeof(U16));
                p_rrm_temp_cell_info->cell_id = (p_rrm_temp_cell_info->cell_id << 16);
                RRM_MEMCPY(&cell_identity, &p_utra_daho_cell->uc_id.cell_id[1], sizeof(U8));
                cell_identity = (cell_identity << RRM_BYTE_SIZE_IN_BITS);
                cell_identity |= p_utra_daho_cell->uc_id.cell_id[0];
            }

            p_rrm_temp_cell_info->cell_id |= cell_identity;
        }
        /* SPR 10272 Start */
        /* SPR 19364 start */
        /* Code removed */
        /* SPR 19364 end */
        RRM_UT_TRACE_EXIT();
        return RRM_SUCCESS;
    }
    /* GERAN-HO changes start */
    if(daho_geran_pci == phy_cell_id_info.phy_cell_id)
    {
        ret_val = fill_target_id_with_daho_info(
            p_target_id,
            cell_index,
            HANDOVER_TYPE_LTE_TO_GERAN);
        /* SPR 19364 start */
        /* Code removed */
        /* SPR 19364 end */
        /*CCO changes begin*/
        /* SPR 19364 start */
        /* SPR_14067_Fix_Start */
        if (RRM_TRUE == rrm_ue_check_for_cco(p_ue_context, &phy_cell_id_info))
        /* SPR_14067_Fix_End */
        /* SPR 19364 end */
        {
            rrm_ue_fill_cco_params_for_daho_cell(p_cco_params,p_daho_cell);
        }
        /*CCO changes end*/

        return RRM_SUCCESS;
    }
    /* GERAN-HO changes end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 15674 End */
/*Klockwork_fix_start*/

/*SPR 15752 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_dl_earfcn
 *   INPUT      : p_choice_eutra_mode 
 *   OUTPUT     : none
 *   DESCRIPTION: 
 *   RETURNS:  This returns the DL EARFCN from rrm_x2ap_choice_eutra_mode_t 
 ******************************************************************************/
static  U32 rrm_get_dl_earfcn(rrm_x2ap_choice_eutra_mode_t * p_choice_eutra_mode)
{
    U32 dl_earfcn; 
    RRM_UT_TRACE_ENTER();
    if(RRM_X2AP_EUTRA_MODE_FDD ==  p_choice_eutra_mode->bitmask)
    {
        dl_earfcn = p_choice_eutra_mode->fdd_info.dl_earfcn.earfcn; 
    }
    else 
    {
        dl_earfcn = p_choice_eutra_mode->tdd_info.earfcn.earfcn;
    }
    RRM_UT_TRACE_EXIT();
    return dl_earfcn;
}
/*SPR 15752 Fix Stop */
/* SPR 15674 Start*/
/******************************************************************************
 *   FUNCTION NAME: is_x2_link_exist
 *   INPUT      : phy_cell_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *                Checks weather X2 x2 neoghbor exist or not
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
is_x2_link_exist 
	(
 phy_cell_id_info_t phy_cell_id_info
	)
{
    U8 count=0;
    rrm_return_et      ret_val = RRM_FAILURE;
    rrm_x2ap_enb_node_t         *p_x2ap_enb_node = RRM_PNULL;
    YLNODE *p_node = RRM_PNULL;

    p_node = ylFirst(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));
    RRM_UT_TRACE_ENTER();
     while (p_node)
     {
         p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;
         /* MENB CHANGES - START */
         for(count = RRM_ZERO;count< p_x2ap_enb_node->link_up_data.eutra_cell_info.num_served_cell;count++)
         {
            if((phy_cell_id_info.phy_cell_id == p_x2ap_enb_node->link_up_data.eutra_cell_info.cell_info[count].
                               ngh_dir_cell_arr.served_cell_info.pci)
            /*SPR 15752 Fix Start */
                &&  (phy_cell_id_info.carr_earfcn  == 
                rrm_get_dl_earfcn(&p_x2ap_enb_node->link_up_data.eutra_cell_info.cell_info[count].
                ngh_dir_cell_arr.served_cell_info.choice_eutra_mode.choice_eutra_mode))) 
            /*SPR 15752 Fix Stop */
            {    
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Physical cell id [%d] Earfcn[%d]found in the X2 neighbour list"
                        ,phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                 ret_val = RRM_SUCCESS;
                 break;
             }
         }
         /* MENB CHANGES - END */
         if(ret_val == RRM_SUCCESS)
         {
             break;
         }
         p_node = ylNext(p_node);
    }
    return ret_val;
}
/* SPR 15674 End */

/* SPR 15674 Start*/
/******************************************************************************
 *   FUNCTION NAME: is_phy_cell_support_x2_neighbour 
 *   INPUT      : phy_cell_id,p_x2_link_up,p_cell_index
 *   OUTPUT     :
 *   DESCRIPTION:
 *       Checks weather phy_cell_id supported by x2 neoghbor or not
 *
 *   RETURNS:
 *       RRM_TRUE  on Success
 *       RRM_FALSE  on Failure
 ******************************************************************************/
/*SPR 15180 Fix Start*/
rrm_bool_et 
is_phy_cell_support_x2_neighbour 
(
 lte_ncl_t *p_ncl_params,
 U8   ncl_count,
 phy_cell_id_info_t phy_cell_id_info,
 rrmcm_rmif_cell_x2_status_et *p_x2_link_up, /*OUT :  If the target has an X2 link up */
         /*SPR 17777 +-*/
 rrm_bool_et intra_freq_cell_present
 )
{

    RRM_UT_TRACE_ENTER();

    /* Now check if this X2-nbr cell is allowed */
    if(RRM_TRUE == intra_freq_cell_present ) 
        /*SPR 15180 Fix Stop*/
    {    
	/* SPR 21571 Fix Start */      
	switch(p_ncl_params->intra_freq_cells[ncl_count].x2_status)
	{
		case X2_PROHIBITED_CONNECTED:
        	{
            		RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
					"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO but can be used for direct data forwarding in S1HO as X2 link status[%d]",
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
            		*p_x2_link_up = X2_PROHIBITED_CONNECTED;
            		RRM_UT_TRACE_EXIT();
            		return RRM_TRUE;
        	}
		case X2_PROHIBITED_DISCONNECTED:
        	{
            		RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
					"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO as X2 link status %d",
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
            		*p_x2_link_up = X2_PROHIBITED_DISCONNECTED;
            		RRM_UT_TRACE_EXIT();
            		return RRM_FALSE;
		}
		case X2_ALLOWED_DISCONNECTED:
		{
			RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
					"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO as X2 link status %d",
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
			*p_x2_link_up = X2_ALLOWED_DISCONNECTED;
			RRM_UT_TRACE_EXIT();
			return RRM_FALSE;
		}
		case X2_ALLOWED:
		{
			if(RRM_FAILURE == is_x2_link_exist(phy_cell_id_info))
			{
				RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
						"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO as X2 link status %d",
						phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
				*p_x2_link_up = X2_PROHIBITED;
				RRM_UT_TRACE_EXIT();
				return RRM_FALSE;
			}
			else
			{
				*p_x2_link_up= X2_ALLOWED;
				RRM_UT_TRACE_EXIT();
				return RRM_TRUE;
			}           
		}
		case X2_PROHIBITED:
		{
			if(RRM_FAILURE == is_x2_link_exist(phy_cell_id_info))
			{
				RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"Physical cell id [%d] Earfcn [%d] is not allowed for X2 HO",
						phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
				*p_x2_link_up = X2_PROHIBITED;
				RRM_UT_TRACE_EXIT();
				return RRM_FALSE;
			}
			else
			{
				RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
						"Physical cell id [%d] Earfcn [%d] is not allowed for X2 HO but can be used for direct data forwarding in S1 HO",
						phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
				*p_x2_link_up = X2_ALLOWED;
				RRM_UT_TRACE_EXIT();
				return RRM_TRUE;
			}           
		}
		case X2_LOCALLY_CONNECTED_CELL:
		{
			*p_x2_link_up= X2_LOCALLY_CONNECTED_CELL;
			RRM_UT_TRACE_EXIT();
			return RRM_TRUE;
		}
		default:
		{
			*p_x2_link_up= X2_ALLOWED_CONNECTED;
			RRM_UT_TRACE_EXIT();
			return RRM_TRUE;
		}
	}
    }
    else 
    {    
	switch(p_ncl_params->inter_freq_cells[ncl_count].x2_status)
	{
		case X2_PROHIBITED_CONNECTED:
        	{
            		RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
					"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO but can be used for direct data forwarding in S1HO as X2 link status[%d]",
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
            		*p_x2_link_up = X2_PROHIBITED_CONNECTED;
            		RRM_UT_TRACE_EXIT();
            		return RRM_TRUE;
        	}
		case X2_PROHIBITED_DISCONNECTED:
        	{
            		RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
					"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO as X2 link status %d",
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
            		*p_x2_link_up = X2_PROHIBITED_DISCONNECTED;
            		RRM_UT_TRACE_EXIT();
            		return RRM_FALSE;
		}
		case X2_ALLOWED_DISCONNECTED:
		{
			RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
					"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO as X2 link status %d",
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
			*p_x2_link_up = X2_ALLOWED_DISCONNECTED;
			RRM_UT_TRACE_EXIT();
			return RRM_FALSE;
		}
		case X2_ALLOWED:
		{
			if(RRM_FAILURE == is_x2_link_exist(phy_cell_id_info))
			{
				RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
						"Physical cell id [%d] Earfcn [%d] is not allowed for X2HO as X2 link status %d",
						phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn, p_ncl_params->intra_freq_cells[ncl_count].x2_status);
				*p_x2_link_up = X2_PROHIBITED;
				RRM_UT_TRACE_EXIT();
				return RRM_FALSE;
			}
			else
			{
				*p_x2_link_up= X2_ALLOWED;
				RRM_UT_TRACE_EXIT();
				return RRM_TRUE;
			}           
		}
		case X2_PROHIBITED:
		{
			if(RRM_FAILURE == is_x2_link_exist(phy_cell_id_info))
			{
				RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"Physical cell id [%d] Earfcn [%d] is not allowed for X2 HO",
						phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
				*p_x2_link_up = X2_PROHIBITED;
				RRM_UT_TRACE_EXIT();
				return RRM_FALSE;
			}
			else
			{
				RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
						"Physical cell id [%d] Earfcn [%d] is not allowed for X2 HO but can be used for direct data forwarding in S1 HO",
						phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
				*p_x2_link_up = X2_ALLOWED;
				RRM_UT_TRACE_EXIT();
				return RRM_TRUE;
			}           
		}
		case X2_LOCALLY_CONNECTED_CELL:
		{
			*p_x2_link_up= X2_LOCALLY_CONNECTED_CELL;
			RRM_UT_TRACE_EXIT();
			return RRM_TRUE;
		}
		default:
		{
			*p_x2_link_up= X2_ALLOWED_CONNECTED;
			RRM_UT_TRACE_EXIT();
			return RRM_TRUE;
		}
	}
	/* SPR 21571 Fix End */      
    }
    /* Loss-less data transfer changes end */

}
/* SPR 15674 End */
/* Start :SPR 9309 */
/* SPR 15674 Start */
/******************************************************************************
 *   FUNCTION NAME: is_x2_link_up_for_phy_cell
 *   INPUT      : phy_cell_id,cell_index
 *   OUTPUT     :
 *   DESCRIPTION:
 *       Checks weather X2 link up received from SON for phy_cell_id or not
 *
 *   RETURNS:
 *       RRM_SUCCESS  on X2 link is up
 *       RRM_FAILURE  on X2 link is not up
 ******************************************************************************/
rrm_return_et 
is_x2_link_up_for_phy_cell 
(
 phy_cell_id_info_t phy_cell_id_info,
	rrm_cell_index_t  cell_index
)
{
    rrm_return_et      ret_val = RRM_FAILURE;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;
    lte_ncl_t          *p_ncl_params = RRM_PNULL;
    U8                 ncl_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_cell_context = rrm_cellm_get_cell_context(cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found");
        return ret_val;
    }
    /* Now check if this X2-nbr cell is allowed */
    p_ncl_params = rrm_cellm_get_ncl_params(cell_index);
    if(p_ncl_params == RRM_PNULL)
    {
        RRM_TRACE(g_uem_log_on_off,	p_rrm_uem_facility_name, RRM_WARNING,
                "LTE NCL is not configured");
        return ret_val;
    }
    for(ncl_count=RRM_ZERO; ncl_count < p_ncl_params->num_valid_intra_freq_cell; ncl_count++)
    {
        if((phy_cell_id_info.phy_cell_id == p_ncl_params->intra_freq_cells[ncl_count].phy_cell_id)
                && (phy_cell_id_info.carr_earfcn == p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn))
        {
            if((X2_ALLOWED_CONNECTED == p_ncl_params->intra_freq_cells[ncl_count].x2_status ) ||
                    (X2_PROHIBITED_CONNECTED ==p_ncl_params->intra_freq_cells[ncl_count].x2_status))
            {
                RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "X2 link[%d] is up for Intra Physical cell id [%d] Earfcn [%d]",
                        p_ncl_params->intra_freq_cells[ncl_count].x2_status,
                        phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
                ret_val =  RRM_SUCCESS;
            }
            else
            {
                RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "X2 Link [%d] is not up for Intra Physical cell id [%d], Earfcn[%d] ",
                        p_ncl_params->intra_freq_cells[ncl_count].x2_status,
                        phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
            }
            break;
        }
    }
    if (ret_val == RRM_FAILURE)
    {
        for(ncl_count=RRM_ZERO; ncl_count < p_ncl_params->num_valid_inter_freq_cell; ncl_count++)
        {
            if((phy_cell_id_info.phy_cell_id == p_ncl_params->inter_freq_cells[ncl_count].phy_cell_id)
                    && (phy_cell_id_info.carr_earfcn == p_ncl_params->inter_freq_cells[ncl_count].eutra_carrier_arfcn))
            {
                if((X2_ALLOWED_CONNECTED == p_ncl_params->inter_freq_cells[ncl_count].x2_status ) ||
                        (X2_PROHIBITED_CONNECTED ==p_ncl_params->inter_freq_cells[ncl_count].x2_status))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "X2 link [%d] is up for Inter Physical cell id [%d], Earfcn[%d]",
                            p_ncl_params->inter_freq_cells[ncl_count].x2_status,
                            phy_cell_id_info.phy_cell_id,
                            phy_cell_id_info.carr_earfcn);
                    ret_val =  RRM_SUCCESS;
                }
                else 
                {
                    RRM_TRACE(  g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "X2 link[%d] is not up for Inter Physical cell id [%d], Earfcn[%d] ",
                            p_ncl_params->inter_freq_cells[ncl_count].x2_status,
                            phy_cell_id_info.phy_cell_id,
                            phy_cell_id_info.carr_earfcn);
                }
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 15674 End */
/* End :SPR 9309 */
/* CDMA2000 changes start */

/******************************************************************************
 *   FUNCTION NAME: fill_mobility_params_cdma2000
 *   INPUT      : p_ue_context,p_mobility_parameters,p_add_mobility_parameters
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the ho required message
 *
 *   RETURNS: none
 ******************************************************************************/
rrm_void_t 
fill_mobility_params_cdma2000
(
  rrm_ue_context_t                *p_ue_context,
 mobility_parameters_t            *p_mobility_parameters,
 additional_mobility_parameters_t *p_add_mobility_parameters
 )
{
    RRM_UT_TRACE_ENTER();

    p_mobility_parameters->bitmask = RRM_ZERO;
    p_add_mobility_parameters->bitmask = RRM_ZERO;

    rrm_rrc_fill_mobility_sib_8_params(
            p_ue_context->cell_index,
         /*SPR 17777 +-*/
            p_mobility_parameters,
            p_add_mobility_parameters
            );

    rrm_rrc_fill_irat_ncl_cdma2000_params(
            p_ue_context->cell_index,
         /*SPR 17777 +-*/
            p_mobility_parameters,
            p_add_mobility_parameters);

    rrm_rrc_fill_ue_generic_cdma2000_params(
            p_ue_context->cell_index,
         /*SPR 17777 +-*/
            p_mobility_parameters,
            p_add_mobility_parameters);

    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_hrpd_cell_meas_ctx_cdma2000_cell_type
 *   INPUT      : p_rrm_ue_context,p_ue_measurment_results
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches HRPD PCI stored in cell ctx to corresponding PCI received for meas_id
 *
 ******************************************************************************/
void
rrm_ue_match_hrpd_cell_meas_ctx_cdma2000_cell_type
(
    
 rrm_ue_context_t  *p_rrm_ue_context,
         /*SPR 17777 +-*/
 /* SPR_11971_FIX_start */
 rrm_ue_cdma2000_ncl_info_list_t  **p_cdma2000_hrpd_ctx_info,
 /* SPR_11971_FIX_end */
 U8                               valid_meas_id_index,
 U8                               MEAS_ID_MATCHED
)
{
    U8 valid_pci_meas_index = RRM_ZERO;
    U8 max_cell_pilot_strength = RRM_ZERO;
    U8 valid_pci = RRM_ZERO;
    U8 best_pci_index = RRM_ZERO;
  
    RRM_UT_TRACE_ENTER();
        if(RRM_TRUE == MEAS_ID_MATCHED)
        {

            max_cell_pilot_strength = p_rrm_ue_context-> \
                                      meas_results_info[RRM_ONE]. \
                                      pilot_strength[RRM_ZERO];

            for(valid_pci = RRM_ONE;
                    valid_pci < p_rrm_ue_context-> \
                    meas_results_info[RRM_ONE].pci_count;
                    valid_pci++)
            {
                if( (p_rrm_ue_context->meas_results_info[RRM_ONE]. \
                            pilot_strength[valid_pci] ) >
                        max_cell_pilot_strength)
                {
                    max_cell_pilot_strength = p_rrm_ue_context->meas_results_info[RRM_ONE].\
                                              pilot_strength[valid_pci];
                    best_pci_index = valid_pci;
                }
            }

            for(valid_pci_meas_index = RRM_ZERO;
                    valid_pci_meas_index < p_rrm_ue_context->p_meas_obj_cdma2000_info->
                    meas_obj_cdma2000_cell_info_hrpd[valid_meas_id_index]. \
                    ncl_count;
                    valid_pci_meas_index++)
            {
                if(p_rrm_ue_context->meas_results_info[RRM_ONE].pci[best_pci_index] ==
                        p_rrm_ue_context->p_meas_obj_cdma2000_info-> \
                        meas_obj_cdma2000_cell_info_hrpd[valid_meas_id_index]. \
                        cdma2000_ncl_info_list[valid_pci_meas_index].pn_offset)
                {
                    /* SPR_11971_FIX_start */
                    *p_cdma2000_hrpd_ctx_info = &(p_rrm_ue_context->p_meas_obj_cdma2000_info->
                            meas_obj_cdma2000_cell_info_hrpd[valid_meas_id_index]. \
                            cdma2000_ncl_info_list[valid_pci_meas_index]);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "cdma2000 hrpd ctx found");
                    /* SPR_11971_FIX_end */
                    break;
                }
            }
        }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_hrpd_cell_meas_ctx_ue_measurment_results
 *   INPUT      : p_rrm_ue_context,p_ue_measurment_results
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches HRPD PCI stored in cell ctx to corresponding PCI received for meas_id
 *
 ******************************************************************************/
void
rrm_ue_match_hrpd_cell_meas_ctx_ue_measurment_results
(
 rrm_ue_context_t  *p_rrm_ue_context,
 rrm_ue_measurment_results_ind_t  *p_ue_measurment_results,
 /* SPR_11971_FIX_start */
 rrm_ue_cdma2000_ncl_info_list_t  **p_cdma2000_hrpd_ctx_info,
 /* SPR_11971_FIX_start */
 U8                               valid_meas_id_index,
 U8                               MEAS_ID_MATCHED
)
{
    U8 valid_pci_results_index = RRM_ZERO;
    U8 valid_pci_meas_index = RRM_ZERO;

     RRM_UT_TRACE_ENTER();
        if(RRM_TRUE == MEAS_ID_MATCHED)
        {
            for(valid_pci_results_index = RRM_ZERO;
                    valid_pci_results_index < p_ue_measurment_results-> \
                    cdma2000_meas_results. \
                    meas_result_list_cdma2000.
                    cdma2000_count;
                    valid_pci_results_index++)
            {
                for(valid_pci_meas_index = RRM_ZERO;
                        valid_pci_meas_index < p_rrm_ue_context->p_meas_obj_cdma2000_info->
                        meas_obj_cdma2000_cell_info_hrpd[valid_meas_id_index].ncl_count;
                        valid_pci_meas_index++)
                {
                    if(p_ue_measurment_results->cdma2000_meas_results. \
                            meas_result_list_cdma2000. \
                            meas_result_cdma2000[valid_pci_results_index].
                            phy_cell_id == 
                            p_rrm_ue_context->p_meas_obj_cdma2000_info-> \
                            meas_obj_cdma2000_cell_info_hrpd[valid_meas_id_index].
                            cdma2000_ncl_info_list[valid_pci_meas_index].pn_offset)
                    {
                        /* SPR_11971_FIX_start */
                        *p_cdma2000_hrpd_ctx_info = 
                            &(p_rrm_ue_context->p_meas_obj_cdma2000_info->
                                    meas_obj_cdma2000_cell_info_hrpd[valid_meas_id_index]. \
                                    cdma2000_ncl_info_list[valid_pci_meas_index]);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                            "cdma2000 hrpd ctx found");
                        /* SPR_11971_FIX_start */
                        break;
                    }
                }
                /*Cov_fix_start_65027_65026*/
                if(*p_cdma2000_hrpd_ctx_info)
                {
                    break;
                }
               /*Cov_fix_end_65027_65026*/ 
            }
        }
        RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_hrpd_cell_meas_ctx
 *   INPUT      : p_rrm_ue_context,p_ue_measurment_results
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches HRPD PCI stored in cell ctx to corresponding PCI received for meas_id
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_ue_cdma2000_ncl_info_list_t *
rrm_ue_match_hrpd_cell_meas_ctx
(
 rrm_ue_context_t  *p_rrm_ue_context,
 rrm_ue_measurment_results_ind_t  *p_ue_measurment_results
 )
{
    U8 valid_meas_id_index = RRM_ZERO;
    U8 meas_id_index = RRM_ZERO;
    U8 MEAS_ID_MATCHED = RRM_FALSE;
    rrm_ue_cdma2000_ncl_info_list_t    *p_cdma2000_hrpd_ctx_info = RRM_PNULL;
 
    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
            "CDMA 2000 Cell Type: [%d]",
            p_rrm_ue_context->meas_results_info[RRM_ONE].cdma2000_cell_type);

    if(RRM_TRUE ==p_rrm_ue_context->meas_results_info[RRM_ONE].cdma2000_cell_type)
    {
        for (meas_id_index = RRM_ZERO;
                meas_id_index < p_rrm_ue_context-> \
                p_meas_obj_cdma2000_info-> \
                count_meas_object_hrpd;
                meas_id_index++)
        {
            if(p_rrm_ue_context->meas_results_info[RRM_ONE].meas_id == 
                    p_rrm_ue_context->p_meas_obj_cdma2000_info->
                    meas_obj_cdma2000_cell_info_hrpd[meas_id_index]. \
                    meas_id)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        " meas_id [%d] matched , meas_id_index: [%d]",
                        p_rrm_ue_context->meas_results_info[RRM_ONE].meas_id,
                        meas_id_index);
                valid_meas_id_index = meas_id_index;
                MEAS_ID_MATCHED = RRM_TRUE;
                break;
            }
        }
        /*Klocwork activity 1-Apr_2014 start*/
        rrm_ue_match_hrpd_cell_meas_ctx_cdma2000_cell_type
            (
             p_rrm_ue_context,
         /*SPR 17777 +-*/
             /* SPR_11971_FIX_start */
             &p_cdma2000_hrpd_ctx_info,
             /* SPR_11971_FIX_end */
             valid_meas_id_index,
             MEAS_ID_MATCHED
            );
        /*Klocwork activity 1-Apr_2014 end*/
    }
    else if((RRM_PNULL != p_ue_measurment_results))
    {
        for (meas_id_index = RRM_ZERO;
                meas_id_index < p_rrm_ue_context-> \
                p_meas_obj_cdma2000_info-> \
                count_meas_object_hrpd;
                meas_id_index++)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "CDMA 2000 meas_id [%d]",
                    p_rrm_ue_context->p_meas_obj_cdma2000_info->
                    meas_obj_cdma2000_cell_info_hrpd[meas_id_index].meas_id);
            if(p_ue_measurment_results->meas_id == 
                    p_rrm_ue_context->p_meas_obj_cdma2000_info->
                    meas_obj_cdma2000_cell_info_hrpd[meas_id_index]. \
                    meas_id)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        " meas_id [%d] matched , meas_id_index: [%d]",
                        p_ue_measurment_results->meas_id,
                        meas_id_index);
                valid_meas_id_index = meas_id_index;
                MEAS_ID_MATCHED = RRM_TRUE;
                break;
            }
        }
        /*Klocwork activity 1-Apr_2014 start*/
        rrm_ue_match_hrpd_cell_meas_ctx_ue_measurment_results
            (
             p_rrm_ue_context,
             p_ue_measurment_results,
             /* SPR_11971_FIX_start */
             &p_cdma2000_hrpd_ctx_info,
             /* SPR_11971_FIX_end */
             valid_meas_id_index,
             MEAS_ID_MATCHED
            );
        /*Klocwork activity 1-Apr_2014 end*/
    }

    RRM_UT_TRACE_EXIT();

    return p_cdma2000_hrpd_ctx_info;
}
/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_1xrtt_cell_meas_ctx_cdma2000_cell_type
 *   INPUT      : p_rrm_ue_context,p_ue_measurment_results
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches 1XRTT PCI stored in cell ctx to corresponding PCI received for meas_id
 *
 ******************************************************************************/
void
rrm_ue_match_1xrtt_cell_meas_ctx_cdma2000_cell_type
(
 rrm_ue_context_t  *p_rrm_ue_context,
         /*SPR 17777 +-*/
 /* SPR_11971_FIX_start */
 rrm_ue_cdma2000_ncl_info_list_t  **p_cdma2000_1xrtt_ctx_info,
 /* SPR_11971_FIX_end */
 U8                               valid_meas_id_index,
 U8                               MEAS_ID_MATCHED
 
)
{   
 
    U8 valid_pci_meas_index = RRM_ZERO;
    U8 valid_pci = RRM_ZERO;
    U8 max_cell_pilot_strength = RRM_ZERO;
    U8 best_meas_result_pci_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

        if(RRM_TRUE == MEAS_ID_MATCHED)
        {
            max_cell_pilot_strength = p_rrm_ue_context-> \
                                      meas_results_info[RRM_ZERO]. \
                                      pilot_strength[RRM_ZERO];

            for(valid_pci = RRM_ONE;
                    valid_pci < p_rrm_ue_context-> \
                    meas_results_info[RRM_ZERO].pci_count;
                    valid_pci++)
            {
                if( (p_rrm_ue_context->meas_results_info[RRM_ZERO]. \
                            pilot_strength[valid_pci] ) >
                        max_cell_pilot_strength)
                {
                    max_cell_pilot_strength = p_rrm_ue_context->meas_results_info[RRM_ZERO].\
                                              pilot_strength[valid_pci];
                    best_meas_result_pci_index = valid_pci;
                }
            }

            for(valid_pci_meas_index = RRM_ZERO;
                    valid_pci_meas_index < p_rrm_ue_context->p_meas_obj_cdma2000_info->
                    meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index].ncl_count;
                    valid_pci_meas_index++)
            {
                if(p_rrm_ue_context->meas_results_info[RRM_ZERO].pci[best_meas_result_pci_index] ==
                        p_rrm_ue_context->p_meas_obj_cdma2000_info-> \
                        meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index].
                        cdma2000_ncl_info_list[valid_pci_meas_index].pn_offset)
                {
                    /* SPR_11971_FIX_start */
                    *p_cdma2000_1xrtt_ctx_info = &(p_rrm_ue_context->p_meas_obj_cdma2000_info->
                            meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index]. \
                            cdma2000_ncl_info_list[valid_pci_meas_index]);
                     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                            "cdma2000_1xrtt ctx found : pn_offset[%d], best_meas_result_pci_index = %d"
                            "valid_meas_id_index = %d",
                             p_rrm_ue_context->p_meas_obj_cdma2000_info->meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index].
                             cdma2000_ncl_info_list[valid_pci_meas_index].pn_offset, best_meas_result_pci_index,
                             valid_meas_id_index);
                    /* SPR_11971_FIX_end */
                    break;
                }
            }
        }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_1xrtt_cell_meas_ctx_ue_measurment_results
 *   INPUT      : p_rrm_ue_context,p_ue_measurment_results
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches 1XRTT PCI stored in cell ctx to corresponding PCI received for meas_id
 *
 ******************************************************************************/
void
rrm_ue_match_1xrtt_cell_meas_ctx_ue_measurment_results
(
 rrm_ue_context_t  *p_rrm_ue_context,
 rrm_ue_measurment_results_ind_t  *p_ue_measurment_results,
 /* SPR_11971_FIX_start */
  rrm_ue_cdma2000_ncl_info_list_t  **p_cdma2000_1xrtt_ctx_info,
 /* SPR_11971_FIX_end */
 U8                               valid_meas_id_index,
 U8                               MEAS_ID_MATCHED 
)
{

    U8 valid_pci_meas_index = RRM_ZERO;
    U8 valid_pci_results_index = RRM_ZERO;
    
    RRM_UT_TRACE_ENTER();
        if(RRM_TRUE == MEAS_ID_MATCHED)
        {
            for(valid_pci_results_index = RRM_ZERO;
                    valid_pci_results_index < p_ue_measurment_results->cdma2000_meas_results.
                    meas_result_list_cdma2000.cdma2000_count;
                    valid_pci_results_index++)
            {
                for(valid_pci_meas_index = RRM_ZERO;
                        valid_pci_meas_index < p_rrm_ue_context->p_meas_obj_cdma2000_info->
                        meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index].ncl_count;
                        valid_pci_meas_index++)
                {
                    if(p_ue_measurment_results->cdma2000_meas_results.meas_result_list_cdma2000.
                            meas_result_cdma2000[valid_pci_results_index].
                            phy_cell_id == p_rrm_ue_context->p_meas_obj_cdma2000_info-> \
                            meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index].
                            cdma2000_ncl_info_list[valid_pci_meas_index].pn_offset)
                    {
                        /* SPR_11971_FIX_start */
                        *p_cdma2000_1xrtt_ctx_info = &(p_rrm_ue_context->p_meas_obj_cdma2000_info->
                                meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id_index]. \
                                cdma2000_ncl_info_list[valid_pci_meas_index]);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                "cdma2000_1xrtt ctx found : pci[%d], valid_pci_results_index = %d",
                                p_ue_measurment_results->cdma2000_meas_results.meas_result_list_cdma2000.
                                meas_result_cdma2000[valid_pci_results_index].phy_cell_id, valid_pci_results_index);
                        /* SPR_11971_FIX_end */
                        break;
                    }
                }
                /*Cov_fix_start_65027_65026*/
                if(*p_cdma2000_1xrtt_ctx_info)
                {
                    break;
                }
                /*Cov_fix_end_65027_65026*/
            }
        }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_1xrtt_cell_meas_ctx
 *   INPUT      : p_rrm_ue_context,p_ue_measurment_results
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches 1XRTT PCI stored in cell ctx to corresponding PCI received for meas_id
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_ue_cdma2000_ncl_info_list_t *
rrm_ue_match_1xrtt_cell_meas_ctx
(
 rrm_ue_context_t  *p_rrm_ue_context,
 rrm_ue_measurment_results_ind_t  *p_ue_measurment_results
 )
{
    U8 valid_meas_id_index = RRM_ZERO;
    U8 meas_id_index = RRM_ZERO;
    U8 MEAS_ID_MATCHED = RRM_FALSE;
    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_1xrtt_ctx_info = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
            "CDMA 2000 Cell Type: [%d]",
            p_rrm_ue_context->meas_results_info[RRM_ZERO].cdma2000_cell_type);

    /*SPR 21978 Start*/
    if(RRM_NULL != p_rrm_ue_context->p_meas_obj_cdma2000_info)
    {   
    /*SPR 21978 End*/

        if(RRM_TRUE == p_rrm_ue_context->meas_results_info[RRM_ZERO].cdma2000_cell_type)
        {
            for (meas_id_index = RRM_ZERO;
                    meas_id_index < p_rrm_ue_context-> \
                    p_meas_obj_cdma2000_info-> \
                    count_meas_object_1xrtt;
                    meas_id_index++)
            {
                if(p_rrm_ue_context->meas_results_info[RRM_ZERO].meas_id == 
                        p_rrm_ue_context->p_meas_obj_cdma2000_info->
                        meas_obj_cdma2000_cell_info_1xrtt[meas_id_index]. \
                        meas_id)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                            "meas_id [%d] matched , meas_id_index: [%d]",
                            p_rrm_ue_context->meas_results_info[RRM_ZERO].meas_id,
                            meas_id_index);
                    valid_meas_id_index = meas_id_index;
                    MEAS_ID_MATCHED = RRM_TRUE;
                    break;
                }
            }
            /*Klocwork activity 1-Apr_2014 start*/
            rrm_ue_match_1xrtt_cell_meas_ctx_cdma2000_cell_type
                (
                 p_rrm_ue_context,
                 /*SPR 17777 +-*/
                 /* SPR_11971_FIX_start */
                 &p_cdma2000_1xrtt_ctx_info,
                 /* SPR_11971_FIX_end */
                 valid_meas_id_index,
                 MEAS_ID_MATCHED
                );
            /*Klocwork activity 1-Apr_2014 end*/
        }
        else if((RRM_PNULL != p_ue_measurment_results))
        {
            for (meas_id_index = RRM_ZERO;
                    meas_id_index < p_rrm_ue_context-> \
                    p_meas_obj_cdma2000_info-> \
                    count_meas_object_1xrtt;
                    meas_id_index++)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "CDMA 2000 meas_id [%d]",
                        p_rrm_ue_context->p_meas_obj_cdma2000_info->
                        meas_obj_cdma2000_cell_info_1xrtt[meas_id_index].meas_id);
                if(p_ue_measurment_results->meas_id == 
                        p_rrm_ue_context->p_meas_obj_cdma2000_info->
                        meas_obj_cdma2000_cell_info_1xrtt[meas_id_index]. \
                        meas_id)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                            "meas_id [%d] matched , meas_id_index: [%d]",
                            p_ue_measurment_results->meas_id,
                            meas_id_index);
                    valid_meas_id_index = meas_id_index;
                    MEAS_ID_MATCHED = RRM_TRUE;
                    break;
                }
            }
            /*Klocwork activity 1-Apr_2014 start*/
            rrm_ue_match_1xrtt_cell_meas_ctx_ue_measurment_results
                (
                 p_rrm_ue_context,
                 p_ue_measurment_results,
                 /* SPR_11971_FIX_start */
                 &p_cdma2000_1xrtt_ctx_info,
                 /* SPR_11971_FIX_end */
                 valid_meas_id_index,
                 MEAS_ID_MATCHED 
                );
            /*Klocwork activity 1-Apr_2014 end*/
        }
        /*SPR 21978 Start*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                "meas Object not created for CDMA2000 ");

    }
/*SPR 21978 End*/
RRM_UT_TRACE_EXIT();
    RRM_UT_TRACE_EXIT();

    return p_cdma2000_1xrtt_ctx_info;
}

/******************************************************************************
 *   FUNCTION NAME: fill_ho_required_cdma2000_1xrtt_info
 *   INPUT      : p_ue_context,p_cdma2000_1xrtt_ctx_info
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *   RETURNS:
 *       None
 ******************************************************************************/
rrm_void_t
fill_ho_required_cdma2000_1xrtt_info
(
rrm_ue_context_t  *p_ue_context,
rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_1xrtt_ctx_info,
rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required
)
{
    RRM_UT_TRACE_ENTER();
    
    RRM_MEMCPY(&(p_rrc_rrm_ho_required->target_id.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
               &(p_cdma2000_1xrtt_ctx_info->CID),
               RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);

    p_rrc_rrm_ho_required->target_id.bitmask |= 
               RRM_TARGET_ID_CDMA2000_1XRTT_CELL_ID_PRESENT;

    /* Saving Band_class, ARFCN, CID in UE Context to be filled in HO_CMD_RESP */
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.arfcn =
      p_cdma2000_1xrtt_ctx_info->arfcn;
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.band_class =
      p_cdma2000_1xrtt_ctx_info->band_class;

    RRM_MEMCPY(&(p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.CID),
               &(p_rrc_rrm_ho_required->target_id.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
               RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
          ho_required_sent_status = RRM_TRUE;

    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
          ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL;

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_ho_required_cdma2000_hrpd_info
 *   INPUT      : p_rrm_ue_context,p_cdma2000_hrpd_ctx_info
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *   RETURNS:
 *       None
 ******************************************************************************/
rrm_void_t
fill_ho_required_cdma2000_hrpd_info
(
 rrm_ue_context_t  *p_rrm_ue_context,
 rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_hrpd_ctx_info,
 rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required)
{
    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(&(p_rrc_rrm_ho_required->target_id.sector_id_hrpd.sector_id),
            &(p_cdma2000_hrpd_ctx_info->CID),
            RRM_CDMA2000_HRPD_CELL_ID_LENGTH);

    p_rrc_rrm_ho_required->target_id.sector_id_hrpd.sector_id_length = 
            RRM_CDMA2000_HRPD_CELL_ID_LENGTH;

    p_rrc_rrm_ho_required->target_id.bitmask |=
            RRM_TARGET_ID_CDMA2000_HRPD_SECTOR_ID_PRESENT;

    /* Saving Band_class, ARFCN, CID in UE Context to be filled in HO_CMD_RESP */
    p_rrm_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.arfcn =
      p_cdma2000_hrpd_ctx_info->arfcn;
    p_rrm_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.band_class =
      p_cdma2000_hrpd_ctx_info->band_class;

    RRM_MEMCPY(&(p_rrm_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.CID),
               &(p_rrc_rrm_ho_required->target_id.sector_id_hrpd.sector_id),
               RRM_CDMA2000_HRPD_CELL_ID_LENGTH);

    p_rrm_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.
        ho_required_sent_status = RRM_TRUE;

    p_rrm_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.
          ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL;

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_ho_required_daho_cdma2000_hrpd_info
 *   INPUT      : p_ue_context,p_cdma2000_daho_hrpd_cell
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *   RETURNS:
 *       None
 ******************************************************************************/
rrm_void_t
fill_ho_required_daho_cdma2000_hrpd_info
(
rrm_ue_context_t       *p_ue_context,
rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell,
rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required
)
{
    RRM_UT_TRACE_ENTER();
    RRM_MEMCPY(&(p_rrc_rrm_ho_required->target_id.sector_id_hrpd.sector_id),
            &(p_cdma2000_daho_hrpd_cell->CID),
            RRM_CDMA2000_HRPD_CELL_ID_LENGTH);
    
    p_rrc_rrm_ho_required->target_id.sector_id_hrpd.sector_id_length =
        RRM_CDMA2000_HRPD_CELL_ID_LENGTH;

    p_rrc_rrm_ho_required->target_id.bitmask |=
        RRM_TARGET_ID_CDMA2000_HRPD_SECTOR_ID_PRESENT;

    /* Saving Band_class, ARFCN, CID in UE Context to be filled in HO_CMD_RESP */
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.arfcn =
      p_cdma2000_daho_hrpd_cell->arfcn;
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.band_class =
      p_cdma2000_daho_hrpd_cell->band_class;

    RRM_MEMCPY(&(p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.CID),
               &(p_rrc_rrm_ho_required->target_id.sector_id_hrpd.sector_id),
               RRM_CDMA2000_HRPD_CELL_ID_LENGTH);
    
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.
        ho_required_sent_status = RRM_TRUE;

    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.
        ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL;

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_ho_required_daho_cdma2000_1xrtt_info
 *   INPUT      : p_ue_context,p_cdma2000_daho_1xrtt_cell
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *   RETURNS:
 *       None
 ******************************************************************************/
rrm_void_t
fill_ho_required_daho_cdma2000_1xrtt_info
(
rrm_ue_context_t       *p_ue_context,
rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell,
rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required
)
{
    RRM_UT_TRACE_ENTER();
    
    RRM_MEMCPY(&(p_rrc_rrm_ho_required->target_id.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
            &(p_cdma2000_daho_1xrtt_cell->CID),
            RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);

    p_rrc_rrm_ho_required->target_id.bitmask |=
        RRM_TARGET_ID_CDMA2000_1XRTT_CELL_ID_PRESENT;

    /* Saving Band_class, ARFCN, CID in UE Context to be filled in HO_CMD_RESP */
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.arfcn =
      p_cdma2000_daho_1xrtt_cell->arfcn;
    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.band_class =
      p_cdma2000_daho_1xrtt_cell->band_class;

    RRM_MEMCPY(&(p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.CID),
               &(p_rrc_rrm_ho_required->target_id.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
               RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);

    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
        ho_required_sent_status = RRM_TRUE;

    p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
        ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL;

    RRM_UT_TRACE_EXIT();
}

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_required_for_cdma2000_hrpd_1xrtt_ctx
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_ho_required_for_cdma2000_hrpd_1xrtt_ctx
(
 rrc_rrm_ho_required_t                        *p_rrc_rrm_ho_required,
 rrm_ue_context_t                             *p_rrm_ue_context,
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params,
 rrm_ue_cdma2000_ncl_info_list_t              *p_cdma2000_hrpd_ctx_info,
 rrm_ue_cdma2000_ncl_info_list_t              *p_cdma2000_1xrtt_ctx_info,
 U16                                          trans_id
 )
{
    RRM_UT_TRACE_ENTER();

        /* Check for Con. PS HO */
        if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
           (p_irat_cdma_params->inter_rat_parameters_cdma2000_v920.
            bitmask & RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG))
        {
           if((p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT) && (p_rrm_ue_context->
                 ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                  inter_rat_parameters_cdma2000_v920.bitmask &
                 RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT))
           {
               /* Concurr */
               p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
               /*KPI:start*/
               p_rrm_ue_context->ho_typ= RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
               /*KPI:end*/
               /* Fill Info for HRPD/1XRTT */
               fill_ho_required_cdma2000_1xrtt_info(p_rrm_ue_context, 
                       p_cdma2000_1xrtt_ctx_info, 
                       p_rrc_rrm_ho_required);

               fill_ho_required_cdma2000_hrpd_info(p_rrm_ue_context,
                       p_cdma2000_hrpd_ctx_info,
                       p_rrc_rrm_ho_required);
           }
           else if(p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                       ue_eutra_capability_v920_ies.bitmask &
                       RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT)
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "Only eCSFB Applicable.");
               p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
               /*KPI:start*/
               p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
               /*KPI:end*/
               fill_ho_required_cdma2000_1xrtt_info(p_rrm_ue_context, 
                       p_cdma2000_1xrtt_ctx_info, 
                       p_rrc_rrm_ho_required);
           }
           else
           {
               /* Release with redirection to both CSFB RWR*/
               /* Bug 16121 Fix Start */
                if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                            p_rrm_ue_context->ue_index,
                            RADIO_NETWORK_LAYER_TYPE,
                            /* SPR-10489-fix start */
                            REDIRECTION_TOWARDS_1XRTT,
                            /* SPR-10489-fix end */
                            trans_id,
                            p_rrm_ue_context,
                            /* SPR_10729_fix */
                            p_rrm_ue_context->cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to send release connection ind for [UE:%d]",
                            p_rrm_ue_context->ue_index);
                }
                RRM_UT_TRACE_EXIT();
                /* Bug 16121 Fix End */
               return RRM_FAILURE;
           }
        }
        else if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                    (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
        {
               /* fill ho required for 1xRTT */
               /* HO CMD RESP, redirection to HRPD */
               p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
               /*KPI:start*/
               p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
               /*KPI:end*/
               fill_ho_required_cdma2000_1xrtt_info(p_rrm_ue_context, 
                       p_cdma2000_1xrtt_ctx_info, 
                       p_rrc_rrm_ho_required);
        }
        else
        {
            /* Release with redirection to both CSFB RWR*/
            /* Bug 16121 Fix Start */
            if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                        p_rrm_ue_context->ue_index,
                        RADIO_NETWORK_LAYER_TYPE,
                        /* SPR-10489-fix start */
                        REDIRECTION_TOWARDS_1XRTT,
                        /* SPR-10489-fix end */
                        trans_id,
                        p_rrm_ue_context,
                        /* SPR_10729_fix */
                        p_rrm_ue_context->cell_index))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_DETAILED,
                            "ue_connection_release_ind sent, \
                            Failed to clean up ue resources");
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send release connection ind for [UE:%d]",
                        p_rrm_ue_context->ue_index);
            }
            /* Bug 16121 Fix End */
            return RRM_FAILURE;
        }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*Klocwork activity 1-Apr_2014 end*/
/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_required_for_cdma2000_hrpd_1xrtt_daho
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_ho_required_for_cdma2000_hrpd_1xrtt_daho
(
 rrc_rrm_ho_required_t                        *p_rrc_rrm_ho_required,
 rrm_ue_context_t                             *p_rrm_ue_context,
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params,
 rrm_ue_cdma2000_ncl_info_list_t              *p_cdma2000_1xrtt_ctx_info,
 U16                                           trans_id,
 inter_rat_ncl_t                              *p_inter_rat_ncl,
 rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell,
 rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell
 )
{
    RRM_UT_TRACE_ENTER();

        if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
        {
                p_cdma2000_daho_1xrtt_cell = rrm_ue_match_1xrtt_daho_cell_from_ncl
                                                 (p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);
                p_cdma2000_daho_hrpd_cell = rrm_ue_match_hrpd_daho_cell_from_ncl
                                             (p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);
            /* If conc is possible */
            if((p_irat_cdma_params->inter_rat_parameters_cdma2000_v920.
                     bitmask & RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG) && 
                     (p_rrm_ue_context-> ue_capability_params.rrm_eutra_radio_capability_info.
                             ue_eutra_capability_v920_ies.inter_rat_parameters_cdma2000_v920.bitmask &
                                RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT))
            {
                /* conc to DAHO */
                if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell && RRM_PNULL != p_cdma2000_daho_hrpd_cell)
                {
                    p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
                    /*KPI:start*/
                    p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
                    /*KPI:end*/
                    /* Fill DAHO Info for HRPD/1XRTT */
                    fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                            p_rrc_rrm_ho_required);

                    fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                            p_rrc_rrm_ho_required);
                }
                else if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell)
                {
                    /*DAHO to 1xrtt + HRPD Redirection*/
                    p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                    /*KPI:start*/
                    p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                    /*KPI:end*/

                    fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                            p_rrc_rrm_ho_required);
                }
                else if(p_rrm_ue_context->cdma2000_capabilities.is_ecsfb_present)
                {
                    /*eCSFB to 1xrtt*/
                    p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                    /*KPI:start*/
                    p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                    /*KPI:end*/
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Only eCSFB Applicable. 2");
                    fill_ho_required_cdma2000_1xrtt_info(p_rrm_ue_context, 
                            p_cdma2000_1xrtt_ctx_info, 
                            p_rrc_rrm_ho_required);
                }
                else
                {
                    /* RWR */
                    /* Bug 16121 Fix Start*/
                    if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                                p_rrm_ue_context->ue_index,
                                RADIO_NETWORK_LAYER_TYPE,
                                /* SPR-10489-fix start */
                                REDIRECTION_TOWARDS_1XRTT,
                                /* SPR-10489-fix end */
                                trans_id,
                                p_rrm_ue_context,
                                /* SPR_10729_fix */
                                p_rrm_ue_context->cell_index))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                        if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                        {
                            RRM_TRACE(g_uem_log_on_off,
                                    p_rrm_uem_facility_name,
                                    RRM_DETAILED,
                                    "ue_connection_release_ind sent, \
                                    Failed to clean up ue resources");
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to send release connection ind for [UE:%d]",
                                p_rrm_ue_context->ue_index);
                    }
                    /* Bug 16121 Fix End */
                    return RRM_FAILURE;
                }

            }
            else if(p_rrm_ue_context->cdma2000_capabilities.is_ecsfb_present)
            {
                /*eCSFB to 1xrtt*/
               p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
               /*KPI:start*/
               p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
               /*KPI:end*/
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "Only eCSFB Applicable. 2");
               fill_ho_required_cdma2000_1xrtt_info(p_rrm_ue_context, 
                       p_cdma2000_1xrtt_ctx_info, 
                       p_rrc_rrm_ho_required);
            }
       }
        else
        {
            /* Release with redirection to both CSFB RWR*/
            /* Bug 16121 Fix Start */
            if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                        p_rrm_ue_context->ue_index,
                        RADIO_NETWORK_LAYER_TYPE,
                        /* SPR-10489-fix start */
                        REDIRECTION_TOWARDS_1XRTT,
                        /* SPR-10489-fix end */
                        trans_id,
                        p_rrm_ue_context,
                        /* SPR_10729_fix */
                        p_rrm_ue_context->cell_index))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_DETAILED,
                            "ue_connection_release_ind sent, \
                            Failed to clean up ue resources");
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send release connection ind for [UE:%d]",
                        p_rrm_ue_context->ue_index);
            }
            /* Bug 16121 Fix End */
            return RRM_FAILURE;
        }
    RRM_UT_TRACE_EXIT();
return RRM_SUCCESS;
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_required_for_cdma2000_daho
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_ho_required_for_cdma2000_daho(rrm_ue_context_t       *p_rrm_ue_context ,
               rrmcm_idle_mode_mobility_irat_cdma_params_t       *p_irat_cdma_params ,
                                          inter_rat_ncl_t        *p_inter_rat_ncl ,
                                          rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required , 
                                          U16                    trans_id)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell  = RRM_PNULL;
   
    RRM_UT_TRACE_ENTER();
    p_cdma2000_daho_1xrtt_cell = (rrmcm_rmif_cdma2000_freq_cells_t *) \
                                 rrm_ue_match_1xrtt_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);
    p_cdma2000_daho_hrpd_cell = rrm_ue_match_hrpd_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    if(!(p_rrm_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))
    {
        if (RRM_PNULL != p_cdma2000_daho_hrpd_cell)
        {
            fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                    p_rrc_rrm_ho_required);
            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
            /*KPI:start*/
            p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
            /*KPI:end*/
        }
        else
        {
            /* Bug 16121 Fix Start */
                if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                            p_rrm_ue_context->ue_index,
                            RADIO_NETWORK_LAYER_TYPE,
                            CS_FALLBACK_TRIGGERED,
                            trans_id,
                            p_rrm_ue_context,
                            /* SPR_10729_fix */
                            p_rrm_ue_context->cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to send release connection ind for [UE:%d]",
                            p_rrm_ue_context->ue_index);
                }
                /* Bug 16121 Fix End */

            return RRM_FAILURE;
        }
    }
    else if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell && RRM_PNULL != p_cdma2000_daho_hrpd_cell)
    {
        /* Check for Con. PS HO */
        if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_irat_cdma_params->inter_rat_parameters_cdma2000_v920.
                 bitmask & RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG))
        {
            if((p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.bitmask &
                        RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT) && (p_rrm_ue_context->
                            ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                            inter_rat_parameters_cdma2000_v920.bitmask &
                            RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT))
            {
                /* Concurr */
                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
                /*KPI:start*/
                p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
                /*KPI:end*/

                /* Fill DAHO Info for HRPD/1XRTT */
                fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                        p_rrc_rrm_ho_required);

                fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                        p_rrc_rrm_ho_required);
            }
            else if(p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.bitmask &
                    RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT)
            {
                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                /*KPI:start*/
                p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                /*KPI:end*/

                fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                        p_rrc_rrm_ho_required);
            }
            else
            {
                /* Release with redirection to both CSFB RWR*/
                /* Bug 16121 Fix Start */
                    if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                                p_rrm_ue_context->ue_index,
                                RADIO_NETWORK_LAYER_TYPE,
                                /* SPR-10489-fix start */
                                REDIRECTION_TOWARDS_1XRTT,
                                /* SPR-10489-fix end */
                                trans_id,
                                p_rrm_ue_context,
                                /* SPR_10729_fix */
                                p_rrm_ue_context->cell_index))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                        if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                        {
                            RRM_TRACE(g_uem_log_on_off,
                                    p_rrm_uem_facility_name,
                                    RRM_DETAILED,
                                    "ue_connection_release_ind sent, \
                                    Failed to clean up ue resources");
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to send release connection ind for [UE:%d]",
                                p_rrm_ue_context->ue_index);
                    }
                    /* Bug 16121 Fix End */

                return RRM_FAILURE;
            }

        }
        else if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
        {
            /* Check for eCSFB */
            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:start*/
            p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:end*/
            fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                    p_rrc_rrm_ho_required);

        }
        else
        {
            /* RWR CSFB to both */
            /* Bug 16121 Fix Start */
                if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                            p_rrm_ue_context->ue_index,
                            RADIO_NETWORK_LAYER_TYPE,
                            CS_FALLBACK_TRIGGERED,
                            trans_id,
                            p_rrm_ue_context,
                            /* SPR_10729_fix */
                            p_rrm_ue_context->cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to send release connection ind for [UE:%d]",
                            p_rrm_ue_context->ue_index);
                }
                /* Bug 16121 Fix End */

            return RRM_FAILURE;
        }
    }
    else if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell && RRM_PNULL == p_cdma2000_daho_hrpd_cell)
    {
        if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
        {
            /* fill ho required for 1xRTT */
            /* HO CMD RESP, redirection to HRPD */
            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:start*/
            p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:end*/
            fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                    p_rrc_rrm_ho_required);
        }
        else
        {
            /* Release with redirection to both CSFB RWR*/
            /* Bug 16121 Fix Start */
                if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                            p_rrm_ue_context->ue_index,
                            RADIO_NETWORK_LAYER_TYPE,
                            /* SPR-10489-fix start */
                            REDIRECTION_TOWARDS_1XRTT,
                            /* SPR-10489-fix end */
                            trans_id,
                            p_rrm_ue_context,
                            /* SPR_10729_fix */
                            p_rrm_ue_context->cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to send release connection ind for [UE:%d]",
                            p_rrm_ue_context->ue_index);
                }
                /* Bug 16121 Fix End */
            return RRM_FAILURE;
        }
    }
    else if(RRM_PNULL == p_cdma2000_daho_1xrtt_cell && RRM_PNULL != p_cdma2000_daho_hrpd_cell)
    {
        /* HO to HRPD */
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:start*/
        p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:end*/
        fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                p_rrc_rrm_ho_required);
    }
    else if(RRM_PNULL == p_cdma2000_daho_1xrtt_cell && RRM_PNULL == p_cdma2000_daho_hrpd_cell)
    {
        /* RWR CSFB */
        /* Bug 16121 Fix Start */
            if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                        p_rrm_ue_context->ue_index,
                        RADIO_NETWORK_LAYER_TYPE,
                        /* SPR-10489-fix start */
                        REDIRECTION_TOWARDS_1XRTT,
                        /* SPR-10489-fix end */
                        trans_id,
                        p_rrm_ue_context,
                        /* SPR_10729_fix */
                        p_rrm_ue_context->cell_index))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "ue connection release ind sent for [UE:%d]",p_rrm_ue_context->ue_index);
                if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_DETAILED,
                            "ue_connection_release_ind sent, \
                            Failed to clean up ue resources");
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send release connection ind for [UE:%d]",
                        p_rrm_ue_context->ue_index);
            }
            /* Bug 16121 Fix End */

        return RRM_FAILURE;
    }
RRM_UT_TRACE_EXIT();
return ret_val ;
}
/*Klockwork_fix_end*/


/*Klocwork activity 1-Apr_2014 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_required_for_cdma2000
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_ho_required_for_cdma2000
(
 rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required,
 rrm_ue_context_t       *p_rrm_ue_context
 )
{
    U8 report_index = RRM_FALSE;
    U8 valid_report_index = RRM_ZERO;
    rrm_cell_context_t  *p_cell_context = RRM_PNULL;
    rrm_ue_measurment_results_ind_t *p_ue_measurment_results = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params = RRM_PNULL;
    inter_rat_ncl_t  *p_inter_rat_ncl = RRM_PNULL;
    U16  trans_id = RRM_ONE;
    rrm_return_et ret_val = RRM_SUCCESS;

    p_ue_measurment_results = (rrm_ue_measurment_results_ind_t *)
        p_rrm_ue_context->current_procedure.p_proc_data;

    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_hrpd_ctx_info = RRM_PNULL;
    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_1xrtt_ctx_info = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell = RRM_PNULL;

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);

    p_irat_cdma_params = &(p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_inter_rat_ncl = &(p_cell_context->ran_info.ncl_params.inter_rat_ncl);

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->target_id.bitmask = RRM_ZERO;

    p_rrc_rrm_ho_required->ue_index = p_rrm_ue_context->ue_index;

    p_cdma2000_hrpd_ctx_info = rrm_ue_match_hrpd_cell_meas_ctx(p_rrm_ue_context, p_ue_measurment_results);

    p_cdma2000_1xrtt_ctx_info = rrm_ue_match_1xrtt_cell_meas_ctx(p_rrm_ue_context, p_ue_measurment_results);

    if((RRM_PNULL != p_cdma2000_hrpd_ctx_info) && (RRM_PNULL != p_cdma2000_1xrtt_ctx_info))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 HRPD & 1xrtt Context is not NULL.");

        if(RRM_FAILURE == rrm_ue_fill_ho_required_for_cdma2000_hrpd_1xrtt_ctx
                (
                 p_rrc_rrm_ho_required,
                 p_rrm_ue_context,
                 p_irat_cdma_params,
                 p_cdma2000_hrpd_ctx_info,
                 p_cdma2000_1xrtt_ctx_info,
                 trans_id
                ))
                {
            return RRM_FAILURE;
        }
    }
    else if((RRM_PNULL == p_cdma2000_hrpd_ctx_info) && (RRM_PNULL != p_cdma2000_1xrtt_ctx_info))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 HRPD Context is  NULL & 1xrtt context is not NULL.");
        if(RRM_FAILURE == rrm_ue_fill_ho_required_for_cdma2000_hrpd_1xrtt_daho
            (
             p_rrc_rrm_ho_required,
             p_rrm_ue_context,
             p_irat_cdma_params,
             p_cdma2000_1xrtt_ctx_info,
             trans_id,
             p_inter_rat_ncl,
             p_cdma2000_daho_1xrtt_cell,
             p_cdma2000_daho_hrpd_cell
            ))
            {
            return RRM_FAILURE;
        }
    }
    else if((RRM_PNULL != p_cdma2000_hrpd_ctx_info) && (RRM_PNULL == p_cdma2000_1xrtt_ctx_info))
    {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 HRPD Context is not NULL & 1xrtt context is NULL.");
        /* HO to HRPD */
            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
            /*KPI:start*/
            p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
            /*KPI:end*/
            fill_ho_required_cdma2000_hrpd_info(p_rrm_ue_context,
                       p_cdma2000_hrpd_ctx_info,
                       p_rrc_rrm_ho_required);
    }
    else if((RRM_PNULL == p_cdma2000_hrpd_ctx_info) && (RRM_PNULL == p_cdma2000_1xrtt_ctx_info))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 HRPD Context & 1xrtt context is NULL.");
        /* To DAHO Cell */
        /*Klockwork_fix_start*/
        ret_val = rrm_ue_fill_ho_required_for_cdma2000_daho(p_rrm_ue_context ,p_irat_cdma_params ,
                p_inter_rat_ncl ,p_rrc_rrm_ho_required ,trans_id);
        if (ret_val == RRM_FAILURE)
        {
            RRM_UT_TRACE_EXIT(); 
            return RRM_FAILURE;
        }
        /*Klockwork_fix_end*/
    }
    else
    {
        /* Control Shouldn't come here */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "No Measurement & DAHO Cell configured");
    }


    p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
    p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_CDMA2000_INFO_PRESENT ;

    p_rrc_rrm_ho_required->cdma2000_information.bitmask = RRM_ZERO;

    if(!(HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == p_rrc_rrm_ho_required->ho_type))
    {
      /* Fill Mobility Params */
      fill_mobility_params_cdma2000(p_rrm_ue_context,
            &(p_rrc_rrm_ho_required->cdma2000_information.mobility_parameters),
            &(p_rrc_rrm_ho_required->cdma2000_information.add_mobility_parameters));

      p_rrc_rrm_ho_required->cdma2000_information.bitmask |= 
        RRC_RRM_HO_REQUIRED_MOBILITY_PARAMETERS_PRESENT;

      p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
        RRC_RRM_HO_REQUIRED_ADDITIONAL_MOBILITY_PARAMETERS_PRESENT;
    }

    report_index = p_rrm_ue_context->p_ue_mac_report->report_index;

    valid_report_index = (report_index % RRM_MAX_REPORT_STAT_UE);
    if(RRM_ZERO < valid_report_index)
    {

        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[valid_report_index - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }
    else if((RRM_ZERO == valid_report_index) && (RRM_ZERO < report_index))
    {
        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[RRM_MAX_REPORT_STAT_UE - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/* CDMA2000 changes ends */


/*Klocwork activity 1-Apr_2014 end*/

/* CA: Stage3 HO code start */
/*****************************************************************************
 * FUNCTION NAME : rrm_fill_scell_candidate_info_list
 * INPUT         : p_rrc_rrm_ho_required
 *                 eutran_neighbor_list
 *                 p_cell_ctxt
 * OUTPUT        : p_rrc_rrm_ho_required
 * DESCRIPTION   : Fills the candidate scell info list in ho_required message
 * RETURNS       : RRM_SUCCESS on Success
 *                 RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_fill_scell_candidate_info_list(
        rrc_rrm_ho_required_t             *p_rrc_rrm_ho_required,
        inter_freq_cells_t                *p_eutran_neighbor_list,
         /*SPR 17777 +-*/
        rrm_son_eutran_neighbor_cell_t    *p_eutran_meas_report

        )
{
    candidate_cell_info_list_t  *p_candidate_list = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_PRESENT;

    p_rrc_rrm_ho_required->source_to_target_container.bitmask |= SOURCE_TO_TARGET_TRANSPARENT_ENB_CONTAINER_PRESENT;

    p_rrc_rrm_ho_required->source_to_target_container.eNBContainer.rrc_container.bitmask |= RRM_RRC_CONTAINER_RRM_CONFIG_PRESENT;

    p_rrc_rrm_ho_required->source_to_target_container.eNBContainer.rrc_container.rrm_config.bitmask |= RRM_CONFIG_EXT_CANDIDATE_CELL_INFO_LIST_PRESENT;

    p_candidate_list = (candidate_cell_info_list_t *)&(p_rrc_rrm_ho_required->source_to_target_container.eNBContainer.rrc_container.
            rrm_config.candidate_cell_info_list);

    p_candidate_list->count++;

    p_candidate_list->candidate_cell_info[p_candidate_list->count - RRM_ONE].bitmask |= CANDIDATE_CELL_INFO_RSRP_PRESENT;
    p_candidate_list->candidate_cell_info[p_candidate_list->count - RRM_ONE].bitmask |= CANDIDATE_CELL_INFO_RSRQ_PRESENT;

    p_candidate_list->candidate_cell_info[p_candidate_list->count - RRM_ONE].phy_cell_id = p_eutran_neighbor_list->phy_cell_id;
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "PCI of SCell added in the candidate list at index[%d] is %d",
            (p_candidate_list->count - RRM_ONE),
            p_eutran_neighbor_list->phy_cell_id);

    p_candidate_list->candidate_cell_info[p_candidate_list->count - RRM_ONE].carrier_freq = p_eutran_neighbor_list->eutra_carrier_arfcn;
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Carrier Frequency of SCell added in the candidate list at index[%d] is %d",
            (p_candidate_list->count - RRM_ONE),
            p_eutran_neighbor_list->eutra_carrier_arfcn);

    p_candidate_list->candidate_cell_info[p_candidate_list->count - RRM_ONE].rsrp_result = p_eutran_meas_report->rsrp;
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "RSRP of SCell added in the candidate list at index[%d] is %d",
            (p_candidate_list->count - RRM_ONE),
            p_eutran_meas_report->rsrp);

    p_candidate_list->candidate_cell_info[p_candidate_list->count - RRM_ONE].rsrq_result = p_eutran_meas_report->rsrq;
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "RSRQ of SCell added in the candidate list at index[%d] is %d",
            (p_candidate_list->count - RRM_ONE),
            p_eutran_meas_report->rsrq);

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}



/* SPR 15674 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_required 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills the ho required message
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
    rrm_return_et rrm_ue_fill_ho_required 
(
 phy_cell_id_info_t      phy_cell_id_info,
 rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
 rrm_ue_context_t        *p_rrm_ue_context
 )
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    /* SPR 21446 start */
    /* Code removed */
    /* SPR 21446 end */
    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */
    rrm_target_id_t          target_id;
    rrm_cell_index_t         cell_index = p_rrm_ue_context->cell_index;
    /*csg start*/
    rrm_temp_cell_info_t     rrm_temp_cell_info;
    /*csg end*/
    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */

    /* SPR 20635 Fix - SRVCC to GERAN - Starts */
    cell_selection_priority_list_t  *p_geran_cell_list = RRM_PNULL;
    U8                              index = RRM_NULL;
    /* SPR 20635 Fix - SRVCC to GERAN - Ends */

    RRM_UT_TRACE_ENTER();
    RRM_MEMSET(p_rrc_rrm_ho_required, RRM_ZERO,(sizeof(rrc_rrm_ho_required_t)));
    RRM_MEMSET(&(target_id), RRM_ZERO,(sizeof(rrm_target_id_t)));
    /*csg start*/
    RRM_MEMSET(&(rrm_temp_cell_info), RRM_ZERO,(sizeof(rrm_temp_cell_info)));
    /*csg end*/

    /* Soft Lock start - Global variable removal */
    rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
    p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return RRM_FAILURE;
    }
    /* Soft Lock end - Global variable removal */

    /* Check if SPID is not present & CDMA2000 is configured */
    if((p_rrm_ue_context->cdma2000_capabilities.is_cdma2000_present) &&
            (RRM_TRUE == p_rrm_ue_context->cdma2000_meas_id_received))
    {
        /* Fill HO Required For CDMA2000 */
        /*coverity 30053, rel2.0.1, aditya, typecasted to rrm_return_et*/
        ret_val = rrm_ue_fill_ho_required_for_cdma2000(p_rrc_rrm_ho_required, p_rrm_ue_context);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Filled HO Required for CDMA2000");
    }
    // HO Enhancement: For CSFB blind timer case, choose RAT for HO on the basis of defined priority 
    else if((MEAS_REP_EVENT_NONE == p_rrm_ue_context->meas_rep_event) &&
            (RRM_IRAT_PRIORITY_CDMA2000 == get_next_priority_rat(RRM_ZERO, p_rrm_ue_context)))
    {
        /* Fill HO Required For CDMA2000 */
        /*coverity 30052, rel2.0.1, aditya, typecasted to rrm_return_et*/
        ret_val = rrm_ue_fill_ho_required_for_cdma2000(p_rrc_rrm_ho_required, p_rrm_ue_context);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Filled HO Required for CDMA2000");
    }
    else
    {
        if(RRM_FAILURE == rrm_get_target_id_from_phy_cell_id(phy_cell_id_info,
                    cell_index,
                    &target_id,
                    /* SPR 19364 start */
                    /* Code removed */
                    /* SPR 19364 end */
                    /*casg start*/
                    &rrm_temp_cell_info,
                    /*casg end*/
                    /* SPR 314 start */
                    p_rrm_ue_context->target_cell_type,
                    /* SPR 314 end */
                    /* SPR 12396 Fix Start */
                    /*CCO change begin*/
                    p_rrc_rrm_ho_required,
                    /* SPR 12396 Fix Stop */
                    p_rrm_ue_context
                    /*CCO change end*/
                    ))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "target cell id selection failed for [UE:%u]",
                    p_rrm_ue_context->ue_index);      
            ret_val = RRM_FAILURE;
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /* SPR 19364 start */
        /* Fix Start 9903 */
		/*SPR 19791 Fix Start*/
		/*Code removed*/
		/*SPR 19791 Fix Stop*/
        p_rrc_rrm_ho_required->ue_index = p_rrm_ue_context->ue_index;
        /* Fix End 9903 */
	/* SPR 19620: CID 94856 Fix Start */ 
	switch(p_rrm_ue_context->target_cell_type)
	{
		case EUTRA_CELL:
			{
				RRM_MEMCPY(&(p_rrm_ue_context->ho_params.target_cell_identity[RRM_ZERO]),\
						&(target_id.enb_id.global_enb_id.ecgi),\
						MAX_CELL_IDENTITY_OCTETS);
                /* SPR 21446 start */
                /* Code removed */
                /* SPR 21446 end */
			}
			break;

		case UTRA_CELL:
			{
				if(target_id.bitmask & RRM_TARGET_ID_RNC_ID_PRESENT)
				{
					p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_UTRAN;
					/*KPI:start*/
					p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_UTRAN;
					/*KPI:end*/
					/*CSFB Changes begin*/
					if (p_rrm_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
						p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;
					else
					{
						/* SPR_13939_Fix_Start */
						/* SPR 17002 Fix Start */
						/* SPR 17774_Fix_Start */
						if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_rrm_ue_context->cell_index))) &&
									(RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.
									 rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
								(RRM_FALSE == p_rrm_ue_context->ho_params.a2_event_received))
							/* SPR 17774_Fix_Stop */
						{
							p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
						}
						else
						{ 
							p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
						}
						/* SPR 17002 Fix End */
						/* SPR_13939_Fix_End */
						/* SRVCC SUPPORT START */
						if(RRM_UEM_SRVCC_HO_INDICATION_PRESENT & p_rrm_ue_context->srvcc_config_info.bitmask)
						{
							/* Trigger SRVCC HO */
							if(RRM_SRVCC_CS_ONLY_TYPE == p_rrm_ue_context->srvcc_config_info.srvcc_ho_indication)
							{
								p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT;
								p_rrc_rrm_ho_required->srvcc_ho_indication = CS_ONLY_TYPE;
								p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_PS_SERVICE_NOT_AVAILABLE_PRESENT;
								p_rrc_rrm_ho_required->ps_service_not_available = RRM_ZERO;
							}
							else if(RRM_SRVCC_CS_PS_TYPE == p_rrm_ue_context->srvcc_config_info.srvcc_ho_indication)
							{
								p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT;
								p_rrc_rrm_ho_required->srvcc_ho_indication = CS_PS_TYPE;
							}
						}
						else
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"SRVCC HO Indication not to be sent");
						}
						/* SRVCC SUPPORT END */
					}
                    /* SPR 20811 Fix Start */
                    /* Code Deleted */
                    /* SPR 20811 Fix End */
                    /* Fix 10029 Start */
                    if(RRM_UEM_TEMP_CELL_ID_PRESENT & rrm_temp_cell_info.bitmask)
                    {
                        /* SPR 10137 Start */
                        RRM_MEMCPY(&p_rrc_rrm_ho_required->source_to_target_container.\
                                rncContainer.target_cell_id, &rrm_temp_cell_info.cell_id,
                                sizeof(U8) * RRM_MERGED_UTRAN_CELL_IDENTITY_OCTETS);
                        /* SPR 10137 End */
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Target cell ID absent");
                    }
                    /* Fix 10029 End */
                    /* SPR 20811 Fix Start */
                    /* Code Deleted */
                    /* SPR 20811 Fix End */
				}
			}
			break;

		case GERAN_CELL:
			{
				if(HANDOVER_TYPE_CCO != p_rrc_rrm_ho_required->ho_type)
				{
					if(target_id.bitmask & RRM_TARGET_ID_CGI_PRESENT)
					{
						p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_GERAN;
						/*KPI:start*/
						p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_GERAN;
						/*KPI:end*/

						/* SPR_13721_fix : start */
						if (p_rrm_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
							p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;
						else
						{
							p_rrc_rrm_ho_required->cause.value = S1_INTER_SYSTEM_HANDOVER_TRIGGERED;
							/* SRVCC SUPPORT START */
							if(RRM_UEM_SRVCC_HO_INDICATION_PRESENT & p_rrm_ue_context->srvcc_config_info.bitmask)
							{
								/* Trigger SRVCC HO */
								if(RRM_SRVCC_CS_ONLY_TYPE == p_rrm_ue_context->srvcc_config_info.srvcc_ho_indication)
								{
									p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT;
									p_rrc_rrm_ho_required->srvcc_ho_indication = CS_ONLY_TYPE;
									p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_PS_SERVICE_NOT_AVAILABLE_PRESENT;
									p_rrc_rrm_ho_required->ps_service_not_available = RRM_ZERO;
								}
								else if(RRM_SRVCC_CS_PS_TYPE == p_rrm_ue_context->srvcc_config_info.srvcc_ho_indication)
								{
									p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT;
									p_rrc_rrm_ho_required->srvcc_ho_indication = CS_PS_TYPE;
								}
							}
							else
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
										"GERAN SRVCC HO Indication not to be sent");
							}
							if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_rrm_ue_context->cell_index))) &&
										(RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.
										 rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
									(RRM_FALSE == p_rrm_ue_context->ho_params.a2_event_received))
								/* SPR 17774_Fix_Stop */
							{
								p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
							}
							else
							{ 
								p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
							}
						}
						/* SPR_13721_fix : end */
						/* SPR_13721_fix : start */
						/*Code removed*/
						/* SPR_13721_fix : end */
					}
				}
			}
			break;

            default:
            break;
        }
        /* SPR 19620: CID 94856 Fix End */
        /* SPR 19364 end */
        /* SPR 19364 start */
        /* Code removed */
        /* SPR 19364 end */

        /*SPR 15180 Fix Start*/
        /* code deleted */
        p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
        /*SPR 15180 Fix Stop*/
        if(p_rrc_rrm_ho_required->ho_type == HANDOVER_TYPE_INTRA_LTE_X2)
        {
            /* SRVCC SUPPORT START */
            /* Need to send SRVCC ho op possible in case of X2 HO */
            if(RRM_TRUE == p_rrm_ue_context->srvcc_config_info.srvcc_ho_op_possible)
            {
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_OP_POSSIBLE_PRESENT;
                p_rrc_rrm_ho_required->srvcc_ho_op_possible = RRM_TRUE;
            }
            /* SRVCC SUPPORT END */
        }
        /*CCO Fix-21-feb*/
        /* SPR 19364 start */
        if(HANDOVER_TYPE_CCO != p_rrc_rrm_ho_required->ho_type)
        {
            /* SPR 20635 Fix - SRVCC to GERAN - Starts */
            /* Store the Target GERAN Cell RSSI value received in Meas Results,
             * To fill Target Cell Radio Information in Old BSS to New BSS Information */
            p_geran_cell_list = &(p_rrm_ue_context->ho_params.geran_known_cell_selection_list);
            for(index = RRM_NULL; index < p_geran_cell_list->count; index++)
            {
                if(p_geran_cell_list->reported_neighbor_cell_info[index].phy_cell_id == 
                        phy_cell_id_info.phy_cell_id)
                {
                    p_rrm_ue_context->ho_params.target_geran_cell_rssi =
                        p_geran_cell_list->reported_neighbor_cell_info[index].rsrx_value;
                    break;
                }
            }

            /* Fill Primary Containter */
            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_PRESENT;
            rrm_ue_fill_src_target_container(&p_rrc_rrm_ho_required->source_to_target_container,
                    p_rrm_ue_context, (rrc_handover_type_et)(p_rrc_rrm_ho_required->ho_type));

            /* Fill Secondary Containter with Old BSS to New BSS Information if CS + PS SRVCC to GERAN */
            if((HANDOVER_TYPE_LTE_TO_GERAN == p_rrc_rrm_ho_required->ho_type) &&
                    (RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT & p_rrc_rrm_ho_required->bitmask) &&
                    (CS_PS_TYPE == p_rrc_rrm_ho_required->srvcc_ho_indication))
            {
                p_rrc_rrm_ho_required->bitmask |= 
                    RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_SECONDARY_PRESENT;
                rrm_ue_fill_oldbss_to_newbss_information(
                        &p_rrc_rrm_ho_required->source_to_target_container_secondary,
                        p_rrm_ue_context);
            }
            /* SPR 20635 Fix - SRVCC to GERAN - Ends */
            /* Loss-less data transfer changes start */
            fill_dl_data_fwd_erab_list(
                    p_rrm_ue_context, 
                    p_rrc_rrm_ho_required);
            /* Loss-less data transfer changes end */
        }
        /* SPR 19364 end */

        /* Inter RAT changes start */
        /* coverity id :16552 ,rel 2.0.1 */
        /* SPR 19364 start */
        /* Code removed */
        /* SPR 19364 end */
        /* SPR 14886 Fix Start */
        /* In case X2 link is not present for the target then resetting the bitmask to remove 
         * the FORWARDING PATH AVILABILITY IE in case of S1 HO*/ 
        /*SPR 15180 Fix Start*/
		/*SPR 19791 Fix Start*/
        /* SPR 21446 start */
        /* Code removed */
        /* SPR 21446 end */
        /* SPR 14886 Fix End */
        /* Inter RAT changes end */
        RRM_MEMCPY(&p_rrc_rrm_ho_required->target_id,&target_id,sizeof(rrm_target_id_t));

        /*csg id start*/
        if(rrm_temp_cell_info.bitmask & RRM_UEM_TEMP_CELL_ACCESS_MODE_PRESENT)
        {
            if(rrm_temp_cell_info.cell_access_mode == RRM_OAM_ACCESS_MODE_HYBRID)
            {
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_CELL_ACCESS_MODE_PRESENT;
                p_rrc_rrm_ho_required->cell_access_mode = RRC_HYBRID; 
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_CSG_ID_PRESENT;
                RRM_MEMCPY(p_rrc_rrm_ho_required->csg_identity,rrm_temp_cell_info.csg_id,CSG_ID_OCTET_SIZE);
            }
            else if(rrm_temp_cell_info.cell_access_mode == RRM_OAM_ACCESS_MODE_CLOSE)
            {
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_CSG_ID_PRESENT;
                RRM_MEMCPY(p_rrc_rrm_ho_required->csg_identity,rrm_temp_cell_info.csg_id,CSG_ID_OCTET_SIZE);
            }

        }
        /*csg id end*/
    }/*End of else*/
    /* Populate RRMUEM_RMIF_HANDOVER_REPORT msg to be sent to RMIF */
    rrm_ue_populate_rrmif_handover_report(p_rrm_ue_context,
            &target_id,
            /* MLB Changes start */
            /* SPR 17108 FIX START*/
            &phy_cell_id_info
            /* SPR 17108 FIX END*/
            /* MLB Changes end */
            );

    /* BLR Team HO status report to SON Changes End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 15674 End */


/******************************************************************************
 *   FUNCTION NAME:rrm_ue_fill_daho_cdma2000_ho_required
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills and sends ho required 
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_daho_cdma2000_ho_required
(
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required,
    rrm_ue_context_t              *p_rrm_ue_context 
)
{

    rrm_return_et                   ret_val = RRM_SUCCESS;
    inter_rat_ncl_t                 *p_inter_rat_ncl = RRM_PNULL;
    idle_mode_mobility_params_t     *p_irat_params = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  
                                    *p_irat_cdma_params = RRM_PNULL;
    U8  report_index = RRM_ZERO;
    U8 valid_report_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    RRM_MEMSET(p_rrc_rrm_ho_required, RRM_ZERO,(sizeof(rrc_rrm_ho_required_t)));

    p_inter_rat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_rrm_ue_context->cell_index);

    p_irat_params = rrm_cellm_get_idle_mode_params(p_rrm_ue_context->cell_index);

    p_irat_cdma_params = &(p_irat_params->idle_mode_mobility_irat_cdma_params);

    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell = RRM_PNULL;

    p_cdma2000_daho_1xrtt_cell = (rrmcm_rmif_cdma2000_freq_cells_t *) \
                                 rrm_ue_match_1xrtt_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);
    p_cdma2000_daho_hrpd_cell = rrm_ue_match_hrpd_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    /* Fill HO Required For CDMA2000 */
    if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell && RRM_PNULL != p_cdma2000_daho_hrpd_cell)
    {
        /* Check for Con. PS HO */
        if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_irat_cdma_params->inter_rat_parameters_cdma2000_v920.
                 bitmask & RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG))
        {
            if((p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.bitmask &
                        RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT) && (p_rrm_ue_context->
                            ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                            inter_rat_parameters_cdma2000_v920.bitmask &
                            RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT))
            {
                /* Concurr */
                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
                /*KPI:start*/
                p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD;
                /*KPI:end*/

                /* Fill DAHO Info for HRPD/1XRTT */
                fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                        p_rrc_rrm_ho_required);

                fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                        p_rrc_rrm_ho_required);
            }
            else if((p_irat_cdma_params->presence_bitmask &
                        RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                    (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                     ue_eutra_capability_v920_ies.bitmask &
                     RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
            {
                /* Check for eCSFB */
                p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                /*KPI:start*/
                p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
                /*KPI:end*/
                fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                        p_rrc_rrm_ho_required);

            }
            else
            {
                return RRM_FAILURE;
            }
        }
        else if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
        {
            /* Check for eCSFB */
            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:start*/
            p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:end*/
            fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                    p_rrc_rrm_ho_required);

        }
        else
        {
            return RRM_FAILURE;
        }
    }
    else if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell && RRM_PNULL == p_cdma2000_daho_hrpd_cell)
    {
        if((p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
                (p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
        {
            /* fill ho required for 1xRTT */
            /* HO CMD RESP, redirection to HRPD */
            p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:start*/
            p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
            /*KPI:end*/
            fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                    p_rrc_rrm_ho_required);
        }
        else
        {
            return RRM_FAILURE;
        }
    }
    else if(RRM_PNULL == p_cdma2000_daho_1xrtt_cell && RRM_PNULL != p_cdma2000_daho_hrpd_cell)
    {
        /* HO to HRPD */
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:start*/
        p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:end*/
        fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                p_rrc_rrm_ho_required);
    }
    else if(RRM_PNULL == p_cdma2000_daho_1xrtt_cell && RRM_PNULL == p_cdma2000_daho_hrpd_cell)
    {
        return RRM_FAILURE;
    }
    p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
    /* SPR_13939_Fix_Start */
    if (p_rrm_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
        p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;
    else
    /* SPR 17002 Fix Start */
    {
        /* SPR_13939_Fix_Start */
        /* SPR 17774_Fix_Start */
        if (((ICIC_SCHEME_NONE != (rrm_cellm_get_icic_scheme_configured_in_cell(p_rrm_ue_context->cell_index))) &&
                (RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.
                 rrm_ue_dynamic_icic_present_data.ue_present_position)) ||
                (RRM_FALSE == p_rrm_ue_context->ho_params.a2_event_received))
        /* SPR 17774_Fix_Stop */
        {
    p_rrc_rrm_ho_required->cause.value = HANDOVER_DESIRABLE_FOR_RADIO_REASONS;
        }
        else
        { 
            p_rrc_rrm_ho_required->cause.value = TIME_CRITICAL_HANDOVER;
        }
    }
    /* SPR 17002 Fix End */
    /* SPR_13939_Fix_End */

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_CDMA2000_INFO_PRESENT ;

    p_rrc_rrm_ho_required->cdma2000_information.bitmask = RRM_ZERO;

    if(!(HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == p_rrc_rrm_ho_required->ho_type))
    {
        /* Fill Mobility Params */
        fill_mobility_params_cdma2000(p_rrm_ue_context,
                &(p_rrc_rrm_ho_required->cdma2000_information.mobility_parameters),
                &(p_rrc_rrm_ho_required->cdma2000_information.add_mobility_parameters));

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |= 
            RRC_RRM_HO_REQUIRED_MOBILITY_PARAMETERS_PRESENT;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_HO_REQUIRED_ADDITIONAL_MOBILITY_PARAMETERS_PRESENT;
    }

    report_index = p_rrm_ue_context->p_ue_mac_report->report_index;

    valid_report_index = (report_index % RRM_MAX_REPORT_STAT_UE);
    if(RRM_ZERO < valid_report_index)
    {

        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[valid_report_index - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }
    else if((RRM_ZERO == valid_report_index) && (RRM_ZERO < report_index))
    {
        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[RRM_MAX_REPORT_STAT_UE - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_daho_1xrtt_ho_required 
 *   INPUT      : p_ue_context,trans_id
 *   OUTPUT     : none 
 *   DESCRIPTION:
 *       Fills and sends ho required
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_daho_1xrtt_ho_required
(
 rrm_ue_context_t    *p_ue_context,
 U16                  trans_id)
{
    /*coverity 30050, rel2.0.1, aditya, type changed to rrm_return_et*/
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 report_index = RRM_FALSE;
    U8 valid_report_index = RRM_ZERO;
    rrm_cell_context_t  *p_cell_context = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params = RRM_PNULL;
    inter_rat_ncl_t  *p_inter_rat_ncl = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell = RRM_PNULL;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
   /* 
    if(RRM_FAILURE == rrm_ue_handle_lipa_bearer_release(p_ue_context))
    {
        return RRM_FAILURE;
    }
    */
    RRM_ASSERT(RRM_PNULL != p_ue_context);   /* Klocwork_fix_27_aug */
    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
        rrm_mem_get(sizeof(rrc_rrm_ho_required_t));

    if (RRM_PNULL == p_rrc_rrm_ho_required)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_rrc_rrm_ho_required, RRM_ZERO,(sizeof(rrc_rrm_ho_required_t)));

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    RRM_ASSERT(RRM_PNULL != p_cell_context);   /* Klocwork_fix_27_aug */

    p_irat_cdma_params = &(p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_inter_rat_ncl = &(p_cell_context->ran_info.ncl_params.inter_rat_ncl);

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->target_id.bitmask = RRM_ZERO;

    p_rrc_rrm_ho_required->ue_index = p_ue_context->ue_index;

    p_cdma2000_daho_1xrtt_cell = rrm_ue_match_1xrtt_daho_cell_from_ncl
        (p_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell)
    {
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:start*/
        p_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:end*/

        fill_ho_required_daho_cdma2000_1xrtt_info(p_ue_context, p_cdma2000_daho_1xrtt_cell,
                p_rrc_rrm_ho_required);

        p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
        /* SPR_13939_Fix_Start */
        p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;
        /* SPR_13939_Fix_End */

        p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
        p_rrc_rrm_ho_required->bitmask |= RRC_RRM_CDMA2000_INFO_PRESENT ;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask = RRM_ZERO;

        /* Fill Mobility Params */
        fill_mobility_params_cdma2000(p_ue_context,
                &(p_rrc_rrm_ho_required->cdma2000_information.mobility_parameters),
                &(p_rrc_rrm_ho_required->cdma2000_information.add_mobility_parameters));

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |= 
            RRC_RRM_HO_REQUIRED_MOBILITY_PARAMETERS_PRESENT;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_HO_REQUIRED_ADDITIONAL_MOBILITY_PARAMETERS_PRESENT;

        report_index = p_ue_context->p_ue_mac_report->report_index;
        valid_report_index = (report_index % RRM_MAX_REPORT_STAT_UE);
        if(RRM_ZERO < valid_report_index)
        {
            p_rrc_rrm_ho_required->cdma2000_information.
                eutran_round_trip_delay_estimation_info = p_ue_context->
                p_ue_mac_report->ue_stats[valid_report_index - RRM_ONE].timingAdvanceValue;

            p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
                RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
        }
        else if((RRM_ZERO == valid_report_index) && (RRM_ZERO < report_index))
        {
            p_rrc_rrm_ho_required->cdma2000_information.
                eutran_round_trip_delay_estimation_info = p_ue_context->
                p_ue_mac_report->ue_stats[RRM_MAX_REPORT_STAT_UE - RRM_ONE].timingAdvanceValue;

            p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
                RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
        }

        ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
                RRM_MODULE_ID,RRC_MODULE_ID,trans_id,p_ue_context->cell_index);

        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "[UE:%d]Failed to send HO REQUIRED",
                    p_rrc_rrm_ho_required->ue_index);
        }
        else
        { 
            /*SPR 18241 START*/
            RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_SRC_HO_ONGOING);
            /*SPR 18241 END*/

            UEM_FSM_SET_STATE( p_ue_context, RRM_UE_STATE_HO_ONGOING);
            rrm_raise_event_ho_out_prep_attempt(p_ue_context,
                    p_rrc_rrm_ho_required);
            /* Review_comment_for_SPR_7996_nd_8345_start */
            rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                                                p_ue_context);
            /* Review_comment_for_SPR_7996_nd_8345_end */
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "No DAHO Cell of type 1XRTT found");
        /* RWR */
        /* Bug 16121 Fix Start */
        if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                    p_ue_context->ue_index,
                    RADIO_NETWORK_LAYER_TYPE,
                    /* SPR-10489-fix start */
                    /* SPR-12518-fix start */
                    CS_FALLBACK_TRIGGERED,
                    /* SPR-12518-fix end */
                    //REDIRECTION_TOWARDS_1XRTT,
                    /* SPR-10489-fix end */
                    trans_id,
                    p_ue_context,
                    /* SPR_10729_fix */
                    p_ue_context->cell_index))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ue connection release ind sent for [UE:%d]",p_ue_context->ue_index);
            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "ue_connection_release_ind sent, \
                        Failed to clean up ue resources");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to send release connection ind for [UE:%d]",
                    p_ue_context->ue_index);
        }
        /* Bug 16121 Fix End */

        ret_val = RRM_FAILURE;
    }

    /* COVERITY : RESOURCE LEAK : CID : 54410 fix start */
    if(p_rrc_rrm_ho_required )
    /* Bug 16121 Fix Start */
        RRM_MEM_FREE( p_rrc_rrm_ho_required );
    /* Bug 16121 Fix End*/
    /* COVERITY : RESOURCE LEAK : CID : 54410 fix end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_daho_cdma2000_ho_required_is_rab_ue_released
 *   INPUT      : p_ue_context,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *             Check is_rab_ue_released then fills and sends ho required
 ******************************************************************************/
void
rrm_build_and_send_daho_cdma2000_ho_required_is_rab_ue_released
 (
    rrm_ue_context_t * p_ue_context,
    U16  transaction_id,
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required,
    rrm_ue_lipa_release_et  is_rab_ue_released,
    rrm_return_et          *ret_val
)
{

    RRM_UT_TRACE_ENTER();

    if(UE_LIPA_RAB_RELEASE == is_rab_ue_released)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "HO REQUIRED is queued, it shall be called once erb release cnf is received");
        rrm_ue_procedure_queue_t    proc_queue;
        proc_queue.api_id = RRC_RRM_HO_REQUIRED;
        proc_queue.p_proc_data = (rrc_rrm_ho_required_t *)p_rrc_rrm_ho_required;
        /*BUG 13332:start*/
        proc_queue.trans_id = transaction_id;
        /*BUG 13332:end*/

        /**Enqueue ERAB setup request */
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue,p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/

        p_ue_context->lipa_ho_required.transaction_id = transaction_id;
        p_ue_context->current_procedure.state =
            RRM_UE_LIPA_SIPTO_HO_ONGOING;
    }
    else 
    {
        *ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
                RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
        if(*ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "[UE:%d]Failed to send HO REQUIRED",
                    p_rrc_rrm_ho_required->ue_index);
        }
        else
        {  
            /*SPR 18241 START*/
            RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_SRC_HO_ONGOING);
            /*SPR 18241 END*/

            UEM_FSM_SET_STATE( p_ue_context, RRM_UE_STATE_HO_ONGOING);
                /* SPR 15232 start */
                /* Remove code */
                /* SPR 15232 end */
            p_ue_context->ho_params.ho_retry_count++;
            /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-START
              When an outgoing handover preparation UE task is requested*/
            rrm_raise_event_ho_out_prep_attempt(p_ue_context,
                    p_rrc_rrm_ho_required); 
            /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-END*/
            /* Review_comment_for_SPR_7996_nd_8345_start */
            rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                    p_ue_context);
            /* Review_comment_for_SPR_7996_nd_8345_end */
        }
            /* SPR 15441 start */
            /* code removed */
            /* SPR 15441 end */
    }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_daho_cdma2000_ho_required
 *   INPUT      : p_ue_context,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required 
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_daho_cdma2000_ho_required
 (
    rrm_ue_context_t * p_ue_context,
  U16  transaction_id)
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;
    rrm_ue_lipa_release_et  is_rab_ue_released = UE_LIPA_RELEASE_NONE;
    
    RRM_UT_TRACE_ENTER();
  
    if(RRM_FAILURE == rrm_ue_handle_lipa_bearer_release(p_ue_context, &is_rab_ue_released))
    {
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    else
    {
        if(UE_LIPA_UE_RELEASE == is_rab_ue_released)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_SUCCESS;
        }
    }

    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
                              rrm_mem_get(sizeof(rrc_rrm_ho_required_t));
    if (RRM_PNULL == p_rrc_rrm_ho_required)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    /* Inter RAT changes start */
    if (RRM_FAILURE != (ret_val = rrm_ue_fill_daho_cdma2000_ho_required
                (p_rrc_rrm_ho_required,p_ue_context)))
        /* Inter RAT changes end */
    {
        /*Klocwork activity 1-Apr_2014 start*/
        rrm_build_and_send_daho_cdma2000_ho_required_is_rab_ue_released
            (
             p_ue_context,
             transaction_id,
             p_rrc_rrm_ho_required,
             is_rab_ue_released,
             &ret_val
            );
        /*Klocwork activity 1-Apr_2014 end*/

    }   
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
               "Failed to fill the UE REQUIRED Message for the [UE:%d]",
               p_rrc_rrm_ho_required->ue_index);
        /* SPR 15441 start */
        /* code removed */
        /* SPR 15441 end */
    }
    /* SPR 15441 start */
    RRM_MEM_FREE(p_rrc_rrm_ho_required);
    /* SPR 15441 end */
    RRM_UT_TRACE_EXIT();
    /*Cov_fix_start_64548*/
    /*Cov_fix_end_64548*/
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_cdma2000_ho_required
 *   INPUT      : p_ue_context
 *   OUTPUT     : p_rrc_rrm_ho_required
 *   DESCRIPTION:
 *       Fills and sends ho required
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_cdma2000_ho_required
(
 rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required,
 rrm_ue_context_t  *p_ue_context
 )
{
    /* HRPD HO Case */
    /*coverity 30051, rel2.0.1, aditya, rrm_bool_et changed to rrm_return_et*/
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 report_index = RRM_FALSE;
    U8 valid_report_index = RRM_ZERO;
    rrm_cell_context_t  *p_cell_context = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params = RRM_PNULL;
    inter_rat_ncl_t  *p_inter_rat_ncl = RRM_PNULL;
    U16  trans_id = RRM_ONE;

    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_hrpd_ctx_info = RRM_PNULL;
    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_1xrtt_ctx_info = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell = RRM_PNULL;

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);

    p_irat_cdma_params = &(p_cell_context->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_inter_rat_ncl = &(p_cell_context->ran_info.ncl_params.inter_rat_ncl);

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->target_id.bitmask = RRM_ZERO;

    p_rrc_rrm_ho_required->ue_index = p_ue_context->ue_index;

    p_cdma2000_hrpd_ctx_info = rrm_ue_match_hrpd_cell_meas_ctx(p_ue_context, RRM_PNULL);

    p_cdma2000_1xrtt_ctx_info = rrm_ue_match_1xrtt_cell_meas_ctx(p_ue_context, RRM_PNULL);

    if(RRM_PNULL != p_inter_rat_ncl && RRM_PNULL != p_irat_cdma_params)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "Inter rat ncl & irat cdma params is  not NULL");
	    p_cdma2000_daho_1xrtt_cell = rrm_ue_match_1xrtt_daho_cell_from_ncl
		    (p_ue_context, p_inter_rat_ncl, p_irat_cdma_params);
	    p_cdma2000_daho_hrpd_cell = rrm_ue_match_hrpd_daho_cell_from_ncl
		    (p_ue_context, p_inter_rat_ncl, p_irat_cdma_params);
    }

    if(RRM_PNULL != p_cdma2000_hrpd_ctx_info)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 HRPD Context is  not NULL");
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:start*/
        p_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:end*/
        fill_ho_required_cdma2000_hrpd_info(p_ue_context,
                p_cdma2000_hrpd_ctx_info,
                p_rrc_rrm_ho_required);
    }
    else if(RRM_PNULL != p_cdma2000_daho_hrpd_cell)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 DAHO HRPD cell Context is  not NULL");
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:start*/
        p_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:end*/
        fill_ho_required_daho_cdma2000_hrpd_info(p_ue_context, p_cdma2000_daho_hrpd_cell,
                p_rrc_rrm_ho_required);
    }
    else if(RRM_PNULL != p_cdma2000_1xrtt_ctx_info)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 1xrtt Context is  not NULL");
        /* fill ho required for 1xRTT */
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:start*/
        p_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:end*/
        fill_ho_required_cdma2000_1xrtt_info(p_ue_context, 
                p_cdma2000_1xrtt_ctx_info, 
                p_rrc_rrm_ho_required);
    }
    else if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
               "CDMA 2000 DAHO 1xrtt cell Context is  not NULL");
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:start*/
        p_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:end*/
        fill_ho_required_daho_cdma2000_1xrtt_info(p_ue_context, p_cdma2000_daho_1xrtt_cell,
                p_rrc_rrm_ho_required);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "No Cell of type 1XRTT/HRPD found");
        /* Bug 16121 Fix Start */
        if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                    p_ue_context->ue_index,
                    RADIO_NETWORK_LAYER_TYPE,
                    /* SPR-13129-fix start */
                    INTER_RAT_REDIRECTION,
                    /* SPR-13129-fix end */
                    trans_id,
                    p_ue_context,
                    /* SPR_10729_fix */
                    p_ue_context->cell_index))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ue connection release ind sent for [UE:%d]",p_ue_context->ue_index);
            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "ue_connection_release_ind sent, \
                        Failed to clean up ue resources");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to send release connection ind for [UE:%d]",
                    p_ue_context->ue_index);
        }
        /* Bug 16121 Fix End */

        return RRM_FAILURE;
    }

    p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
    /* SPR_13939_Fix_Start */
    p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;
    /* SPR_13939_Fix_End */

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_CDMA2000_INFO_PRESENT ;

    p_rrc_rrm_ho_required->cdma2000_information.bitmask = RRM_ZERO;

    report_index = p_ue_context->p_ue_mac_report->report_index;
    valid_report_index = (report_index % RRM_MAX_REPORT_STAT_UE);
    if(RRM_ZERO < valid_report_index)
    {

        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_ue_context->
            p_ue_mac_report->ue_stats[valid_report_index - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }
    else if((RRM_ZERO == valid_report_index) && (RRM_ZERO < report_index))
    {
        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_ue_context->
            p_ue_mac_report->ue_stats[RRM_MAX_REPORT_STAT_UE - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_cdm2000_ho_required_is_rab_ue_released 
 *   INPUT      : p_ue_context,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required
 ******************************************************************************/
void
rrm_build_and_send_cdm2000_ho_required_is_rab_ue_released
(
    rrm_ue_context_t  *p_ue_context,
    U16                transaction_id,
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required,
    rrm_ue_lipa_release_et  is_rab_ue_released,
    rrm_return_et          *ret_val
 )
{
    RRM_UT_TRACE_ENTER();
    
    if(UE_LIPA_RAB_RELEASE == is_rab_ue_released)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "HO REQUIRED is queued, it shall be called once erb release cnf is received");
        rrm_ue_procedure_queue_t    proc_queue;
        proc_queue.api_id = RRC_RRM_HO_REQUIRED;
        proc_queue.p_proc_data = (rrc_rrm_ho_required_t *)p_rrc_rrm_ho_required;
        /*BUG 13332:start*/
        proc_queue.trans_id = transaction_id;
        /*BUG 13332:end*/

        /**Enqueue ERAB setup request */
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue,p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/

        p_ue_context->lipa_ho_required.transaction_id = transaction_id;
        p_ue_context->current_procedure.state =
            RRM_UE_LIPA_SIPTO_HO_ONGOING;

    }
    else 
    {
        *ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
                RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
        if(*ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "[UE:%d]Failed to send HO REQUIRED",
                    p_rrc_rrm_ho_required->ue_index);
        }
        else
        {
            UEM_FSM_SET_STATE( p_ue_context, RRM_UE_STATE_HO_ONGOING);
                /* SPR 15232 start */
                /* Remove code */
                /* SPR 15232 end */
            p_ue_context->ho_params.ho_retry_count++;
            /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-START
              When an outgoing handover preparation UE task is requested*/
            rrm_raise_event_ho_out_prep_attempt(p_ue_context,
                    p_rrc_rrm_ho_required); 
            /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-END*/
            /* Review_comment_for_SPR_7996_nd_8345_start */
            rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                    p_ue_context);
            /* Review_comment_for_SPR_7996_nd_8345_end */
        }
	    /* Coverity 94055 Fix Start */
        /* Code Deleted */
        /*Coverity 94055 Fix End */
    }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_cdm2000_ho_required 
 *   INPUT      : p_ue_context,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_cdm2000_ho_required
(
 rrm_ue_context_t  *p_ue_context,
 U16                transaction_id
 )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;
    rrm_ue_lipa_release_et  is_rab_ue_released = UE_LIPA_RELEASE_NONE;

    RRM_UT_TRACE_ENTER();
 
    if(RRM_FAILURE == rrm_ue_handle_lipa_bearer_release(p_ue_context, &is_rab_ue_released))
    {
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    else
    {
        if(UE_LIPA_UE_RELEASE == is_rab_ue_released)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_SUCCESS;
        }
    }

    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
                              rrm_mem_get(sizeof(rrc_rrm_ho_required_t));

    if (RRM_PNULL == p_rrc_rrm_ho_required)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    if (RRM_FAILURE != (ret_val = rrm_ue_fill_cdma2000_ho_required
                              (p_rrc_rrm_ho_required,p_ue_context)))
    {
        rrm_build_and_send_cdm2000_ho_required_is_rab_ue_released
            (
             p_ue_context,
             transaction_id,
             p_rrc_rrm_ho_required,
             is_rab_ue_released,
             &ret_val
            );

    }   
    else
    {
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
			    "Failed to fill the UE REQUIRED Message for the [UE:%d]",
			    p_rrc_rrm_ho_required->ue_index);
	    /* Coverity 94055 Fix Start */
        /* Code Deleted */
        /* Coverity 94055 Fix End */
        /* SPR 15441 start */
        /* code removed */
        /* SPR 15441 end */
    }
    /* SPR 15441 start */
    /* Coverity 94055 Fix Start */
    if (RRM_PNULL != p_rrc_rrm_ho_required)
    {
        RRM_MEM_FREE(p_rrc_rrm_ho_required);
    }
    /* Coverity 94055 Fix End */

    /* SPR 15441 end */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_hrpd_daho_ho_required
 *   INPUT      : p_rrm_ue_context,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_hrpd_daho_ho_required
(
 rrm_ue_context_t  *p_rrm_ue_context,
 U16                transaction_id)
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;

    U8 report_index = RRM_FALSE;
    U8 valid_report_index = RRM_ZERO;
    rrm_cell_context_t  *p_cell_context = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params = RRM_PNULL;
    inter_rat_ncl_t  *p_inter_rat_ncl = RRM_PNULL;

    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_hrpd_cell = RRM_PNULL;

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);

    p_irat_cdma_params = &(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_inter_rat_ncl = &(p_cell_context->ran_info.ncl_params.inter_rat_ncl);

    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
        rrm_mem_get(sizeof(rrc_rrm_ho_required_t));

    if (RRM_PNULL == p_rrc_rrm_ho_required)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->target_id.bitmask = RRM_ZERO;

    p_rrc_rrm_ho_required->ue_index = p_rrm_ue_context->ue_index;

    /* To DAHO Cell */
    p_cdma2000_daho_hrpd_cell = rrm_ue_match_hrpd_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    if(RRM_PNULL != p_cdma2000_daho_hrpd_cell)
    {
        /* HO to HRPD */
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:start*/
        p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD;
        /*KPI:end*/
        fill_ho_required_daho_cdma2000_hrpd_info(p_rrm_ue_context, p_cdma2000_daho_hrpd_cell,
                p_rrc_rrm_ho_required);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Failed to send HO to HRPD DAHO Cell");
        /* COVERITY : RESOURCE LEAK : CID : 54414 fix start */
        if( RRM_NULL != p_rrc_rrm_ho_required )
            RRM_MEM_FREE(p_rrc_rrm_ho_required);
        /* COVERITY : RESOURCE LEAK : CID : 54414 fix end */
        return RRM_FAILURE;
    }

    p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
    p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_CDMA2000_INFO_PRESENT ;

    p_rrc_rrm_ho_required->cdma2000_information.bitmask = RRM_ZERO;

    report_index = p_rrm_ue_context->p_ue_mac_report->report_index;
    valid_report_index = (report_index % RRM_MAX_REPORT_STAT_UE);
    if(RRM_ZERO < valid_report_index)
    {

        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[valid_report_index - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }
    else if((RRM_ZERO == valid_report_index) && (RRM_ZERO < report_index))
    {
        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[RRM_MAX_REPORT_STAT_UE - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }

    ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_rrm_ue_context->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d]Failed to send HO REQUIRED",
                p_rrc_rrm_ho_required->ue_index);
    }
    else
    {
        /*SPR 18241 START*/
        RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_SRC_HO_ONGOING);
        /*SPR 18241 END*/
        UEM_FSM_SET_STATE( p_rrm_ue_context, RRM_UE_STATE_HO_ONGOING);
        p_rrm_ue_context->ho_params.ho_retry_count++;
        /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-START
          When an outgoing handover preparation UE task is requested*/
        rrm_raise_event_ho_out_prep_attempt(p_rrm_ue_context,
                p_rrc_rrm_ho_required); 
        /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-END*/
        /* Review_comment_for_SPR_7996_nd_8345_start */
        rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                                            p_rrm_ue_context);
        /* Review_comment_for_SPR_7996_nd_8345_end */
    }
    RRM_MEM_FREE(p_rrc_rrm_ho_required);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_1xrtt_daho_ho_required
 *   INPUT      : p_rrm_ue_context,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_1xrtt_daho_ho_required
(
 rrm_ue_context_t  *p_rrm_ue_context,
 U16                transaction_id)
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;

    U8 report_index = RRM_FALSE;
    U8 valid_report_index = RRM_ZERO;
    rrm_cell_context_t  *p_cell_context = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params = RRM_PNULL;
    inter_rat_ncl_t  *p_inter_rat_ncl = RRM_PNULL;

    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_1xrtt_cell = RRM_PNULL;

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);

    p_irat_cdma_params = &(p_cell_context->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    p_inter_rat_ncl = &(p_cell_context->ran_info.ncl_params.inter_rat_ncl);

    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
        rrm_mem_get(sizeof(rrc_rrm_ho_required_t));

    if (RRM_PNULL == p_rrc_rrm_ho_required)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->target_id.bitmask = RRM_ZERO;

    p_rrc_rrm_ho_required->ue_index = p_rrm_ue_context->ue_index;

    p_cdma2000_daho_1xrtt_cell = rrm_ue_match_1xrtt_daho_cell_from_ncl
        (p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    if(RRM_PNULL != p_cdma2000_daho_1xrtt_cell)
    {
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:start*/
        p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT;
        /*KPI:end*/

        fill_ho_required_daho_cdma2000_1xrtt_info(p_rrm_ue_context, p_cdma2000_daho_1xrtt_cell,
                p_rrc_rrm_ho_required);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Failed to send HO to 1XRTT DAHO Cell");
        /* COVERITY : RESOURCE LEAK : CID : 54408 fix start */    
        if( RRM_NULL != p_rrc_rrm_ho_required )
            RRM_MEM_FREE(p_rrc_rrm_ho_required);
        /* COVERITY : RESOURCE LEAK : CID : 54408 fix end */
        return RRM_FAILURE;
    }

    p_rrc_rrm_ho_required->cause.type =RADIO_NETWORK_LAYER_TYPE;
    p_rrc_rrm_ho_required->cause.value = CS_FALLBACK_TRIGGERED;

    p_rrc_rrm_ho_required->bitmask = RRM_ZERO;
    p_rrc_rrm_ho_required->bitmask |= RRC_RRM_CDMA2000_INFO_PRESENT ;

    p_rrc_rrm_ho_required->cdma2000_information.bitmask = RRM_ZERO;

    /* Fill Mobility Params */
    fill_mobility_params_cdma2000(p_rrm_ue_context,
            &(p_rrc_rrm_ho_required->cdma2000_information.mobility_parameters),
            &(p_rrc_rrm_ho_required->cdma2000_information.add_mobility_parameters));

    p_rrc_rrm_ho_required->cdma2000_information.bitmask |= 
        RRC_RRM_HO_REQUIRED_MOBILITY_PARAMETERS_PRESENT;

    p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
        RRC_RRM_HO_REQUIRED_ADDITIONAL_MOBILITY_PARAMETERS_PRESENT;


    report_index = p_rrm_ue_context->p_ue_mac_report->report_index;
    valid_report_index = (report_index % RRM_MAX_REPORT_STAT_UE);
    if(RRM_ZERO < valid_report_index)
    {

        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[valid_report_index - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }
    else if((RRM_ZERO == valid_report_index) && (RRM_ZERO < report_index))
    {
        /* Coverity 56722 fix */
        p_rrc_rrm_ho_required->cdma2000_information.
            eutran_round_trip_delay_estimation_info = p_rrm_ue_context->
            p_ue_mac_report->ue_stats[RRM_MAX_REPORT_STAT_UE - RRM_ONE].timingAdvanceValue;

        p_rrc_rrm_ho_required->cdma2000_information.bitmask |=
            RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT;
    }

    ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_rrm_ue_context->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d]Failed to send HO REQUIRED",
                p_rrc_rrm_ho_required->ue_index);
    }
    else
    {
        /*SPR 18241 START*/
        RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_SRC_HO_ONGOING);
        /*SPR 18241 END*/
        UEM_FSM_SET_STATE( p_rrm_ue_context, RRM_UE_STATE_HO_ONGOING);
        p_rrm_ue_context->ho_params.ho_retry_count++;
        /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-START
          When an outgoing handover preparation UE task is requested*/
        rrm_raise_event_ho_out_prep_attempt(p_rrm_ue_context,
                p_rrc_rrm_ho_required); 
        /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-END*/
        /* Review_comment_for_SPR_7996_nd_8345_start */
        rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                                            p_rrm_ue_context);
        /* Review_comment_for_SPR_7996_nd_8345_end */
    }
    RRM_MEM_FREE(p_rrc_rrm_ho_required);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR-604 Fix Starts*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_ho_required_for_intra_cell
 *
 *   DESCRIPTION:
 *       Fills the ho required message for intra-cell HO
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
    rrm_ue_fill_ho_required_for_intra_cell
(
 rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required,
 rrm_ue_context_t              *p_rrm_ue_context
 )
{
    rrm_return_et       ret_val = RRM_SUCCESS;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;
    U8                  ue_history_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found");
        return RRM_FAILURE;
    }

    if (RRM_PNULL != p_rrc_rrm_ho_required)
    {
        RRM_MEMSET(p_rrc_rrm_ho_required, RRM_ZERO, sizeof(rrc_rrm_ho_required_t));

        p_rrc_rrm_ho_required->ue_index = p_rrm_ue_context->ue_index;
        p_rrc_rrm_ho_required->ho_type = HANDOVER_TYPE_INTRA_CELL;
        p_rrc_rrm_ho_required->cause.type = RADIO_NETWORK_LAYER_TYPE;
        /* SPR_21520 - Fix Start */
        p_rrc_rrm_ho_required->cause.value = RRM_X2AP_UNSPECIFIED;
        /* SPR_21520 - Fix End */
        p_rrc_rrm_ho_required->mobility_control_info.t304_timer =
            p_cell_context->ran_info.rrc_timers_and_constants.rrc_timers.t304_eutra;
        p_rrc_rrm_ho_required->bitmask  |= RRC_RRM_UE_HO_ADM_REQ_MOBILITY_CONTROL_INFO_PRESENT;

        p_rrm_ue_context->ho_typ = RRM_HANDOVER_TYPE_INTRA_CELL;
        p_rrm_ue_context->ho_type =HANDOVER_TYPE_INTRA_CELL;

        /* Filling eNB-ID */
        RRM_MEMCPY(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.plmn_identity.mcc,
                p_cell_context->epc_info.epc_params.general_epc_params.plmn_list[0].plmn_id.mcc,
                MAX_MCC_DIGITS);

        p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.plmn_identity.mnc.count =
            p_cell_context->epc_info.epc_params.general_epc_params.plmn_list[0].plmn_id.num_mnc_digit;

        RRM_MEMCPY(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.plmn_identity.mnc.mnc,
                p_cell_context->epc_info.epc_params.general_epc_params.plmn_list[0].plmn_id.mnc,
                MAX_MNC_DIGITS);

        p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.plmn_identity.
            presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

        RRM_MEMCPY(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity,
                p_cell_context->ran_info.common_eutran_params.cell_identity,
                MAX_CELL_IDENTITY_OCTETS);

        p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.bitmask |=
            EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT;

        RRM_MEMCPY(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.ecgi,
                p_cell_context->ran_info.common_eutran_params.cell_identity,
                MAX_CELL_IDENTITY_OCTETS);

        p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_type = MACRO_ENB_ID;

        RRM_MEMCPY(&(p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.plmn_identity),
                &(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.plmn_identity),
                sizeof(plmn_identity_t));

        RRM_MEMCPY(p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.tracking_area_code,
                p_cell_context->epc_info.epc_params.general_epc_params.tac,
                MAX_TAC_SIZE);

        p_rrc_rrm_ho_required->target_id.bitmask |= RRM_TARGET_ID_ENB_ID_PRESENT;

        RRM_MEMCPY(&(p_rrm_ue_context->ho_params.target_cell_identity[0]),\
                &(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity),\
                MAX_CELL_IDENTITY_OCTETS);


        ue_history_count = p_rrm_ue_context->ue_history.last_visited_cell_list.count;

        if ((RRM_ZERO == ue_history_count) ||
                (RRM_SUCCESS != rrm_compare_global_cell_id(&(p_rrm_ue_context->ue_history.\
                                                             last_visited_cell_list.last_visited_cell_info[ue_history_count-1].\
                                                             last_visited_e_utran_cell_information.global_cell_id), &(p_cell_context->global_cell_id))))
        {
            uerrm_add_ue_history_e_utran_cell_information(p_rrm_ue_context);
        }


        if (RRM_SUCCESS == rrm_ue_fill_src_target_container(
                    &p_rrc_rrm_ho_required->source_to_target_container,
                    p_rrm_ue_context, (rrc_handover_type_et)(p_rrc_rrm_ho_required->ho_type)))
        {
            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_PRESENT;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failure in filling src target container");
        }


        p_rrc_rrm_ho_required->bitmask |= \
                                          RRC_RRM_UE_HO_ADM_REQ_DIRECT_FORWARD_PATH_AVAILABLE_PRESENT;
        p_rrc_rrm_ho_required->direct_fwd_path_available = RRM_FALSE;

        fill_dl_data_fwd_erab_list(p_rrm_ue_context,
                p_rrc_rrm_ho_required);

        if(RRM_OAM_ACCESS_MODE_HYBRID == p_cell_context->access_mgmt_params.access_mode)
        {
            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_REQ_CELL_ACCESS_MODE_PRESENT;
            p_rrc_rrm_ho_required->cell_access_mode = RRC_HYBRID;
            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_CSG_ID_PRESENT;
            RRM_MEMCPY(p_rrc_rrm_ho_required->csg_identity, p_cell_context->\
                    access_mgmt_params.csg_id,CSG_ID_OCTET_SIZE);
        }
        else if(RRM_OAM_ACCESS_MODE_CLOSE == p_cell_context->access_mgmt_params.access_mode)
        {
            p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_CSG_ID_PRESENT;
            RRM_MEMCPY(p_rrc_rrm_ho_required->csg_identity, p_cell_context->\
                    access_mgmt_params.csg_id, CSG_ID_OCTET_SIZE);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_rrc_rrm_ho_required is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR-604 Fix Ends*/
/*SPR-604 Fix Starts*/
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_intra_cell_ho_required
 *
 *   DESCRIPTION:
 *       Fills and sends ho required for intra-cell HO
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_intra_cell_ho_required(
        rrm_ue_context_t    *p_ue_context,
        U8 transaction_id
        )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
        rrm_mem_get(sizeof(rrc_rrm_ho_required_t));
    if (RRM_PNULL == p_rrc_rrm_ho_required)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    ret_val = rrm_ue_fill_ho_required_for_intra_cell(
            p_rrc_rrm_ho_required, p_ue_context);
    if (RRM_SUCCESS == ret_val)
    {
        /* Bug_12878_Start: Start */
        /* SPR 14486 Fix - Sending Scell Deact removed */
        /* Bug_12878_End: End */

        /* Bug 881 Fix Start */
        p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT;
        p_rrc_rrm_ho_required->ho_freq_type = HANDOVER_INTRA_FREQ;
        /* Bug 881 Fix Stop */

        ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
                RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "[UE:%d]Failed to send HO REQUIRED",
                    p_rrc_rrm_ho_required->ue_index);
        }
        else
        {
            /*SPR 18241 START*/
            RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_SRC_HO_ONGOING);
            /*SPR 18241 END*/

            UEM_FSM_SET_STATE( p_ue_context, RRM_UE_STATE_HO_ONGOING);
            /* SPR 15232 start */
            /* Remove code */
            /* SPR 15232 end */
            p_ue_context->ho_params.ho_retry_count++;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "Failed to fill the UE REQUIRED Message for the [UE:%d]",
                p_rrc_rrm_ho_required->ue_index);
    }
    RRM_MEM_FREE(p_rrc_rrm_ho_required);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR-604 Fix Ends*/

/* cyclo start */
/******************************************************************************
  *   FUNCTION NAME: rrm_process_ue_ho_required
  *   INPUT      : p_ue_context,
  *   OUTPUT     : none
  *   DESCRIPTION:
  *       Handels ue HO required
  *   RETURNS:
  *       RRM_SUCCESS  on Success
  *       RRM_FAILURE  on Failure
*******************************************************************************/
rrm_return_et
rrm_process_ue_ho_required(rrc_rrm_ho_required_t *p_rrc_rrm_ho_required,
                           rrm_ue_context_t *p_ue_context,
                           rrm_ue_lipa_release_et  *is_rab_ue_released,
                           U8 transaction_id,
                           /* SPR 19634 Fix Start */
                           phy_cell_id_info_t phy_cell_id_info)
                           /* SPR 19634 Fix End */
{

   rrm_return_et          ret_val = RRM_SUCCESS;
   RRM_UT_TRACE_ENTER();

   /* SPR 19634 Fix Start */
   /* Code Removed */
   if(UE_LIPA_RAB_RELEASE == *is_rab_ue_released)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "HO REQUIRED is queued, it shall be called once erb release cnf is received");
        rrm_ue_procedure_queue_t    proc_queue;
        proc_queue.api_id = RRC_RRM_HO_REQUIRED;
        proc_queue.p_proc_data = (rrc_rrm_ho_required_t *)p_rrc_rrm_ho_required;
        /*BUG 13332:start*/
        proc_queue.trans_id = transaction_id;
        /*BUG 13332:end*/

        /**Enqueue ERAB setup request */
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue, p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
        p_ue_context->lipa_ho_required.transaction_id = transaction_id;
        p_ue_context->current_procedure.state =
            RRM_UE_LIPA_SIPTO_HO_ONGOING;

    }
    else 
    {
        ret_val = rrm_il_send_rrc_rrm_ho_required(p_rrc_rrm_ho_required,
                RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "[UE:%d]Failed to send HO REQUIRED",
                    p_rrc_rrm_ho_required->ue_index);
        }
        else
        {
           /* SPR 16406 8SEP start */
           /*SPR 17943 START*/
           RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_SRC_HO_ONGOING);
           /*SPR 17943 END*/
           p_ue_context->ho_params.target_phys_cell_id = phy_cell_id_info.phy_cell_id;
           p_ue_context->ho_params.target_earfcn = phy_cell_id_info.carr_earfcn;
           p_ue_context->ho_params.last_ho_trigger_event = p_ue_context->meas_rep_event;
           p_ue_context->ue_ho_current_state =  RRM_HO_STATE_HO_TRIGGERED;
           UEM_FSM_SET_STATE( p_ue_context, RRM_UE_STATE_HO_ONGOING);
           /* SPR 16406 8SEP end */
                /* SPR 15232 start */
                /* Remove code */
                /* SPR 15232 end */
            p_ue_context->ho_params.ho_retry_count++;
            /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-START
              When an outgoing handover preparation UE task is requested*/
            rrm_raise_event_ho_out_prep_attempt(p_ue_context,
                    p_rrc_rrm_ho_required); 
            /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-END*/
            /* Review_comment_for_SPR_7996_nd_8345_start */
            rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                                                p_ue_context);
            /* Review_comment_for_SPR_7996_nd_8345_end */
           /* SPR 16406 8SEP start */
           rrm_clear_pending_anr_cgi(p_ue_context);
           /* SPR 16406 8SEP end */
        }
            /* SPR 15441 start */
            /* code removed */
            /* SPR 15441 end */
    }

   /* SPR 19634 Fix End */
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/* SPR 16406 3Aug Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_remove_rsc_and_cgi_pending_nodes 
 *   INPUT      : p_ue_context
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Remove ReportStrongestCell and CGI reports configured earlier in HO procedure
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_uem_remove_rsc_and_cgi_pending_nodes
(
    rrm_ue_context_t *p_ue_context
)
{
    RRM_UT_TRACE_ENTER();

    rrm_counter_t report_count = RRM_ZERO;
    rrm_counter_t meas_id = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    rrc_rrm_meas_config_req_t *p_rrc_rrm_meas_config_req = RRM_PNULL;
    rrm_ue_procedure_record_t *p_rrm_ue_procedure_record = RRM_PNULL;
    rrm_ue_meas_config_cgi_queue_node_t *p_cgi_node = RRM_PNULL;
    rrm_ue_procedure_record_t *p_next_node = RRM_PNULL;
    U16 transaction_id = rrm_generate_txn_id();

     p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t *)
        rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return ret_val;
    }
    for(meas_id = RRM_ZERO; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
    {
        if(RRM_MEAS_CONFIG_REQ_SENT == p_ue_context->p_meas_config[meas_id].meas_config_status)
        {
            /* RSC has been triggered, here we are removing all RSC configured */
            p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[report_count++] = 
                p_ue_context->p_meas_config[meas_id].report_id; 
            rrm_uem_reset_meas_config_struct(&p_ue_context->p_meas_config[meas_id]);
        } 
    }

    if(report_count)
    {
        p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count = report_count;
        p_rrc_rrm_meas_config_req->meas_config.bitmask = RRM_ZERO; 
        p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index; 
        p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT; 

	/* SPR 19838 : CID 10024 Fix Start */
        if((RRM_UE_MEAS_CONFIG_REQ_ONGOING  != p_ue_context->current_procedure.state)
                && (RRM_UE_REESTABLISH_PROCEDURE_ONGOING != p_ue_context->current_procedure.state))
	/* SPR 19838 : CID 10024 Fix End */
        {
            ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);

            if(ret_val == RRM_FAILURE)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send RSC remove list request for [UE:%d]",
                        p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Successfully sent RSC remove list request for [UE:%d]",
                        p_ue_context->ue_index);
                p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;/*RRM_MEAS Changes */
                RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_MEAS_CONFIG_REQ_ONGOING);
            }    
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Either MEAS_CONFIG_REQ or REESTABLISH_PROCEDURE_ONGOING"
                    " already ongoing for [UE:%d]",
                    p_ue_context->ue_index);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "No RSC was configured before HO procedure for [UE:%d]",
                p_ue_context->ue_index);
    }


    /* If any CGI req is present in the procedure queue, delete it */
    
    while (RRM_PNULL != p_ue_context->p_proc_queue_first_meas_node)
    {
        p_rrm_ue_procedure_record = p_ue_context->p_proc_queue_first_meas_node;
        p_next_node = (rrm_ue_procedure_record_t *)ylNext(&p_rrm_ue_procedure_record->s_node);
        if (RRC_RRM_MEAS_CONFIG_REQ == p_rrm_ue_procedure_record->proc_queue.api_id) 
        {
            p_cgi_node = (rrm_ue_meas_config_cgi_queue_node_t*)p_rrm_ue_procedure_record->proc_queue.p_proc_data;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Deleting queued procedure for CGI Req for ARFCN = %d"
                    " as corresponding meas object is being removed", p_cgi_node->arfcn);
            ylDelete(&p_ue_context->procedure_queue, &p_rrm_ue_procedure_record->s_node);
            RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
            RRM_MEM_FREE(p_rrm_ue_procedure_record);
        }
        p_ue_context->p_proc_queue_first_meas_node = p_next_node;
    }
    /* coverity_fix 88577 ++ */
    if(PNULL != p_rrc_rrm_meas_config_req)
    {
        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    }
    /* coverity_fix 88577 -- */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 16406 3Aug End */
/* cyclo end */
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ho_required
 *   INPUT      : p_ue_context,phy_cell_id,transaction_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required 
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_ho_required(
        /* SPR 15674 Start  */
        phy_cell_id_info_t phy_cell_id_info,
        /* SPR 15674 End  */
        rrm_ue_context_t    *p_ue_context,
        U8 transaction_id
        )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;
    rrm_ue_lipa_release_et  is_rab_ue_released = UE_LIPA_RELEASE_NONE;

    RRM_UT_TRACE_ENTER();

    /* SPR 16406 8SEP start */
	/*SPR_17893_START*/
    if ((RRM_UE_STATE_ACTIVE == p_ue_context->ue_state)||
        (RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES == p_ue_context->ue_state))
    {
	/*SPR_17893_END*/
        /* SPR 16406 8SEP end */
        if(RRM_FAILURE == rrm_ue_handle_lipa_bearer_release(p_ue_context, &is_rab_ue_released))
        {
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        else
        {
            if(UE_LIPA_UE_RELEASE == is_rab_ue_released)
            {
                RRM_UT_TRACE_EXIT();
                return RRM_SUCCESS;
            }
        }

        p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)
            rrm_mem_get(sizeof(rrc_rrm_ho_required_t));
        if (RRM_PNULL == p_rrc_rrm_ho_required)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
            return RRM_FAILURE;
        }

        /* Inter RAT changes start */
        /* SPR 15674 Start  */
        if (RRM_FAILURE != (ret_val = rrm_ue_fill_ho_required(phy_cell_id_info,\
                        p_rrc_rrm_ho_required,p_ue_context)))
            /* SPR 15674 End  */
            /* Inter RAT changes end */
        {
            /* Carrier aggregation start*/    
            /* SPR 14486 Fix- Sending Scell Deact removed */
/* SPR 19634 Fix Start */
            ret_val = rrm_process_ue_ho_required(p_rrc_rrm_ho_required,p_ue_context,&is_rab_ue_released,transaction_id,phy_cell_id_info);
/* SPR 19634 Fix End */
            /* cyclo changes end*/ 
            /*BUG 585, MULTISECTOR_CHANGE_START*/
            /*BUG 585, MULTISECTOR_CHANGE_END*/

            /* SPR 19634 Fix Start */
              /* Code Removed */
            /* SPR 19634 Fix End */
        }   
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Failed to fill the UE REQUIRED Message for the [UE:%d]",
                    p_rrc_rrm_ho_required->ue_index);
        }
        /* SPR 15441 start */
        RRM_MEM_FREE(p_rrc_rrm_ho_required);
        /* SPR 15441 end */
        /* SPR 16406 8SEP start */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
               "Cannot send Handover Required as [UE:%d] is in state [%d]"      ,
                p_ue_context->ue_index, p_ue_context->ue_state);
    }
    /* SPR 16406 8SEP end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_lipa_ho_required
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends ho required 
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_lipa_ho_required(
         rrm_ue_context_t  *p_ue_context
         )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrc_rrm_ho_required_t  *p_rrc_rrm_ho_required = RRM_PNULL;
    U8                      transaction_id = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_required = (rrc_rrm_ho_required_t *)(p_ue_context->current_procedure.p_proc_data);
    transaction_id = p_ue_context->lipa_ho_required.transaction_id;

    ret_val = rrm_il_send_rrc_rrm_ho_required(
            p_rrc_rrm_ho_required,
            RRM_MODULE_ID,
            RRC_MODULE_ID,
            transaction_id,p_ue_context->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d]Failed to send HO REQUIRED",
                p_rrc_rrm_ho_required->ue_index);
    }
    else
    {
        /* SPR 15232 start */
        /* Remove code */
        /* SPR 15232 end */
        p_ue_context->ho_params.ho_retry_count++;
        /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-START
         *                          When an outgoing handover preparation UE task is requested*/
        rrm_raise_event_ho_out_prep_attempt(p_ue_context,
                p_rrc_rrm_ho_required);
        /*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_ATTEMPT-END*/
        /* Review_comment_for_SPR_7996_nd_8345_start */
        rrm_increment_num_of_enb_init_ho_csg_and_non_csg_usr(
                p_ue_context);
        /* Review_comment_for_SPR_7996_nd_8345_end */
    }
    /* SPR 15441 start */ 
    /* code removed */
    /* SPR 15441 end */ 
    /* SPR 15441 start */
    RRM_MEM_FREE(p_rrc_rrm_ho_required);
    /* SPR 15441 end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*MC, MR & HO  END */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_context_mod_resp
 *   INPUT      : p_rrm_ue_context,response
 *   OUTPUT     : p_rrc_rrm_ue_contxt_mod_resp
 *   DESCRIPTION:
 *       Fills and sends context modification response
 *
 *  RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_fill_context_mod_resp(
        rrm_ue_context_t *p_rrm_ue_context,
        rrc_rrm_ue_contxt_mod_resp_t    *p_rrc_rrm_ue_contxt_mod_resp,
        rrm_ue_response_et response)
{
    RRM_UT_TRACE_ENTER();
    do
    {
        RRM_MEMSET(p_rrc_rrm_ue_contxt_mod_resp, RRM_ZERO,(sizeof(rrc_rrm_ue_contxt_mod_resp_t)));
        p_rrc_rrm_ue_contxt_mod_resp->bitmask = RRM_ZERO;
        p_rrc_rrm_ue_contxt_mod_resp->ue_index = p_rrm_ue_context->ue_index;
        p_rrc_rrm_ue_contxt_mod_resp->response = response;
    } while(RRM_ZERO);

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_context_mod_resp
 *   INPUT      : p_rrm_ue_cntxt,transaction_id
 *   OUTPUT     : response
 *   DESCRIPTION:
 *       Fills and sends context modification response
 *
 *  RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_context_mod_resp(
        rrm_ue_response_et response,
        rrm_ue_context_t *p_rrm_ue_cntxt,
        U16              transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_contxt_mod_resp_t    rrc_rrm_ue_contxt_mod_resp;

    RRM_UT_TRACE_ENTER();


    rrm_ue_fill_context_mod_resp(p_rrm_ue_cntxt,
            &rrc_rrm_ue_contxt_mod_resp, response);



    ret_val = rrm_il_send_rrc_rrm_ue_contxt_mod_resp
             (&rrc_rrm_ue_contxt_mod_resp,
               RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_rrm_ue_cntxt->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d], Failed to send Context"
                   "MODIFICATION RESPONSE" ,p_rrm_ue_cntxt->ue_index);
    }
    else
    {
        /* CSR 58774 Fix Start */
        RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"[UE:%d],Successfully sent "
                   "CONTEXT MODIFICATION RESPONSE" ,p_rrm_ue_cntxt->ue_index);
        /* CSR 58774 Fix End */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME: build_and_send_ue_info_req_to_rrc
 *   INPUT      : p_rrm_ue_cntxt
 *   DESCRIPTION:
 *       Fills and sends erb modify response
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
build_and_send_ue_info_req_to_rrc(
        rrm_ue_context_t *p_rrm_ue_cntxt,
        prach_cause_et               cause
        )
{

    rrc_rrm_ue_information_req_t *p_rrc_rrm_ue_information_req = RRM_PNULL;
    rrm_return_et                 ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_ue_information_req = (rrc_rrm_ue_information_req_t *)\
                                   rrm_mem_get(sizeof(rrc_rrm_ue_information_req_t));

    if (RRM_PNULL != p_rrc_rrm_ue_information_req) /* Coverity : CID 41042 */
    {

	p_rrc_rrm_ue_information_req->bitmask = RRM_ONE;
        p_rrc_rrm_ue_information_req->ue_Index = p_rrm_ue_cntxt->ue_index;
        p_rrc_rrm_ue_information_req->rach_report_req = RRM_TRUE;
        p_rrc_rrm_ue_information_req->rlf_report_req = RRM_FALSE;

        /*After sending UE_INFO_REQ setting the flag if ue_info_res
          is requested and setting the cause*/
        p_rrm_ue_cntxt->temp_rach_data.is_ue_report_requested = RRM_TRUE;
        p_rrm_ue_cntxt->temp_rach_data.cause = cause;

        ret_val = rrm_il_send_rrc_rrm_ue_information_req 
            (p_rrc_rrm_ue_information_req,
             RRM_MODULE_ID,RRC_MODULE_ID,RRM_ZERO,p_rrm_ue_cntxt->cell_index);
        if(ret_val == RRM_FAILURE)
        { 
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "[UE:%d], Failed to send UE INFORMATION REQUEST" ,
                    p_rrm_ue_cntxt->ue_index);

            p_rrm_ue_cntxt->temp_rach_data.is_ue_report_requested = RRM_FALSE;
        }
        else
        {
            RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "[UE:%d], Successfully sent "
                    "UE INFORMATION REQUEST" ,p_rrm_ue_cntxt->ue_index);
        }
        RRM_MEM_FREE(p_rrc_rrm_ue_information_req);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Failed to Allocate Memory for UE_INFO_REQ");
        ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_erb_modify_resp
 *   INPUT      : p_rrm_ue_cntxt,transaction_id
 *   OUTPUT     : response 
 *   DESCRIPTION:
 *       Fills and sends erb modify response
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_erb_modify_resp(
        rrm_ue_response_et response,
        rrm_ue_context_t *p_rrm_ue_cntxt,
        U16              transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_erab_modify_resp_t      *p_rrc_rrm_erab_modify_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_erab_modify_resp  = (rrc_rrm_erab_modify_resp_t *)\
                                   rrm_mem_get(sizeof(rrc_rrm_erab_modify_resp_t));
    if (RRM_PNULL == p_rrc_rrm_erab_modify_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory "
                "for RRC_RRM_ERAB_MODIFY_RESP");
        return RRM_FAILURE;
    }


    rrm_ue_rbc_fill_erb_modify_resp(p_rrm_ue_cntxt,
            p_rrc_rrm_erab_modify_resp,response
            );	



    /* Raise Event - RRM_EVENT_LOCAL_ERAB_MODIFY_READY START */
    rrm_raise_event_erab_modify_ready(p_rrm_ue_cntxt);
    /* Raise Event - RRM_EVENT_LOCAL_ERAB_MODIFY_READY END */

    ret_val = rrm_il_send_rrc_rrm_erab_modify_resp
            (p_rrc_rrm_erab_modify_resp,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_rrm_ue_cntxt->cell_index);
    if(ret_val == RRM_FAILURE)
    { 
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d], Failed to send ERB "
                   "MODIFY RESPONSE" ,p_rrm_ue_cntxt->ue_index);
    }
    else
    {
        RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"[UE:%d], Successfully sent "
                   "ERB MODIFY RESPONSE" ,p_rrm_ue_cntxt->ue_index);
        /*SPR 18241 START*/
        if(response != RRM_UE_FAILURE)
        {    
            RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_cntxt->current_procedure, RRM_UE_ERB_MODIFY_ONGOING);
        }
        /*SPR 18241 END*/
    }


    RRM_MEM_FREE(p_rrc_rrm_erab_modify_resp);
    RRM_UT_TRACE_EXIT();
    
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_erb_release_resp
 *   INPUT      : p_rrm_ue_cntxt,transaction_id
 *   OUTPUT     : response 
 *   DESCRIPTION:
 *       Fills and sends erb release response
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_erb_release_resp(
        rrm_ue_response_et response,
        rrm_ue_context_t *p_rrm_ue_cntxt,
        U16              transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_erb_release_resp_t      rrc_rrm_erb_release_resp ={RRM_ZERO};
    rrm_cell_context_t              *p_cell_ctxt= RRM_PNULL; 

    RRM_UT_TRACE_ENTER();
    rrm_ue_rbc_fill_erb_release_resp(p_rrm_ue_cntxt,
            &rrc_rrm_erb_release_resp,response);
    /*KPI:start erb release success and fail */
    /*update cell context*/
    p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_cntxt->cell_index);
    /*CID 65768:start*/
    if (RRM_PNULL != p_cell_ctxt)
    {
        p_cell_ctxt->kpi_stat.kpi.num_of_erb_release_success += 
            rrc_rrm_erb_release_resp.drb_release_item_list.num_of_list;
        p_cell_ctxt->kpi_stat.kpi.num_of_erb_release_fail += 
            rrc_rrm_erb_release_resp.drb_failed_to_release_item_list.num_of_list;
    }
    /*CID 65768:end*/
    /*KPI:end*/


    /* Raise Event - RRM_EVENT_LOCAL_ERAB_RELEASE_READY START */
    rrm_raise_event_erab_release_ready(p_rrm_ue_cntxt);
    /* Raise Event - RRM_EVENT_LOCAL_ERAB_RELEASE_READY END */

    ret_val = rrm_il_send_rrc_rrm_erb_release_resp(&rrc_rrm_erb_release_resp,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_rrm_ue_cntxt->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d], Failed to send ERB "
                   "RELEASE RESPONSE" ,p_rrm_ue_cntxt->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"[UE:%d], Successfully sent ERB "
                   "RELEASE RESPONSE" ,p_rrm_ue_cntxt->ue_index);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_release_resp
 *   INPUT      : p_cell_index,p_ue_index,transaction_id 
 *   OUTPUT     : response
 *   DESCRIPTION:
 *       Fills and sends UE release response
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
rrm_build_and_send_ue_release_resp(
        rrm_cell_index_t    cell_index,
        rrm_ue_index_t      ue_index,
        rrm_ue_response_et  response,
        U16                 transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_release_resp_t       rrc_rrm_ue_release_resp;

    RRM_UT_TRACE_ENTER();

    rrm_ue_rbc_fill_ue_release_resp(ue_index,/*SPR 17777 +-*/
            &rrc_rrm_ue_release_resp,response);



    ret_val = rrm_il_send_rrc_rrm_ue_release_resp(&rrc_rrm_ue_release_resp,
            RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d], Failed to send UE RELEASE "
                   "RESPONSE" ,ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"[UE:%d], Successfully sent UE RELEASE "
                   "RESPONSE" ,ue_index);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* cyclo start */
/****************************************************************************
 * Function Name  : rrm_fill_redirection_info_for_csfb
 * Input          : p_ue_context,feature_group_indicators_utran,
 *                  p_ue_connection_release_ind
 * Outputs        : None
 * Description    : Fill redirected carrier frequency corresponding
 *                  to Cell based on measuremnt report for utran
 *Returns         : none
 ****************************************************************************/
rrm_void_t
rrm_fill_redirection_info_for_csfb_utra_cell(rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
                                             inter_rat_ncl_t   *p_irat_ncl,rrm_ue_context_t *p_ue_context,
                                             rrm_bool_et       feature_group_indicators_utran)

{
     U16                     count = RRM_ZERO;
     rrm_meas_config_info_t  *p_rrm_meas_config_info = RRM_NULL;
/*CA HARDENING CHANGES START*/
    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /*CA HARDENING CHANGES END*/
     RRM_UT_TRACE_ENTER(); 
     p_rrm_meas_config_info = rrm_cellm_get_meas_config_info(p_ue_context->cell_index);
     /* SPR 13734 Fix Start */
     if(INVALID_PHYSICAL_CELL_ID == p_ue_context->ho_params.target_phys_cell_id)
     {
                    /* SPR 16406 Start */
                    /* SPR 15406 Changes Starts */
                    p_ue_context->ho_params.target_phys_cell_id =  p_ue_context->ho_params.
                        utra_known_cell_selection_list.reported_neighbor_cell_info[RRM_ZERO].phy_cell_id ;
                    /* SPR 15674 Start */
                    p_ue_context->ho_params.target_earfcn =  p_ue_context->ho_params.
                        utra_known_cell_selection_list.reported_neighbor_cell_info[RRM_ZERO].target_earfcn ;
                    /* SPR 15406 Changes Ends */
                    /* SPR 16406 End */
         RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_DETAILED,
                 "target_phys_cell_id = %d , target_earfcn = %d", 
                 p_ue_context->ho_params.target_phys_cell_id, p_ue_context->ho_params.target_earfcn);
         /* SPR 15674 End */
     }
     /* SPR 13734 Fix End */

 
                  if((p_rrm_meas_config_info->csfb_tgt_selection.bitmask &\
         RRMCM_RMIF_UTRAN_CSFB_TGT_SELECTION_PRESENT)
         &&
         (RRM_CSFB_TGT_SELECT_MAHO ==\
          p_rrm_meas_config_info->csfb_tgt_selection.utran_csfb_tgt_selection)
         &&
                          (INVALID_PHYSICAL_CELL_ID != p_ue_context->ho_params.target_phys_cell_id))
                  {
                      for(count = RRM_ZERO;count < p_irat_ncl->num_valid_utran_freq_cell;count++)
                      {
                        /* SPR 15674 Start */
                        /* SPR 21761 Start */
                          if((p_ue_context->ho_params.target_earfcn == p_irat_ncl->utran_freq_cells[count].uarfcndl) &&
                                  feature_group_indicators_utran)
                        /* SPR 21761 End */
                            /* SPR 15674 End */

                          {

                              RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_DETAILED,
                                      "Filling redirected carrier info for UTRAN cell with PSC [%u]",
                                      p_ue_context->ho_params.target_phys_cell_id);
                              /*CID 65842:start*/
                              if (RRM_PNULL != p_cell_context)
                              {
                                  /* SPR 10497 Fix Start */
                                  if(FREQ_NOT_CONFIGURED != rrmcm_search_uarfcn_fdd_in_cell_context(p_cell_context,
                                              p_irat_ncl->utran_freq_cells[count].uarfcndl))
                                  {
                                      p_ue_connection_release_ind->bitmask |= RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
                                      p_ue_connection_release_ind->redirected_carrier_info.bitmask |= RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT;
                                      p_ue_connection_release_ind->redirected_carrier_info.utra_fdd = p_irat_ncl->utran_freq_cells[count].uarfcndl;
                                  }
                                  else if((RRM_MAX_PCI_UTRAN_TDD > p_ue_context->ho_params.target_phys_cell_id) &&
                                          (FREQ_NOT_CONFIGURED != rrmcm_search_uarfcn_tdd_in_cell_context(p_cell_context,
                                                                                                          p_irat_ncl->utran_freq_cells[count].uarfcndl)))
                                  {
                                      p_ue_connection_release_ind->bitmask |= RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
                                      p_ue_connection_release_ind->redirected_carrier_info.bitmask |= RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT;
                                      p_ue_connection_release_ind->redirected_carrier_info.utra_tdd = p_irat_ncl->utran_freq_cells[count].uarfcndl;
                                  }
                                  else
                                  {
                                      RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                              "UARFCN = %d Not configured", p_irat_ncl->utran_freq_cells[count].uarfcndl);
                                  }
                              }
                              else
                              {
                                  RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
                              }
                              /*CID 65842:end*/
                              break;
                              /* SPR 10497 Fix End */
                          }
                      }

                  }
    RRM_UT_TRACE_EXIT();
}
/* cyclo start */
/****************************************************************************
 * Function Name  : rrm_fill_redirection_info_for_csfb_greran_cell
 * Input          : p_ue_context,feature_group_indicators_geran,
 *                  p_ue_connection_release_ind
 * Outputs        : None
 * Description    : Fill redirected carrier frequency corresponding
 *                  to Cell based on measuremnt report for geran  
 *Returns         : none
 ****************************************************************************/
rrm_void_t
rrm_fill_redirection_info_for_csfb_geran_cell(rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
                                             inter_rat_ncl_t   *p_irat_ncl,rrm_ue_context_t *p_ue_context,
                                             rrm_bool_et       feature_group_indicators_geran)

{
    U16                     count = RRM_ZERO;
    rrm_meas_config_info_t  *p_rrm_meas_config_info = RRM_NULL;

    /*SPR 21761 +-*/
    RRM_UT_TRACE_ENTER();
    p_rrm_meas_config_info = rrm_cellm_get_meas_config_info(p_ue_context->cell_index);

    /*SPR 21761 Start*/
    if(INVALID_PHYSICAL_CELL_ID == p_ue_context->ho_params.target_phys_cell_id)
    {
        p_ue_context->ho_params.target_phys_cell_id =  p_ue_context->ho_params.
            geran_known_cell_selection_list.reported_neighbor_cell_info[RRM_ZERO].phy_cell_id ;
        p_ue_context->ho_params.target_earfcn =  p_ue_context->ho_params.
            geran_known_cell_selection_list.reported_neighbor_cell_info[RRM_ZERO].target_earfcn ;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_DETAILED,
                "target_phys_cell_id = %d , target_earfcn = %d", 
                p_ue_context->ho_params.target_phys_cell_id, p_ue_context->ho_params.target_earfcn);
    }

    if((p_rrm_meas_config_info->csfb_tgt_selection.bitmask & RRMCM_RMIF_GERAN_CSFB_TGT_SELECTION_PRESENT) &&
            (RRM_CSFB_TGT_SELECT_MAHO == p_rrm_meas_config_info->csfb_tgt_selection.geran_csfb_tgt_selection)&&
            /* SPR_14067_Fix_Start */
            (INVALID_PHYSICAL_CELL_ID != p_ue_context->ho_params.target_phys_cell_id))  
            /*SPR 21761 End*/
            /* SPR_14067_Fix_End */
    {
        /* SPR 15674 End */
        for(count = RRM_ZERO;count < p_irat_ncl->num_valid_geran_cell;count++)
        {
            /* SPR 15674 Start */
            if((p_ue_context->ho_params.target_earfcn ==p_irat_ncl->geran_freq_cells[count].bcch_arfcn)&&
                    feature_group_indicators_geran)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_DETAILED,
                        "redirected carrier info:Earfcn [%d]",
                        p_ue_context->ho_params.target_earfcn);
                /* SPR 15674 End */

                p_ue_connection_release_ind->bitmask |=
                    RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
                p_ue_connection_release_ind->redirected_carrier_info.bitmask |=
                    RRM_REDIRECTED_CARRIER_INFO_GERAN_PRESENT;
                p_ue_connection_release_ind->redirected_carrier_info.geran.starting_arfcn =
                    p_irat_ncl->geran_freq_cells[count].bcch_arfcn;
                if(RRM_SON_GERAN_DCS_1800 == p_irat_ncl->geran_freq_cells[count].band_indicator)
                {
                    p_ue_connection_release_ind->redirected_carrier_info.geran.band_indicator=\
                                                                                              RRM_RRC_DCS1800;
                }
                else
                {
                    p_ue_connection_release_ind->redirected_carrier_info.geran.band_indicator=\
                                                                                              RRM_RRC_PCS1900;
                }
                /*Filling Geran following arfcn from idle mode param*/
                p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.\
                    presence_bitmask |=GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;
                p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.\
                    explicit_list_of_arfcns.count =RRM_ONE;
                p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.\
                    explicit_list_of_arfcns.data[RRM_ZERO] = p_irat_ncl->geran_freq_cells[count].bcch_arfcn;
                break;

            }
        }
    }
    RRM_UT_TRACE_EXIT();  
}
/* cyclo end */
/****************************************************************************
 * Function Name  : rrm_fill_redirection_info_for_csfb
 * Input          : p_ue_context,feature_group_indicators_utran,
 *                  p_ue_connection_release_ind,feature_group_indicators_geran
 * Outputs        : None
 * Description    : Fill redirected carrier frequency corresponding
 *                  to Cell based on measuremnt report 
 *Returns         : none
 ****************************************************************************/
rrm_void_t  rrm_fill_redirection_info_for_csfb(
     rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
     rrm_ue_context_t *p_ue_context,
     rrm_bool_et         feature_group_indicators_utran,
     rrm_bool_et         feature_group_indicators_geran)
{
    inter_rat_ncl_t         *p_irat_ncl   = RRM_PNULL;
  
    RRM_UT_TRACE_ENTER(); 
 
    p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);
    if(RRM_PNULL == p_irat_ncl)
    {
          RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_ERROR,
                      "NCl list is not available csfb not possible");
          return;
    }
    switch(p_ue_context->target_cell_type)
     {
          case UTRA_CELL:
              {
                  rrm_fill_redirection_info_for_csfb_utra_cell(p_ue_connection_release_ind,p_irat_ncl,
                                                               p_ue_context,feature_group_indicators_utran);
                  break;
              }
          case GERAN_CELL:
              {
                  rrm_fill_redirection_info_for_csfb_geran_cell(p_ue_connection_release_ind,p_irat_ncl,
                                                              p_ue_context,feature_group_indicators_geran); 
                  break;
              }
          default:
              {
                  RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_ERROR,
                          "Invalid tye of RAT recived [%u]", p_ue_context->target_cell_type);

                  break;
              }
     }/*end of switch*/
    RRM_UT_TRACE_EXIT();
}

/*CR 713 changes*/
/****************************************************************************
 * Function Name  : fill_rim_info_r10
 * Input          : Pointer p_ue_connection_release_ind: outgoing message
 *                : pointer p_utran_freq_cells: to fill outgoing message
 * Outputs        : None
 * Returns        : None
 * Description    : Fill encoded si info for utran in connection release indication
 ****************************************************************************/
rrm_void_t fill_rim_info_r10 (
        rrc_rrm_ue_connection_release_ind_t *p_ue_connection_release_ind,
        utran_freq_cells_t     *p_utran_freq_cells,
        U8        r10_cell_count)
{
    RRM_UT_TRACE_ENTER();

    p_ue_connection_release_ind->bitmask |=
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V890_IES_PRESENT;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.bitmask |=
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V920_IES_PRESENT;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.bitmask |=
        RRC_RRM_CELL_INFO_LIST_UTRA_TDD_R10_PRESENT;

    /*Statment is done to reuse the function in case of csfb is false*/
    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_tdd_r10.cell_info_utra_tdd_r10[r10_cell_count].phys_cell_id_r10 =
        p_utran_freq_cells->pcpich_scrambling_code;
    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_tdd_r10.cell_info_utra_tdd_r10[r10_cell_count].carrier_freq_r10 = p_utran_freq_cells->uarfcndl;

    if(RRM_PNULL != p_utran_freq_cells->rim_utran_info)
    {
            p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
            cell_info_list_r9.utra_tdd_r10.cell_info_utra_tdd_r10[r10_cell_count].utra_BCCH_Container_r10.utra_bcch_container_length=
            p_utran_freq_cells->rim_utran_info->utran_si_len;

        RRM_MEMCPY(&(p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
                    cell_info_list_r9.utra_tdd_r10.cell_info_utra_tdd_r10[r10_cell_count].utra_BCCH_Container_r10.utra_bcch_container),
                p_utran_freq_cells->rim_utran_info->utran_si,
                p_utran_freq_cells->rim_utran_info->utran_si_len);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                RRM_ERROR,"rim_utran_info is NULL");
    }

    RRM_UT_TRACE_EXIT();
}
/*CR 713 changes*/

/****************************************************************************
 * Function Name  : fill_rim_info 
 * Input          : Pointer p_ue_connection_release_ind: outgoing message
 *                : pointer p_utran_freq_cells: to fill outgoing message
 * Outputs        : None
 * Returns        : None
 * Description    : Fill encoded si info for utran in connection release indication
 ****************************************************************************/
rrm_void_t fill_rim_info (
    rrc_rrm_ue_connection_release_ind_t *p_ue_connection_release_ind,
    utran_freq_cells_t     *p_utran_freq_cells)
{
    U8        r9_cell_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /* SPR 10497 Fix Start */
    if(RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT &
         p_ue_connection_release_ind->redirected_carrier_info.bitmask)
    {
    /* SPR 10497 Fix End*/
    p_ue_connection_release_ind->bitmask |= 
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V890_IES_PRESENT;
    
    p_ue_connection_release_ind->rrc_connection_release_v890_ies.bitmask |= 
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V920_IES_PRESENT;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.bitmask |=
        RRC_RRM_CELL_INFO_LIST_R9_PRESENT;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.cell_info_list_r9.bitmask |=
                RRC_RRM_CELL_INFO_LIST_UTRA_TDD_R9_PRESENT;
   /*Statment is done to reuse the function in case of csfb is false*/
   r9_cell_count = p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_tdd_r9.count;
    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
            cell_info_list_r9.utra_tdd_r9.cell_info_utra_tdd_r9[r9_cell_count].phys_cell_id_r9 =
            p_utran_freq_cells->pcpich_scrambling_code;
        
        p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
            cell_info_list_r9.utra_tdd_r9.cell_info_utra_tdd_r9[r9_cell_count].bitmask |= RRC_RRM_UTRA_TDD_BCCH_CONTAINER_ENCODED_SI_PRESENT;

    if(RRM_PNULL != p_utran_freq_cells->rim_utran_info)
    {
        p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
            cell_info_list_r9.utra_tdd_r9.cell_info_utra_tdd_r9[r9_cell_count].utra_tdd_bcch_cont_r9_encoded_si_info.utra_bcch_container_length=
            p_utran_freq_cells->rim_utran_info->utran_si_len;

        RRM_MEMCPY(&(p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
                    cell_info_list_r9.utra_tdd_r9.cell_info_utra_tdd_r9[r9_cell_count].utra_tdd_bcch_cont_r9_encoded_si_info.utra_bcch_container),
                p_utran_freq_cells->rim_utran_info->utran_si,
                p_utran_freq_cells->rim_utran_info->utran_si_len);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                    RRM_ERROR,"rim_utran_info is NULL");
    }
   r9_cell_count++;
   p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_tdd_r9.count = r9_cell_count;
    /* SPR 10497 Fix Start */
    } 
    else if(RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT &
         p_ue_connection_release_ind->redirected_carrier_info.bitmask)
    {
    /* SPR 10497 Fix End*/
    p_ue_connection_release_ind->bitmask |= 
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V890_IES_PRESENT;
    p_ue_connection_release_ind->rrc_connection_release_v890_ies.bitmask |= 
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V920_IES_PRESENT;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.bitmask |=  
        RRC_RRM_CELL_INFO_LIST_R9_PRESENT;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.cell_info_list_r9.bitmask |=
        RRC_RRM_CELL_INFO_LIST_UTRA_FDD_R9_PRESENT;

   /*Statment is done to reuse the function in case of csfb is false*/
   r9_cell_count = p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_fdd_r9.count;
    
    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_fdd_r9.cell_info_utra_fdd_r9[r9_cell_count].phys_cell_id_r9 =
        p_utran_freq_cells->pcpich_scrambling_code;

    p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_fdd_r9.cell_info_utra_fdd_r9[r9_cell_count].bitmask |=
        RRC_RRM_UTRA_FDD_BCCH_CONTAINER_ENCODED_SI_PRESENT;

    if(RRM_PNULL != p_utran_freq_cells->rim_utran_info)
    {
        p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
            cell_info_list_r9.utra_fdd_r9.cell_info_utra_fdd_r9[r9_cell_count].utra_fdd_bcch_cont_r9_encoded_si_info.utra_bcch_container_length=
            p_utran_freq_cells->rim_utran_info->utran_si_len;

        RRM_MEMCPY(&(p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
                    cell_info_list_r9.utra_fdd_r9.cell_info_utra_fdd_r9[r9_cell_count].utra_fdd_bcch_cont_r9_encoded_si_info.utra_bcch_container),
                    p_utran_freq_cells->rim_utran_info->utran_si,
                    p_utran_freq_cells->rim_utran_info->utran_si_len);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                    RRM_ERROR,"rim_utran_info is NULL");
    }

   r9_cell_count++;
   p_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
        cell_info_list_r9.utra_fdd_r9.count = r9_cell_count;

    /* SPR 10497 Fix Start */
    } 

    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "UTRAN redirected carrier freq info Absent");
    }
    /* SPR 10497 Fix End*/
    RRM_UT_TRACE_EXIT();
}
/* cyclo start */
/****************************************************************************
 * Function Name  : rrm_uem_get_redirected_geran_carrier_frequency
 * Inputs         : U16 spid
 * Outputs        : None
 * Description    : to get redirected carrier frequency corresponding
 *                  to SPID
 * Returns        : none
 ****************************************************************************/
rrm_void_t
rrm_uem_get_redirected_geran_carrier_frequency(
        rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
        rrm_ue_context_t *p_ue_context)
{

    U16                     count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

            if(p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.count)
            {
                p_ue_connection_release_ind->bitmask |= RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
                p_ue_connection_release_ind->redirected_carrier_info.bitmask |= RRM_REDIRECTED_CARRIER_INFO_GERAN_PRESENT;
                p_ue_connection_release_ind->redirected_carrier_info.geran.starting_arfcn = 
                    p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.
                    freqs_priority_geran[RRM_ZERO].carrier_freq.starting_arfcn;                        

                p_ue_connection_release_ind->redirected_carrier_info.geran.band_indicator= 
                    p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.
                    freqs_priority_geran[RRM_ZERO].carrier_freq.band_indicator;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "[UE:%d] geran arfcn[%d] band[%s]",p_ue_context->ue_index,
                        p_ue_connection_release_ind->redirected_carrier_info.geran.starting_arfcn,
                        (p_ue_connection_release_ind->redirected_carrier_info.geran.band_indicator?"RRM_RRC_PCS1900":"RRM_RRC_DCS1800"));
                if(p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].
                        carrier_freq.following_arfcns.presence_bitmask & GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG)
                {
                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.\
                        presence_bitmask |= GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.\
                        explicit_list_of_arfcns.count =
                        p_ue_connection_release_ind->idle_mode_mobility_control.\
                        freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                        following_arfcns.explicit_list_of_arfcns.count;
                    for(count = RRM_ZERO; count < 
                            p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.
                            explicit_list_of_arfcns.count;count++)
                    {
                        p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.
                            explicit_list_of_arfcns.data[count] = 
                            p_ue_connection_release_ind->idle_mode_mobility_control.\
                            freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                            following_arfcns.explicit_list_of_arfcns.data[count];
                    }
                }
                if(p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                        following_arfcns.presence_bitmask & GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG)
                {
                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.presence_bitmask |=
                        GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;
                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.equally_spaced_arfcns.arfcn_spacing =
                        p_ue_connection_release_ind->idle_mode_mobility_control.
                        freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                        following_arfcns.equally_spaced_arfcns.arfcn_spacing;
                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.equally_spaced_arfcns.num_of_following_arfcns = 
                        p_ue_connection_release_ind->idle_mode_mobility_control.\
                        freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                        following_arfcns.equally_spaced_arfcns.num_of_following_arfcns;
                }
                if(p_ue_connection_release_ind->idle_mode_mobility_control.
                        freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                        following_arfcns.presence_bitmask & GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG)
                {
                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.presence_bitmask |=
                        GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;
                    p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.var_bitmap_of_arfcns.count =
                        p_ue_connection_release_ind->idle_mode_mobility_control.\
                        freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                        following_arfcns.var_bitmap_of_arfcns.count;
                    for(count = RRM_ZERO; count < 
                            p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.var_bitmap_of_arfcns.count;count++)
                    {
                        p_ue_connection_release_ind->redirected_carrier_info.geran.following_arfcns.var_bitmap_of_arfcns.data[count] = 
                            p_ue_connection_release_ind->idle_mode_mobility_control.\
                            freq_priority_list_geran.freqs_priority_geran[RRM_ZERO].carrier_freq.
                            following_arfcns.var_bitmap_of_arfcns.data[count]; 
                    }

                }
            }
 RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_uem_get_redirected_utran_carrier_frequency
 * Inputs         : U16 spid
 * Outputs        : None
 * Description    : to get redirected carrier frequency corresponding
 *                  to SPID
 * Returns        : none
 ****************************************************************************/
rrm_void_t
rrm_uem_get_redirected_utran_carrier_frequency(
        rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
        rrm_ue_context_t *p_ue_context)
{


    RRM_UT_TRACE_ENTER();
 
/* Start fix for SPR 7015 */
                if((p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_tdd.count) &&
                   (p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_fdd.count))
                {
			if (p_ue_connection_release_ind->idle_mode_mobility_control.
			       freq_priority_list_utra_tdd.freq_priority_utra_tdd[RRM_ZERO].
				  cell_reselection_priority >= p_ue_connection_release_ind->idle_mode_mobility_control.
				      freq_priority_list_utra_fdd.freq_priority_utra_fdd[RRM_ZERO].cell_reselection_priority)
			{
			    p_ue_connection_release_ind->bitmask |=RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.bitmask |=RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.utra_tdd =
				p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_tdd.freq_priority_utra_tdd[RRM_ZERO].carrier_freq;
			    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				    "[UE:%d] utra tdd redirect freq[%u]",p_ue_context->ue_index,
				    p_ue_connection_release_ind->redirected_carrier_info.utra_tdd);

			}
                        else 
                        {
			    p_ue_connection_release_ind->bitmask |= RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.bitmask |= RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.utra_fdd =
				p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_fdd.freq_priority_utra_fdd[RRM_ZERO].carrier_freq;
			    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				    "[UE:%d] utra fdd redirect freq[%u]",p_ue_context->ue_index,
				    p_ue_connection_release_ind->redirected_carrier_info.utra_fdd);
                        }
                }
                else 
                {
			if(p_ue_connection_release_ind->idle_mode_mobility_control.
				freq_priority_list_utra_tdd.count)
			{
			    p_ue_connection_release_ind->bitmask |=RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.bitmask |=RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.utra_tdd =
				p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_tdd.freq_priority_utra_tdd[RRM_ZERO].carrier_freq;
			    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				    "[UE:%d] utra tdd redirect freq[%u]",p_ue_context->ue_index,
				    p_ue_connection_release_ind->redirected_carrier_info.utra_tdd);
			}
			if(p_ue_connection_release_ind->idle_mode_mobility_control.
				freq_priority_list_utra_fdd.count)
			{
			    p_ue_connection_release_ind->bitmask |= RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.bitmask |= RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT;
			    p_ue_connection_release_ind->redirected_carrier_info.utra_fdd =
				p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_fdd.freq_priority_utra_fdd[RRM_ZERO].carrier_freq;
			    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				    "[UE:%d] utra fdd redirect freq[%u]",p_ue_context->ue_index,
				    p_ue_connection_release_ind->redirected_carrier_info.utra_fdd);
			}
                }
/* End fix for SPR 7015 */
  RRM_UT_TRACE_EXIT();       
}
/* cyclo end */ 
/****************************************************************************
 * Function Name  : rrm_uem_get_redirected_carrier_frequency
 * Inputs         : U16 spid
 * Outputs        : None
 * Description    : to get redirected carrier frequency corresponding
 *                  to SPID
 * Returns        : none
 ****************************************************************************/
rrm_void_t
rrm_uem_get_redirected_carrier_frequency(
        rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
                  rrm_ue_context_t *p_ue_context )
{
    rrm_bool_et                         feature_group_indicators_utran = RRM_FALSE;
    rrm_bool_et                         feature_group_indicators_geran = RRM_FALSE;

    rrm_meas_config_info_t  *p_rrm_meas_config_info = RRM_NULL;
  
    p_rrm_meas_config_info = rrm_cellm_get_meas_config_info(p_ue_context->cell_index);

    RRM_UT_TRACE_ENTER();
    if (RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT &
            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT");
        /*Start:Bug 762*/   
	if((RRM_TRUE == rrm_is_set_fgi_bit(p_ue_context,RRM_NINE)))
	{ 
	    feature_group_indicators_geran = RRM_TRUE;  /* CID: 60178 - Fix */
	}
	/* cyclo start */
    /* cyclo end */
    if((RRM_TRUE == rrm_is_set_fgi_bit(p_ue_context,RRM_EIGHT)))
	{
	    feature_group_indicators_utran = RRM_TRUE;
	}
    /* cyclo start */
    /* cyclo end */    
     /*End:Bug 762*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "fgi utran:%x geran:%x", feature_group_indicators_utran, feature_group_indicators_geran);
    }

    /*check if CSFB case */
    /*SPR 21761 Start*/
    if ((p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD) &&
            ((RRM_CSFB_TGT_SELECT_MAHO ==\
                p_rrm_meas_config_info->csfb_tgt_selection.utran_csfb_tgt_selection)||
                (RRM_CSFB_TGT_SELECT_MAHO ==\
                p_rrm_meas_config_info->csfb_tgt_selection.geran_csfb_tgt_selection)))

    {
    /*SPR 21761 End*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "CSFB true fill redirection info");
        rrm_fill_redirection_info_for_csfb( p_ue_connection_release_ind,
                p_ue_context,feature_group_indicators_utran,
                feature_group_indicators_geran);
        return;
    }
    switch(p_ue_context->target_cell_type)
    {
        /* cyclo start */
        case GERAN_CELL:
            /* cyclo start */
            if(feature_group_indicators_geran)
             {
               rrm_uem_get_redirected_geran_carrier_frequency(p_ue_connection_release_ind,p_ue_context);  
             }
            break;
        case UTRA_CELL:
            /* SPR 17850 Fix Start */
            /* Code Deleted */
            /* SPR 17850 Fix End */
               rrm_uem_get_redirected_utran_carrier_frequency(p_ue_connection_release_ind,p_ue_context);
            /* SPR 17850 Fix Start */
            /* Code Deleted */
            /* SPR 17850 Fix End */
            break;
           
        default :
            break;  
             /*Condition will never be true. Handled for removing warning*/
           /* cyclo end */  
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: fill_geran_si_psi_info 
 *   INPUT        : p_geran_freq_cells,p_rrc_rrm_ue_connection_release_ind
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *                  fill geran si psi info for RWR
 *   RETURNS      :
 *                   NONE
 ******************************************************************************/
 rrm_void_t fill_geran_si_psi_info(
    rrc_rrm_ue_connection_release_ind_t *p_rrc_rrm_ue_connection_release_ind,
    geran_freq_ncl_t        *p_geran_freq_cells
 )
{
    U8                         r9_cell_count = RRM_ZERO;
    U8                         count = RRM_ZERO;
    system_info_list_geran_t   *p_system_information_r9 = RRM_PNULL;
    
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ue_connection_release_ind->bitmask |= RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V890_IES_PRESENT;
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.bitmask |=
        RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V920_IES_PRESENT;   
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.bitmask |=
        RRC_RRM_CELL_INFO_LIST_R9_PRESENT;
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.cell_info_list_r9.bitmask |=
        RRC_RRM_CELL_INFO_LIST_GERAN_R9_PRESENT;

    r9_cell_count = p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.
        rrc_connection_release_v920_ies.cell_info_list_r9.geran_r9.count;
    /*Filling phys_cell_id_geran_t*/
    /* SPR_14067_Fix_Start */
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.\
        rrc_connection_release_v920_ies.cell_info_list_r9.geran_r9.cell_info_geran_r9[r9_cell_count].\
        phys_cell_id_r9.network_colour_code = (U8)((p_geran_freq_cells->pci) &\
                RRM_NCC_MASK)>> RRM_THREE;
    /* SPR_14067_Fix_End */                 
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.\
        rrc_connection_release_v920_ies.cell_info_list_r9.geran_r9.cell_info_geran_r9[r9_cell_count].\
        phys_cell_id_r9.base_station_colour_code = (p_geran_freq_cells->pci) &\
        RRM_BSCC_MASK;
    /*Filling carrier_freq_geran_t */
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.
        rrc_connection_release_v920_ies.cell_info_list_r9.geran_r9.cell_info_geran_r9[r9_cell_count]
        .carrier_freq_r9.arfcn = p_geran_freq_cells->bcch_arfcn;

    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.
        rrc_connection_release_v920_ies.cell_info_list_r9.geran_r9.cell_info_geran_r9[r9_cell_count]
        .carrier_freq_r9.band_indicator = p_geran_freq_cells->band_indicator;

    /*Filling system_info_list_geran_t */
    p_system_information_r9 = &(p_rrc_rrm_ue_connection_release_ind->\
            rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.\
            cell_info_list_r9.geran_r9.cell_info_geran_r9[r9_cell_count].\
            system_information_r9);
    if (p_geran_freq_cells->rim_geran_info != RRM_NULL)
    {
        p_system_information_r9->count = p_geran_freq_cells->rim_geran_info->num_si_psi;

        for (count =RRM_ZERO;count <p_system_information_r9->count;count++)
        {
            p_system_information_r9->system_info_geran_elem[count].bitmask |=
                RRC_RRM_SYS_INFO_CONTAINER_ENCODED_PRESENT;
            /*SPR 20553 FIX START */ 
    	    /* SPR 18738 fix start */
            if(p_geran_freq_cells->rim_geran_info->bitmask ==RRM_GERAN_PSI_PRESENT) 
            {
            p_system_information_r9->system_info_geran_elem[count].\
                sys_info_container_encoded_si_info.length =
                RIM_MAX_SI_PSI_PAYLOAD_INDIV;
            RRM_MEMCPY(&(p_system_information_r9->system_info_geran_elem[count].\
                        sys_info_container_encoded_si_info.data),
                    	&(p_geran_freq_cells->rim_geran_info->geran_si_psi[count]),
                    RIM_MAX_SI_PSI_PAYLOAD_INDIV);
        }
	    else if (p_geran_freq_cells->rim_geran_info->bitmask == RRM_GERAN_SI_PRESENT)
	    {
            	p_system_information_r9->system_info_geran_elem[count].\
                	sys_info_container_encoded_si_info.length =
                	RIM_MAX_SI_PAYLOAD_INDIV;
            	RRM_MEMCPY(&(p_system_information_r9->system_info_geran_elem[count].\
                        sys_info_container_encoded_si_info.data),
                    	&(p_geran_freq_cells->rim_geran_info->geran_si_psi[count]),
                    	RIM_MAX_SI_PAYLOAD_INDIV);
	    }
    	    /* SPR 18738 fix end */
            /*SPR 20553 FIX END */
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                    RRM_ERROR,"rim_geran_info is NULL");
    }
    r9_cell_count++;
    p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.
        rrc_connection_release_v920_ies.cell_info_list_r9.geran_r9.count = r9_cell_count;
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_connection_release_ind_carrier_redir 
 *   INPUT      : ue_index,type,cause,transaction_id,earfcn
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       build and send connection release ind for carrier redir
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et 
rrm_build_and_send_ue_connection_release_ind_carrier_redir
(
 rrm_ue_index_t      ue_index,
 rrm_cell_index_t    cell_index,
 U16                 earfcn,
 rrm_type_et         type,
 rrm_radio_network_cause_et      cause,
 U16                 transaction_id
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_ue_connection_release_ind_t  *p_rrc_rrm_ue_connection_release_ind= RRM_PNULL;
    rrm_cell_context_t        *p_cell_ctxt = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t          *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_ue_connection_release_ind = (rrc_rrm_ue_connection_release_ind_t*)
                                           rrm_mem_get (sizeof (rrc_rrm_ue_connection_release_ind_t));
    if(RRM_PNULL == p_rrc_rrm_ue_connection_release_ind)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_rrc_rrm_ue_connection_release_ind, RRM_ZERO,
                sizeof(rrc_rrm_ue_connection_release_ind_t));

    p_rrc_rrm_ue_connection_release_ind->ue_index = ue_index;
    p_rrc_rrm_ue_connection_release_ind->release_cause.type = type;
    p_rrc_rrm_ue_connection_release_ind->release_cause.value= cause;
    
    p_rrc_rrm_ue_connection_release_ind->bitmask |= 
                RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
    p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.bitmask |= 
                RRM_REDIRECTED_CARRIER_INFO_EUTRA_PRESENT;
    p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.eutra = earfcn;
    /*KPI: enb init ue release  */
    /* SPR 20652 Fix Start */
    p_ue_context = rrm_ue_find_context(ue_index,
            cell_index);
    if(RRM_PNULL != p_ue_context)
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
        /*CID 65764,65843:start*/
        if(RRM_PNULL != p_cell_ctxt)
        {
            p_cell_ctxt->kpi_stat.kpi.num_of_enb_init_ue_release += RRM_ONE;
        }
        /*CID 65764,65843:end*/
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "UE context not found");
    }
    /*KPI: enb init ue release  */
    if (RRM_SUCCESS == (ret_val = rrm_il_send_rrc_rrm_ue_connection_release_ind(
                p_rrc_rrm_ue_connection_release_ind,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                transaction_id,cell_index)))
    {
        /* Bug_944_start */
        if (RRM_PNULL != p_ue_context)
        {
            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "Failed to clean up ue resources for [UE:%d]",ue_index);
                ret_val = RRM_FAILURE;
                /* SPR 20652 Fix End */

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "successfully cleaned up resources for the [UE:%d]",
                        ue_index);
            }
        }
        /* Bug_944_end */
    }
    RRM_MEM_FREE (p_rrc_rrm_ue_connection_release_ind);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_check_dual_rx_support
 *   INPUT      : p_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION:
 *       Checks if UE & eND supports Dual Rx Mode.
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_bool_et
rrm_ue_check_dual_rx_support
(
 rrm_ue_context_t  *p_ue_context
)
{
    rrm_bool_et DUAL_RX_MODE_SUPPORTED = RRM_FALSE;
    rrm_bool_et eNB_SUPPORT_DUAL_RX_MODE = RRM_FALSE;
    rrm_bool_et UE_SUPPORT_DUAL_RX_MODE = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);

    /*CID 65841:start*/
    if (RRM_PNULL != p_cell_context)
    {
        eNB_SUPPORT_DUAL_RX_MODE = p_cell_context->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params.csfb_support_for_dual_rx_ues_r9;
    /* SPR_17552_changes_start */
    if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT) && 
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask & RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT))
    {
        /* SPR_17552_changes_end */
        /*Rel 10 597 changes*/
        if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                    bitmask & RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_CDMA2000_V1020_PRESENT) &&
                (RRM_ECSFB_1XRTT_DUAL_R10_SUPPORTED == p_ue_context->ue_capability_params.
                 rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                 ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                 inter_rat_parameters_cdma2000_v1020.eCSFB_dual_1xrtt_r10))
            /*Rel 10 597 changes*/
        {
            UE_SUPPORT_DUAL_RX_MODE = RRM_TRUE;
        }
        /* SPR_17552_changes_start */
    }
    /* SPR_17552_changes_end */
        /* coverity : CID 30264  */
        /*Coverity_fix_start_54970*/
        DUAL_RX_MODE_SUPPORTED = (rrm_bool_et)(eNB_SUPPORT_DUAL_RX_MODE && UE_SUPPORT_DUAL_RX_MODE);
        /*Coverity_fix_end_54970*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
    }
    /*CID 65841:end*/
    RRM_UT_TRACE_EXIT();
    return (DUAL_RX_MODE_SUPPORTED);
}
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_rrc_connection_release_v890_ies_geran_cell
 *   INPUT      : p_ue_context
 *   OUTPUT     : p_rrc_rrm_ue_connection_release_ind
 *   DESCRIPTION:
 *       Fills and rrc_connection_release_v890_ies
 *   RETURNS:
 *      none
 ******************************************************************************/
rrm_void_t
rrm_fill_rrc_connection_release_v890_ies_geran_cell(
       rrc_rrm_ue_connection_release_ind_t *p_rrc_rrm_ue_connection_release_ind,
       rrm_ue_context_t * p_ue_context,inter_rat_ncl_t *p_irat_ncl)
{
   U16                   index = RRM_ZERO;  
   RRM_UT_TRACE_ENTER();
         for(index = RRM_ZERO; index < p_irat_ncl->num_valid_geran_cell;
                  index++) 
          {
              if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
              {
                    /* SPR 15674 Start */
                        /* SPR 15674 End */
                    /* SPR 18892 Start */
		      if(p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.geran.starting_arfcn==p_irat_ncl->geran_freq_cells[index].bcch_arfcn)
		      { 
			      /* SPR 18892 End */
			      /* SPR-10489-fix start */
			      if ((p_irat_ncl->geran_freq_cells[index].bitmask & RRM_GERAN_FREQ_CELL_DTM_SUPPORTED_PRESENT) &&
					      (p_irat_ncl->geran_freq_cells[index].dtm_supported == RRM_ZERO ) &&
					      (!(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
						 inter_rat_parameters_geran_v920.bitmask & RRM_UE_IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT)))
			      {
				      p_rrc_rrm_ue_connection_release_ind->release_cause.type = RADIO_NETWORK_LAYER_TYPE;
				      p_rrc_rrm_ue_connection_release_ind->release_cause.value= UE_NOT_AVAILABLE_FOR_PS_SERVICE;
			      }
			      else if ((!(p_irat_ncl->geran_freq_cells[index].bitmask & RRM_GERAN_FREQ_CELL_DTM_SUPPORTED_PRESENT)) &&
					      (!(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
						 inter_rat_parameters_geran_v920.bitmask & RRM_UE_IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT)))
			      {

				      p_rrc_rrm_ue_connection_release_ind->release_cause.type = RADIO_NETWORK_LAYER_TYPE;
				      p_rrc_rrm_ue_connection_release_ind->release_cause.value= UE_NOT_AVAILABLE_FOR_PS_SERVICE;
			      }

			      /* SPR-10489-fix end */



			      /*If mandatory SI/PSI not present then donot proceed*/
			      if ((RRM_PNULL != p_irat_ncl->geran_freq_cells[index].rim_geran_info) &&
					      ((RRM_GERAN_SI_PRESENT == p_irat_ncl->geran_freq_cells[index].rim_geran_info->bitmask) ||
					       (RRM_GERAN_PSI_PRESENT == p_irat_ncl->geran_freq_cells[index].rim_geran_info->bitmask))) 
			      {
			/*SPR_18650_FIX_START*/
			if (p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
					cell_info_list_r9.geran_r9.count < MAX_CELL_INFO_GERAN_R9)
			{
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_INFO,
                                               "Geran pci[%u] SI/PSI present",
                                              p_irat_ncl->geran_freq_cells[index].pci);
				/*SPR_18650_FIX_STOP*/

				      fill_geran_si_psi_info(p_rrc_rrm_ue_connection_release_ind,&(p_irat_ncl->geran_freq_cells[index]));
				/*SPR_18650_FIX_START*/
			}
			else
			{
				RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name,RRM_WARNING,
						"Geran cell count reached to max");
				      break;
			      }
			/*SPR_18650_FIX_STOP*/
		}
			      else
			      {
				      /* SPR 15674 Start */
				      RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_WARNING,
						      "Geran pci[%u] earfcn[%d] SI/PSI not present",
						      p_ue_context->ho_params.target_phys_cell_id,
						      p_ue_context->ho_params.target_earfcn);
				      /* SPR 15674 End */
				      break;

			      }
		      }
              }
     }
RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_rrc_connection_release_v890_ies_utra_cell
 *   INPUT      : p_ue_context
 *   OUTPUT     : p_rrc_rrm_ue_connection_release_ind
 *   DESCRIPTION:
 *       Fills and rrc_connection_release_v890_ies
 *   RETURNS:
 *      none
 ******************************************************************************/
rrm_void_t
rrm_fill_rrc_connection_release_v890_ies_utra_cell(
       rrc_rrm_ue_connection_release_ind_t *p_rrc_rrm_ue_connection_release_ind,
       rrm_ue_context_t * p_ue_context,inter_rat_ncl_t *p_irat_ncl)
{
   U16                   index = RRM_ZERO;
    /* SPR 10497 Fix Start */
  U8                              count_r10 = RRM_ZERO;
    /* SPR 10497 Fix End */
   RRM_UT_TRACE_ENTER();
   
          for(index = RRM_ZERO; index < p_irat_ncl->num_valid_utran_freq_cell;
                  index++)
          {
                    	      /*SPR 18774 Start*/
              if (p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
              {
                  if (p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.utra_fdd ==
                          p_irat_ncl->utran_freq_cells[index].uarfcndl)
                  {
		    /*SPR_18416_START*/
		    RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
				    "UTRAN arfcn[%d] found",
				    p_ue_context->ho_params.target_earfcn);
		    /*SPR_18416_STOP*/
                      /* Bug 4160 changes start */
                      if ((p_irat_ncl->utran_freq_cells[index].rim_utran_info != RRM_NULL) && 
                              (RRM_UTRAN_SI_PRESENT &
                               p_irat_ncl->utran_freq_cells[index].rim_utran_info->bitmask))
                      {
                          /*SPR_18650_FIX_START*/
                          if (p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
                                 cell_info_list_r9.utra_fdd_r9.count < MAX_CELL_INFO_UTRA_R9)
                  {
                          /*SPR_18650_FIX_STOP*/
                              fill_rim_info(p_rrc_rrm_ue_connection_release_ind,
                                      &(p_irat_ncl->utran_freq_cells[index]));
                          /*SPR_18650_FIX_START*/
                          }
                          else
                      {
                          RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name,RRM_WARNING,
                                           "utra cell count reached to max");
                          break;
                      }
                          /*SPR_18650_FIX_STOP*/
                      }
                      else
                      {
                          RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_WARNING,
                                  "Utran psc[%u] freq[%u] SI not present",
                                  p_irat_ncl->utran_freq_cells[index].pcpich_scrambling_code,
                                  p_irat_ncl->utran_freq_cells[index].uarfcndl);
                      }
                      /* Bug 4160 changes end */
                  }
              }
	      /*SPR 18774 END*/
	      //THE IF ELSE IF NEED TO BE CORRECTED AFTER REVIEWING THE FLOW	
              /* SPR 10497 Fix Start */
              else if(p_rrc_rrm_ue_connection_release_ind->bitmask & RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT)
              {
                  /*select best freq of utran and redirect */   /* SPR-16135 START */
                    if(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            eutra_radio_capability_info_def.access_stratum_release >= RRM_REL10)
                    {
                    /* SPR-16135 END */

                        /* SPR 10497 Fix End */
                      for(count_r10 = RRM_ZERO; count_r10 < p_rrc_rrm_ue_connection_release_ind->
                              redirected_carrier_info.redirected_carrier_info_utra_tdd_r10.count; count_r10++)
                      {
                          if ((p_irat_ncl->utran_freq_cells[count_r10].rim_utran_info != RRM_NULL) &&
                                  (RRM_UTRAN_SI_PRESENT &
                                   p_irat_ncl->utran_freq_cells[count_r10].rim_utran_info->bitmask))
                          {
                              fill_rim_info_r10(p_rrc_rrm_ue_connection_release_ind,
                                      &(p_irat_ncl->utran_freq_cells[count_r10]), count_r10);
                              if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                          ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                          ue_eutra_capability_v1020_ies.bitmask & RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT) && 
                                      (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                       ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                                       /*SPR 13383 changes start */
                                       ue_eutra_capability_v1060.tdd_add_ue_eutra_capability_v1060.bitmask &
                                       /*SPR 13383 changes end */
                                       RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_UTRA_TDD_PRESENT) &&
                                      (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                       ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                       /*SPR 13383 changes start */
                                       ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.tdd_add_ue_eutra_capability_v1060.
                                       /*SPR 13383 changes end */
                                       inter_rat_parameters_utra_tdd_v1060.e_redirection_utra_tdd_r10 == 
                                       RRM_E_REDIRECTION_UTRA_TDD_R10_SUPPORTED))
                              {
                                  p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.redirected_carrier_info_utra_tdd_r10.
                                      utra_tdd_r10[count_r10] = p_irat_ncl->utran_freq_cells[count_r10].uarfcndl;
                                  p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.bitmask |= RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_R10_PRESENT;
                              }
                              if(count_r10 == MAX_FREQ_UTRA_TDD_R10)
                              {
                                  break;
                              }
                              p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.
                                  redirected_carrier_info_utra_tdd_r10.count = count_r10;
                              p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.
                                  rrc_connection_release_v920_ies.cell_info_list_r9.utra_tdd_r10.count = count_r10;
                          }
                          else
                          {
                              RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_WARNING,
                                      "Utran psc[%u] freq[%u] SI not present",
                                      p_irat_ncl->utran_freq_cells[count_r10].pcpich_scrambling_code,
                                      p_irat_ncl->utran_freq_cells[count_r10].uarfcndl);
                          }
                      }
                      /*CR 713 changes*/
                      /* SPR 10497 Fix Start */
                  }
                    else if(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                          eutra_radio_capability_info_def.access_stratum_release == RRM_REL9)
                    {
                        if ((RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT &
                                    p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.bitmask)
                                &&(p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.utra_tdd ==
                                    p_irat_ncl->utran_freq_cells[index].uarfcndl))
                        {
                            if ((p_irat_ncl->utran_freq_cells[index].rim_utran_info != RRM_NULL) &&
                                    (RRM_UTRAN_SI_PRESENT &
                                     p_irat_ncl->utran_freq_cells[index].rim_utran_info->bitmask))
                            {
                                fill_rim_info(p_rrc_rrm_ue_connection_release_ind,
                                        &(p_irat_ncl->utran_freq_cells[index]));
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_WARNING,
                                        "Utran TDD psc[%u] freq[%u] SI not present",
                                        p_irat_ncl->utran_freq_cells[index].pcpich_scrambling_code,
                                        p_irat_ncl->utran_freq_cells[index].uarfcndl);
                            }
                        }
                        else if ((RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT &
                                    p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.bitmask)
                                && (p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info.utra_fdd ==
                                    p_irat_ncl->utran_freq_cells[index].uarfcndl))
                            /* SPR 10497 Fix End*/
                        {
                            if ((p_irat_ncl->utran_freq_cells[index].rim_utran_info != RRM_NULL) &&
                                    (RRM_UTRAN_SI_PRESENT &
                                     p_irat_ncl->utran_freq_cells[index].rim_utran_info->bitmask))
                            {
                                fill_rim_info(p_rrc_rrm_ue_connection_release_ind,
                                        &(p_irat_ncl->utran_freq_cells[index]));
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_WARNING,
                                        "Utran FDD psc[%u]freq[%u] SI not present",
                                        p_irat_ncl->utran_freq_cells[index].pcpich_scrambling_code,
                                        p_irat_ncl->utran_freq_cells[index].uarfcndl);
                            }
                        }
                        /* SPR 10497 Fix Start */
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_DETAILED,
                                "UE access_stratum_release = %d",
                                p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                eutra_radio_capability_info_def.access_stratum_release);
                    }
              }
              else
              {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_DETAILED,
                    "Carrier redirected info not present");
              }
              /* SPR 10497 Fix End*/
          }/*end of for*/
RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_rrc_connection_release_v890_ies
 *   INPUT      : p_ue_context
 *   OUTPUT     : p_rrc_rrm_ue_connection_release_ind
 *   DESCRIPTION:
 *       Fills and rrc_connection_release_v890_ies
 *   RETURNS:
 *      none 
 ******************************************************************************/
void
rrm_fill_rrc_connection_release_v890_ies(
    rrc_rrm_ue_connection_release_ind_t 
    *p_rrc_rrm_ue_connection_release_ind,
    rrm_ue_context_t *p_ue_context
    )
{

  inter_rat_ncl_t                 *p_irat_ncl   = RRM_PNULL;
  /*Rel10 CR changes start*/
  rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = NULL;
  /*Rel10 CR changes end*/

  RRM_UT_TRACE_ENTER();

  /*Rel10 CR changes start*/
  p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_ue_context->cell_index);
  /*Rel10 CR changes end*/
  
  p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);
  
  if (RRM_PNULL != p_irat_ncl)
  {
      if (GERAN_CELL == p_ue_context->target_cell_type) 
      {
       rrm_fill_rrc_connection_release_v890_ies_geran_cell(p_rrc_rrm_ue_connection_release_ind,p_ue_context,p_irat_ncl); 
      }
      else if(UTRA_CELL == p_ue_context->target_cell_type)
      {
         rrm_fill_rrc_connection_release_v890_ies_utra_cell(p_rrc_rrm_ue_connection_release_ind,p_ue_context,p_irat_ncl);
      }/*end of if*/
      /*Rel10 CR changes start*/
      if ((RRM_UE_REL_CAUSE_CONGESTION == p_ue_context->ue_release_cause) &&
              (RRM_UE_ESTAB_CAUSE_DELAYTOLERANTACCESS_V1020 == p_ue_context->establishment_cause))
      {
          if (RRM_SERVICE_PROFILE_UE_ADM_EXTENDED_WAIT_TIME_PRESENT & p_ue_service_profile->bitmask)
          {
              p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
                  rrc_connection_release_v1020_ies.bitmask |= RRC_RRM_EXTENDED_WAIT_TIME_PRESENT;
              p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
                  rrc_connection_release_v1020_ies.extended_wait_time_r10 = p_ue_service_profile->extended_wait_time;
          }
      }
      /*Rel10 CR changes end*/
  }
  RRM_UT_TRACE_EXIT();
}
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME: rrm_process_ue_connection_release_ind_utra_cell
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       process ue connection release indication for utra cell
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/
rrm_void_t 
rrm_process_ue_connection_release_ind_utra_cell(rrm_ue_context_t   *p_ue_context,
                  rrc_rrm_ue_connection_release_ind_t   * rrc_rrm_ue_connection_release_ind)
{
   RRM_UT_TRACE_ENTER();
   
   if(RRM_SUCCESS == rrm_get_idle_mode_ue_connection_release_ind_param(
               rrc_rrm_ue_connection_release_ind,
               p_ue_context))
   {

       rrm_uem_get_redirected_carrier_frequency(
               rrc_rrm_ue_connection_release_ind,
               p_ue_context);
     /*Fix for Bug 4323 start */
       if(RRM_REL9 <= p_ue_context->ue_capability_params.\
                   rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.\
                   access_stratum_release)
     /*Fix for Bug 4323 stop */
       {
           rrm_fill_rrc_connection_release_v890_ies(
                   rrc_rrm_ue_connection_release_ind,
                   p_ue_context);
       }
       /*SPR_7742_fix Rel10_CRs:36.331-490 release cause CS_FB_HIGH_PRIORITY logic 
         remove from here it will take care by L3*/
   }
   RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_process_ue_connection_release_ind_geran_cell
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       process ue connection release indication for utra cell
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/
rrm_void_t
rrm_process_ue_connection_release_ind_geran_cell(rrm_ue_context_t   *p_ue_context,
         rrc_rrm_ue_connection_release_ind_t   *rrc_rrm_ue_connection_release_ind)
{
    RRM_UT_TRACE_ENTER();
    
    if(RRM_SUCCESS == rrm_get_idle_mode_ue_connection_release_ind_param(
                      rrc_rrm_ue_connection_release_ind,
                      p_ue_context))
     {
        rrm_uem_get_redirected_carrier_frequency(
                      rrc_rrm_ue_connection_release_ind,
                      p_ue_context);

    /*SPR 20571 START*/
          if((RRM_REL9 > p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release) || 
             ((RRM_REL9 == p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release) &&
                    !(RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask)) )  
          {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Cell Info list not filled.UE Access Stratum release:[%d]",p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release);
          }
          else
          {
    /*SPR 20571 END*/
                rrm_fill_rrc_connection_release_v890_ies(
                          rrc_rrm_ue_connection_release_ind,
                          p_ue_context);
    /*SPR 20571 START*/
          }
    /*SPR 20571 END*/
      }
        
    
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_process_ue_connection_release_ind_CDMA2000_cell
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       process ue connection release indication for utra cell
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/
 rrm_void_t
 rrm_process_ue_connection_release_ind_CDMA2000_cell(rrm_ue_context_t   *p_ue_context,
             rrc_rrm_ue_connection_release_ind_t   *rrc_rrm_ue_connection_release_ind)
 {

    rrm_bool_t                           DUAL_RX_MODE_SUPPORTED = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
     /* Check if UE/eNB support for dual Rx Mode */
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
             "RRC_CONNECTION_REL_IND: target rat type: CDMA2000_CELL");
     DUAL_RX_MODE_SUPPORTED = rrm_ue_check_dual_rx_support(p_ue_context);
     if(!DUAL_RX_MODE_SUPPORTED)
     {
         rrm_fill_release_params_cdma2000(
                 rrc_rrm_ue_connection_release_ind,
                 p_ue_context);
     }
     else
     {
         RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                 RRM_DETAILED, "DUAL Rx Mode is supported by UE & eNB"
                 "so Redirection information is not filled");
     }
     RRM_UT_TRACE_EXIT();
 }
/* cyclo end */
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_target_rat_type
 *   INPUT      : p_ue_index,type,cause,transaction_id,p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills UE connection release indication.
 *   RETURNS:     None
 ******************************************************************************/
rrm_void_t
rrm_fill_target_rat_type( rrm_ue_context_t                     *p_ue_context,
                          rrc_rrm_ue_connection_release_ind_t  *rrc_rrm_ue_connection_release_ind,
                          rrm_cell_type_t       target_rat_type)
{
    RRM_UT_TRACE_ENTER();
    switch(target_rat_type)
    {
        case EUTRA_CELL:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "RRC_CONNECTION_REL_IND: target rat type: EUTRA_CELL");
            if (RRM_FAILURE == rrm_get_idle_mode_ue_connection_release_ind_param(
                        rrc_rrm_ue_connection_release_ind,
                        p_ue_context))
            {
                /* Coverity : CID 41376 */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "Received Failure");
            }
            break;

        case UTRA_CELL:
            /* cyclo start */
            rrm_process_ue_connection_release_ind_utra_cell(p_ue_context,rrc_rrm_ue_connection_release_ind);
            /* cyclo end */
            break;
        case GERAN_CELL:
            /* cyclo start */
            rrm_process_ue_connection_release_ind_geran_cell(p_ue_context,rrc_rrm_ue_connection_release_ind);
            /* cyclo end */
            break;

        case CDMA2000_CELL:
            /* cyclo start */
            rrm_process_ue_connection_release_ind_CDMA2000_cell(p_ue_context,rrc_rrm_ue_connection_release_ind);
            /* cyclo end */ 
            break;
        default :
            rrc_rrm_ue_connection_release_ind->release_cause.type = RADIO_NETWORK_LAYER_TYPE;
            rrc_rrm_ue_connection_release_ind->release_cause.value= UNSPECIFIED;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                    RRM_DETAILED, " INVALID target cell id ");
            break;

    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_connection_release_ind 
 *   INPUT      : p_ue_index,type,cause,transaction_id,p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills and sends UE connection release indication. 
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
 rrm_return_et
rrm_build_and_send_ue_connection_release_ind
(
    rrm_ue_index_t		ue_index,
    U8 		            type, /* change data type to U8 to remove coverity warning after SPR_8345_fix */
    U16 		        cause, /* change data type to U16 to remove coverity warning after SPR_8345_fix */
    U16              	transaction_id,
    rrm_ue_context_t   *p_ue_context,
    rrm_cell_index_t    cell_index
)
{
    rrc_rrm_ue_connection_release_ind_t  *rrc_rrm_ue_connection_release_ind = RRM_PNULL;
    rrm_return_et                        ret_val = RRM_SUCCESS;
    rrm_cell_type_t                      target_rat_type =  UTRA_CELL; /* coverity :  CID 41574 */
    rrm_cell_context_t                   *p_cell_ctxt = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* Coverity: CID 11218 */
    rrc_rrm_ue_connection_release_ind = (rrc_rrm_ue_connection_release_ind_t *)
                                                rrm_mem_get(sizeof(rrc_rrm_ue_connection_release_ind_t));
    if (RRM_PNULL == rrc_rrm_ue_connection_release_ind)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }
    /* Coverity: CID 11218 */

    RRM_MEMSET(rrc_rrm_ue_connection_release_ind, RRM_ZERO,
                sizeof(rrc_rrm_ue_connection_release_ind_t));

    rrc_rrm_ue_connection_release_ind->ue_index = ue_index;
    rrc_rrm_ue_connection_release_ind->release_cause.type = type;
    rrc_rrm_ue_connection_release_ind->release_cause.value= cause;

    /* Coverity: CID 30598 */
    /*KLOC FIX */
    if(RRM_PNULL != p_ue_context)
    {
        if ((RRM_TRUE == p_ue_context->cdma2000_meas_id_received))
        {
            target_rat_type = CDMA2000_CELL;
        }
        else
        {
            target_rat_type = rrm_get_hghst_prorty_inter_rat_basd_on_spid(p_ue_context);
        }
        p_ue_context->target_cell_type = target_rat_type;
        /*Klockwork_fix_start*/
        rrm_fill_target_rat_type(p_ue_context,rrc_rrm_ue_connection_release_ind,target_rat_type);
        /*Klockwork_fix_end*/
    /* SPR_10729_fix start */
    }
    /*KPI: enb init ue release  */
    p_cell_ctxt = rrm_cellm_get_cell_context(cell_index);
    /*CID 65843:start*/
    if (RRM_PNULL != p_cell_ctxt)
    {    
        p_cell_ctxt->kpi_stat.kpi.num_of_enb_init_ue_release += RRM_ONE;
    }
    /*CID 65843:end*/
    /*KPI: enb init ue release  */
    /* CID: 30598 - Fix Start*/
    ret_val = rrm_il_send_rrc_rrm_ue_connection_release_ind(
            rrc_rrm_ue_connection_release_ind,
            RRM_MODULE_ID,
            RRC_MODULE_ID,
            transaction_id,cell_index);
    /* CID: 30598 - Fix End*/
    /* SPR_10729_fix end */

    RRM_UT_TRACE_EXIT();
    RRM_MEM_FREE(rrc_rrm_ue_connection_release_ind);
    return ret_val;

}


/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_lipa_erb_release_ind
 *   input        : p_ue_context,p_ue_index,p_erab_id,count,type,cause,transaction_id
 *   output       : none
 *   DESCRIPTION:
 *       Fills and sends ERAB release indication.
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_lipa_erb_release_ind(
    rrc_rrm_erb_release_ind_t  *p_rrc_rrm_erb_release_ind,
    rrm_cell_index_t cell_index)
{
    rrm_return_et                        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    ret_val = rrm_il_send_rrc_rrm_erb_release_ind(
                  p_rrc_rrm_erb_release_ind,
                  RRM_MODULE_ID,
                  RRC_MODULE_ID,
                  RRM_ONE,cell_index);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_erb_release_ind
 *   input      : p_ue_context,p_ue_index,p_erab_id,count,type,cause,transaction_id
 *   output     : none
 *   DESCRIPTION:
 *       Fills and sends ERAB release indication.
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_erb_release_ind(
	 rrm_ue_context_t	*p_ue_context,
         rrm_ue_index_t          ue_index,
         U8                      *p_erab_id,
         U16                     count,
         rrm_type_et                 type,
         rrm_radio_network_cause_et                     cause,
         U16                 transaction_id
         )
{
    rrc_rrm_erb_release_ind_t  rrc_rrm_erb_release_ind;
    U16                        drb_count;
    rrm_return_et              ret_val = RRM_SUCCESS;
    /*SPR_19066_START*/
    U32                        max_value_of_inactive_timer = RRM_ZERO; /* Time infinite */
    U8                         qos_index = RRM_ZERO;
    U8                         drb_index = RRM_ZERO;
    rrm_cell_context_t         *p_cell_context = RRM_PNULL;
    /*SPR_19066_END*/

    RRM_UT_TRACE_ENTER();
    RRM_MEMSET(&rrc_rrm_erb_release_ind, RRM_ZERO,
                sizeof(rrc_rrm_erb_release_ind_t));

    rrc_rrm_erb_release_ind.ue_index = ue_index;
    /*SPR_19066_START*/
    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    if(RRM_PNULL != p_cell_context)
    {    
        for (drb_count = RRM_ZERO; drb_count < count; drb_count++)
        {
            rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
                erab_to_be_release_item[drb_count].erab_id = p_erab_id[drb_count];
            rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
                erab_to_be_release_item[drb_count].cause.type = type;
            rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
                erab_to_be_release_item[drb_count].cause.value = cause;
        }

        rrc_rrm_erb_release_ind.erab_to_be_released_item_list.count = count;
        for (qos_index = RRM_ZERO;
                (qos_index < p_cell_context->epc_info.epc_params.num_valid_qos_profiles) && 
                (qos_index < RRM_MAX_QCI) ; qos_index++)
        {
            if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].bitmask &
                    RRMCM_RMIF_UE_INACTIVE_TIMER_PRESENT)
            {
                /* Checking in already established RABs */
                for (drb_index = RRM_ZERO; (drb_index < p_ue_context->drb_configured.num_of_list) &&
                        (drb_index < RRM_MAX_NUM_DRB_PER_UE ) ; drb_index++)
                {
                    if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].qci == p_ue_context->drb_configured.erab_item[drb_index].erab_level_qos_params.qci)
                    {
                        if (p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config >
                                max_value_of_inactive_timer)
                        {
                            max_value_of_inactive_timer =
                                p_cell_context->epc_info.epc_params.qos_config_params[qos_index].ue_inactivity_timer_config;
                        }
                    }
                }
            }
        }
    }
    rrc_rrm_erb_release_ind.ue_inactive_time_config = (max_value_of_inactive_timer * (RRM_ONE_THOUSAND_MS));
    rrc_rrm_erb_release_ind.bitmask = RRM_ERB_RELEASE_IND_API_UE_INACTIVE_TIME_PRESENT;
    /*SPR_19066_END*/
    ret_val = rrm_il_send_rrc_rrm_erb_release_ind(
               &rrc_rrm_erb_release_ind,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                transaction_id,
                p_ue_context->cell_index);

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_admission_req 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg,p_s_tmsi
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission request 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_admission_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
        rrm_uem_s_tmsi_t s_tmsi
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_admission_req_t  rrc_rrm_ue_admission_req = {0};
    U32                         *p_establishment_cause = RRM_PNULL;
    U32                         index = RRM_NULL;
    RRM_UT_TRACE_ENTER();
    /**Parse the UE admission request */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_admission_req(
                    		&rrc_rrm_ue_admission_req,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
    {
        
    	p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_admission_req.ue_index;
		/** TO BE UPADTE LATER - when RRC will provide the cell index */
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        /* SPR 21251 Start */
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        /* SPR 21251 End */
        p_establishment_cause = (U32*)rrm_mem_get(sizeof(U32));

        /* Kshitij start Coverity, CID 16301 */
        if(RRM_PNULL == p_establishment_cause)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                      "rrm_ue_rrc_parse_ue_admission_req: Mem allocation failed");
            return RRM_FAILURE;
        }
        /*Kshitij_end*/
        *p_establishment_cause = rrc_rrm_ue_admission_req.establishment_cause;
        p_rrm_ue_rrc_msg->p_msg_data = p_establishment_cause;
//CP UE ATTACH FIX TO BE LOOKED 
// why no bitmask is checked before assigning??? 
        rrc_rrm_ue_admission_req.ue_identity.s_tmsi.mmec[RRM_ZERO] = 
            rrc_rrm_ue_admission_req.ue_identity.s_tmsi.mmec[RRM_ZERO] + 48;
        for ( index=RRM_ZERO;index<RRM_FOUR;index++)
        {
            rrc_rrm_ue_admission_req.ue_identity.s_tmsi.m_tmsi[index] = 
                rrc_rrm_ue_admission_req.ue_identity.s_tmsi.m_tmsi[index]+48;
        }
	/*BUG 680 fix start*/
	s_tmsi[RRM_ZERO] = rrc_rrm_ue_admission_req.ue_identity.s_tmsi.mmec[RRM_ZERO];
	for( index = RRM_ONE; index < M_TMSI_OCTET_SIZE; index++ )
	{
	s_tmsi[index] = rrc_rrm_ue_admission_req.ue_identity.s_tmsi.m_tmsi[index-RRM_ONE];
	}
	/*BUG 680 fix end*/

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d],S_TMSI [0x%x%x%x%x%x]" 
                " parsed RRC_RRM_UE_ADMISSION_REQ",p_rrm_ue_rrc_msg->ue_index,s_tmsi[RRM_ZERO],
                s_tmsi[RRM_ONE],s_tmsi[RRM_TWO],s_tmsi[RRM_THREE],s_tmsi[RRM_FOUR]);
        
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed parse RRC_RRM_UE_ADMISSION_REQ");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_inactive_ind
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   INPUT      : none
 *   DESCRIPTION:
 *       Parse the UE inactivity indication. 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_inactive_ind
(
	U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
)
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    rrc_rrm_inactive_ues_ind_t  rrc_inactive_ind = {RRM_ZERO};
    S32                         length_read = RRM_NULL;
    U16							index = RRM_NULL;
    
    RRM_UT_TRACE_ENTER();
    /** Parse the ue inactivity indication message */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_inactive_ues_ind(
                            &rrc_inactive_ind,
                            p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                            data_len,
                            &length_read))
    {
		p_rrm_ue_rrc_msg->num_of_inactive_ue = rrc_inactive_ind.num_of_inactive_ue;
        for(index = RRM_ZERO; index<rrc_inactive_ind.num_of_inactive_ue; index++)
        {
           p_rrm_ue_rrc_msg->num_of_inactive_ue_list[index] = rrc_inactive_ind.inactive_ue_info[index].ue_index;
        }
        
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                  "Successfully parsed inactive UES IND"); 
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "Failed parse RRC_RRM_INACTIVE_UES_IND");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_info_resp
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission cnf
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_info_resp(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_information_resp_t  *p_rrc_rrm_ue_information_resp = RRM_PNULL ;
    rrm_ue_info_resp_t              *p_rrm_ue_info_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ue_information_resp = (rrc_rrm_ue_information_resp_t *)\
                                      rrm_mem_get(sizeof(rrc_rrm_ue_information_resp_t));

    if( RRM_PNULL == p_rrc_rrm_ue_information_resp )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory "
        "for rrc_rrm_ue_information_resp_t ");
        return RRM_FAILURE;
    }
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_information_resp(
                 p_rrc_rrm_ue_information_resp,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {	
        p_rrm_ue_info_resp = (rrm_ue_info_resp_t *)rrm_mem_get(sizeof(rrm_ue_info_resp_t));

        if(RRM_PNULL == p_rrm_ue_info_resp)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    " Mem allocation failed");
            RRM_MEM_FREE(p_rrc_rrm_ue_information_resp);
            return RRM_FAILURE;
        }

        p_rrm_ue_rrc_msg->ue_index = p_rrc_rrm_ue_information_resp->ue_Index;
        /** TO BE UPADTE LATER - when RRC will provide the cell index */
        /*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        /*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        p_rrm_ue_info_resp->bitmask = RRM_ZERO;
        if( p_rrc_rrm_ue_information_resp->response == RRC_SUCCESS)
        {
            if( p_rrc_rrm_ue_information_resp->bitmask & RRC_UE_INFO_RACH_REPORT_PRESENT) 
            {
                p_rrm_ue_info_resp->bitmask |= RRM_UE_RACH_INFO_PRESENT;
                p_rrm_ue_info_resp->number_of_preambles_sent =
                    p_rrc_rrm_ue_information_resp->rach_report.no_of_preamables_sent;
                /* coverity : CID 41573 
                   info :  both api LHS and RHS are not same type. so RHS is strongly typecasted 
                   to enum for removing the warning*/
                p_rrm_ue_info_resp->contention_detected =  
                (rrm_bool_et) p_rrc_rrm_ue_information_resp->rach_report.contention_detected;
            }
        }
        p_rrm_ue_rrc_msg->p_msg_data = (void *)p_rrm_ue_info_resp;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                "[UE:%d],Successfully parsed UE "
                "INFO RESPONSE",p_rrm_ue_rrc_msg->ue_index);
        ret_val = RRM_SUCCESS;
    }
    else
    {
        /*Cov_fix_start_54424*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "UE Failed to parse UE INFO RESPONSE");
        /*Cov_fix_end_54424*/
        ret_val = RRM_FAILURE;
    }

    RRM_MEM_FREE( p_rrc_rrm_ue_information_resp );
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_16053_Fix: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_reestab_complete_ind
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE re-establishment complete ind
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
    rrm_return_et
rrm_ue_rrc_parse_ue_reestab_complete_ind(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    S32                                 length_read = RRM_NULL;
    rrc_rrm_ue_reestab_complete_ind_t   rrc_rrm_ue_reestab_complete_ind = {RRM_ZERO};
    U8                                  *p_response = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    if( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_reestab_complete_ind(
                 &rrc_rrm_ue_reestab_complete_ind,
                 p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                 data_len,
                 &length_read))
    {

        p_response = (U8 *)rrm_mem_get(sizeof(U8));

        if(RRM_PNULL == p_response)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    " Mem allocation failed");
            return RRM_FAILURE;
        }

        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_reestab_complete_ind.ue_index;
/*SPR 21653 changes start*/
        p_rrm_ue_rrc_msg->cell_index =  rrc_rrm_ue_reestab_complete_ind.cell_index;
/*SPR 21653 changes end*/

        *p_response = rrc_rrm_ue_reestab_complete_ind.response;

        p_rrm_ue_rrc_msg->p_msg_data = p_response;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d],Successfully parsed UE RE-ESTABLISHMENT IND with response code [%d] [%p]",
                p_rrm_ue_rrc_msg->ue_index, *p_response, (U8 *)p_rrm_ue_rrc_msg->p_msg_data);
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "[UE:%d],Failed to parse UE RE-ESTABLISHMENT IND",
                 p_rrm_ue_rrc_msg->ue_index);
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR_16053_Fix: End */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_reestab_config_req
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE re-establishment req
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_reestab_config_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et                     ret_val = RRM_SUCCESS;
    S32                               length_read = RRM_NULL;
    rrc_rrm_ue_reestab_config_req_t   rrc_rrm_ue_reestab_config = {RRM_ZERO};

    /*ho_report_change start */
   
    /* SPR 20652 Fix Start */
    /* Code removed */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_ENTER();

    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_reestab_config_req(
                       &rrc_rrm_ue_reestab_config,
                       p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                       data_len,
                       &length_read))
    {	

        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_reestab_config.ue_index;
        /*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        /*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                "[UE:%d],Successfully parsed UE "
                "RE-ESTABLISHMENT REQ",p_rrm_ue_rrc_msg->ue_index);

        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
                p_rrm_ue_rrc_msg->cell_index);

        if(RRM_PNULL != p_ue_context)
        {
            /* Ho report to  son is  sent from here in case of  too early ho failure */
            /*SPR 17777 +-*/
            if( RRM_SUCCESS ==  rrm_fill_reestab_ho_failure_report(p_ue_context))
            {
                /* SPR 20652 Fix End */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                        "[UE:%d],Successfully sent ho report in case of too early ho failure " 
                        ,p_rrm_ue_rrc_msg->ue_index);
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                    "UE context not found");
        }
        /*ho_report_change end */
    }
    else
    {
        /*Cov_fix_start_54424*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "UE Failed to parse UE RE-ESTABLISHMENT REQ");
        /*Cov_fix_end_54424*/
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_sync_status
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission cnf
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_sync_status(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_sync_status_t    rrc_rrm_ue_sync_status = {RRM_ZERO};
    U32                          *p_sync_status= RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_sync_status(
                       &rrc_rrm_ue_sync_status,
                       p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                       data_len,
                       &length_read))
    {	
        p_sync_status = (U32 *)rrm_mem_get(sizeof(U32));

        if(RRM_PNULL == p_sync_status)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    " Mem allocation failed");
            return RRM_FAILURE;
        }

        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_sync_status.ue_index;
        /** TO BE UPADTE LATER - when RRC will provide the cell index */
        /*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        /*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);

        *p_sync_status = rrc_rrm_ue_sync_status.rrc_rrm_ue_sync_status;
        p_rrm_ue_rrc_msg->p_msg_data = (void *)p_sync_status;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                "[UE:%d],Successfully parsed UE "
                "SYNC STATUS",p_rrm_ue_rrc_msg->ue_index);
        ret_val = RRM_SUCCESS;

    }
    else
    {
        /*Cov_fix_start_54424*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "Failed to parse UE SYNC STATUS"); 
        /*Cov_fix_end_54424*/
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_admission_cnf 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission cnf
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_admission_cnf(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_admission_cnf_t  rrc_rrm_admission_cnf = {RRM_ZERO};
    U8                          *p_response = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    /**Parse the UE admission cnf */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_admission_cnf(
                    		&rrc_rrm_admission_cnf,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
    {	
    	p_response = (U8 *)rrm_mem_get(sizeof(U8));

        /*Kshitij_start CID:16300*/
        if(RRM_PNULL == p_response)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                      "rrm_ue_rrc_parse_ue_admission_cnf: Mem allocation failed");
            return RRM_FAILURE;
        }
        /*Kshitij_end*/

        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_admission_cnf.ue_index;
		/** TO BE UPADTE LATER - when RRC will provide the cell index */
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/

        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);

	    *p_response = rrc_rrm_admission_cnf.response;
        p_rrm_ue_rrc_msg->p_msg_data = p_response;
        ret_val = RRM_SUCCESS;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_UE_ADMISSION_CNF:[UE:%d] with response:%d",
                p_rrm_ue_rrc_msg->ue_index, rrc_rrm_admission_cnf.response);
        /* Raising Event - LOCAL_RRC_CONN_SETUP_READY START*/
        rrm_raise_event_rrc_setup_ready();/*SPR 17777 +-*/
        /* Raising Event - LOCAL_RRC_CONN_SETUP_READY END*/
   }
   	else
   	{
       /*Cov_fix_54424*/
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_UE_ADMISSION_CNF->UEM failed to process");
       ret_val = RRM_FAILURE;
       /*Cov_fix_54424*/
   	}
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_release_req 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission request 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_release_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_release_req_t    rrc_rrm_ue_release_req = {RRM_ZERO};
    /* CSR-79374[SPR-11578]-fix start */
    rrm_ue_release_req_t        *p_rrc_rrm_ue_release_req = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    /**Parse the UE release request */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_release_req(
                &rrc_rrm_ue_release_req,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_release_req.ue_index;
        /** TO BE UPADTE LATER - when RRC will provide the cell index */
        /*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        /*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
              "RRC->UEM:RRC_RRM_UE_RELEASE_REQ successfully parsed");
        p_rrc_rrm_ue_release_req = (rrm_ue_release_req_t *)
            rrm_mem_get(sizeof(rrm_ue_release_req_t));

        if (RRM_PNULL == p_rrc_rrm_ue_release_req)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
            RRM_UT_TRACE_EXIT();    
            return RRM_FAILURE;
        }
        if(rrc_rrm_ue_release_req.bitmask & RRC_RRM_UE_RELEASE_CAUSE_PRESENCE_FLAG)
        {
            p_rrc_rrm_ue_release_req->bitmask        = RRM_ZERO;
            p_rrc_rrm_ue_release_req->bitmask       |= RRM_UE_RELEASE_CAUSE_PRESENCE_FLAG;
            p_rrc_rrm_ue_release_req->cause.type     = rrc_rrm_ue_release_req.cause.type;
            p_rrc_rrm_ue_release_req->cause.value    = rrc_rrm_ue_release_req.cause.value;
        }
        p_rrm_ue_rrc_msg->p_msg_data = p_rrc_rrm_ue_release_req;
        /* CSR-79374[SPR-11578]-fix end */
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed parse RRC_RRM_UE_RELEASE_REQ");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();    
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_populate_capability_meas_params
 *   INPUT      : p_rrm_meas,p_rrc_meas
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Populate the ue capability meas parameter received UE Capability Ind
 *		 from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
static rrm_return_et
rrm_ue_populate_capability_meas_params (
		rrm_ue_meas_parameters_t	*p_rrm_meas,
		meas_pameters_t				*p_rrc_meas
	)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	U8 eutra_index = RRM_ZERO;
        U8 eutra_count = RRM_ZERO;
	U8 freq_band_index = RRM_ZERO;
        U8 freq_band_count = RRM_ZERO;
	U8 rat_band_index = RRM_ZERO; 
        U8 rat_band_count = RRM_ZERO;

	if (RRM_PNULL != p_rrm_meas && RRM_PNULL != p_rrc_meas)
	{
		p_rrm_meas->band_list_eutra.count = eutra_count = 
			p_rrc_meas->band_list_eutra.count;
                /* SPR 21496 Fix Start */
                p_rrm_meas->band_list_eutra.p_band_info_eutra = (rrm_ue_band_info_eutra_t*)rrm_mem_get(eutra_count * sizeof(rrm_ue_band_info_eutra_t));
                if(RRM_PNULL != p_rrm_meas->band_list_eutra.p_band_info_eutra)
                {
                        for (eutra_index = RRM_ZERO; eutra_index < eutra_count; ++eutra_index)
                        {
                              p_rrm_meas->band_list_eutra.p_band_info_eutra[eutra_index].bitmask = RRM_ZERO;
                              p_rrm_meas->band_list_eutra.p_band_info_eutra[eutra_index].inter_freq_band_list.count = freq_band_count =
                                p_rrc_meas->band_list_eutra.band_info_eutra[eutra_index].inter_freq_band_list.count;
                              for (freq_band_index = RRM_ZERO; freq_band_index < freq_band_count; ++freq_band_index)
                              {
                                    p_rrm_meas->band_list_eutra.p_band_info_eutra[eutra_index].
                                          inter_freq_band_list.inter_freq_band_info[freq_band_index].inter_freq_need_for_gaps = 
                                          p_rrc_meas->band_list_eutra.band_info_eutra[eutra_index].
                                          inter_freq_band_list.inter_freq_band_info[freq_band_index].inter_freq_need_for_gaps;
                              }
                              if (p_rrc_meas->band_list_eutra.band_info_eutra[eutra_index].bitmask & EUTRA_INTER_RAT_BAND_LIST_PRESENT)
                              {
                                    p_rrm_meas->band_list_eutra.p_band_info_eutra[eutra_index].bitmask |= RRM_UE_EUTRA_INTER_RAT_BAND_LIST_PRESENT;
                                    p_rrm_meas->band_list_eutra.p_band_info_eutra[eutra_index].inter_rat_band_list.count = rat_band_count =
                                          p_rrc_meas->band_list_eutra.band_info_eutra[eutra_index].inter_rat_band_list.count;
                                    for (rat_band_index = RRM_ZERO; rat_band_index < rat_band_count; ++rat_band_index)
                                    {
                                            p_rrm_meas->band_list_eutra.p_band_info_eutra[eutra_index].
                                                    inter_rat_band_list.inter_rat_band_info[rat_band_index].inter_rat_need_for_gaps = 
                                                    p_rrc_meas->band_list_eutra.band_info_eutra[eutra_index].
                                                    inter_rat_band_list.inter_rat_band_info[rat_band_index].inter_rat_need_for_gaps;
                                    }
                              }
                        }
                }
                else
                {
		  /* SPR 21768 Fix Start */
                  RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                      "Failed to allocate memory to p_band_info_eutra");
		  /* SPR 21768 Fix End */
                  RRM_UT_TRACE_EXIT();
                  return RRM_FAILURE;
                }
                /* SPR 21496 Fix End */
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Invalid Arguments[p_rrm_meas = %p, p_rrc_meas = %p] passed",
                p_rrm_meas, p_rrc_meas);
        ret_val = RRM_FAILURE;
	}
	return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_access_stratum_release_info
 *   INPUT      : p_rrm_uem_acc_st_rel
 *   OUTPUT     : rrc_acc_st_rel
 *   DESCRIPTION: Fill access stratum release info from RRC to ue Ctxt.
 *   RETURNS: none 
 *       
 *       
 *****************************************************************************/
void rrm_uem_fill_access_stratum_release_info(U8     rrc_acc_st_rel, 
                                              rrm_ue_access_stratum_release_et  *p_rrm_uem_acc_st_rel)
{
  RRM_UT_TRACE_ENTER();
 
  switch (rrc_acc_st_rel)
  {
   case RRM_ZERO:
    *p_rrm_uem_acc_st_rel = RRM_REL8;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
               RRM_INFO, "Access stratum RRM_REL8");
    break;   

   case RRM_ONE:
    *p_rrm_uem_acc_st_rel = RRM_REL9;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
               RRM_INFO, "Access stratum RRM_REL9");
    break;   

   case RRM_TWO:
    *p_rrm_uem_acc_st_rel = RRM_REL10;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
               RRM_INFO, "Access stratum RRM_REL10");
    break;   

   case RRM_THREE:
    *p_rrm_uem_acc_st_rel = RRM_REL11;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
               RRM_INFO, "Access stratum RRM_RELSPARE5");
    break;   

   case RRM_FOUR:
    *p_rrm_uem_acc_st_rel = RRM_REL12;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
               RRM_INFO, "Access stratum RRM_RELSPARE4");
    break;   

   case RRM_FIVE:
    *p_rrm_uem_acc_st_rel = RRM_REL13;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
               RRM_INFO, "Access stratum RRM_RELSPARE3");
    break;   

   case RRM_SIX:
    *p_rrm_uem_acc_st_rel = RRM_RELSPARE2;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                RRM_INFO, "Access stratum RRM_RELSPARE2");
    break;

   case RRM_SEVEN:
    *p_rrm_uem_acc_st_rel = RRM_RELSPARE1;
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
               RRM_INFO, "Access stratum RRM_RELSPARE1");
    break;

   default:
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
              "Invalid access stratum release %d", rrc_acc_st_rel);
    break; 
  }/*switch case end*/
 
  RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_rohc_profile_info
 *   INPUT      : p_rrc_rohc_profile
 *   OUTPUT     : p_rrm_rohc_profile
 *   DESCRIPTION: Fill RoHC profile received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *
 *****************************************************************************/
void rrm_uem_fill_rohc_profile_info(rrm_ue_pdcp_rohc_profile_t  *p_rrm_rohc_profile,
                                    rrc_pdcp_rohc_profile_t     *p_rrc_rohc_profile)
{
 RRM_UT_TRACE_ENTER();
 
 /*profile 1*/
 p_rrm_rohc_profile->profile0x0001 = p_rrc_rohc_profile->profile0x0001; 
 /*profile 2*/
 p_rrm_rohc_profile->profile0x0002 = p_rrc_rohc_profile->profile0x0002; 
 /*profile 3*/
 p_rrm_rohc_profile->profile0x0003 = p_rrc_rohc_profile->profile0x0003; 
 /*profile 4*/
 p_rrm_rohc_profile->profile0x0004 = p_rrc_rohc_profile->profile0x0004; 
 /*profile 6*/
 p_rrm_rohc_profile->profile0x0006 = p_rrc_rohc_profile->profile0x0006; 
 /*profile 101*/
 p_rrm_rohc_profile->profile0x0101  = p_rrc_rohc_profile->profile0x0101; 
 /*profile 102*/
 p_rrm_rohc_profile->profile0x0102 = p_rrc_rohc_profile->profile0x0102; 
 /*profile 103*/
 p_rrm_rohc_profile->profile0x0103 = p_rrc_rohc_profile->profile0x0103; 
 /*profile 104*/
 p_rrm_rohc_profile->profile0x0104 = p_rrc_rohc_profile->profile0x0104; 

 RRM_UT_TRACE_EXIT();
}

/*klock_works_changes_start*/
    void
rrc_max_ctxt_session_lower_range(U8 rrc_max_ctxt_session, rrm_ue_max_num_rohc_context_session_et *p_rrm_max_ctxt_session)
{
    /*CID 65760:start*/
    RRM_UT_TRACE_ENTER();
    switch(rrc_max_ctxt_session)
    {
        case RRM_ZERO:
            *p_rrm_max_ctxt_session = RRM_UE_CS2;
            break;
        case RRM_ONE:
            *p_rrm_max_ctxt_session = RRM_UE_CS4;
            break;
        case RRM_TWO:
            *p_rrm_max_ctxt_session = RRM_UE_CS8;
            break;
        case RRM_THREE:
            *p_rrm_max_ctxt_session =RRM_UE_CS12;
            break;
        case RRM_FOUR:
            *p_rrm_max_ctxt_session =RRM_UE_CS16;
            break;
        case RRM_FIVE:
            *p_rrm_max_ctxt_session = RRM_UE_CS24;
            break;
        case RRM_SIX:
            *p_rrm_max_ctxt_session = RRM_UE_CS32;
            break;
        case RRM_SEVEN:
            *p_rrm_max_ctxt_session = RRM_UE_CS48;
            break;

        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Invalid max context session %d", rrc_max_ctxt_session);
            break;
    }/*switch case ends*/

    RRM_UT_TRACE_EXIT();
    /*CID 65760:end*/

}

void
rrc_max_ctxt_session_higher_range(U8 rrc_max_ctxt_session, rrm_ue_max_num_rohc_context_session_et *p_rrm_max_ctxt_session)
{

    RRM_UT_TRACE_ENTER();
    switch(rrc_max_ctxt_session)
    {
    case RRM_EIGHT:
    *p_rrm_max_ctxt_session = RRM_UE_CS64;
     break;
    case RRM_NINE:
    *p_rrm_max_ctxt_session = RRM_UE_CS128;
     break;
    case RRM_TEN:
    *p_rrm_max_ctxt_session = RRM_UE_CS256;
     break;
    case RRM_ELEVEN:
    *p_rrm_max_ctxt_session = RRM_UE_CS512;
     break;
    case RRM_TWELVE:
    *p_rrm_max_ctxt_session = RRM_UE_CS1024;
     break;
    case RRM_THIRTEEN:
    *p_rrm_max_ctxt_session = RRM_UE_CS16384;
     break;
    case RRM_FOURTEEN:
    *p_rrm_max_ctxt_session = RRM_UE_SPARE2;
     break;
    case RRM_FIFTEEN:
    *p_rrm_max_ctxt_session = RRM_UE_SPARE1;
     break;

    default:
     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
              "Invalid max context session %d", rrc_max_ctxt_session);
     break;
  }/*switch case ends*/

 RRM_UT_TRACE_EXIT();
}
/*klock_works_changes_end*/




/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_rohc_max_cntxt_session_info
 *   INPUT      : rrc_max_ctxt_session
 *   OUTPUT     : p_rrm_max_ctxt_session
 *   DESCRIPTION: Fill Max context session received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *****************************************************************************/
void rrm_uem_fill_rohc_max_cntxt_session_info(rrm_ue_max_num_rohc_context_session_et *p_rrm_max_ctxt_session,
                                              U8                                      rrc_max_ctxt_session)
{
 RRM_UT_TRACE_ENTER();
 /*klock_works_changes_start*/
 if (rrc_max_ctxt_session<= RRM_SEVEN)
 {
     rrc_max_ctxt_session_lower_range(rrc_max_ctxt_session,p_rrm_max_ctxt_session);
 }
 else
 {
     rrc_max_ctxt_session_higher_range(rrc_max_ctxt_session,p_rrm_max_ctxt_session);
 }
 /*klock_works_changes_end*/

  
 RRM_UT_TRACE_EXIT();
}

/*klock_works_changes_start*/
void rrm_uem_fill_geran_supported_band_info_higher_range(
        rrm_ue_supported_band_geran_et *p_rrm_supported_band,
        U8                             rrc_supported_band)
{
    /*CID 65757:start*/
    RRM_UT_TRACE_ENTER();

    switch(rrc_supported_band)
    {
        case geran_gsm900R:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_900_R;
            break;

        case geran_gsm1800:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_1800;
            break;

        case geran_gsm1900:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_1900;
            break;

        case geran_spare5:
            *p_rrm_supported_band = RRM_UE_GERAN_SPARE5;
            break;

        case geran_spare4:
            *p_rrm_supported_band = RRM_UE_GERAN_SPARE4;
            break;

        case geran_spare3:
            *p_rrm_supported_band = RRM_UE_GERAN_SPARE3;
            break;

        case geran_spare2:
            *p_rrm_supported_band = RRM_UE_GERAN_SPARE2;
            break;

        case geran_spare1:
            *p_rrm_supported_band = RRM_UE_GERAN_SPARE1;
            break;

        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid RRC supported band %d", rrc_supported_band); 
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
    /*CID 65757:end*/
} 


void rrm_uem_fill_geran_supported_band_info_lower_range(
        rrm_ue_supported_band_geran_et *p_rrm_supported_band,
        U8                             rrc_supported_band)
{
    RRM_UT_TRACE_ENTER();

    switch(rrc_supported_band)
    {
        case geran_gsm450:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_450;
            break;

        case geran_gsm480:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_480;
            break;

        case geran_gsm710:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_710;
            break;

        case geran_gsm750:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_750;
            break;

        case geran_gsm810:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_810;
            break;

        case geran_gsm850:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_850;
            break;

        case geran_gsm900P:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_900_P;
            break;

        case geran_gsm900E:
            *p_rrm_supported_band = RRM_UE_GERAN_GSM_900_E;
            break;
        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid RRC supported band %d", rrc_supported_band);
            break;
    }/*switch ends here*/

   RRM_UT_TRACE_EXIT();
}

/*klock_works_changes_end*/    
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_geran_supported_band_info
 *   INPUT      : rrc_supported_band
 *   OUTPUT     : p_rrm_supported_band
 *   DESCRIPTION: Fill Geran supported Band received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *****************************************************************************/
void rrm_uem_fill_geran_supported_band_info(
                    rrm_ue_supported_band_geran_et *p_rrm_supported_band, 
                    U8                             rrc_supported_band)
{
    RRM_UT_TRACE_ENTER();
      
    /*klock_works_changes_start*/  
    if(rrc_supported_band<=RRM_UE_GERAN_GSM_900_E)
      {
        rrm_uem_fill_geran_supported_band_info_lower_range(p_rrm_supported_band, rrc_supported_band);  
      }
    else 
      {
       rrm_uem_fill_geran_supported_band_info_higher_range(p_rrm_supported_band, rrc_supported_band);   
      }
     /*klock_works_changes_end*/

   RRM_UT_TRACE_EXIT();
} 
/* SPR 10497 Fix */                    
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_utra_tdd128_supported_band_info
 *   INPUT      : rrc_supported_band
 *   OUTPUT     : p_rrm_supported_band
 *   DESCRIPTION: Fill Utra TDD128 supported Band received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *****************************************************************************/
void rrm_uem_fill_utra_tdd128_supported_band_info(
                    rrm_ue_supported_band_utra_tdd128_et  *p_rrm_supported_band, 
                    U8                                     rrc_supported_band)
{
    RRM_UT_TRACE_ENTER();

    switch(rrc_supported_band)
    {
        case tdd128_a:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_A;
            break;

        case tdd128_b:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_B;
            break;

        case tdd128_c:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_C;
            break;

        case tdd128_d:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_D;
            break;

        case tdd128_e:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_E;
            break;

        case tdd128_f:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_F;
            break;

        case tdd128_g:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_G;
            break;

        case tdd128_h:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_H;
            break;

        case tdd128_i:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_I;
            break;

        case tdd128_j:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_J;
            break;

        case tdd128_k:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_K;
            break;

        case tdd128_l:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_L;
            break;

        case tdd128_m:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_M;
            break;

        case tdd128_n:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_N;
            break;

        case tdd128_o:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_O;
            break;

        case tdd128_p:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_128_P;
            break;

        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid RRC supported band %d", rrc_supported_band); 
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
} 


/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_utra_tdd384_supported_band_info
 *   INPUT      : rrc_supported_band
 *   OUTPUT     : p_rrm_supported_band
 *   DESCRIPTION: Fill Utra tdd384 supported Band received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *****************************************************************************/
void rrm_uem_fill_utra_tdd384_supported_band_info(
                    rrm_ue_supported_band_utra_tdd384_et  *p_rrm_supported_band, 
                    U8                                     rrc_supported_band)
{
    RRM_UT_TRACE_ENTER();

    switch(rrc_supported_band)
    {
        case tdd384_a:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_A;
            break;

        case tdd384_b:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_B;
            break;

        case tdd384_c:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_C;
            break;

        case tdd384_d:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_D;
            break;

        case tdd384_e:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_E;
            break;

        case tdd384_f:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_F;
            break;

        case tdd384_g:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_G;
            break;

        case tdd384_h:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_H;
            break;

        case tdd384_i:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_I;
            break;

        case tdd384_j:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_J;
            break;

        case tdd384_k:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_K;
            break;

        case tdd384_l:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_L;
            break;

        case tdd384_m:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_M;
            break;

        case tdd384_n:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_N;
            break;

        case tdd384_o:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_O;
            break;

        case tdd384_p:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_384_P;
            break;

        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid RRC supported band %d", rrc_supported_band); 
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
} 

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_utra_tdd768_supported_band_info
 *   INPUT      : rrc_supported_band
 *   OUTPUT     : p_rrm_supported_band
 *   DESCRIPTION: Fill Utra tdd768 supported Band received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *****************************************************************************/
void rrm_uem_fill_utra_tdd768_supported_band_info(
                    rrm_ue_supported_band_utra_tdd768_et  *p_rrm_supported_band, 
                    U8                                     rrc_supported_band)
{
    RRM_UT_TRACE_ENTER();

    switch(rrc_supported_band)
    {
        case tdd768_a:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_A;
            break;

        case tdd768_b:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_B;
            break;

        case tdd768_c:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_C;
            break;

        case tdd768_d:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_D;
            break;

        case tdd768_e:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_E;
            break;

        case tdd768_f:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_F;
            break;

        case tdd768_g:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_G;
            break;

        case tdd768_h:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_H;
            break;

        case tdd768_i:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_I;
            break;

        case tdd768_j:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_J;
            break;

        case tdd768_k:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_K;
            break;

        case tdd768_l:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_L;
            break;

        case tdd768_m:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_M;
            break;

        case tdd768_n:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_N;
            break;

        case tdd768_o:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_O;
            break;

        case tdd768_p:
            *p_rrm_supported_band = RRM_UE_UTRA_TDD_768_P;
            break;

        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid RRC supported band %d", rrc_supported_band); 
            break;
    }/*switch ends here*/

    RRM_UT_TRACE_EXIT();
} 
/* SPR 10497 Fix */                    

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_utra_fdd_supported_band_info
 *   INPUT      : rrc_supported_band
 *   OUTPUT     : p_rrm_supported_band
 *   DESCRIPTION: Fill Utra FDD supported Band received from RRC to ue Ctxt.
 *   RETURNS: none 
 *
 *****************************************************************************/
void rrm_uem_fill_utra_fdd_supported_band_info(rrm_ue_supported_band_utra_fdd_et  *p_rrm_supported_band, U8  rrc_supported_band)
{
 RRM_UT_TRACE_ENTER();

 switch(rrc_supported_band)
  {
   case utra_fdd_bandI:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDI;
    break;

   case utra_fdd_bandII:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDII;
    break;

   case utra_fdd_bandIII:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDIII;
    break;

   case utra_fdd_bandIV:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDIV;
    break;

   case utra_fdd_bandV:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDV;
    break;

   case utra_fdd_bandVI:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDVI;
    break;

   case utra_fdd_bandVII:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDVII;
    break;

   case utra_fdd_bandVIII:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDVIII;
    break;

   case utra_fdd_bandIX:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDIX;
    break;

   case utra_fdd_bandX:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDX;
    break;

   case utra_fdd_bandXI:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXI;
    break;

   case utra_fdd_bandXII:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXII;
    break;

   case utra_fdd_bandXIII:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXIII;
    break;

   case utra_fdd_bandXIV:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXIV;
    break;

   case utra_fdd_bandXV:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXV;
    break;

   case utra_fdd_bandXVI:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXVI;
    break;

   case utra_fdd_bandXVII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXVII_8A0;
    break;

   case utra_fdd_bandXVIII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXVIII_8A0;
    break;

   case utra_fdd_bandXIX_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXIX_8A0;
    break;

   case utra_fdd_bandXX_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXX_8A0;
    break;

   case utra_fdd_bandXXI_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXI_8A0;
    break;

   case utra_fdd_bandXXII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXII_8A0;
    break;

   case utra_fdd_bandXXIII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXIII_8A0;
    break;

   case utra_fdd_bandXXIV_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXIV_8A0;
    break;

   case utra_fdd_bandXXV_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXV_8A0;
    break;

   case utra_fdd_bandXXVI_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXVI_8A0;
    break;

   case utra_fdd_bandXXVII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXVII_8A0;
    break;

   case utra_fdd_bandXXVIII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXVIII_8A0;
    break;

   case utra_fdd_bandXXIX_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXIX_8A0;
    break;

   case utra_fdd_bandXXX_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXX_8A0;
    break;

   case utra_fdd_bandXXXI_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXXI_8A0;
    break;

   case utra_fdd_bandXXXII_8a0:
    *p_rrm_supported_band = RRM_UE_UTRA_FDD_BANDXXXII_8A0;
    break;
 
   default:
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
              "Invalid RRC supported band %d", rrc_supported_band); 
    break;
  }/*switch ends here*/

 RRM_UT_TRACE_EXIT();
} 
/* Coverity_fix_start_62566 */
/******************************************************************************
 *   FUNCTION NAME: get_rrm_ca_band_width_class_r10
 *   INPUT      : ca_band_width_class_ul_dl_r10
 *   OUTPUT     : None
 *   DESCRIPTION:
 *        Map RRC ca bw class to RRM bw class 
 *   RETURNS: none
 *****************************************************************************/
/*Coverity 62607 62611 Fix:start*/
rrm_ca_band_width_class_r10_et get_rrm_ca_band_width_class_r10
/*Coverity 62607 62611 Fix:end*/
(
/*Coverity 62598 62599 62600 62601 62602 62603 Fix:start*/ 
     U8 ca_band_width_class_ul_dl_r10
/*Coverity 62598 62599 62600 62601 62602 62603 Fix:end*/ 
)
{
    rrm_ca_band_width_class_r10_et rrm_ca_band_width_class_ul_r10 = rrm_bw_a;
    switch(ca_band_width_class_ul_dl_r10)
    {
	case bw_a:
	    rrm_ca_band_width_class_ul_r10 = rrm_bw_a; 
	    break;
	case bw_b:
	    rrm_ca_band_width_class_ul_r10 = rrm_bw_b;
	    break;
	case bw_c:
	    rrm_ca_band_width_class_ul_r10 = rrm_bw_c;
	    break;
	case bw_d:
	    rrm_ca_band_width_class_ul_r10 = rrm_bw_d;
	    break;
	case bw_e:
	    rrm_ca_band_width_class_ul_r10 = rrm_bw_e;
	    break;
	case bw_f:
	    rrm_ca_band_width_class_ul_r10 = rrm_bw_f;
	    break;
	default:
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Invalid ca_band_width_class_r10 value %d", ca_band_width_class_ul_dl_r10);
            break; 
    }/*end of switch*/
    return rrm_ca_band_width_class_ul_r10;
}
/* Coverity_fix_end_62566 */

/* Coverity_fix_start_62565 */
/******************************************************************************
 *   FUNCTION NAME: get_supported_mimo_capability_dl_r10
 *   INPUT      : supported_mimo_capability_dl_r10
 *   OUTPUT     : None
 *   DESCRIPTION: Map RRC supp. mimo dl capa to RRM supp. mimo dl capa.
 *   RETURNS: none
 *****************************************************************************/

rrm_mimo_capability_dl_r10_et get_supported_mimo_capability_dl_r10
(
/*Coverity 62604 62605 62606 Fix:start*/
     U8 supported_mimo_capability_dl_r10
/*Coverity 62604 62605 62606 Fix:start*/
)
{
    rrm_mimo_capability_dl_r10_et rrm_supported_mimo_capability_dl_r10 = RRM_DL_TWO_LAYERS;
    switch(supported_mimo_capability_dl_r10)
    {
	case DL_TWO_LAYERS:
	    rrm_supported_mimo_capability_dl_r10 = RRM_DL_TWO_LAYERS;
	    break;
	case DL_FOUR_LAYERS:
	    rrm_supported_mimo_capability_dl_r10 = RRM_DL_FOUR_LAYERS;
	    break;
	case DL_EIGHT_LAYERS:
	    rrm_supported_mimo_capability_dl_r10 = RRM_DL_EIGHT_LAYERS;
	    break;
	default:
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Invalid supported_mimo_capability_dl_r10 value %d", supported_mimo_capability_dl_r10);
	    break;
    }/*End of Switch*/
    return rrm_supported_mimo_capability_dl_r10;
}
/* Coverity_fix_end_62565 */
/******************************************************************************
 *   FUNCTION NAME: get_supported_mimo_capability_ul_r10
 *   INPUT      : supported_mimo_capability_ul_r10
 *   OUTPUT     : None
 *   DESCRIPTION: Map RRC supp. mimo ul capa to RRM supp. mimo ul capa.
 *   RETURNS: none
 *****************************************************************************/
rrm_mimo_capability_ul_r10_et get_supported_mimo_capability_ul_r10
(
/*Coverity 62564 Fix:start*/
  U8 supported_mimo_capability_ul_r10
/*Coverity 62564 Fix:end*/
 )
{
    rrm_mimo_capability_ul_r10_et rrm_supported_mimo_capability_ul_r10 = RRM_UL_TWO_LAYERS;
    switch(supported_mimo_capability_ul_r10)
    {
	case UL_TWO_LAYERS:
	    rrm_supported_mimo_capability_ul_r10 = RRM_UL_TWO_LAYERS;
	    break;
	case UL_FOUR_LAYERS:
	    rrm_supported_mimo_capability_ul_r10 = RRM_UL_FOUR_LAYERS;
	    break;
	default:
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Invalid supported_mimo_capability_ul_r10 value %d", supported_mimo_capability_ul_r10);
	    break;
    }/*End of Switch*/
    return rrm_supported_mimo_capability_ul_r10;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_extract_r10_rf_params
 *   INPUT      : p_rrm_rf_param_v1020_ies, p_rf_param_v1020
 *   OUTPUT     : None
 *   DESCRIPTION:
 *        Populate the v1020 rf_params received in ue capability params 
 *        received in UE Capability Ind from RRC & store in UE context.
 *   RETURNS: none
 *****************************************************************************/

void
rrm_extract_r10_rf_params(
    rrm_rf_parameters_v1020_ies_t *p_rrm_rf_param_v1020_ies,
    rf_parameters_v1020_ies_t     *p_rf_param_v1020)
{
    /* SPR 21496 Fix Start */
    U8 supp_band_comb_count = RRM_ZERO;
    U8 band_param_count = RRM_ZERO;
    U8 ca_mimo_param_count = RRM_ZERO;

    p_rrm_rf_param_v1020_ies->supported_band_combination_r10.count = 
        p_rf_param_v1020->supported_band_combination_r10.count;

    p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10 = 
        rrm_mem_get(p_rrm_rf_param_v1020_ies->supported_band_combination_r10.count * sizeof(rrm_band_combination_parameters_r10_t));

    if(RRM_PNULL != p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10)
    {
    for(supp_band_comb_count = RRM_ZERO; supp_band_comb_count < (p_rf_param_v1020->supported_band_combination_r10.count); supp_band_comb_count++)
    {
            p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].count = 
            p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].count;

            p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].p_band_parameters_info = 
                rrm_mem_get(p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].count * sizeof(rrm_band_parameters_r10_t));
            if(RRM_PNULL != p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].p_band_parameters_info)
            {
        for(band_param_count = RRM_ZERO;
             band_param_count < p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].count;
               band_param_count++)
        {
            p_rrm_rf_param_v1020_ies->supported_band_combination_r10.
                        p_band_combination_parameters_r10[supp_band_comb_count].p_band_parameters_info[band_param_count].band_eutra_r10 = 
            p_rf_param_v1020->supported_band_combination_r10.
                band_combination_parameters_r10[supp_band_comb_count].band_parameters_info[band_param_count].band_eutra_r10;

                    if( p_rf_param_v1020->supported_band_combination_r10.\
                            band_combination_parameters_r10[supp_band_comb_count].band_parameters_info[band_param_count].\
                            bitmask & RRC_RRM_BAND_PARAMETERS_UL_R10_IES_PRESENT)
                    {
                        p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].\
                            p_band_parameters_info[band_param_count].bitmask |= RRM_BAND_PARAMETERS_UL_R10_IES_PRESENT;

                        p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                            p_band_parameters_info[band_param_count].band_parameters_ul_r10.count = 
                            p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].
                            band_parameters_info[band_param_count].band_parameters_ul_r10.count;  

                        for(ca_mimo_param_count = RRM_ZERO;
                                ca_mimo_param_count < p_rf_param_v1020->supported_band_combination_r10.
                                band_combination_parameters_r10[supp_band_comb_count].
                                band_parameters_info[band_param_count].band_parameters_ul_r10.count;
                                ca_mimo_param_count++)
                        {
                            /* CID: 61291 -62566 Fix */
                            /* SPR 21496 Fix Start*/
                            p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                                p_band_parameters_info[band_param_count].band_parameters_ul_r10.
                                ca_mimo_parameters_ul_r10[ca_mimo_param_count].ca_band_width_class_ul_r10 =  
                                get_rrm_ca_band_width_class_r10(p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].
                                        band_parameters_info[band_param_count].band_parameters_ul_r10.
                                        ca_mimo_parameters_ul_r10[ca_mimo_param_count].ca_band_width_class_ul_r10);

                            if(p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].\
                                    band_parameters_info[band_param_count].band_parameters_ul_r10.
                                    ca_mimo_parameters_ul_r10[ca_mimo_param_count].bitmask & RRC_RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT)
                            {
                                /* mimo_capability_dl_r10 present */
                                p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                                    p_band_parameters_info[band_param_count].band_parameters_ul_r10.
                                    ca_mimo_parameters_ul_r10[ca_mimo_param_count].bitmask |= RRM_SUPPORTED_MIMO_CAPABILITY_UL_R10_IE_PRESENT;

                                /* CID: 61289 - Fix */
                                /* CID: 62564 - Fix */
                                p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                                    p_band_parameters_info[band_param_count].band_parameters_ul_r10.
                                    ca_mimo_parameters_ul_r10[ca_mimo_param_count].supported_mimo_capability_ul_r10 = 
                                    get_supported_mimo_capability_ul_r10(p_rf_param_v1020->supported_band_combination_r10.
                                            band_combination_parameters_r10[supp_band_comb_count]. band_parameters_info[band_param_count].
                                            band_parameters_ul_r10.ca_mimo_parameters_ul_r10[ca_mimo_param_count].
                                            supported_mimo_capability_ul_r10);
                            }
                            /* SPR 21496 Fix End */
                        }
                    }
                    if( p_rf_param_v1020->supported_band_combination_r10.\
                            band_combination_parameters_r10[supp_band_comb_count].band_parameters_info[band_param_count].\
                            bitmask & RRC_RRM_BAND_PARAMETERS_DL_R10_IES_PRESENT)
                    {
                        p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                            p_band_parameters_info[band_param_count].bitmask |= RRM_BAND_PARAMETERS_DL_R10_IES_PRESENT;

                        p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                            p_band_parameters_info[band_param_count].band_parameters_dl_r10.count = 
                            p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].
                            band_parameters_info[band_param_count].band_parameters_dl_r10.count;  

                        for(ca_mimo_param_count = RRM_ZERO;
                                ca_mimo_param_count < p_rf_param_v1020->supported_band_combination_r10.
                                band_combination_parameters_r10[supp_band_comb_count].
                                band_parameters_info[band_param_count].band_parameters_dl_r10.count;
                                ca_mimo_param_count++)
                        {
                            /* CID: 61290 - 62566 Fix */
                            p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                                p_band_parameters_info[band_param_count].band_parameters_dl_r10.
                                ca_mimo_parameters_dl_r10[ca_mimo_param_count].ca_band_width_class_dl_r10 =  
                                get_rrm_ca_band_width_class_r10(p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].
                                        band_parameters_info[band_param_count].band_parameters_dl_r10.
                                        ca_mimo_parameters_dl_r10[ca_mimo_param_count].ca_band_width_class_dl_r10);

                            if(p_rf_param_v1020->supported_band_combination_r10.band_combination_parameters_r10[supp_band_comb_count].\
                                    band_parameters_info[band_param_count].band_parameters_dl_r10.
                                    ca_mimo_parameters_dl_r10[ca_mimo_param_count].bitmask & RRC_RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT)
                            {
                                /* mimo_capability_dl_r10 present */
                                p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                                    p_band_parameters_info[band_param_count].band_parameters_dl_r10.
                                    ca_mimo_parameters_dl_r10[ca_mimo_param_count].bitmask |= RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT;

                                /* CID: 61288 - Fix */
                                /* Coverity_fix_62565 */
                                p_rrm_rf_param_v1020_ies->supported_band_combination_r10.p_band_combination_parameters_r10[supp_band_comb_count].
                                    p_band_parameters_info[band_param_count].band_parameters_dl_r10.
                                    ca_mimo_parameters_dl_r10[ca_mimo_param_count].supported_mimo_capability_dl_r10 =  
                                    get_supported_mimo_capability_dl_r10(p_rf_param_v1020->supported_band_combination_r10.
                                            band_combination_parameters_r10[supp_band_comb_count].
                                            band_parameters_info[band_param_count].band_parameters_dl_r10.
                                            ca_mimo_parameters_dl_r10[ca_mimo_param_count].supported_mimo_capability_dl_r10);
                            }
                        }
                    }
                } 
            } 
        }
    }
    /* SPR 21496 Fix End */
}

/* SPR_11104_FIX_START */

/******************************************************************************
 *   FUNCTION NAME: extract_ue_eutra_capability_v9a0_ies_fdd_tdd 
 *   INPUT      : p_src_from_rrc 
 *   OUTPUT     : p_dest_to_rrm 
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS: none
 *****************************************************************************/
rrm_void_t extract_ue_eutra_capability_v9a0_ies_fdd_tdd(
                       ue_eutra_capability_addxdd_mode_r9_t      *p_src_from_rrc,
                       rrm_ue_eutra_capability_addxdd_mode_r9_t  *p_dest_to_rrm)
{
   U32                                        feature_group_indicator    = RRM_ZERO;
   U16                                        count = RRM_ZERO;

   RRM_UT_TRACE_ENTER();

   RRM_ASSERT(RRM_PNULL != p_src_from_rrc);
   RRM_ASSERT(RRM_PNULL != p_dest_to_rrm);

   p_dest_to_rrm->bitmask = 0x00;

   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_PHY_LAYER_PARAMETERS_R9_PRESENT)
   {
       p_dest_to_rrm->phy_layer_parameters_r9.ue_TxAntennaSelectionSupported = 
           p_src_from_rrc->phy_layer_parameters_r9.ue_TxAntennaSelectionSupported;
       p_dest_to_rrm->phy_layer_parameters_r9.ue_SpecificRefSigsSupported = 
           p_src_from_rrc->phy_layer_parameters_r9.ue_SpecificRefSigsSupported;
       p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_PHY_LAYER_PARAMETERS_R9_PRESENT;
   }
   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT)
   {
       RRM_MEMCPY(&feature_group_indicator, 
                  &(p_src_from_rrc->feature_group_indicators_r9),
                  RRM_FOUR);
       p_dest_to_rrm->feature_group_indicators_r9 =
           RRM_NTOHL(feature_group_indicator);
       p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT;
   }
   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT)
   {
       RRM_MEMCPY(&feature_group_indicator, 
                  &(p_src_from_rrc->feature_group_ind_rel9add_r9),
                  RRM_FOUR);
       p_dest_to_rrm->feature_group_ind_rel9add_r9=
           RRM_NTOHL(feature_group_indicator);
        p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT;
   }
   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_GERAN_R9_PRESENT)
   {
       p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.count = 
           p_src_from_rrc->inter_rat_parameters_geran_r9.supported_band_list_geran.count;
       for (count = RRM_ZERO; count < 
              p_src_from_rrc->inter_rat_parameters_geran_r9.supported_band_list_geran.count; count++)
       {
           switch(p_src_from_rrc->inter_rat_parameters_geran_r9.supported_band_list_geran.supported_band_geran[count])
           {
              case geran_gsm450:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm450;
                   break;
              case geran_gsm480:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm480;
                   break;
              case geran_gsm710:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm710;
                   break;
              case geran_gsm750:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm750;
                   break;
              case geran_gsm810:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm810;
                   break;
              case geran_gsm850:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm850;
                   break;
              case geran_gsm900P:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm900P;
                   break;
              case geran_gsm900E:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm900E;
                   break;
              case geran_gsm900R:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm900R;
                   break;
              case geran_gsm1800:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm1800;
                   break;
              case geran_gsm1900:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_gsm1900;
                   break;
              case geran_spare5:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_spare5;
                   break;
              case geran_spare4:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_spare4;
                   break;
              case geran_spare3:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_spare3;
                   break;
              case geran_spare2:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_spare2;
                   break;
              case geran_spare1:
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.rrm_supported_band_geran[count] = 
                         rrm_geran_spare1;
                   break;
              default :
                   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                             "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_geran_r9.
                             supported_band_list_geran.supported_band_geran[count]);
                   p_dest_to_rrm->inter_rat_parameters_geran_r9.supported_band_list_geran.
                    rrm_supported_band_geran[count] =  rrm_geran_gsm450;
           }
       }
       p_dest_to_rrm->inter_rat_parameters_geran_r9.inter_rat_ps_ho_to_geran = 
           p_src_from_rrc->inter_rat_parameters_geran_r9.inter_rat_ps_ho_to_geran;
       p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_GERAN_R9_PRESENT;
   }
   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_UTRA_R9_PRESENT)
   {
       switch(p_src_from_rrc->inter_rat_parameters_utra_r9.e_redirection_utra_r9)
       {
            case RRM_RRC_E_REDIRECTION_UTRA_SUPPORTED:
                 p_dest_to_rrm->inter_rat_parameters_utra_r9.e_redirection_utra_r9 = 
                          RRM_RRC_E_REDIRECTION_UTRA_SUPPORTED_DEFINED; 
                 break;
            default :
                 RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                             "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_r9.e_redirection_utra_r9);
                 p_dest_to_rrm->inter_rat_parameters_utra_r9.e_redirection_utra_r9 = 
                          RRM_RRC_E_REDIRECTION_UTRA_SUPPORTED_DEFINED; 
       }
       p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_UTRA_R9_PRESENT;
   }
   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_CDMA2000_R9_PRESENT)
   {
        p_dest_to_rrm->inter_rat_parameters_cdma2000_r9.bitmask = 0x00;
        switch(p_src_from_rrc->inter_rat_parameters_cdma2000_r9.eCSFB_1xrtt_r9)
        {
            case ECSFB_1XRTT_R9_SUPPORTED:
                  p_dest_to_rrm->inter_rat_parameters_cdma2000_r9.eCSFB_1xrtt_r9 = 
                          RRM_ECSFB_1XRTT_R9_SUPPORTED;
                  break;
            default :
                  p_dest_to_rrm->inter_rat_parameters_cdma2000_r9.eCSFB_1xrtt_r9 = 
                          RRM_ECSFB_1XRTT_R9_SUPPORTED;
                 RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                             "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_cdma2000_r9.eCSFB_1xrtt_r9);
        }
        if (p_src_from_rrc->inter_rat_parameters_cdma2000_r9.bitmask &
               IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT)
        {
            switch(p_src_from_rrc->inter_rat_parameters_cdma2000_r9.eCSFB_conc_ps_mobility_1xrtt_r9)
            {
                case ECSFB_CONC_PS_MOB_1XRTT_R9_SUPPORTED:
                    p_dest_to_rrm->inter_rat_parameters_cdma2000_r9.eCSFB_conc_ps_mobility_1xrtt_r9= 
                        RRM_ECSFB_CONC_PS_MOB_1XRTT_R9_SUPPORTED;
                    break;
                default :
                    p_dest_to_rrm->inter_rat_parameters_cdma2000_r9.eCSFB_conc_ps_mobility_1xrtt_r9= 
                        RRM_ECSFB_CONC_PS_MOB_1XRTT_R9_SUPPORTED;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                            p_src_from_rrc->inter_rat_parameters_cdma2000_r9.eCSFB_conc_ps_mobility_1xrtt_r9);
            }
            p_dest_to_rrm->inter_rat_parameters_cdma2000_r9.bitmask |= 
                RRM_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT;
        }
        p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_CDMA2000_R9_PRESENT;
   }
   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_NEIGH_CELLSI_ACQUISITION_PARAMS_R9_PRESENT)
   {
        p_dest_to_rrm->neigh_cellsi_acquisition_parameters_r9.intra_freq_si_acquisition_for_ho_supported_r9 =
               p_src_from_rrc->neigh_cellsi_acquisition_parameters_r9.intra_freq_si_acquisition_for_ho_supported_r9;
        p_dest_to_rrm->neigh_cellsi_acquisition_parameters_r9.inter_freq_si_acquisition_for_ho_supported_r9 =
               p_src_from_rrc->neigh_cellsi_acquisition_parameters_r9.inter_freq_si_acquisition_for_ho_supported_r9;
        p_dest_to_rrm->neigh_cellsi_acquisition_parameters_r9.utran_si_acquisition_for_ho_supported_r9 =
               p_src_from_rrc->neigh_cellsi_acquisition_parameters_r9.utran_si_acquisition_for_ho_supported_r9;
        p_dest_to_rrm->bitmask |= RRM_UE_EUTRA_CAPABILITY_NEIGH_CELLSI_ACQUISITION_PARAMS_R9_PRESENT;
   }

   RRM_UT_TRACE_EXIT();
}


/******************************************************************************
 *   FUNCTION NAME: extract_ue_eutra_capability_v9a0_ies 
 *   INPUT      : p_src_from_rrc 
 *   OUTPUT     : p_dest_to_rrm 
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS: none
 *****************************************************************************/
rrm_void_t extract_ue_eutra_capability_v9a0_ies(
                       ue_eutra_capability_v9c0_ies_t        *p_src_from_rrc,
                       rrm_ue_eutra_capability_v9c0_ies_t    *p_dest_to_rrm)
{
   RRM_UT_TRACE_ENTER();

   p_dest_to_rrm->bitmask = 0x00;

   if (p_src_from_rrc->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMS_UTRA_v9c0_PRESENT)
   {
        p_dest_to_rrm->inter_rat_parameters_utra_v9c0.bitmask = 0x00;
        if(p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask & VOICEOVERPS_HS_UTRA_FDD_R9_PRESENT)
        {
            p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask |=
                        RRM_VOICEOVERPS_HS_UTRA_FDD_R9_PRESENT;
            switch(p_src_from_rrc->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_fdd_r9)
            {
                case VOICEOVERPS_HS_UTRA_FDD_R9_SUPPORTED:
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_fdd_r9 = 
                                RRM_VOICEOVERPS_HS_UTRA_FDD_R9_SUPPORTED;
                     break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_fdd_r9);
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_fdd_r9 = 
                                RRM_VOICEOVERPS_HS_UTRA_FDD_R9_SUPPORTED;
            }
        }
        if(p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask & VOICEOVERPS_HS_UTRA_TDD_R9_PRESENT)
        {
            p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask |=
                        RRM_VOICEOVERPS_HS_UTRA_TDD_R9_PRESENT;
            switch(p_src_from_rrc->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_tdd128_r9)
            {
                case VOICEOVERPS_HS_UTRA_TDD_R9_SUPPORTED:
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_tdd128_r9 = 
                                RRM_VOICEOVERPS_HS_UTRA_TDD_R9_SUPPORTED;
                     break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_tdd128_r9);
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.voice_over_ps_hs_utra_tdd128_r9 = 
                                RRM_VOICEOVERPS_HS_UTRA_TDD_R9_SUPPORTED;
            }
        }
        if(p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask & 
                SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_PRESENT)
        {
            p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask |=
                        RRM_SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_PRESENT;
            switch(p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_utra_fdd_r9)
            {
                case SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_SUPPORTED:
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_utra_fdd_r9 = 
                                RRM_SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_SUPPORTED;
                     break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_utra_fdd_r9);
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_utra_fdd_r9 = 
                                RRM_SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_SUPPORTED;
            }
        }
        if(p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask & 
             SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_PRESENT)
        {
            p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask |=
                        RRM_SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_PRESENT;
            switch(p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_geran_r9)
            {
                case SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_SUPPORTED:
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_geran_r9 = 
                                RRM_SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_SUPPORTED;
                     break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_geran_r9);
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_fdd_to_geran_r9 = 
                                RRM_SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_SUPPORTED;
            }
        }
        if(p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask & 
            SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_PRESENT)
        {
            p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask |=
                        RRM_SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_PRESENT;
            switch(p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_utra_tdd128_r9)
            {
                case SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_SUPPORTED:
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_utra_tdd128_r9 = 
                                RRM_SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_SUPPORTED;
                     break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_utra_tdd128_r9);
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_utra_tdd128_r9 = 
                                RRM_SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_SUPPORTED;
            }
        }
        if(p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask & 
            SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_PRESENT)
        {
            p_src_from_rrc->inter_rat_parameters_utra_v9c0.bitmask |=
                        RRM_SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_PRESENT;
            switch(p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_geran_r9)
            {
                case SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_SUPPORTED:
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_geran_r9 = 
                                RRM_SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_SUPPORTED;
                     break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Incorrect Value Recieved from RRC[%d]",
                             p_src_from_rrc->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_geran_r9);
                     p_dest_to_rrm->inter_rat_parameters_utra_v9c0.srvcc_from_utra_tdd128_to_geran_r9 = 
                                RRM_SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_SUPPORTED;
            }
        }
        p_dest_to_rrm->bitmask |= 
                RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMS_UTRA_v9c0_PRESENT;
   }


   RRM_UT_TRACE_EXIT();
}

/* SPR_11104_FIX_END */

/* CID 115996 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_ue_eutra_capability_v920_ies 
 *   INPUT      : p_rrc_ue_eutra_capability_v920_ies_t
 *   OUTPUT     : p_rrm_ue_eutra_capability_v920_ies
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS: none
 *****************************************************************************/
rrm_multi_cluster_pusch_withincc_r10_et
rrm_map_multi_cluster_pusch_withincc_r10(
U8 multi_cluster_pusch_withincc_r10
)
{
    RRM_UT_TRACE_ENTER();
    switch(multi_cluster_pusch_withincc_r10)
    {
       case MULTI_CLUSTER_SUPPORTED:
            return RRM_MULTI_CLUSTER_SUPPORTED;

       default:
            return RRM_MULTI_CLUSTER_SUPPORTED;
    } 
    RRM_UT_TRACE_EXIT();
}
/* CID 115996 Fix End */

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_ue_eutra_capability_v920_ies 
 *   INPUT      : p_rrc_ue_eutra_capability_v920_ies_t
 *   OUTPUT     : p_rrm_ue_eutra_capability_v920_ies
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS: none
 *****************************************************************************/
void
rrm_uem_fill_ue_eutra_capability_v920_ies(
    rrm_ue_eutra_capability_v920_ies_t 
    *p_rrm_ue_eutra_capability_v920_ies,
    ue_eutra_capability_v920_ies_t
    *p_rrc_ue_eutra_capability_v920_ies_t
    )
{
    /* SPR_11104_FIX_START */
    /*SPR_15241_Start*/
    rrm_ue_eutra_capability_v9a0_ies_t         *p_rrm_ue_eutra_capability_v9a0_ies_dest = RRM_PNULL;
    ue_eutra_capability_v9a0_ies_t             *p_rrc_ue_eutra_capability_v9a0_ies_src = RRM_PNULL;;
    /*SPR_15241_End*/
    U32                                        feature_group_indicator    = RRM_ZERO;
    /* SPR_11104_FIX_END */
    /* SPR 13383 changes start */
    U8                                         i = RRM_ZERO , j=RRM_ZERO;
    /* SPR 13383 changes end */
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_rrc_ue_eutra_capability_v920_ies_t) /* Klocwork_fix_27_aug */
    {
        /* SPR_11104_FIX_START */
        p_rrm_ue_eutra_capability_v920_ies->bitmask = RRM_ZERO;
        p_rrm_ue_eutra_capability_v920_ies->
            inter_rat_parameters_cdma2000_v920.bitmask = RRM_ZERO;

        /* SPR_11104_FIX_END */
        /*fill csg_proximity_indication_parameters start*/
        p_rrm_ue_eutra_capability_v920_ies->csg_proximity_indication_parameters_r9.
            rrm_intra_freq_proximity_indication_supported_r9 =
            p_rrc_ue_eutra_capability_v920_ies_t->csg_proximity_indication_parameters_r9.
            intra_freq_proximity_indication_supported_r9;


        p_rrm_ue_eutra_capability_v920_ies->csg_proximity_indication_parameters_r9.
            rrm_inter_freq_proximity_indication_supported_r9 =
            p_rrc_ue_eutra_capability_v920_ies_t->csg_proximity_indication_parameters_r9.
            inter_freq_proximity_indication_supported_r9;


        p_rrm_ue_eutra_capability_v920_ies->csg_proximity_indication_parameters_r9.
            rrm_utran_proximity_indication_supported_r9 =
            p_rrc_ue_eutra_capability_v920_ies_t->csg_proximity_indication_parameters_r9.
            utran_proximity_indication_supported_r9;
        /*fill csg_proximity_indication_parameters end*/
        /* SPR-10489-fix start */
        p_rrm_ue_eutra_capability_v920_ies->\
            inter_rat_parameters_geran_v920.bitmask = RRM_ZERO;
        if(p_rrc_ue_eutra_capability_v920_ies_t->
                inter_rat_parameters_geran_v920.bitmask & IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT)
        {

            p_rrm_ue_eutra_capability_v920_ies->\
                inter_rat_parameters_geran_v920.dtm_r9 = (rrc_irat_params_geran_v920_dtm_r9_root_et) p_rrc_ue_eutra_capability_v920_ies_t->\
                inter_rat_parameters_geran_v920.dtm_r9;

            p_rrm_ue_eutra_capability_v920_ies->
                inter_rat_parameters_geran_v920.bitmask |= RRM_UE_IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT;
            /* SPR_13721_fix : start */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Debug: DTM R9 present in Ue Capability.");
            /* SPR_13721_fix : end */
        }
        /* SPR-10489-fix end */
        /*SPR 20571 START*/
        if(p_rrc_ue_eutra_capability_v920_ies_t->
                inter_rat_parameters_geran_v920.bitmask & IRAT_PARAMS_GERAN_V920_E_REDIRECTION_GERAN_R9_PRESENT)
        {

            p_rrm_ue_eutra_capability_v920_ies->inter_rat_parameters_geran_v920.e_redirectiongeran_r9 = 
                (rrc_irat_params_geran_v920_e_redirection_geran_r9_root_et)p_rrc_ue_eutra_capability_v920_ies_t->
                inter_rat_parameters_geran_v920.e_redirection_geran_r9;

            p_rrm_ue_eutra_capability_v920_ies->
                inter_rat_parameters_geran_v920.bitmask |= RRM_UE_IRAT_PARAMS_GERAN_V920_E_REDIRECTIONGERAN_R9_PRESENT;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "E Redirection GERAN R9 present in Ue Capability."); 
        }
        /*SPR 20571 END*/

        /*+ Valgrind Fix 23_May_2014 +*/
        p_rrm_ue_eutra_capability_v920_ies->inter_rat_parameters_cdma2000_v920.
            bitmask = RRM_ZERO;
        p_rrm_ue_eutra_capability_v920_ies->bitmask = RRM_ZERO;
        /*- Valgrind Fix 23_May_2014 -*/

        /* SPR-10489-fix start */
        p_rrm_ue_eutra_capability_v920_ies->\
            inter_rat_parameters_geran_v920.bitmask = RRM_ZERO;
        if(p_rrc_ue_eutra_capability_v920_ies_t->
                inter_rat_parameters_geran_v920.bitmask & IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT)
        {

            p_rrm_ue_eutra_capability_v920_ies->\
                inter_rat_parameters_geran_v920.dtm_r9 = (rrc_irat_params_geran_v920_dtm_r9_root_et) p_rrc_ue_eutra_capability_v920_ies_t->\
                inter_rat_parameters_geran_v920.dtm_r9;

            p_rrm_ue_eutra_capability_v920_ies->
                inter_rat_parameters_geran_v920.bitmask |= RRM_UE_IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT;

        }
        /* SPR-10489-fix end */



        /* CDMA2000 changes start */
        if(p_rrc_ue_eutra_capability_v920_ies_t->bitmask & 
                RRC_RRM_INTER_RAT_PARAMS_CDMA2000_V920_PRESENT)
        {
            p_rrm_ue_eutra_capability_v920_ies->inter_rat_parameters_cdma2000_v920.
                eCSFB_1xrtt_r9 = (rrm_oam_eCSFB_1xrtt_r9_et)p_rrc_ue_eutra_capability_v920_ies_t->\
                inter_rat_parameters_cdma2000_v920.eCSFB_1xrtt_r9;

            if(p_rrc_ue_eutra_capability_v920_ies_t->
                    inter_rat_parameters_cdma2000_v920.bitmask &
                    IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT)
            {
                p_rrm_ue_eutra_capability_v920_ies->inter_rat_parameters_cdma2000_v920.
                    eCSFB_conc_ps_mobility_1xrtt_r9 =(rrm_oam_eCSFB_conc_ps_mobility_1xrtt_r9_et)p_rrc_ue_eutra_capability_v920_ies_t->
                    inter_rat_parameters_cdma2000_v920.eCSFB_conc_ps_mobility_1xrtt_r9;

                p_rrm_ue_eutra_capability_v920_ies->inter_rat_parameters_cdma2000_v920.
                    bitmask |= RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT;
            }
            p_rrm_ue_eutra_capability_v920_ies->bitmask |= RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT;
        }
        /* CDMA2000 changes ends */

        /* SPR 12897 Start */
        /* SI-Acquisition params */
        p_rrm_ue_eutra_capability_v920_ies->neigh_cell_si_acquisition_parameters_r9.
            intra_freq_si_acquisition_for_ho_supported_r9 = 
            p_rrc_ue_eutra_capability_v920_ies_t->neigh_cell_si_acquisition_parameters_r9.
            intra_freq_si_acquisition_for_ho_supported_r9; 

        p_rrm_ue_eutra_capability_v920_ies->neigh_cell_si_acquisition_parameters_r9.
            inter_freq_si_acquisition_for_ho_supported_r9 = 
            p_rrc_ue_eutra_capability_v920_ies_t->neigh_cell_si_acquisition_parameters_r9.
            inter_freq_si_acquisition_for_ho_supported_r9;

        p_rrm_ue_eutra_capability_v920_ies->neigh_cell_si_acquisition_parameters_r9.
            utran_si_acquisition_for_ho_supported_r9 = 
            p_rrc_ue_eutra_capability_v920_ies_t->neigh_cell_si_acquisition_parameters_r9.
            utran_si_acquisition_for_ho_supported_r9;
        /* SPR 12897 End */

        /*+ Valgrind Fix 23_May_2014 +*/
        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
            ue_eutra_capability_v1020_ies.bitmask = RRM_ZERO;
        /*- Valgrind Fix 23_May_2014 -*/
        /*Rel10 CR changes start*/
        if(p_rrc_ue_eutra_capability_v920_ies_t->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT)
        {
            p_rrm_ue_eutra_capability_v920_ies->bitmask |= RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT;
            /* SPR_11104_FIX_START */
            p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.bitmask = 0x00;
            if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.bitmask &
                    RRC_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT)
            {
                p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.bitmask |=
                    RRC_RRM_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT;
                p_rrm_ue_eutra_capability_v9a0_ies_dest = &(p_rrm_ue_eutra_capability_v920_ies->
                        ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies);
                RRM_ASSERT(RRM_PNULL != p_rrm_ue_eutra_capability_v9a0_ies_dest);
                p_rrm_ue_eutra_capability_v9a0_ies_dest->bitmask = 0x00;

                p_rrc_ue_eutra_capability_v9a0_ies_src = &(p_rrc_ue_eutra_capability_v920_ies_t->
                        ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies);
                RRM_ASSERT(RRM_PNULL != p_rrc_ue_eutra_capability_v9a0_ies_src);

                if (p_rrc_ue_eutra_capability_v9a0_ies_src->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_REL9_ADD_PRESENT)
                {
                    RRM_MEMCPY(&feature_group_indicator, 
                            p_rrc_ue_eutra_capability_v9a0_ies_src->feature_group_ind_rel9add_r9,
                            RRM_FOUR);
                    p_rrm_ue_eutra_capability_v9a0_ies_dest->feature_group_ind_rel9add_r9 = 
                        RRM_NTOHL(feature_group_indicator);
                    p_rrm_ue_eutra_capability_v9a0_ies_dest->bitmask |= 
                        RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_REL9_ADD_PRESENT;
                }
                if (p_rrc_ue_eutra_capability_v9a0_ies_src->bitmask & RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT)
                {
                    extract_ue_eutra_capability_v9a0_ies_fdd_tdd(
                            &(p_rrc_ue_eutra_capability_v9a0_ies_src->fdd_add_ue_eutra_capabilities_r9),
                            &(p_rrm_ue_eutra_capability_v9a0_ies_dest->fdd_add_ue_eutra_capabilities_r9));
                    p_rrm_ue_eutra_capability_v9a0_ies_dest->bitmask |= 
                        RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT;
                }
                if (p_rrc_ue_eutra_capability_v9a0_ies_src->bitmask & RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT)
                {
                    extract_ue_eutra_capability_v9a0_ies_fdd_tdd(
                            &(p_rrc_ue_eutra_capability_v9a0_ies_src->tdd_add_ue_eutra_capabilities_r9),
                            &(p_rrm_ue_eutra_capability_v9a0_ies_dest->tdd_add_ue_eutra_capabilities_r9));
                    p_rrm_ue_eutra_capability_v9a0_ies_dest->bitmask |= 
                        RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT;
                }
                if (p_rrc_ue_eutra_capability_v9a0_ies_src->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V9c0_IES_PRESENT)
                {
                    extract_ue_eutra_capability_v9a0_ies(
                            &(p_rrc_ue_eutra_capability_v9a0_ies_src->ue_eutra_capability_v9c0_ies),
                            &(p_rrm_ue_eutra_capability_v9a0_ies_dest->ue_eutra_capability_v9c0_ies));
                    p_rrm_ue_eutra_capability_v9a0_ies_dest->bitmask |= 
                        RRM_UE_EUTRA_CAPABILITY_V9c0_IES_PRESENT;
                }
            }
            /* SPR_11104_FIX_END */

            if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.bitmask &
                    RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT)
            {
                p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.bitmask |=
                    RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT;

                /* SPR_11104_FIX_START */
                p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask = 0x00;

                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_V1020_FEATUREGROUP_IND_R10_PRESENT)
                {
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRC_RRM_UE_EUTRA_CAPABILITY_V1020_FEATUREGROUP_IND_R10_PRESENT;
                    RRM_MEMCPY(&feature_group_indicator,
                            &(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.featuregroup_ind_r10),
                            RRM_FOUR);
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.featuregroup_ind_r10 =
                        RRM_NTOHL(feature_group_indicator);
                }
                /* SPR_11104_FIX_END */

                /* Rel10 CR-530 fill v1020 UE category */
                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT)
                {
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT;

                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.ue_category_v1020 =
                        p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.ue_category_v1020;
                }
                /* fill v1020 RF Param in UE Context */
                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_V1020_RF_PARAMETERS_PRESENT)
                {
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRM_UE_EUTRA_CAPABILITY_V1020_RF_PARAMETERS_PRESENT;

                    rrm_extract_r10_rf_params(&(p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.rf_parameters_v1020),    /* rrm structure */
                            &(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.rf_parameters_v1020));    /*info received from rrc */
                }

                /* SPR 10497 Fix */
                /* SPR_11104_FIX_START */
                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_UTRA_TDD_V1020_PRESENT)
                {
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_UTRA_TDD_V1020_PRESENT;
                    if (RRM_RRC_E_REDIRECTION_UTRA_TDD_R10_SUPPORTED == p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.inter_rat_parameters_utra_tdd_v1020.e_redirection_utra_tdd_r10)
                    {
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.inter_rat_parameters_utra_tdd_v1020.e_redirection_utra_tdd_r10 =
                            RRM_E_REDIRECTION_UTRA_TDD_R10_SUPPORTED;
                    }
                }
                /* SPR_11104_FIX_END */
                /* SPR 13383 changes start */
                if(( p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.bitmask &
                            RRC_RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT) )
                {

                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT;

                    if( p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.bitmask & 
                            RRC_RRM_UE_EUTRA_CAPABILITY_V1060_RF_PARAMETERS_PRESENT )
                    {
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.bitmask = 0x00;

                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.bitmask |=
                            RRM_UE_EUTRA_CAPABILITY_V1060_RF_PARAMETERS_PRESENT ;

                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                            supported_band_combination_ext_r10.count =
                            p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.rf_parameters_v1060.
                            supported_band_combination_ext_r10.count;

                        /* SPR 21496 Fix Start  */
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                            supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10 =
                            rrm_mem_get(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.rf_parameters_v1060.
                                    supported_band_combination_ext_r10.count *sizeof(rrm_band_combination_parameters_ext_r10_t));

                        if(RRM_PNULL != p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10)
                        {
                            for( i = RRM_ZERO; i < p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                    supported_band_combination_ext_r10.count && i < MAX_BAND_COMB_R10 ; i++ )
                            {
                                p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                    supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10[i].bitmask = 0x00;

                                if( p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                        ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.rf_parameters_v1060.
                                        supported_band_combination_ext_r10.band_combination_parameters_ext_r10[i].
                                        /* SPR 13383 changes start */
                                        presence_bitmask & RRC_RRM_SUPPORTED_BAND_WIDTH_COMB_SET_R10 )
                                    /* SPR 13383 changes end */                        
                                {
                                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                        ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                        supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10[i].
                                        bitmask |= RRM_SUPPORTED_BAND_WIDTH_COMB_SET_R10;

                                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                        ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                        supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10[i].
                                        supported_band_width_combination_set_r10.count =
                                        p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                        ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.rf_parameters_v1060.
                                        supported_band_combination_ext_r10.band_combination_parameters_ext_r10[i].
                                        supported_band_width_combination_set_r10.count;

                                    ;
                                    for( j = RRM_ZERO; j < 
                                            p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                            supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10[i].
                                            supported_band_width_combination_set_r10.count
                                            && j < MAX_BAND_WIDTH_COMB_R10 ; j++ )
                                    {
                                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
                                            supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10[i].
                                            supported_band_width_combination_set_r10.data[j] = 
                                            p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.rf_parameters_v1060.
                                            supported_band_combination_ext_r10.band_combination_parameters_ext_r10[i].
                                            supported_band_width_combination_set_r10.data[j];
                                    }
                                }
                            }
                        }
                        /* SPR 21496 Fix End  */

                    }
                    if( p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.bitmask &
                            RRC_RRM_TDD_ADD_UE_EUTRA_CAPABILITIES_v1060_PRESENT )
                    {
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.
                            tdd_add_ue_eutra_capability_v1060.bitmask = 0x00;

                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.
                            tdd_add_ue_eutra_capability_v1060.bitmask |=
                            RRM_TDD_ADD_UE_EUTRA_CAPABILITIES_v1060_PRESENT ;

                        if( p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                tdd_add_ue_eutra_capability_v1060.bitmask  &
                                RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_UTRA_TDD_PRESENT )
                        {
                            p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.
                                tdd_add_ue_eutra_capability_v1060.bitmask = 0x00;

                            p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.
                                tdd_add_ue_eutra_capability_v1060.bitmask |= RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_UTRA_TDD_PRESENT;

                            p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.
                                tdd_add_ue_eutra_capability_v1060.inter_rat_parameters_utra_tdd_v1060.
                                e_redirection_utra_tdd_r10 = 
                                p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                tdd_add_ue_eutra_capability_v1060.inter_rat_parameters_utra_tdd_v1060.
                                e_redirection_utra_tdd_r10;
                        }    
                    }     
                }
                /* SPR 13383 changes end */   
                /* SPR 10497 Fix */
                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_CDMA2000_V1020_PRESENT)
                {
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_CDMA2000_V1020_PRESENT;

                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.inter_rat_parameters_cdma2000_v1020.
                        eCSFB_dual_1xrtt_r10 = p_rrc_ue_eutra_capability_v920_ies_t->
                        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                        inter_rat_parameters_cdma2000_v1020.eCSFB_dual_1xrtt_r10;
                }

                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_NW_PERF_MEAS_PARAMS_PRESENT)
                {
                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRM_UE_EUTRA_CAPABILITY_NW_PERF_MEAS_PARAMS_PRESENT;

                    if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_based_nw_perf_meas_params.bitmask &
                            RRC_RRM_LOGGED_MEAS_IDLE_UE_EUTRA_CAPABILITY_R10_PRESENT)
                    {
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_based_nw_perf_meas_params.bitmask |=
                            RRM_LOGGED_MEAS_IDLE_UE_EUTRA_CAPABILITY_R10_PRESENT;

                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_based_nw_perf_meas_params.
                            logged_measurements_idle_r10 = p_rrc_ue_eutra_capability_v920_ies_t->
                            ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                            ue_based_nw_perf_meas_params.logged_measurements_idle_r10;
                    }

                    if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_based_nw_perf_meas_params.bitmask &
                            RRC_RRM_STANDALONE_GNSS_LOC_UE_EUTRA_CAPABILITY_R10_PRESENT)
                    {
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_based_nw_perf_meas_params.bitmask |=
                            RRM_STANDALONE_GNSS_LOC_UE_EUTRA_CAPABILITY_R10_PRESENT;

                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.ue_based_nw_perf_meas_params.
                            standalone_gnss_location_r10 = p_rrc_ue_eutra_capability_v920_ies_t->
                            ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                            ue_based_nw_perf_meas_params.standalone_gnss_location_r10;
                    }
                }
                /* SPR 21958 PUSCH RAT1 Support Start */
                if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRC_RRM_UE_EUTRA_CAPABILITY_V1020_PHYLAYERS_PARAMETERS_PRESENT)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "eutra_capability_v1020_ies phylayer_parameter_v1020 Present");

                    p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.bitmask |=
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask |=
                        RRC_RRM_UE_EUTRA_CAPABILITY_V1020_PHYLAYERS_PARAMETERS_PRESENT;

                    (p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                     ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.bitmask |=
                     RRC_RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT);

                    if(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.bitmask &
                            RRC_RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "eutra_capability_v1020_ies phylayer_parameter_v1020 multi_cluster_pusch_withincc_r10 Present");
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.bitmask |= 
                            RRC_RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT;
                        /* CID 115996 Fix Start */
                        p_rrm_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.multi_cluster_pusch_withincc_r10 = 
                            rrm_map_multi_cluster_pusch_withincc_r10(p_rrc_ue_eutra_capability_v920_ies_t->ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.multi_cluster_pusch_withincc_r10); 
                        /* CID 115996 Fix End */


                    }

                }
                /* SPR 21958 PUSCH RAT1 Support End */
            }
        }

        /*Rel10 CR changes end*/

        /*TM mode 7-8 start*/
        p_rrm_ue_eutra_capability_v920_ies->phy_layer_parameters_v920.
            enhanced_dual_layer_fdd_supported_r9
            = p_rrc_ue_eutra_capability_v920_ies_t->
            phy_layer_parameters_v920.enhanced_dual_layer_fdd_supported_r9;

        p_rrm_ue_eutra_capability_v920_ies->phy_layer_parameters_v920.
            enhanced_dual_layer_tdd_supported_r9
            = p_rrc_ue_eutra_capability_v920_ies_t->
            phy_layer_parameters_v920.enhanced_dual_layer_tdd_supported_r9;
        /*TM mode 7-8 end*/
    }
    else   /* Klocwork_fix_27_aug */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "p_rrc_ue_eutra_capability_v920_ies received Null!");
    }
    RRM_UT_TRACE_EXIT();
    /* SPR 13383 changes end */
}

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_populate_capability_params_for_inter_rat_params
 *   INPUT      : p_rrc_ue_capability_info
 *   OUTPUT     : p_rrm_ue_capability_params
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *****************************************************************************/

void
rrm_ue_populate_capability_params_for_inter_rat_params
(
 rrc_radio_capability_info_t *p_rrc_ue_capability_info,
 rrm_ue_capability_params_t *p_rrm_ue_capability_params
)
{
    /* SPR 10497 Fix */                    
    U8              utra_tdd_index = RRM_ZERO; 
    U8              utra_tdd_count = RRM_ZERO;
    /* SPR 10497 Fix */                    
    U8              utra_fdd_index = RRM_ZERO; 
    U8              utra_fdd_count = RRM_ZERO;
    /* SPR 10497 Fix */                    

    RRM_UT_TRACE_ENTER();	


			/* Inter RAT Parameters */
			p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.bitmask = RRM_ZERO;
/* SPR 10497 Fix */                    
			if (p_rrc_ue_capability_info->eutra_radio_capability_info.
				eutra_radio_capability_info_def.inter_rat_Parameters.bitmask & INTER_RAT_UTRA_TDD128_PRESENT)
			{
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "TDD 128 Present");
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.bitmask |= RRM_INTER_RAT_UTRA_TDD_128_PRESENT;
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.utra_tdd128.count = utra_tdd_count = 
				p_rrc_ue_capability_info->eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_Parameters.utra_tdd128.count;
				for (utra_tdd_index = RRM_ZERO; utra_tdd_index < utra_tdd_count; ++utra_tdd_index)
				{
                   rrm_uem_fill_utra_tdd128_supported_band_info(
                              &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                               eutra_radio_capability_info_def.inter_rat_parameters.
                               utra_tdd128.supported_band_utra_tdd128[utra_tdd_index], 
                               p_rrc_ue_capability_info->eutra_radio_capability_info.
                               eutra_radio_capability_info_def.inter_rat_Parameters.
                               utra_tdd128.supported_band_utra_tdd128[utra_tdd_index]);
				}
			}
			else if (p_rrc_ue_capability_info->eutra_radio_capability_info.
				eutra_radio_capability_info_def.inter_rat_Parameters.bitmask & INTER_RAT_UTRA_TDD384_PRESENT)
			{
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "TDD 384 Present");
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.bitmask |= RRM_INTER_RAT_UTRA_TDD_384_PRESENT;
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.utra_tdd384.count = utra_tdd_count = 
				p_rrc_ue_capability_info->eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_Parameters.utra_tdd384.count;
				for (utra_tdd_index = RRM_ZERO; utra_tdd_index < utra_tdd_count; ++utra_tdd_index)
				{
                   rrm_uem_fill_utra_tdd384_supported_band_info(
                              &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                               eutra_radio_capability_info_def.inter_rat_parameters.
                               utra_tdd384.supported_band_utra_tdd384[utra_tdd_index], 
                               p_rrc_ue_capability_info->eutra_radio_capability_info.
                               eutra_radio_capability_info_def.inter_rat_Parameters.
                               utra_tdd384.supported_band_utra_tdd384[utra_tdd_index]);
				}
			}
			else if (p_rrc_ue_capability_info->eutra_radio_capability_info.
				eutra_radio_capability_info_def.inter_rat_Parameters.bitmask & INTER_RAT_UTRA_TDD768_PRESENT)
			{
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "TDD 768 Present");
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.bitmask |= RRM_INTER_RAT_UTRA_TDD_768_PRESENT;
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.utra_tdd768.count = utra_tdd_count = 
				p_rrc_ue_capability_info->eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_Parameters.utra_tdd768.count;
				for (utra_tdd_index = RRM_ZERO; utra_tdd_index < utra_tdd_count; ++utra_tdd_index)
				{
                   rrm_uem_fill_utra_tdd768_supported_band_info(
                              &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                               eutra_radio_capability_info_def.inter_rat_parameters.
                               utra_tdd768.supported_band_utra_tdd768[utra_tdd_index], 
                               p_rrc_ue_capability_info->eutra_radio_capability_info.
                               eutra_radio_capability_info_def.inter_rat_Parameters.
                               utra_tdd768.supported_band_utra_tdd768[utra_tdd_index]);
				}
			}
/* SPR 10497 Fix */                    
			if (p_rrc_ue_capability_info->eutra_radio_capability_info.
				eutra_radio_capability_info_def.inter_rat_Parameters.bitmask & INTER_RAT_UTRA_FDD_PRESENT)
			{
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.bitmask |= RRM_INTER_RAT_UTRA_FDD_PRESENT;
				p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_parameters.utra_fdd.count = utra_fdd_count = 
				p_rrc_ue_capability_info->eutra_radio_capability_info.
					eutra_radio_capability_info_def.inter_rat_Parameters.utra_fdd.count;
				for (utra_fdd_index = RRM_ZERO; utra_fdd_index < utra_fdd_count; ++utra_fdd_index)
				{
                                   rrm_uem_fill_utra_fdd_supported_band_info(
                                      &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                                       eutra_radio_capability_info_def.inter_rat_parameters.
                                       utra_fdd.supported_band_utra_fdd[utra_fdd_index], 
                                       p_rrc_ue_capability_info->eutra_radio_capability_info.
                                       eutra_radio_capability_info_def.inter_rat_Parameters.
                                       utra_fdd.supported_band_utra_fdd[utra_fdd_index]);
				}
			}
/* SPR 10497 Fix */                    
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_populate_capability_params_for_cdma2000_params
 *   INPUT      : p_rrc_ue_capability_info
 *   OUTPUT     : p_rrm_ue_capability_params
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer for hrpd and 1xrtt in cdma2000. 
 *        
 *****************************************************************************/

void
rrm_ue_populate_capability_params_for_cdma2000_params
(
 rrc_radio_capability_info_t *p_rrc_ue_capability_info,
 rrm_ue_capability_params_t *p_rrm_ue_capability_params
 )
{
    rrm_ue_inter_rat_Parameters_t  *p_rrm_ue_inter_rat_parameters = RRM_PNULL;
    inter_rat_Parameters_t         *p_rrc_ue_inter_rat_parameters = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    /* cdma2000 start */
            /*Coverity_fix_start_54947*/
               p_rrm_ue_inter_rat_parameters = 
                &(p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.inter_rat_parameters);
               
               p_rrc_ue_inter_rat_parameters = &(p_rrc_ue_capability_info-> \
                                              eutra_radio_capability_info. \
                                              eutra_radio_capability_info_def. \
                                              inter_rat_Parameters);
            /*Coverity_fix_end_54947*/

			if (p_rrc_ue_inter_rat_parameters->bitmask & INTER_RAT_UTRA_CDMA2000_HRPD_PRESENT)
			{
                p_rrm_ue_inter_rat_parameters->cdma2000_hrpd. \
                    supported_band_list_hrpd.count = \
                p_rrc_ue_inter_rat_parameters->cdma2000_hrpd. \
                    supported_band_list_hrpd.count;

                RRM_MEMCPY((U8*)p_rrm_ue_inter_rat_parameters->cdma2000_hrpd. \
                                supported_band_list_hrpd.band_class_cdma2000,
                             (U8*)p_rrc_ue_inter_rat_parameters->cdma2000_hrpd. \
                                 supported_band_list_hrpd.band_class_cdma2000,
                                 p_rrm_ue_inter_rat_parameters->cdma2000_hrpd. \
                                     supported_band_list_hrpd.count);

                if(tx_rx_single == \
                       p_rrc_ue_inter_rat_parameters->cdma2000_hrpd.tx_confiig_hrpd)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_hrpd.tx_confiig_hrpd = \
                        rrm_ue_tx_rx_single;
                }
                else if(tx_rx_dual == \
                            p_rrc_ue_inter_rat_parameters->cdma2000_hrpd.tx_confiig_hrpd)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_hrpd.tx_confiig_hrpd = \
                        rrm_ue_tx_rx_dual;
                }

                if(tx_rx_single == \
                       p_rrc_ue_inter_rat_parameters->cdma2000_hrpd.rx_confiig_hrpd)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_hrpd.rx_confiig_hrpd = \
                        rrm_ue_tx_rx_single;
                }
                else if(tx_rx_dual == \
                            p_rrc_ue_inter_rat_parameters->cdma2000_hrpd.rx_confiig_hrpd)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_hrpd.rx_confiig_hrpd = \
                                rrm_ue_tx_rx_dual;
                }

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "CDMA HRPD present");
				p_rrm_ue_inter_rat_parameters->bitmask |= RRM_INTER_RAT_CDMA2000_HRPD_PRESENT;
           } 

			if (p_rrc_ue_inter_rat_parameters->bitmask & INTER_RAT_UTRA_CDMA2000_1XRTT_PRESENT)
			{
                p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt. \
                    supported_band_list_1xrtt.count = \
                p_rrc_ue_inter_rat_parameters->cdma2000_1x_rtt. \
                    supported_band_list_1xrtt.count;

                RRM_MEMCPY((U8*)p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt. \
                                supported_band_list_1xrtt.band_class_cdma2000,
                             (U8*)p_rrc_ue_inter_rat_parameters->cdma2000_1x_rtt. \
                                 supported_band_list_1xrtt.band_class_cdma2000,
                                 p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt. \
                                     supported_band_list_1xrtt.count);

                if(tx_rx_single == \
                       p_rrc_ue_inter_rat_parameters->cdma2000_1x_rtt.tx_confiig_1xrtt)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt.tx_confiig_1xrtt = \
                        rrm_ue_tx_rx_single;
                }
                else if(tx_rx_dual == \
                            p_rrc_ue_inter_rat_parameters->cdma2000_1x_rtt.tx_confiig_1xrtt)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt.tx_confiig_1xrtt = \
                        rrm_ue_tx_rx_dual;
                }

                if(tx_rx_single == \
                       p_rrc_ue_inter_rat_parameters->cdma2000_1x_rtt.rx_confiig_1xrtt)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt.rx_confiig_1xrtt = \
                        rrm_ue_tx_rx_single;
                }
                else if(tx_rx_dual == \
                            p_rrc_ue_inter_rat_parameters->cdma2000_1x_rtt.rx_confiig_1xrtt)
                {
                    p_rrm_ue_inter_rat_parameters->cdma2000_1x_rtt.rx_confiig_1xrtt = \
                        rrm_ue_tx_rx_dual;
                }

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "CDMA 1XRTT present");
				p_rrm_ue_inter_rat_parameters->bitmask |= RRM_INTER_RAT_CDMA2000_1XRTT_PRESENT;
           } 
            /* cdma2000 end */
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_populate_capability_params_for_geran
 *   INPUT      : p_rrc_ue_capability_info
 *   OUTPUT     : p_rrm_ue_capability_params
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_void_t
rrm_ue_populate_capability_params_for_geran(rrc_radio_capability_info_t   *p_rrc_ue_capability_info ,
                                            rrm_ue_capability_params_t    *p_rrm_ue_capability_params)
{
    U8              geran_index = RRM_ZERO;
    U8              geran_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if (p_rrc_ue_capability_info->eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_Parameters.bitmask & INTER_RAT_UTRA_GERAN_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "GERAN Present");
        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.bitmask |= RRM_INTER_RAT_GERAN_PRESENT;
        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.geran.count = geran_count = 
            p_rrc_ue_capability_info->eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_Parameters.geran.supported_band_list_geran.count;
        for (geran_index = RRM_ZERO; geran_index < geran_count; ++geran_index)
        {
            rrm_uem_fill_geran_supported_band_info(
                    &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.inter_rat_parameters.
                    geran.supported_band_geran[geran_index], 
                    p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.inter_rat_Parameters.
                    geran.supported_band_list_geran.supported_band_geran[geran_index]);
        }
    } 
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_populate_capability_params_for_cdma
 *   INPUT      : p_rrc_ue_capability_info
 *   OUTPUT     : p_rrm_ue_capability_params
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_void_t
rrm_ue_populate_capability_params_for_cdma(rrc_radio_capability_info_t   *p_rrc_ue_capability_info ,
                                            rrm_ue_capability_params_t   *p_rrm_ue_capability_params)
{
    RRM_UT_TRACE_ENTER();

    if (p_rrc_ue_capability_info->eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_Parameters.bitmask &
            INTER_RAT_UTRA_CDMA2000_HRPD_PRESENT)
    {
        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.
            cdma2000_hrpd.tx_confiig_hrpd = p_rrc_ue_capability_info->
            eutra_radio_capability_info.eutra_radio_capability_info_def.
            inter_rat_Parameters.cdma2000_hrpd.tx_confiig_hrpd;

        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.
            cdma2000_hrpd.rx_confiig_hrpd = p_rrc_ue_capability_info->
            eutra_radio_capability_info.eutra_radio_capability_info_def.
            inter_rat_Parameters.cdma2000_hrpd.rx_confiig_hrpd;

        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.
            bitmask |= RRM_INTER_RAT_CDMA2000_HRPD_PRESENT;
    }
    if (p_rrc_ue_capability_info->eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_Parameters.bitmask &
            INTER_RAT_UTRA_CDMA2000_1XRTT_PRESENT)
    {
        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.
            cdma2000_1x_rtt.tx_confiig_1xrtt = p_rrc_ue_capability_info->
            eutra_radio_capability_info.eutra_radio_capability_info_def.
            inter_rat_Parameters.cdma2000_1x_rtt.tx_confiig_1xrtt;

        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.
            cdma2000_1x_rtt.rx_confiig_1xrtt = p_rrc_ue_capability_info->
            eutra_radio_capability_info.eutra_radio_capability_info_def.
            inter_rat_Parameters.cdma2000_1x_rtt.rx_confiig_1xrtt;

        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.inter_rat_parameters.
            bitmask |= RRM_INTER_RAT_CDMA2000_1XRTT_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

#ifdef ENDC_ENABLED
/* NR_BAND_FIX_START */
rrm_nr_freq_band_mode_et
rrm_check_nr_freq_band_duplexing_mode
(
    U16 nr_freq_band_indicator
)
{
    rrm_nr_freq_band_mode_et freq_band_mode = RRM_NR_FREQ_BAND_INVALID;

    RRM_UT_TRACE_ENTER();

    switch(nr_freq_band_indicator)
    {
        case RRM_NR_BAND_N1:
        case RRM_NR_BAND_N2:
        case RRM_NR_BAND_N3:
        case RRM_NR_BAND_N5:
        case RRM_NR_BAND_N7:
        case RRM_NR_BAND_N8:
        case RRM_NR_BAND_N20:
        case RRM_NR_BAND_N28:
        case RRM_NR_BAND_N66:
        case RRM_NR_BAND_N70:
        case RRM_NR_BAND_N71:
        case RRM_NR_BAND_N74:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Freq band indicator [%u] is for FDD duplexing mode \n",
                 nr_freq_band_indicator);
            freq_band_mode = RRM_NR_FREQ_BAND_FDD;
            break;
        }
        case RRM_NR_BAND_N38:
        case RRM_NR_BAND_N41:
        case RRM_NR_BAND_N50:
        case RRM_NR_BAND_N51:
        case RRM_NR_BAND_N77:
        case RRM_NR_BAND_N78:
        case RRM_NR_BAND_N79:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Freq band indicator [%u] is for TDD duplexing mode \n",
                 nr_freq_band_indicator);
            freq_band_mode = RRM_NR_FREQ_BAND_FDD;
            break;
        }
        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Freq band indicator [%u] is neither for FDD or TDD duplexing mode \n",
                 nr_freq_band_indicator);
            break;
        }
    }

    RRM_UT_TRACE_EXIT();
    return freq_band_mode;
}
/* NR_BAND_FIX_END */
/* MENB_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_nr_nbr_list 
 *   INPUT      : p_meas_results_nr
 *   OUTPUT     : p_ue_proc_data
 *   DESCRIPTION:
 *       Fills the NR neighbour list parameters in meas reults ind
 *       to be sent to RMIF received from RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
rrm_void_t
rrm_ue_fill_nr_nbr_list
(
 rrm_ue_measurment_results_ind_t     *p_ue_proc_data,
 meas_results_list_nr_r15_t *p_meas_results_nr
)
{
    U8 nr_cell_count = RRM_ZERO;
    U8 ssb_count = RRM_ZERO;
    meas_result_ind_nr_t 
        *p_meas_result_nr = RRM_PNULL;
    meas_result_nr_r15_t 
        *p_rrm_meas_result_cell = RRM_PNULL;
    threshold_list_nr_r15_t 
        *p_meas_result_cell = RRM_PNULL;
    rrm_meas_result_nr_neighbour_list_r15_t 
        *p_rrm_meas_result_list_nr = RRM_PNULL;
    rrm_meas_result_neighbour_nr_cell_r15_t
        *p_rrm_meas_result_nr = RRM_PNULL;
    meas_result_ssb_index_r15_t 
        *p_meas_res_ssb_idx = RRM_PNULL;
    rrm_meas_result_ssb_index_r15_t
        *p_rrm_meas_ssb_idx = RRM_PNULL;
    meas_result_ssb_index_list_r15_t
        *p_meas_res_ssb_idx_list = RRM_PNULL;
    rrm_meas_result_ssb_indexlist_r15_t 
        *p_rrm_meas_ssb_idx_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrm_meas_result_list_nr = 
        &(p_ue_proc_data->rrm_meas_result_nr_neighbour_list_r15);

    p_rrm_meas_result_list_nr->count = p_meas_results_nr->count;
    for(nr_cell_count = RRM_ZERO ; 
            nr_cell_count < p_meas_results_nr->count; nr_cell_count++)
    {
        p_meas_result_nr = &(p_meas_results_nr->meas_result_nr[nr_cell_count]);
        p_rrm_meas_result_nr = &(p_rrm_meas_result_list_nr->\
                meas_result_neighbour_nr_cell_r15[nr_cell_count]);

        p_rrm_meas_result_nr->pci_r15 = p_meas_result_nr->phys_cell_id_r15;

        p_meas_result_cell = &(p_meas_result_nr->meas_result_cell_r15);
        p_rrm_meas_result_cell = &(p_rrm_meas_result_nr->meas_result_nr_r15);
        p_rrm_meas_result_cell->bitmask = 0x00;
        if(p_meas_result_cell->bitmask &
                THRESHOLD_LIST_NR_RSRP_PRESENT)
        {
            p_rrm_meas_result_cell->rsrp_result_nr_r15 = 
                p_meas_result_cell->rsrp_nr_r15;
            p_rrm_meas_result_cell->bitmask |= MEAS_RESULT_NR_RSRP_PRESENT; 
        }

        if(p_meas_result_cell->bitmask &
                THRESHOLD_LIST_NR_RSRQ_PRESENT)
        {
            p_rrm_meas_result_cell->rsrq_result_nr_r15 = 
                p_meas_result_cell->rsrq_nr_r15;
            p_rrm_meas_result_cell->bitmask |= MEAS_RESULT_NR_RSRQ_PRESENT; 
        }
        if(p_meas_result_cell->bitmask &
                THRESHOLD_LIST_NR_SINR_PRESENT)
        {
            p_rrm_meas_result_cell->rs_sinr_result_r15 = 
                p_meas_result_cell->sinr_nr_r15;
            p_rrm_meas_result_cell->bitmask |= MEAS_RESULT_NR_RS_SINR_PRESENT; 
        }

        p_rrm_meas_result_nr->bitmask = 0x00;   
        if(p_rrm_meas_result_nr->bitmask &
                MEAS_RESULT_NR_RS_INDEX_LIST_R15_PRESENT)
        {
            p_rrm_meas_result_nr->bitmask |=
                RRM_MEAS_RESULT_SSB_INDEX_LIST_PRESENT;             
            p_meas_res_ssb_idx_list = 
                &(p_meas_result_nr->rs_index_list_r15);
            p_rrm_meas_ssb_idx_list = 
                &(p_rrm_meas_result_nr->meas_result_ssb_indexlist_r15);

            p_rrm_meas_ssb_idx_list->count = p_meas_res_ssb_idx_list->count;
            for( ssb_count = RRM_ZERO ; 
                    ssb_count < p_meas_res_ssb_idx_list->count;
                    ssb_count++)
            {
                p_meas_res_ssb_idx = 
                    &(p_meas_res_ssb_idx_list->\
                            meas_result_ssb_index_r15[ssb_count]);
                p_rrm_meas_ssb_idx = 
                    &(p_rrm_meas_ssb_idx_list->\
                            meas_result_ssb_index_r15[ssb_count]);
                p_rrm_meas_ssb_idx->ssb_index = 
                    p_meas_res_ssb_idx->ssb_index_r15;

                p_rrm_meas_ssb_idx->bitmask = RRM_ZERO;
                if(p_meas_res_ssb_idx->bitmask &
                        MEAS_RESULT_SSB_INDEX_R15_PRESENT)
                {
                    p_rrm_meas_ssb_idx->bitmask |= 
                        RRM_MEAS_RESULT_SSB_INDEX_PRESENT;
                    p_rrm_meas_ssb_idx->meas_result_ssb_index.\
                        bitmask = RRM_ZERO;

                    if(p_meas_res_ssb_idx->meas_result_ssb_index_r15.\
                            bitmask & THRESHOLD_LIST_NR_RSRP_PRESENT) 
                    {
                        p_rrm_meas_ssb_idx->meas_result_ssb_index.bitmask |= 
                            MEAS_RESULT_NR_RSRP_PRESENT;
                        p_rrm_meas_ssb_idx->meas_result_ssb_index.\
                            rsrp_result_nr_r15 = 
                            p_meas_res_ssb_idx->meas_result_ssb_index_r15.\
                            rsrp_nr_r15;
                    }
                    if(p_meas_res_ssb_idx->meas_result_ssb_index_r15.\
                            bitmask & THRESHOLD_LIST_NR_RSRQ_PRESENT) 
                    {
                        p_rrm_meas_ssb_idx->meas_result_ssb_index.bitmask |= 
                            MEAS_RESULT_NR_RSRQ_PRESENT;
                        p_rrm_meas_ssb_idx->meas_result_ssb_index.\
                            rsrq_result_nr_r15 = 
                            p_meas_res_ssb_idx->meas_result_ssb_index_r15.\
                            rsrq_nr_r15;
                    }
                    if(p_meas_res_ssb_idx->meas_result_ssb_index_r15.\
                            bitmask & THRESHOLD_LIST_NR_SINR_PRESENT) 
                    {
                        p_rrm_meas_ssb_idx->meas_result_ssb_index.\
                            bitmask |= MEAS_RESULT_NR_RS_SINR_PRESENT;
                        p_rrm_meas_ssb_idx->meas_result_ssb_index.\
                            rs_sinr_result_r15 = 
                            p_meas_res_ssb_idx->meas_result_ssb_index_r15.\
                            sinr_nr_r15;
                    }
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_mrdc_supported_band_comb_list
 *   INPUT        : rrc_supported_band_comb_list
 *   OUTPUT       : rrm_supported_band_comb_list
 *   DESCRIPTION  :
 *        Populate the MRDC ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS      : NONE
 *****************************************************************************/
rrm_void_t
rrm_uem_fill_mrdc_supported_band_comb_list
(
    supported_band_comb_list_t        *p_rrc_supported_band_comb_list,
    rrm_supported_band_comb_list_t    *p_rrm_supported_band_comb_list,
    rrm_ue_context_t                  *p_ue_context
)
{
    U16    band_comb_count = RRM_ZERO;
    U16    band_count      = RRM_ZERO;

    band_combination_band_list_t        *p_rrc_band_combination_band_list = RRM_PNULL;
    rrm_band_combination_band_list_t    *p_rrm_band_combination_band_list = RRM_PNULL;

    U16  nr_band_arr_index  = RRM_ZERO;
    U16  nr_band_bit  = RRM_ZERO;
    U16  nr_freq_band_indicator = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* coverity_280037_fix_start */
    RRM_ASSERT(p_ue_context != RRM_PNULL);
/* NR_BAND_FIX_START */
        RRM_MEMSET(p_ue_context->nr_band_bitmap_fdd, RRM_NULL, MAX_NR_FREQ_BANDS_OCT);
        RRM_MEMSET(p_ue_context->nr_band_bitmap_tdd, RRM_NULL, MAX_NR_FREQ_BANDS_OCT);
/* NR_BAND_FIX_END */
    /* coverity_280037_fix_end */

    p_rrm_supported_band_comb_list->count = p_rrc_supported_band_comb_list->count;

    for ( band_comb_count = RRM_ZERO; band_comb_count <
        p_rrm_supported_band_comb_list->count; band_comb_count++ )
    {
        /*
         * feature_set_combination
         */
        p_rrm_supported_band_comb_list->band_combination_list[band_comb_count].
            feature_set_combination =
            p_rrc_supported_band_comb_list->band_combination[band_comb_count].
            feature_set_combination;

        p_rrc_band_combination_band_list =  &(p_rrc_supported_band_comb_list->
            band_combination[band_comb_count].band_combination_band_list);

        p_rrm_band_combination_band_list =  &(p_rrm_supported_band_comb_list->
            band_combination_list[band_comb_count].band_combination_band_list);

        p_rrm_band_combination_band_list->count =
            p_rrc_band_combination_band_list->count;

        for ( band_count = RRM_ZERO; band_count < p_rrm_band_combination_band_list->
            count; band_count++ )
        {
            p_rrm_band_combination_band_list->band_list[band_count].bitmask =
                p_rrc_band_combination_band_list->band[band_count].bitmask;

            if ( BAND_PARAMETERS_EUTRA_PRESENT &
                 p_rrc_band_combination_band_list->band[band_count].bitmask )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "MRDC band parameters eutra is present");

                p_rrm_band_combination_band_list->band_list[band_count].eutra.bitmask |=
                    RRM_BAND_PARAMETERS_EUTRA_PRESENT;
                p_rrm_band_combination_band_list->band_list[band_count].eutra.band_eutra =
                    p_rrc_band_combination_band_list->band[band_count].eutra.
                    band_eutra;

                if ( BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_PRESENT &
                    p_rrc_band_combination_band_list->band[band_count].eutra.bitmask )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "MRDC band parameters eutra CA bandwidth class DL is present");
                    p_rrm_band_combination_band_list->band_list[band_count].eutra.
                        ca_bandwidth_class_dl_eutra =
                        p_rrc_band_combination_band_list->band[band_count].eutra.
                        ca_bandwidth_class_dl_eutra;
                    p_rrm_band_combination_band_list->band_list[band_count].eutra.bitmask |=
                        RRM_BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_PRESENT;
                }
                if ( BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_PRESENT &
                    p_rrc_band_combination_band_list->band[band_count].eutra.bitmask )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "MRDC band parameters eutra CA bandwidth class UL is present");
                    p_rrm_band_combination_band_list->band_list[band_count].eutra.
                        ca_bandwidth_class_ul_eutra =
                        p_rrc_band_combination_band_list->band[band_count].eutra.
                        ca_bandwidth_class_ul_eutra;
                    p_rrm_band_combination_band_list->band_list[band_count].eutra.bitmask |=
                        RRM_BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_PRESENT;
                }
            }
            else if ( BAND_PARAMETERS_NR_PRESENT &
                 p_rrc_band_combination_band_list->band[band_count].bitmask )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "MRDC band parameters NR is present");
                p_rrm_band_combination_band_list->band_list[band_count].nr.bitmask =
                    RRM_BAND_PARAMETERS_NR_PRESENT;
                p_rrm_band_combination_band_list->band_list[band_count].nr.band_nr =
                    p_rrc_band_combination_band_list->band[band_count].nr.
                    band_nr;
                /* NR_BAND_FIX_START */
                nr_freq_band_indicator = p_rrm_band_combination_band_list->band_list[band_count].nr.band_nr;

                if( RRM_NR_FREQ_BAND_FDD == rrm_check_nr_freq_band_duplexing_mode(nr_freq_band_indicator))
                {
                nr_band_arr_index = nr_freq_band_indicator / (sizeof(U64)*8);
                nr_band_bit  = nr_freq_band_indicator % (sizeof(U64)*8);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "For UE[%d]:- FDD nr_freq_band_indicator :%u , "
                            "nr_band_arr_index:%u, nr_band_bit :%u",
                            p_ue_context->ue_index,nr_freq_band_indicator,nr_band_arr_index,nr_band_bit);
                    if( nr_band_bit > RRM_ZERO )
                    {
                    p_ue_context->nr_band_bitmap_fdd[nr_band_arr_index] |= ((U64)1 << (nr_band_bit-1)); 
                    }
                }
                else if( RRM_NR_FREQ_BAND_TDD == rrm_check_nr_freq_band_duplexing_mode(nr_freq_band_indicator))
                {
                    nr_band_arr_index = nr_freq_band_indicator / (sizeof(U64)*8);
                    nr_band_bit  = nr_freq_band_indicator % (sizeof(U64)*8);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "For UE[%d]:- TDD nr_freq_band_indicator :%u , "
                                "nr_band_arr_index:%u, nr_band_bit :%u",
                                p_ue_context->ue_index,nr_freq_band_indicator,nr_band_arr_index,nr_band_bit);
                    if( nr_band_bit > RRM_ZERO )
                    {
                    p_ue_context->nr_band_bitmap_tdd[nr_band_arr_index] |= ((U64)1 << (nr_band_bit-1)); 
                    }
                }
                else
                {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "For UE[%d]:- Invalid nr_freq_band_indicator :%u",
                                 p_ue_context->ue_index,nr_freq_band_indicator);
                }
                /* NR_BAND_FIX_END */

                if ( BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_NR_PRESENT &
                    p_rrc_band_combination_band_list->band[band_count].nr.bitmask )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "MRDC band parameters NR CA bandwidth class DL is present");
                    p_rrm_band_combination_band_list->band_list[band_count].nr.
                        ca_bandwidth_class_dl_nr =
                        p_rrc_band_combination_band_list->band[band_count].nr.
                        ca_bandwidth_class_dl_nr;
                    p_rrm_band_combination_band_list->band_list[band_count].nr.bitmask |=
                        RRM_BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_NR_PRESENT;
                }
                if ( BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_NR_PRESENT &
                    p_rrc_band_combination_band_list->band[band_count].nr.bitmask )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "MRDC band parameters NR CA bandwidth class UL is present");
                    p_rrm_band_combination_band_list->band_list[band_count].nr.
                        ca_bandwidth_class_ul_nr =
                        p_rrc_band_combination_band_list->band[band_count].nr.
                        ca_bandwidth_class_ul_nr;
                    p_rrm_band_combination_band_list->band_list[band_count].nr.bitmask |=
                        RRM_BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_NR_PRESENT;
                }
            }
        }
    }

    RRM_UT_TRACE_EXIT();
}
/* MENB_CHANGES_END */
#endif

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_populate_capability_params
 *   INPUT      : p_rrc_ue_capability_info
 *   OUTPUT     : p_rrm_ue_capability_params
 *   DESCRIPTION:
 *        Populate the ue capability params received UE Capability Ind
 *        from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/

static rrm_return_et
rrm_ue_populate_capability_params(
		rrc_radio_capability_info_t *p_rrc_ue_capability_info,
		rrm_ue_capability_params_t *p_rrm_ue_capability_params
#ifdef ENDC_ENABLED
        ,
        rrm_ue_context_t *p_ue_context 
#endif
	)
{
    rrm_return_et	ret_val = RRM_SUCCESS;
    U8 band_eutra_index = RRM_ZERO;
    U8              band_eutra_count = RRM_ZERO;

    /* FGI_change_start */
    U32 feature_group_indicator    = RRM_ZERO;
    /* FGI_change_end */

#ifdef ENDC_ENABLED
    /* MENB_CHANGES_START */
    rrm_ue_eutra_capability_v1310_ies_t *p_rrm_ue_eutra_capability_v1310 = RRM_PNULL;
    ue_eutra_capability_v1310_ies_t    *p_rrc_ue_eutra_capability_v1310 = RRM_PNULL;
    ue_eutra_capability_v1350_ies_t    *p_rrc_ue_eutra_capability_v1350 = RRM_PNULL;
    rrm_ue_eutra_capability_v1350_ies_t *p_rrm_ue_eutra_capability_v1350 = RRM_PNULL;
    /* MENB_CHANGES_END */
#endif

    RRM_UT_TRACE_ENTER();	
    if (RRM_PNULL != p_rrc_ue_capability_info && RRM_PNULL != p_rrm_ue_capability_params)
    {	
        p_rrm_ue_capability_params->bitmask = RRM_ZERO;
        if (p_rrc_ue_capability_info->bitmask & EUTRA_RADIO_CAPABILITY_PRESENT)
        {
            p_rrm_ue_capability_params->bitmask |= RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT;
            /*SPR 16504* fix start */
            p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.bitmask = RRM_ZERO;
            /*SPR 16504* fix stop */

            /* Access Stratum Release */
            rrm_uem_fill_access_stratum_release_info(
                    p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.access_stratum_release,
                    &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.access_stratum_release);

            /* UE Category */
            p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.ue_category = 
                p_rrc_ue_capability_info->eutra_radio_capability_info.
                eutra_radio_capability_info_def.ue_category;

            /* PDCP Prameters */
            /* filling ROHC Profile */ 
            rrm_uem_fill_rohc_profile_info(
                    &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.pdcp_parameters.rohc_profile,
                    &p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.pdcp_parameters.rohc_profile);   

            /* filling max context session*/ 
            rrm_uem_fill_rohc_max_cntxt_session_info(
                    &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.pdcp_parameters.
                    max_num_rohc_context_session,
                    p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.pdcp_parameters.
                    max_num_rohc_context_session);                        

            /* RF Parameters */
            p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.rf_parameters.
                supported_band_list_eutra.count = band_eutra_count = 
                p_rrc_ue_capability_info->eutra_radio_capability_info.
                eutra_radio_capability_info_def.rf_parameters.
                supported_band_list_eutra.count;
            for (band_eutra_index = RRM_ZERO; band_eutra_index < band_eutra_count; ++band_eutra_index)
            {
                p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.rf_parameters.
                    supported_band_list_eutra.supported_band_eutra[band_eutra_index].band_eutra = 
                    p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.rf_parameters.
                    supported_band_list_eutra.supported_band_eutra[band_eutra_index].band_eutra;

                /** Not supported in Rel-1.1 */
            }

            /* Meas Parameters */
            ret_val = rrm_ue_populate_capability_meas_params (
                    &p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.meas_parameters,
                    &p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.meas_prameters);

            /* Feature Group Indicators */
            if (p_rrc_ue_capability_info->eutra_radio_capability_info.
                    eutra_radio_capability_info_def.bitmask & RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
            {

                /* FGI_change_start */
                RRM_MEMCPY(&feature_group_indicator,p_rrc_ue_capability_info->eutra_radio_capability_info.
                        eutra_radio_capability_info_def.feature_group_indicators,RRM_FOUR);
                p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.feature_group_indicators= RRM_NTOHL(feature_group_indicator);
                /* FGI_change_end */ 

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "FGI Value  %d", 
                        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                        eutra_radio_capability_info_def.feature_group_indicators);
                p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.bitmask |= RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, "Feature Group Indicator "
                        "Not Present in RRC UE Capability Ind!!");
            }
            /* Inter RAT Parameters */
            /*Klocwork activity 1-Apr_2014 start*/
            rrm_ue_populate_capability_params_for_inter_rat_params
                (
                 p_rrc_ue_capability_info,
                 p_rrm_ue_capability_params
                );
            /*Klocwork activity 1-Apr_2014 end*/
            /*Klockwork_fix_start*/
            rrm_ue_populate_capability_params_for_geran(p_rrc_ue_capability_info ,p_rrm_ue_capability_params);
            /*Klockwork_fix_end*/


            /* CDMA2000 changes start */
            /*Klockwork_fix_start*/
            rrm_ue_populate_capability_params_for_cdma(p_rrc_ue_capability_info ,p_rrm_ue_capability_params);
            /*Klockwork_fix_end*/
            /* CDMA2000 changes ends */
            /*csg start*/
            if(p_rrc_ue_capability_info->eutra_radio_capability_info.bitmask &
                    UE_EUTRA_CAPABILITY_V920_IES_PRESENT) 
            {
                p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.bitmask |=
                    RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT;
                rrm_uem_fill_ue_eutra_capability_v920_ies(
                        &(p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies),
                        &(p_rrc_ue_capability_info->eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies));
            }
            /*csg end*/

            /* cdma2000 start */
            /*Klocwork activity 1-Apr_2014 start*/
            rrm_ue_populate_capability_params_for_cdma2000_params
                (
                 p_rrc_ue_capability_info,
                 p_rrm_ue_capability_params
                );
            /*Klocwork activity 1-Apr_2014 end*/
            /* MENB_CHANGES_START */
#if  defined(ENDC_ENABLED)
            if((p_rrc_ue_capability_info->eutra_radio_capability_info.bitmask &
                        UE_EUTRA_CAPABILITY_V920_IES_PRESENT) &&
                    (p_rrc_ue_capability_info->eutra_radio_capability_info.
                     ue_eutra_capability_v920_ies.bitmask &
                     RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1090_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1180_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v11a0_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                      ue_eutra_capability_v11a0_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1250_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                      ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1260_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                      ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                      ue_eutra_capability_v1260_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1270_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                      ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                      ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1280_IES_PRESENT) &&
                    ( p_rrc_ue_capability_info->eutra_radio_capability_info.
                      ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                      ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                      ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                      ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                      ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                      ue_eutra_capability_v1280_ies.bitmask &
                      RRC_RRM_UE_EUTRA_CAPABILITY_v1310_IES_PRESENT) 
                    )
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "LWA paramters recieved in UE Capability ");
                        p_rrm_ue_capability_params->rrm_eutra_radio_capability_info.bitmask |=
                            RRM_UE_EUTRA_CAPABILITY_V1310_IES_PRESENT;

#ifdef ENDC_ENABLED
                        /* MENB_CHANGES_START */
                        p_rrm_ue_eutra_capability_v1310 = &(p_rrm_ue_capability_params->
                                rrm_eutra_radio_capability_info.ue_eutra_capability_v1310_ies);
                        p_rrc_ue_eutra_capability_v1310 = &(p_rrc_ue_capability_info->
                                eutra_radio_capability_info.
                                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies);
                        if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1320_IES_PRESENT &
                                p_rrc_ue_eutra_capability_v1310->bitmask )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                    "ue_eutra_capability_v1320 recieved in UE Capability ");
                            p_rrm_ue_eutra_capability_v1310->bitmask |=
                                RRM_UE_EUTRA_CAPABILITY_v1320_IES_PRESENT;

                            if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1330_IES_PRESENT &
                                    p_rrc_ue_eutra_capability_v1310->
                                    ue_eutra_capability_v1320_ies.bitmask )
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                        "ue_eutra_capability_v1330 recieved in UE Capability ");
                                p_rrm_ue_eutra_capability_v1310->ue_eutra_capability_v1320_ies.
                                    bitmask |=
                                    RRM_UE_EUTRA_CAPABILITY_v1330_IES_PRESENT;

                                if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1340_IES_PRESENT &
                                        p_rrc_ue_eutra_capability_v1310->
                                        ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                        bitmask )
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                            "ue_eutra_capability_v1340 recieved in UE Capability ");
                                    p_rrm_ue_eutra_capability_v1310->ue_eutra_capability_v1320_ies.
                                        ue_eutra_capability_v1330_ies.bitmask |=
                                        RRM_UE_EUTRA_CAPABILITY_v1340_IES_PRESENT;

                                    if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1350_IES_PRESENT &
                                            p_rrc_ue_eutra_capability_v1310->
                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                            ue_eutra_capability_v1340_ies.bitmask )
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                "ue_eutra_capability_v1350 recieved in UE Capability ");
                                        p_rrm_ue_eutra_capability_v1310->ue_eutra_capability_v1320_ies.
                                            ue_eutra_capability_v1330_ies.ue_eutra_capability_v1340_ies.
                                            bitmask |=
                                            RRM_UE_EUTRA_CAPABILITY_v1350_IES_PRESENT;

                                        p_rrc_ue_eutra_capability_v1350 = &(p_rrc_ue_eutra_capability_v1310->
                                                ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies);

                                        if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1360_IES_PRESENT &
                                                p_rrc_ue_eutra_capability_v1350->bitmask )
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                    "ue_eutra_capability_v1360 recieved in UE Capability ");
                                            p_rrm_ue_eutra_capability_v1350 = &(p_rrm_ue_eutra_capability_v1310->
                                                    ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                    ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies);

                                            p_rrm_ue_eutra_capability_v1350->bitmask |=
                                                RRM_UE_EUTRA_CAPABILITY_v1360_IES_PRESENT;

                                            if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1430_IES_PRESENT &
                                                    p_rrc_ue_eutra_capability_v1350->
                                                    ue_eutra_capability_v1360_ies.bitmask )
                                            {
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                        "ue_eutra_capability_v1430 recieved in UE Capability ");
                                                p_rrm_ue_eutra_capability_v1350->
                                                    ue_eutra_capability_v1360_ies.bitmask |=
                                                    RRM_UE_EUTRA_CAPABILITY_v1430_IES_PRESENT;

                                                if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1440_IES_PRESENT &
                                                        p_rrc_ue_eutra_capability_v1350->
                                                        ue_eutra_capability_v1360_ies.bitmask )
                                                {
                                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                            "ue_eutra_capability_v1440 recieved in UE Capability ");
                                                    p_rrm_ue_eutra_capability_v1350->
                                                        ue_eutra_capability_v1360_ies.
                                                        ue_eutra_capability_v1430_ies.bitmask |=
                                                        RRM_UE_EUTRA_CAPABILITY_v1440_IES_PRESENT;

                                                    if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1450_IES_PRESENT &
                                                            p_rrc_ue_eutra_capability_v1350->
                                                            ue_eutra_capability_v1360_ies.
                                                            ue_eutra_capability_v1430_ies.bitmask )
                                                    {
                                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                                "ue_eutra_capability_v1450 recieved in UE Capability ");
                                                        p_rrm_ue_eutra_capability_v1350->
                                                            ue_eutra_capability_v1360_ies.
                                                            ue_eutra_capability_v1430_ies.
                                                            ue_eutra_capability_v1440_ies.bitmask |=
                                                            RRM_UE_EUTRA_CAPABILITY_v1450_IES_PRESENT;

                                                        if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1460_IES_PRESENT &
                                                                p_rrc_ue_eutra_capability_v1350->
                                                                ue_eutra_capability_v1360_ies.
                                                                ue_eutra_capability_v1430_ies.
                                                                ue_eutra_capability_v1440_ies.bitmask )
                                                        {
                                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                                    "ue_eutra_capability_v1460 recieved in UE Capability ");
                                                            p_rrm_ue_eutra_capability_v1350->
                                                                ue_eutra_capability_v1360_ies.
                                                                ue_eutra_capability_v1430_ies.
                                                                ue_eutra_capability_v1440_ies.
                                                                ue_eutra_capability_v1450_ies.bitmask |=
                                                                RRM_UE_EUTRA_CAPABILITY_v1460_IES_PRESENT;

                                                            if ( RRC_RRM_UE_EUTRA_CAPABILITY_V1510_IES_PRESENT &
                                                                    p_rrc_ue_eutra_capability_v1350->
                                                                    ue_eutra_capability_v1360_ies.
                                                                    ue_eutra_capability_v1430_ies.
                                                                    ue_eutra_capability_v1440_ies.
                                                                    ue_eutra_capability_v1450_ies.
                                                                    ue_eutra_capability_v1460_ies.bitmask )
                                                            {
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                                        "ue_eutra_capability_v1510 recieved in UE Capability ");
                                                                p_rrm_ue_eutra_capability_v1350->
                                                                    ue_eutra_capability_v1360_ies.
                                                                    ue_eutra_capability_v1430_ies.
                                                                    ue_eutra_capability_v1440_ies.
                                                                    ue_eutra_capability_v1450_ies.
                                                                    ue_eutra_capability_v1460_ies.bitmask |=
                                                                    RRM_UE_EUTRA_CAPABILITY_v1510_IES_PRESENT;

                                                                rrm_uem_fill_ue_eutra_endc_capability_v1510_ies(
                                                                        &(p_rrm_ue_eutra_capability_v1350->
                                                                            ue_eutra_capability_v1360_ies.
                                                                            ue_eutra_capability_v1430_ies.
                                                                            ue_eutra_capability_v1440_ies.
                                                                            ue_eutra_capability_v1450_ies.
                                                                            ue_eutra_capability_v1460_ies.
                                                                            ue_eutra_capability_v1510_ies),
                                                                        &(p_rrc_ue_eutra_capability_v1350->
                                                                            ue_eutra_capability_v1360_ies.
                                                                            ue_eutra_capability_v1430_ies.
                                                                            ue_eutra_capability_v1440_ies.
                                                                            ue_eutra_capability_v1450_ies.
                                                                            ue_eutra_capability_v1460_ies.
                                                                            ue_eutra_capability_v1510_ies));
                                                            }
                                                            else
                                                            {
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                                        "ue_eutra_capability_v1510 is not recieved in UE Capability ");
                                                            }
                                                        }
                                                        else
                                                        {
                                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                                    "ue_eutra_capability_v1460 is not recieved in UE Capability ");
                                                        }
                                                    }
                                                    else
                                                    {
                                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                                "ue_eutra_capability_v1450 is not recieved in UE Capability ");
                                                    }
                                                }
                                                else
                                                {
                                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                            "ue_eutra_capability_v1440 is not recieved in UE Capability ");
                                                }
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                        "ue_eutra_capability_v1430 is not recieved in UE Capability ");
                                            }
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                    "ue_eutra_capability_v1360 is not recieved in UE Capability ");
                                        }
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                                "ue_eutra_capability_v1350 is not recieved in UE Capability ");
                                    }
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                            "ue_eutra_capability_v1340 is not recieved in UE Capability ");
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                        "ue_eutra_capability_v1330 is not recieved in UE Capability ");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                    "ue_eutra_capability_v1320 is not recieved in UE Capability ");
                        }
                        /* MENB_CHANGES_END */
#endif

                    }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "ue_eutra_capability_v1310 paramters NOT recieved in UE Capability ");
            }

            /* MENB_CHANGES_END */
#endif            
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, "EUTRA RADIO CAPABILITY "
                    "Not Present in RRC UE Capability Ind!!");
        }
#ifdef ENDC_ENABLED
        /* MENB_CHANGES_START */
        if ( EURTA_NR_RADIO_CAPABILITY_PRESENT & p_rrc_ue_capability_info->bitmask )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "MRDC RADIO CAPABILITY "
                    "is Present in RRC UE Capability Ind!!");
            p_rrm_ue_capability_params->bitmask |= RRM_UE_EUTRA_NR_RADIO_CAPABILITY_PRESENT;

            if ( RF_PARAMETERS_MRDC_SUPPORTED_BAND_COMB_LIST_PRESENT &
                    p_rrc_ue_capability_info->eutra_nr_radio_capability_info.
                    rf_parameters_mrdc.bitmask )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "RF parameters MRDC "
                        "supported band combination list is present");
                p_rrm_ue_capability_params->rrm_eutra_nr_radio_capability_info.
                    rf_parameters_mrdc.bitmask |=
                    RRM_RF_PARAMETERS_MRDC_SUPPORTED_BAND_COMB_LIST_PRESENT;

                /* MRDC Supported Band combination list */
                rrm_uem_fill_mrdc_supported_band_comb_list(
                        &p_rrc_ue_capability_info->eutra_nr_radio_capability_info.
                        rf_parameters_mrdc.supported_band_comb_list,
                        &p_rrm_ue_capability_params->rrm_eutra_nr_radio_capability_info.
                        rf_parameters_mrdc.supported_band_comb_list,
                        p_ue_context);
/* NR_BAND_FIX_START */
                if( RRM_TRUE == rrm_check_is_ue_support_endc(p_ue_context) &&
                    RRM_TRUE == rrm_check_frequancy_band(p_ue_context))
                {
                   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "MRDC capability is valid and updated in ue context \n");
                     p_ue_context->rrm_endc_nr_data.mrdc_capability_valid = RRM_TRUE;
            }
/* NR_BAND_FIX_END */
 
            }
            
        }
        /* MENB_CHANGES_END */

/* ENDC_MEAS_CHANGES_START */
        if ( NR_RADIO_CAPABILITY_PRESENT & p_rrc_ue_capability_info->bitmask )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "NR RADIO CAPABILITY "
                    "is Present in RRC UE Capability Ind!!");
            p_rrm_ue_capability_params->bitmask |= RRM_UE_NR_RADIO_CAPABILITY_PRESENT;

            if ( RRC_NR_SUPPORTED_GAP_PATTERN_PRESENT &
                    p_rrc_ue_capability_info->nr_radio_capability_info.
                    bitmask )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "supported meas gap pattern present \n");
                p_rrm_ue_capability_params->rrm_nr_radio_capability_info.\
                    bitmask |=
                    RRM_NR_RADIO_CAPABILITY_NR_MEAS_PRESENT;
                p_rrm_ue_capability_params->rrm_nr_radio_capability_info.\
                    rrm_nr_meas_parameters.supported_gap_pattern =
                    p_rrc_ue_capability_info->nr_radio_capability_info.\
                    supported_gap_pattern; 
            }
        }
/* ENDC_MEAS_CHANGES_END */
#endif

        /*SPR_17893_START*/
        if (p_rrc_ue_capability_info->bitmask & UTRA_RADIO_CAPABILITY_PRESENT)
        {
            p_rrm_ue_capability_params->bitmask |= RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "UTRA RADIO CAPABILITY BUFFER Not Present in RRC UE Capability Ind!!");
        }
        /*SPR_17893_END*/
        /*SPR 20459 FIX START*/
        if (p_rrc_ue_capability_info->bitmask & CDMA2000_RADIO_CAPABILITY_PRESENT)
        {
            p_rrm_ue_capability_params->bitmask |= RRM_UE_CDMA2000_RADIO_CAPABILITY_PRESENT;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "CDMA2000 RADIO CAPABILITY BUFFER Not Present in RRC UE Capability Ind!!");
        }
        /*SPR 20459 FIX END*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Invalid Arguments[p_rrc_ue_capability_info = %p,"
                "p_rrm_ue_capability_params = %p] passed",
                p_rrc_ue_capability_info, p_rrm_ue_capability_params);
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_capability_ind_check_and_fill 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission request 
 *****************************************************************************/
void
rrm_ue_rrc_parse_ue_capability_ind_check_and_fill
(
 /* SPR 21496 Fix Start */
 rrc_radio_capability_info_t *p_radio_capability_info, 
 rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
 rrm_return_et    *p_ret_val
 /* SPR 21496 Fix End */
 )
{

    RRM_UT_TRACE_ENTER();
    /* SPR 21496 Fix Start */
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    /* don't take this variable and no need to take memory */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d],Successfully parsed UE "
            "CAPABILITY IND",p_rrm_ue_rrc_msg->ue_index);
    /* get the ue context with help of ue index and pass the ue
     * capability lying inside the ue context */
    p_ue_context = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
            p_rrm_ue_rrc_msg->cell_index);
    if (RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "[UE:%d], failed to find ue context",p_rrm_ue_rrc_msg->ue_index);
        *p_ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d], UE CONTEXT FOUND",p_ue_context->ue_index);
        /* SPR 21496 Fix Start */
        /** Release UE Capability params from UE Context if UE Capability is received again so
         * that it could not lead to memory leak **/
        rrm_ue_release_ue_capability_params(p_ue_context);
        /* SPR 21496 Fix End */
        /** Populate UE Capability to Store in ue context */
        *p_ret_val = rrm_ue_populate_capability_params(
                p_radio_capability_info,
                &p_ue_context->ue_capability_params
#ifdef ENDC_ENABLED
                ,
                p_ue_context
#endif
                );
        if (RRM_SUCCESS == *p_ret_val)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d],Successfully Populate UE "
                    "CAPABILITY IND in UE Context", p_rrm_ue_rrc_msg->ue_index);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Populate RRC_RRM_UE_CAPABILITY_IND"
                    "for [UE:%d]", p_rrm_ue_rrc_msg->ue_index);
        }
        /* Raise Event - RRM_EVENT_LOCAL_EVENT_UE_CAPABILITY START*/ /* Coverity: CID 58742 */
        rrm_raise_event_ue_capability(/*SPR 17777 +-*/
                p_radio_capability_info->
                eutra_radio_capability_info.eutra_radio_capability_info_def.
                access_stratum_release,
                p_radio_capability_info->
                eutra_radio_capability_info.eutra_radio_capability_info_def.
                ue_category,
                p_radio_capability_info->
                eutra_radio_capability_info.eutra_radio_capability_info_def.
                feature_group_indicators);
        /* Raise Event - RRM_EVENT_LOCAL_EVENT_UE_CAPABILITY END */
    }
    /* SPR 21496 Fix End */
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_capability_ind 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission request 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_capability_ind(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_capability_ind_t *p_rrc_ue_capability_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_ue_capability_ind = (rrc_rrm_ue_capability_ind_t*)
                              rrm_mem_get(sizeof(rrc_rrm_ue_capability_ind_t));
    if (RRM_PNULL == p_rrc_ue_capability_ind)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }
    /** Parse the ue capability indication message */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_capability_ind(
                    		p_rrc_ue_capability_ind,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
   	{
   		p_rrm_ue_rrc_msg->ue_index = p_rrc_ue_capability_ind->ue_Index;
		/** TO BE UPADTE LATER - when RRC will provide the cell index */
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector changed end*/

        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
              "RRC->UEM:RRC_RRM_UE_CAPABILITY_IND successfully parsed");
        /*Klocwork activity 1-Apr_2014 start*/
        /* SPR 21496 Fix Start */
        /* UE capability will be directly stored in the UE Context and p_rrm_ue_rrc_msg will not contain it */
        p_rrm_ue_rrc_msg->p_msg_data = RRM_PNULL;
        rrm_ue_rrc_parse_ue_capability_ind_check_and_fill
            (
             &p_rrc_ue_capability_ind->radio_capability_info,
             p_rrm_ue_rrc_msg,
             &ret_val
            );
        /* SPR 21496 Fix End */
        /*Klocwork activity 1-Apr_2014 end*/
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_UE_CAPABILITY_IND parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_rrc_ue_capability_ind);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_setup_req_for_csfb
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg,spid
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE ERAB setup request message from L3
 *****************************************************************************/
void
rrm_ue_rrc_parse_ue_erab_setup_req_for_csfb
(
 rrc_rrm_erb_setup_req_t     *p_rrc_ue_erb_setup_req,
 rrm_ue_proc_erab_setup_data_t   *p_ue_proc_data
)
{
    RRM_UT_TRACE_ENTER();

    if(p_rrc_ue_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_SUB_PROFILE_ID_PRESENT)
    {
        p_ue_proc_data->spid = p_rrc_ue_erb_setup_req->sub_profile_id;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "SPID present in erab_setup_req");
        p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_SPID_PRESENT;
    }
    /* SRVCC SUPPORT START */
    if((p_rrc_ue_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_SRVCC_HO_OP_POSSIBLE_PRESENT)
            && (RRM_TRUE == p_rrc_ue_erb_setup_req->srvcc_ho_op_possible))
    {
        p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_SRVCC_OP_POSSIBLE_PRESENT;
        p_ue_proc_data->srvcc_op_possible = RRM_TRUE;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "srvcc_op_possible present in erab_setup_req");
    }
    /* SRVCC SUPPORT END */

    if(p_rrc_ue_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_CSF_INDICATOR_PRESENT)
    {
        p_ue_proc_data->csf_indicator = p_rrc_ue_erb_setup_req->csf_indicator;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CSF_Indicator present in erab_setup_req");
        p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_CSF_INDICATOR_PRESENT;
    }
    if(p_rrc_ue_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_REGISTERED_LAI_PRESENT)
    {
        /*coverity 21487, rrm_uem_registered_lai_t replaced, aditya rel1.3.1*/

        /*BUG 680 fix start*/
        rrm_map_rrm_rrc_registered_lai_t(&(p_ue_proc_data->registered_lai), &(p_rrc_ue_erb_setup_req->registered_lai));
        /*BUG 680 fix end*/

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Registered_lai present in erab_setup_req");
        p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_REGISTERED_LAI_PRESENT;
    }
    /*start csg membership*/
    if(p_rrc_ue_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_CSG_MEM_STATUS)
    {
        p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_CSG_MEM_STATUS_PRESENT;
        if(p_rrc_ue_erb_setup_req->csg_mem_status == RRC_MEMBER)
        {
            p_ue_proc_data->csg_membership_status = RRM_MEMBER;
        }
        else /*RRC_NOT_MEMBER*/
        {
            p_ue_proc_data->csg_membership_status = RRM_NOT_MEMBER;
        }
    }
    /*end csg membership*/
    /* ho_restriction_list */
    if(p_rrc_ue_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_HO_RESTRICTION_LIST_PRESENT)
    {
        p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_HO_RESTRICTION_LIST_PRESENT;
        /*SPR 21848 Start*/
        rrm_map_ho_restriction_list(&(p_ue_proc_data->ho_restriction_list),&(p_rrc_ue_erb_setup_req->ho_restriction_list));
        /*SPR 21848 End*/
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_setup_req_success
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg,spid
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE ERAB setup request message from L3
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_erab_setup_req_success(rrc_rrm_erb_setup_req_t         *p_rrc_ue_erb_setup_req ,
                                           rrm_ue_proc_erab_setup_data_t   *p_ue_proc_data ,
                                           rrm_ue_rrc_msg_t                *p_rrm_ue_rrc_msg)
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    U8                          index = RRM_NULL;
    RRM_UT_TRACE_ENTER();
    /*coverity 21490, erb_setup_item_list initialized to NULL, aditya, rel1.3.1*/
    rrm_ue_erab_setup_item_list_t 	erb_setup_item_list = {RRM_ZERO};

           p_ue_proc_data->bitmask = RRM_ZERO;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d],Successfully allocated "
                        "the proc data for RRC_RRM_ERAB_SETUP_REQ",
                        p_rrc_ue_erb_setup_req->ue_index);
           	p_rrm_ue_rrc_msg->ue_index = p_rrc_ue_erb_setup_req->ue_index;
			/** TO BE UPADTE LATER - when RRC will provide the cell index */

            if(RRM_TRUE == (p_rrc_ue_erb_setup_req->bitmask & 
                    RRC_RRM_ERB_SETUP_REQ_UE_AGG_MAX_BIT_RATE_PRESENT))
            {
                p_ue_proc_data->ambr.ue_agg_max_bit_rate_ul = 
                    p_rrc_ue_erb_setup_req->ue_agg_max_bit_rate.
                        ue_agg_max_bit_rate_ul;
                p_ue_proc_data->ambr.ue_agg_max_bit_rate_dl = 
                    p_rrc_ue_erb_setup_req->ue_agg_max_bit_rate.
                        ue_agg_max_bit_rate_dl;
                p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_AMBR_PRESENT;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                          "DEBUG: AMBR UL[%llu], DL[%llu]",
                          p_ue_proc_data->ambr.ue_agg_max_bit_rate_ul,
                          p_ue_proc_data->ambr.ue_agg_max_bit_rate_dl);
            }

            #ifdef ENDC_ENABLED
            if(p_rrc_ue_erb_setup_req->bitmask & 
                    RRC_RRM_ERB_SETUP_REQ_UE_AGG_MAX_BIT_RATE_PRESENT)
            {
                if ( RRC_RRM_EXT_UE_AGG_MAX_BITRATE_PRESENT &
                    p_rrc_ue_erb_setup_req->ue_agg_max_bit_rate.bitmask )
                {
                    p_ue_proc_data->ambr.bitmask |= 
                        RRM_EXT_UE_AGG_MAX_BITRATE_EXT_PRESENT;

                    p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_ul_ext = 
                        p_rrc_ue_erb_setup_req->ue_agg_max_bit_rate.
                        ue_agg_max_bit_rate_ext.ext_ue_agg_max_bit_rate_ul;

                    p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_dl_ext = 
                        p_rrc_ue_erb_setup_req->ue_agg_max_bit_rate.
                        ue_agg_max_bit_rate_ext.ext_ue_agg_max_bit_rate_dl;
                }
                p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_AMBR_PRESENT;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                          "DEBUG: AMBR Ext UL[%llu], DL[%llu]",
                          p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_ul_ext,
                          p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_dl_ext);
            }
            #endif

            erb_setup_item_list.num_of_list = 
                    p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.num_of_list;
            for(index=RRM_NULL;index< erb_setup_item_list.num_of_list;
                        index++ )
            {
            	erb_setup_item_list.erab_item[index].erab_id = 
                    p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                        erab_to_be_setup_item[index].erab_id;

				if (p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].bitmask &
						ERAB_TO_BE_SETUP_LIPA_RAB_IND_PRESENT_FLAG)
				{
					erb_setup_item_list.erab_item[index].lipa_rab_ind = 
						p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
						erab_to_be_setup_item[index].lipa_rab_ind;
					
                    erb_setup_item_list.erab_item[index].bitmask |= 
						RRM_UEM_ERAB_TO_BE_SETUP_LIPA_RAB_IND_PRESENT_FLAG;
				}

                erb_setup_item_list.erab_item[index].erab_level_qos_params.
                    bitmask = p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    bitmask;

                erb_setup_item_list.erab_item[index].erab_level_qos_params.
                    qci = p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.qci;

                 /* Raising event LOCAL_ERAB_SETUP_QCI
                    This shall be triggered when ERAB setup Request arrives at RRM
                 */
                rrm_raise_event_erab_setup_qci(p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                                               erab_to_be_setup_item[index].erab_id, 
                                               p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                                               erab_to_be_setup_item[index].erab_level_qos_params.qci);
                                               /*SPR 17777 +-*/


                erb_setup_item_list.erab_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.priority_level = 
                    p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.priority_level;
                    

                erb_setup_item_list.erab_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_capability = 
                    p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_capability;

                erb_setup_item_list.erab_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_vulnerability = 
                    p_rrc_ue_erb_setup_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_vulnerability;

                 erb_setup_item_list.erab_item[index].erab_level_qos_params.bitmask = 0x00;

                if(p_rrc_ue_erb_setup_req->\
                        erab_to_be_setup_item_list.erab_to_be_setup_item[index].
                        erab_level_qos_params.bitmask & ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT)
                {
                    erb_setup_item_list.erab_item[index].erab_level_qos_params.
                        gbr_qos_info.erab_max_bit_rate_dl = p_rrc_ue_erb_setup_req->\
                        erab_to_be_setup_item_list.erab_to_be_setup_item[index].
                        erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl;

                    erb_setup_item_list.erab_item[index].erab_level_qos_params.
                        gbr_qos_info.erab_max_bit_rate_ul = p_rrc_ue_erb_setup_req->\
                        erab_to_be_setup_item_list.erab_to_be_setup_item[index].
                        erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul;

                    erb_setup_item_list.erab_item[index].erab_level_qos_params.
                        gbr_qos_info.erab_guar_bit_rate_dl = p_rrc_ue_erb_setup_req->\
                        erab_to_be_setup_item_list.erab_to_be_setup_item[index].
                        erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;

                    erb_setup_item_list.erab_item[index].erab_level_qos_params.
                        gbr_qos_info.erab_guar_bit_rate_ul = p_rrc_ue_erb_setup_req->\
                        erab_to_be_setup_item_list.erab_to_be_setup_item[index].
                        erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;
                    erb_setup_item_list.erab_item[index].erab_level_qos_params.bitmask |=
                        ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT;
                }
            }
            /* Updating the CSFB param from rrc_rrm_erb_setup_req_t to 
                  rrm_ue_proc_erab_setup_data_t */
    /*Klocwork activity 1-Apr_2014 start*/
    /*Cov_fix_63675_start*/    
    rrm_ue_rrc_parse_ue_erab_setup_req_for_csfb
        (
         p_rrc_ue_erb_setup_req,
         p_ue_proc_data
        );
    /*Cov_fix_63675_end*/        
    /*Klocwork activity 1-Apr_2014 end*/
            p_ue_proc_data->erab_setup_list = erb_setup_item_list;
                p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;
                ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/*Klocwork activity 1-Apr_2014 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_setup_req 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg,spid
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE ERAB setup request message from L3 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
	/* SPR 17438 Fix Start */
rrm_return_et
rrm_ue_rrc_parse_ue_erab_setup_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
	/* SPR 17438 Fix End */
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_erb_setup_req_t     *p_rrc_ue_erb_setup_req = RRM_PNULL;
    rrm_ue_proc_erab_setup_data_t   *p_ue_proc_data = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_ue_erb_setup_req = (rrc_rrm_erb_setup_req_t*)
                              rrm_mem_get(sizeof(rrc_rrm_erb_setup_req_t));
    if (RRM_PNULL == p_rrc_ue_erb_setup_req)
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory"); 
	return RRM_FAILURE;
    }
    /** Parse the ue ERAB setup request */
/*BUG 585, Multisector change start*/
         p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector changed end*/
    SET_CELL_INDEX(p_rrm_ue_rrc_msg->cell_index);
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_erb_setup_req(
                    		p_rrc_ue_erb_setup_req,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
    {
        /* SPR 21251 Start */
        SET_UE_INDEX(p_rrc_ue_erb_setup_req->ue_index);
        /* Raising Event - RRM_EVENT_LOCAL_ERAB_SETUP_ATTEMPT START */
        rrm_raise_event_erab_setup_attempt(p_rrc_ue_erb_setup_req);
         /*SPR 17777 +-*/
        /* Raising Event - RRM_EVENT_LOCAL_ERAB_SETUP_ATTEMPT End */

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_ERB_SETUP_REQ successfully parsed");
        p_ue_proc_data = (rrm_ue_proc_erab_setup_data_t*)
                rrm_mem_get(sizeof(rrm_ue_proc_erab_setup_data_t));

        /*Kshitij_start CID: 16306 */
        if(RRM_PNULL == p_ue_proc_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                      "rrm_ue_rrc_parse_ue_erab_setup_req: Mem allocation failed");
            RRM_MEM_FREE(p_rrc_ue_erb_setup_req);
            return RRM_FAILURE;
        }
        /*Kshitij_end*/ 
        else
        {
        RRM_MEMSET(p_ue_proc_data, RRM_NULL, sizeof(rrm_ue_proc_erab_setup_data_t));
	/* SPR 17438 Fix Start */
	/*Code Deleted*/
	/* SPR 17438 Fix End */
        if(RRM_PNULL == p_ue_proc_data)
        {
        	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%d],Failed to allocate the "
                        "proc data for RRC_RRM_ERAB_SETUP_REQ",
                        p_rrc_ue_erb_setup_req->ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /*Klockwork_fix_start*/
            rrm_ue_rrc_parse_ue_erab_setup_req_success(p_rrc_ue_erb_setup_req ,
                                             p_ue_proc_data ,p_rrm_ue_rrc_msg);
            /*Klockwork_fix_end*/
		}
		}
	}
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "RRC->UEM:RRC_RRM_ERB_SETUP_REQ parsing failed");
        ret_val = RRM_FAILURE;

        /* Raise Event - RRM_EVENT_LOCAL_ERAB_ADMISSION_REJECT START */
        rrm_raise_event_erab_adm_rej(RRM_ZERO, 
                                     RRM_EVENT_INVALID_PARAMS_REJECT);
         /*SPR 17777 +-*/
        /* Raise Event - RRM_EVENT_LOCAL_ERAB_ADMISSION_REJECT END*/
    }
    RRM_MEM_FREE(p_rrc_ue_erb_setup_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_modify_req 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission request 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_erab_modify_req(
        U8 *p_api_buf,
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                     	length_read = RRM_NULL;
    rrc_rrm_erab_modify_req_t   rrc_ue_erb_modify_req;
    rrm_ue_proc_erab_setup_data_t 	*p_ue_proc_data = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t 	erb_modify_item_list = {RRM_NULL};
    U8 							index = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    /** Parse the erb modify request message */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_erab_modify_req(
                    		&rrc_ue_erb_modify_req,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
    {
        /* SPR 21251 Start */
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, rrc_ue_erb_modify_req.ue_index);
        /* SPR 21251 End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_ERB_MODIFY_REQ successfully parsed");
    	p_ue_proc_data = (rrm_ue_proc_erab_setup_data_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_erab_setup_data_t));

        /*Kshitij_start Coverity, CID:16303*/
        if(RRM_PNULL == p_ue_proc_data)
        {
              RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "rrm_ue_rrc_parse_ue_erab_modify_req: Mem allocation failed");
              return RRM_FAILURE;
        }
        /* Kshitij_end*/

		/* coverity_280110_fix_start */
	    RRM_MEMSET(p_ue_proc_data,RRM_ZERO,sizeof(rrm_ue_proc_erab_setup_data_t));
	    /* coverity_280110_fix_start */

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d], Successfully parsed "
                    "RRC_RRM_ERAB_MODIFY_REQ",rrc_ue_erb_modify_req.ue_index);
        p_rrm_ue_rrc_msg->ue_index = rrc_ue_erb_modify_req.ue_index;
		/** TO BE UPADTE LATER - when RRC will provide the cell index */
        if(RRM_TRUE == (rrc_ue_erb_modify_req.bitmask & 
            RRC_RRM_ERB_SETUP_REQ_UE_AGG_MAX_BIT_RATE_PRESENT))
        {
            p_ue_proc_data->ambr.ue_agg_max_bit_rate_ul = 
                rrc_ue_erb_modify_req.ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul;
            p_ue_proc_data->ambr.ue_agg_max_bit_rate_dl = 
                rrc_ue_erb_modify_req.ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl;
        }

        #ifdef ENDC_ENABLED
        if ( rrc_ue_erb_modify_req.bitmask & 
                    RRC_RRM_ERB_SETUP_REQ_UE_AGG_MAX_BIT_RATE_PRESENT )
        {
            if ( RRC_RRM_EXT_UE_AGG_MAX_BITRATE_PRESENT &
                    rrc_ue_erb_modify_req.ue_agg_max_bit_rate.bitmask )
            {
                p_ue_proc_data->ambr.bitmask |= 
                    RRM_EXT_UE_AGG_MAX_BITRATE_EXT_PRESENT;

                p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_ul_ext = 
                    rrc_ue_erb_modify_req.ue_agg_max_bit_rate.
                    ue_agg_max_bit_rate_ext.ext_ue_agg_max_bit_rate_ul;

                p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_dl_ext = 
                    rrc_ue_erb_modify_req.ue_agg_max_bit_rate.
                    ue_agg_max_bit_rate_ext.ext_ue_agg_max_bit_rate_dl;
            }
            p_ue_proc_data->bitmask |= RRM_UEM_ERAB_SETUP_REQ_AMBR_PRESENT;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                    "DEBUG: AMBR Ext UL[%llu], DL[%llu]",
                    p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_ul_ext,
                    p_ue_proc_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_dl_ext);
        }
        #endif

        erb_modify_item_list.num_of_list = 
                rrc_ue_erb_modify_req.erab_to_be_modified_item_list.num_of_list;
        for(index = RRM_NULL; index<erb_modify_item_list.num_of_list; 
                    index++)
        {
        	erb_modify_item_list.erab_item[index].erab_id = 
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].erab_id;

        	erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    bitmask = 
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.bitmask;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    qci = 
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.qci;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.priority_level =
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.priority_level;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_capability =
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_capability;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_vulnerability =
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].erab_level_qos_params.
                    alloc_and_reten_prior.preemption_vulnerability;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    gbr_qos_info.erab_max_bit_rate_dl = 
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].
                    erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                     gbr_qos_info.erab_max_bit_rate_ul =
                     rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                     erab_to_be_setup_item[index].
                     erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    gbr_qos_info.erab_guar_bit_rate_dl = 
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].
                    erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;

            erb_modify_item_list.erab_item[index].erab_level_qos_params.
                    gbr_qos_info.erab_guar_bit_rate_ul =
                    rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                    erab_to_be_setup_item[index].
                    erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;

            erb_modify_item_list.erab_item[index].dl_fwding =
                      rrc_ue_erb_modify_req.erab_to_be_modified_item_list.
                      erab_to_be_setup_item[index].
                      dl_fwding;
            /*SPR_18138_Fix_Start*/
            /* Setting Data Forwarding Not Possible to True */
            erb_modify_item_list.erab_item[index].data_fwding_not_possible = RRM_TRUE;
            /*SPR_18138_Fix_End*/

		}
        ret_val = RRM_SUCCESS;
        p_ue_proc_data->erab_setup_list = erb_modify_item_list;
        p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;

        /* Raise Event RRM_EVENT_LOCAL_ERAB_MODIFY_ATTEMPT START*/
        rrm_raise_event_erab_modify_attempt(&rrc_ue_erb_modify_req);
         /*SPR 17777 +-*/
        /* Raise Event RRM_EVENT_LOCAL_ERAB_MODIFY_ATTEMPT END*/
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_ERB_MODIFY_REQ parsing failed");
        ret_val = RRM_FAILURE;
    } 
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_return_et
reponse_code_sucess_process_message
(
 rrc_rrm_erb_setup_cnf_t     *rrc_ue_erb_setup_cnf,
 rrm_ue_rrc_msg_t            *p_rrm_ue_rrc_msg
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    rrm_cell_context_t              *p_cell_ctxt= RRM_PNULL;
    /* SPR 20652 Fix Start */
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_ENTER();

    if( rrc_ue_erb_setup_cnf->response_code != RRM_FAILURE )
    {
        rrm_raise_event_erab_drb_allocated(/*SPR 17777 +-*/
                rrc_ue_erb_setup_cnf);
        /*KPI:start erb setup success and fail*/
        p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_rrc_msg->cell_index);
        /*CID 65888:start*/
        if (RRM_PNULL != p_cell_ctxt)
        {
            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context(rrc_ue_erb_setup_cnf->ue_index,
                    p_rrm_ue_rrc_msg->cell_index);
            if(RRM_PNULL != p_ue_context)
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_fail +=
                    rrc_ue_erb_setup_cnf->erab_error_list.erab_count;
                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_success +=
                    rrc_ue_erb_setup_cnf->erab_cnf_list.erab_count;
                if((RRM_ZERO == p_ue_context->drb_configured.num_of_list) &&
                        (RRM_ZERO != rrc_ue_erb_setup_cnf->erab_cnf_list.erab_count))
                {
                    p_cell_ctxt->kpi_stat.kpi.num_of_ue_admission_success += RRM_ONE;
                }
                else if((RRM_ZERO == p_ue_context->drb_configured.num_of_list) &&
                        (RRM_ZERO == rrc_ue_erb_setup_cnf->erab_cnf_list.erab_count))
                {
                    p_cell_ctxt->kpi_stat.kpi.num_of_ue_admission_fail += RRM_ONE;
                }

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "p_ue_context is NULL for cell_index[%d], [UE:%d]",
                        p_rrm_ue_rrc_msg->cell_index,rrc_ue_erb_setup_cnf->ue_index);
            }
            /*KPI:end erb setup success and fail*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /*CID 65888:end*/
    }
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_EXIT();
    return ret_val;

}


/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_setup_cnf 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE ERAB setup CNF message from L3 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_erab_setup_cnf(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )    
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_erb_setup_cnf_t     rrc_ue_erb_setup_cnf;
    U8								index = RRM_NULL;
    rrm_ue_proc_erab_cnf_data_t 	*p_ue_proc_erab_cnf_data = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /** Parse the UE ERAB setup CNF */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_erb_setup_cnf(
                    		&rrc_ue_erb_setup_cnf,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
    {
        /* SPR 21251 Start */
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, rrc_ue_erb_setup_cnf.ue_index);
        
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_ERB_SETUP_CNF:[UE:%d] with response: %d",
                rrc_ue_erb_setup_cnf.ue_index, rrc_ue_erb_setup_cnf.response_code);

        /* SPR 21251 End */
        p_ue_proc_erab_cnf_data = (rrm_ue_proc_erab_cnf_data_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_erab_cnf_data_t));
        /* Kshitij_start Coverity CID: 16305 */
        if(RRM_PNULL == p_ue_proc_erab_cnf_data)
        {
             RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                       "rrm_ue_rrc_parse_ue_erab_setup_cnf: Mem allocation failed");
             return RRM_FAILURE;
        }
	/* Kshitij_end */
        /*+ Valgrind Fix 29 Nov 2013 +*/
        RRM_MEMSET(p_ue_proc_erab_cnf_data,RRM_ZERO,sizeof(rrm_ue_proc_erab_cnf_data_t));
        /*- Valgrind Fix 29 Nov 2013 -*/
        p_rrm_ue_rrc_msg->ue_index = rrc_ue_erb_setup_cnf.ue_index;

/** TO BE UPADTE LATER - when RRC will provide the cell index */

        p_ue_proc_erab_cnf_data->erab_cnf_list.erab_count = 
                rrc_ue_erb_setup_cnf.erab_cnf_list.erab_count;
        for(index=RRM_NULL; 
            index<p_ue_proc_erab_cnf_data->erab_cnf_list.erab_count; 
            index++)
        {
        	p_ue_proc_erab_cnf_data->erab_cnf_list.erab_cnf_info[index].
                    erab_id = 
                    rrc_ue_erb_setup_cnf.erab_cnf_list.erab_cnf_info[index].
                    erab_id;
        } 

        p_ue_proc_erab_cnf_data->erab_error_list.erab_count = 
                rrc_ue_erb_setup_cnf.erab_error_list.erab_count;
        for(index=RRM_NULL; 
            index<p_ue_proc_erab_cnf_data->erab_error_list.erab_count; 
            index++)
        {
        	p_ue_proc_erab_cnf_data->erab_error_list.
                    erab_error_info[index].erab_id = 
                    rrc_ue_erb_setup_cnf.erab_error_list.erab_error_info[index].
                    erab_id;
            p_ue_proc_erab_cnf_data->erab_error_list.
                    erab_error_info[index].error_code = 
                    rrc_ue_erb_setup_cnf.erab_error_list.erab_error_info[index].
                    error_code;
       	}
        /* SPR 19968 Start */
        p_ue_proc_erab_cnf_data->erab_rel_cnf_list.erab_cnf_list.erab_count = 
                    rrc_ue_erb_setup_cnf.erab_rel_cnf_list.erab_cnf_list.erab_count;
       for(index=RRM_NULL; 
            index<p_ue_proc_erab_cnf_data->erab_rel_cnf_list.erab_cnf_list.erab_count; 
            index++)
        {
        	p_ue_proc_erab_cnf_data->erab_rel_cnf_list.erab_cnf_list.erab_cnf_info[index].
                    erab_id = 
                    rrc_ue_erb_setup_cnf.erab_rel_cnf_list.erab_cnf_list.erab_cnf_info[index].
                    erab_id;
        } 
        /* SPR 19968 End */
        /* SPS related changes start */
        if(rrc_ue_erb_setup_cnf.bitmask & RRC_RRM_ERB_SETUP_CNF_SPS_ERROR_CODE_PRESENT)
        {
            p_ue_proc_erab_cnf_data->sps_error = RRM_TRUE;
        }
        /* SPS related changes end */

        /* SPR_21459 Fix - Start */
        /*SPR 10329:fix start*/
        if(rrc_ue_erb_setup_cnf.bitmask & RRC_RRM_ERB_SETUP_CNF_GUMMEI_INFO_PRESENT)
        {
            p_ue_proc_erab_cnf_data->bitmask |= RRM_UEM_ERAB_SETUP_CNF_GUMMEI_INFO_PRESENT;
            RRM_MEMCPY(&p_ue_proc_erab_cnf_data->gummei_info,&rrc_ue_erb_setup_cnf.gummei_info,
                sizeof(mme_sel_gummei_info_t));
        }
        /*SPR 10329:fix end*/
        if(rrc_ue_erb_setup_cnf.bitmask & RRC_RRM_ERB_SETUP_CNF_MME_ID_PRESENT)
        {
            p_ue_proc_erab_cnf_data->bitmask |= RRM_UEM_ERAB_SETUP_CNF_MME_ID_PRESENT;
            p_ue_proc_erab_cnf_data->mme_id = rrc_ue_erb_setup_cnf.mme_id;
        }
        /* SPR_21459 Fix - End */
        p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_erab_cnf_data;   
        /*coverity 82025 fix start*/
        //ret_val = RRM_SUCCESS;
        /*coverity 82025 fix end*/

        /* Raise Event - RRM_EVENT_LOCAL_ERAB_DRB_ALLOCATED START */
        /*Fix for Bug-334: If response code is FAILURE,don't
          raise the event*/
        /*klock_works_changes_start*/

        ret_val=reponse_code_sucess_process_message(&rrc_ue_erb_setup_cnf, p_rrm_ue_rrc_msg);        

        /*klock_works_changes_end*/
        /* Raise Event - RRM_EVENT_LOCAL_ERAB_DRB_ALLOCATED END */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_ERB_SETUP_CNF->UEM failed to process");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_setup_cnf 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE admission request 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_erab_modify_cnf(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        ) 
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_erb_modify_cnf_t    rrc_ue_erb_modify_cnf;
    U8							index = RRM_NULL;
    rrm_cell_context_t  *p_cell_ctxt = RRM_PNULL;
    rrm_ue_proc_erab_cnf_data_t *p_ue_proc_erab_cnf_data;
    rrm_cell_index_t            cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /** Parse the ue capability indication message */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_erb_modify_cnf(
                    		&rrc_ue_erb_modify_cnf,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
   	{
        cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(cell_index, rrc_ue_erb_modify_cnf.ue_index);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_ERB_MODIFY_CNF:[UE:%d] witn response: %d",
                rrc_ue_erb_modify_cnf.ue_index, rrc_ue_erb_modify_cnf.response);
        /* SPR 12737 Start */
        /*KPI: start erb_modify success and fail*/
        p_cell_ctxt = rrm_cellm_get_cell_context(cell_index);
        /* SPR 12737 Delete */
        /*CID 65827, 65768:start*/
        if (RRM_PNULL != p_cell_ctxt)
        {
            p_cell_ctxt->kpi_stat.kpi.num_of_erb_modify_success += 
                rrc_ue_erb_modify_cnf.erab_cnf_list.erab_count;
            p_cell_ctxt->kpi_stat.kpi.num_of_erb_modify_fail += 
                rrc_ue_erb_modify_cnf.erab_error_list.erab_count;
            /*KPI: start erb_modify success and fail*/
            /* SPR 12737 End */
        }
        /*CID 65827,65768:end*/
        p_ue_proc_erab_cnf_data = (rrm_ue_proc_erab_cnf_data_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_erab_cnf_data_t));
        if (RRM_PNULL == p_ue_proc_erab_cnf_data)
        {
        	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],Failed to allocate the erab "
                        "conf data",rrc_ue_erb_modify_cnf.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
        	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],allocated the erab conf "
                        "data",rrc_ue_erb_modify_cnf.ue_index);    
            p_rrm_ue_rrc_msg->ue_index = rrc_ue_erb_modify_cnf.ue_index;
			/** TO BE UPADTE LATER - when RRC will provide the cell index */
            p_rrm_ue_rrc_msg->cell_index = cell_index;

            p_ue_proc_erab_cnf_data->erab_cnf_list.erab_count = 
                    rrc_ue_erb_modify_cnf.erab_cnf_list.erab_count;
            for(index=RRM_NULL; 
                index<p_ue_proc_erab_cnf_data->erab_cnf_list.erab_count
                ; index++)
            {
            	p_ue_proc_erab_cnf_data->erab_cnf_list.
                        erab_cnf_info[index].erab_id = 
                        rrc_ue_erb_modify_cnf.erab_cnf_list.
                        erab_cnf_info[index].erab_id;
            }

            p_ue_proc_erab_cnf_data->erab_error_list.erab_count = 
                    rrc_ue_erb_modify_cnf.erab_error_list.erab_count;
            for(index=RRM_NULL; 
                index<p_ue_proc_erab_cnf_data->erab_error_list.
                erab_count; index++)
            {
            	p_ue_proc_erab_cnf_data->erab_error_list.
                        erab_error_info[index].erab_id = 
                        rrc_ue_erb_modify_cnf.erab_error_list.
                        erab_error_info[index].erab_id;
                p_ue_proc_erab_cnf_data->erab_error_list.
                        erab_error_info[index].error_code = 
                        rrc_ue_erb_modify_cnf.erab_error_list.
                        erab_error_info[index].error_code;
            }
            p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_erab_cnf_data;
            ret_val = RRM_SUCCESS;
        }
	}
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_ERB_MODIFY_CNF->UEM failed to process");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_context_mod_cnf
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE Context Mod Cnf
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_context_mod_cnf(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
    )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_contxt_mod_cnf_t rrc_rrm_ue_contxt_mod_cnf;
    rrm_ue_contxt_mod_cnf_t     *p_ue_contxt_mod_cnf = RRM_PNULL;
    rrm_cell_index_t            cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_contxt_mod_cnf(
                &rrc_rrm_ue_contxt_mod_cnf,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        ret_val = RRM_SUCCESS;
        p_ue_contxt_mod_cnf = (rrm_ue_contxt_mod_cnf_t *)
               rrm_mem_get(sizeof(rrm_ue_contxt_mod_cnf_t));
        if (RRM_PNULL == p_ue_contxt_mod_cnf)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                     "[UE:%d], Failed to allocate memory for contxt_mod_cnf",
                      rrc_rrm_ue_contxt_mod_cnf.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /*BUG 585, Multisector change start*/
            cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
	        p_rrm_ue_rrc_msg->cell_index = cell_index;
            p_ue_contxt_mod_cnf->ue_index = rrc_rrm_ue_contxt_mod_cnf.ue_index;
            /*BUG 585, Multisector change end*/
            SET_CELL_AND_UE_INDEX(cell_index, p_ue_contxt_mod_cnf->ue_index);
            p_ue_contxt_mod_cnf->response = rrc_rrm_ue_contxt_mod_cnf.response;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_UE_CONTEXT_MOD_CNF:[UE:%d] with response: %d",
                    rrc_rrm_ue_contxt_mod_cnf.ue_index, rrc_rrm_ue_contxt_mod_cnf.response);
			/* irat-test fix start*/
	    p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_contxt_mod_cnf.ue_index;
            p_rrm_ue_rrc_msg->p_msg_data = (void *)p_ue_contxt_mod_cnf;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->UEM:RRC_RRM_UE_CONTEXT_MOD_CNF failed to parse");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_dl_nas_transport_ind_msg 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the DL NAS Transport Indication message
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_rrc_parse_dl_nas_transport_ind_msg(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
    )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    S32                            length_read = RRM_NULL;
    rrc_rrm_dl_nas_transport_ind_t rrc_rrm_dl_nas_transport_ind;
    rrm_dl_nas_transport_ind_t  *p_dl_nas_transport_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if(RRM_SUCCESS == rrm_il_parse_rrc_rrm_dl_nas_transport_ind(
                &rrc_rrm_dl_nas_transport_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        /* SPR 21251 Start */
        SET_UE_INDEX(rrc_rrm_dl_nas_transport_ind.ue_index);
        /* SPR 21251 End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_DL_NAS_TRANSPORT_IND successfully parsed");
        ret_val = RRM_SUCCESS;
        p_dl_nas_transport_ind = (rrm_dl_nas_transport_ind_t *)
            rrm_mem_get(sizeof(rrm_dl_nas_transport_ind_t));

        if (RRM_PNULL == p_dl_nas_transport_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                     "[UE:%d], Failed to allocate memory for DL NAS Indication",
                      rrc_rrm_dl_nas_transport_ind.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_dl_nas_transport_ind->ue_index = rrc_rrm_dl_nas_transport_ind.ue_index;
            if(rrc_rrm_dl_nas_transport_ind.bitmask & RRM_DL_NAS_TRANSPORT_IND_SUBS_PROF_ID_PRESENT)
            {
                p_dl_nas_transport_ind->subscriber_profile_id_for_rfp = 
                    rrc_rrm_dl_nas_transport_ind.subscriber_profile_id_for_rfp;
            }
            
            p_rrm_ue_rrc_msg->ue_index = rrc_rrm_dl_nas_transport_ind.ue_index;
            p_rrm_ue_rrc_msg->p_msg_data = (void *)p_dl_nas_transport_ind;
            p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
            ret_val = RRM_SUCCESS;
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_DL_NAS_TRANSPORT_IND parsing failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME : rrm_rrc_parse_local_error_ind
 *   INPUT         : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT        : none
 *   DESCRIPTION   :
 *       Parse the Local Error Indication message
 *   RETURNS       :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_rrc_parse_local_error_ind(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_global_context_t *p_rrm_ue_glb_ctxt
    )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    S32                            length_read = RRM_NULL;
    rrc_rrm_local_error_ind_t      rrc_rrm_local_error_ind;
    rrm_ue_proc_local_error_ind_t  *p_local_error_ind = RRM_PNULL;
    rrm_ue_context_t               *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    U8                             impacted_items_outer = RRM_ZERO;
    S8                             impacted_items_inner = RRM_ZERO;
    U8                             erab_index = RRM_ZERO;
    rrm_cell_index_t               cell_index = RRM_ZERO;
    
    RRM_UT_TRACE_ENTER();
 
    if(RRM_SUCCESS == rrm_il_parse_rrc_rrm_local_error_ind(
                &rrc_rrm_local_error_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(cell_index, rrc_rrm_local_error_ind.impacted_items.impacted_items_list[impacted_items_outer].ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_LOCAL_ERROR_IND successfully parsed cause %d", rrc_rrm_local_error_ind.cause);
        ret_val = RRM_SUCCESS;
        /* SPR 15388 changes start */
        /* Code moved */
        /* SPR 15388 changes Ends */
        /* SPR 15388 changes start */
        if(rrc_rrm_local_error_ind.bitmask &
                   RRM_LOCAL_ERROR_IND_IMPACTED_ITEM_LIST_PRESENT)
            {
               for(impacted_items_outer = RRM_ZERO; 
                      impacted_items_outer < rrc_rrm_local_error_ind.impacted_items.impacted_items_count;
                          impacted_items_outer++)
               {

                /* SPR 15388 changes Ends */
        p_local_error_ind = (rrm_ue_proc_local_error_ind_t *)
            rrm_mem_get(sizeof(rrm_ue_proc_local_error_ind_t));

        if (RRM_PNULL == p_local_error_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                     "Failed to allocate memory for p_local_error_ind");
            ret_val = RRM_FAILURE;
            /* SPR 15388 changes start */
            RRM_UT_TRACE_EXIT();
            return ret_val;
            /* SPR 15388 changes Ends */
        }
        else
        {
            p_local_error_ind->cause = rrc_rrm_local_error_ind.cause;
                /* SPR 15388 changes start */
                /* Code moved */
                /* SPR 15388 changes Ends */
                   erab_index = RRM_ZERO;
				   p_local_error_ind->ue_index = rrc_rrm_local_error_ind.impacted_items.\
												 impacted_items_list[impacted_items_outer].ue_index;

                   p_local_error_ind->erab_id_list.count = RRM_ZERO; 
				  
                   RRM_MEMSET(p_local_error_ind->erab_id_list.erab_id, 
						   RRM_ZERO, 
						   RRM_MAX_NUM_DRB_PER_UE);
				   
                   if (rrc_rrm_local_error_ind.impacted_items.\
						   impacted_items_list[impacted_items_outer].bitmask &
						   RRM_LOCAL_ERROR_IND_ERAB_ID_PRESENT)
				   {
                       p_local_error_ind->erab_id_list.count++;
                       p_local_error_ind->erab_id_list.erab_id[erab_index++] = \
                                               rrc_rrm_local_error_ind.impacted_items.\
                                                   impacted_items_list[impacted_items_outer].erab_id;
                   }
                   for(impacted_items_inner = impacted_items_outer + RRM_ONE;
                           impacted_items_inner < rrc_rrm_local_error_ind.impacted_items.impacted_items_count;
                           impacted_items_inner++)
                   {
                       if (p_local_error_ind->ue_index == rrc_rrm_local_error_ind.impacted_items.\
                               impacted_items_list[impacted_items_inner].ue_index)
                       {
                           if (rrc_rrm_local_error_ind.impacted_items.\
                                   impacted_items_list[impacted_items_inner].bitmask &
                                   RRM_LOCAL_ERROR_IND_ERAB_ID_PRESENT)
                           {
                               p_local_error_ind->erab_id_list.count++;
                               p_local_error_ind->erab_id_list.erab_id[erab_index++] = 
                                   rrc_rrm_local_error_ind.impacted_items.\
                                   impacted_items_list[impacted_items_inner].erab_id;

                               if(impacted_items_inner ==
                                       (rrc_rrm_local_error_ind.impacted_items.impacted_items_count - RRM_ONE))
                               {
                                   RRM_MEMSET(&(rrc_rrm_local_error_ind.impacted_items.impacted_items_list[impacted_items_inner]),
                                           RRM_NULL, sizeof(rrc_impacted_items_list_t));
                               }
                               else
                               {
                                   if(impacted_items_inner < (rrc_rrm_local_error_ind.impacted_items.impacted_items_count - RRM_ONE))
                                   {
                                       RRM_MEMCPY(&(rrc_rrm_local_error_ind.impacted_items.impacted_items_list[impacted_items_inner]),
                                               &(rrc_rrm_local_error_ind.impacted_items.\
                                                   impacted_items_list[rrc_rrm_local_error_ind.impacted_items.impacted_items_count
                                                   - RRM_ONE]),
                                               sizeof(rrc_impacted_items_list_t));
                                       RRM_MEMSET(&(rrc_rrm_local_error_ind.impacted_items.\
                                                   impacted_items_list[rrc_rrm_local_error_ind.impacted_items.impacted_items_count
                                                   - RRM_ONE]),
                                               RRM_NULL
                                               ,sizeof(rrc_impacted_items_list_t));
                                       impacted_items_inner--;
                                   }
                               }
                               rrc_rrm_local_error_ind.impacted_items.impacted_items_count--;
                           }
                       }
                   }
                   /* This function needs to be updated to latest checked in on dev 2.0.1 */
                   /* SPR 20652 Fix Start */
                   p_ue_context = rrm_ue_find_context(p_local_error_ind->ue_index,
                           cell_index);
                   if (RRM_PNULL == p_ue_context)
                   {
                       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%d], failed to find ue context",p_local_error_ind->ue_index);
                       ret_val = RRM_FAILURE;
                       /*Cov_fix_63702_63828_63829*/
                       if(RRM_PNULL != p_local_error_ind)
                           RRM_MEM_FREE(p_local_error_ind);
                       /*Cov_fix_63702_63828_63829*/
                   }
                   else
                   {
                       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d], UE CONTEXT FOUND",p_ue_context->ue_index);
                       /* SPR 20652 Fix End */
                       p_rrm_ue_glb_ctxt->p_ue_context = p_ue_context;
                       p_ue_context->ue_event = RRC_RRM_LOCAL_ERROR_IND_EVENT;
                       p_ue_context->current_procedure.p_proc_data =
                           (void *)p_local_error_ind;

                    /* SPR 15441 start */
					   /** Free the memory before enter into the UE FSM */
					   if(RRM_SUCCESS == rrm_uem_process_fsm(p_ue_context->ue_state, 
                                                         p_ue_context->ue_event,
                                                             p_rrm_ue_glb_ctxt))
                       {
                           ret_val = RRM_SUCCESS;
                       }
                       else
					   {
                        ret_val = RRM_FAILURE;
                    }
                    RRM_MEM_FREE(p_local_error_ind);
                    /* SPR 15441 end */

				   }
               } 
            }
             }
    /* SPR 15388 changes start */
    ret_val = RRM_SUCCESS;
    /* SPR 15388 changes Ends */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_LOCAL_ERROR_IND parsing failed");
        ret_val = RRM_FAILURE;
    }
 
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_intra_enodeb_Ho_ind_msg
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the INTRA Enb HO Indication message
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_rrc_parse_intra_enodeb_Ho_ind_msg(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
    )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    S32                            length_read = RRM_NULL;
    rrc_rrm_intra_enb_ho_ind_t rrc_rrm_intra_enodeb_Ho_ind;
    rrm_intra_enodeb_ho_ind_t *p_intra_enodeb_Ho_ind = RRM_PNULL;
    rrm_cell_index_t                cell_idx = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    cell_idx = rrm_get_cell_id_from_header((U8*)(p_api_buf));
    SET_CELL_INDEX(cell_idx);
    if(RRM_SUCCESS == rrm_il_parse_rrc_rrm_intra_enb_ho_ind(
                &rrc_rrm_intra_enodeb_Ho_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        /* SPR 21251 Start */
        SET_UE_INDEX(rrc_rrm_intra_enodeb_Ho_ind.ue_index);
        /* SPR 21251 End */
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
              "RRC->UEM:RRC_RRM_INTRA_ENB_HO_IND successfully parsed");
        ret_val = RRM_SUCCESS;
        p_intra_enodeb_Ho_ind = (rrm_intra_enodeb_ho_ind_t*)
            rrm_mem_get(sizeof(rrm_intra_enodeb_ho_ind_t));

        if (RRM_PNULL == p_intra_enodeb_Ho_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                     "[UE:%d], Failed to allocate memory for Intra Enb HO Indication",
                      rrc_rrm_intra_enodeb_Ho_ind.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_intra_enodeb_Ho_ind->ue_index = rrc_rrm_intra_enodeb_Ho_ind.ue_index;
            p_rrm_ue_rrc_msg->ue_index = rrc_rrm_intra_enodeb_Ho_ind.ue_index;
            p_rrm_ue_rrc_msg->p_msg_data = (void *)p_intra_enodeb_Ho_ind;
            p_rrm_ue_rrc_msg->cell_index = cell_idx;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to parse RRC_RRM_INTRA_ENB_HO_IND");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* UE positioning start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_s1ap_rrm_lppa_ecid_meas_init_req
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the lppa ecid measurement init request message
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_rrc_parse_s1ap_rrm_lppa_ecid_meas_init_req(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
    )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    S32                            length_read = RRM_NULL;
    s1ap_rrm_lppa_ecid_meas_init_req_t s1ap_rrm_lppa_ecid_meas_init_req;
    rrm_ue_lppa_ecid_meas_init_req_t *p_lppa_ecid_meas_init_req = RRM_PNULL;
    U8 meas_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if(RRM_SUCCESS == rrm_il_parse_s1ap_rrm_lppa_ecid_meas_init_req(
                &s1ap_rrm_lppa_ecid_meas_init_req,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        /* SPR 21251 Start */
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, s1ap_rrm_lppa_ecid_meas_init_req.ue_index);
        /* SPR 21251 End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ successfully parsed");
        ret_val = RRM_SUCCESS;
        p_lppa_ecid_meas_init_req = (rrm_ue_lppa_ecid_meas_init_req_t*)
            rrm_mem_get(sizeof(rrm_ue_lppa_ecid_meas_init_req_t));

        if (RRM_PNULL == p_lppa_ecid_meas_init_req)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "[UE:%d], Failed to allocate memory for lppa ecid meas init req",
                    s1ap_rrm_lppa_ecid_meas_init_req.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /*coverity_86780 ++*/
            RRM_MEMSET(p_lppa_ecid_meas_init_req,0,sizeof(rrm_ue_lppa_ecid_meas_init_req_t));
            /*coverity_86780 --*/
            p_lppa_ecid_meas_init_req->mme_id = s1ap_rrm_lppa_ecid_meas_init_req.mme_id;
            p_lppa_ecid_meas_init_req->routing_id = s1ap_rrm_lppa_ecid_meas_init_req.routing_id;
            p_lppa_ecid_meas_init_req->lppa_trans_id = s1ap_rrm_lppa_ecid_meas_init_req.lppa_trans_id;
            p_lppa_ecid_meas_init_req->e_smlc_meas_id = s1ap_rrm_lppa_ecid_meas_init_req.e_smlc_meas_id;
            /* coverity : CID 31046 */
            p_lppa_ecid_meas_init_req->report_char = (rrm_lppa_report_char_et)s1ap_rrm_lppa_ecid_meas_init_req.report_char;
            if (LPPA_MEAS_INIT_REQ_MEAS_PERIODICITY_PRESENT & s1ap_rrm_lppa_ecid_meas_init_req.bitmask) 
            {
                p_lppa_ecid_meas_init_req->bitmask |= RRM_LPPA_MEAS_INIT_REQ_MEAS_PERIODICITY_PRESENT;
                /* coverity : CID 31044 */
                p_lppa_ecid_meas_init_req->meas_periodicity = 
                (rrm_lppa_meas_peridicity_et)s1ap_rrm_lppa_ecid_meas_init_req.meas_periodicity;
            }
            p_lppa_ecid_meas_init_req->num_meas_quantifier = s1ap_rrm_lppa_ecid_meas_init_req.num_meas_quantifier;
            /* Klocwork_fix_start : meas_quantifier */
            for (meas_count = RRM_ZERO; (meas_count < s1ap_rrm_lppa_ecid_meas_init_req.num_meas_quantifier) && (meas_count < MAX_NO_OF_MEAS); meas_count++)
            {
                /* coverity : CID 31045 */
                p_lppa_ecid_meas_init_req->meas_quantifier[meas_count].meas_quantity_item = 
                (rrm_lppa_meas_quanify_item_et)s1ap_rrm_lppa_ecid_meas_init_req.meas_quantifier[meas_count].meas_quantity_item;
            }
            p_rrm_ue_rrc_msg->ue_index = s1ap_rrm_lppa_ecid_meas_init_req.ue_index;
            p_rrm_ue_rrc_msg->p_msg_data = (void *)p_lppa_ecid_meas_init_req;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ parsing failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_s1ap_rrm_lppa_ecid_meas_termination_cmd
 *   INPUT      : p_api_buf,api_id,data_lendata_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the lppa ecid measurement termination cmd  message
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_rrc_parse_s1ap_rrm_lppa_ecid_meas_termination_cmd(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
    )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    S32                            length_read = RRM_NULL;
    s1ap_rrm_lppa_ecid_meas_termination_cmd_t s1ap_rrm_lppa_ecid_meas_termination_cmd;
    rrm_ue_lppa_ecid_meas_termination_cmd_t *p_lppa_ecid_meas_termination_cmd = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if(RRM_SUCCESS == rrm_il_parse_s1ap_rrm_lppa_ecid_meas_termination_cmd(
                &s1ap_rrm_lppa_ecid_meas_termination_cmd,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        /* SPR 21251 Start */
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, s1ap_rrm_lppa_ecid_meas_termination_cmd.ue_index);
        /* SPR 21251 End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND successfully parsed");
        ret_val = RRM_SUCCESS;
        p_lppa_ecid_meas_termination_cmd = (rrm_ue_lppa_ecid_meas_termination_cmd_t*)
            rrm_mem_get(sizeof(rrm_ue_lppa_ecid_meas_termination_cmd_t));

        if (RRM_PNULL == p_lppa_ecid_meas_termination_cmd)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "[UE:%d], Failed to allocate memory for lppa ecid meas termination cmd",
                    s1ap_rrm_lppa_ecid_meas_termination_cmd.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_lppa_ecid_meas_termination_cmd->mme_id = s1ap_rrm_lppa_ecid_meas_termination_cmd.mme_id;
            p_lppa_ecid_meas_termination_cmd->routing_id = s1ap_rrm_lppa_ecid_meas_termination_cmd.routing_id;
            p_lppa_ecid_meas_termination_cmd->lppa_trans_id = s1ap_rrm_lppa_ecid_meas_termination_cmd.lppa_trans_id;
            p_lppa_ecid_meas_termination_cmd->e_smlc_ue_meas_id = s1ap_rrm_lppa_ecid_meas_termination_cmd.e_smlc_ue_meas_id;
            p_lppa_ecid_meas_termination_cmd->enb_ue_meas_id = s1ap_rrm_lppa_ecid_meas_termination_cmd.enb_ue_meas_id;
            p_rrm_ue_rrc_msg->ue_index = s1ap_rrm_lppa_ecid_meas_termination_cmd.ue_index;
            p_rrm_ue_rrc_msg->p_msg_data = (void *)p_lppa_ecid_meas_termination_cmd;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND parsing failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_start*/

rrm_return_et
fill_lppa_error_ind
(
 U8                        *p_api_buf,
 rrm_ue_lppa_error_ind_t   *p_rrm_lppa_error_ind,
 rrm_ue_rrc_msg_t          *p_rrm_ue_rrc_msg,
 s1ap_rrm_lppa_error_ind_t *s1ap_rrm_lppa_error_ind
)
{
    rrm_return_et  ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_rrm_lppa_error_ind->bitmask |= RRM_LPPA_ERROR_IND_UE_INDEX_PRESENT;
    p_rrm_lppa_error_ind->ue_index = s1ap_rrm_lppa_error_ind->ue_index;
    p_rrm_ue_rrc_msg->ue_index = s1ap_rrm_lppa_error_ind->ue_index;
    if ( LPPA_ERROR_IND_CAUSE_PRESENT & s1ap_rrm_lppa_error_ind->bitmask)
    {
        p_rrm_lppa_error_ind->bitmask |= RRM_LPPA_ERROR_IND_CAUSE_PRESENT;
        p_rrm_lppa_error_ind->cause.type  = s1ap_rrm_lppa_error_ind->cause.type;
        p_rrm_lppa_error_ind->cause.value = s1ap_rrm_lppa_error_ind->cause.value;
    }
    if ( LPPA_ERROR_IND_CRITIC_DIAG_PRESENT & s1ap_rrm_lppa_error_ind->bitmask)
    {
        p_rrm_lppa_error_ind->bitmask |= RRM_LPPA_ERROR_IND_CRITIC_DIAG_PRESENT;
        if (LPPA_CRIT_DIAGNO_PROCEDURE_CODE_PRESENT & s1ap_rrm_lppa_error_ind->criticality_diagnostics.bitmask)
        {
            p_rrm_lppa_error_ind->criticality_diagnostics.bitmask  |= RRM_LPPA_CRIT_DIAGNO_PROCEDURE_CODE_PRESENT;
            p_rrm_lppa_error_ind->criticality_diagnostics.procedure_code
                = s1ap_rrm_lppa_error_ind->criticality_diagnostics.procedure_code;
        }
        if (LPPA_CRIT_DIAGNO_TRIGERRING_MSG_PRESENT & s1ap_rrm_lppa_error_ind->criticality_diagnostics.bitmask)
        {
            p_rrm_lppa_error_ind->criticality_diagnostics.bitmask  |= RRM_LPPA_CRIT_DIAGNO_TRIGERRING_MSG_PRESENT;
            p_rrm_lppa_error_ind->criticality_diagnostics.triggering_msg
                = s1ap_rrm_lppa_error_ind->criticality_diagnostics.triggering_msg;
        }
        if (LPPA_CRIT_DIAGNO_PROC_CRITICALITY_PRESENT & s1ap_rrm_lppa_error_ind->criticality_diagnostics.bitmask)
        {
            p_rrm_lppa_error_ind->criticality_diagnostics.bitmask  |= RRM_LPPA_CRIT_DIAGNO_PROC_CRITICALITY_PRESENT;
            p_rrm_lppa_error_ind->criticality_diagnostics.proc_critic
                = s1ap_rrm_lppa_error_ind->criticality_diagnostics.proc_critic;
        }
        if (LPPA_CRIT_DIAGNO_TRANS_ID_PRESENT & s1ap_rrm_lppa_error_ind->criticality_diagnostics.bitmask)
        {
            p_rrm_lppa_error_ind->criticality_diagnostics.bitmask  |= RRM_LPPA_CRIT_DIAGNO_TRANS_ID_PRESENT;
            p_rrm_lppa_error_ind->criticality_diagnostics.lppa_trans_id
                = s1ap_rrm_lppa_error_ind->criticality_diagnostics.lppa_trans_id;
        }
    }
    p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
    p_rrm_ue_rrc_msg->p_msg_data = (void *)p_rrm_lppa_error_ind;

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_s1ap_rrm_lppa_ind
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the lppa error indication  message
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_rrc_parse_s1ap_rrm_lppa_error_ind(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
    )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    S32                            length_read = RRM_NULL;
    s1ap_rrm_lppa_error_ind_t s1ap_rrm_lppa_error_ind;
    rrm_ue_lppa_error_ind_t *p_rrm_lppa_error_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if(RRM_SUCCESS == rrm_il_parse_s1ap_rrm_lppa_error_ind(
                &s1ap_rrm_lppa_error_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        /* SPR 21251 Start */
        SET_UE_INDEX(s1ap_rrm_lppa_error_ind.ue_index);
        /* SPR 21251 End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:S1AP_RRM_LPPA_ERROR_IND successfully parsed");
        ret_val = RRM_SUCCESS;
        p_rrm_lppa_error_ind = (rrm_ue_lppa_error_ind_t*)
            rrm_mem_get(sizeof(rrm_ue_lppa_error_ind_t));

        if (RRM_PNULL == p_rrm_lppa_error_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to allocate memory for lppa error ind");
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* coverity 54428*/
            RRM_MEMSET(p_rrm_lppa_error_ind, RRM_ZERO, sizeof(rrm_ue_lppa_error_ind_t));
            p_rrm_lppa_error_ind->mme_id = s1ap_rrm_lppa_error_ind.mme_id;
            p_rrm_lppa_error_ind->routing_id = s1ap_rrm_lppa_error_ind.routing_id;
            p_rrm_lppa_error_ind->lppa_trans_id = s1ap_rrm_lppa_error_ind.lppa_trans_id;
            if (LPPA_ERROR_IND_UE_INDEX_PRESENT & s1ap_rrm_lppa_error_ind.bitmask)
            {
                /*klock_works_changes_start*/
                fill_lppa_error_ind(p_api_buf, p_rrm_lppa_error_ind, p_rrm_ue_rrc_msg, &s1ap_rrm_lppa_error_ind);
                /*klock_works_changes_end*/
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                          "UE index is not present so RRM can't process this S1AP_RRM_LPPA_ERROR_IND");
                ret_val = RRM_FAILURE;
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:S1AP_RRM_LPPA_ERROR_IND parsing failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* UE positioning end */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_context_mod_req
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE Context Mod request
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_context_mod_req(
	U8 *p_api_buf,
         /*SPR 17777 +-*/
	U16 data_len,
	rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
	)
{
	rrm_return_et               ret_val = RRM_SUCCESS;
	S32                         length_read = RRM_NULL;
	rrc_rrm_ue_contxt_mod_req_t rrc_ue_contxt_mod_req = {RRM_ZERO};
    rrm_ue_context_mod_req_t   *p_ue_context_mod_req = RRM_PNULL;
	RRM_UT_TRACE_ENTER();

	if(RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_contxt_mod_req(
				&rrc_ue_contxt_mod_req,
				p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
				data_len,
				&length_read))
	{

            p_ue_context_mod_req = (rrm_ue_context_mod_req_t *)rrm_mem_get
                                 (sizeof(rrm_ue_context_mod_req_t));
            /* Kshitij_start CID: 16302 */
            if(RRM_PNULL == p_ue_context_mod_req)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                          "rrm_ue_rrc_parse_ue_context_mod_req: Mem allocation failed");
                return RRM_FAILURE;
            }
            /* Kshitij_end */
            RRM_MEMSET(p_ue_context_mod_req, RRM_ZERO, sizeof(rrm_ue_context_mod_req_t));
/*BUG 585, Multisector change start*/
            p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, rrc_ue_contxt_mod_req.ue_index); 
			/* Initializing the bitmask for CSFB, Registered-LAI */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "RRC->UEM:RRC_RRM_UE_CONTEXT_MOD_REQ successfully parsed");
			p_ue_context_mod_req->bitmask = RRM_ZERO;

            if(rrc_ue_contxt_mod_req.bitmask & RRC_RRM_UE_CONTXT_MOD_SPID_PRESENT)
            {
                p_ue_context_mod_req->spid = rrc_ue_contxt_mod_req.SPID;
                p_ue_context_mod_req->bitmask |= RRM_UEM_CTX_SPID_PRESENT;
            }
			if(rrc_ue_contxt_mod_req.bitmask & RRC_RRM_UE_CONTXT_MOD_CS_FALLBACK_PRESENT)
			{
				p_ue_context_mod_req->csf_indicator = rrc_ue_contxt_mod_req.CS_Fallback_Indicator;
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
						"[UE:%d], Updating Bitmask for CS_FALLBACK in UE_CONTEXT", 
						rrc_ue_contxt_mod_req.ue_index);
				p_ue_context_mod_req->bitmask |= RRM_UEM_CTX_CSF_INDICATOR_PRESENT;
			}
			if(rrc_ue_contxt_mod_req.bitmask & RRC_RRM_UE_CONTXT_MOD_REGISTERED_LAI_PRESENT)
			{
			    /*BUG 680 fix start*/
				rrm_map_rrm_rrc_registered_lai_t(&(p_ue_context_mod_req->registered_lai), 
								&(rrc_ue_contxt_mod_req.registered_lai));
			    /*BUG 680 fix end*/
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
						"[UE:%d], Updating Bitmask for REGISTERED_LAI in UE_CONTEXT",
						rrc_ue_contxt_mod_req.ue_index);
				p_ue_context_mod_req->bitmask |= RRM_UEM_CTX_REGISTERED_LAI_PRESENT;
			}
            if(rrc_ue_contxt_mod_req.bitmask & RRC_RRM_UE_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT)
            {
                p_ue_context_mod_req->bitmask |= RRM_UEM_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT;
                if(rrc_ue_contxt_mod_req.csg_membership_status == RRC_MEMBER)
                {
                    p_ue_context_mod_req->csg_membership_status = RRM_MEMBER;
                }
                else /*RRC_NOT_MEMBER*/
                {
                    p_ue_context_mod_req->csg_membership_status = RRM_NOT_MEMBER;
                }
            }
			ret_val = RRM_SUCCESS;
	}
	else
	{
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_UE_CONTEXT_MOD_REQ parsing failed");
		ret_val = RRM_FAILURE;
	}

    p_rrm_ue_rrc_msg->ue_index = rrc_ue_contxt_mod_req.ue_index;
    p_rrm_ue_rrc_msg->p_msg_data = (void *)p_ue_context_mod_req;

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_release_req 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE ERAB release request 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_erab_release_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    U8							index = RRM_NULL;
    rrm_ue_proc_erab_release_data_t		*p_erab_to_release_data = RRM_PNULL; 
    rrm_ue_erab_to_be_released_item_list_t 	erab_to_release;
    rrc_rrm_erb_release_req_t   rrc_ue_erb_release_req;

    RRM_UT_TRACE_ENTER();
    /** Parse the ue ERAB release request */
    /*coverity_83558 ++*/
    RRM_MEMSET(&erab_to_release,RRM_NULL,sizeof(rrm_ue_erab_to_be_released_item_list_t));
    /*coverity_83558 --*/
    /*Coverity_fix_start_54948*/
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_erb_release_req(
                &rrc_ue_erb_release_req,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))

    {
        /* SPR 21251 Start */
        /*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        /*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, rrc_ue_erb_release_req.ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_ERB_RELEASE_REQ successfully parsed");
        p_erab_to_release_data = (rrm_ue_proc_erab_release_data_t *)
            rrm_mem_get(sizeof(rrm_ue_proc_erab_release_data_t));

        /*Kshitij_start Coverity, CID:16304*/
        if(RRM_PNULL == p_erab_to_release_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "rrm_ue_rrc_parse_ue_erab_release_req: Mem allocation failed");
            return RRM_FAILURE;
        }
        /*Kshitij_end*/

        p_rrm_ue_rrc_msg->ue_index = rrc_ue_erb_release_req.ue_index;

        /** TO BE UPADTE LATER - when RRC will provide the cell index */
        p_erab_to_release_data->ambr.ue_agg_max_bit_rate_ul = 
            rrc_ue_erb_release_req.ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul;
        p_erab_to_release_data->ambr.ue_agg_max_bit_rate_dl = 
            rrc_ue_erb_release_req.ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl;
        erab_to_release.num_of_list = 
            rrc_ue_erb_release_req.erab_to_be_released_item_list.count;
        for (index = RRM_NULL; index<erab_to_release.num_of_list; index++)
        {
            erab_to_release.erab_to_be_release_item[index].erab_id = 
                rrc_ue_erb_release_req.erab_to_be_released_item_list.
                erab_to_be_release_item[index].erab_id;
            erab_to_release.erab_to_be_release_item[index].cause.type = 
                rrc_ue_erb_release_req.erab_to_be_released_item_list.
                erab_to_be_release_item[index].cause.type;
            erab_to_release.erab_to_be_release_item[index].cause.value = 
                rrc_ue_erb_release_req.erab_to_be_released_item_list.
                erab_to_be_release_item[index].cause.value;
        }
        p_erab_to_release_data->erab_setup_list = erab_to_release;
        p_rrm_ue_rrc_msg->p_msg_data = p_erab_to_release_data;
        ret_val = RRM_SUCCESS;

        /* Raise Event - RRM_EVENT_LOCAL_ERAB_RELEASE_ATTEMPT START */
        rrm_raise_event_erab_drb_release_attempt(&rrc_ue_erb_release_req);
         /*SPR 17777 +-*/
        /* Raise Event - RRM_EVENT_LOCAL_ERAB_RELEASE_ATTEMPT END */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_ERB_RELEASE_REQ parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*Coverity_fix_end_54948*/
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_erab_release_cnf 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE ERAB release CNF 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_erab_release_cnf(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_erb_release_cnf_t   rrc_ue_erb_release_cnf;
    U8							index = RRM_NULL;
    rrm_ue_proc_erab_cnf_data_t *p_ue_proc_erab_cnf_data = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    /** Parse the ue ERAB rlease cnf message */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_erb_release_cnf(
                    		&rrc_ue_erb_release_cnf,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))

   	{
        /* SPR 21251 Start */
/*BUG 585, Multisector change start*/
         p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, rrc_ue_erb_release_cnf.ue_index);
        
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_ERB_RELEASE_CNF:[UE:%d] with response: %d",
                rrc_ue_erb_release_cnf.ue_index, rrc_ue_erb_release_cnf.response);
        /* SPR 21251End */
        p_ue_proc_erab_cnf_data = (rrm_ue_proc_erab_cnf_data_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_erab_cnf_data_t));
        if(RRM_PNULL == p_ue_proc_erab_cnf_data)
        {
        	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%d],Failed to allocate the "
                        "procedure data ",rrc_ue_erb_release_cnf.ue_index); 
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_rrm_ue_rrc_msg->ue_index = rrc_ue_erb_release_cnf.ue_index;
			/** TO BE UPADTE LATER - when RRC will provide the cell index */
            p_ue_proc_erab_cnf_data->erab_cnf_list.erab_count = 
                    rrc_ue_erb_release_cnf.erab_cnf_list.erab_count;
            for(index=RRM_NULL; 
                index<p_ue_proc_erab_cnf_data->erab_cnf_list.erab_count
                ; index++)
            {
            	p_ue_proc_erab_cnf_data->erab_cnf_list.
                        erab_cnf_info[index].erab_id = 
                        rrc_ue_erb_release_cnf.erab_cnf_list.
                        erab_cnf_info[index].erab_id;
            }

            p_ue_proc_erab_cnf_data->erab_error_list.erab_count = 
                    rrc_ue_erb_release_cnf.erab_error_list.erab_count;
            for(index=RRM_NULL; 
                index<p_ue_proc_erab_cnf_data->erab_error_list.
                erab_count; index++)
            {
            	p_ue_proc_erab_cnf_data->erab_error_list.
                        erab_error_info[index].erab_id = 
                        rrc_ue_erb_release_cnf.erab_error_list.
                        erab_error_info[index].erab_id;
                p_ue_proc_erab_cnf_data->erab_error_list.
                        erab_error_info[index].error_code = 
                        rrc_ue_erb_release_cnf.erab_error_list.
                        erab_error_info[index].error_code;
           	}

            p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_erab_cnf_data;
            ret_val = RRM_SUCCESS;

        /* Raise Event - RRM_EVENT_LOCAL_ERAB_DRB_RELEASE START */
        /*Cov_fix_54424*/
        rrm_raise_event_erab_drb_release(/*SPR 17777 +-*/
                                         &rrc_ue_erb_release_cnf);
        /* Raise Event - RRM_EVENT_LOCAL_ERAB_DRB_RELEASE END */
        /*Cov_fix_54424*/
      }
	}
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_ERB_RELEASE_CNF->UEM failed to process");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 13205 Fix Start */
/*Klocwork activity 1-Apr_2014 start*/

/****************************************************************************
 * Function Name  : rrm_cellm_assign_new_priorities_for_utran_eutran_geran
 * Inputs         : p_ue_connection_release_ind,
 *                  p_freq_priority,p_priority_cfg,spid
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Assign new priorities to the freq priority list for eutran,geran,utran
 ****************************************************************************/
/*void
rrm_cellm_assign_new_priorities_for_utran_eutran_geran
(
 rrm_freq_priority_list_t *p_freq_priority,
 rrm_priority_cfg_t *p_priority_cfg,
 rrm_ue_context_t *p_ue_context,
 U8  get_eutran_priority,
 U8  get_utran_priority,
 U8  get_geran_priority,
 U8  flag_cdma
 )
{
    RRM_UT_TRACE_ENTER();

    if(RRM_OAM_FREQ_PRIORITY_HIGH == get_eutran_priority  && RRM_OAM_FREQ_PRIORITY_MEDIUM == get_utran_priority \
            && RRM_OAM_FREQ_PRIORITY_LOW == get_geran_priority)
    {
        arrange_medium_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
        arrange_low_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
    }
    else if(RRM_OAM_FREQ_PRIORITY_HIGH == get_eutran_priority  && RRM_OAM_FREQ_PRIORITY_LOW == get_utran_priority \
            && RRM_OAM_FREQ_PRIORITY_MEDIUM == get_geran_priority)
    {
        arrange_high_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg,
                flag_cdma);
        arrange_medium_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
        arrange_low_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
    }
    else if(RRM_OAM_FREQ_PRIORITY_MEDIUM == get_eutran_priority  && RRM_OAM_FREQ_PRIORITY_HIGH == get_utran_priority \
            && RRM_OAM_FREQ_PRIORITY_LOW == get_geran_priority)
    {
        arrange_high_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg,
                flag_cdma);
        arrange_medium_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
        arrange_low_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
    }
    else if(RRM_OAM_FREQ_PRIORITY_LOW == get_eutran_priority  && RRM_OAM_FREQ_PRIORITY_HIGH == get_utran_priority \
            && RRM_OAM_FREQ_PRIORITY_MEDIUM == get_geran_priority)
    {
        arrange_high_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg,
                flag_cdma);
        arrange_medium_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
        arrange_low_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
    }
    else if(RRM_OAM_FREQ_PRIORITY_MEDIUM == get_eutran_priority  && RRM_OAM_FREQ_PRIORITY_LOW == get_utran_priority \
            && RRM_OAM_FREQ_PRIORITY_HIGH == get_geran_priority)
    {
        arrange_high_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg,
                flag_cdma);
        arrange_medium_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
        arrange_low_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
    }
    else if(RRM_OAM_FREQ_PRIORITY_LOW == get_eutran_priority  && RRM_OAM_FREQ_PRIORITY_MEDIUM == get_utran_priority \
            && RRM_OAM_FREQ_PRIORITY_HIGH == get_geran_priority)
    {
        arrange_high_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg,
                flag_cdma);
        arrange_medium_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
        arrange_low_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
    }
    else 
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_ERROR,
                "No RAT priority found for this SPID:[%d]", p_ue_context->sub_profile_id);
    }
    RRM_UT_TRACE_EXIT(); 
}*/
/*Klocwork activity 1-Apr_2014 end*/
/* SPR 13205 Fix End */
/****************************************************************************
 * Function Name  : rrm_cellm_assign_new_priorities
 * Inputs         : p_ue_connection_release_ind,
 *                  p_freq_priority,p_priority_cfg,spid
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_return_et rrm_cellm_assign_new_priorities(
                rrm_freq_priority_list_t *p_freq_priority,
                rrm_priority_cfg_t *p_priority_cfg,
                rrm_ue_context_t *p_ue_context)
{
    rrm_return_et               ret_val = RRM_FAILURE;
    int                         i = RRM_ZERO;
  /* SPR 13205 Fix Start */
    /*U8                          flag_cdma = RRM_ZERO;*/
    /* U8                          cell_resel_pri = RRM_ZERO;*/
  /* SPR 13205 Fix End */
    U8                          cell_index = p_ue_context->cell_index;
    /* SPR 20653 Fix Start */
    /* CID 112963, 112962, 112970, 112968 Start */
    rrm_oam_rat_priority_info_et    get_eutran_priority = RRM_OAM_RAT_PRIORITY_INVALID;
    rrm_oam_rat_priority_info_et    get_utran_priority = RRM_OAM_RAT_PRIORITY_INVALID;
    rrm_oam_rat_priority_info_et    get_geran_priority = RRM_OAM_RAT_PRIORITY_INVALID;
  /* SPR 13205 Fix Start */
    rrm_oam_rat_priority_info_et    get_cdma_priority = RRM_OAM_RAT_PRIORITY_INVALID;
    /* CID 112963, 112962, 112970, 112968 End */
  /* SPR 13205 Fix End */
    /* SPR 20653 Fix End */
    rrm_oam_spid_table_t        *spid_table_params = RRM_PNULL;
    

    RRM_UT_TRACE_ENTER();
    spid_table_params = rrm_cellm_get_spid_table_params(cell_index);

    if(RRM_PNULL != spid_table_params && RRM_ZERO != spid_table_params->spid_count)
    {
        /* SPR 20653 Fix Start */
        for(i =RRM_ZERO; i< spid_table_params->spid_count ; i++) 
        {
            /* SPR 22553 FIXED START*/
            if(spid_table_params->spid_config[i].spid == p_ue_context->rrm_sub_profile_id_info.sub_profile_id)
            {
                /* SPR 22553 FIXED END*/
                get_rat_priority(&spid_table_params->spid_config[i].rrm_rat_priority_list,
                        &get_eutran_priority, &get_utran_priority, &get_geran_priority, &get_cdma_priority);
                /* SPR 20653 Fix End */

                /* CID 112963, 112962, 112970, 112968 Start */
                if ((RRM_OAM_RAT_PRIORITY_INVALID != get_utran_priority) && (RRM_OAM_RAT_PRIORITY_INVALID != get_eutran_priority) && 
                    (RRM_OAM_RAT_PRIORITY_INVALID != get_geran_priority) && (RRM_OAM_RAT_PRIORITY_INVALID != get_cdma_priority))
                    /* CID 112963, 112962, 112970, 112968 End */
            /* SPR 13205 Fix End */
                {
                    ret_val = RRM_SUCCESS;
                    break;
                }

            }
        }
    }
    else
    {
        return ret_val;
    }

    /*
    * COMP_WARN_1_FEB:compilation warning removal 
    * changed = to == and added proper braces
    */
   /* SPR 13205 Fix Start */
    if (RRM_SUCCESS == ret_val)
    {   
        /* CID 112957 Start */
        switch((rrm_oam_freq_priority_info_et)get_eutran_priority)
        {
            case RRM_OAM_FREQ_PRIORITY_HIGH:   arrange_high_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_MEDIUM: arrange_medium_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW:    arrange_low_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW_2:  arrange_low_2_eutran (&p_freq_priority->eutran_freq_priority_list_info, p_priority_cfg);
                                               break;
        }
        switch((rrm_oam_freq_priority_info_et)get_utran_priority)
        {
            case RRM_OAM_FREQ_PRIORITY_HIGH:   arrange_high_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_MEDIUM: arrange_medium_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW:    arrange_low_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW_2:  arrange_low_2_utran (&p_freq_priority->utran_freq_priority_list_info, p_priority_cfg);
                                               break;
        }
        switch((rrm_oam_freq_priority_info_et)get_geran_priority)
        {
            case RRM_OAM_FREQ_PRIORITY_HIGH:   arrange_high_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_MEDIUM: arrange_medium_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW:    arrange_low_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW_2:  arrange_low_2_geran (&p_freq_priority->geran_freq_priority_list_info, p_priority_cfg);
                                               break;
        }
        switch((rrm_oam_freq_priority_info_et)get_cdma_priority)
        {
            case RRM_OAM_FREQ_PRIORITY_HIGH:   arrange_high_cdma (&p_freq_priority->cdma_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_MEDIUM: arrange_medium_cdma (&p_freq_priority->cdma_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW:    arrange_low_cdma (&p_freq_priority->cdma_freq_priority_list_info, p_priority_cfg);
                                               break;
            case RRM_OAM_FREQ_PRIORITY_LOW_2:  arrange_low_2_cdma (&p_freq_priority->cdma_freq_priority_list_info, p_priority_cfg);
                                               break;
        }
        /* CID 112957 End */
    }
    else 
    {
        /* SPR 22553 FIXED START*/
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_ERROR,
                "No RAT priority found for this SPID:[%d]", p_ue_context->rrm_sub_profile_id_info.sub_profile_id);
        /* SPR 22553 FIXED END*/
    }

    /* SPR 13205 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}

 /* SPR 13205 Fix Start */
/****************************************************************************
 * Function Name  : arrange_high_eutran 
 * Inputs         : p_eutran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_high_eutran (rrm_eutran_freq_priority_list_info_t *p_eutran_priority_frequency_list_info, 
                                     rrm_priority_cfg_t *p_priority_cfg)
    /* SPR 13205 Fix End */
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;
        
        RRM_UT_TRACE_ENTER();
    
        for(i = RRM_ZERO; i < p_eutran_priority_frequency_list_info->count; i++)
        {
            cell_resel_pri = p_eutran_priority_frequency_list_info->\
                              eutran_freq_priority_info[i].cell_reselection_priority;

           if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].max) &&
              (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].min ))
           {
               /* SPR 13205 Fix Start */
               /* code deleted */
               /* SPR 13205 Fix End */
               cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].max) &&
                 (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].min ))
           {
                 cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].max) &&
                 (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].min ))
           {
                 cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].value;
           }
          else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
           }

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n EUTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
                      p_eutran_priority_frequency_list_info->\
                                 eutran_freq_priority_info[i].carrier_freq,
                      p_eutran_priority_frequency_list_info->\
                                 eutran_freq_priority_info[i].cell_reselection_priority,
                      cell_resel_pri);

           p_eutran_priority_frequency_list_info->\
                eutran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
        } 
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
* Function Name  : arrange_medium_eutran
* Inputs         : p_eutran_priority_frequency_list_info,
*                  p_priority_cfg
* Outputs        : None
* Returns        : none
* Description    : Assign new priorities to the freq priority list
****************************************************************************/

rrm_void_t arrange_medium_eutran (rrm_eutran_freq_priority_list_info_t *p_eutran_priority_frequency_list_info,
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
        for(i = RRM_ZERO; i < p_eutran_priority_frequency_list_info->count; i++)
        {
            cell_resel_pri = p_eutran_priority_frequency_list_info->\
                              eutran_freq_priority_info[i].cell_reselection_priority;

           if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].max) &&
              (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].min ))
           {
               cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].max) &&
                 (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].min ))
           {
                 cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].value;
           }
          else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
           }

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n EUTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
                      p_eutran_priority_frequency_list_info->\
                                 eutran_freq_priority_info[i].carrier_freq,
                      p_eutran_priority_frequency_list_info->\
                                 eutran_freq_priority_info[i].cell_reselection_priority,
                      cell_resel_pri);
           p_eutran_priority_frequency_list_info->\
                eutran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
        }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : arrange_low_eutran
 * Inputs         : p_eutran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_eutran (rrm_eutran_freq_priority_list_info_t *p_eutran_priority_frequency_list_info,
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
        for(i = RRM_ZERO; i < p_eutran_priority_frequency_list_info->count; i++)
        {
            cell_resel_pri = p_eutran_priority_frequency_list_info->\
                              eutran_freq_priority_info[i].cell_reselection_priority;

           if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].max) &&
              (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].min ))
           {
               cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].max) &&
                 (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].min ))
           {
                 cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].value;
           }
           /* SPR 13205 Fix Start */
               /* code deleted */
           /* SPR 13205 Fix End */
          else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
           }

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n EUTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
                      p_eutran_priority_frequency_list_info->\
                                 eutran_freq_priority_info[i].carrier_freq,
                      p_eutran_priority_frequency_list_info->\
                                 eutran_freq_priority_info[i].cell_reselection_priority,
                      cell_resel_pri);

           p_eutran_priority_frequency_list_info->\
                eutran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
        }
     RRM_UT_TRACE_EXIT();
}

    /* SPR 13205 Fix Start */

/****************************************************************************
 * Function Name  : arrange_low_2_eutran 
 * Inputs         : p_eutran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_2_eutran (rrm_eutran_freq_priority_list_info_t *p_eutran_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();
        
        for(i = RRM_ZERO; i < p_eutran_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_eutran_freq_priority_list_info->\
                              eutran_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n EUTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_eutran_freq_priority_list_info->\
		                 eutran_freq_priority_info[i].carrier_freq,
		      p_eutran_freq_priority_list_info->\
		                 eutran_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_eutran_freq_priority_list_info->\
               eutran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }

    RRM_UT_TRACE_EXIT();
}
    /* SPR 13205 Fix End */

    /* SPR 13205 Fix Start */
/****************************************************************************
 * Function Name  : arrange_high_utran
 * Inputs         : p_utran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_high_utran (rrm_utran_freq_priority_list_info_t *p_utran_priority_frequency_list_info,
                                     rrm_priority_cfg_t *p_priority_cfg)
/* SPR 13205 Fix End */
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();

        for(i = 0; i < p_utran_priority_frequency_list_info->count; i++)
        {
            cell_resel_pri = p_utran_priority_frequency_list_info->\
                              utran_freq_priority_info[i].cell_reselection_priority;

           if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].max) &&
              (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].min ))
           {
            /* SPR 13205 Fix Start*/
             /* Code removed */
            /* SPR 13205 Fix End */
               cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].max) &&
                 (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].min ))
           {
                 cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].max) &&
                 (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].min ))
           {
                 cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].value;
           }
          else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
           }

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n UTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
                      p_utran_priority_frequency_list_info->\
                                 utran_freq_priority_info[i].carrier_freq,
                      p_utran_priority_frequency_list_info->\
                                 utran_freq_priority_info[i].cell_reselection_priority,
                      cell_resel_pri);

           p_utran_priority_frequency_list_info->\
                utran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
        }

        RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : arrange_medium_utran 
 * Inputs         : p_utran_priority_frequency_list_info,
 *                  p_priority_cfg,flag_cdma
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_medium_utran (rrm_utran_freq_priority_list_info_t *p_utran_priority_frequency_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();

        for(i = RRM_ZERO; i < p_utran_priority_frequency_list_info->count; i++)
        {
            cell_resel_pri = p_utran_priority_frequency_list_info->\
                              utran_freq_priority_info[i].cell_reselection_priority;

           if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].max) &&
              (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].min ))
           {
               cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].max) &&
                 (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].min ))
           {
                 cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].value;
           }
          else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
           }

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n UTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
                      p_utran_priority_frequency_list_info->\
                                 utran_freq_priority_info[i].carrier_freq,
                      p_utran_priority_frequency_list_info->\
                                 utran_freq_priority_info[i].cell_reselection_priority,
                      cell_resel_pri);

           p_utran_priority_frequency_list_info->\
                utran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
        }

        RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : arrange_low_utran 
 * Inputs         : p_utran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_utran (rrm_utran_freq_priority_list_info_t *p_utran_priority_frequency_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();

        for(i = RRM_ZERO; i < p_utran_priority_frequency_list_info->count; i++)
        {
            cell_resel_pri = p_utran_priority_frequency_list_info->\
                              utran_freq_priority_info[i].cell_reselection_priority;

           if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].max) &&
              (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].min ))
           {
               cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].value;
           }
           else if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].max) &&
                 (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].min ))
           {
                 cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].value;
           }
            /* SPR 13205 Fix Start*/
             /* Code removed */
            /* SPR 13205 Fix End */
          else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
           }

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n UTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
                      p_utran_priority_frequency_list_info->\
                                 utran_freq_priority_info[i].carrier_freq,
                      p_utran_priority_frequency_list_info->\
                                 utran_freq_priority_info[i].cell_reselection_priority,
                      cell_resel_pri);

           p_utran_priority_frequency_list_info->\
                utran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
        }
 
        RRM_UT_TRACE_EXIT();
}

    /* SPR 13205 Fix Start */

/****************************************************************************
 * Function Name  : arrange_low_2_utran 
 * Inputs         : p_utran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_2_utran (rrm_utran_freq_priority_list_info_t *p_utran_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();
        
        for(i = RRM_ZERO; i < p_utran_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_utran_freq_priority_list_info->\
                              utran_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n UTRAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_utran_freq_priority_list_info->\
		                 utran_freq_priority_info[i].carrier_freq,
		      p_utran_freq_priority_list_info->\
		                 utran_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_utran_freq_priority_list_info->\
               utran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }

    RRM_UT_TRACE_EXIT();
}

    /* SPR 13205 Fix Start */
/****************************************************************************
 * Function Name  : arrange_high_geran 
 * Inputs         : p_geran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_high_geran (rrm_geran_freq_priority_list_info_t *p_geran_freq_priority_list_info, 
                                     rrm_priority_cfg_t *p_priority_cfg)
    /* SPR 13205 Fix End */

{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;
 
        RRM_UT_TRACE_ENTER();

        for(i = RRM_ZERO; i < p_geran_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_geran_freq_priority_list_info->\
                              geran_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].min ))
            {
               cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].value;
            /* SPR 13205 Fix Start*/
             /* Code removed */
            /* SPR 13205 Fix End */ 
            }
            else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].max) &&
                  (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].min ))
            {
                  cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].max) &&
                  (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].min ))
            {
                  cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n GERAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].carrier_freq.starting_arfcn,
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_geran_freq_priority_list_info->\
               geran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }
 
         RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : arrange_medium_geran 
 * Inputs         : p_geran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_medium_geran (rrm_geran_freq_priority_list_info_t *p_geran_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;
 
        RRM_UT_TRACE_ENTER();

        for(i = RRM_ZERO; i < p_geran_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_geran_freq_priority_list_info->\
                              geran_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].max) &&
                  (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].min ))
            {
                  cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].value;
            }
            /* SPR 13205 Fix Start*/
             /* Code removed */
            /* SPR 13205 Fix End */
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n GERAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].carrier_freq.starting_arfcn,
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_geran_freq_priority_list_info->\
               geran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }
     
         RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : arrange_low_geran 
 * Inputs         : p_geran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_geran (rrm_geran_freq_priority_list_info_t *p_geran_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();
        
        for(i = RRM_ZERO; i < p_geran_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_geran_freq_priority_list_info->\
                              geran_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].max) &&
                  (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].min ))
            {
                  cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].value;
            }
            /* SPR 13205 Fix Start*/
             /* Code removed */
            /* SPR 13205 Fix End */
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n GERAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].carrier_freq.starting_arfcn,
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_geran_freq_priority_list_info->\
               geran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }

    RRM_UT_TRACE_EXIT();
}

    /* SPR 13205 Fix Start */

/****************************************************************************
 * Function Name  : arrange_low_2_geran 
 * Inputs         : p_geran_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_2_geran (rrm_geran_freq_priority_list_info_t *p_geran_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();
        
        for(i = RRM_ZERO; i < p_geran_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_geran_freq_priority_list_info->\
                              geran_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n GERAN Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].carrier_freq.starting_arfcn,
		      p_geran_freq_priority_list_info->\
		                 geran_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_geran_freq_priority_list_info->\
               geran_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : arrange_high_cdma 
 * Inputs         : p_cdma_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_high_cdma (rrm_cdma_freq_priority_list_info_t *p_cdma_freq_priority_list_info, 
                                     rrm_priority_cfg_t *p_priority_cfg)

{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;
 
        RRM_UT_TRACE_ENTER();

        for(i = RRM_ZERO; i < p_cdma_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_cdma_freq_priority_list_info->\
                              cdma_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].min ))
            {
               cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ZERO].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].max) &&
                  (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].min ))
            {
                  cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_ONE].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].max) &&
                  (cell_resel_pri >= p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].min ))
            {
                  cell_resel_pri = p_priority_cfg->high_priority_cfg.bucket[RRM_TWO].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n CDMA Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].arfcn,
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_cdma_freq_priority_list_info->\
               cdma_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }
 
         RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : arrange_medium_cdma 
 * Inputs         : p_cdma_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_medium_cdma (rrm_cdma_freq_priority_list_info_t *p_cdma_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;
 
        RRM_UT_TRACE_ENTER();

        for(i = RRM_ZERO; i < p_cdma_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_cdma_freq_priority_list_info->\
                              cdma_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ZERO].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].max) &&
                  (cell_resel_pri >= p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].min ))
            {
                  cell_resel_pri = p_priority_cfg->medium_priority_cfg.bucket[RRM_ONE].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n CDMA Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].arfcn,
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_cdma_freq_priority_list_info->\
               cdma_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }
     
         RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : arrange_low_cdma 
 * Inputs         : p_cdma_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_cdma (rrm_cdma_freq_priority_list_info_t *p_cdma_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();
        
        for(i = RRM_ZERO; i < p_cdma_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_cdma_freq_priority_list_info->\
                              cdma_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ZERO].value;
            }
            else if((cell_resel_pri <=  p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].max) &&
                  (cell_resel_pri >= p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].min ))
            {
                  cell_resel_pri = p_priority_cfg->low_priority_cfg.bucket[RRM_ONE].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n CDMA Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].arfcn,
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_cdma_freq_priority_list_info->\
               cdma_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : arrange_low_2_cdma 
 * Inputs         : p_cdma_priority_frequency_list_info,
 *                  p_priority_cfg
 * Outputs        : None
 * Returns        : none 
 * Description    : Assign new priorities to the freq priority list
 ****************************************************************************/
rrm_void_t arrange_low_2_cdma (rrm_cdma_freq_priority_list_info_t *p_cdma_freq_priority_list_info, 
                             rrm_priority_cfg_t *p_priority_cfg)
{
        U8      i =RRM_ZERO;
        U8      cell_resel_pri = RRM_ZERO;

        RRM_UT_TRACE_ENTER();
        
        for(i = RRM_ZERO; i < p_cdma_freq_priority_list_info->count; i++)
        {
            cell_resel_pri = p_cdma_freq_priority_list_info->\
                              cdma_freq_priority_info[i].cell_reselection_priority;

            if((cell_resel_pri <=  p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].max) &&
                (cell_resel_pri >= p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].min ))
            {
                cell_resel_pri = p_priority_cfg->low_2_priority_cfg.bucket[RRM_ZERO].value;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        "Received  priority [%d] is not supported",cell_resel_pri);
               RRM_UT_TRACE_EXIT();
            }
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "\n CDMA Freq : [%d] \t Recv priority : [%d] \t Assigned priority : [%d] ",
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].arfcn,
		      p_cdma_freq_priority_list_info->\
		                 cdma_freq_priority_info[i].cell_reselection_priority,
		      cell_resel_pri);

            p_cdma_freq_priority_list_info->\
               cdma_freq_priority_info[i].cell_reselection_priority = cell_resel_pri;
         }

    RRM_UT_TRACE_EXIT();
}

/* SPR 13205 Fix End */

/****************************************************************************
 * Function Name  : sort_utran_frq_pri_list
 * Inputs         : rrm_freq_priority_list_t,count
 * Outputs        : None
 * Returns        : None 
 * Description    : sort the eutran/utran frequencies and priorities
 ****************************************************************************/
rrm_void_t sort_utran_frq_pri_list(
                  rrm_utran_freq_priority_list_info_t*  p_utran_freq_pri_list
                  )
{
    U8                             temp = RRM_ZERO;
    U16                            temp_freq = RRM_ZERO;
    U8                             x = RRM_ZERO;
    U8                             y = RRM_ZERO;
    U8                             index_of_min = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    for(x = RRM_ZERO; x < ((p_utran_freq_pri_list->count)-RRM_ONE); x++)
	{
		index_of_min = x;
		for(y = (x+RRM_ONE); y < p_utran_freq_pri_list->count; y++)
		{
			if(p_utran_freq_pri_list->utran_freq_priority_info[index_of_min].\
                cell_reselection_priority < p_utran_freq_pri_list->\
                utran_freq_priority_info[y].cell_reselection_priority)
			{
				index_of_min = y;
			}
		}
		temp = p_utran_freq_pri_list->utran_freq_priority_info[x].cell_reselection_priority;
		p_utran_freq_pri_list->utran_freq_priority_info[x].cell_reselection_priority = \
        p_utran_freq_pri_list->utran_freq_priority_info[index_of_min].cell_reselection_priority;
        p_utran_freq_pri_list->utran_freq_priority_info[index_of_min].cell_reselection_priority = \
        temp;
        temp_freq = p_utran_freq_pri_list->utran_freq_priority_info[x].carrier_freq;
        p_utran_freq_pri_list->utran_freq_priority_info[x].carrier_freq =\
        p_utran_freq_pri_list->utran_freq_priority_info[index_of_min].carrier_freq;
        p_utran_freq_pri_list->utran_freq_priority_info[index_of_min].carrier_freq=
        temp_freq;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "Utran: freq[%u] cell selection priority[%u]", 
                        p_utran_freq_pri_list->utran_freq_priority_info[x].cell_reselection_priority,
                        p_utran_freq_pri_list->utran_freq_priority_info[x].carrier_freq);
	}
    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : sort_eutran_frq_pri_list
 * Inputs         : rrm_freq_priority_list_t,count
 * Outputs        : None
 * Returns        : None 
 * Description    : sort the eutran/utran frequencies and priorities
 ****************************************************************************/
rrm_void_t sort_eutran_frq_pri_list(
                  rrm_eutran_freq_priority_list_info_t* p_eutran_freq_pri_list
                  )
{
    U8                             temp = RRM_ZERO;
    U16                            temp_freq = RRM_ZERO;
    U8                             x = RRM_ZERO;
    U8                             y = RRM_ZERO;
    U8                             index_of_min = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    for(x = RRM_ZERO; x < ((p_eutran_freq_pri_list->count)-RRM_ONE); x++)
	{
		index_of_min = x;
		for(y = (x+RRM_ONE); y < p_eutran_freq_pri_list->count; y++)
		{
			if(p_eutran_freq_pri_list->eutran_freq_priority_info[index_of_min].\
                cell_reselection_priority < p_eutran_freq_pri_list->\
                eutran_freq_priority_info[y].cell_reselection_priority)
			{
				index_of_min = y;
			}
		}
		temp = p_eutran_freq_pri_list->eutran_freq_priority_info[x].cell_reselection_priority;
		p_eutran_freq_pri_list->eutran_freq_priority_info[x].cell_reselection_priority = \
        p_eutran_freq_pri_list->eutran_freq_priority_info[index_of_min].cell_reselection_priority;
        p_eutran_freq_pri_list->eutran_freq_priority_info[index_of_min].cell_reselection_priority = \
        temp;
        temp_freq = p_eutran_freq_pri_list->eutran_freq_priority_info[x].carrier_freq;
        p_eutran_freq_pri_list->eutran_freq_priority_info[x].carrier_freq =\
        p_eutran_freq_pri_list->eutran_freq_priority_info[index_of_min].carrier_freq;
        p_eutran_freq_pri_list->eutran_freq_priority_info[index_of_min].carrier_freq=
        temp_freq;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "Eutran: freq[%u] cell selection priority[%u]", 
                        p_eutran_freq_pri_list->eutran_freq_priority_info[x].cell_reselection_priority,
                        p_eutran_freq_pri_list->eutran_freq_priority_info[x].carrier_freq);
    }    
    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : sort_cdma_freq_pri_list
 * Inputs         : rrm_freq_priority_list_t
 * Outputs        : None
 * Returns        : None 
 * Description    : sort the cdma frequencies and priorities
 ****************************************************************************/
rrm_void_t sort_cdma_freq_pri_list(
                  rrm_cdma_freq_priority_list_info_t*  p_cdma_freq_pri_list
                  )
{
    U8                             temp = RRM_ZERO;
    U8                            temp_freq = RRM_ZERO;
    U8                             x = RRM_ZERO;
    U8                             y = RRM_ZERO;
    U8                             index_of_min = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    for(x = RRM_ZERO; x < ((p_cdma_freq_pri_list->count)-RRM_ONE); x++)
    {
        index_of_min = x;
        for(y = (x+RRM_ONE); y < p_cdma_freq_pri_list->count; y++)
        {
            if(p_cdma_freq_pri_list->cdma_freq_priority_info[index_of_min].\
                cell_reselection_priority < p_cdma_freq_pri_list->\
                cdma_freq_priority_info[y].cell_reselection_priority)
            {
                index_of_min = y;
            }
        }
        temp = p_cdma_freq_pri_list->cdma_freq_priority_info[x].cell_reselection_priority;
        p_cdma_freq_pri_list->cdma_freq_priority_info[x].cell_reselection_priority = \
        p_cdma_freq_pri_list->cdma_freq_priority_info[index_of_min].cell_reselection_priority;
        p_cdma_freq_pri_list->cdma_freq_priority_info[index_of_min].cell_reselection_priority = \
        temp;
        temp_freq = p_cdma_freq_pri_list->cdma_freq_priority_info[x].band_class;
        p_cdma_freq_pri_list->cdma_freq_priority_info[x].band_class =\
        p_cdma_freq_pri_list->cdma_freq_priority_info[index_of_min].band_class;
        p_cdma_freq_pri_list->cdma_freq_priority_info[index_of_min].band_class=
        temp_freq;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "CDMA:band class [%u] cell selection priority[%u]", 
                        p_cdma_freq_pri_list->cdma_freq_priority_info[x].band_class,
                        p_cdma_freq_pri_list->cdma_freq_priority_info[x].cell_reselection_priority);
	}
    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : sort_geran_freq_pri_list
 * Inputs         : rrm_freq_priority_list_t
 * Outputs        : None
 * Returns        : None 
 * Description    : sort the cdma frequencies and priorities
 ****************************************************************************/
rrm_return_et sort_geran_freq_pri_list(
                  rrm_geran_freq_priority_list_info_t*  p_geran_freq_pri_list
                  )
{
    rrm_return_et                  ret_val = RRM_SUCCESS;
    U8                             temp = RRM_ZERO;
    U8                             x = RRM_ZERO;
    U8                             y = RRM_ZERO;
    U8                             index_of_min = RRM_ZERO;
    rrm_son_geran_carrier_freqs_t  temp_geran_carrier_freq = {RRM_ZERO};
    RRM_UT_TRACE_ENTER();
    for(x = RRM_ZERO; x < ((p_geran_freq_pri_list->count)-RRM_ONE); x++)
    {
        index_of_min = x;
        for(y = (x+RRM_ONE); y < p_geran_freq_pri_list->count; y++)
        {
            if(p_geran_freq_pri_list->geran_freq_priority_info[index_of_min].\
                cell_reselection_priority < p_geran_freq_pri_list->\
                geran_freq_priority_info[y].cell_reselection_priority)
            {
                index_of_min = y;
            }
        }
        /* SPR-22640 START */
        if(index_of_min != x)
        {
            /* SPR-22640 END */
            temp = p_geran_freq_pri_list->geran_freq_priority_info[x].cell_reselection_priority;
            p_geran_freq_pri_list->geran_freq_priority_info[x].cell_reselection_priority = \
                                                                                           p_geran_freq_pri_list->geran_freq_priority_info[index_of_min].cell_reselection_priority;
            p_geran_freq_pri_list->geran_freq_priority_info[index_of_min].cell_reselection_priority = \
                                                                                                      temp;
            RRM_MEMCPY(&temp_geran_carrier_freq,
                    &p_geran_freq_pri_list->geran_freq_priority_info[x].carrier_freq,
                    sizeof(rrm_son_geran_carrier_freqs_t));
            RRM_MEMCPY(&p_geran_freq_pri_list->geran_freq_priority_info[x].carrier_freq,
                    &p_geran_freq_pri_list->geran_freq_priority_info[index_of_min].carrier_freq,
                    sizeof(rrm_son_geran_carrier_freqs_t));
            RRM_MEMCPY(&p_geran_freq_pri_list->geran_freq_priority_info[index_of_min].carrier_freq,
                    &temp_geran_carrier_freq,
                    sizeof(rrm_son_geran_carrier_freqs_t));
            /* SPR-22640 START */
        }
        /* SPR-22640 END */
	}
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_hrpd_daho_cell_from_ncl
 *   INPUT      : p_inter_rat_ncl,p_irat_cdma_params
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches HRPD DAHO Cell stored in cell ctx to NCL
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrmcm_rmif_cdma2000_freq_cells_t*
rrm_ue_match_hrpd_daho_cell_from_ncl
(
 rrm_ue_context_t  *p_rrm_ue_context,
 inter_rat_ncl_t  *p_inter_rat_ncl, 
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params
 )
{
    U8 cdma2000_ncl_count = RRM_ZERO;
    U8 valid_cdma2000_ncl_hrpd = RRM_ZERO;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_cell = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    /* start spr 9064 */
    if( (p_rrm_ue_context->ho_restriction_list.bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT ) &&
            ( (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_ALL) ||
              (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_CDMA2000_TYPE) ||
              (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_CDMA2000_AND_UTRAN)
            )
      )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CDMA is restricted for [UE:%d]", p_rrm_ue_context->ue_index);
        return RRM_PNULL;
    }
    /* end spr 9064 */
    cdma2000_ncl_count = p_inter_rat_ncl->num_valid_cdma2000_freq_cells;
    
    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_CDMA2000_CELL_PARAMS_PRESENCE_FLAG)
    {
        if(p_irat_cdma_params->cdma2000_cell_param.bitmask &
                 RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG)
        {
            for(valid_cdma2000_ncl_hrpd = RRM_ZERO;
                    valid_cdma2000_ncl_hrpd < cdma2000_ncl_count;
                    valid_cdma2000_ncl_hrpd++)
            {
                if(RRM_OAM_NCL_TYPE_HRPD == p_inter_rat_ncl->cdma2000_freq_cells[valid_cdma2000_ncl_hrpd].type)
                {
                    /**daho clean up start*/
                    if(RRM_TRUE == p_inter_rat_ncl->cdma2000_freq_cells[valid_cdma2000_ncl_hrpd].daho_indication)
                    {
                        p_cdma2000_daho_cell= &(p_inter_rat_ncl->cdma2000_freq_cells[valid_cdma2000_ncl_hrpd]);
                        break;
                    }
                    /**daho clean up end*/
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return p_cdma2000_daho_cell;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_match_1xrtt_daho_cell_from_ncl
 *   INPUT      : p_inter_rat_ncl,p_irat_cdma_params
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Matches 1XRTT DAHO Cell stored in cell ctx to NCL
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/
rrmcm_rmif_cdma2000_freq_cells_t *
rrm_ue_match_1xrtt_daho_cell_from_ncl
(
  rrm_ue_context_t *p_rrm_ue_context,
  inter_rat_ncl_t  *p_inter_rat_ncl, 
  rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params
)
{
    U8 cdma2000_ncl_count = RRM_ZERO;
    U8 valid_cdma2000_ncl_1xrtt = RRM_ZERO;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_daho_cell = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* start spr 9064 */ 
    if( (p_rrm_ue_context->ho_restriction_list.bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT ) &&
            ( (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_ALL) ||
              (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_CDMA2000_TYPE) ||
              (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_CDMA2000_AND_UTRAN)
            )
      )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CDMA is restricted for [UE:%d]", p_rrm_ue_context->ue_index);
        return RRM_PNULL;
    }
    /* end spr 9064 */ 

    cdma2000_ncl_count = p_inter_rat_ncl->num_valid_cdma2000_freq_cells;

    if(p_irat_cdma_params->presence_bitmask &
            RRMCM_RMIF_CDMA2000_CELL_PARAMS_PRESENCE_FLAG)
    {
        if(p_irat_cdma_params->cdma2000_cell_param.bitmask &
                    RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG)
        {

            for(valid_cdma2000_ncl_1xrtt = RRM_ZERO;
                    valid_cdma2000_ncl_1xrtt < cdma2000_ncl_count;
                    valid_cdma2000_ncl_1xrtt++)
            {
                /*daho clean up start*/
                if(RRM_TRUE == p_inter_rat_ncl->cdma2000_freq_cells[valid_cdma2000_ncl_1xrtt].daho_indication)
                {
                    p_cdma2000_daho_cell= &(p_inter_rat_ncl->cdma2000_freq_cells[valid_cdma2000_ncl_1xrtt]);
                    break;
                }
                /*daho clean up end */
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return p_cdma2000_daho_cell;
}

/****************************************************************************
 * Function Name  : rrm_uem_sort_freq_priority_list
 * Inputs         : rrm_freq_priority_list_t
 * Outputs        : None
 * Returns        : none 
 * Description    : sort the frequencies and priorities
 ****************************************************************************/
rrm_void_t rrm_uem_sort_freq_priority_list(
                  rrm_freq_priority_list_t* p_freq_pri_list)
{
    RRM_UT_TRACE_ENTER();

    sort_eutran_frq_pri_list(&p_freq_pri_list->eutran_freq_priority_list_info);
    sort_utran_frq_pri_list(&(p_freq_pri_list->utran_freq_priority_list_info));
    sort_geran_freq_pri_list(&p_freq_pri_list->geran_freq_priority_list_info);
    sort_cdma_freq_pri_list(&p_freq_pri_list->cdma_freq_priority_list_info);
    RRM_UT_TRACE_EXIT();
    return;
}

/*CDMA2000 changes start*/

/****************************************************************************
 * Function Name  : fill_conn_release_ind_to_cdma2000_1xrtt_cell
 * Inputs         : p_rrm_ue_context,p_inter_rat_ncl,p_irat_cdma_params
 *                  p_rrc_connection_release_ind
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the release with redirection parameters w.r.t. CDMA2000
 ****************************************************************************/
rrm_void_t
fill_conn_release_ind_to_cdma2000_1xrtt_cell
(
 rrm_ue_context_t *p_rrm_ue_context,
 inter_rat_ncl_t  *p_inter_rat_ncl,
 rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma_params,
 rrc_rrm_ue_connection_release_ind_t  *p_rrc_connection_release_ind
 )
{
    U8 valid_band_class_list = RRM_ZERO;
    U8 band_class_list = RRM_ZERO;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_1xrtt_cell = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_cdma2000_1xrtt_cell = rrm_ue_match_1xrtt_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    if(RRM_PNULL != p_cdma2000_1xrtt_cell)
    {
            /* Fill Redirected Carrier Info */
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_1xrtt.
                band_class = p_cdma2000_1xrtt_cell->band_class;
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_1xrtt.
                arfcn = p_cdma2000_1xrtt_cell->arfcn;
            p_rrc_connection_release_ind->redirected_carrier_info.bitmask |=
                RRM_REDIRECTED_CARRIER_INFO_CDMA2000_1XRTT_PRESENT;

            p_rrc_connection_release_ind->bitmask |= 
                RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;

            if(p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
            {
                p_rrc_connection_release_ind->idle_mode_mobility_control.
                    band_class_priority_list_1xrtt.count =  p_irat_cdma_params->
                    cell_reselection_params_1xrtt.band_class_list.count;

                band_class_list = p_irat_cdma_params->
                    cell_reselection_params_1xrtt.band_class_list.count;
                for(valid_band_class_list = RRM_ZERO;
                        valid_band_class_list < band_class_list;
                        valid_band_class_list++)
                {
                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_1xrtt.
                        band_class_priority[valid_band_class_list].band_class = 
                        p_irat_cdma_params->cell_reselection_params_1xrtt.
                        band_class_list.band_class_info_cdma2000[valid_band_class_list].
                        band_class;

                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_1xrtt.
                        band_class_priority[valid_band_class_list].
                        cell_reselection_priority = p_irat_cdma_params->
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[valid_band_class_list].
                        cell_reselection_priority;
                }
                p_rrc_connection_release_ind->idle_mode_mobility_control.bitmask |= 
                    RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_1XRTT_PRESENT;
            }       
            p_rrc_connection_release_ind->bitmask |=
                RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}

/*Klocwork activity 1-Apr_2014 start*/
/****************************************************************************
 * Function Name  : rrm_fill_release_params_cdma2000_for_hrpd_cell_index
 * Inputs         : p_rrc_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the release with redirection parameters w.r.t. CDMA2000
 ****************************************************************************/
rrm_void_t
rrm_fill_release_params_cdma2000_for_hrpd_cell_index
(
 rrc_rrm_ue_connection_release_ind_t     *p_rrc_connection_release_ind,
         /*SPR 17777 +-*/
 rrmcm_idle_mode_mobility_irat_cdma_params_t *p_irat_cdma_params,
 rrmcm_rmif_cdma2000_freq_cells_t  *p_hrpd_cell_index
 )
{
    RRM_UT_TRACE_ENTER();

    U8 band_class_list = RRM_ZERO;
    U8 valid_band_class_list = RRM_ZERO;

        if(p_hrpd_cell_index)
        {
            /* Fill Redirected Carrier Info */
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_hrpd.
                band_class = p_hrpd_cell_index->band_class;
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_hrpd.
                arfcn = p_hrpd_cell_index->arfcn;

            p_rrc_connection_release_ind->redirected_carrier_info.bitmask |=
                RRM_REDIRECTED_CARRIER_INFO_CDMA2000_HRPD_PRESENT;

            p_rrc_connection_release_ind->bitmask |= 
                RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;

            if(p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG)
            {
                p_rrc_connection_release_ind->idle_mode_mobility_control.
                    band_class_priority_list_hrpd.count = p_irat_cdma_params->
                    cell_reselection_params_hrpd.band_class_list.count;

                band_class_list = p_irat_cdma_params->
                    cell_reselection_params_hrpd.band_class_list.count;
                for(valid_band_class_list = RRM_ZERO;
                        valid_band_class_list < band_class_list;
                        valid_band_class_list++)
                {
                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_hrpd.
                        band_class_priority[valid_band_class_list].band_class = 
                        p_irat_cdma_params->cell_reselection_params_hrpd.
                        band_class_list.band_class_info_cdma2000[valid_band_class_list].
                        band_class;

                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_hrpd.
                        band_class_priority[valid_band_class_list].
                        cell_reselection_priority = p_irat_cdma_params->
                        cell_reselection_params_hrpd.band_class_list.
                        band_class_info_cdma2000[valid_band_class_list].
                        cell_reselection_priority;
                }
                p_rrc_connection_release_ind->idle_mode_mobility_control.bitmask |= 
                    RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_HRPD_PRESENT;
            }
            p_rrc_connection_release_ind->bitmask |=
                RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
        }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/

/*Klocwork activity 1-Apr_2014 start*/
/****************************************************************************
 * Function Name  : rrm_fill_release_params_cdma2000_for_1xrtt_cell_index
 * Inputs         : p_rrc_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the release with redirection parameters w.r.t. CDMA2000
 ****************************************************************************/
rrm_void_t
rrm_fill_release_params_cdma2000_for_1xrtt_cell_index
(
 rrc_rrm_ue_connection_release_ind_t     *p_rrc_connection_release_ind,
         /*SPR 17777 +-*/
 rrmcm_idle_mode_mobility_irat_cdma_params_t *p_irat_cdma_params,
 rrmcm_rmif_cdma2000_freq_cells_t  *p_1xrtt_cell_index
 )
{
    RRM_UT_TRACE_ENTER();

    U8 band_class_list = RRM_ZERO;
    U8 valid_band_class_list = RRM_ZERO;

        if(p_1xrtt_cell_index)
        {
            /* Fill Redirected Carrier Info */
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_1xrtt.
                band_class = p_1xrtt_cell_index->band_class;

            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_1xrtt.
                arfcn = p_1xrtt_cell_index->arfcn;

            p_rrc_connection_release_ind->redirected_carrier_info.bitmask |=
                RRM_REDIRECTED_CARRIER_INFO_CDMA2000_1XRTT_PRESENT;

            p_rrc_connection_release_ind->bitmask |=
                RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;

            if(p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
            {
                p_rrc_connection_release_ind->idle_mode_mobility_control.
                    band_class_priority_list_1xrtt.count = p_irat_cdma_params->
                    cell_reselection_params_1xrtt.band_class_list.count;

                if(p_irat_cdma_params->presence_bitmask &
                        RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
                {
                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_1xrtt.count = p_irat_cdma_params->
                        cell_reselection_params_1xrtt.band_class_list.count;

                    band_class_list = p_irat_cdma_params->
                        cell_reselection_params_1xrtt.band_class_list.count;
                    for(valid_band_class_list = RRM_ZERO;
                            valid_band_class_list < band_class_list;
                            valid_band_class_list++)
                    {
                        p_rrc_connection_release_ind->idle_mode_mobility_control.
                            band_class_priority_list_1xrtt.
                            band_class_priority[valid_band_class_list].band_class = 
                            p_irat_cdma_params->cell_reselection_params_1xrtt.
                            band_class_list.band_class_info_cdma2000[valid_band_class_list].
                            band_class;

                        p_rrc_connection_release_ind->idle_mode_mobility_control.
                            band_class_priority_list_1xrtt.
                            band_class_priority[valid_band_class_list].
                            cell_reselection_priority = p_irat_cdma_params->
                            cell_reselection_params_1xrtt.band_class_list.
                            band_class_info_cdma2000[valid_band_class_list].
                            cell_reselection_priority;
                    }
                    p_rrc_connection_release_ind->idle_mode_mobility_control.bitmask |= 
                        RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_1XRTT_PRESENT;
                }
                p_rrc_connection_release_ind->bitmask |=
                    RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
            }
        }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/
/****************************************************************************
 * Function Name  : rrm_fill_release_params_cdma2000_for_1xrtt_hrpd
 * Inputs         : p_rrc_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the release with redirection parameters w.r.t. CDMA2000
 ****************************************************************************/
rrm_void_t
rrm_fill_release_params_cdma2000_for_1xrtt_hrpd
(
 rrc_rrm_ue_connection_release_ind_t     *p_rrc_connection_release_ind,
 rrm_ue_context_t                        *p_ue_context
 )
{
    RRM_UT_TRACE_ENTER();
    inter_rat_ncl_t                 *p_inter_rat_ncl = RRM_PNULL;
    rrm_cell_context_t              *p_rrm_cell_ctx = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_irat_cdma_params = RRM_PNULL;

    U8 num_valid_cdma2000_freq_cells = RRM_ZERO;
    U8 band_class_hrpd_ue_capab = RRM_ZERO;
    U8 band_class_1xrtt_ue_capab = RRM_ZERO;
    U8 valid_bc_index = RRM_ZERO;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_hrpd_cell_index = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_1xrtt_cell_index = RRM_PNULL;
    U8 count_bc_hrpd_ue_capab = RRM_ZERO;
    U8 count_bc_1xrtt_ue_capab = RRM_ZERO;
    U8 valid_bc_ue_capab_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    p_inter_rat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);

    p_irat_cdma_params = &(p_rrm_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);
    /*CID 65840:start*/
    if (RRM_PNULL != p_rrm_cell_ctx)
    {
        num_valid_cdma2000_freq_cells = p_rrm_cell_ctx->ran_info.ncl_params.
            inter_rat_ncl.num_valid_cdma2000_freq_cells;

        p_rrc_connection_release_ind->redirected_carrier_info.bitmask = RRM_ZERO;

        if(!(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))
        {
            count_bc_hrpd_ue_capab = p_ue_context->ue_capability_params.
                rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
                inter_rat_parameters.cdma2000_hrpd.supported_band_list_hrpd.
                count;

            for(valid_bc_ue_capab_index = RRM_ZERO;
                    ((valid_bc_ue_capab_index < count_bc_hrpd_ue_capab) && (valid_bc_ue_capab_index < MAX_CDMA_BAND_CLASS ));
                    valid_bc_ue_capab_index++)
            {
                band_class_hrpd_ue_capab = p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
                    inter_rat_parameters.cdma2000_hrpd.supported_band_list_hrpd.
                    band_class_cdma2000[valid_bc_ue_capab_index];

                /* Find Bandclass for supported HRPD Cell */
                for(valid_bc_index = RRM_ZERO;
                        valid_bc_index < num_valid_cdma2000_freq_cells;
                        valid_bc_index++)
                {
                    if(p_inter_rat_ncl->cdma2000_freq_cells[valid_bc_index].type == RRM_OAM_NCL_TYPE_HRPD)
                    {
                        if(band_class_hrpd_ue_capab == p_inter_rat_ncl->
                                cdma2000_freq_cells[valid_bc_index].band_class)
                        {
                            p_hrpd_cell_index = &(p_inter_rat_ncl->cdma2000_freq_cells[valid_bc_index]);
                            break;
                        }
                    }
                }
                if(p_hrpd_cell_index)
                {
                    break;
                }
            }
            /* Fill Info for HRPD */
            /*Klocwork activity 1-Apr_2014 start*/
            rrm_fill_release_params_cdma2000_for_hrpd_cell_index
                (
                 p_rrc_connection_release_ind,
         /*SPR 17777 +-*/
                 p_irat_cdma_params,
                 p_hrpd_cell_index
                );
            /*Klocwork activity 1-Apr_2014 end*/

        }
        else
        {
            count_bc_1xrtt_ue_capab = p_ue_context->ue_capability_params.
                rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
                inter_rat_parameters.cdma2000_1x_rtt.supported_band_list_1xrtt.
                count;

            for(valid_bc_ue_capab_index = RRM_ZERO;
                    ((valid_bc_ue_capab_index < count_bc_1xrtt_ue_capab) && ( valid_bc_ue_capab_index < MAX_CDMA_BAND_CLASS));
                    valid_bc_ue_capab_index++)
            {
                band_class_1xrtt_ue_capab = p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
                    inter_rat_parameters.cdma2000_1x_rtt.supported_band_list_1xrtt.
                    band_class_cdma2000[valid_bc_ue_capab_index];

                /* Find Bandclass for supported HRPD Cell */
                for(valid_bc_index = RRM_ZERO;
                        valid_bc_index < num_valid_cdma2000_freq_cells;
                        valid_bc_index++)
                {
                    if(p_inter_rat_ncl->cdma2000_freq_cells[valid_bc_index].type == RRM_OAM_NCL_TYPE_1XRTT)
                    {
                        if(band_class_1xrtt_ue_capab == p_inter_rat_ncl->
                                cdma2000_freq_cells[valid_bc_index].band_class)
                        {
                            p_1xrtt_cell_index = &(p_inter_rat_ncl->cdma2000_freq_cells[valid_bc_index]);
                            break;
                        }
                    }
                }
                if(p_1xrtt_cell_index)
                {
                    break;
                }
            }
            /* Fill Info for 1xrtt */
            /*Klocwork activity 1-Apr_2014 start*/
            rrm_fill_release_params_cdma2000_for_1xrtt_cell_index
                (
                 p_rrc_connection_release_ind,
                /*SPR 17777 +-*/
                 p_irat_cdma_params,
                 p_1xrtt_cell_index
                );
            /*Klocwork activity 1-Apr_2014 end*/
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
    }

    /*CID 65840:end*/
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_conn_release_ind_to_cdma2000_hrpd_cell
 * Inputs         : p_inter_rat_ncl,p_irat_cdma_params,p_rrc_connection_release_ind
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the release with redirection parameters w.r.t. CDMA2000
 ****************************************************************************/
rrm_void_t
fill_conn_release_ind_to_cdma2000_hrpd_cell
(
 rrm_ue_context_t *p_rrm_ue_context,
 inter_rat_ncl_t  *p_inter_rat_ncl,
  rrmcm_idle_mode_mobility_irat_cdma_params_t * p_irat_cdma_params,
rrc_rrm_ue_connection_release_ind_t  *p_rrc_connection_release_ind
 )
{
    U8 band_class_list = RRM_ZERO;
    U8 valid_band_class_list = RRM_ZERO;
    rrmcm_rmif_cdma2000_freq_cells_t  *p_cdma2000_hrpd_cell = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_cdma2000_hrpd_cell = rrm_ue_match_hrpd_daho_cell_from_ncl(p_rrm_ue_context, p_inter_rat_ncl, p_irat_cdma_params);

    if(RRM_PNULL != p_cdma2000_hrpd_cell)
    {
            /* Fill Redirected Carrier Info */
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_hrpd.
                band_class = p_cdma2000_hrpd_cell->band_class;
            p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_hrpd.
                arfcn = p_cdma2000_hrpd_cell->arfcn;
            p_rrc_connection_release_ind->redirected_carrier_info.bitmask |=
                RRM_REDIRECTED_CARRIER_INFO_CDMA2000_HRPD_PRESENT;

            p_rrc_connection_release_ind->bitmask |= 
                RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;

            if(p_irat_cdma_params->presence_bitmask &
                    RRMCM_RMIF_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG)
            {
                p_rrc_connection_release_ind->idle_mode_mobility_control.
                    band_class_priority_list_hrpd.count =  p_irat_cdma_params->
                    cell_reselection_params_hrpd.band_class_list.count;

                band_class_list = p_irat_cdma_params->
                    cell_reselection_params_hrpd.band_class_list.count;
                for(valid_band_class_list = RRM_ZERO;
                        valid_band_class_list < band_class_list;
                        valid_band_class_list++)
                {
                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_hrpd.
                        band_class_priority[valid_band_class_list].band_class = 
                        p_irat_cdma_params->cell_reselection_params_hrpd.
                        band_class_list.band_class_info_cdma2000[valid_band_class_list].
                        band_class;

                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_hrpd.
                        band_class_priority[valid_band_class_list].
                        cell_reselection_priority = p_irat_cdma_params->
                        cell_reselection_params_hrpd.band_class_list.
                        band_class_info_cdma2000[valid_band_class_list].
                        cell_reselection_priority;
                }
                p_rrc_connection_release_ind->idle_mode_mobility_control.bitmask |= 
                    RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_HRPD_PRESENT;
            }
            p_rrc_connection_release_ind->bitmask |=
                RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
        }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_fill_release_params_cdma2000
 * Inputs         : p_rrc_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the release with redirection parameters w.r.t. CDMA2000
 ****************************************************************************/
rrm_void_t
rrm_fill_release_params_cdma2000
(
 rrc_rrm_ue_connection_release_ind_t     *p_rrc_connection_release_ind,
 rrm_ue_context_t                        *p_ue_context
 )
{
    U8 cdma2000_cells_present = RRM_ZERO;
    U8 band_class_list = RRM_ZERO;
    U8 valid_band_class_list = RRM_ZERO;

    rrm_ue_measurment_results_ind_t *p_ue_measurment_results = RRM_PNULL;
    inter_rat_ncl_t                 *p_inter_rat_ncl = RRM_PNULL;
    rrm_cell_context_t              *p_rrm_cell_ctx = RRM_PNULL;
    rrmcm_idle_mode_mobility_irat_cdma_params_t *p_irat_cdma_params = RRM_PNULL;

    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_hrpd_ctx_info = RRM_PNULL;
    rrm_ue_cdma2000_ncl_info_list_t  *p_cdma2000_1xrtt_ctx_info = RRM_PNULL;

    p_ue_measurment_results = (rrm_ue_measurment_results_ind_t *)
        p_ue_context->current_procedure.p_proc_data;

    RRM_UT_TRACE_ENTER();


    p_rrm_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    p_inter_rat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);


    if(RRM_PNULL != p_ue_measurment_results)
    {
      cdma2000_cells_present = p_ue_measurment_results->cdma2000_meas_results.
          meas_result_list_cdma2000.cdma2000_count;
    }

    if(RRM_PNULL != p_rrm_cell_ctx)   /* Klocwork_fix_27_aug */
    {
        p_irat_cdma_params = &(p_rrm_cell_ctx->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
    }

    if((cdma2000_cells_present > RRM_ZERO) && (RRM_PNULL != p_irat_cdma_params)) /* Klocwork_fix_27_aug */
    {
        p_rrc_connection_release_ind->redirected_carrier_info.bitmask = RRM_ZERO;

        if(!(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))
        {
            /* If measurements are reported for HRPD Cell */
            p_cdma2000_hrpd_ctx_info = rrm_ue_match_hrpd_cell_meas_ctx(p_ue_context, p_ue_measurment_results);

            if(RRM_PNULL != p_cdma2000_hrpd_ctx_info)
            {
                /* Fill Redirected Carrier Info */
                p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_hrpd.
                    band_class = p_cdma2000_hrpd_ctx_info->band_class;
                p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_hrpd.
                    arfcn = p_cdma2000_hrpd_ctx_info->arfcn;

                p_rrc_connection_release_ind->redirected_carrier_info.bitmask |=
                    RRM_REDIRECTED_CARRIER_INFO_CDMA2000_HRPD_PRESENT;

                p_rrc_connection_release_ind->bitmask |= 
                    RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;

                if(p_irat_cdma_params->presence_bitmask &
                        RRMCM_RMIF_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG)
                {
                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_hrpd.count = p_irat_cdma_params->
                        cell_reselection_params_hrpd.band_class_list.count;

                    band_class_list = p_irat_cdma_params->
                        cell_reselection_params_hrpd.band_class_list.count;
                    for(valid_band_class_list = RRM_ZERO;
                            valid_band_class_list < band_class_list;
                            valid_band_class_list++)
                    {
                        p_rrc_connection_release_ind->idle_mode_mobility_control.
                            band_class_priority_list_hrpd.
                            band_class_priority[valid_band_class_list].band_class = 
                            p_irat_cdma_params->cell_reselection_params_hrpd.
                            band_class_list.band_class_info_cdma2000[valid_band_class_list].
                            band_class;

                        p_rrc_connection_release_ind->idle_mode_mobility_control.
                            band_class_priority_list_hrpd.
                            band_class_priority[valid_band_class_list].
                            cell_reselection_priority = p_irat_cdma_params->
                            cell_reselection_params_hrpd.band_class_list.
                            band_class_info_cdma2000[valid_band_class_list].
                            cell_reselection_priority;
                    }
                    p_rrc_connection_release_ind->idle_mode_mobility_control.bitmask |= 
                        RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_HRPD_PRESENT;
                }
                p_rrc_connection_release_ind->bitmask |=
                    RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
            }
            else
            {
                fill_conn_release_ind_to_cdma2000_hrpd_cell(p_ue_context, p_inter_rat_ncl, 
                        p_irat_cdma_params, 
                        p_rrc_connection_release_ind);
            }
        }
        else if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
        {
            /* If measurements are reported for 1XRTT Cell */
            /* Fill 1XRTT only if eCSFb/eCSFB con. PS HO is not supported */
            p_cdma2000_1xrtt_ctx_info = rrm_ue_match_1xrtt_cell_meas_ctx(p_ue_context, p_ue_measurment_results);

            if(RRM_PNULL != p_cdma2000_1xrtt_ctx_info)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "In case of CSFB_RECD CDMA 2000 1xrtt Context is  not NULL");
                /* Fill Redirected Carrier Info */
                p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_1xrtt.
                    band_class = p_cdma2000_1xrtt_ctx_info->band_class;

                p_rrc_connection_release_ind->redirected_carrier_info.cdma2000_1xrtt.
                    arfcn = p_cdma2000_1xrtt_ctx_info->arfcn;

                p_rrc_connection_release_ind->redirected_carrier_info.bitmask |=
                    RRM_REDIRECTED_CARRIER_INFO_CDMA2000_1XRTT_PRESENT;

                p_rrc_connection_release_ind->bitmask |= 
                    RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;

                if(p_irat_cdma_params->presence_bitmask &
                        RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
                {
                    p_rrc_connection_release_ind->idle_mode_mobility_control.
                        band_class_priority_list_1xrtt.count = p_irat_cdma_params->
                        cell_reselection_params_1xrtt.band_class_list.count;

                    band_class_list = p_irat_cdma_params->
                        cell_reselection_params_1xrtt.band_class_list.count;
                    for(valid_band_class_list = RRM_ZERO;
                            valid_band_class_list < band_class_list;
                            valid_band_class_list++)
                    {
                        p_rrc_connection_release_ind->idle_mode_mobility_control.
                            band_class_priority_list_1xrtt.
                            band_class_priority[valid_band_class_list].band_class = 
                            p_irat_cdma_params->cell_reselection_params_1xrtt.
                            band_class_list.band_class_info_cdma2000[valid_band_class_list].
                            band_class;

                        p_rrc_connection_release_ind->idle_mode_mobility_control.
                            band_class_priority_list_1xrtt.
                            band_class_priority[valid_band_class_list].
                            cell_reselection_priority = p_irat_cdma_params->
                            cell_reselection_params_1xrtt.band_class_list.
                            band_class_info_cdma2000[valid_band_class_list].
                            cell_reselection_priority;
                    }
                    p_rrc_connection_release_ind->idle_mode_mobility_control.bitmask |= 
                        RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_1XRTT_PRESENT;
                }
                p_rrc_connection_release_ind->bitmask |=
                    RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
            }
            else
            {
                fill_conn_release_ind_to_cdma2000_1xrtt_cell(p_ue_context,
                        p_inter_rat_ncl,
                        p_irat_cdma_params,
                        p_rrc_connection_release_ind);
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Cell Reported by Measurement Results doesn't matched");
        }
    }
    else
    {
        rrm_fill_release_params_cdma2000_for_1xrtt_hrpd(
                p_rrc_connection_release_ind,
                p_ue_context);
    }
    RRM_UT_TRACE_EXIT();
}
/*CDMA2000 changes end*/

/*Klocwork activity 1-Apr_2014 start*/
/****************************************************************************
 * Function Name  : rrm_get_idle_mode_ue_connection_release_ind_param_for_eutran
 * Inputs         : p_ue_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Fills the idlemode reselction priorities
 ****************************************************************************/
rrm_return_et rrm_get_idle_mode_ue_connection_release_ind_param_for_eutran
(
 rrc_rrm_ue_connection_release_ind_t *p_ue_connection_release_ind,
 rrm_ue_context_t                    *p_ue_context,
         /*SPR 17777 +-*/
 rrm_freq_priority_list_t            *p_freq_priority,
 rrm_cell_context_t                  *p_cell_ctx
 )
{
    rrm_return_et   ret_val = RRM_FAILURE;
    U8                val = RRM_ZERO;
    U32                            carrier_freq = RRM_ZERO;
    U8                             freq_count = RRM_ZERO;
    
    RRM_UT_TRACE_ENTER();

    if((EUTRA_CELL == p_ue_context->target_cell_type) && (!(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))) 
    {
        /*SPR_15878 Fix start*/
        /* Code removed : During CSFB RRM is changing the cellReselectionPriority value
         * to a quantized value based on the bucket value set in rrm.cfg */
        /*SPR_15878 Fix end*/
    
    /* Fill RWR info for Eutran DAHO */
        /* Intra Freq DAHO Cell */
        p_ue_connection_release_ind->redirected_carrier_info.bitmask = RRM_ZERO;
        p_ue_connection_release_ind->redirected_carrier_info.eutra =
            p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn;
	    p_ue_connection_release_ind->redirected_carrier_info.bitmask |=
                                    RRM_REDIRECTED_CARRIER_INFO_EUTRA_PRESENT;
        /* 6135 : Bitmask changes start */
        p_ue_connection_release_ind->bitmask |=
            RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT;
        /* 6135 : Bitmask changes end */

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "received eutran freq priority count is [%d] ",\
                    p_freq_priority->eutran_freq_priority_list_info.count);
        for(val =0; val < p_freq_priority->eutran_freq_priority_list_info.count;val++)
        {
            carrier_freq = p_freq_priority->eutran_freq_priority_list_info.\
                eutran_freq_priority_info[val].carrier_freq;
            /* SPR 12897 Start */
            if (RRM_ZERO == rrm_ue_is_ue_supported_eutra_frequency (
            /* SPR 12897 End */
                                                       carrier_freq,
                                                        p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			"Carrier Freq = %d, is not supported by [UE:%d]",
                         carrier_freq,
                         p_ue_context->ue_index);
	        continue;
            }
            p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_eutra.freq_priority_eutra[freq_count].carrier_freq = carrier_freq;
            p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_eutra.freq_priority_eutra[freq_count].cell_reselection_priority =\
            p_freq_priority->eutran_freq_priority_list_info.eutran_freq_priority_info[val].\
                cell_reselection_priority;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "new eutran frequency [%d] and priority is [%d] ",\
                    p_freq_priority->eutran_freq_priority_list_info.\
                    eutran_freq_priority_info[val].carrier_freq,
                    p_freq_priority->eutran_freq_priority_list_info.\
                    eutran_freq_priority_info[val].cell_reselection_priority);
            freq_count++;
        }
        if(freq_count)
        {
            p_ue_connection_release_ind->idle_mode_mobility_control.bitmask |=\
                                                                              RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_EUTRA_PRESENT;
            p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_eutra.\
                count = freq_count;
            /* SPR 19445 Fix Start */
            if (!(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))
            {
            p_ue_connection_release_ind->bitmask |= \
                                                    RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
        }
            /* SPR 19445 Fix End */
        }
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_SUCCESS;
        return ret_val;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klocwork activity 1-Apr_2014 end*/

/*Klocwork activity 1-Apr_2014 start*/
/****************************************************************************
 * Function Name  : rrm_get_idle_mode_ue_connection_release_ind_param_for_utran
 * Inputs         : p_ue_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Fills the idlemode reselction priorities
 ****************************************************************************/
rrm_return_et
rrm_get_idle_mode_ue_connection_release_ind_param_for_utran
(
 rrc_rrm_ue_connection_release_ind_t *p_ue_connection_release_ind,
         /*SPR 17777 +-*/
 rrm_ue_context_t                    *p_ue_context,
 rrm_freq_priority_list_t            *p_freq_priority,
 /*SPR 17850 +-*/
 rrm_cell_context_t                  *p_cell_ctx
 )
{
    rrm_return_et     ret_val = RRM_FAILURE;
    U8                val = RRM_ZERO;
    U16                            carrier_freq = RRM_ZERO;
    U8                             freq_count = RRM_ZERO;
    U8                             utran_fdd_count=RRM_ZERO; 
    U8                             utran_tdd_count=RRM_ZERO;


    RRM_UT_TRACE_ENTER();

    /* SPR 17850 Fix Start */
    if(p_ue_context->target_cell_type == UTRA_CELL)
    /* SPR 17850 Fix End */
    {
        /*SPR_15878 Fix start*/
        /* Code removed : During CSFB RRM is changing the cellReselectionPriority value
         * to a quantized value based on the bucket value set in rrm.cfg */
        /*SPR_15878 Fix end*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "RRC_CONNECTION_REL_IND: target rat type:UTRA_CELL");

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "received utran freq priority count is [%d]",\
                    p_freq_priority->utran_freq_priority_list_info.count);
        /* Start fix for SPR 7015 */
	if (p_cell_ctx->ran_info.mobility_params.\
			idle_mode_mobility_params.bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT)
	{
		if (p_cell_ctx->ran_info.mobility_params.\
				idle_mode_mobility_params.\
				idle_mode_mobility_irat_utra_params.bitmask & RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT)
		{
			for(val =0, freq_count=0; val< p_freq_priority->utran_freq_priority_list_info.count;val++)
			{
			    carrier_freq = p_freq_priority->utran_freq_priority_list_info.\
				 utran_freq_priority_info[val].carrier_freq;
				for(utran_fdd_count = RRM_ZERO;utran_fdd_count<= p_cell_ctx->ran_info.mobility_params.\
						idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
						irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers - RRM_ONE; utran_fdd_count ++ )
				{
				    if (carrier_freq == p_cell_ctx->ran_info.mobility_params.\
					idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
					irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[utran_fdd_count].utra_carrier_arfcn)
                                        { 
                        /* SPR 22731 Fix Start */
                        if(RRM_FALSE == rrm_ue_is_ue_supported_utra_fdd_frequency (
								     carrier_freq,
								     p_ue_context))
                            /* SPR 22731 Fix End */
					    {
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						  "UTRA Carrier Freq = %d, is not supported by [UE:%d]",
						   carrier_freq,
						   p_ue_context->ue_index);
						break;
					    }
					    p_ue_connection_release_ind->idle_mode_mobility_control.\
						freq_priority_list_utra_fdd.freq_priority_utra_fdd[freq_count].carrier_freq = carrier_freq;
					    p_ue_connection_release_ind->idle_mode_mobility_control.\
						freq_priority_list_utra_fdd.freq_priority_utra_fdd[freq_count].cell_reselection_priority =\
					    p_freq_priority->utran_freq_priority_list_info.utran_freq_priority_info[val].\
						cell_reselection_priority;
					    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
						    "new utran frequency [%d] and priority is [%d] ",\
						    p_freq_priority->utran_freq_priority_list_info.\
						    utran_freq_priority_info[val].carrier_freq,
						    p_freq_priority->utran_freq_priority_list_info.\
						    utran_freq_priority_info[val].cell_reselection_priority);
					    freq_count++;
                                            break;
                                        }
				}
                        }
			if(freq_count)
			{
			    p_ue_connection_release_ind->idle_mode_mobility_control.bitmask |=\
				RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_UTRA_FDD_PRESENT;
			    p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_fdd.\
			       count = freq_count;
                /* SPR 19445 Fix Start */
                if (!(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))
                {
 			    p_ue_connection_release_ind->bitmask |= \
			   RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
			}
                /* SPR 19445 Fix End */
            }

		}

		if (p_cell_ctx->ran_info.mobility_params.\
				idle_mode_mobility_params.\
				idle_mode_mobility_irat_utra_params.bitmask & RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT)
		{
			for(val =RRM_ZERO, freq_count=RRM_ZERO; val< p_freq_priority->utran_freq_priority_list_info.count;val++)
			{
			    carrier_freq = p_freq_priority->utran_freq_priority_list_info.\
				 utran_freq_priority_info[val].carrier_freq;
				for(utran_tdd_count = RRM_ZERO;utran_tdd_count<= p_cell_ctx->ran_info.mobility_params.\
						idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
						irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers - RRM_ZERO; utran_tdd_count ++ )
				{
				    if (carrier_freq == p_cell_ctx->ran_info.mobility_params.\
					idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
					irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[utran_tdd_count].utra_carrier_arfcn)
                                    { 
          
                        /* SPR 22731 Fix Start */
                        if(RRM_FALSE == rrm_ue_is_ue_supported_utra_tdd_frequency (
								     carrier_freq,
								     p_ue_context))
                            /* SPR 22731 Fix End */
					    {
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						  "UTRA Carrier Freq = %d, is not supported by [UE:%d]",
						   carrier_freq,
						   p_ue_context->ue_index);
						break;
					    }
					    p_ue_connection_release_ind->idle_mode_mobility_control.\
						freq_priority_list_utra_tdd.freq_priority_utra_tdd[freq_count].carrier_freq = carrier_freq;
					    p_ue_connection_release_ind->idle_mode_mobility_control.\
						freq_priority_list_utra_tdd.freq_priority_utra_tdd[freq_count].cell_reselection_priority =\
					    p_freq_priority->utran_freq_priority_list_info.utran_freq_priority_info[val].\
						cell_reselection_priority;
					    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
						    "new utran frequency [%d] and priority is [%d] ",\
					    p_freq_priority->utran_freq_priority_list_info.\
					    utran_freq_priority_info[val].carrier_freq,
					    p_freq_priority->utran_freq_priority_list_info.\
					    utran_freq_priority_info[val].cell_reselection_priority);
					    freq_count++;
                                            break;
				    }
                                }
			}
			if(freq_count)
			{
			    p_ue_connection_release_ind->idle_mode_mobility_control.bitmask |=\
				RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_UTRA_TDD_PRESENT;
			    p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_utra_tdd.\
				count = freq_count;
			    p_ue_connection_release_ind->bitmask |= \
			   RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
			}
		}
	}
        /* End fix for SPR 7015 */
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_SUCCESS;
        return ret_val;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klocwork activity 1-Apr_2014 end*/
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_get_idle_mode_ue_conn_release_ind_param_for_geran
 * Inputs         : p_ue_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the idlemode reselction priorities
 ****************************************************************************/
rrm_void_t
rrm_get_idle_mode_ue_conn_release_ind_param_for_geran(rrm_freq_priority_list_t  *p_freq_priority ,
                                           rrc_rrm_ue_connection_release_ind_t  *p_ue_connection_release_ind ,
                                           U8                                   freq_count ,
                                           U8                                   val)

{
    U8                             count= RRM_ZERO;
    U8                             exp_arfcn_count= RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(p_freq_priority->geran_freq_priority_list_info.\
            geran_freq_priority_info[val].carrier_freq.following_arfcns.bitmask & 
            RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT)
    {
        p_ue_connection_release_ind->idle_mode_mobility_control.\
            freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
            following_arfcns.presence_bitmask |= GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

        exp_arfcn_count = p_freq_priority->geran_freq_priority_list_info.\
                          geran_freq_priority_info[val].carrier_freq.following_arfcns.exp_arfcn_list_size;

        p_ue_connection_release_ind->idle_mode_mobility_control.\
            freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
            following_arfcns.explicit_list_of_arfcns.count = exp_arfcn_count;

        for(count = 0; count < exp_arfcn_count;count++)
        {
            p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
                following_arfcns.explicit_list_of_arfcns.data[count] = \
                p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.following_arfcns.exp_arfcn_list[count];
        }
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_get_idle_mode_ue_release_ind_param_for_geran_bitmap
 * Inputs         : p_ue_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the idlemode reselction priorities
 ****************************************************************************/
rrm_void_t
rrm_get_idle_mode_ue_release_ind_param_for_geran_bitmap(rrm_freq_priority_list_t  *p_freq_priority ,
                                           rrc_rrm_ue_connection_release_ind_t    *p_ue_connection_release_ind ,
                                           U8                                     freq_count ,
                                           U8                                     val )
                               
{

    U8                             bmp_arfcn_count= RRM_ZERO;
    U8                             count= RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(p_freq_priority->geran_freq_priority_list_info.\
            geran_freq_priority_info[val].carrier_freq.following_arfcns.bitmask & 
            RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT)
    {
        p_ue_connection_release_ind->idle_mode_mobility_control.\
            freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
            following_arfcns.presence_bitmask |= GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;

        bmp_arfcn_count = p_freq_priority->geran_freq_priority_list_info.\
                          geran_freq_priority_info[val].carrier_freq.following_arfcns.arfcn_bmp_list_size;

        p_ue_connection_release_ind->idle_mode_mobility_control.\
            freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
            following_arfcns.var_bitmap_of_arfcns.count = bmp_arfcn_count;

        for(count = RRM_ZERO; count < bmp_arfcn_count;count++)
        {
            p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
                following_arfcns.var_bitmap_of_arfcns.data[count] = \
                p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.following_arfcns.arfcn_bmp_list[count];
        }

    }
    RRM_UT_TRACE_EXIT();
}

/*Klockwork_fix_end*/



/*Klocwork activity 1-Apr_2014 start*/
/****************************************************************************
 * Function Name  : rrm_get_idle_mode_ue_connection_release_ind_param_for_geran
 * Inputs         : p_ue_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Fills the idlemode reselction priorities
 ****************************************************************************/
rrm_return_et
rrm_get_idle_mode_ue_connection_release_ind_param_for_geran
(
 rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
 rrm_ue_context_t *p_ue_context,
         /*SPR 17777 +-*/
 rrm_freq_priority_list_t *p_freq_priority
)
{
    rrm_return_et     ret_val                 = RRM_FAILURE;
    U8                val = RRM_ZERO;
    U16                            carrier_freq = RRM_ZERO;
    U8                             freq_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

      /*cs fall back is true nd target cell is geran*/
    /* Start :SPR 1020 */
    if ((p_ue_context->target_cell_type == GERAN_CELL))
    /* End :SPR 1020 */
    {   
        /*SPR_15878 Fix start*/
        /* Code removed : During CSFB RRM is changing the cellReselectionPriority value
         * to a quantized value based on the bucket value set in rrm.cfg */
        /*SPR_15878 Fix end*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                          "RRC_CONNECTION_REL_IND: target rat type:GERAN_CELL");
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "received GERAN freq priority count is [%d]",\
                    p_freq_priority->geran_freq_priority_list_info.count);
        for(val =RRM_ZERO, freq_count=RRM_ZERO; val< p_freq_priority->geran_freq_priority_list_info.count;val++)
        {
            carrier_freq = p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.starting_arfcn;
            if(RRM_FALSE == rrm_ue_is_ue_supported_geran_frequency (
                                     carrier_freq,
                                     p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
	          "GERAN Carrier Freq = %d, is not supported by [UE:%d]",
                   carrier_freq,
                   p_ue_context->ue_index);
	                continue;
            }
            p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.starting_arfcn =\
                carrier_freq;
            if (p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.band_ind == RRM_SON_GERAN_DCS_1800)
            {
                p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.\
                band_indicator = RRM_RRC_DCS1800;
            }
            else
            {
                p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.\
                band_indicator = RRM_RRC_PCS1900;
            }
            p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].cell_reselection_priority =\
            p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].cell_reselection_priority;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "[UE:%d] support geran freq[%d] band[%s] cell selection priority[%u]",p_ue_context->ue_index,
                    carrier_freq,
                    (p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.\
                     freqs_priority_geran[freq_count].carrier_freq.band_indicator?"RRM_RRC_PCS1900":"RRM_RRC_DCS1800"),
                    p_freq_priority->geran_freq_priority_list_info.geran_freq_priority_info[val].cell_reselection_priority);
                       
            /*Klockwork_fix_start*/
            rrm_get_idle_mode_ue_conn_release_ind_param_for_geran(p_freq_priority ,
                                     p_ue_connection_release_ind ,freq_count ,val);
            /*Klockwork_fix_end*/
            
            if(p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.following_arfcns.bitmask & 
                RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT)
            {
                p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
                following_arfcns.presence_bitmask |= GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

                p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
                following_arfcns.equally_spaced_arfcns.arfcn_spacing =\
                p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.following_arfcns.arfcn_spacing;

                p_ue_connection_release_ind->idle_mode_mobility_control.\
                freq_priority_list_geran.freqs_priority_geran[freq_count].carrier_freq.
                following_arfcns.equally_spaced_arfcns.num_of_following_arfcns =\
                p_freq_priority->geran_freq_priority_list_info.\
                geran_freq_priority_info[val].carrier_freq.following_arfcns.num_of_following_arfcn;
            }
             /*Klockwork_fix_start*/
             rrm_get_idle_mode_ue_release_ind_param_for_geran_bitmap(p_freq_priority ,
                  p_ue_connection_release_ind ,freq_count ,val);
             /*Klockwork_fix_end*/
             
            freq_count++;
        }
        if(freq_count)
        {
            p_ue_connection_release_ind->idle_mode_mobility_control.bitmask |=\
                                                                              RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_GERAN_PRESENT;
            p_ue_connection_release_ind->idle_mode_mobility_control.freq_priority_list_geran.\
                count = freq_count;
            /* SPR 19445 Fix Start */
            if (!(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD))
            {
            p_ue_connection_release_ind->bitmask |= \
                                                    RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT;
        }
            /* SPR 19445 Fix End */
        }
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_SUCCESS;
        return ret_val;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klocwork activity 1-Apr_2014 end*/

/****************************************************************************
 * Function Name  : rrm_get_idle_mode_ue_connection_release_ind_param
 * Inputs         : p_ue_connection_release_ind,p_ue_context
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Fills the idlemode reselction priorities
 ****************************************************************************/
rrm_return_et rrm_get_idle_mode_ue_connection_release_ind_param(
                  rrc_rrm_ue_connection_release_ind_t* p_ue_connection_release_ind,
                  rrm_ue_context_t *p_ue_context)
{
    rrm_return_et     ret_val  = RRM_SUCCESS;
    /* SPR 21089 Fix Start */
    /* Code Deleted */
    /* SPR 21089 Fix End */
    rrm_freq_priority_list_t *p_freq_priority = RRM_PNULL;
    rrm_cell_index_t               cell_index = p_ue_context->cell_index;
    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */
    /* Start :SPR 1020 */
    /* Deleted the code related to FGI bit 9 check for GERAN */
    /* End :SPR 1020 */
    /* Start fix for SPR 7015 */
    /* End fix for SPR 7015 */

    rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;

    p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    RRM_UT_TRACE_ENTER();


    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */

    p_freq_priority = rrm_cellm_get_freq_priority_params(cell_index);
    if(p_freq_priority == RRM_PNULL)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "failed frequency priority params");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                "Successfully received frequency priority params ");
        rrm_uem_sort_freq_priority_list(p_freq_priority);
    }


    /* SPR 21089 Fix Start */
    /* Code Deleted */
    /* SPR 21089 Fix End */
    if(RRM_SUCCESS == rrm_get_idle_mode_ue_connection_release_ind_param_for_eutran
            (
             p_ue_connection_release_ind,
             p_ue_context,
         /*SPR 17777 +-*/
             p_freq_priority,
             p_cell_ctx
            ))
    {
        RRM_UT_TRACE_EXIT();
        return RRM_SUCCESS;
    }
    /*Klocwork activity 1-Apr_2014 end*/
    /*Klocwork activity 1-Apr_2014 start*/
    if(RRM_SUCCESS ==  rrm_get_idle_mode_ue_connection_release_ind_param_for_utran
            (
             p_ue_connection_release_ind,
             p_ue_context,
         /*SPR 17777 +-*/
             p_freq_priority,
	     /*SPR 17850 +-*/
             p_cell_ctx
            ))
    {
        RRM_UT_TRACE_EXIT();
        return RRM_SUCCESS;
    }
    /*Klocwork activity 1-Apr_2014 end*/

    /*SPR 5863*/
    /*SPR 5863 or condition is added for CCO.If RWR is triggered for CCO it will contain
      idle mode mobility params for geran.Bit 9 is not needed to be checked in this case
      as redirected carrier freq for geran will be present in case of geran only*/

    /*Klocwork activity 1-Apr_2014 start*/
    if(RRM_SUCCESS ==  rrm_get_idle_mode_ue_connection_release_ind_param_for_geran
            (
             p_ue_connection_release_ind,
             p_ue_context,
         /*SPR 17777 +-*/
             p_freq_priority
            ))
    {
        RRM_UT_TRACE_EXIT();
        return RRM_SUCCESS;
    }
    /*Klocwork activity 1-Apr_2014 end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 21426 +- */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_inactive_ues_ind
 *   INPUT      : p_api_buf,api_id,data_len,new_trans_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the INACTIVE UES IND
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
 rrm_return_et
rrm_ue_rrc_parse_inactive_ues_ind(U8 *p_api_buf,
         /*SPR 17777 +-*/
                                  U16 data_len,
                                  rrm_ue_global_context_t *p_rrm_glb_ctxt)
{
    rrm_return_et               return_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_inactive_ues_ind_t rrc_rrm_inactive_ues_ind = {RRM_NULL};
    rrm_cell_index_t             cell_index = RRM_ZERO; /* temporary assignment */
    U32 loop = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Parsing the UE Inactive Ind  received from RRC */
    if (RRM_SUCCESS != rrm_il_parse_rrc_rrm_inactive_ues_ind(
                            &rrc_rrm_inactive_ues_ind,
                            p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                            data_len,
                            &length_read))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_INACTIVE_UES_IND parsing failed");
        return_val = RRM_FAILURE;
    }
    else
    {
        /*BUG 585, Multisector change start*/
        cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_INDEX(cell_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_INACTIVE_UES_IND successfully parsed");
        
        /*BUG 585, Multisector change end*/
        /* Checking for cell state */
        /*KLOC FIX */
        /* SPR 21446 start */
        /* Code removed */
        /* SPR 21446 end */
        for(loop=RRM_ZERO; loop<rrc_rrm_inactive_ues_ind.num_of_inactive_ue; loop++)
        {
            /*SPR 11535:start*/
            return_val = rrm_handle_ue_inactive(rrc_rrm_inactive_ues_ind.inactive_ue_info[loop].ue_index,
                    cell_index, p_rrm_glb_ctxt);
            /*SPR 11535:end*/
        }
    }
    RRM_UT_TRACE_EXIT();
    return return_val;
}

/* SPR_15310_fix: start */
/******************************************************************************
 *  FUNCTION NAME: rrm_check_qci_support_for_lossless_ho
 *  INPUT      : qci, p_ue_context
 *  OUTPUT     : NONE
 *  DESCRIPTION: Checks if the QCI supports Lossless HO or not.
 *  RETURNS:
 *  RRM_SUCCESS  on Success
 *  RRM_FAILURE  on Failure
 *******************************************************************************/
rrm_bool_et
rrm_check_qci_support_for_lossless_ho(
        U8                  qci,
        rrm_ue_context_t    *p_ue_context
        )
{
    rrm_bool_et  ret_val = RRM_FALSE;
    U8           qos_count = RRM_ZERO;
    epc_params_t *p_epc_params = RRM_PNULL;
    p_epc_params = rrm_cellm_get_erb_service_profile(p_ue_context->cell_index);

    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_epc_params)
    {
        for(qos_count = RRM_ZERO ;
                (qos_count < p_epc_params->num_valid_qos_profiles) && (qos_count < RRM_MAX_QCI); qos_count++)
        {
            if(qci == p_epc_params->qos_config_params[qos_count].qci)
            {
                if(RRMCM_RMIF_LOSSLESS_HO_REQ_PRESNET &
                        p_epc_params->qos_config_params[qos_count].bitmask )
                {
                    /* UL tunnel should be added if LOSSLESS HO and PSR reporting enabled i.e., optimized lossless HO */
                    if(RRM_TRUE ==
                            p_epc_params->qos_config_params[qos_count].lossless_ho_required)
                    {
                        if((p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                    pdcp_config.bitmask & RRC_PDCP_CONFIG_RLC_AM_ENB_STATUS_REPORT_REQ_ERB_SERVICE_PROFILE_PRESENT) &&
                                (p_epc_params->qos_config_params[qos_count].erb_service_profile.
                                 pdcp_config.rlc_am_enb_status_report_required == RRM_ONE))
                        {
                            ret_val = RRM_TRUE;
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Cell support Lossless HO for QCI[%d] when PSR and LOSSLESS HO is enabled", qci);
                        }
                    }
                }
                break;
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "epc params NULL!");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR_15310_fix: end */

/******************************************************************************
 *   FUNCTION NAME: fill_ho_adm_resp_drb_sub_fwd_list
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_drb_sub_to_fwd_list
 *   DESCRIPTION:
 *       Fills the rrm_drb_sub_to_fwd_list_t
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 *******************************************************************************/

rrm_return_et
fill_ho_adm_resp_drb_sub_fwd_list(
        rrm_drb_sub_to_fwd_list_t *p_rrm_drb_sub_to_fwd_list,
        rrm_ue_context_t                  *p_rrm_ue_context
)
{
   rrm_return_et                       ret_val = RRM_SUCCESS;
    U16                                 drb_count = RRM_ZERO;
    /* Fix start 8257 */
    U16                                 drb_sub_to_fwd_count = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t       *p_successful_erbs = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);
/*SPR 5589 Fix START */
    p_rrm_drb_sub_to_fwd_list->count = RRM_ZERO;
    for (drb_count = RRM_ZERO ; (drb_count < p_successful_erbs->num_of_list) 
            /* Coverity 19oct Start : 54992 */
            && (drb_count < RRM_MAX_NUM_DRB_PER_UE);
            /* Coverity 19oct End : 54992 */
            drb_count++)
    {
        /* SPR_15310_fix: start */
        /* Check if Source proposed DL Forwarding */
        /*SPR_17817_Fix_Start*/
        if( (RRM_TRUE == p_successful_erbs->erab_item[drb_count].dl_fwding) &&
                (RRM_FALSE != p_successful_erbs->erab_item[drb_count].data_fwding_not_possible)  ) /*SPR_17817_Fix_End */
        {
            /* Get the Transfer Mode of the Erab ID received from Source is UM Mode. */
            if(UM_MODE == p_successful_erbs->erab_item[drb_count].data_transfer_mode)
            {
                p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].erab_id =
                    p_successful_erbs->erab_item[drb_count].erab_id;
                /* RLC UM bearers only support seamless data forwarding  i.e. only packets not already transmitted over
                 * the air (UL/_DL) can be transmitted once the UE arrives at the target. Due to this it makes sense that
                 * we have DL data forwarding but makes no UL data forwarding. (refer to 36.300 sections 10.1.2.3.1 & 10.1.2.3.2) */
                p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].forward_direction = UECC_FORWARDING_DIRECTION_DL;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Erab ID [ %d ] is UM mode & will support UECC_FORWARDING_DIRECTION_DL.",
                        p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].erab_id);
                drb_sub_to_fwd_count++;
            }
            /* Get the Transfer Mode of the Erab ID received from Source is AM Mode. */
            else if(AM_MODE == p_successful_erbs->erab_item[drb_count].data_transfer_mode)
            {
                p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].erab_id =
                    p_successful_erbs->erab_item[drb_count].erab_id;
                /* Check if QCI supports the lossless HO */
                if(RRM_TRUE == rrm_check_qci_support_for_lossless_ho(
                            p_successful_erbs->erab_item[drb_count].erab_level_qos_params.qci,p_rrm_ue_context))
                {
                    /* UL data forwarding is used to support optimised lossless data forwarding and can only be used for RLC AM if
                     * eNB supports Lossless HO for the QCI admitted over HO */
            p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].forward_direction = UECC_FORWARDING_DIRECTION_BOTH;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Erab ID [ %d ] is AM mode & will support UECC_FORWARDING_DIRECTION_BOTH.",
                            p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].erab_id);
                }
                else
                {
                    p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].forward_direction = UECC_FORWARDING_DIRECTION_DL;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Erab ID [ %d ] is AM mode & will support UECC_FORWARDING_DIRECTION_DL.",
                            p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[drb_sub_to_fwd_count].erab_id);
                }
                drb_sub_to_fwd_count++;
            }
            /* SPR_15310_fix: end */
        }
    }
    p_rrm_drb_sub_to_fwd_list->count = drb_sub_to_fwd_count;
    /* Fix end 8257 */
/*SPR 5589 Fix END */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klocwork activity 1-Apr_2014 start*/

/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: fill_ho_adm_resp_radio_resource_config_for_drx
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_ho_adm_resp_radio_res_config
 *   DESCRIPTION:
 *       Fills the rrm_ho_adm_resp_radio_res_config_t
 *
 ******************************************************************************/
void
rrm_fill_qci_val_for_drx(rrm_cell_context_t             *p_cell_context,
                         rrm_ue_context_t               *p_rrm_ue_context,
                         rrm_ue_erab_setup_item_list_t  *p_successful_erbs,                         
                         radio_resource_config_t        *p_rrm_ho_adm_resp_radio_res_config , 
                         epc_params_t                   *p_epc_params)
{
    U8                               qci_val = RRM_ZERO;
    U8                               index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* SPR_13793_start */
    if(RRM_REL8 == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.access_stratum_release)
    {
        if ( (RRM_FALSE != p_cell_context->sps_on) &&
                /*Start:Bug 762*/
                (RRM_TRUE  == rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_THREE)) && 
                (RRM_TRUE  == rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_SEVEN)))
            /*End:Bug 762*/
        {
            for (index = RRM_ZERO; (index < p_successful_erbs->num_of_list)
                    /* Coverity 21oct Start : 55005 */
                    && (index < RRM_MAX_NUM_DRB_PER_UE); index++)
                /* Coverity 21oct End : 55005 */
            {
                if ( (p_rrm_ue_context->ue_sps_data.sps_erab_id) ==
                        (p_successful_erbs->erab_item[index].erab_id) )   
                    /* Check whether the requested RAB is the one decided for SPS */
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SPS configuration being sent for erab_id[%d] of [UE:%d]",
                            p_successful_erbs->erab_item[index].erab_id,  p_rrm_ue_context->ue_index);

                    qci_val = p_successful_erbs->erab_item[index].erab_level_qos_params.qci;

                    /* SPR 8978 : code removed */
                    p_rrm_ho_adm_resp_radio_res_config->bitmask |=
                        RADIO_RESOURCE_CONFIG_SPS_CONFIG_PRESENT;

                    fill_sps_config(&(p_rrm_ho_adm_resp_radio_res_config->rrc_sps_config),
                            p_epc_params, qci_val, p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch, 
                            p_rrm_ue_context);
                }
            }
        }
    }
    else
    {
        /* SPR_13793_end */
        if ( (RRM_FALSE != p_cell_context->sps_on) &&
                /*Start:Bug 762*/
                (RRM_TRUE  == rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_TWENTY_NINE)) && 
                (RRM_TRUE  == rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_SEVEN)))
            /*End:Bug 762*/
        {
            for (index = RRM_ZERO; (index < p_successful_erbs->num_of_list)
                    /* Coverity 21oct Start : 55005 */
                    && (index < RRM_MAX_NUM_DRB_PER_UE); index++)
                /* Coverity 21oct End : 55005 */
            {
                if ( (p_rrm_ue_context->ue_sps_data.sps_erab_id) ==
                        (p_successful_erbs->erab_item[index].erab_id) )   
                    /* Check whether the requested RAB is the one decided for SPS */
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SPS configuration being sent for erab_id[%d] of [UE:%d]",
                            p_successful_erbs->erab_item[index].erab_id,  p_rrm_ue_context->ue_index);

                    qci_val = p_successful_erbs->erab_item[index].erab_level_qos_params.qci;

                    /* SPR 8978 : code removed */
                    p_rrm_ho_adm_resp_radio_res_config->bitmask |=
                        RADIO_RESOURCE_CONFIG_SPS_CONFIG_PRESENT;

                    fill_sps_config(&(p_rrm_ho_adm_resp_radio_res_config->rrc_sps_config),
                            p_epc_params, qci_val, p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch, 
                            p_rrm_ue_context);
                }
            }
        }
        /* SPR_13793_start */
    }
    /* SPR_13793_end */
   RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/******************************************************************************
 *   FUNCTION NAME: fill_ho_adm_resp_radio_resource_config_for_drx
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_ho_adm_resp_radio_res_config
 *   DESCRIPTION:
 *       Fills the rrm_ho_adm_resp_radio_res_config_t
 *
 ******************************************************************************/
void
fill_ho_adm_resp_radio_resource_config_for_drx
(
 radio_resource_config_t *p_rrm_ho_adm_resp_radio_res_config,
 rrm_ue_context_t                  *p_rrm_ue_context,
 epc_params_t                    *p_epc_params,
 mac_layer_params_t              *p_mac_layer_params,
 S32                            *applicable_drx_index,
 rrm_ue_erab_setup_item_list_t   *p_successful_erbs,
 rrm_cell_context_t               *p_cell_context
 )
{
    RRM_UT_TRACE_ENTER();

    /**CLPC_MR_START*/
    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator present, "
                "checking for bit5"
                ,p_rrm_ue_context->ue_index);
        /*Check for fgi bit5 if fgi present*/
#ifndef LTE_EMBMS_SUPPORTED
        if((p_mac_layer_params != RRM_PNULL) 
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE) &&
                /*Start:Bug 762*/
                ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE))
            /*End:Bug 762*/
#else
        if(((p_mac_layer_params != RRM_PNULL) 
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE) &&
                ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FIVE)) == RRM_TRUE)) &&
            ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
        {
            *applicable_drx_index = 
/* SPR 10450 Fix Start */
               rrm_find_drx_profile_to_send(p_rrm_ue_context);
/* SPR 10450 Fix End */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d], drx is disabled from oam or BIT 5 IS OFF"
                    ,p_rrm_ue_context->ue_index);
        }
        /* SPS related changes start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Checking for sps provision of [UE:%d]",
                p_rrm_ue_context->ue_index);

        /*Klockwork_fix_start*/
        rrm_fill_qci_val_for_drx(p_cell_context, p_rrm_ue_context,p_successful_erbs, 
                                 p_rrm_ho_adm_resp_radio_res_config , p_epc_params);
        /*Klockwork_fix_end*/
        /* SPS related changes end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] Feature Group Indicator not present, "
                "not checking for bit5"
                ,p_rrm_ue_context->ue_index);
        /*Check for fgi bit5 if fgi present*/
#ifndef LTE_EMBMS_SUPPORTED
        if((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE))
#else
        if(((p_mac_layer_params != RRM_PNULL)
                && (p_mac_layer_params->mac_layer_param_drx.
                    drx_enabled == RRM_TRUE)) &&
            ( RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled ))
#endif
        {
            *applicable_drx_index =
/* SPR 10450 Fix Start */
               rrm_find_drx_profile_to_send(p_rrm_ue_context);
/* SPR 10450 Fix End */
        }
    }
    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/
/******************************************************************************
 *   FUNCTION NAME: fill_ho_adm_resp_radio_resource_config
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : p_rrm_ho_adm_resp_radio_res_config
 *   DESCRIPTION:
 *       Fills the rrm_ho_adm_resp_radio_res_config_t
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
fill_ho_adm_resp_radio_resource_config(
        radio_resource_config_t *p_rrm_ho_adm_resp_radio_res_config,
        rrm_ue_context_t                  *p_rrm_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    epc_params_t                    *p_epc_params = RRM_PNULL;
    rlc_layer_params_t              *p_rlc_layer_params = RRM_PNULL;
    admission_control_info_t        *p_admission_control_info = RRM_PNULL;
    mac_layer_params_t              *p_mac_layer_params = RRM_PNULL;
    S32                             applicable_drx_index = NO_DRX_PROFILE;
    rrm_cell_index_t                cell_index = p_rrm_ue_context->cell_index;
    U8                              ul_mcs = RRM_NULL;
    U8                              dl_mcs = RRM_NULL;
    rrm_ue_erab_failed_item_list_t  *p_failed_erbs = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs = RRM_PNULL;
    rrm_common_params_for_eutra_t   *p_rrm_common_params_for_eutra = RRM_PNULL;
    U16                             tpc_rnti_pucch_old = RRM_NULL;
    U16                             tpc_rnti_pusch_old = RRM_NULL;
    /* SPS related changes start */
    rrm_cell_context_t               *p_cell_context = RRM_PNULL;
    /* SPS related changes end */

    /*TM mode 7-8 start*/
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info=
        rrm_cm_get_mrrm_tm_mode_additional_info(cell_index);
    /*TM mode 7-8 end*/
    RRM_UT_TRACE_ENTER();

    p_rrm_common_params_for_eutra =
        rrm_cellm_get_connected_mode_common_params(cell_index);
    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    p_mac_layer_params = rrm_cellm_mac_layer_params(cell_index);
    /* Coverity 19oct Start : 54988 */
    RRM_ASSERT(RRM_PNULL != p_mac_layer_params);
    /* Coverity 19oct End : 54988 */
    p_epc_params = rrm_cellm_get_erb_service_profile(cell_index);
    p_rlc_layer_params = rrm_cellm_get_srb_info(cell_index);
    p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);

    if(p_rlc_layer_params != RRM_PNULL)
    {
        /* Start CSR 00059256 */
        if (p_rlc_layer_params->num_valid_srb_info != RRM_ZERO)
        {
            rrm_rrc_ue_adm_resp_fill_srb1_info
                (&(p_rrm_ho_adm_resp_radio_res_config->srb_info),p_rlc_layer_params,
                 p_rrm_ue_context);
        }
        if(p_rlc_layer_params->num_valid_srb_info == RRM_TWO)
        {
            fill_erb_setup_resp_srb2_info
                (&(p_rrm_ho_adm_resp_radio_res_config->srb_info),p_rlc_layer_params,
                 p_rrm_ue_context);
        }
        /* End CSR 00059256 */
    }

    if(p_epc_params != RRM_PNULL && p_successful_erbs->num_of_list > RRM_ZERO)
    {
        fill_erb_setup_modify_resp_drb_to_add_list
            (&(p_rrm_ho_adm_resp_radio_res_config->drb_to_add_list),
             p_rrm_ue_context,p_epc_params);
        p_rrm_ho_adm_resp_radio_res_config->bitmask |=
             RADIO_RESOURCE_CONFIG_DRB_SUB_FWR_LIST_PRESENT;
        fill_ho_adm_resp_drb_sub_fwd_list
           (&(p_rrm_ho_adm_resp_radio_res_config->drb_sub_to_fwd_list),
            p_rrm_ue_context);
    }
    /* SPR 19078: CID 61089 Fix Start */
    else if(p_epc_params == RRM_PNULL)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_epc_params is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* SPR 19078: CID 61089 Fix End */

    /*DRX parameters will be given if bit 5 of
      feature group indicator is set as one*/

    /* SPS related changes start */
    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65806:start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65806:end*/

    // SPS configuration will be sent if the 29th bit of FGI is set to 1
    /* SPS related changes end */


    /**CLPC_MR_START*/
    /*Klocwork activity 1-Apr_2014 start*/
    fill_ho_adm_resp_radio_resource_config_for_drx
        (
         p_rrm_ho_adm_resp_radio_res_config,
         p_rrm_ue_context,
         p_epc_params,
         p_mac_layer_params,
         &applicable_drx_index,
         p_successful_erbs,
         p_cell_context
        );
    /*Klocwork activity 1-Apr_2014 end*/
    tpc_rnti_pucch_old = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch;
    tpc_rnti_pusch_old = p_rrm_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch;

    /* SPR:757- Coverity fix start */
    if(p_mac_layer_params != RRM_PNULL)
    {
    rrm_allocate_tpc_rnti_pucch(applicable_drx_index,
            p_rrm_ue_context,p_mac_layer_params);

    rrm_allocate_tpc_rnti_pusch(applicable_drx_index,
            p_rrm_ue_context,p_mac_layer_params);
    }
    /* SPR:757- Coverity fix end */
    
    /* SPR 16775 start */
    /* Code deleted */
    /* SPR 16775 end */
    /**CLPC_MR_START*/
    /*spr_22524_changes_start*/
    /*code deleted*/
    /*spr_22524_changes_end*/
    /* SPR 16775 start */
    if(p_admission_control_info != RRM_PNULL)
    {
         fill_erb_setup_resp_physical_config_dedicated
            (&(p_rrm_ho_adm_resp_radio_res_config->physical_config_dedicated),
             p_admission_control_info,&ul_mcs,
             &dl_mcs,p_rrm_ue_context,
             /*spr_19392_changes_start*/
             tpc_rnti_pucch_old,tpc_rnti_pusch_old, ERAB_HO_ADM);
             /*spr_19392_changes_end*/
	/* Bug 3961 Fix Start */
        if ((RRM_TRUE == rrm_is_set_fgi_bit(p_rrm_ue_context, RRM_HUNDRED_FIFTEEN)) && (RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release))
	    {
	 	if((RRM_TRUE == rrm_cellm_is_victim_node(p_cell_context)) && (RRM_FALSE == rrm_check_absPattern_is_null(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset)))
  		{
			
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                   		"rrc_meas_subframe_pattern_pcell_r10 bitmask is set to MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT  ");
			p_rrm_ho_adm_resp_radio_res_config->bitmask |= RRM_UE_CONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT;
      			p_rrm_ho_adm_resp_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.bitmask |= MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT; 
      			p_rrm_ho_adm_resp_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.bitmask |= RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;
      			RRM_MEMCPY(p_rrm_ho_adm_resp_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                	    	subframe_pattern_fdd_r10.data,p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset, MAX_SUBFRAME_PATTERN_FDD);
  		}
		else
		{
                        if(RRM_FALSE != p_rrm_ue_context->is_csi_pattern_to_release) 
           		{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                   			"rrc_meas_subframe_pattern_pcell_r10 bitmask is set to MEAS_SUBFRAME_PATTERN_PCELL_R10_RELEASE_PRESENT  ");
          
	  			p_rrm_ho_adm_resp_radio_res_config->bitmask |= RRM_UE_CONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT;
	  			p_rrm_ho_adm_resp_radio_res_config->rrc_meas_subframe_pattern_pcell_r10.bitmask |=  MEAS_SUBFRAME_PATTERN_PCELL_R10_RELEASE_PRESENT;
			}
		}
    	}
	/* Bug 3961 Fix End */
    }
    /* SPR 16775 end */

/*spr_22524_changes_start*/
    if(p_mac_layer_params != RRM_PNULL)
    {
         p_rrm_ho_adm_resp_radio_res_config->bitmask |=
              RRM_ERAB_SETUP_RADIO_RES_CONFIG_MAC_CONFIG_PRESENT;
        fill_erb_setup_resp_mac_config
            (&(p_rrm_ho_adm_resp_radio_res_config->mac_config),
             p_mac_layer_params,p_rrm_ue_context,
             ul_mcs,dl_mcs,applicable_drx_index);
        /*TM mode 7-8 start*/
        if(p_rrm_ho_adm_resp_radio_res_config->physical_config_dedicated.
                antenna_information.bitmask & RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT)
        {
            if(TRANSMISSION_MODE_TM7 == p_rrm_ho_adm_resp_radio_res_config->physical_config_dedicated.
                    antenna_information.antenna_information_explicit_value.transmission_mode)
            {
                p_rrm_ho_adm_resp_radio_res_config->mac_config.
                    mac_main_config_extensions.bitmask |= RRM_MAC_MAIN_CONFIG_EXT_PDSCH_EPRE_TO_UE_RS_RATIO_PRESENT;
                p_rrm_ho_adm_resp_radio_res_config->mac_config.mac_main_config_extensions.pdsch_epre_to_ue_rs_ratio
                    = p_rrm_tm_mode_additional_info->pdsch_epre_to_ue_rs_ratio;
            }
        }
        /*TM mode 7-8 end*/
    }
/*spr_22524_changes_end*/

    p_failed_erbs  = (rrm_ue_erab_failed_item_list_t*)
        (p_rrm_ue_context->current_procedure.p_erb_failed_list);
    /* Start fix for SPR 6513 */
    if((p_failed_erbs != RRM_PNULL) && (p_failed_erbs->num_of_list > RRM_ZERO))
    /* End fix for SPR 6513 */
    {
        p_rrm_ho_adm_resp_radio_res_config->bitmask |=
            RADIO_RESOURCE_CONFIG_DRB_FAIL_TO_ADD_LIST_PRESENT;
        fill_erb_setup_resp_drb_failed_to_add_list
            (&(p_rrm_ho_adm_resp_radio_res_config->drb_failed_to_add_list),
             p_failed_erbs);
    }
    /* MC,MR & HO START*/
    if ( p_rrm_common_params_for_eutra !=RRM_PNULL)
    {
          p_rrm_ho_adm_resp_radio_res_config->bitmask |=
                          RADIO_RESOURCE_CONFIG_MEAS_CONFIG_PRESENT;
          rrm_ue_fill_meas_config_req_for_ho(&(p_rrm_ho_adm_resp_radio_res_config->
                               meas_config),p_rrm_ue_context);

         /* CSR 00055769  : inter-freq HO code changes start */
         rrm_ue_fill_meas_remove_list_from_ho_adm_req(&(p_rrm_ho_adm_resp_radio_res_config->
                                meas_config),p_rrm_ue_context);
          /* CSR 00055769  : inter-freq HO code changes end */
    }
    /* MC,MR & HO End*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rbc_fill_ho_adm_resp
 *   INPUT      : p_rrm_ue_context,p_ho_adm_resp
 *   OUTPUT     : response
 *   DESCRIPTION:
 *       Fills the erab setup response
 *
 *   RETURNS:
 *       RRM_SUCCESS  on Success
 *       RRM_FAILURE  on Failure
 ******************************************************************************/

rrm_return_et
    rrm_ue_rbc_fill_ho_adm_resp(
        rrm_ue_context_t              *p_rrm_ue_context,
        rrc_rrm_ue_ho_adm_resp_t       *p_ho_adm_resp,
        rrm_response_t              response)
{
    rrm_return_et            ret_val = RRM_SUCCESS;
    rrc_timers_t             *p_rrc_timers;
    rrm_cell_index_t         cell_index = p_rrm_ue_context->cell_index;
    admission_control_info_t        *p_admission_control_info = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);
    if(response.response != RRM_UE_FAILURE)
    {
        p_rrc_timers = rrm_cellm_get_timer_info(cell_index);
        /* SPR 13045 start */
        p_ho_adm_resp->bitmask |=
            RRC_RRM_UE_HO_ADM_RESP_RADIO_REOURCE_CONFIG_PRESENT;
        /* SPR 13045 end */
        fill_ho_adm_resp_radio_resource_config
            (&(p_ho_adm_resp->radio_resource_config),p_rrm_ue_context);
        /*SPR_19066_START*/
        if( RRM_SUCCESS != (rrm_fill_ue_inactivity(&p_ho_adm_resp->ue_inactive_time_config, p_rrm_ue_context)))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "RRM Fill Ue Inactivity error");
        }
        /*SPR_19066_END*/
        p_ho_adm_resp->bitmask |=
            RRC_RRM_UE_HO_ADM_RESP_MOBILITY_CONTROL_INFO_PRESENT;
        p_ho_adm_resp->mobility_control_info.t304_timer = p_rrc_timers->t304_eutra;
        /*csg start*/
        /*start fill report_proximity_config*/
        if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
        {
            /*SPR 22842 FIXED START*/
            if(p_admission_control_info != RRM_PNULL)
            {   

                if((p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)&& 
                        (p_admission_control_info->bitmask & RRMCM_RMIF_PROXIMITY_IND_STATUS_PRESENT)&&
                        (p_admission_control_info->proximity_indication_status ==  RRM_TRUE))

                {

                    if(RRM_SUCCESS == rrm_ue_fill_eutra_capability_v920_ies(
                                &(p_ho_adm_resp->proximity_config),
                                &(p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info)))
                    {

                        p_ho_adm_resp->bitmask |= RRC_RRM_UE_HO_ADM_RESP_CONFIG_PROXIMITY_PRESENT;

                    }

                }

            }
            /*SPR 22842 FIXED END*/


        }
        /*end fill report_proximity_config*/
        /*csg start*/

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Bug_11947_fix: Start */
/******************************************************************************
*   FUNCTION NAME: rrm_ue_calc_total_gbr_bit_rate_from_ho_adm
*   INPUT      : *p_rrm_ue_proc_ho_adm_data, *p_ul_total_gbr_ue, *p_dl_total_gbr_ue
*   OUTPUT     : NONE
*   DESCRIPTION: Calculate GBR bitrate of GBRs received in HO ADM REQ.
*
*   RETURNS: rrm_void_t
******************************************************************************/
void
rrm_ue_calc_total_gbr_bit_rate_from_ho_adm(
 rrm_ue_proc_ho_adm_data_t *p_rrm_ue_proc_ho_adm_data,
 U64                        *p_ul_total_gbr_ue,
 U64                        *p_dl_total_gbr_ue
)
{
    U16         drb_configured_index = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    for(drb_configured_index = RRM_NULL;
            drb_configured_index<p_rrm_ue_proc_ho_adm_data->erab_setup_list.num_of_list;
            drb_configured_index++)
    {
        if((p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[drb_configured_index].erab_level_qos_params.qci >= RRM_ONE) &&
                (p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[drb_configured_index].erab_level_qos_params.qci <= RRM_FOUR))
        {
            (*p_dl_total_gbr_ue) += p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[drb_configured_index].
                                     erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;

            (*p_ul_total_gbr_ue) += p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[drb_configured_index].
                                                 erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;
        }
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_init_bitmask_for_cell_addition
 *   INPUT      : ca_param_bitmask
 *   OUTPUT     :
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_void_t
rrm_fill_init_bitmask_for_scell_add_in_intra_cell_ho(U64 *p_ca_param_bitmask)
{
    RRM_UT_TRACE_ENTER();
    *p_ca_param_bitmask = (
            /* Bug_12781_fix: Start */
            RRM_SCELL_ADD_MOD_SCELL_IDX_AND_ID |
            /* Bug_12781_fix: End */
            RRM_SCELL_ADD_MOD_MAC_MAIN_CONFIG_EXT_SCELL |
            RRM_MAC_MAIN_CONFIG_EXT_DL_NUM_HARQ_PROCESS |
            RRM_MAC_MAIN_CONFIG_EXT_DL_I_MCS |
            RRM_MAC_MAIN_CONFIG_EXT_NUM_OF_LAYER |
            RRM_MAC_MAIN_CONFIG_EXT_CODE_BOOK_INDEX |
            RRM_MAC_MAIN_CONFIG_EXT_SCELL_ACTIVATE_STATUS );
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
*   FUNCTION NAME: rrm_fill_scell_add_mod_list_for_intra_cell_ho 
*   INPUT      : p_rrm_ue_cntxt, p_rrm_ue_proc_ho_adm_data, p_rrc_rrm_ho_adm_resp 
*   OUTPUT     : NONE
*   DESCRIPTION: Calculate GBR bitrate of GBRs received in HO ADM REQ.
*
*   RETURNS: rrm_return_et
******************************************************************************/
rrm_return_et
rrm_fill_scell_add_mod_list_for_intra_cell_ho(
        rrm_ue_context_t          *p_rrm_ue_cntxt,
        rrm_ue_proc_ho_adm_data_t *p_rrm_ue_proc_ho_adm_data,
        rrc_rrm_ue_ho_adm_resp_t  *p_rrc_rrm_ho_adm_resp
)
{
    rrm_return_et         ret_val = RRM_SUCCESS;
    U8                    index = RRM_ZERO;
    U8                    ncl_index = RRM_ZERO;
    lte_ncl_t            *p_ncl_params = RRM_PNULL;
    rrm_cell_index_t      p_arr_cell_index[RRM_MAX_SCELL];
    U8                    num_of_scell = RRM_ZERO;
    U64                   ca_param_bitmask = RRM_ZERO;
    rrm_cell_context_t    *p_cell_ctxt = RRM_PNULL;
    U8                    scell_deact_timer = RRM_SCELL_RFINFINITY;

    RRM_UT_TRACE_ENTER();

    if(p_rrm_ue_cntxt == RRM_PNULL)
    {

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE Context Invalid or NULL!!");
         ret_val = RRM_FAILURE;
    }
    else  /* valid ue_context received */
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_cntxt->cell_index);
        /*CID 65807:start*/
        if (RRM_PNULL == p_cell_ctxt )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /*CID 65807:end*/

        /* coverity_fix_64363: Start */
        RRM_MEMSET(p_arr_cell_index, RRM_OUT_OF_RANGE, (sizeof(rrm_cell_index_t)*RRM_MAX_SCELL));
        /* coverity_fix_64363: End */

        /* Get NCL of current cell & from PCI get cell_id & from cell_id get cell index of the cell */
        p_ncl_params = rrm_cellm_get_ncl_params(p_cell_ctxt->cell_index);

        /* coverity_fix_64362: Start */
        if( p_ncl_params == RRM_PNULL )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "NCL empty!! Cell Index: [%d]", p_cell_ctxt->cell_index);
            ret_val = RRM_FAILURE;
        }
        else   /* lte_ncl not valid in cell context */
        {
            for(index = RRM_ZERO; index < p_rrm_ue_proc_ho_adm_data->scell_add_mod_list.count; index++)
            {
                for(ncl_index = RRM_ZERO; ncl_index < p_ncl_params->num_valid_inter_freq_cell; ncl_index++)
                {
                    if((p_rrm_ue_proc_ho_adm_data->scell_add_mod_list.rrm_scell_to_add_mod[index].scell_id.phy_cell_id == 
                                p_ncl_params->inter_freq_cells[ncl_index].phy_cell_id) &&
                            (p_rrm_ue_proc_ho_adm_data->scell_add_mod_list.rrm_scell_to_add_mod[index].scell_id.dl_carrier_freq ==
                             p_ncl_params->inter_freq_cells[ncl_index].eutra_carrier_arfcn))
                    {
                        rrm_get_cell_index_from_ncl_pci(num_of_scell, 
                                p_arr_cell_index, 
                                p_ncl_params->inter_freq_cells[ncl_index].cell_id);
                        num_of_scell++;
                    }
                }
            }

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Total number of Scell candidates to be added: %d", num_of_scell);

            for(index = RRM_ZERO; index < num_of_scell; index++)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Cell Index of the Scell to be added: %d", p_arr_cell_index[index]);
            }

            /* Fill required params in ho adm resp */
            /* Fill Scell related MAC params only */
            if (num_of_scell > RRM_ZERO)
            {
                /* Fill bitmask for params to be filled in Intra Cell HO */
                rrm_fill_init_bitmask_for_scell_add_in_intra_cell_ho(&ca_param_bitmask);

                if (RRM_SUCCESS == fill_scell_config_params_in_ue_reconfig(p_rrm_ue_cntxt,
                            num_of_scell,
                            p_arr_cell_index,
                            &(p_rrc_rrm_ho_adm_resp->scell_config),
                            ca_param_bitmask))
                {
                    p_rrc_rrm_ho_adm_resp->scell_config.scell_add_mod_list.count = num_of_scell;
                    p_rrc_rrm_ho_adm_resp->bitmask |= RRC_RRM_UE_HO_ADM_RESP_CONFIG_SCELL_PRESENT;

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SCell addition in Intra Cell HO successful. No. of Scells added = [%d]", 
                            p_rrc_rrm_ho_adm_resp->scell_config.scell_add_mod_list.count);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "SCell addition in Intra Cell HO failed!");
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
            }
            /* Fill Scell Deactivation Timer in radio resource MAC Main Config */
            p_rrc_rrm_ho_adm_resp->radio_resource_config.mac_config.
                mac_main_config.bitmask |= RRC_MAC_MAIN_CONFIG_V1020_PRESENT;

            p_rrc_rrm_ho_adm_resp->radio_resource_config.mac_config.
                mac_main_config.mac_main_config_v1020.bitmask |= 
                RRC_MAC_MAIN_CONFIG_V1020_SCELL_DEACTIVATION_TIMER_PRESENT;

            if((p_cell_ctxt->operator_info.bitmask & RRMCM_RMIF_CA_CONFIG_INFO_PRESENT) &&
                    p_cell_ctxt->operator_info.ca_config.bitmask & RRM_SCELL_DEACTIVATION_TIMER_PRESENT)
            {
                rrm_get_scell_deact_timer_for_rrc(p_cell_ctxt->operator_info.ca_config.scell_deactivation_timer, 
                        &scell_deact_timer);
                p_rrc_rrm_ho_adm_resp->radio_resource_config.mac_config.mac_main_config.mac_main_config_v1020.
                    scell_deactivation_timer = scell_deact_timer;
            }
            /* Bug_12882_fix: Start */
            rrm_fill_ca_lc_bandwidth_for_scell(p_rrm_ue_cntxt,&(p_rrc_rrm_ho_adm_resp->scell_config));
            /* Bug_12882_fix: End */
        }
        /* coverity_fix_64362: End */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
*   FUNCTION NAME: rrm_fill_scell_add_mod_list_in_ho_adm_resp
*   INPUT      : *p_rrm_ue_cntxt, *p_rrm_ue_proc_ho_adm_data, *p_rrc_rrm_ho_adm_resp
*   OUTPUT     : NONE
*   DESCRIPTION: 
*
*   RETURNS: rrm_void_t
******************************************************************************/
rrm_return_et
rrm_fill_scell_add_mod_list_in_ho_adm_resp(
        rrm_ue_context_t          *p_rrm_ue_cntxt,
        rrm_ue_proc_ho_adm_data_t *p_rrm_ue_proc_ho_adm_data,
        rrc_rrm_ue_ho_adm_resp_t  *p_rrc_rrm_ho_adm_resp
)
{

    rrm_return_et         ret_val = RRM_SUCCESS;
    U64                   ul_total_gbr_ue  = RRM_ZERO;
    U64                   dl_total_gbr_ue  = RRM_ZERO;
    U64                   ca_param_bitmask = RRM_ZERO;
    U8                    index = RRM_ZERO;
    U8                    ncl_index = RRM_ZERO;
    lte_ncl_t            *p_ncl_params = RRM_PNULL;
    rrm_cell_index_t      p_arr_cell_index[RRM_MAX_SCELL];
    U8                    num_of_scell = RRM_ZERO;
    rrm_cell_context_t    *p_cell_ctxt = RRM_PNULL;
    U8                    scell_deact_timer = RRM_SCELL_RFINFINITY;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_cntxt->cell_index);
    /*CID 65808:start*/
    if (RRM_PNULL == p_cell_ctxt )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65808:end*/

    RRM_MEMSET(p_arr_cell_index, RRM_OUT_OF_RANGE, (sizeof(rrm_cell_index_t)*RRM_MAX_SCELL));

    /* CA: Stage3 HO code start */
    if((RRM_TRUE == rrm_is_set_fgi_bit (p_rrm_ue_cntxt, RRM_HUNDRED_TWELVE)) &&
            (RRM_SCELL_CANDIDATE_INFO_PRESENT & p_rrm_ue_proc_ho_adm_data->bitmask))
    {
        /* rrm_ue_calculate_total_bit_rate(p_rrm_ue_cntxt,
           &ul_total_gbr_ue,
           &dl_total_gbr_ue);*/

        rrm_ue_calc_total_gbr_bit_rate_from_ho_adm(p_rrm_ue_proc_ho_adm_data,
                &ul_total_gbr_ue,
                &dl_total_gbr_ue);

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "ul_total_gbr_ue: %llu, dl_total_gbr_ue: %llu",
                ul_total_gbr_ue, dl_total_gbr_ue);

        if(dl_total_gbr_ue > p_cell_ctxt->operator_info.ca_config.ca_applicable_bitrate_dl)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "dl_total_gbr_ue: %llu, ca_applicable_bitrate_dl: %llu", dl_total_gbr_ue,
                    p_cell_ctxt->operator_info.ca_config.ca_applicable_bitrate_dl);

            fill_init_bitmask_for_cell_addition(&ca_param_bitmask);

            p_ncl_params = rrm_cellm_get_ncl_params(p_cell_ctxt->cell_index);
            /*klok_fix_start_8606*/
            if( RRM_PNULL != p_ncl_params)
            {
             /*klok_fix_end_8606*/
                for(index = RRM_ZERO; index < p_rrm_ue_proc_ho_adm_data->scell_candidate_count; index++)
                {
                    for(ncl_index = RRM_ZERO; ncl_index < p_ncl_params->num_valid_inter_freq_cell; ncl_index++)
                    {
                        if((p_rrm_ue_proc_ho_adm_data->candidate_scell_info[index].pci == 
                                    p_ncl_params->inter_freq_cells[ncl_index].phy_cell_id) &&
                                (p_rrm_ue_proc_ho_adm_data->candidate_scell_info[index].carrier_freq ==
                                 p_ncl_params->inter_freq_cells[ncl_index].eutra_carrier_arfcn) &&
                                (X2_LOCALLY_CONNECTED_CELL == p_ncl_params->inter_freq_cells[ncl_index].x2_status))
                        {
                            rrm_get_cell_index_from_ncl_pci(num_of_scell, 
                                    p_arr_cell_index, 
                                    p_ncl_params->inter_freq_cells[ncl_index].cell_id);
                            num_of_scell++;
                        }
                    }
                }
            /*klok_fix_start_8606*/
            }
            /*klok_fix_end_8606*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Total number of Scell candidates to be added: %d", num_of_scell);

            for(index = RRM_ZERO; index < num_of_scell; index++)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Cell Index of the Scell to be added: %d", p_arr_cell_index[index]);
            }

            if (num_of_scell > RRM_ZERO)
            {
                if (RRM_SUCCESS == fill_scell_config_params_in_ue_reconfig(p_rrm_ue_cntxt,
                            num_of_scell,
                            p_arr_cell_index,
                            &(p_rrc_rrm_ho_adm_resp->scell_config),
                            ca_param_bitmask))
                {
                    p_rrc_rrm_ho_adm_resp->scell_config.scell_add_mod_list.count = num_of_scell;
                    p_rrc_rrm_ho_adm_resp->bitmask |= RRC_RRM_UE_HO_ADM_RESP_CONFIG_SCELL_PRESENT;

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SCell candidate list addition successful. No. of Scells added = [%d]", 
                            p_rrc_rrm_ho_adm_resp->scell_config.scell_add_mod_list.count);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SCell candidate list addition failed");
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Total GBR bitrate did not exceed OAM-configured bitrate threshold,"
                    "so no need to fill SCell candidate Info List");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "SCell Candidate Info List did not come in HO_ADM_REQ "
                "or FGI bit 112 is not set");
    }
    /* CA: Stage3 HO code end */

    /* Fill Scell Deactivation Timer in radio resource MAC Main Config */
    p_rrc_rrm_ho_adm_resp->radio_resource_config.mac_config.
                                mac_main_config.bitmask |= RRC_MAC_MAIN_CONFIG_V1020_PRESENT;

    p_rrc_rrm_ho_adm_resp->radio_resource_config.mac_config.
                            mac_main_config.mac_main_config_v1020.bitmask |=
                                  RRC_MAC_MAIN_CONFIG_V1020_SCELL_DEACTIVATION_TIMER_PRESENT;

    if((p_cell_ctxt->operator_info.bitmask & RRMCM_RMIF_CA_CONFIG_INFO_PRESENT) &&
            p_cell_ctxt->operator_info.ca_config.bitmask & RRM_SCELL_DEACTIVATION_TIMER_PRESENT)
    {
        rrm_get_scell_deact_timer_for_rrc(p_cell_ctxt->operator_info.ca_config.scell_deactivation_timer,
                &scell_deact_timer);
        p_rrc_rrm_ho_adm_resp->radio_resource_config.mac_config.mac_main_config.mac_main_config_v1020.
                                  scell_deactivation_timer = scell_deact_timer;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Bug_11947_fix: End */

/*klock_works_changes_start*/
/******************************************************************************
*   FUNCTION NAME: rrm_ue_scell_config_fill_ho_adm_resp_for_inter_cell_handover
*   INPUT      : p_rrm_ue_cntxt, p_rrc_rrm_ho_adm_resp,p_scell_add_mod_list,p_cell_ctxt
*   OUTPUT     : p_rrc_rrm_ho_adm_resp
*   DESCRIPTION:
*       Fill UE scell config in HO admission resp
*
*   RETURNS: rrm_void_t
******************************************************************************/
rrm_void_t
rrm_ue_scell_config_fill_ho_adm_resp_for_inter_cell_handover
(
 rrm_cell_context_t          *p_cell_ctxt,
 rrc_rrm_ue_ho_adm_resp_t    *p_rrc_rrm_ho_adm_resp,
 rrm_scell_to_add_mod_list_t *p_scell_add_mod_list,
 rrm_ue_context_t            *p_rrm_ue_cntxt
)
{
    U8 scell_count              = RRM_ZERO;
    U8 scell_release_cnt        = RRM_ZERO;
    U8 mac_instance_id_chk_cnt  = RRM_ZERO;
    U8 count                    = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if (RRM_TRUE == p_cell_ctxt->operator_info.ca_config.is_masa) 
    {
        /*KLOC FIX */
        /*Cov_fix_62190_start*/
        for (scell_count = RRM_ZERO; ((scell_count < p_scell_add_mod_list->count) &&
                    (scell_count < RRM_MAX_SCELL) && (scell_count < MAX_SCELL));
                          scell_count++)
        {
            p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.rrc_scell_to_release[scell_count].\
                scellIndex = p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_index; 
            /* SPR 12797 start */
            scell_release_cnt++;    
            /* SPR 12797 end */
        }
        /*Cov_fix_62190_end*/
    }
    else
    {
        /*Coverity:65489 Start*/
        for (scell_count = RRM_ZERO; ((scell_count < p_scell_add_mod_list->count) &&
                    (scell_count < RRM_MAX_SCELL) && (scell_count < MAX_SCELL ) && (scell_release_cnt < MAX_SCELL)); scell_count++)
        /*Coverity:65489 End*/
        {
            /* Incase of inter cell HO release the cell whose PCI is matched */
            /*KLOC FIX */
            if ((p_cell_ctxt->ran_info.rf_params.rf_configurations.phy_cell_id ==
                        p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_id.phy_cell_id) &&
					(p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn == 
                     p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_id.dl_carrier_freq))
	        {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "Cell index[%d] is"
                        "add in release list because PCI = %d and dl arfcn = %d"
                        "is matched with serving cell",p_rrm_ue_cntxt->cell_index,p_cell_ctxt->ran_info.rf_params.\
					    rf_configurations.phy_cell_id,p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn);
	            p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.rrc_scell_to_release[scell_release_cnt].\
                    scellIndex = p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_index; 
                scell_release_cnt++;    
            }
            else
            {
                /* Klocwork_fix_27_aug */
                for (mac_instance_id_chk_cnt = RRM_ZERO; ((mac_instance_id_chk_cnt < RRM_MAX_NUM_CELLS) && (scell_release_cnt < MAX_SCELL));
                        mac_instance_id_chk_cnt++)
                {
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[mac_instance_id_chk_cnt])
                    {
                        if((p_g_rrm_cell_ctx->p_rrm_cell_ctx[mac_instance_id_chk_cnt]->ran_info.rf_params.
                                    rf_configurations.phy_cell_id == p_scell_add_mod_list->
                                    rrm_scell_to_add_mod[scell_count].scell_id.phy_cell_id) && 
				(p_g_rrm_cell_ctx->p_rrm_cell_ctx[mac_instance_id_chk_cnt]->ran_info.rf_params. \
                                 rf_configurations.dl_earfcn == p_scell_add_mod_list-> \
                                 rrm_scell_to_add_mod[scell_count].scell_id.dl_carrier_freq)
							)
	                    {
                            /*Cov_fix_62190*/
                            if ((p_g_rrm_cell_ctx->p_rrm_cell_ctx[mac_instance_id_chk_cnt]->operator_info.l2_instance !=
                                        p_cell_ctxt->operator_info.l2_instance))
                            {
                                p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.rrc_scell_to_release[scell_release_cnt].\
                                    scellIndex = p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_index; 
                                scell_release_cnt++;    
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, 
                                        "MAC instance of Scell did not match [%d] with MAC Inst[%d] of cell context"
                                        " with Phy cell ID[%d] and dl freq[%d] is not matched",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[mac_instance_id_chk_cnt]->operator_info.l2_instance,
                                        p_cell_ctxt->operator_info.l2_instance,
                                        p_scell_add_mod_list-> rrm_scell_to_add_mod[scell_count].scell_id.phy_cell_id,
                                        p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_id.dl_carrier_freq);
                            }
                            else
                            {
                                /* Storing scell list in UE context */
                                /*SPR 17777 +-*/
                                rrm_store_scell_list_rcv_in_ho_adm_req(p_rrm_ue_cntxt, count, 
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[mac_instance_id_chk_cnt]->cell_index,
                                        p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_index);
                                count++;
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, 
                                    "Phy cell ID[%d] and dl freq[%d] is not matched", p_scell_add_mod_list->
                                    rrm_scell_to_add_mod[scell_count].scell_id.phy_cell_id,
                                    p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_id.dl_carrier_freq);
                            /* SPR 12797 start */
                            p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.rrc_scell_to_release[scell_release_cnt].\
                                scellIndex = p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_index; 
                            scell_release_cnt++;    
                            /* SPR 12797 end */
                        }
                    }
                }
            }
        }
    }
    /* SPR 12797 start */
    if (scell_release_cnt > RRM_ZERO)
    {
        p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.count = scell_release_cnt;
        p_rrc_rrm_ho_adm_resp->bitmask |= RRC_RRM_UE_HO_ADM_RESP_CONFIG_SCELL_PRESENT;
        p_rrc_rrm_ho_adm_resp->scell_config.bitmask |= RRM_SCELL_RELEASE_LIST_PRESENT;
    }
    /* SPR 12797 end */
    RRM_UT_TRACE_EXIT();
}        
/*klock_works_changes_end*/
/* Carrier_Aggregation_Start */
/******************************************************************************
*   FUNCTION NAME: rrm_ue_scell_config_fill_ho_adm_resp
*   INPUT      : p_rrm_ue_cntxt, p_rrc_rrm_ho_adm_resp
*   OUTPUT     : p_rrc_rrm_ho_adm_resp
*   DESCRIPTION:
*       Fill UE scell config in HO admission resp
*
*   RETURNS: rrm_void_t
******************************************************************************/
rrm_void_t
rrm_ue_scell_config_fill_ho_adm_resp
(
    rrm_ue_context_t *p_rrm_ue_cntxt,
    rrc_rrm_ue_ho_adm_resp_t *p_rrc_rrm_ho_adm_resp
)
{
    rrm_ue_proc_ho_adm_data_t *p_rrm_ue_proc_ho_adm_data = RRM_PNULL;
    rrm_scell_to_add_mod_list_t *p_scell_add_mod_list    = RRM_PNULL;
    U8 scell_count                                       = RRM_ZERO;   
    rrm_cell_context_t *p_cell_ctxt                      = RRM_PNULL;
    U8  scell_release_cnt                                = RRM_ZERO;

    RRM_ASSERT(p_rrm_ue_cntxt != RRM_PNULL);
    RRM_ASSERT(p_rrc_rrm_ho_adm_resp != RRM_PNULL);

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_adm_resp->scell_config.bitmask = RRM_ZERO;

    p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_cntxt->cell_index);
    if (RRM_PNULL != p_cell_ctxt)
    {
        p_rrm_ue_proc_ho_adm_data = (rrm_ue_proc_ho_adm_data_t *)
            p_rrm_ue_cntxt->current_procedure.p_proc_data;
        if (RRM_AS_CONFIG_EXT_SCELL_ADD_MOD_LIST_PRESENT & p_rrm_ue_proc_ho_adm_data->bitmask)
        {
            p_scell_add_mod_list = &p_rrm_ue_proc_ho_adm_data->scell_add_mod_list;
            switch(p_rrm_ue_proc_ho_adm_data->ho_type)
            {
                case HANDOVER_TYPE_INTER_CELL:
                    
                  /*klock_works_changes_start*/                    
                  rrm_ue_scell_config_fill_ho_adm_resp_for_inter_cell_handover(p_cell_ctxt, p_rrc_rrm_ho_adm_resp, p_scell_add_mod_list, p_rrm_ue_cntxt);
                  /*klock_works_changes_end*/
                  
                  /* Bug_11947_fix: Start */
                    rrm_fill_scell_add_mod_list_in_ho_adm_resp(p_rrm_ue_cntxt,
                            p_rrm_ue_proc_ho_adm_data,
                            p_rrc_rrm_ho_adm_resp);
                    /* Bug_11947_fix: End */
                   
                   break;

                case HANDOVER_TYPE_INTRA_LTE_S1:
                case HANDOVER_TYPE_INTRA_LTE_X2:
                    for (scell_count = RRM_ZERO; ((scell_count < p_scell_add_mod_list->count) &&
                                (scell_count < RRM_MAX_SCELL) && (scell_count < MAX_SCELL )); scell_count++)
                    {
                        p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.rrc_scell_to_release[scell_count].\
                            scellIndex = p_scell_add_mod_list->rrm_scell_to_add_mod[scell_count].scell_index;

                        scell_release_cnt++;
                    }

                    if (scell_release_cnt > RRM_ZERO)
                    {
                        p_rrc_rrm_ho_adm_resp->scell_config.scell_release_list.count = scell_release_cnt;
                        p_rrc_rrm_ho_adm_resp->bitmask |= RRC_RRM_UE_HO_ADM_RESP_CONFIG_SCELL_PRESENT;
                        p_rrc_rrm_ho_adm_resp->scell_config.bitmask |= RRM_SCELL_RELEASE_LIST_PRESENT;
                    }
                    /* Bug_11947_fix: Start */
                    rrm_fill_scell_add_mod_list_in_ho_adm_resp(p_rrm_ue_cntxt,
                            p_rrm_ue_proc_ho_adm_data,
                            p_rrc_rrm_ho_adm_resp);
                    /* Bug_11947_fix: End */
                    break;

                    /* Bug_11947_fix: Start */
                case HANDOVER_TYPE_INTRA_CELL:
                    rrm_fill_scell_add_mod_list_for_intra_cell_ho(p_rrm_ue_cntxt,
                            p_rrm_ue_proc_ho_adm_data,
                            p_rrc_rrm_ho_adm_resp);
                    break;
                    /* Bug_11947_fix: End */

                default:
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, 
                            "HO Type is Other than Inter Cell, Intra Cell, S1HO & X2HO. [Cell Idx: %d]",
                            p_rrm_ue_cntxt->cell_index);
                    break;
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, 
                "Cell context is NULL of cell_index[%d]", p_rrm_ue_cntxt->cell_index);
    }
    RRM_UT_TRACE_EXIT();
}
    /* Carrier_Aggregation_End */

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
*   FUNCTION NAME: rrm_build_and_send_ho_adm_resp_for_ho_typ
*   INPUT      : p_rrm_ue_cntxt,transaction_id
*   OUTPUT     : response
*   DESCRIPTION:
*       Fill and send ho adm response
******************************************************************************/

void
rrm_build_and_send_ho_adm_resp_for_ho_typ
(
 rrm_response_t response,
 rrm_ue_context_t *p_rrm_ue_cntxt,
 rrm_cell_context_t *p_cell_ctxt 
 )
{
    RRM_UT_TRACE_ENTER();

    switch(p_rrm_ue_cntxt->ho_typ)
    {
	    /* SPR 20742 start */
	    /* Code removed */
	    /* SPR 20742 end */
        case RRM_HANDOVER_TYPE_LTE_TO_UTRAN:
        case RRM_HANDOVER_TYPE_LTE_TO_GERAN:
            break;
        case RRM_HANDOVER_TYPE_UTRAN_TO_LTE:
        {
            if ((U8)RRM_FAILURE == response.response) /* Coverity: CID 30759 */
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_utran_hi_fail += RRM_ONE;
            }
        }
        break;
        case RRM_HANDOVER_TYPE_GERAN_TO_LTE:
        {
            if ((U8)RRM_FAILURE == response.response) /* Coverity: CID 30759 */
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_geran_hi_fail += RRM_ONE;
            }
        }
        break;
        case RRM_HANDOVER_TYPE_INTRA_CELL:
        case RRM_HANDOVER_TYPE_INTER_CELL:
        case RRM_HANDOVER_TYPE_INTRA_LTE_X2:
	/* SPR 20742 start */
        case RRM_HANDOVER_TYPE_INTRA_LTE_S1:
	/* SPR 20742 end */
        {
            if ((U8)RRM_FAILURE == response.response) /* Coverity: CID 30759 */
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_eutran_hi_fail += RRM_ONE;
            }
        }
        break;
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT:
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD:
        case RRM_HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD:
        case RRM_HANDOVER_TYPE_CCO:
            break;
        default:
            break;
    }
    RRM_UT_TRACE_EXIT(); 
}
/*Klocwork activity 1-Apr_2014 end*/

/******************************************************************************
*   FUNCTION NAME: rrm_build_and_send_ho_adm_resp
*   INPUT      : p_rrm_ue_cntxt,transaction_id
*   OUTPUT     : response
*   DESCRIPTION:
*       Fill and send ho adm response
*
*   RETURNS:
*       RRM_SUCCESS  on Success
*       RRM_FAILURE  on Failure
******************************************************************************/

rrm_return_et
rrm_build_and_send_ho_adm_resp(
        rrm_response_t response,
        rrm_ue_context_t *p_rrm_ue_cntxt,
        U16              transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    /* Coverity Fix, CID:11213, [Prasant] */
    rrc_rrm_ue_ho_adm_resp_t        *p_rrc_rrm_ho_adm_resp = RRM_PNULL;
    rrm_cell_context_t              *p_cell_ctxt= RRM_PNULL; 

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_adm_resp = (rrc_rrm_ue_ho_adm_resp_t*)rrm_mem_get(sizeof(rrc_rrm_ue_ho_adm_resp_t));
    if(RRM_PNULL == p_rrc_rrm_ho_adm_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%u],Failed to allocate the "
                "proc data for RRC_RRM_HO_ADM_RES", p_rrm_ue_cntxt->ue_index);
        return RRM_FAILURE;
    }

    /* SPR 13045 start */
    RRM_MEMSET(p_rrc_rrm_ho_adm_resp, RRM_ZERO,(sizeof(rrc_rrm_ue_ho_adm_resp_t)));
    p_rrc_rrm_ho_adm_resp->ue_index = p_rrm_ue_cntxt->ue_index;
    RRM_MEMCPY(&p_rrc_rrm_ho_adm_resp->response,&response,sizeof(rrm_response_t));
    /* SPR 13045 end */

    /* Carrier_Aggregation_Start */
    rrm_ue_scell_config_fill_ho_adm_resp (p_rrm_ue_cntxt, p_rrc_rrm_ho_adm_resp);
    /* Carrier_Aggregation_End */

    rrm_ue_rbc_fill_ho_adm_resp(p_rrm_ue_cntxt,
            p_rrc_rrm_ho_adm_resp,response);
    /*KPI:start ho success and fail */
    p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_cntxt->cell_index);
    /*Klocwork activity 1-Apr_2014 start*/
    /*CID 65809:start*/
    if (RRM_PNULL == p_cell_ctxt )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
        /*CID 66686:start*/
        RRM_MEM_FREE(p_rrc_rrm_ho_adm_resp);
        /*CID 66686:end*/
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65809:end*/

    rrm_build_and_send_ho_adm_resp_for_ho_typ
        (
         response,
         p_rrm_ue_cntxt,
         p_cell_ctxt
        );
    /*Klocwork activity 1-Apr_2014 end*/
    /*KPI:end*/

    ret_val = rrm_il_send_rrc_rrm_ue_ho_adm_resp(p_rrc_rrm_ho_adm_resp,
            RRM_MODULE_ID,RRC_MODULE_ID, transaction_id,p_rrm_ue_cntxt->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d], Failed to send HO ADM RESP" ,p_rrm_ue_cntxt->ue_index);
    }
    else
    {
	/* SPR 20742 start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                "UE_INDEX[%d], Successfully sent HO ADM RESPONSE [%d]",
		p_rrm_ue_cntxt->ue_index, response.response);
	/* SPR 20742 end */

        /* raising event RRM_EVENT_LOCAL_HO_IN_EXEC_ATTEMPT Start*/
        rrm_raise_event_ho_in_exec_attempt(p_rrm_ue_cntxt);
        /* raising event RRM_EVENT_LOCAL_HO_IN_EXEC_ATTEMPT End*/

        /* raising event RRM_EVENT_LOCAL_HO_IN_PREP_COMPLETE start */  
        if ((response.response == RRM_UE_SUCCESS)||
            (response.response == RRM_UE_PARTIAL_SUCCESS)
           )
        {
          rrm_raise_event_ho_in_prep_complete(p_rrm_ue_cntxt);               
          /*SPR 18241 START*/
          RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_cntxt->current_procedure, RRM_UE_HO_ADM_ONGOING);
          /*SPR 18241 END*/

        }
        /* raising event RRM_EVENT_LOCAL_HO_IN_PREP_COMPLETE end */
        /* raising event RRM_EVENT_LOCAL_HO_IN_EXEC_FAILED start */
        else
        {
          rrm_raise_event_ho_in_exec_failed(p_rrm_ue_cntxt);
          /*SPR 18241 START*/
            /* SPR 20742 start */
            /* RRC will not send ho admission cnf hence releasing the UE context here */
            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_rrm_ue_cntxt))
            {
                 RRM_TRACE(g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_ERROR,
                            "Failed to release the resources for the UE");
                            
                 ret_val = RRM_FAILURE;
            }
            /*SPR 18241 END*/
            /* SPR 20742 end */

        }
        /* raising event RRM_EVENT_LOCAL_HO_IN_EXEC_FAILED End */
    }

    RRM_MEM_FREE(p_rrc_rrm_ho_adm_resp);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
*   FUNCTION NAME: rrm_build_and_send_ho_adm_resp_failure
*   INPUT      : response, ue_index, cell_index,transaction_id
*   OUTPUT     : response
*   DESCRIPTION:
*       Fill and send ho adm response failure
*
*   RETURNS:
******************************************************************************/
rrm_return_et
rrm_build_and_send_ho_adm_resp_failure(
        rrm_response_t response,
        rrm_ue_index_t ue_index,
        rrm_cell_index_t cell_index,
        U16              transaction_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_ho_adm_resp_t        *p_rrc_rrm_ho_adm_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    /*SPR 19188 START*/
    /* SPR 20652 Fix Start */
    /* Code removed */
    /* SPR 20652 Fix End */
    rrm_cell_context_t          *p_cell_ctxt = RRM_PNULL;
    rrm_ue_context_t            *p_ue_context= RRM_PNULL;
    rrm_ue_proc_ho_adm_data_t       *p_rrm_ue_proc_ho_adm_data = RRM_PNULL;
    /*SPR 19188 END*/


    p_rrc_rrm_ho_adm_resp = (rrc_rrm_ue_ho_adm_resp_t*)rrm_mem_get(sizeof(rrc_rrm_ue_ho_adm_resp_t));
    if(RRM_PNULL == p_rrc_rrm_ho_adm_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%d],Failed to allocate the "
                "proc data for RRC_RRM_HO_ADM_RES",ue_index);
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_rrc_rrm_ho_adm_resp, RRM_NULL , sizeof(rrc_rrm_ue_ho_adm_resp_t));
    p_rrc_rrm_ho_adm_resp->ue_index = ue_index;
    p_rrc_rrm_ho_adm_resp->response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
    p_rrc_rrm_ho_adm_resp->response.response = RRC_FAILURE;
    p_rrc_rrm_ho_adm_resp->response.cause.type = response.cause.type;
    p_rrc_rrm_ho_adm_resp->response.cause.value = response.cause.value;

    /*SPR 19188 START*/
    /* SPR 20652 Fix Start */
    p_ue_context = rrm_ue_find_context(ue_index,
            cell_index);
    /* SPR 20652 Fix End */
    if(RRM_PNULL != p_ue_context)
    {
        /* Coverity-110415 END */
        p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
        /* Coverity-110413 START */
        if (RRM_PNULL == p_cell_ctxt)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "p_cell_context is NULL for cell_index=%u",p_ue_context->cell_index);
            RRM_MEM_FREE(p_rrc_rrm_ho_adm_resp);
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /* Coverity-110413 END */
        p_rrm_ue_proc_ho_adm_data = (rrm_ue_proc_ho_adm_data_t *)
            p_ue_context->current_procedure.p_proc_data;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "UE context not found");
    }
    if(RRM_PNULL == p_rrm_ue_proc_ho_adm_data)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_rrm_ue_proc_ho_adm_data is NULL");
        RRM_MEM_FREE(p_rrc_rrm_ho_adm_resp);
        return RRM_FAILURE;
    }

    switch(p_rrm_ue_proc_ho_adm_data->ho_type)
    {
        case HANDOVER_TYPE_LTE_TO_UTRAN:
        case HANDOVER_TYPE_LTE_TO_GERAN:
        break;
        case HANDOVER_TYPE_UTRAN_TO_LTE:
        {
            if ((U8)RRM_FAILURE == response.response) /* Coverity: CID 30759 */
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_utran_hi_fail += RRM_ONE;
            }
        }
        break;
        case HANDOVER_TYPE_GERAN_TO_LTE:
        {
            if ((U8)RRM_FAILURE == response.response) /* Coverity: CID 30759 */
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_geran_hi_fail += RRM_ONE;
            }
        }
        break;
        case HANDOVER_TYPE_INTRA_CELL:
        case HANDOVER_TYPE_INTER_CELL:
        case HANDOVER_TYPE_INTRA_LTE_S1:
        case HANDOVER_TYPE_INTRA_LTE_X2:
        {
            if ((U8)RRM_FAILURE == response.response) /* Coverity: CID 30759 */
            {
                p_cell_ctxt->kpi_stat.kpi.num_of_eutran_hi_fail += RRM_ONE;
            }
        }
        break;
        case HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT:
        case HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD:
        case HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD:
        case HANDOVER_TYPE_CCO:

        break;
        default:
        break;
    }
    /*KPI:end*/
    /* SPR 20652 Fix Start */
    /* Code removed */
    /* SPR 20652 Fix End */
    /*SPR 19188 END*/

    if(RRM_FAILURE == rrm_il_send_rrc_rrm_ue_ho_adm_resp(p_rrc_rrm_ho_adm_resp,
                RRM_MODULE_ID,RRC_MODULE_ID, transaction_id,cell_index))
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d], Failed to send HO ADM RESP" ,ue_index);
    }
    else
    {
            /* SPR 20742 start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                "[UE:%d], Successfully sent HO ADM RESPONSE" ,ue_index);
    }

    RRM_MEM_FREE(p_rrc_rrm_ho_adm_resp);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* UE MEAS CHANGES : STARTS */

/******************************************************************************
 *   FUNCTION NAME: fill_eutran_meas_object_to_add_mod_list
 *   INPUT      : p_cell_ctx,p_meas_eutran_node,meas_obj_id
 *   OUTPUT     : p_meas_object_to_add_mod
 *   DESCRIPTION:
 *       Fills the eutran configuration in the meas object.
 *
 *   RETURNS:
 *          None
 ******************************************************************************/
static rrm_void_t
fill_eutran_meas_object_to_add_mod_list(
            rrm_cell_context_t          *p_cell_ctx,
            meas_eutran_node_t          *p_meas_eutran_node,
            meas_object_to_add_mod_t    *p_meas_object_to_add_mod,
            U8                          meas_obj_id
            )
{
    U32                     self_earfcn        = RRM_NULL;
    inter_freq_params_t     *p_cell_ctx_inter_params = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    /* Fill meas_object_to_add_mod[index] */
    p_meas_object_to_add_mod->meas_object_id = meas_obj_id;

    p_meas_object_to_add_mod->meas_object.bitmask |=
        MEAS_OBJECT_TO_ADD_EUTRA_PRESENT;

    /* Fill meas_object_eutra */
    p_meas_object_to_add_mod->meas_object.meas_object_eutra.
        carrier_freq = p_meas_eutran_node->eutran_config.earfcn;

    self_earfcn = p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn;
	if(self_earfcn == p_meas_eutran_node->eutran_config.earfcn)
    {
        /* RITIKA 5376 FIX Start*/
        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            offset_freq = SON_ANR_MEAS_OFFSET_FREQ;
        /* RITIKA 5376 FIX End*/

        if(p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info.
                bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT) 
        {
            p_meas_object_to_add_mod->meas_object.meas_object_eutra.
                allowed_meas_bandwidth =  
                p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info.
                measurement_bandwidth;
        }
        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            presence_antenna_port1 =
            p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info.
            presence_antenna_port1;

        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            neigh_cell_config = 
            p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
            neigh_cell_config;
    }
    else
    {
        p_cell_ctx_inter_params = &(p_cell_ctx->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[p_meas_eutran_node->cell_ctx_index]);

        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            offset_freq = p_meas_eutran_node->eutran_config.offset_frequency;

        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            allowed_meas_bandwidth =
            p_cell_ctx_inter_params->inter_freq_params_op_specific.allowed_meas_bandwidth;

        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            presence_antenna_port1 =
            p_cell_ctx_inter_params->inter_freq_params_op_specific.presence_antenna_port1;

        p_meas_object_to_add_mod->meas_object.meas_object_eutra.
            neigh_cell_config = p_cell_ctx_inter_params->neigh_cell_config;
    }

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_utran_meas_object_to_add_mod_list
 *   INPUT      : p_cell_context,p_meas_utran_node,meas_obj_id
 *   OUTPUT     : p_meas_object_to_add_mod
 *   DESCRIPTION:
 *       Fills the utran configuration in the meas object.
 *
 *   RETURNS:
 *          None
 ******************************************************************************/
static rrm_void_t
fill_utran_meas_object_to_add_mod_list(
         /*SPR 17777 +-*/
        meas_utran_node_t           *p_meas_utran_node,
        meas_object_to_add_mod_t    *p_meas_object_to_add_mod,
        U8                          meas_obj_id
        )
{
    RRM_UT_TRACE_ENTER();

    /* Fill meas_object_to_add_mod[index] */
    p_meas_object_to_add_mod->meas_object_id = meas_obj_id;

    p_meas_object_to_add_mod->meas_object.bitmask |=
        MEAS_OBJECT_TO_ADD_UTRA_PRESENT;

    /* Fill meas_object_utra */
    p_meas_object_to_add_mod->meas_object.meas_object_utra.
        carrier_freq = p_meas_utran_node->utran_config.uarfcn;

    p_meas_object_to_add_mod->meas_object.meas_object_utra.
        offset_freq = p_meas_utran_node->utran_config.offset_frequency;

    RRM_UT_TRACE_EXIT();

}

/******************************************************************************
 *   FUNCTION NAME: fill_utran_tdd_meas_object_to_add_mod_list
 *   INPUT      : p_cell_context,p_meas_utran_tdd_node,meas_obj_id
 *   OUTPUT     : p_meas_object_to_add_mod
 *   DESCRIPTION:
 *       Fills the utran_tdd configuration in the meas object.
 *
 *   RETURNS:
 *          None
 ******************************************************************************/
static rrm_void_t
fill_utran_tdd_meas_object_to_add_mod_list(
         /*SPR 17777 +-*/
        meas_utran_tdd_node_t       *p_meas_utran_tdd_node,
        meas_object_to_add_mod_t    *p_meas_object_to_add_mod,
        U8                          meas_obj_id
        )
{
    RRM_UT_TRACE_ENTER();
    
    /* Fill meas_object_to_add_mod[index] */
    p_meas_object_to_add_mod->meas_object_id = meas_obj_id;

    p_meas_object_to_add_mod->meas_object.bitmask |=
        MEAS_OBJECT_TO_ADD_UTRA_PRESENT;

    /* Fill meas_object_utra */
    p_meas_object_to_add_mod->meas_object.meas_object_utra.
        carrier_freq = p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd;

    p_meas_object_to_add_mod->meas_object.meas_object_utra.
        offset_freq = p_meas_utran_tdd_node->utran_tdd_config.offset_frequency;

    RRM_UT_TRACE_EXIT();

}

/******************************************************************************
 *   FUNCTION NAME: fill_eutran_report_config_to_add_mod_list
 *   INPUT      : purpose,report_id
 *   OUTPUT     : p_report_config_to_add_mod
 *   DESCRIPTION:
 *       Fills the eutran configuration in report config to be sent to RRC.
 *
 *   RETURNS:
 *          None
 ******************************************************************************/
static rrm_void_t
fill_eutran_report_config_to_add_mod_list(
            report_config_to_add_mod_t      *p_report_config_to_add_mod,
            rrm_trigger_type_periodical_purpose_et purpose,
            U8                              report_id
            )
{
    RRM_UT_TRACE_ENTER();
    
    p_report_config_to_add_mod->report_config_id = report_id;

    p_report_config_to_add_mod->report_config.bitmask |=
        REPORT_CONFIG_EUTRA_PRESENT;

    p_report_config_to_add_mod->report_config.report_config_eutra.trigger_type.
	bitmask |= REPORT_CONFIG_EUTRA_TRIGGER_TYPE_PERIODICAL_PRESENT;

    p_report_config_to_add_mod->report_config.report_config_eutra.
	trigger_type.periodical.purpose = purpose;

    p_report_config_to_add_mod->report_config.report_config_eutra.
	trigger_quantity = RRM_RRC_RSRP;

    p_report_config_to_add_mod->report_config.report_config_eutra.
	report_quantity = RRM_RRC_SAME_AS_TRIGGER_QUANTITY;

    /* CSR00069389 Start */
    p_report_config_to_add_mod->report_config.report_config_eutra.
	max_report_cells = RRM_MAX_CELLS_REPORTED;  
    /* CSR00069389 End */

    p_report_config_to_add_mod->report_config.report_config_eutra.
	report_interval = RRM_RRC_REPORT_INTERVAL_MS_120;

    /*SPR 15314 CHANGES START */
    p_report_config_to_add_mod->report_config.report_config_eutra.report_interval = RRM_RRC_REPORT_INTERVAL_MS_640;

    if(purpose== RRM_RRC_REPORT_CGI )	
    {
        p_report_config_to_add_mod->report_config.report_config_eutra.report_amount = RRM_RRC_REPORT_AMOUNT_1 ; 
    }	
    else
    {
        p_report_config_to_add_mod->report_config.report_config_eutra.report_amount = RRM_RRC_REPORT_AMOUNT_2 ;	 
    }	
    /*SPR 15314 CHANGES END*/

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_geran_meas_object_to_add_mod_list
 *   INPUT      : p_cell_ctx,p_meas_geran_node,meas_obj_id
 *   OUTPUT     : p_meas_object_to_add_mod
 *   DESCRIPTION:
 *       Fills the geran configuration in the meas object.
 *
 *   RETURNS:
 *          None
 ******************************************************************************/
static rrm_void_t
fill_geran_meas_object_to_add_mod_list(
            rrm_cell_context_t          *p_cell_ctx,
            meas_geran_node_t           *p_meas_geran_node,
            meas_object_to_add_mod_t    *p_meas_object_to_add_mod,
            U8                          meas_obj_id
            )
{
    idle_mode_mobility_irat_geran_params_t   *p_cell_ctx_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params);

    /* Fill meas_object_to_add_mod[index] */
    p_meas_object_to_add_mod->meas_object_id = meas_obj_id;

    p_meas_object_to_add_mod->meas_object.bitmask |=
        MEAS_OBJECT_TO_ADD_GERAN_PRESENT;

    /* Fill meas_object_geran */

    p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        starting_arfcn =
        p_meas_geran_node->geran_config.starting_arfcn;

    p_meas_object_to_add_mod->meas_object.meas_object_geran.
        offset_freq = p_meas_geran_node->geran_config.offset_frequency;

    p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        band_indicator = p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.band_ind;

    if(RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT &
        p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.following_arfcns.bitmask)
    {
        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
            following_arfcns.presence_bitmask |= GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
            following_arfcns.explicit_list_of_arfcns.count = p_cell_ctx_params->
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
            geran_car_freqs.following_arfcns.exp_arfcn_list_size;

        RRM_MEMCPY(p_meas_object_to_add_mod->meas_object.meas_object_geran.
            carrier_freqs.following_arfcns.explicit_list_of_arfcns.data,
            p_cell_ctx_params->irat_eutran_to_geran_list.
            irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
            geran_car_freqs.following_arfcns.exp_arfcn_list,
            sizeof(U16) * RRM_SON_MAX_GERAN_EXP_ARFCN_LIST_SIZE);

    }

    if(RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT &
        p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.following_arfcns.bitmask)
    {
        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        following_arfcns.presence_bitmask |= GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        following_arfcns.equally_spaced_arfcns.arfcn_spacing =
        p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.following_arfcns.arfcn_spacing;

        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        following_arfcns.equally_spaced_arfcns.num_of_following_arfcns =
        p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.following_arfcns.num_of_following_arfcn;
    }

    if(RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT &
        p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.following_arfcns.bitmask)
    {
        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        following_arfcns.presence_bitmask |= GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;

        p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        following_arfcns.var_bitmap_of_arfcns.count = 
        p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
        geran_car_freqs.following_arfcns.arfcn_bmp_list_size;

        RRM_MEMCPY(p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
            following_arfcns.var_bitmap_of_arfcns.data,
            p_cell_ctx_params->irat_eutran_to_geran_list.
            irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
            geran_car_freqs.following_arfcns.arfcn_bmp_list,
            sizeof(U8) * RRM_SON_MAX_NUM_OF_OCTETS_IN_VAR_BITMAP);
    }

    p_meas_object_to_add_mod->meas_object.meas_object_geran.ncc_Permitted
        = p_cell_ctx_params->irat_eutran_to_geran_list.
        irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].ncc_permitted;

    RRM_UT_TRACE_EXIT();
}


/******************************************************************************
 *   FUNCTION NAME: fill_cdma_meas_object_to_add_mod_list
 *   INPUT      : p_cell_ctx,p_meas_cdma_node,meas_obj_id
 *   OUTPUT     : p_meas_object_to_add_mod
 *   DESCRIPTION:
 *       Fills the cdma configuration in the meas object.
 *
 *   RETURNS:
 *          None
 ******************************************************************************/
static rrm_void_t
fill_cdma_meas_object_to_add_mod_list(
            rrm_cell_context_t          *p_cell_ctx,
            meas_cdma_node_t            *p_meas_cdma_node,
            meas_object_to_add_mod_t    *p_meas_object_to_add_mod,
            U8                          meas_obj_id
            )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t *p_cell_ctx_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params);

    /* Fill meas_object_to_add_mod[index] */
    p_meas_object_to_add_mod->meas_object_id = meas_obj_id;

    p_meas_object_to_add_mod->meas_object.bitmask |=
        MEAS_OBJECT_TO_ADD_CDMA2000_PRESENT;

    /* Fill meas_object_geran */
    if(RRM_PNULL != p_meas_cdma_node)
    {
        p_meas_object_to_add_mod->meas_object.meas_object_cdma2000.
            carrier_freq_cdma2000.band_class =
            p_meas_cdma_node->cdma_config.band_class;

      
        p_meas_object_to_add_mod->meas_object.meas_object_cdma2000.
            carrier_freq_cdma2000.arfcn =
            p_meas_cdma_node->cdma_config.arfcn;

        p_meas_object_to_add_mod->meas_object.meas_object_cdma2000.
            offset_freq = p_meas_cdma_node->cdma_config.offset_frequency;
        
        p_meas_object_to_add_mod->meas_object.meas_object_cdma2000.cdma2000_type =  \
                                p_meas_cdma_node->cdma_config.cdma_type;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "p_meas_cdma_node is found NULL");

    }
    p_meas_object_to_add_mod->meas_object.meas_object_cdma2000.search_window_size = \
                            p_cell_ctx_params->search_window_size;
    RRM_UT_TRACE_EXIT();
}







/******************************************************************************
 *   FUNCTION NAME: fill_interrat_report_config_to_add_mod_list
 *   INPUT      : p_ue_context, p_report_config_to_add_mod, purpose,report_id
 *   OUTPUT     : p_report_config_to_add_mod
 *   DESCRIPTION:
 *       Fills the utran configuration in report config to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_interrat_report_config_to_add_mod_list(
            /* SPR 12897 Start */
            rrm_ue_context_t                *p_ue_context,
            /* SPR 12897 End */
            report_config_to_add_mod_t      *p_report_config_to_add_mod,
            /* SPR 7514 Fix Start - report config 924 */
            rrm_interrat_trigger_type_periodical_purpose_et purpose,
            /* SPR 7514 Fix End - report config 924 */
            U8                              report_id
            )
{
    RRM_UT_TRACE_ENTER();
    
    p_report_config_to_add_mod->report_config_id = report_id;
        
    p_report_config_to_add_mod->report_config.bitmask |=
	REPORT_CONFIG_INTERRAT_PRESENT;

    p_report_config_to_add_mod->report_config.report_config_interrat.
	trigger_type.bitmask |= REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_PERIODICAL_PRESENT;

    p_report_config_to_add_mod->report_config.report_config_interrat.
	trigger_type.periodical.purpose = purpose;

    /* CSR00069389 Start */
    /* SPR 12351 Start */
    if((REPORT_CONFIG_INTERRAT_UTRAN_CDMA_ID == report_id) ||
        (REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID == report_id))
    /* SPR 12351 End */
    {
        p_report_config_to_add_mod->report_config.report_config_interrat.
            max_report_cells = RRM_ONE;
    }
    /* For GERAN Configuration */
    else
    {
        p_report_config_to_add_mod->report_config.report_config_interrat.
            max_report_cells = RRM_MAX_CELLS_REPORTED;
    }
    /* CSR00069389 End */

    p_report_config_to_add_mod->report_config.report_config_interrat.
	report_interval = RRM_RRC_REPORT_INTERVAL_MS_120;

    p_report_config_to_add_mod->report_config.report_config_interrat.
	report_amount = RRM_RRC_REPORT_AMOUNT_1; 


    /* SPR 12897 Start */
    /* If CGI report configuration is being sent */
    if((REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID == report_id) ||
            (REPORT_CONFIG_INTERRAT_GERAN_CGI_ID  == report_id))
    {
        /* If autonomous gaps are to be configured */
        if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
                (RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                 eutra_radio_capability_info_def.access_stratum_release) &&
                 (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status))
        {
            p_report_config_to_add_mod->report_config.report_config_interrat.
                si_request_for_ho_r9 = RRM_RRC_SETUP_R9;

            p_report_config_to_add_mod->report_config.report_config_interrat.
                bitmask |= SI_REQUEST_FOR_HO_R9_INTERRAT_PRESENT;
        }
    }
    /* SPR 12897 End */

    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: fill_meas_id_to_add_mod_list
 *   INPUT      : p_meas_config_info
 *   OUTPUT     : p_meas_id_to_add_mod
 *   DESCRIPTION:
 *       Fills the configuration in meas id to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_meas_id_to_add_mod_list(
            meas_id_to_add_mod_t        *p_meas_id_to_add_mod,
            rrm_ue_meas_config_t        *p_meas_config_info
            )
{
    RRM_UT_TRACE_ENTER();

    p_meas_id_to_add_mod->meas_id = p_meas_config_info->meas_id;

    p_meas_id_to_add_mod->meas_object_id = p_meas_config_info->meas_obj_id;

    p_meas_id_to_add_mod->report_config_id = p_meas_config_info->report_id;
        
    RRM_UT_TRACE_EXIT();
}


//CP 10-Feb-2013 start
/******************************************************************************
 *   FUNCTION NAME: rrm_search_ho_meas_object 
 *   INPUT      : p_rrm_ue_context,earfcn,p_meas_obj_id
 *   OUTPUT     : none 
 *   DESCRIPTION:
 *       Search for meas object created for HO. This function fills object
 *       id in output argument if already exists else fill 0.
 *
 *   RETURNS:
 *       NONE        
 *****************************************************************************/
    static rrm_void_t 
rrm_search_ho_meas_object(rrm_ue_context_t *p_rrm_ue_context, U32 earfcn, U8 *p_meas_obj_id )
{
    RRM_UT_TRACE_ENTER();

    meas_report_info_node_t *p_meas_report_info = RRM_PNULL;

    YLNODE *p_node = RRM_PNULL;

    p_node = ylFirst(&(p_rrm_ue_context->meas_report_list));

    while (p_node) {
        p_meas_report_info = (meas_report_info_node_t*) p_node;
        if (p_meas_report_info->carrier_earfcn == earfcn) {
            *p_meas_obj_id = p_meas_report_info->meas_object_id;
            break;
        }
        p_node = ylNext(p_node);
    }
    RRM_UT_TRACE_EXIT();
}
//CP 10-Feb-2013 end
/******************************************************************************
 *   FUNCTION NAME: fill_eutran_meas_config_list
 *   INPUT      : p_cell_context,p_meas_eutran_node,p_meas_config,index
 *                purpose,p_meas_config_info
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the eutran configuration in meas config list to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_eutran_meas_config_list(
            rrm_cell_context_t          *p_cell_context,
            /* CSR00069389 Start */
            rrm_ue_context_t            *p_ue_context,
            /* CSR00069389 End */
            meas_eutran_node_t          *p_meas_eutran_node,
            rrm_meas_config_t           *p_meas_config,
            U8                          index,
            rrm_trigger_type_periodical_purpose_et purpose,
            rrm_ue_meas_config_t        *p_meas_config_info
            )
{
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Meas Config Req purpose = REPORT CGI at index = %d", index);

    /* Fill meas_object_to_add_mod_list */
    fill_eutran_meas_object_to_add_mod_list(p_cell_context, p_meas_eutran_node,
            &p_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index],
            p_meas_config_info->meas_obj_id);

    /* SPR 15314 Start */
    p_ue_context->p_meas_config[p_meas_config_info->meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter = RRM_ONE;
    /*SPR 17061 Start*/
    /*SPR 15835:Start*/
    p_ue_context->temp_report_amt_ue+=RRM_ONE ;
    /*SPR 15835:End*/
    /*SPR 17061 End*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"\nValue of report counter stored in meas_id=%d for CGI reporting=%d,"
            "Global report amount of UE=%d temp report amount UE=%d",p_meas_config_info->meas_id,
            p_ue_context->p_meas_config[p_meas_config_info->meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter,
            p_ue_context->report_amount_ue,
    /*SPR 17061 Start*/
    /*SPR 15835:Start*/
            p_ue_context->temp_report_amt_ue);
    /*SPR 15835:End*/
    /*SPR 17061 End*/
    /* SPR 15314 End */
    /* CSR00069389 Start */
    /* SPR 12351 Start */
    if(!(REPORT_CONFIG_EUTRA_CGI_SENT & p_ue_context->meas_config_sent_bitmask))
    {
        p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_EUTRA_CGI_SENT;

        /* Fill report_config_to_add_mod_list */
        fill_eutran_report_config_to_add_mod_list(
                &p_meas_config->report_config_to_add_mod_list.
                report_config_to_add_mod[index], purpose, REPORT_CONFIG_EUTRA_CGI_ID);
        /* SPR 12351 End */

        p_meas_config->bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Report configuration for Eutran reportCGI already sent");
    }
    /* CSR00069389 End */

    /* SPR 12351 Start */
    /* Update report ID for CGI reporting being sent */
    p_meas_config_info->report_id = REPORT_CONFIG_EUTRA_CGI_ID;
    /* SPR 12351 End */

    /* Fill meas_id_to_add_mod_list */
    fill_meas_id_to_add_mod_list(&p_meas_config->
            meas_id_to_add_mod_list.meas_id_to_add_mod[index], p_meas_config_info);

    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
 *   FUNCTION NAME: fill_eutran_object_meas_config_list
 *   INPUT      : p_cell_context,p_meas_eutran_node,index,purpose,p_meas_config_info
 *   OUTPUT     : p_meas_config
 *   DESCRIPTION:
 *       Fills the eutran configuration in meas config list to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_eutran_object_meas_config_list(
            rrm_cell_context_t          *p_cell_context,
            meas_eutran_node_t          *p_meas_eutran_node,
            rrm_meas_config_t           *p_meas_config,
            U8                          index,
         /*SPR 17777 +-*/
            rrm_ue_meas_config_t        *p_meas_config_info
            )
{
    RRM_UT_TRACE_ENTER();

    /* CSR00069389 Start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Meas Config Req purpose = REPORT STRONGEST CELLS for EUTRAN freq at index = %d",
            index);

    /* Fill meas_object_to_add_mod_list */
    fill_eutran_meas_object_to_add_mod_list(p_cell_context, p_meas_eutran_node,
            &p_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index],
            p_meas_config_info->meas_obj_id);

    /* CSR00069389 End */    

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_utran_meas_config_list
 *   INPUT      : p_cell_context,p_ue_context,p_meas_utran_node,index,purpose,p_meas_config_info
 *   OUTPUT     : p_meas_config
 *   DESCRIPTION:
 *       Fills the utran configuration in meas config list to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_utran_meas_config_list(
            rrm_cell_context_t          *p_cell_context,
            /* CSR00069389 Start */
            rrm_ue_context_t            *p_ue_context,
            /* CSR00069389 End */
            meas_utran_node_t           *p_meas_utran_node,
            rrm_meas_config_t           *p_meas_config,
            U8                          index,
            /* SPR 7514 Fix Start - report config 924 */
            rrm_interrat_trigger_type_periodical_purpose_et purpose,
            /* SPR 7514 Fix End - report config 924 */
            rrm_ue_meas_config_t        *p_meas_config_info
            )
{

    /* SPR 14326 Fix Start */
    rrm_bool_et    send_measgap = RRM_FALSE;
    /* SPR 14326 Fix End */
    RRM_UT_TRACE_ENTER();

    /* Fill meas_object_to_add_mod_list */
         /*SPR 17777 +-*/
    fill_utran_meas_object_to_add_mod_list( p_meas_utran_node, 
            &p_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index],
            p_meas_config_info->meas_obj_id);

    /* CSR00069389 Start */
    /* SPR 12351 Start */

    /* SPR 14326 Fix Start */
    if(SON_ANR_MEAS_OFFSET_FREQ ==  p_meas_config->meas_object_to_add_mod_list.
                 meas_object_to_add_mod[index].meas_object.meas_object_eutra.offset_freq)
    {
        send_measgap = RRM_TRUE;
    }
    else
    {
        send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                        .rf_configurations.dl_earfcn ,
                         p_meas_utran_node->utran_config.uarfcn,
                         p_ue_context,
                         INTER_FREQ_BAND_LIST,
                         EUTRA_FREQ ,
                         RRM_PNULL
                         );
    }
    if( RRM_TRUE == send_measgap)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "CGI: Send MEAS GAP for EUTRAN");
        p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
    }   
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "CGI: No need to send MEAS GAP for EUTRAN");
        p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
    }
    /* SPR 14326 Fix End */

    if(!(REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_SENT & p_ue_context->meas_config_sent_bitmask))
    {
        p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_SENT;

        /* Fill report_config_to_add_mod_list */
        fill_interrat_report_config_to_add_mod_list(
                /* SPR 12987 Start */
                p_ue_context,
                /* SPR 12987 End */
                &p_meas_config->report_config_to_add_mod_list.
                report_config_to_add_mod[index], purpose, REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID);

        p_meas_config->bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;
        /* SPR 12351 End */

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Report configuration for Utran/Cdma reportCGI already sent");
    }
    /* CSR00069389 End */

    /* SPR 12351 Start */
    /* Update report ID for CGI reporting being sent */
    p_meas_config_info->report_id = REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID;
    /* SPR 12351 End */

    /* Fill meas_id_to_add_mod_list */
    fill_meas_id_to_add_mod_list(&p_meas_config->
            meas_id_to_add_mod_list.meas_id_to_add_mod[index], p_meas_config_info);

    RRM_UT_TRACE_EXIT();
}

/* TDD Support SON Start */
/******************************************************************************
 *   FUNCTION NAME: fill_utran_tdd_meas_config_list
 *   INPUT      : p_cell_context,p_ue_context,p_meas_utran_tdd_node,index,purpose,p_meas_config_info
 *   OUTPUT     : p_meas_config
 *   DESCRIPTION:
 *       Fills the utran_tdd configuration in meas config list to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_utran_tdd_meas_config_list(
            rrm_cell_context_t          *p_cell_context,
            /* CSR00069389 Start */
            rrm_ue_context_t            *p_ue_context,
            /* CSR00069389 End */
            meas_utran_tdd_node_t       *p_meas_utran_tdd_node,
            rrm_meas_config_t           *p_meas_config,
            U8                          index,
            /* SPR 7514 Fix Start - report config 924 */
            rrm_interrat_trigger_type_periodical_purpose_et purpose,
            /* SPR 7514 Fix End - report config 924 */
            rrm_ue_meas_config_t        *p_meas_config_info
            )
{
    /* SPR 14326 Fix Start */
    rrm_bool_et    send_measgap = RRM_FALSE;
    /* SPR 14326 Fix End */

    RRM_UT_TRACE_ENTER();
    
    /* Fill meas_object_to_add_mod_list */
         /*SPR 17777 +-*/
    fill_utran_tdd_meas_object_to_add_mod_list(p_meas_utran_tdd_node, 
            &p_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index],
            p_meas_config_info->meas_obj_id);


    /* CSR00069389 Start */
    /* SPR 12351 Start */
    /* SPR 14326 Fix Start */
    send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                    .rf_configurations.dl_earfcn ,
                     p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd,
                     p_ue_context,
                     INTER_RAT_BAND_LIST,
                     UTRAN_TDD_FREQ,
                     RRM_PNULL
                     );
    if( RRM_TRUE == send_measgap)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                    "CGI: Send MEAS GAP for UTRAN TDD");
        p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                          "CGI: No need to send MEAS GAP for UTRAN TDD");
        p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
    }
    /* SPR 14326 Fix End */

    
    
    if(!(REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_SENT & p_ue_context->meas_config_sent_bitmask))
    {
        p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_SENT;

        /* Fill report_config_to_add_mod_list */
        fill_interrat_report_config_to_add_mod_list(
            /* SPR 12987 Start */
            p_ue_context,
            /* SPR 12987 End */
            &p_meas_config->report_config_to_add_mod_list.
            report_config_to_add_mod[index], purpose, REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID);

	    p_meas_config->bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;
        /* SPR 12351 End */       
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Report configuration for Utran/Cdma reportCGI already sent");
    }
    /* CSR00069389 End */

    /* SPR 12351 Start */
    /* Update report ID for CGI reporting being sent */
    p_meas_config_info->report_id = REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID;
    /* SPR 12351 End */

    /* Fill meas_id_to_add_mod_list */
    fill_meas_id_to_add_mod_list(&p_meas_config->
            meas_id_to_add_mod_list.meas_id_to_add_mod[index], p_meas_config_info);

    RRM_UT_TRACE_EXIT();
}
/* TDD Support SON End */


/******************************************************************************
 *   FUNCTION NAME: fill_geran_meas_config_list
 *   INPUT      : p_cell_context,p_ue_context,p_meas_geran_node,index,purpose,p_meas_config_info
 *   OUTPUT     : p_meas_config
 *   DESCRIPTION:
 *       Fills the geran configuration in meas config list to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_geran_meas_config_list(
            rrm_cell_context_t          *p_cell_context,
            /* CSR00069389 Start */
            rrm_ue_context_t            *p_ue_context,
            /* CSR00069389 End */
            meas_geran_node_t           *p_meas_geran_node,
            rrm_meas_config_t           *p_meas_config,
            U8                          index,
            /* SPR 7514 Fix Start - report config 924 */
            rrm_interrat_trigger_type_periodical_purpose_et purpose,
            /* SPR 7514 Fix End - report config 924 */
        /* Spr 18401 Changes Start */
        rrm_ue_meas_config_t        *p_meas_config_info,
        U16                          geran_arfcn_on_report_cgi
        /* Spr 18401 Changes End */
            )
{
    /* SPR 14326 Fix Start */
    rrm_bool_et    send_measgap = RRM_FALSE;
    /* SPR 14326 Fix End */

    RRM_UT_TRACE_ENTER();

    /* Spr 18401 Changes Start */
    fill_geran_meas_object_to_add_mod_list_for_cgi(p_cell_context, p_meas_geran_node, 
            &p_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index],
            p_meas_config_info->meas_obj_id,
            geran_arfcn_on_report_cgi);
    /* Spr 18401 Changes End */
    /* SPR 14326 Fix Start */
    send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                   .rf_configurations.dl_earfcn ,
                   p_meas_geran_node->geran_config.starting_arfcn,
                   p_ue_context,
                   INTER_RAT_BAND_LIST,
                   GERAN_FREQ,
                   RRM_PNULL
                   );
    if( RRM_TRUE == send_measgap)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                        "CGI: Send MEAS GAP for GERAN");
        p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                             "CGI: No need to send MEAS GAP for GERAN");
        p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
    }
   /* SPR 14326 Fix End */

    /* CSR00069389 Start */
    /* SPR 12351 Start */
    if(!(REPORT_CONFIG_INTERRAT_GERAN_CGI_SENT & p_ue_context->meas_config_sent_bitmask))
    {
        p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_GERAN_CGI_SENT;

        /* Fill report_config_to_add_mod_list */
        fill_interrat_report_config_to_add_mod_list(
            /* SPR 12987 Start */
            p_ue_context,
            /* SPR 12987 End */
            &p_meas_config->report_config_to_add_mod_list.
            report_config_to_add_mod[index], purpose, REPORT_CONFIG_INTERRAT_GERAN_CGI_ID);
        /* SPR 12351 End */
	    p_meas_config->bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Report configuration for Geran reportCGI already sent");
    }
    /* CSR00069389 End */

    /* SPR 12351 Start */
    /* Update report ID for CGI reporting being sent */
    p_meas_config_info->report_id = REPORT_CONFIG_INTERRAT_GERAN_CGI_ID;
    /* SPR 12351 End */

    /* Fill meas_id_to_add_mod_list */
    fill_meas_id_to_add_mod_list(&p_meas_config->
            meas_id_to_add_mod_list.meas_id_to_add_mod[index], p_meas_config_info);

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_cdma2000_meas_config_list
 *   INPUT      : p_cell_context,p_ue_context,p_meas_cdma_node,index,purpose,p_meas_config_info
 *   OUTPUT     : p_meas_config
 *   DESCRIPTION:
 *       Fills the cdma configuration in meas config list to be sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_cdma2000_meas_config_list(
            rrm_cell_context_t          *p_cell_context,
            /* CSR00069389 Start */
            rrm_ue_context_t            *p_ue_context,
            /* CSR00069389 End */
            meas_cdma_node_t            *p_meas_cdma_node,
            rrm_meas_config_t           *p_meas_config,
            U8                          index,
            /* SPR 7514 Fix Start - report config 924 */
            rrm_interrat_trigger_type_periodical_purpose_et purpose,
            /* SPR 7514 Fix End - report config 924 */
            rrm_ue_meas_config_t        *p_meas_config_info
            )
{

    /* SPR 14326 Fix Start */
    rrm_bool_et    send_measgap = RRM_FALSE;
    /* SPR 14326 Fix End */

    RRM_UT_TRACE_ENTER();

    /* Fill meas_object_to_add_mod_list */
    fill_cdma_meas_object_to_add_mod_list(p_cell_context, p_meas_cdma_node, 
            &p_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index],
            p_meas_config_info->meas_obj_id);
    
    /* SPR 14326 Fix Start */
    rrm_cdma_meas_gap_config_t cdma_meas_gap_config = {RRM_ZERO};
    cdma_meas_gap_config.band_class = p_meas_cdma_node->cdma_config.band_class;
    cdma_meas_gap_config.cdma_type  = p_meas_cdma_node->cdma_config.cdma_type;
    send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
            .rf_configurations.dl_earfcn ,
             p_meas_cdma_node->cdma_config.arfcn,
            p_ue_context,
            INTER_RAT_BAND_LIST,
            CDMA_FREQ,
            &cdma_meas_gap_config
            );
    if( RRM_TRUE == send_measgap)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "CGI: Send MEAS GAP for CDMA");
        p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "CGI: No need to send MEAS GAP for CDMA");
        p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
    }
    /* SPR 14326 Fix End */


        /* CSR00069389 Start */
    /* SPR 12351 Start */
    if(!(REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_SENT & p_ue_context->meas_config_sent_bitmask))
    {
        p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_SENT;

        /* Fill report_config_to_add_mod_list */
        fill_interrat_report_config_to_add_mod_list(
                /* SPR 12987 Start */
                p_ue_context,
                /* SPR 12987 End */
                &p_meas_config->report_config_to_add_mod_list.
                report_config_to_add_mod[index], purpose, REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID);

	    p_meas_config->bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;
        /* SPR 12351 End */        
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Report configuration for Utran/Cdma reportCGI already sent");
    }
    /* CSR00069389 End */

    /* SPR 12351 Start */
    /* Update report ID for CGI reporting being sent */
    p_meas_config_info->report_id = REPORT_CONFIG_INTERRAT_UTRAN_CDMA_CGI_ID;
    /* SPR 12351 End */

    /* Fill meas_id_to_add_mod_list */
    fill_meas_id_to_add_mod_list(&p_meas_config->
            meas_id_to_add_mod_list.meas_id_to_add_mod[index], p_meas_config_info);

    RRM_UT_TRACE_EXIT();
}




/******************************************************************************
 *   FUNCTION NAME: fill_quantity_config_eutra
 *   INPUT      : p_quantity_config 
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the eutran quantity configuration in meas config request to be 
 *       sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
/* SPR 16880: start */
rrm_void_t
fill_quantity_config_eutra(
        quantity_config_t       *p_quantity_config,
        rrm_ue_context_t *p_rrm_ue_context
            )
{
    rrm_common_params_for_eutra_t
        *p_common_params_for_eutra  = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_common_params_for_eutra = rrm_cellm_get_connected_mode_common_params(p_rrm_ue_context->cell_index);
    p_quantity_config->bitmask |= QUANTITY_CONFIG_EUTRA_PRESENT;
    p_quantity_config->quantity_config_eutra.filter_coefficient_rsrp =
        p_common_params_for_eutra->filter_coefficient_rsrp;
    p_quantity_config->quantity_config_eutra.filter_coefficient_rsrq =
        p_common_params_for_eutra->filter_coefficient_rsrq; 

    RRM_UT_TRACE_EXIT();
}
/* SPR 16880: end */

/******************************************************************************
 *   FUNCTION NAME: fill_quantity_config_utra
 *   INPUT      : p_quantity_config
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the utran quantity configuration in meas config request to be
 *       sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
/* SPR 16880: start */
rrm_void_t
fill_quantity_config_utra(
        quantity_config_t       *p_quantity_config,
        rrm_ue_context_t *p_rrm_ue_context
            )
{
    rrm_irat_params_t        *p_rrm_irat_params          = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrm_irat_params = rrm_cellm_get_connected_mode_irat_params(p_rrm_ue_context->cell_index);

    p_quantity_config->bitmask |= QUANTITY_CONFIG_UTRA_PRESENT;
    p_quantity_config->quantity_config_utra.meas_quantity_utra_fdd = p_rrm_irat_params->meas_quantity_utra_fdd;
    p_quantity_config->quantity_config_utra.meas_quantity_utra_tdd = p_rrm_irat_params->meas_quantity_utra_tdd;
    p_quantity_config->quantity_config_utra.filter_coefficient = p_rrm_irat_params->filter_coefficient_utra;

    RRM_UT_TRACE_EXIT();
}
/* SPR 16880: end */
/******************************************************************************
 *   FUNCTION NAME: fill_quantity_config_cdma
 *   INPUT      : p_quantity_config
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the cdma quantity configuration in meas config request to be
 *       sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
/* SPR 16880: start */
rrm_void_t
fill_quantity_config_cdma(
        quantity_config_t       *p_quantity_config,
        rrm_ue_context_t *p_rrm_ue_context
            )
{
    rrm_irat_params_t        *p_rrm_irat_params          = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrm_irat_params = rrm_cellm_get_connected_mode_irat_params(p_rrm_ue_context->cell_index);

    p_quantity_config->bitmask |= QUANTITY_CONFIG_CDMA2000_PRESENT;
    p_quantity_config->quantity_config_cdma2000.meas_quantity_cdma2000= p_rrm_irat_params->meas_quantity_cdma2000;

    RRM_UT_TRACE_EXIT();
}
/* SPR 16880: end */

/******************************************************************************
 *   FUNCTION NAME: fill_quantity_config_geran
 *   INPUT        : p_quantity_config
 *   OPUTPUT      : none
 *   DESCRIPTION:
 *       Fills the geran quantity configuration in meas config request to be
 *       sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
/* SPR 16880: start */
rrm_void_t
fill_quantity_config_geran(
        quantity_config_t       *p_quantity_config,
        rrm_ue_context_t *p_rrm_ue_context
            )
{
    rrm_irat_params_t        *p_rrm_irat_params          = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrm_irat_params = rrm_cellm_get_connected_mode_irat_params(p_rrm_ue_context->cell_index);
    p_quantity_config->bitmask |= QUANTITY_CONFIG_GERAN_PRESENT;
    p_quantity_config->quantity_config_geran.meas_quantity_geran = RRM_RRC_RSSI;
    p_quantity_config->quantity_config_geran.filter_coefficient = p_rrm_irat_params->filter_coefficient_geran;

    RRM_UT_TRACE_EXIT();
}
/* SPR 16880: end */
/* Fix for SPR-5360 End */
/* Fix for SPR-5360 Delete fn: fill_quantity_config() */

/******************************************************************************
 *   FUNCTION NAME: fill_meas_gap_config
 *   INPUT      : p_meas_gap_config
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the meas gap configuration in meas config request to be
 *       sent to RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
fill_meas_gap_config(
        meas_gap_config_t   *p_meas_gap_config,
        /*SPR 15713 Fix Start*/
        rrm_ue_context_t    *p_ue_context
        /*SPR 15713 Fix End*/
        )
{
    RRM_UT_TRACE_ENTER();
    
    p_meas_gap_config->bitmask |= MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT;
    
    p_meas_gap_config->meas_gap_config_type = RRM_1;

    p_meas_gap_config->setup_config_info.bitmask |= MEAS_GAP_CONFIG_GP1_PRESENT;
    /* SPR 19838 : CID 11943 Fix Start */
    /* Code Deleted */
    /* SPR 19838 : CID 11943 Fix End */
    /*SPR 15713 Fix Start*/
    p_meas_gap_config->setup_config_info.gp1 = p_ue_context->meas_gap_offset;
    /*SPR 15713 Fix End*/

    RRM_UT_TRACE_EXIT();
}

/* static rrm_void_t
fill_meas_config_speed_state_pars(
        meas_config_speed_state_pars_t  *p_meas_config_speed_state_pars
)
{
    RRM_UT_TRACE_ENTER();
    
    p_meas_config_speed_state_pars->bitmask |= 
        MEAS_CONFIG_SPEED_STATE_SETUP_PRESENT;

    p_meas_config_speed_state_pars->setup.time_to_trigger_sf.sf_medium =
    p_meas_config_speed_state_pars->setup.time_to_trigger_sf.sf_high =

    p_meas_config_speed_state_pars->setup.mobility_state_parameters.
        t_evaluation = ;
    p_meas_config_speed_state_pars->setup.mobility_state_parameters.
        t_hyst_normal = ;
    p_meas_config_speed_state_pars->setup.mobility_state_parameters.
        m_cell_charge_medium = ;
    p_meas_config_speed_state_pars->setup.mobility_state_parameters.
        m_cell_charge_high = ;

    RRM_UT_TRACE_EXIT();
}*/


/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
*  FUNCTION NAME: rrm_ue_update_meas_context_list_for_utran
*  INPUT      : p_cell_context
*  OUTPUT     : none
*  DESCRIPTION:
*  RETURNS:
*              RRM_SUCCESS/RRM_FAILURE
*******************************************************************************/

static rrm_void_t
rrm_ue_update_meas_context_list_for_utran
(
 rrm_cell_context_t              *p_cell_context
)
{
    meas_utran_context_list_t       *p_meas_utran_list  = RRM_PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_context_list_t   *p_meas_utran_tdd_list  = RRM_PNULL;
    /* TDD Support SON End */
    meas_utran_node_t               *p_meas_utran_node  = RRM_PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_node_t           *p_meas_utran_tdd_node  = RRM_PNULL;
    /* TDD Support SON End */

    YLNODE                          *p_node             = RRM_PNULL;
    S8                              cell_ctx_index      = FREQ_NOT_CONFIGURED;
    U8                              index               = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    
    p_meas_utran_list  = &(p_cell_context->meas_utran_list);
    /* TDD Support SON Start */
    p_meas_utran_tdd_list  = &(p_cell_context->meas_utran_tdd_list);
    /* TDD Support SON End */

    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_utran_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_utran_node =  YMEMBEROF(meas_utran_node_t, sNode, p_node);
        /* TDD Support SON Start */
        cell_ctx_index = rrmcm_search_uarfcn_fdd_in_cell_context(p_cell_context,
                p_meas_utran_node->utran_config.uarfcn);
        /* TDD Support SON End */        

        if(CELL_STATE_W_FOR_CELL_RECONFIG_RESP == p_cell_context->cell_state)
        {
            if((INVALID_OFFSET_FREQ == p_meas_utran_node->utran_config.prev_offset_frequency)
                    || (FREQ_NOT_CONFIGURED == cell_ctx_index))
            {
                p_meas_utran_node->cell_ctx_index = FREQ_NOT_CONFIGURED;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Skipping this node(Awaiting Cell Reconfig Resp)");
            }
            else
            {
                p_meas_utran_node->cell_ctx_index = cell_ctx_index;
            }
        }
        /* If Reconfig is not currently triggered */
        else
        {
            /* If freq is configured at RRM */
            if(FREQ_NOT_CONFIGURED != cell_ctx_index) 
            {
                p_meas_utran_node->cell_ctx_index = cell_ctx_index;
                p_meas_utran_node->utran_config.prev_offset_frequency = 
                    p_meas_utran_node->utran_config.offset_frequency;
            } 
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Deleting node for FDD UARFCN = %d", 
                        p_meas_utran_node->utran_config.uarfcn);
                /* Delete the node as this freq is not configured at RRM */
                rrm_list_delete_node(p_meas_utran_list, p_node);        
                RRM_MEM_FREE(p_meas_utran_node);
            }
        }
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }

    /* TDD Support SON Start */
    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_utran_tdd_list);
    for(index = 0; RRM_PNULL != p_node; index++)
    {
        p_meas_utran_tdd_node =  YMEMBEROF(meas_utran_tdd_node_t, sNode, p_node);
        cell_ctx_index = rrmcm_search_uarfcn_tdd_in_cell_context(p_cell_context,
                p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd);

        if(CELL_STATE_W_FOR_CELL_RECONFIG_RESP == p_cell_context->cell_state)
        {
            if((INVALID_OFFSET_FREQ == p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency)
                    || (FREQ_NOT_CONFIGURED == cell_ctx_index))
            {
                p_meas_utran_tdd_node->cell_ctx_index = FREQ_NOT_CONFIGURED;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Skipping this node(Awaiting Cell Reconfig Resp)");
            }
            else
            {
                p_meas_utran_tdd_node->cell_ctx_index = cell_ctx_index;
            }
        }
        /* If Reconfig is not currently triggered */
        else
        {
            /* If freq is configured at RRM */
            if(FREQ_NOT_CONFIGURED != cell_ctx_index) 
            {
                p_meas_utran_tdd_node->cell_ctx_index = cell_ctx_index;
                p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency = 
                    p_meas_utran_tdd_node->utran_tdd_config.offset_frequency;
            } 
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Deleting node for TDD UARFCN = %d", 
                        p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd);
                /* Delete the node as this freq is not configured at RRM */
                rrm_list_delete_node(p_meas_utran_tdd_list, p_node);        
                RRM_MEM_FREE(p_meas_utran_tdd_node);
            }
        }
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }
    /* TDD Support SON End */

    RRM_UT_TRACE_EXIT();
}
/*Klocwork activity 1-Apr_2014 end*/

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
*  FUNCTION NAME: rrm_ue_update_meas_context_list_for_geran
*  INPUT      : p_cell_context
*  OUTPUT     : none
*  DESCRIPTION:
*  RETURNS:
*              RRM_SUCCESS/RRM_FAILURE
*******************************************************************************/

static rrm_void_t
rrm_ue_update_meas_context_list_for_geran(
        rrm_cell_context_t              *p_cell_context
        )
{
    meas_geran_context_list_t       *p_meas_geran_list  = RRM_PNULL;
    meas_geran_node_t               *p_meas_geran_node  = RRM_PNULL;

    YLNODE                          *p_node             = RRM_PNULL;
    S8                              cell_ctx_index      = FREQ_NOT_CONFIGURED;
    U8                              index               = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_meas_geran_list  = &(p_cell_context->meas_geran_list);

    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_geran_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_geran_node =  YMEMBEROF(meas_geran_node_t, sNode, p_node);
        cell_ctx_index = rrmcm_search_geran_arfcn_in_cell_context(p_cell_context,
                p_meas_geran_node->geran_config.starting_arfcn,
                p_meas_geran_node->geran_config.band_ind);

        if(CELL_STATE_W_FOR_CELL_RECONFIG_RESP == p_cell_context->cell_state)
        {
            if((INVALID_OFFSET_FREQ == p_meas_geran_node->geran_config.prev_offset_frequency)
                    || (FREQ_NOT_CONFIGURED == cell_ctx_index))
            {
                p_meas_geran_node->cell_ctx_index = FREQ_NOT_CONFIGURED;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Skipping this node(Awaiting Cell Reconfig Resp)");
            }
            else
            {
                p_meas_geran_node->cell_ctx_index = cell_ctx_index;
            }
        }
        /* If Reconfig is not currently triggered */
        else
        {
            /* If freq is configured at RRM */
            if(FREQ_NOT_CONFIGURED != cell_ctx_index) 
            {
                p_meas_geran_node->cell_ctx_index = cell_ctx_index;
                p_meas_geran_node->geran_config.prev_offset_frequency = 
                    p_meas_geran_node->geran_config.offset_frequency;
            } 
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Deleting node for GERAN ARFCN = %d", 
                        p_meas_geran_node->geran_config.starting_arfcn);
                /* Delete the node as this freq is not configured at RRM */
                rrm_list_delete_node(p_meas_geran_list, p_node);        
                RRM_MEM_FREE(p_meas_geran_node);
            }
        }
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }
    RRM_UT_TRACE_EXIT();
}

/*Klocwork activity 1-Apr_2014 start*/
/******************************************************************************
*  FUNCTION NAME:rrm_ue_update_meas_context_list_for_cdma2000
*  INPUT      : p_cell_context
*  OUTPUT     : none
*  DESCRIPTION:
*  RETURNS:
*              RRM_SUCCESS/RRM_FAILURE
*******************************************************************************/

static rrm_void_t
rrm_ue_update_meas_context_list_for_cdma2000(
          rrm_cell_context_t              *p_cell_context
      )
{

    YLNODE                          *p_node             = RRM_PNULL;
    meas_cdma_context_list_t *p_meas_cdma2000_list = RRM_PNULL;
    S8                              cell_ctx_index      = FREQ_NOT_CONFIGURED;
    meas_cdma_node_t         *p_meas_cdma2000_node = RRM_PNULL;
    U8                              index               = RRM_NULL;
        
    RRM_UT_TRACE_ENTER();

    p_meas_cdma2000_list = &(p_cell_context->meas_cdma_list);
    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_cdma2000_list);

    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_cdma2000_node =  YMEMBEROF(meas_cdma_node_t, sNode, p_node);
        cell_ctx_index = rrmcm_search_cdma_arfcn_in_cell_context_in_ncl_params(
                p_cell_context,
                p_meas_cdma2000_node->cdma_config.arfcn,
                p_meas_cdma2000_node->cdma_config.band_class);


        if(CELL_STATE_W_FOR_CELL_RECONFIG_RESP == p_cell_context->cell_state)
        {
            if((INVALID_OFFSET_FREQ == p_meas_cdma2000_node->cdma_config.prev_offset_frequency)
                    || (FREQ_NOT_CONFIGURED == cell_ctx_index))
            {
                p_meas_cdma2000_node->cell_ctx_index = FREQ_NOT_CONFIGURED;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Skipping this node(Awaiting Cell Reconfig Resp)");
            }
            else
            {
                p_meas_cdma2000_node->cell_ctx_index = cell_ctx_index;
            }
        }
        /* If Reconfig is not currently triggered */
        else
        {
            /* If freq is configured at RRM */
            /* klocwork_27Mar: Start */
            /* Max value of cdma2000_freq_cells[] is RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS. Hence cell_ctx_index check
               introduced in below condition */
            if((FREQ_NOT_CONFIGURED != cell_ctx_index) && (cell_ctx_index < RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS))
            /* klocwork_27Mar: End */
            {
                p_meas_cdma2000_node->cell_ctx_index = cell_ctx_index;
                p_meas_cdma2000_node->cdma_config.cdma_type = 
                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                    cdma2000_freq_cells[cell_ctx_index].type;
                    p_meas_cdma2000_node->cdma_config.prev_offset_frequency =
                    p_meas_cdma2000_node->cdma_config.offset_frequency;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Deleting node for CDMA ARFCN = %d",
                        p_meas_cdma2000_node->cdma_config.arfcn);
                /* Delete the node as this freq is not configured at RRM */
                rrm_list_delete_node(p_meas_cdma2000_list, p_node);
                RRM_MEM_FREE(p_meas_cdma2000_node);
            }
        }
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }
 RRM_UT_TRACE_EXIT();
}

/*Klocwork activity 1-Apr_2014 end*/

/******************************************************************************
*  FUNCTION NAME: rrm_ue_update_meas_context_list 
*  INPUT      : p_cell_context
*  OUTPUT     : none
*  DESCRIPTION:
*  RETURNS:
*              RRM_SUCCESS/RRM_FAILURE
*******************************************************************************/

static rrm_void_t
rrm_ue_update_meas_context_list(
        rrm_cell_context_t              *p_cell_context
        )
{
    meas_eutran_context_list_t      *p_meas_eutran_list = RRM_PNULL;
    meas_eutran_node_t              *p_meas_eutran_node = RRM_PNULL;

    YLNODE                          *p_node             = RRM_PNULL;
    S8                              cell_ctx_index      = FREQ_NOT_CONFIGURED;
    U8                              index               = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_meas_eutran_list = &(p_cell_context->meas_eutran_list);

    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_eutran_list);
    for(index = 0; RRM_PNULL != p_node; index++)
    {
        p_meas_eutran_node =  YMEMBEROF(meas_eutran_node_t, sNode, p_node);
        if(p_meas_eutran_node->eutran_config.earfcn == 
                p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
	    {
            cell_ctx_index = RRM_SERV_CELL_FREQ;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Node contains the Serving cell freq");
        }
        else
        {
            cell_ctx_index = rrmcm_search_earfcn_in_cell_context(p_cell_context,
                    p_meas_eutran_node->eutran_config.earfcn);
        }
        if(CELL_STATE_W_FOR_CELL_RECONFIG_RESP == p_cell_context->cell_state)
        {
            if((INVALID_OFFSET_FREQ == p_meas_eutran_node->eutran_config.prev_offset_frequency)
                    || (FREQ_NOT_CONFIGURED == cell_ctx_index))
            {
                p_meas_eutran_node->cell_ctx_index = FREQ_NOT_CONFIGURED;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Skipping this node(Awaiting Cell Reconfig Resp)");
            }
            else
            {
                p_meas_eutran_node->cell_ctx_index = cell_ctx_index;
            }
        }
        /* If Reconfig is not currently triggered */
        else
        {
            /* If freq is configured at RRM */
            if(FREQ_NOT_CONFIGURED != cell_ctx_index) 
            {
                p_meas_eutran_node->cell_ctx_index = cell_ctx_index;
                p_meas_eutran_node->eutran_config.prev_offset_frequency = 
                    p_meas_eutran_node->eutran_config.offset_frequency;
            } 
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Deleting node for EARFCN = %d", 
                        p_meas_eutran_node->eutran_config.earfcn);
                /* Delete the node as this freq is not configured at RRM */
                rrm_list_delete_node(p_meas_eutran_list, p_node);        
                RRM_MEM_FREE(p_meas_eutran_node);
            }
        }
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }

    /*Klocwork activity 1-Apr_2014 start*/
    rrm_ue_update_meas_context_list_for_utran(
         p_cell_context);
    
    rrm_ue_update_meas_context_list_for_geran(
            p_cell_context
            );
    rrm_ue_update_meas_context_list_for_cdma2000(
     p_cell_context);
    /*Klocwork activity 1-Apr_2014 end*/
    

    RRM_UT_TRACE_EXIT();
}

/* CSR 59124 Delete */

/******************************************************************************
*   FUNCTION NAME: rrm_find_obj_in_ue_meas_config
*   INPUT      : rat_type,arfcn,band_ind,band_classband_class,p_meas_config_info 
*   OUTPUT     : none
*   DESCRIPTION: This function finds objects from ue meas config.
*   RETURNS    : p_meas_config_obj
*****************************************************************************/

rrm_ue_meas_config_t*
rrm_find_obj_in_ue_meas_config(
/*Fix SPR 5515 Start */
            rrm_rat_type_et              rat_type,
            U16                          arfcn,
            U8                           band_ind,
            U8                          band_class,
/*Fix SPR 5515 End */            
            rrm_ue_meas_config_t        *p_meas_config_info
        )
{
    U8          id_index = RRM_ZERO;
    rrm_ue_meas_config_t    *p_meas_config_obj = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /*klok_fix_start_8558*/
    if (RRM_PNULL != p_meas_config_info)
    /*klok_fix_end_8558*/
    {
        for(id_index = RRM_ZERO; id_index < RRM_ANR_MAX_MEAS_OBJ; id_index++)
        {
        /* Spr 18401 Changes Start */
            if((p_meas_config_info[id_index].rat_type == rat_type) &&
                    (p_meas_config_info[id_index].carr_freq == arfcn) && 
                (RRM_GERAN_CELL != rat_type) && ((RRM_CDMA_CELL != rat_type) || 
                        (p_meas_config_info[id_index].band_class == band_class))
              ) 
            {
                p_meas_config_obj = &(p_meas_config_info[id_index]);
                /* Fix SPR 5515 Start*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Meas Object exists for freq = %d meas_id = %d, obj_id = %d",
                        arfcn, p_meas_config_obj->meas_id, p_meas_config_obj->meas_obj_id);

                /* Fix SPR 5515 End*/
                break;
            }
        else if ((RRM_GERAN_CELL == rat_type) && 
                (p_meas_config_info[id_index].band_ind == band_ind))
        {

            if(RRM_TRUE == check_geran_carrier_freq(
                                     p_meas_config_info[id_index].following_arfcns,
                                     p_meas_config_info[id_index].carr_freq,
                                     arfcn))
            {
                p_meas_config_obj = &(p_meas_config_info[id_index]);
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Meas Object exists for freq = %d meas_id = %d, obj_id = %d",
                        arfcn, p_meas_config_obj->meas_id, p_meas_config_obj->meas_obj_id);
                break;
            }

        }
        /* Spr 18401 Changes End */
    }
}
    RRM_UT_TRACE_EXIT();
    return p_meas_config_obj;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_ue_meas_id_config_info
 *   INPUT      : p_meas_config_obj,meas_id,meas_obj_id,report_id,rat_type,
 *                carr_freq,band_ind,band_class
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Fills the meas configuration corresponding to the Meas ID in UE context
 * 
 *   RETURNS:
 *          None
 *****************************************************************************/
static rrm_void_t
rrm_fill_ue_meas_id_config_info(
    rrm_ue_meas_config_t            *p_meas_config_obj,
    U8                              meas_id,
    U8                              meas_obj_id,
    U8                              report_id,
    rrm_rat_type_et                 rat_type,
        U32                             carr_freq,
    rrm_son_geran_band_indicator_et band_ind, 
    rrm_son_cdma_band_class_et              band_class
)
{
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(p_meas_config_obj != RRM_PNULL);

    p_meas_config_obj->meas_id = meas_id;
    p_meas_config_obj->meas_obj_id = meas_obj_id;
    p_meas_config_obj->report_id = report_id;
    p_meas_config_obj->rat_type = rat_type;
    p_meas_config_obj->carr_freq = carr_freq;
    p_meas_config_obj->band_ind = band_ind;

    p_meas_config_obj->band_class = band_class;
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_generate_config_id
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       This function generates the ID to be used as meas object ID and meas Id
 *
 *   RETURNS:
 *          Config ID generated
 *****************************************************************************/
static U8
rrm_ue_generate_config_id(
        rrm_ue_context_t       *p_ue_context
        )
{
    RRM_UT_TRACE_ENTER();
    p_ue_context->config_id++;
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Config ID generated = %d", p_ue_context->config_id);

    RRM_UT_TRACE_EXIT();
    return p_ue_context->config_id;
}
/* SPR 12971 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_delete_previous_meas_obj_and_populate_remove_list 
 *
 *   DESCRIPTION:
 *       This function populates Meas Objects created by UE in previous timer expiry
 *       in the Remove Obj list of Meas Config Req for RRC
 *
 *   RETURNS: None
 *****************************************************************************/
static rrm_void_t
rrm_delete_previous_meas_obj_and_populate_remove_list(
        rrm_cell_context_t              *p_cell_ctx,
        rrm_ue_meas_config_t            *p_meas_config_info,
        rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req
)
{
    U8          id_index = RRM_ZERO;
  /* SPR 18194 fix start */
    U8          i = RRM_ZERO;
    rrm_bool_et report_id_found     = RRM_FALSE;
    /* SPR 18194 fix stop */

    RRM_UT_TRACE_ENTER();

    for(id_index = RRM_ZERO; id_index < RRM_ANR_MAX_MEAS_OBJ; id_index++)
    {
        if(RRM_CELL_UNDEFINED != p_meas_config_info[id_index].rat_type)
        {
		    if(p_meas_config_info[id_index].carr_freq != 
                p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn)
	        {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Meas Object to be removed for freq = %d meas_id = %d, obj_id = %d\n"
                        "Adding in Obj Remove List",
                        p_meas_config_info[id_index].carr_freq, p_meas_config_info[id_index].meas_id,
                        p_meas_config_info[id_index].meas_obj_id);

                /* Add meas object in remove list */
                p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.
                    meas_object_id[p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count] =
                    p_meas_config_info[id_index].meas_obj_id;
                p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count++;
                p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT;
                /* SPR 16053 start */
                p_meas_config_info[id_index].obj_created_at_ue = RRM_FALSE;
                p_meas_config_info[id_index].meas_config_status = RRM_MEAS_CONFIG_TO_DELETE;
                /* SPR 16053 end */

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Not removing Meas Object for serving freq");
            }
 	/* SPR 18194 fix start */
		for (i = RRM_ZERO; i < p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count; i++)
		{
			if (p_meas_config_info[id_index].report_id ==
					p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[i])
			{
				report_id_found = RRM_TRUE;
				break;
			}
		}
        /* Spr 18488 Changes Start */
		if ((RRM_FALSE == report_id_found)&&(p_meas_config_info[id_index].report_id != RRM_NULL))
        /* Spr 18488 Changes End */    
		{
			p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count]
				= p_meas_config_info[id_index].report_id;
			p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count++;
			p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;
		} 
		/* SPR 18194 fix stop */
       }
        else
        {
            break;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 12971 End */

/*Klockwork_fix_2431_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_eutran_meas_config_req
 *   INPUT      : p_cell_context, p_ue_context, obj_fill_info, obj_space_left,
 *   p_eutran_list_valid_count
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for strongest cell reporting.
 *
 *   RETURNS:
 *          Total no. of meas objects for which configuration has been filled
 *****************************************************************************/
U8
rrm_ue_fill_eutran_meas_config_req(rrm_cell_context_t         *p_cell_context,
                                   rrm_ue_context_t           *p_ue_context,
                                   rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req,
 /*SPR_FIX_START :12574*/                                   
                                   U8                         *meas_report_index,
 /*SPR_FIX_END :12574*/
                                   U8                         *index,
                                   /*SPR 14326 start*/
                                   rrm_bool_et                 *send_measgap                                   
                                   /*SPR 14326 End*/
                                   )
 {
        meas_eutran_context_list_t      *p_meas_eutran_list = RRM_PNULL;
        meas_eutran_node_t              *p_meas_eutran_node = RRM_PNULL;
        rrm_ue_meas_config_t            *p_meas_config_obj  = RRM_PNULL;
        YLNODE                          *p_node             = RRM_PNULL;
        U8                              eutran_count        = RRM_NULL;
        U8                              meas_id             = RRM_NULL;
    U8  	                        meas_obj_id	        = RRM_NULL;
        U8                              meas_obj_index      = RRM_NULL;
    rrm_trigger_type_periodical_purpose_et
        purpose = RRM_RRC_REPORT_STRONGEST_CELLS;

        RRM_UT_TRACE_ENTER();

        RRM_ASSERT(RRM_PNULL != p_cell_context);     /* Klocwork_fix_27_aug */    
        p_meas_eutran_list = &(p_cell_context->meas_eutran_list);

        p_node = (YLNODE*)rrm_get_first_list_node(p_meas_eutran_list);

        if(!(UE_SUPPORT_INTRAFREQ_RAT & p_ue_context->supported_rats))
        {
            p_node = (YLNODE*)rrm_get_next_list_node(p_node);
            eutran_count = MAX_SON_MEAS_CONFIG_OBJECT;
        }
        else if(!(UE_SUPPORT_INTERFREQ_RAT & p_ue_context->supported_rats))
        {
            eutran_count = RRM_ONE;
        }
        else
        {
            eutran_count = MAX_SON_MEAS_CONFIG_OBJECT;
        }

        /* Populate EUTRAN configuration to be sent to RRC */
        while(((*index) < eutran_count) && (RRM_PNULL != p_node))
        {
            p_meas_eutran_node =  YMEMBEROF(meas_eutran_node_t, sNode, p_node);
            /* SPR 16406 8SEP start */
            /* If freq is configured at RRM */
            if(FREQ_NOT_CONFIGURED != p_meas_eutran_node->cell_ctx_index)
            {
                 if((RRM_TRUE == rrm_is_anr_allowed_on_eutran_freq(p_ue_context, p_meas_eutran_node->eutran_config.earfcn))
                 /* SPR 12897 Start */
                 && (RRM_ZERO != rrm_ue_is_ue_supported_eutra_frequency (
                 /* SPR 12897 End */
                     p_meas_eutran_node->eutran_config.earfcn, p_ue_context)))
             {
                /* SPR 16406 8SEP end */
                /* SPR 12971 Start */
                meas_id = rrm_ue_generate_config_id(p_ue_context);
                /* SPR 12971 End */

                /* Store the Status parameters for meas req corresponding to the earfcn 
                   at index (meas_id - RRM_MEAS_OBJ_ID_OFFSET) where all the status 
                   params corresponding to meas_id are stored */
                /* Klocwork_fix_start : meas_config */
                if ((meas_id >= RRM_ONE) && (meas_id <= RRM_ANR_MAX_MEAS_OBJ))
                {
                    /* Klocwork_fix_end : meas_config */
                    p_meas_config_obj = &(p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
                    /* Klocwork_fix_start : meas_config */
                    /*CID:88454 Fix Start*/
                    /* Coverity_ID : 31038, 31039 */
                    rrm_fill_ue_meas_id_config_info(p_meas_config_obj, meas_id, RRM_ZERO, REPORT_CONFIG_ID, 
                            RRM_EUTRAN_CELL, p_meas_eutran_node->eutran_config.earfcn, RRM_SON_GERAN_DCS_1800, 
                            RRM_SON_BAND_CLASS_BC_0);
                    if(p_meas_eutran_node->eutran_config.earfcn == 
                            p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn) 
	                {
                        rrm_search_ho_meas_object(p_ue_context, 
                                p_meas_eutran_node->eutran_config.earfcn, &meas_obj_id);

                        /* RITIKA 5376 FIX Start*/
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "For intra freq = %d HO created Meas object id = %d", 
                                p_meas_eutran_node->eutran_config.earfcn, meas_obj_id);

                        p_meas_config_obj->meas_obj_id = meas_obj_id;
                    }
                    else
                    {
                        p_meas_config_obj->meas_obj_id = meas_id;
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Creating Inter-freq meas object for ANR, meas_obj_id = %d", meas_id);
                        /* Fill EUTRAN meas config (meas object & meas id ) */
                        fill_eutran_object_meas_config_list(p_cell_context, p_meas_eutran_node,
                                &p_rrc_rrm_meas_config_req->meas_config, 
                                /*SPR 17777 +-*/
                                meas_obj_index, p_meas_config_obj);

                        meas_obj_index++;
                    }
                    /* SPR 12971 Delete */
                    /* Fix SPR 5515 Start*/

                    p_meas_config_obj->meas_config_status = RRM_MEAS_CONFIG_REQ_SENT; 

                    /* Fix SPR 5515 End */

                    /* Fill meas_id_to_add_mod_list */
                    fill_meas_id_to_add_mod_list(&p_rrc_rrm_meas_config_req->meas_config.
                            meas_id_to_add_mod_list.meas_id_to_add_mod[(*index)], p_meas_config_obj);
                    /*SPR 15314 Start*/
                    p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter = RRM_TWO;
                    /*SPR 17061 Start*/
                    /*SPR 15835:Start*/
                    /* SPR 16053 start */
                    p_ue_context->temp_report_amt_ue += RRM_MAX_STRONGEST_CELL_RPT;
                    /* SPR 16053 end */

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "\nREPORT COUNTER VALUE FOR Strongest Cell meas_id[%d]=%d,GLOBAL UE report amount=%d temp_report_amt=%d",
                            meas_id,
                            p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter,
                            p_ue_context->report_amount_ue,
                            p_ue_context->temp_report_amt_ue);
                    /*SPR 15835:End*/
                    /*SPR 17061 End*/
                    /*SPR 15314 End*/

                    (*index)++;
                    /* CP 10-FEB-2013 STOP SPR 5376*/
                    /* SPR 14326 Fix Start */
                    if( RRM_FALSE == *send_measgap )
                    {
                        *send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                                .rf_configurations.dl_earfcn ,
                                p_meas_eutran_node->eutran_config.earfcn,
                                p_ue_context,
                                INTER_FREQ_BAND_LIST,
                                EUTRA_FREQ,
                                RRM_PNULL
                                );
                    }
                    /* SPR 14326 Fix End */
                    /*CID:88454 Fix Start*/



                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            " Invalid meas_id [%d] recieved ", meas_id);
                }

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "EARFCN = %d NOT configured at RRM (Awaiting Reconfig Resp)",
                        p_meas_eutran_node->eutran_config.earfcn);
            }
            /* SPR 16406 8SEP start */
            }
            /* SPR 16406 8SEP end */

            p_node = (YLNODE*)rrm_get_next_list_node(p_node);
        }
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "no. of nodes processed in EUTRAN list = %d", (*index));
        
        /* SPR 14326 Fix Start */
        if( RRM_TRUE == *send_measgap )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Send MEAS GAP for EUTRAN");
            p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "NO need to send MEAS GAP for EUTRAN");
            p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
        }
        /* SPR 14326 Fix End */

        /* Fix for SPR-5360 Start */
        if(RRM_NULL < (*index))
        {
            if(!(REPORT_CONFIG_EUTRA_SENT & p_ue_context->meas_config_sent_bitmask))
            {
                /* Fill report_config_to_add_mod_list */
                 /*SPR_FIX_START :12574*/
                fill_eutran_report_config_to_add_mod_list( 
                        &p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.
                        report_config_to_add_mod[(*meas_report_index)], purpose, REPORT_CONFIG_ID);
                (*meas_report_index)++;
                 /*SPR_FIX_END :12574*/
                p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_EUTRA_SENT;
            }
            if(!(QUANTITY_CONFIG_EUTRA_SENT & p_ue_context->meas_config_sent_bitmask))
            {
                /* SPR 16880: start */
                fill_quantity_config_eutra(&p_rrc_rrm_meas_config_req->meas_config.quantity_config, p_ue_context);
                /* SPR 16880: end */
                p_ue_context->meas_config_sent_bitmask |= QUANTITY_CONFIG_EUTRA_SENT;

                p_rrc_rrm_meas_config_req->meas_config.bitmask |=
                    UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT;
            }
        }
        RRM_UT_TRACE_EXIT();
        return meas_obj_index;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_utra_fdd_meas_config_req
 *   INPUT      : p_cell_context, p_ue_context, obj_fill_info, obj_space_left,
 *   p_eutran_list_valid_count, p_utran_list_valid_count,
 *   p_geran_list_valid_count, p_cdma2000_list_valid_count, req_index_offset,
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for strongest cell reporting.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
U8
rrm_ue_fill_utra_fdd_meas_config_req(rrm_cell_context_t              *p_cell_context,
                                     rrm_ue_context_t           *p_ue_context,
                                     rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req,
                                     /*SPR_FIX_START :12574*/
                                     /*SPR_FIX_END_12574*/
                                     U8                         *index,
                                     /*SPR 14326 start*/
                                     rrm_bool_et                 *send_measgap
                                     /*SPR 14326 End*/
                                      
                                     )
{
    meas_utran_node_t               *p_meas_utran_node  = RRM_PNULL;
    YLNODE                          *p_node             = RRM_PNULL;
    meas_utran_context_list_t       *p_meas_utran_list  = RRM_PNULL;
    rrm_ue_meas_config_t            *p_meas_config_obj  = RRM_PNULL;
    U8                              meas_id             = RRM_NULL;
    U8                              meas_obj_index      = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_context);   /* Klocwork_fix_27_aug */
    p_meas_utran_list  = &(p_cell_context->meas_utran_list);
    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_utran_list);
    /* Populate UTRAN configuration to be sent to RRC */
    while(((*index) < MAX_SON_MEAS_CONFIG_OBJECT) && (RRM_PNULL != p_node))
    {
        p_meas_utran_node =  YMEMBEROF(meas_utran_node_t, sNode, p_node);

        /* If freq is configured at RRM */
        /* SPR 22731 Fix Start */
        if((FREQ_NOT_CONFIGURED != p_meas_utran_node->cell_ctx_index) &&
                (RRM_TRUE == rrm_ue_is_ue_supported_utra_fdd_frequency (
                                                                    p_meas_utran_node->utran_config.uarfcn, p_ue_context)))
            /* SPR 22731 Fix End */
        {
            /* SPR 12971 Start */
            meas_id = rrm_ue_generate_config_id(p_ue_context);
            /* SPR 12971 End */
            /* End: Enh 317 */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Creating Utran meas object for ANR, meas_obj_id = %d", meas_id);
            /* Store the Status parameters for meas req corresponding to the uarfcn 
               at index (meas_id - RRM_MEAS_OBJ_ID_OFFSET) where all the status
               params corresponding to meas_id are stored  */
            /* Klocwork_fix_start : meas_config */
            if ((meas_id >= RRM_ONE) && (meas_id <= RRM_ANR_MAX_MEAS_OBJ))
            {
                /* Klocwork_fix_end : meas_config */
                p_meas_config_obj = &(p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
                /*Coverity 93946 Fix Start */
                /* Klocwork_fix_start : meas_config */
                    /*SPR 15724:Start*/
                    p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter = RRM_ONE;
            /* Klocwork_fix_end : meas_config */
            /* Coverity_ID : 31040, 31041 */
            rrm_fill_ue_meas_id_config_info(p_meas_config_obj, meas_id, meas_id, REPORT_CONFIG_INTERRAT_UTRAN_CDMA_ID, 
                    RRM_UTRAN_CELL, p_meas_utran_node->utran_config.uarfcn, RRM_SON_GERAN_DCS_1800, RRM_SON_BAND_CLASS_BC_0);

            /* Fill meas_object_to_add_mod_list */
            /*SPR 17777 +-*/
            fill_utran_meas_object_to_add_mod_list( p_meas_utran_node,
                    &(p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.
                        meas_object_to_add_mod[meas_obj_index]), 
                    p_meas_config_obj->meas_obj_id);

            meas_obj_index++;
            /* SPR 12971 Delete */
            p_meas_config_obj->meas_config_status = RRM_MEAS_CONFIG_REQ_SENT; 

            /* Fill meas_id_to_add_mod_list */
            fill_meas_id_to_add_mod_list(&p_rrc_rrm_meas_config_req->meas_config.
                    meas_id_to_add_mod_list.meas_id_to_add_mod[(*index)], 
                    p_meas_config_obj);
                /*SPR 15724:End*/
                /*Coverity 93946 Fix End */
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        " Invalid meas_id [%d] recieved ", meas_id);
            }
            /*Coverity 93946 Fix code moved */

            (*index)++;
            /* SPR 14326 Fix Start */
            if( RRM_FALSE == *send_measgap )
            {
                  *send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                                .rf_configurations.dl_earfcn ,
                                p_meas_utran_node->utran_config.uarfcn,
                                p_ue_context,
                                INTER_RAT_BAND_LIST,
                                UTRAN_FDD_FREQ,
                                RRM_PNULL
                                );
            }
            /* SPR 14326 Fix End */


        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "FDD UARFCN = %d NOT configured at RRM (Awaiting Reconfig Resp)",
                    p_meas_utran_node->utran_config.uarfcn);
        }	
        /* Fetch the next node */
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }
    /* TDD Support SON Start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "no. of nodes processed in FDD UTRAN list = %d", 
            (*index));
   /* SPR 14326 Fix Start */
   if( RRM_TRUE == *send_measgap )
   {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                 "Send MEAS GAP for UTRA FDD");
       p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
   }
   else
   {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                 "NO need to send MEAS GAP for UTRA FDD");
       p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
   }
   /* SPR 14326 Fix End */

    RRM_UT_TRACE_EXIT();
    return meas_obj_index;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_utra_tdd_meas_config_req
 *   INPUT      : p_cell_context, p_ue_context, obj_fill_info, obj_space_left,
 *    p_utran_list_valid_count,
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for strongest cell reporting.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
U8
rrm_ue_fill_utra_tdd_meas_config_req(rrm_cell_context_t         *p_cell_context,
        rrm_ue_context_t           *p_ue_context,
        rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req,
        /*SPR_FIX_START :12574*/
        /*SPR_FIX_END_12574*/
        U8                         *index,
        /*SPR 14326 start*/
        rrm_bool_et                 *send_measgap
        /*SPR 14326 End*/
)
{
    /*CID 65756:start*/
    /* TDD Support SON Start */
    meas_utran_tdd_context_list_t   *p_meas_utran_tdd_list  = RRM_PNULL;
    meas_utran_tdd_node_t           *p_meas_utran_tdd_node  = RRM_PNULL;
    rrm_ue_meas_config_t            *p_meas_config_obj  = RRM_PNULL;
    U8                              meas_id             = RRM_NULL;
    YLNODE                          *p_node             = RRM_PNULL;
    U8                              meas_obj_index      = RRM_NULL;
    /* TDD Support SON End */
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_context);   /* Klocwork_fix_27_aug */

    p_meas_utran_tdd_list  = &(p_cell_context->meas_utran_tdd_list);
    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_utran_tdd_list);
    while(((*index) < MAX_SON_MEAS_CONFIG_OBJECT) && (RRM_PNULL != p_node))
    {
        p_meas_utran_tdd_node =  YMEMBEROF(meas_utran_tdd_node_t, sNode, p_node);

        /* If freq is configured at RRM */
        /* SPR 22731 Fix Start */
        if((FREQ_NOT_CONFIGURED != p_meas_utran_tdd_node->cell_ctx_index) 
                && (RRM_TRUE == rrm_ue_is_ue_supported_utra_tdd_frequency (
                        p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd, p_ue_context)))
            /* SPR 22731 Fix End */
        {
            /* SPR 12971 Start */
            meas_id = rrm_ue_generate_config_id(p_ue_context);
            /* SPR 12971 End */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Creating TDD Utran meas object for ANR, meas_obj_id = %d", meas_id);
            /* Store the Status parameters for meas req corresponding to the uarfcn 
               at index (meas_id - RRM_MEAS_OBJ_ID_OFFSET) where all the status
               params corresponding to meas_id are stored  */
            /* Coverity_ID : 31040, 31041 */
            /* klocwork_27Mar: Start */
            if ((meas_id >= RRM_ONE) && (meas_id <= RRM_ANR_MAX_MEAS_OBJ))
            {
                /* Klocwork_fix_end : meas_config */
                p_meas_config_obj = &(p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
                /* Klocwork_fix_start : meas_config */
            }
            else
            {
/* coverity_96891 start */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        " Invalid meas_id [%d] recieved ", meas_id);
                return meas_obj_index;
/* coverity_96891 stop */
            }
            /* klocwork_27Mar: End */
            rrm_fill_ue_meas_id_config_info(p_meas_config_obj, meas_id, meas_id, REPORT_CONFIG_INTERRAT_UTRAN_CDMA_ID, 
                    RRM_UTRAN_TDD_CELL, p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd, RRM_SON_GERAN_DCS_1800, RRM_SON_BAND_CLASS_BC_0);

            /* Fill meas_object_to_add_mod_list */
            fill_utran_tdd_meas_object_to_add_mod_list(p_meas_utran_tdd_node,
                    &(p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.
                        meas_object_to_add_mod[meas_obj_index]), 
                    p_meas_config_obj->meas_obj_id);

            meas_obj_index++;
            /*Coverity_fix_end_62518*/ 
            /* SPR 12971 Delete */
            p_meas_config_obj->meas_config_status = RRM_MEAS_CONFIG_REQ_SENT; 

            /* Fill meas_id_to_add_mod_list */
            fill_meas_id_to_add_mod_list(&p_rrc_rrm_meas_config_req->meas_config.
                    meas_id_to_add_mod_list.meas_id_to_add_mod[(*index)], 
                    p_meas_config_obj);

            (*index)++;
            /* SPR 14326 Fix Start */
            if( RRM_FALSE == *send_measgap )
            {
                   *send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                                .rf_configurations.dl_earfcn ,
                                p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd,
                                p_ue_context,
                                INTER_RAT_BAND_LIST,
                                UTRAN_TDD_FREQ,
                                RRM_PNULL
                                );
            }
           /* SPR 14326 Fix End */

                /*SPR 15724:Start*/
                p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter = RRM_ONE;
                /*SPR 15724:End*/

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "TDD UARFCN = %d NOT configured at RRM (Awaiting Reconfig Resp)",
                    p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd);
        }	
        /* Fetch the next node */
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);

    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "no. of nodes processed in TDD UTRAN list = %d", 
            (*index));
    /* TDD Support SON End */
        /* SPR 14326 Fix Start */
        if( RRM_TRUE == *send_measgap )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Send MEAS GAP for UTRA TDD");
            p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "NO need to send MEAS GAP for UTRA TDD");
            p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
        }
        /* SPR 14326 Fix End */

    RRM_UT_TRACE_EXIT();
    return meas_obj_index;
    /*CID 65756:end*/
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_geran_meas_config_req
 *   INPUT      : p_cell_context, p_ue_context, obj_fill_info, obj_space_left,
 *    p_geran_list_valid_count,
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for strongest cell reporting.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
U8
rrm_ue_fill_geran_meas_config_req(rrm_cell_context_t         *p_cell_context,
        rrm_ue_context_t           *p_ue_context,
        rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req,
        /*SPR_FIX_START :12574*/
        U8                         *meas_report_index,
        /*SPR_FIX_END :12574*/
        U8                         *index,
        /*SPR 14326 start*/
        rrm_bool_et                 *send_measgap
        /*SPR 14326 End*/)
{
    /*CID 65755:start*/
    meas_geran_context_list_t       *p_meas_geran_list  = RRM_PNULL;
    meas_geran_node_t               *p_meas_geran_node  = RRM_PNULL;
    rrm_ue_meas_config_t            *p_meas_config_obj  = RRM_PNULL;
    U8                              meas_id             = RRM_NULL;
    rrm_interrat_trigger_type_periodical_purpose_et interrat_purpose
        = RRM_INTERRAT_REPORT_STRONGEST_CELLS;
    YLNODE                          *p_node             = RRM_PNULL;
    U8                              meas_obj_index      = RRM_NULL;     
    RRM_UT_TRACE_ENTER();

    p_meas_geran_list  = &(p_cell_context->meas_geran_list);
    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_geran_list);
    while(((*index) < MAX_SON_MEAS_CONFIG_OBJECT)&& (RRM_PNULL != p_node))
        /* TDD Support SON End */
        /* SPR 7514 Fix End - report config 924 */
    {
        p_meas_geran_node =  YMEMBEROF(meas_geran_node_t, sNode, p_node);

        /* If freq is configured at RRM */
        if((FREQ_NOT_CONFIGURED != p_meas_geran_node->cell_ctx_index)
                && (RRM_TRUE == rrm_ue_is_ue_supported_geran_frequency (
                        p_meas_geran_node->geran_config.starting_arfcn, p_ue_context)))
        {
            /* SPR 12971 Start */
            meas_id = rrm_ue_generate_config_id(p_ue_context);
            /* SPR 12971 End */
            /* Store the Status parameters for meas req corresponding to the uarfcn
               at index (meas_id - RRM_MEAS_OBJ_ID_OFFSET) where all the status
               params corresponding to meas_id are stored  */
            /* Klocwork_fix_start : meas_config */
            if ((meas_id >= RRM_ONE) && (meas_id <= RRM_ANR_MAX_MEAS_OBJ))
            {
                /* Klocwork_fix_end : meas_config */
                p_meas_config_obj = &(p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
                /* Klocwork_fix_start : meas_config */
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        " Invalid meas_id [%d] recieved ", meas_id);
                /* Coverity_fix_start_62534 */
                /* SPR 16406 8SEP start */
                 RRM_UT_TRACE_EXIT();
                 return *index;
                /* SPR 16406 8SEP end */
                /* Coverity_fix_end_62534 */
            }
            /* Klocwork_fix_end : meas_config */
            rrm_fill_ue_meas_id_config_info(p_meas_config_obj, meas_id, meas_id, REPORT_CONFIG_INTERRAT_ID, 
                    RRM_GERAN_CELL, p_meas_geran_node->geran_config.starting_arfcn, 
                    p_meas_geran_node->geran_config.band_ind, RRM_SON_BAND_CLASS_BC_0);/* coverity : CID 31043 */

                /* Spr 18401 Changes Start */
                RRM_MEMCPY(&p_meas_config_obj->following_arfcns, &p_cell_context->ran_info.mobility_params.
                                idle_mode_mobility_params.idle_mode_mobility_irat_geran_params.
                                irat_eutran_to_geran_list.
                                irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
				                geran_car_freqs.following_arfcns, sizeof(rrm_son_geran_following_arfcns_t));
                /* Spr 18401 Changes End */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Creating GERAN meas object for ANR, meas_obj_id = %d", meas_id);
            /* Fill meas_object_to_add_mod_list */
            fill_geran_meas_object_to_add_mod_list(p_cell_context, p_meas_geran_node,
                    &(p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.
                        meas_object_to_add_mod[meas_obj_index]),
                    p_meas_config_obj->meas_obj_id);

            meas_obj_index++;

            /* SPR 12971 Start */
            /* Coverity 62534 */       
            /* Cov_fix_62518_start*/
            p_meas_config_obj->meas_config_status = RRM_MEAS_CONFIG_REQ_SENT;

            /* Fill meas_id_to_add_mod_list */
            fill_meas_id_to_add_mod_list(&p_rrc_rrm_meas_config_req->meas_config.
                    meas_id_to_add_mod_list.meas_id_to_add_mod[(*index)],
                    p_meas_config_obj);
                /*SPR 15724:Start*/
                p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter = RRM_ONE;
                /*SPR 15724:End*/

            (*index)++;
            /* SPR 14326 Fix Start */
            if( RRM_FALSE == *send_measgap )
            {
                    *send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                            .rf_configurations.dl_earfcn ,
                            p_meas_geran_node->geran_config.starting_arfcn,
                            p_ue_context,
                            INTER_RAT_BAND_LIST,
                            GERAN_FREQ,
                            RRM_PNULL
                            );
            }
            /* SPR 14326 Fix End */
    

            /* Cov_fix_62518_end*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "GERAN freq = %d NOT configured at RRM (Awaiting Reconfig Resp)",
                    p_meas_geran_node->geran_config.starting_arfcn);
        }	
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "no. of nodes processed in GERAN list = %d", 
            /* TDD Support SON Start */
            (*index));
    /* TDD Support SON End */
    /* Fix for SPR-5360 Start */
    /* TDD Support SON Start */
   /* SPR 14326 Fix Start */
    if( RRM_TRUE == *send_measgap )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                   "Send MEAS GAP for GERAN");
        p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                   "NO need to send MEAS GAP for GERAN");
        p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
    }
    /* SPR 14326 Fix End */

    if(RRM_NULL < (*index))
        /* TDD Support SON End */
    {
        if(!(REPORT_CONFIG_INTERRAT_SENT & p_ue_context->meas_config_sent_bitmask))
        {
            /* Fill report_config_to_add_mod_list */
            /*SPR_FIX_START :12574*/            
            fill_interrat_report_config_to_add_mod_list(
                    /* SPR 12987 Start */
                    p_ue_context,
                    /* SPR 12987 End */
                    &p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.
                    report_config_to_add_mod[(*meas_report_index)], interrat_purpose,
                    REPORT_CONFIG_INTERRAT_ID);
            (*meas_report_index)++;
            /*SPR_FIX_END :12574*/
            p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_SENT;
        }

        if(!(QUANTITY_CONFIG_GERAN_SENT & p_ue_context->meas_config_sent_bitmask))
        {
                /* SPR 16880: start */
                fill_quantity_config_geran(&p_rrc_rrm_meas_config_req->meas_config.quantity_config, p_ue_context);
                /* SPR 16880: end */
            p_ue_context->meas_config_sent_bitmask |= QUANTITY_CONFIG_GERAN_SENT;

            p_rrc_rrm_meas_config_req->meas_config.bitmask |=
                UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT;
        }
    }
    RRM_UT_TRACE_EXIT();
    return meas_obj_index;
    /*CID 65755:end*/
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_cdma_meas_config_req
 *   INPUT      : p_cell_context, p_ue_context, obj_fill_info, obj_space_left,
 *    p_cdma_list_valid_count,
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for strongest cell reporting.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
U8
rrm_ue_fill_cdma_meas_config_req(rrm_cell_context_t         *p_cell_context,
        rrm_ue_context_t           *p_ue_context,
        rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req,
        rrm_interrat_trigger_type_periodical_purpose_et utran_cdma_purpose,
        /*SPR_FIX_START :12574*/
        U8                         *meas_report_index,
        /*SPR_FIX_END :12574*/
        U8                         *index,
        /*SPR 14326 start*/
        rrm_bool_et                 *send_measgap,
        rrm_cdma_meas_gap_config_t  *cdma_meas_gap_config
        /*SPR 14326 End*/)
{
    /*CID 65762:start*/
    meas_cdma_context_list_t        *p_meas_cdma2000_list  = RRM_PNULL;
    meas_cdma_node_t                *p_meas_cdma2000_node = RRM_PNULL;
    rrm_ue_meas_config_t            *p_meas_config_obj  = RRM_PNULL;
    U8  	                        meas_id	            = RRM_NULL;
    YLNODE                          *p_node             = RRM_PNULL;
    U8                              meas_obj_index      = RRM_NULL;        

    RRM_UT_TRACE_ENTER();
    p_meas_cdma2000_list = &(p_cell_context->meas_cdma_list);
    p_node = (YLNODE*)rrm_get_first_list_node(p_meas_cdma2000_list);
    while(((*index) < MAX_SON_MEAS_CONFIG_OBJECT) && (RRM_PNULL != p_node))
    {
        p_meas_cdma2000_node =  YMEMBEROF(meas_cdma_node_t, sNode, p_node);
        /* If freq is configured at RRM */
        if((FREQ_NOT_CONFIGURED != p_meas_cdma2000_node->cell_ctx_index)
                && (RRM_TRUE == rrm_ue_is_ue_supported_cdma2000_frequency(
                        p_meas_cdma2000_node->cdma_config.cdma_type,
                        p_meas_cdma2000_node->cdma_config.band_class,
                        p_ue_context)))
        {	
            /* SPR 12791 Start */
            meas_id = rrm_ue_generate_config_id(p_ue_context);
            /* SPR 12791 End */

            /* Store the Status parameters for meas req corresponding to the uarfcn
               at index (meas_id - RRM_MEAS_OBJ_ID_OFFSET) where all the status
               params corresponding to meas_id are stored  */
            /* Klocwork_fix_start : meas_config */
            if ((meas_id >= RRM_ONE) && (meas_id <= RRM_ANR_MAX_MEAS_OBJ))
            {
                /* Klocwork_fix_end : meas_config */
                p_meas_config_obj = &(p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
                /* Coverity_ID : 31037 , 31042*/
                rrm_fill_ue_meas_id_config_info(p_meas_config_obj, meas_id, meas_id, REPORT_CONFIG_INTERRAT_UTRAN_CDMA_ID, 
                        RRM_CDMA_CELL, p_meas_cdma2000_node->cdma_config.arfcn,RRM_SON_GERAN_DCS_1800, 
                        (rrm_son_cdma_band_class_et)p_meas_cdma2000_node->cdma_config.band_class);

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Creating CDMA meas object for ANR, meas_obj_id = %d", meas_id);
                /* Fill meas_object_to_add_mod_list */
                fill_cdma_meas_object_to_add_mod_list(p_cell_context,p_meas_cdma2000_node,
                        &(p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.
                            meas_object_to_add_mod[meas_obj_index]),
                        p_meas_config_obj->meas_obj_id);
                    /*SPR 15724:Start*/
                    p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_counter = RRM_ONE;
                    /*SPR 15724:End*/

                meas_obj_index++;
                /* Klocwork_fix_start : meas_config */
                /*CID 66794:start*/
                p_meas_config_obj->meas_config_status = RRM_MEAS_CONFIG_REQ_SENT;

                /* Fill meas_id_to_add_mod_list */
                fill_meas_id_to_add_mod_list(&p_rrc_rrm_meas_config_req->meas_config.
                        meas_id_to_add_mod_list.meas_id_to_add_mod[(*index)],
                        p_meas_config_obj);
                /*CID 66794:end*/

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        " Invalid meas_id [%d] recieved ", meas_id);
            }
            /* Klocwork_fix_end : meas_config */
            /* coverity 56708 */
            
            (*index)++;
            /* SPR 14326 Fix Start */
            if( RRM_FALSE == *send_measgap)
            {
                  cdma_meas_gap_config->band_class = p_meas_cdma2000_node->cdma_config.band_class;
                  cdma_meas_gap_config->cdma_type  = p_meas_cdma2000_node->cdma_config.cdma_type;
                  *send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
                                .rf_configurations.dl_earfcn ,
                                p_meas_cdma2000_node->cdma_config.arfcn,
                                p_ue_context,
                                INTER_RAT_BAND_LIST,
                                CDMA_FREQ,
                                cdma_meas_gap_config
                                );
             }
            /* SPR 14326 Fix End */



        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "CDMA freq = %d NOT configured at RRM (Awaiting Reconfig Resp)",
                    p_meas_cdma2000_node->cdma_config.arfcn);
        }	
        p_node = (YLNODE*)rrm_get_next_list_node(p_node);
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "no. of nodes processed in CDMA list = %d", 
            /* TDD Support SON Start */
            (*index));
    /* TDD Support SON End */

        /* SPR 14326 Fix Start */
        if( RRM_TRUE == *send_measgap )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Send MEAS GAP for CDMA`");
            p_ue_context->send_measgap_in_meas_config = RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "NO need to send MEAS GAP for CDMA");
            p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
        }
        /* SPR 14326 Fix End */



    /* Fix for SPR-5360 Start */
    if(RRM_NULL < (*index) )
    {
        if(!(REPORT_CONFIG_INTERRAT_UTRAN_CDMA_SENT & p_ue_context->meas_config_sent_bitmask))
        {
            /* Fill report_config_to_add_mod_list */
            /*SPR_FIX_START :12574*/
            fill_interrat_report_config_to_add_mod_list(
                    /* SPR 12987 Start */
                    p_ue_context,
                    /* SPR 12987 End */
                    &p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.
                    report_config_to_add_mod[(*meas_report_index)], utran_cdma_purpose,
                    REPORT_CONFIG_INTERRAT_UTRAN_CDMA_ID);
            (*meas_report_index)++;
            /*SPR_FIX_END :12574*/
            p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_UTRAN_CDMA_SENT;
        }

        if(!(QUANTITY_CONFIG_CDMA2000_SENT & p_ue_context->meas_config_sent_bitmask))
        {
                /* SPR 16880: start */
                fill_quantity_config_cdma(&p_rrc_rrm_meas_config_req->meas_config.quantity_config, p_ue_context);
                /* SPR 16880: end */
            p_ue_context->meas_config_sent_bitmask |= QUANTITY_CONFIG_CDMA2000_SENT;

            p_rrc_rrm_meas_config_req->meas_config.bitmask |=
                UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT;
        }
    }
    RRM_UT_TRACE_EXIT();
    return meas_obj_index;
    /*CID 65762:end*/
}
/*Klockwork_fix_2431_end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_meas_config_req
 *   INPUT      : p_cell_context, p_ue_context, obj_fill_info, obj_space_left,
 *   p_eutran_list_valid_count, p_utran_list_valid_count,
 *   p_geran_list_valid_count, p_cdma2000_list_valid_count, req_index_offset,
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for strongest cell reporting.
 *
 *   RETURNS:
 *          Total no. of meas objects for which configuration has been filled
 *****************************************************************************/

/* CSR 59124 Start */
static U8 
rrm_ue_fill_meas_config_req(
        rrm_cell_context_t              *p_cell_context,
    	rrm_ue_context_t                *p_ue_context,
        rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req
        )
{
    U8                              index               = RRM_NULL;
    /* RITIKA 5376 FIX Start*/
    U8                              meas_report_index   = RRM_NULL;
    U8                              meas_obj_index      = RRM_NULL;
    /* SPR 12971 Start */
    /* SPR 16053 Start */
    /* Code Deleted */
    /* SPR 16053 End */
    /* SPR 12971 End */
    rrm_interrat_trigger_type_periodical_purpose_et utran_cdma_purpose
        = RRM_INTERRAT_REPORT_STRONGEST_CELLS_FOR_SON;
    /* RITIKA 5376 FIX End*/
    /* SPR 7514 Fix Start - report config 924 */
    /* SPR 7514 Fix End - report config 924 */

    /* SPR 14326 Fix Start */
    rrm_bool_et    send_measgap = RRM_FALSE;
    rrm_cdma_meas_gap_config_t cdma_meas_gap_config = {RRM_ZERO};
    /* SPR 14326 Fix End */

    RRM_UT_TRACE_ENTER();

    /* Klocwork 29 may changes start*/
    RRM_ASSERT( RRM_PNULL != p_ue_context );
    /* Klocwork 29 may changes end*/
    /* Fill ue_index */
    p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
    /* Fill meas_config */

    //p_rrc_rrm_meas_config_req->meas_config.bitmask |=
    //  UE_ADM_MEAS_SPEED_STATE_PARS_PRESENT;
    /* TDD Support SON Start */
    /* TDD Support SON End */
    /* TDD Support SON Start */

    /* SPR 12971 Start */
    rrm_delete_previous_meas_obj_and_populate_remove_list(p_cell_context,
            p_ue_context->p_meas_config, p_rrc_rrm_meas_config_req);
    /*SPR 17061 Start*/
    /*SPR 15835:Start*/
    p_ue_context->report_amount_ue = RRM_ZERO;
    /*SPR 15835:End*/
    /*SPR 17061 End*/

    /* SPR 16053 start */
    /* Code removed */
    /* SPR 16053 end */

    p_ue_context->config_id = RRM_ZERO;
    /* SPR 15598 Start */
    /* Reset meas_config_sent_bitmask since previous ANR objects are being deleted here while adding the new one */
    p_ue_context->meas_config_sent_bitmask = RRM_ZERO;
    /* SPR 15598 End */

    /* SPR 12971 End */

    if(EUTRAN_RAT == p_ue_context->rat_configured) 
    {
        /*Klockwork_fix_2431_start*/
        /*SPR_FIX_START :12574*/

    /* SPR 14326 Fix Start */
        meas_obj_index = rrm_ue_fill_eutran_meas_config_req(p_cell_context,p_ue_context,p_rrc_rrm_meas_config_req,&meas_report_index,&index,&send_measgap);
    /* SPR 14326 Fix End */
        /*SPR_FIX_END :12574*/
        /*Klockwork_fix_2431_end*/
        
        /* Fix for SPR-5360 End */
    }
    else if(UTRAN_FDD_RAT == p_ue_context->rat_configured)
    {
    /* SPR 14326 Fix Start */
        meas_obj_index = meas_obj_index + rrm_ue_fill_utra_fdd_meas_config_req(p_cell_context,p_ue_context,p_rrc_rrm_meas_config_req,&index,&send_measgap);
    /* SPR 14326 Fix End */
    }
    else if(UTRAN_TDD_RAT == p_ue_context->rat_configured)
    {
       /*Klockwork_fix_2431_start*/ 
       meas_obj_index = meas_obj_index + rrm_ue_fill_utra_tdd_meas_config_req(p_cell_context,p_ue_context,p_rrc_rrm_meas_config_req,&index,&send_measgap);
       /*Klockwork_fix_2431_end*/       
        /* Populate UTRAN_TDD configuration to be sent to RRC */
    }
    /* Fix for SPR-5360 End */

    /* Populate GERAN configuration to be sent to RRC */
    /* SPR 7514 Fix Start - report config 924 */
    /* TDD Support SON Start */
    else if(GERAN_RAT == p_ue_context->rat_configured)
    {
        /*Klockwork_fix_2431_start*/
        /*SPR_FIX_START :12574*/
        meas_obj_index = meas_obj_index + rrm_ue_fill_geran_meas_config_req(p_cell_context,p_ue_context,p_rrc_rrm_meas_config_req,&meas_report_index,&index,&send_measgap);
        /*SPR_FIX_END :12574*/
        /*Klockwork_fix_2431_end*/
    }
    /* Fix for SPR-5360 End */
    /* Populate CDMA configuration to be sent to RRC */
    else if(CDMA_RAT == p_ue_context->rat_configured)
    {
        /*Klockwork_fix_2431_start*/
        /*SPR_FIX_START :12574*/
        meas_obj_index = meas_obj_index + rrm_ue_fill_cdma_meas_config_req(p_cell_context,p_ue_context,p_rrc_rrm_meas_config_req,
                utran_cdma_purpose,&meas_report_index,&index,&send_measgap,&cdma_meas_gap_config);
        /*SPR_FIX_END :12574*/
        /*Klockwork_fix_2431_end*/
    }
    else
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "No Rat configured for [UE:%d]", p_ue_context->ue_index);
    }


    if((RRM_NULL < index ) && 
		((UTRAN_TDD_RAT == p_ue_context->rat_configured) || (UTRAN_FDD_RAT == p_ue_context->rat_configured)))
    {
        if(!(REPORT_CONFIG_INTERRAT_UTRAN_CDMA_SENT & p_ue_context->meas_config_sent_bitmask))
        {
            /* Fill report_config_to_add_mod_list */
            fill_interrat_report_config_to_add_mod_list(
                    /* SPR 12987 Start */
                    p_ue_context,
                    /* SPR 12987 End */
                    &p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.
                    report_config_to_add_mod[meas_report_index], utran_cdma_purpose,
                    REPORT_CONFIG_INTERRAT_UTRAN_CDMA_ID);
            meas_report_index++;
            p_ue_context->meas_config_sent_bitmask |= REPORT_CONFIG_INTERRAT_UTRAN_CDMA_SENT;
        }

        if(!(QUANTITY_CONFIG_UTRA_SENT & p_ue_context->meas_config_sent_bitmask))
        {
            /* SPR 16880: start */
            fill_quantity_config_utra(&p_rrc_rrm_meas_config_req->meas_config.quantity_config, p_ue_context);
            /* SPR 16880: end */
            p_ue_context->meas_config_sent_bitmask |= QUANTITY_CONFIG_UTRA_SENT;

            p_rrc_rrm_meas_config_req->meas_config.bitmask |=
                UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT;
        }
    }

    /* Fix for SPR-5360 Delete fn calling : fill_quantity_config()*/
    /* SPR 7514 Fix End - report config 924 */

    /*fill_meas_config_speed_state_pars(
      &p_rrc_rrm_meas_config_req->meas_config.meas_config_speed_state_pars);
     */  

    /* Fix 949 Start */
    /* SPR 15260 start */
    if(meas_obj_index)
    {
        p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.count = 
            meas_obj_index;

        p_rrc_rrm_meas_config_req->meas_config.bitmask |=
            UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT;

        /* Meas Gap Config to be sent only when Objects other than Serving freq are present */
        /* SPR 14326 Fix Start */
        if((p_ue_context->meas_gap_config.meas_gap_added & MEAS_GAP_ADDED_FOR_PRS ) == RRM_FALSE
             &&  ( RRM_TRUE == p_ue_context->send_measgap_in_meas_config)) 
        {
            p_ue_context->send_measgap_in_meas_config = RRM_FALSE;
            /*SPR_17047_START*/
            p_ue_context->meas_gap_sent_status = RRM_SET;
            /*SPR_17047_END*/
        /* SPR 14326 Fix End */
            fill_meas_gap_config(
                    &p_rrc_rrm_meas_config_req->meas_config.meas_gap_config,p_ue_context);
            /*SPR 15713 end*/
            p_rrc_rrm_meas_config_req->meas_config.bitmask |=
                UE_ADM_MEAS_GAP_CONFIG_PRESENT;
            p_ue_context->meas_gap_config.meas_gap_added |= MEAS_GAP_ADDED_FOR_NON_PRS;
            p_ue_context->meas_gap_config.meas_gap_type = RRM_MEAS_GAP_TYPE_1;
            /*SPR 15713 Fix Start*/
            p_ue_context->meas_gap_config.meas_gap_offset = p_ue_context->meas_gap_offset;
            /*SPR 15713 Fix End*/
    /*SPR 17061 Start*/
            /* SPR 15397 Start */
            /* SPR 16053 start */
            /* Code removed */
            /* SPR 16053 end */ 
            /* SPR 15397 End */
    /*SPR 17061 End*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "No need to meas gap if meas gap is already configured for PRS meas_gap_added=%d",
                    p_ue_context->meas_gap_config.meas_gap_added);
        }
    }
    /* SPR 15260 end */
    /* Fix 949 End */

    if(index)
    {
        p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.count = index;
        p_rrc_rrm_meas_config_req->meas_config.bitmask |=
            UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT;
    }
    if(meas_report_index)
    {
        p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.count = 
            meas_report_index;
        p_rrc_rrm_meas_config_req->meas_config.bitmask |=
            UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
    return index;
}
/* CSR 59124 End */
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_meas_config_eutran_req_for_cgi_reporting
 *   INPUT      : p_meas_eutran_node 
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for CGI Reporting.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
rrm_void_t
rrm_ue_fill_meas_config_eutran_req_for_cgi_reporting(rrm_cell_context_t         *p_cell_context,
                                                     rrm_ue_context_t           *p_ue_context,                      
    	                                             meas_eutran_node_t         *p_meas_eutran_node,
                                                     void                       *p_cgi,
                                                     rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req ,
                                                     rrm_ue_meas_config_t       *p_meas_config_info)
{

        U16 cgi = *(U16 *)p_cgi;
        /* SPR 7514 Fix Start - report config 924 */
        rrm_trigger_type_periodical_purpose_et purpose = RRM_RRC_REPORT_CGI;
        /* SPR 7514 Fix End - report config 924 */
    RRM_UT_TRACE_ENTER();
        /* Fill EUTRAN meas object, id & report config */
        /* CSR00069389 Start */
        fill_eutran_meas_config_list(p_cell_context, p_ue_context, p_meas_eutran_node,
                &p_rrc_rrm_meas_config_req->meas_config, RRM_NULL, purpose, p_meas_config_info);

        /* CSR00069389 End */

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_eutra.bitmask |=
            MEAS_OBJECT_EUTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_eutra.cell_for_which_to_report_cgi = cgi;

        if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
                (RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                 eutra_radio_capability_info_def.access_stratum_release) &&
        /* SPR 12897 Start */
                 (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status))
        /* SPR 12897 End */
        {
            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list. \
                report_config_to_add_mod[RRM_NULL].report_config. \
                  report_config_eutra_ext.si_request_for_ho_r9 = RRM_RRC_SETUP_R9;
    
            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list. \
                report_config_to_add_mod[RRM_NULL].report_config. \
                   report_config_eutra_ext.bitmask |= SI_REQUEST_FOR_HO_R9_EUTRA_PRESENT;

            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list. \
                report_config_to_add_mod[RRM_NULL].report_config. \
                bitmask |= REPORT_CONFIG_EUTRA_EXT_PRESENT;
        }
   RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_meas_config_req_for_cgi_reporting
 *   INPUT      : p_meas_eutran_node, p_meas_utran_node, p_meas_geran_node,
 *   p_meas_cdma_node, p_ue_context, p_cgi, p_meas_config_info
 *   OUTPUT     : p_rrc_rrm_meas_config_req
 *   DESCRIPTION:
 *       Fills the meas configuration parameters in meas config to be
 *       sent to RRC for CGI Reporting.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/

static rrm_return_et
rrm_ue_fill_meas_config_req_for_cgi_reporting(
    	meas_eutran_node_t      	*p_meas_eutran_node,
    	meas_utran_node_t       	*p_meas_utran_node,
        /* TDD Support SON Start */
    	meas_utran_tdd_node_t       *p_meas_utran_tdd_node,
        /* TDD Support SON End */
    	meas_geran_node_t       	*p_meas_geran_node,
        meas_cdma_node_t        *p_meas_cdma_node,
	    rrm_ue_context_t            *p_ue_context,
        rrc_rrm_meas_config_req_t   *p_rrc_rrm_meas_config_req,
        /* Spr 18401 Changes Start */
        rrm_ue_meas_config_cgi_queue_node_t *p_report_cgi,
       /* Spr 18401 Changes End */
        rrm_ue_meas_config_t        *p_meas_config_info
        )
{
    rrm_cell_context_t             *p_cell_context    = RRM_PNULL;
    /* SPR 12897 Delete */
    
    /* SPR 7514 Fix Start - report config 924 :delete */
                            
    RRM_UT_TRACE_ENTER();
    p_cell_context = rrm_cellm_get_cell_context(
                            p_ue_context->cell_index);
    /*CID 65811:start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65811:end*/


    /* Fill ue_index */
    p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
    /* Fill meas_config */
    p_rrc_rrm_meas_config_req->meas_config.bitmask |=
        UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT;

    p_rrc_rrm_meas_config_req->meas_config.bitmask |=
        UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT;
    
    /* CSR00069389 Start */
    /* CSR00069389 End */
    //p_rrc_rrm_meas_config_req->meas_config.bitmask |=
    //  UE_ADM_MEAS_SPEED_STATE_PARS_PRESENT;

    if(RRM_PNULL != p_meas_eutran_node)
    {
        /* Spr 18401 Changes Start */
        U16 cgi = p_report_cgi->cgi;

        /*Klockwork_fix_start*/
        rrm_ue_fill_meas_config_eutran_req_for_cgi_reporting(p_cell_context, p_ue_context ,p_meas_eutran_node,
                                                        &cgi ,p_rrc_rrm_meas_config_req ,p_meas_config_info);
        /* Spr 18401 Changes End */
        /*Klockwork_fix_end*/
    }

    /* Request for FDD UTRAN neighbour CGI */
    else if(RRM_PNULL != p_meas_utran_node)
    {    
        /* Spr 18401 Changes Start */
        U16 cgi = p_report_cgi->cgi;
        /* Spr 18401 Changes End */
        /* SPR 7514 Fix Start - report config 924 */
        rrm_interrat_trigger_type_periodical_purpose_et purpose = RRM_INTERRAT_REPORT_CGI;
        /* SPR 7514 Fix End - report config 924 */

        /* Fill UTRAN meas object, id & report config */
        /* CSR00069389 Start */
        fill_utran_meas_config_list(p_cell_context, p_ue_context, p_meas_utran_node,
                &p_rrc_rrm_meas_config_req->meas_config, RRM_NULL, purpose, 
                p_meas_config_info);

        /* CSR00069389 End */

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_utra.bitmask |=
            MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_utra.cell_for_which_to_report_cgi.
            bitmask |=
            MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_FDD_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_utra.cell_for_which_to_report_cgi.
            utra_fdd = cgi;
       
        /* SPR 12897 Delete */
    }
    /* TDD Support SON Start */
    /* Request for TDD UTRAN neighbour CGI */
    else if(RRM_PNULL != p_meas_utran_tdd_node)
    {    
        /* Spr 18401 Changes Start */
        U16 cgi = p_report_cgi->cgi;
        /* Spr 18401 Changes End */
        /* SPR 7514 Fix Start - report config 924 */
        rrm_interrat_trigger_type_periodical_purpose_et purpose = RRM_INTERRAT_REPORT_CGI;
        /* SPR 7514 Fix End - report config 924 */

        /* Fill UTRAN meas object, id & report config */
        /* CSR00069389 Start */
        fill_utran_tdd_meas_config_list(p_cell_context, p_ue_context, p_meas_utran_tdd_node,
                &p_rrc_rrm_meas_config_req->meas_config, RRM_NULL, purpose, 
                p_meas_config_info);

        /* CSR00069389 End */

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_utra.bitmask |=
            MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_utra.cell_for_which_to_report_cgi.
            bitmask |=
            MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_TDD_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_utra.cell_for_which_to_report_cgi.
            utra_tdd = cgi;

        /* SPR 12897 Delete */
    }
    /* TDD Support SON End */

    /* Request for GERAN neighbour CGI */
    else if(RRM_PNULL != p_meas_geran_node)
    {
        /* Spr 18401 Changes Start */
        rrm_son_geran_physical_cell_id_t cgi = 
            *(rrm_son_geran_physical_cell_id_t *)&(p_report_cgi->cgi);
        /* Spr 18401 Changes End */
        /* SPR 7514 Fix Start - report config 924 */
        rrm_interrat_trigger_type_periodical_purpose_et purpose = RRM_INTERRAT_REPORT_CGI;
        /* SPR 7514 Fix End - report config 924 */

        /* Fill GERAN meas object, id & report config */
        /* CSR00069389 Start */
        fill_geran_meas_config_list(p_cell_context, p_ue_context, p_meas_geran_node,
                &p_rrc_rrm_meas_config_req->meas_config, RRM_NULL, purpose, 
                /* Spr 18401 Changes Start */
                p_meas_config_info,p_report_cgi->arfcn);
                /* Spr 18401 Changes End */

        /* CSR00069389 End */

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_geran.bitmask |=
            MEAS_OBJECT_GERAN_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_geran.cell_for_which_to_report_cgi.
            network_colour_code = cgi.ncc;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_geran.cell_for_which_to_report_cgi.
            base_station_colour_code = cgi.bscc;

        /* SPR 12897 Delete */
    }
     else if(RRM_PNULL != p_meas_cdma_node)
     {
        /* Spr 18401 Changes Start */
        U16 cgi = p_report_cgi->cgi;
        /* Spr 18401 Changes End */
        /* SPR 7514 Fix Start - report config 924 */
        rrm_interrat_trigger_type_periodical_purpose_et purpose = RRM_INTERRAT_REPORT_CGI;
        /* SPR 7514 Fix End - report config 924 */

        /* Fill CDMA meas object, id & report config */
        /* CSR00069389 Start */
        fill_cdma2000_meas_config_list(p_cell_context, p_ue_context, p_meas_cdma_node,
                &p_rrc_rrm_meas_config_req->meas_config, RRM_NULL, purpose, 
                p_meas_config_info);

        /* CSR00069389 End */

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_cdma2000.bitmask |=
            MEAS_OBJECT_CDMA2000_CELL_FOR_WHICH_TO_REPEORT_CGI_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.
            meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_NULL].
            meas_object.meas_object_cdma2000.cells_for_which_to_report_cgi = cgi;

        /* SPR 12897 Delete */
    }


    p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.count =
	RRM_1;
    p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.count =
	RRM_1;
    p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.count =
	RRM_1;

/* Fix for SPR-5360 Delete fn calling : fill_quantity_config()*/

    /* SPR 15260 start */
    /* Code deleted */
    /* SPR 15260 end */

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_meas_config_req_for_cgi_reporting
 *   INPUT      : p_meas_eutran_node,p_meas_utran_node,p_meas_geran_node
 *                p_meas_cdma_node,p_ue_context,p_cgi,transaction_id,
 *                p_meas_config_info
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Builds the meas config request and sends to RRC for CGI Reporting.
 *
 *   RETURNS:
 *          rrm_return_et (TRUE/FALSE)
 *****************************************************************************/
rrm_return_et
rrm_build_and_send_meas_config_req_for_cgi_reporting(
    	meas_eutran_node_t      	*p_meas_eutran_node,
    	meas_utran_node_t       	*p_meas_utran_node,
        /* TDD Support SON Start */
    	meas_utran_tdd_node_t       *p_meas_utran_tdd_node,
        /* TDD Support SON End */
    	meas_geran_node_t       	*p_meas_geran_node,
    	meas_cdma_node_t       	    *p_meas_cdma_node,
	    rrm_ue_context_t              	*p_ue_context,
        /* Spr 18401 Changes Start */
        rrm_ue_meas_config_cgi_queue_node_t *p_report_cgi,
        /* Spr 18401 Changes End */
        U16                             transaction_id,
        rrm_ue_meas_config_t        *p_meas_config_info
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRM_PNULL;
    U16                             cgi = RRM_NULL;
    rrm_son_geran_physical_cell_id_t geran_cgi = {RRM_NULL};

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
                              rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL , sizeof(rrc_rrm_meas_config_req_t));


/* TDD Support SON Start */
    rrm_ue_fill_meas_config_req_for_cgi_reporting(p_meas_eutran_node, p_meas_utran_node, 
        /* Spr 18401 Changes Start */
            p_meas_utran_tdd_node, p_meas_geran_node, p_meas_cdma_node,p_ue_context, p_rrc_rrm_meas_config_req, p_report_cgi,
        /* Spr 18401 Changes End */
    p_meas_config_info);
/* TDD Support SON End */    
    ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
            RRM_MODULE_ID, RRC_MODULE_ID, transaction_id,p_ue_context->cell_index);

    if(RRM_NULL != p_meas_geran_node)
    {
        /* Spr 18615 Changes Start */
        geran_cgi =   *(rrm_son_geran_physical_cell_id_t *)(&(p_report_cgi->cgi));
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "For arfcn: %d, p_report_cgi  PCI: ncc = %d, bscc = %d",
                p_report_cgi->arfcn,geran_cgi.ncc, geran_cgi.bscc);
        /* Spr 18615 Changes End */
    }
    else
    {
        /* Spr 18401 Changes Start */
        cgi = p_report_cgi->cgi;
        /* Spr 18401 Changes End */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "For PCI: %d", cgi);
    }
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Failed to send MEAS CONFIG REQUEST for [UE:%d] for "
                "Report CGI", p_ue_context->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Successfully sent MEAS CONFIG REQUEST for [UE:%d] for "
                "Report CGI", p_ue_context->ue_index);
    /* CSR00069389 Start */
	p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
    /* CSR00069389 End */
        /* SPR 15797 Start */
        RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_MEAS_CONFIG_REQ_ONGOING);
        /* SPR 15797 End */
    }
    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_meas_config_req
 *
 *   DESCRIPTION:
 *       Builds the meas config request and sends to RRC for Strongest 
 *       cell reporting.
 *
 *   RETURNS:
 *          rrm_return_et (TRUE/FALSE)
 *****************************************************************************/
rrm_return_et
rrm_build_and_send_meas_config_req(
	rrm_ue_context_t                *p_ue_context,
        meas_type_et                     meas_type
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRM_PNULL;
    rrm_cell_context_t             *p_cell_context    = RRM_PNULL;
    U16                             transaction_id    = RRM_NULL; /*RRM_MEAS Changes */
    U8                              total_meas_obj_filled   = RRM_NULL;
    U8                              meas_count = RRM_NULL;
    /*SPR_17893_START*/
    rrm_bool_et                     send_utran_cap_enq        = RRM_FALSE; 
    /*SPR_17893_END*/
    RRM_UT_TRACE_ENTER();


    /* BLR Meas Changes Start */
    p_cell_context = rrm_cellm_get_cell_context(
            p_ue_context->cell_index);                
    /*CID 65810:start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65810:end*/

    transaction_id = rrm_generate_txn_id(); /*RRM_MEAS Changes */

    /* BLR Meas Changes End */
    /*CID 66690:start*/
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
                              rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    /*CID 66690:end*/
    RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL, 
            sizeof(rrc_rrm_meas_config_req_t));

    /* BLR Meas Changes Start*/
    if (meas_type == MEAS_TYPE_ANR)
    { 
/* TDD Support SON Start */    
        rrm_ue_update_meas_context_list(p_cell_context);
/* TDD Support SON End */
        total_meas_obj_filled = rrm_ue_fill_meas_config_req(p_cell_context,
                p_ue_context, p_rrc_rrm_meas_config_req);

		/* CSR 59124 Delete */

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "Total meas"
                " objects filled for [UE:%d] = %d",
                p_ue_context->ue_index, total_meas_obj_filled);
        if(RRM_NULL == total_meas_obj_filled)
        {
            ret_val = RRM_FAILURE;
            /* SPR 16406 8SEP start */
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            RRM_UT_TRACE_EXIT();
            return ret_val;
            /* SPR 16406 8SEP end */
        }

        for( meas_count = RRM_ZERO; (meas_count< p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.count); meas_count++)
        {
         if(p_ue_context->p_meas_config[(p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                     meas_id_to_add_mod[meas_count].meas_id)-RRM_ONE].rat_type == RRM_EUTRAN_CELL)
         {
            /*Raising event RRM_PE_EVENT_MEAS_CONFIG_PERIODICAL_EUTRA*/
            rrm_raise_event_meas_config_periodical_eutra(p_rrc_rrm_meas_config_req,
                                                         p_ue_context->cell_index);
         }
         /* TDD Support SON Start */
         else if((p_ue_context->p_meas_config[(p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                     meas_id_to_add_mod[meas_count].meas_id)-1].rat_type == RRM_UTRAN_CELL) ||
                     (p_ue_context->p_meas_config[(p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                      meas_id_to_add_mod[meas_count].meas_id)-1].rat_type == RRM_UTRAN_TDD_CELL))
         /* TDD Support SON End */             
         {
            /*Raising event RRM_PE_EVENT_MEAS_CONFIG_PERIODICAL_UTRA*/
            rrm_raise_event_meas_config_periodical_utra(p_rrc_rrm_meas_config_req,
                                                        p_ue_context->cell_index);
         }

         else if(p_ue_context->p_meas_config[(p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                     meas_id_to_add_mod[meas_count].meas_id)-RRM_ONE].rat_type == RRM_GERAN_CELL)

         {
            /*Raising event RRM_PE_EVENT_MEAS_CONFIG_PERIODICAL_GERAN*/
            rrm_raise_event_meas_config_periodical_geran(p_rrc_rrm_meas_config_req,
                                                         p_ue_context->cell_index);
         }
         else if(p_ue_context->p_meas_config[(p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                     meas_id_to_add_mod[meas_count].meas_id)-RRM_ONE].rat_type == RRM_CDMA_CELL)

         {
            /*Raising event RRM_PE_EVENT_MEAS_CONFIG_PERIODICAL_GERAN*/
            rrm_raise_event_meas_config_periodical_cdma(p_rrc_rrm_meas_config_req,
                                                         p_ue_context->cell_index);
         }


        }
    }
    else if (meas_type == MEAS_TYPE_HO)
    {
        p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
        /* Fix for SPR 10310 start */
        ret_val = rrm_ue_fill_meas_config_req_for_ho(&(p_rrc_rrm_meas_config_req->meas_config),
                p_ue_context);
        /* Fix for SPR 10310 end */
	/*SPR_17893_START*/
	if((RRM_SUCCESS == ret_val) && 
			(RRM_TRUE == rrm_check_if_utran_cap_enq_reqd(p_ue_context))
	  )
	{
		send_utran_cap_enq = RRM_TRUE;
	}
	/*SPR_17893_END*/
    }


    /* eICIC_PHASE_1_2_CHANGES_START */
    else if (meas_type == MEAS_TYPE_FOR_VICTIM)
    {
        p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
	/* SPR 14165 start */
	/* SPR 14302 start */
        p_ue_context->rrm_eicic_meas_event_ongoing = RRM_TRUE;
	/* SPR 143012 end */

        ret_val = rrm_ue_fill_meas_config_req_for_victim_ue(
                &(p_rrc_rrm_meas_config_req->meas_config),
                p_ue_context);

       /* SPR 14165 end */
       /*CA HARDENING CHANGES*/
        /* SPR 15239 Fix Start */
        p_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
        /* SPR 15239 Fix End  */

    }

    /* eICIC_PHASE_1_2_CHANGES_END */
    /* SPR 13675 Fix Start */
    if (RRM_NULL == p_rrc_rrm_meas_config_req->meas_config.bitmask)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Nothing to send in MEAS CONFIG REQUEST for [UE:%d]",
                        p_ue_context->ue_index);
        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* SPR 13675 Fix Stop */

    /* BLR Meas Changes End*/
    /* Fix for SPR 10310 start */
    /* eICIC_PHASE_1_2_CHANGES_START */
    /* SPR_16053_Fix: Start */
    if((RRM_UE_REESTABLISH_PROCEDURE_ONGOING != p_ue_context->current_procedure.state ) &&
    /* SPR_16053_Fix: End */
        (ret_val != RRM_FAILURE) && ((meas_type == MEAS_TYPE_HO) || 
            (meas_type == MEAS_TYPE_FOR_VICTIM)  || 
            ((meas_type == MEAS_TYPE_ANR) && (RRM_NULL < total_meas_obj_filled))))
    /* eICIC_PHASE_1_2_CHANGES_END */
    {
		if(p_rrc_rrm_meas_config_req->meas_config.bitmask)
		{
		/*SPR_17893_START*/
                if(RRM_TRUE == send_utran_cap_enq)
                {
                        if(RRM_TRUE == rrm_populate_and_send_utran_cap_enq_req(p_ue_context))
                        {
                                rrm_ue_set_state(p_ue_context,RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES);
                                rrm_set_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_FALSE);		
                        }
                        else
                        {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                                "Failed to populate/send UTRAN CAP ENQ REQ for [UE:%d]",
                                                p_ue_context->ue_index);
                        }
                }
		/*SPR_17893_END*/
            ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);

            if(ret_val == RRM_FAILURE)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send MEAS CONFIG REQUEST for [UE:%d]",
                        p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Successfully sent MEAS CONFIG REQUEST for [UE:%d]",
                        p_ue_context->ue_index);
                p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;/*RRM_MEAS Changes */
              /* SPR 15797 Start */
                RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_MEAS_CONFIG_REQ_ONGOING);
                /* SPR 15797 End */
            }
		}
        /* Start :SPR 9320 */
        else
        {
            ret_val = RRM_FAILURE;
        }
        /* End :SPR 9320 */
    }
    /* Fix for SPR 10310 end */
    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_meas_config_resp
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the MEAS CONFIG RESP
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_meas_config_resp(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_meas_config_response_t  rrc_rrm_meas_config_response = {RRM_ZERO};
    rrm_ue_meas_config_response_t   *p_ue_proc_data = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    /**Parse the MEAS CONFIG RESP */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_meas_config_response(
                &rrc_rrm_meas_config_response,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_meas_config_response.ue_index;
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
 
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_MEAS_CONFIG_RESP:[UE:%d] with response: %d",
                rrc_rrm_meas_config_response.ue_index, rrc_rrm_meas_config_response.response);
        p_ue_proc_data = (rrm_ue_meas_config_response_t *)
            rrm_mem_get(sizeof(rrm_ue_meas_config_response_t));
        if(RRM_PNULL == p_ue_proc_data)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%d],Failed to allocate the "
                    "proc data for RRC_RRM_MEAS_CONFIG_RESP",
                    rrc_rrm_meas_config_response.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d],Successfully allocated "
                    "the proc data for RRC_RRM_MEAS_CONFIG_RESP",
                    rrc_rrm_meas_config_response.ue_index);

            p_ue_proc_data->bitmask = rrc_rrm_meas_config_response.bitmask;
            p_ue_proc_data->ue_index = rrc_rrm_meas_config_response.ue_index;
	    p_ue_proc_data->response =  rrc_rrm_meas_config_response.response;

            if(rrc_rrm_meas_config_response.bitmask &
                RRC_RRM_MEAS_CONFIG_RESP_CAUSE_PRESENT)
            {
                p_ue_proc_data->bitmask |= RRM_UE_MEAS_CONFIG_RESP_CAUSE_PRESENT;                
                p_ue_proc_data->cause = rrc_rrm_meas_config_response.cause;
            }

            ret_val = RRM_SUCCESS;
            p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_MEAS_CONFIG_RESP->UEM failed to process");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}        

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_eutran_nbr_list
 *   INPUT      : p_meas_result_list_eutra
 *   OUTPUT     : p_ue_proc_data
 *   DESCRIPTION:
 *       Fills the eutran neighbour list parameters in meas reults ind 
 *       to be sent to RMIF received from RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
rrm_void_t
rrm_ue_fill_eutran_nbr_list(
        rrm_ue_measurment_results_ind_t     *p_ue_proc_data,
        meas_result_list_eutra_t            *p_meas_result_list_eutra
        )
{
    U8      index       = RRM_NULL;
    U8      plmn_index  = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    p_ue_proc_data->eutran_count = p_meas_result_list_eutra->count;

    for(index = RRM_ZERO; index < p_ue_proc_data->eutran_count; index++)
    {
        p_ue_proc_data->eutran_neighbor_list[index].bitmask = RRM_ZERO;

        p_ue_proc_data->eutran_neighbor_list[index].pci =
            p_meas_result_list_eutra->
            meas_result_eutra[index].phys_cell_id;

        if(MEAS_RESULT_EUTRA_CGI_INFO_PRESENT &
                p_meas_result_list_eutra->meas_result_eutra[index].bitmask)
        {
            p_ue_proc_data->eutran_neighbor_list[index].bitmask |=
                RRM_SON_EUTRAN_NC_CGI_PRESENT;

            RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].cgi.
                    primary_plmn_id.mcc, 
                    p_meas_result_list_eutra->
                    meas_result_eutra[index].cgi_info.cell_global_id.
                    plmn_identity.mcc, sizeof(U8) * MAX_MCC_DIGITS);

            p_ue_proc_data->eutran_neighbor_list[index].cgi.
                primary_plmn_id.num_mnc_digit = 
                p_meas_result_list_eutra->
                meas_result_eutra[index].cgi_info.cell_global_id.
                plmn_identity.mnc.count;

            RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].cgi.
                    primary_plmn_id.mnc,
                    p_meas_result_list_eutra->
                    meas_result_eutra[index].cgi_info.cell_global_id.
                    plmn_identity.mnc.mnc, sizeof(U8) * MAX_MNC_DIGITS);

            RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].cgi.
                    cell_identity,
                    p_meas_result_list_eutra->
                    meas_result_eutra[index].cgi_info.cell_global_id.
                    cell_identity, sizeof(U8) * MAX_CELL_IDENTITY_OCTETS);

            p_ue_proc_data->eutran_neighbor_list[index].bitmask |=
                RRM_SON_EUTRAN_NC_TAC_PRESENT;

            RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].tac,
                    p_meas_result_list_eutra->
                    meas_result_eutra[index].cgi_info.tracking_area_code,
                    sizeof(U8) * MAX_TAC_SIZE);

            if(MEAS_RESULT_EUTRA_CGI_INFO_PLMN_IDENTITY_LIST_PRESENT &
                    p_meas_result_list_eutra->
                    meas_result_eutra[index].cgi_info.bitmask)
            {
                p_ue_proc_data->eutran_neighbor_list[index].bitmask |=
                    RRM_SON_EUTRAN_NC_PLMN_PRESENT;

                p_ue_proc_data->eutran_neighbor_list[index].num_plmn_id =
                    p_meas_result_list_eutra->
                    meas_result_eutra[index].cgi_info.plmn_identity_list.
                    count;

                for(plmn_index = RRM_ZERO; 
                    plmn_index <
                        p_ue_proc_data->eutran_neighbor_list[index].num_plmn_id;
                    plmn_index++)
                {
                    RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].
                            plmn_id[plmn_index].mcc,
                            p_meas_result_list_eutra->
                            meas_result_eutra[index].cgi_info.
                            plmn_identity_list.cell_identity[plmn_index].mcc, 
                            sizeof(U8) * MAX_MCC_DIGITS);

                    p_ue_proc_data->eutran_neighbor_list[index].
                        plmn_id[plmn_index].num_mnc_digit =
                        p_meas_result_list_eutra->
                        meas_result_eutra[index].cgi_info.
                        plmn_identity_list.cell_identity[plmn_index].mnc.count;

                    RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].
                            plmn_id[plmn_index].mnc,
                            p_meas_result_list_eutra->
                            meas_result_eutra[index].cgi_info.
                            plmn_identity_list.cell_identity[plmn_index].mnc.mnc, 
                            sizeof(U8) * MAX_MNC_DIGITS);
                }
            }
        }
        if(MEAS_RESULT_EUTRA_MEAS_RESULT_RSRP_PRESENT &
                p_meas_result_list_eutra->
                meas_result_eutra[index].meas_result.bitmask)
        {
            p_ue_proc_data->eutran_neighbor_list[index].rsrp =
                p_meas_result_list_eutra->
                meas_result_eutra[index].meas_result.rsrp_result;
        }
        if(MEAS_RESULT_EUTRA_MEAS_RESULT_RSRQ_PRESENT &
                p_meas_result_list_eutra->
                meas_result_eutra[index].meas_result.bitmask)
        {
            p_ue_proc_data->eutran_neighbor_list[index].rsrq =
                p_meas_result_list_eutra->
                meas_result_eutra[index].meas_result.rsrq_result;

        }
        /*csg start*/
        if(MEAS_RESULT_EUTRA_CSG_INFO_PRESENT &
                p_meas_result_list_eutra->
                meas_result_eutra[index].bitmask )
        {
            if(MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_MEM_STATUS_PRESENT &
                p_meas_result_list_eutra->meas_result_eutra[index].eutra_csg_info.bitmask)
            {
                p_ue_proc_data->eutran_neighbor_list[index].bitmask |=
                        RRM_SON_EUTRAN_NC_CSG_MEM_STATUS_PRESENT; 
                if(p_meas_result_list_eutra->meas_result_eutra[index].
                    eutra_csg_info.csg_membershipStatus == RRC_MEMBER)
                {
                    p_ue_proc_data->eutran_neighbor_list[index].csg_membershipStatus = 
                        RRM_MEMBER; 
                }
                else if(p_meas_result_list_eutra->meas_result_eutra[index].
                        eutra_csg_info.csg_membershipStatus == RRC_NOT_MEMBER)
                {
                    p_ue_proc_data->eutran_neighbor_list[index].csg_membershipStatus =
                        RRM_NOT_MEMBER;
                }
            }

            if(MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_ID_PRESENT &
                 p_meas_result_list_eutra->meas_result_eutra[index].eutra_csg_info.bitmask)
            {
                p_ue_proc_data->eutran_neighbor_list[index].bitmask |=
                        RRM_SON_EUTRAN_NC_CSG_PRESENT;
                RRM_MEMCPY(p_ue_proc_data->eutran_neighbor_list[index].csg_identity,
                           p_meas_result_list_eutra->meas_result_eutra[index].eutra_csg_info.csg_identity,
                           CSG_ID_OCTET_SIZE);

            }
        }
        /*csg end*/
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_utran_nbr_list
 *   INPUT      : p_meas_result_list_utra
 *   OUTPUT     : p_ue_proc_data
 *   DESCRIPTION:
 *       Fills the utran neighbour list parameters in meas reults ind
 *       to be sent to RMIF received from RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
rrm_void_t
rrm_ue_fill_utran_nbr_list(
rrm_ue_measurment_results_ind_t     *p_ue_proc_data,
meas_result_list_utra_t             *p_meas_result_list_utra)
{
    U8      index = RRM_NULL;
    U8      plmn_index = RRM_NULL;
    
    RRM_UT_TRACE_ENTER();
    p_ue_proc_data->utran_count = p_meas_result_list_utra->count;
    
    for(index = RRM_ZERO; index < p_ue_proc_data->utran_count; index++)
    {
        if(MEAS_RESULT_UTRA_PHYS_CELL_ID_FDD_PRESENT &
            p_meas_result_list_utra->meas_result_utra[index].phys_cell_id.
            bitmask)
        {
            p_ue_proc_data->utran_neighbor_list[index].pci.bitmask |=
                RRM_PCI_FDD_PRESENT;
            p_ue_proc_data->utran_neighbor_list[index].pci.pci_fdd =
                p_meas_result_list_utra->meas_result_utra[index].
                phys_cell_id.fdd;
        }
        if(MEAS_RESULT_UTRA_PHYS_CELL_ID_TDD_PRESENT &
            p_meas_result_list_utra->meas_result_utra[index].phys_cell_id.
            bitmask)
        {
            /* Start fix for bug 715 */
            p_ue_proc_data->utran_neighbor_list[index].pci.bitmask |=
                RRM_PCI_TDD_PRESENT;
            p_ue_proc_data->utran_neighbor_list[index].pci.pci_tdd =
                p_meas_result_list_utra->meas_result_utra[index].
                phys_cell_id.tdd;
            /* End fix for bug 715 */
        }
        if(MEAS_RESULT_UTRA_CGI_INFO_PRESENT &
            p_meas_result_list_utra->meas_result_utra[index].bitmask)
        {
            p_ue_proc_data->utran_neighbor_list[index].bitmask |=
                RRM_SON_UTRAN_NC_CGI_PRESENT;

            p_ue_proc_data->utran_neighbor_list[index].cgi.rat_type = 
                RRM_UTRAN_CELL;

            RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].cgi.
            plmn_id.mcc, p_meas_result_list_utra->meas_result_utra[index].
            cgi_info.cell_global_id.plmn_identity.mcc,
            sizeof(U8) * MAX_MCC_DIGITS);

            p_ue_proc_data->utran_neighbor_list[index].cgi.plmn_id.
            num_mnc_digit = 
                p_meas_result_list_utra->
                meas_result_utra[index].cgi_info.cell_global_id.
                plmn_identity.mnc.count;

            RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].cgi.plmn_id.
                    mnc, p_meas_result_list_utra->
                    meas_result_utra[index].cgi_info.cell_global_id.
                    plmn_identity.mnc.mnc, sizeof(U8) * MAX_MNC_DIGITS);

            RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].cgi.
                    cell_identity, p_meas_result_list_utra->
                    meas_result_utra[index].cgi_info.cell_global_id.
                    cell_identity, sizeof(U8) * MAX_CELL_IDENTITY_OCTETS);

            if(MEAS_RESULT_UTRA_CGI_INFO_LOCATION_AREA_CODE_PRESENT &
                p_meas_result_list_utra->meas_result_utra[index].cgi_info.
                bitmask)
            {
                p_ue_proc_data->utran_neighbor_list[index].bitmask |=
                    RRM_SON_UTRAN_NC_LAC_PRESENT;

                RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].lac,
                    p_meas_result_list_utra->meas_result_utra[index].
                    cgi_info.location_area_code, sizeof(U8) * MAX_LAC_SIZE);
            }
            if(MEAS_RESULT_UTRA_CGI_INFO_ROUTING_AREA_CODE_PRESENT &
                p_meas_result_list_utra->meas_result_utra[index].cgi_info.
                bitmask)
            {
                p_ue_proc_data->utran_neighbor_list[index].bitmask |= 
                    RRM_SON_UTRAN_NC_RAC_PRESENT;

                p_ue_proc_data->utran_neighbor_list[index].rac =
                    p_meas_result_list_utra->meas_result_utra[index].
                    cgi_info.routing_area_code;
            }
            if(MEAS_RESULT_UTRA_CGI_INFO_PLMN_IDENTITY_LIST_PRESENT &
                p_meas_result_list_utra->meas_result_utra[index].cgi_info.
                bitmask)
            {
                p_ue_proc_data->utran_neighbor_list[index].bitmask |=
                    RRM_SON_UTRAN_NC_PLMN_PRESENT;

                p_ue_proc_data->utran_neighbor_list[index].num_plmn_id =
                    p_meas_result_list_utra->
                    meas_result_utra[index].cgi_info.plmn_identity_list.
                    count;

                for(plmn_index = RRM_ZERO; plmn_index <
                        p_ue_proc_data->utran_neighbor_list[index].num_plmn_id;
                        plmn_index++)
                {
                    RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].
                            plmn_id[plmn_index].mcc,
                            p_meas_result_list_utra->
                            meas_result_utra[index].cgi_info.
                            plmn_identity_list.cell_identity[plmn_index].mcc, 
                            sizeof(U8) * MAX_MCC_DIGITS);

                    p_ue_proc_data->utran_neighbor_list[index].plmn_id[plmn_index].
                        num_mnc_digit =
                        p_meas_result_list_utra->
                        meas_result_utra[index].cgi_info.
                        plmn_identity_list.cell_identity[plmn_index].mnc.count;

                    RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].
                            plmn_id[plmn_index].mnc,
                            p_meas_result_list_utra->
                            meas_result_utra[index].cgi_info.
                            plmn_identity_list.cell_identity[plmn_index].mnc.mnc, 
                            sizeof(U8) * MAX_MNC_DIGITS);
                }
            }
        }
        p_ue_proc_data->utran_neighbor_list[index].rscp = 
            p_meas_result_list_utra->meas_result_utra[index].
            meas_result.utra_rscp;
        p_ue_proc_data->utran_neighbor_list[index].ecno = 
            p_meas_result_list_utra->meas_result_utra[index].
            meas_result.utra_ecn0;
        /**csg start*/
        if(MEAS_RESULT_UTRA_CSG_INFO_PRESENT &
                p_meas_result_list_utra->
                meas_result_utra[index].bitmask )
        {
            if(MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_MEM_STATUS_PRESENT &
                    p_meas_result_list_utra->meas_result_utra[index].utra_csg_info.bitmask)
            {
                p_ue_proc_data->utran_neighbor_list[index].bitmask |=
                    RRM_SON_UTRAN_NC_CSG_MEM_STATUS_PRESENT;
                if(p_meas_result_list_utra->meas_result_utra[index].
                        utra_csg_info.csg_membershipStatus == RRC_MEMBER)
                {
                    p_ue_proc_data->utran_neighbor_list[index].csg_membershipStatus =
                        RRM_MEMBER;
                }
                else if(p_meas_result_list_utra->meas_result_utra[index].
                         utra_csg_info.csg_membershipStatus == RRC_MEMBER)
                {
                    p_ue_proc_data->utran_neighbor_list[index].csg_membershipStatus =
                        RRM_MEMBER;
                }
            }

            if(MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_ID_PRESENT &
                    p_meas_result_list_utra->meas_result_utra[index].utra_csg_info.bitmask)
            {
                p_ue_proc_data->utran_neighbor_list[index].bitmask |=
                    RRM_SON_UTRAN_NC_CSG_PRESENT;
                RRM_MEMCPY(p_ue_proc_data->utran_neighbor_list[index].csg_identity,
                        p_meas_result_list_utra->meas_result_utra[index].utra_csg_info.csg_identity,
                        CSG_ID_OCTET_SIZE);

            }
        }
        /**csg end*/
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_geran_nbr_list
 *   INPUT      : p_meas_result_list_geran
 *   OUTPUT     : p_ue_proc_data
 *   DESCRIPTION:
 *       Fills the geran neighbour list parameters in meas reults ind
 *       to be sent to RMIF received from RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
rrm_void_t
rrm_ue_fill_geran_nbr_list(
        rrm_ue_measurment_results_ind_t     *p_ue_proc_data,
        meas_result_list_geran_t            *p_meas_result_list_geran
        )
{
    U8      index       = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_ue_proc_data->geran_count = p_meas_result_list_geran->count;

    for(index = RRM_ZERO; index < p_ue_proc_data->geran_count; index++)
    {
        p_ue_proc_data->geran_neighbor_list[index].bitmask = RRM_ZERO;

        p_ue_proc_data->geran_neighbor_list[index].arfcn =
            p_meas_result_list_geran->meas_result_geran[index].
            carrier_freq.arfcn;

       /* coverity : 16545 ,rel 2.0.1 */
        p_ue_proc_data->geran_neighbor_list[index].band_ind =(rrm_son_geran_band_indicator_et)(
            p_meas_result_list_geran->meas_result_geran[index].
            carrier_freq.band_indicator);

        p_ue_proc_data->geran_neighbor_list[index].pci.ncc =
            p_meas_result_list_geran->meas_result_geran[index].
            phys_cell_id.network_colour_code;

        p_ue_proc_data->geran_neighbor_list[index].pci.bscc =
            p_meas_result_list_geran->meas_result_geran[index].
            phys_cell_id.base_station_colour_code;

        if(MEAS_RESULT_GERAN_CGI_INFO_PRESENT &
            p_meas_result_list_geran->meas_result_geran[index].bitmask)
        {
            p_ue_proc_data->geran_neighbor_list[index].bitmask |=
                RRM_SON_GERAN_MR_IND_CGI_INFO_PRESENT;

            p_ue_proc_data->geran_neighbor_list[index].cgi.rat_type = 
                RRM_GERAN_CELL;

            RRM_MEMCPY(p_ue_proc_data->geran_neighbor_list[index].cgi.
                plmn_id.mcc, p_meas_result_list_geran->
                meas_result_geran[index].cgi_info.cell_global_id.
                plmn_identity.mcc, sizeof(U8) * MAX_MCC_DIGITS);

            p_ue_proc_data->geran_neighbor_list[index].cgi.
                plmn_id.num_mnc_digit = p_meas_result_list_geran->
                meas_result_geran[index].cgi_info.cell_global_id.
                plmn_identity.mnc.count;

            RRM_MEMCPY(p_ue_proc_data->geran_neighbor_list[index].cgi.
                    plmn_id.mnc, p_meas_result_list_geran->
                    meas_result_geran[index].cgi_info.cell_global_id.
                    plmn_identity.mnc.mnc, sizeof(U8) * MAX_MNC_DIGITS);


            /* First 2 bytes of cell_identity store LAC and last 2 bytes
                store cell identity */
            RRM_MEMCPY(p_ue_proc_data->geran_neighbor_list[index].cgi.
                    cell_identity,
                    p_meas_result_list_geran->
                    meas_result_geran[index].cgi_info.cell_global_id.
                    location_area_code, sizeof(U8) * MAX_LAC_SIZE);

            RRM_MEMCPY(p_ue_proc_data->geran_neighbor_list[index].cgi.
                    cell_identity + (sizeof(U8) * MAX_LAC_SIZE),
                    p_meas_result_list_geran->
                    meas_result_geran[index].cgi_info.cell_global_id.cell_identity,
                    sizeof(U8) * (MAX_CELL_IDENTITY_OCTETS - MAX_LAC_SIZE));

            if(MEAS_RESULT_GERAN_CGI_INFO_ROUTING_AREA_CODE_PRESENT &
                p_meas_result_list_geran->meas_result_geran[index].
                cgi_info.bitmask)
            {
                p_ue_proc_data->geran_neighbor_list[index].rac =
                    p_meas_result_list_geran->meas_result_geran[index].
                    cgi_info.routing_area_code;
            }
        }

        p_ue_proc_data->geran_neighbor_list[index].rssi =
            p_meas_result_list_geran->meas_result_geran[index].
            meas_result.rssi;
		    /*SPR 15393 Fix Start */	
		    p_ue_proc_data->geran_neighbor_list[index].bitmask |=
			    RRM_SON_GERAN_MR_IND_RAC_PRESENT;
		    /*SPR 15393 Fix Stop */	
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_cdma2000_nbr_list
 *   INPUT      : p_meas_results_cdma2000
 *   OUTPUT     : p_ue_proc_data
 *   DESCRIPTION:
 *       Fills the cdma2000 neighbour list parameters in meas reults ind
 *       to be sent to RMIF received from RRC.
 *
 *   RETURNS:
 *          None
 *****************************************************************************/
rrm_void_t
rrm_ue_fill_cdma2000_nbr_list(
        rrm_ue_measurment_results_ind_t     *p_ue_proc_data,
        meas_results_cdma2000_t             *p_meas_results_cdma2000
        )
{

    U8 cdma_cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_ue_proc_data->cdma2000_meas_results.pre_registration_status_hrpd =
        p_meas_results_cdma2000->pre_registration_status_hrpd;
    p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
        cdma2000_count = p_meas_results_cdma2000->meas_result_list_cdma2000.count;

    for(cdma_cell_index = RRM_ZERO;
            cdma_cell_index < p_meas_results_cdma2000->meas_result_list_cdma2000.count;
            cdma_cell_index++)
    {
        p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
            meas_result_cdma2000[cdma_cell_index].phy_cell_id = p_meas_results_cdma2000->
            meas_result_list_cdma2000.meas_result_cdma2000[cdma_cell_index].phy_cell_id;

        if(p_meas_results_cdma2000->meas_result_list_cdma2000.
                meas_result_cdma2000[cdma_cell_index].bitmask & MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT)
        {
            p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                meas_result_cdma2000[cdma_cell_index].bitmask = 
                RRM_UEM_MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT;

            if(p_meas_results_cdma2000->meas_result_list_cdma2000.
                    meas_result_cdma2000[cdma_cell_index].cgi_info.bitmask &
                    RRM_UEM_CELL_GLOBAL_ID_CDMA2000_1XRTT_PRESENT)
            {
                RRM_MEMCPY(&(p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                            meas_result_cdma2000[cdma_cell_index].cgi_info.cell_global_id_1xrtt),
                        &(p_meas_results_cdma2000->meas_result_list_cdma2000.
                            meas_result_cdma2000[cdma_cell_index].cgi_info.cell_global_id_1xrtt),
                        RRM_SIX);

                p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                    meas_result_cdma2000[cdma_cell_index].cgi_info.bitmask |=
                    RRM_UEM_CELL_GLOBAL_ID_CDMA2000_1XRTT_PRESENT;
            }
            if(p_meas_results_cdma2000->meas_result_list_cdma2000.
                    meas_result_cdma2000[cdma_cell_index].cgi_info.bitmask &
                    RRM_UEM_CELL_GLOBAL_ID_CDMA2000_HRPD_PRESENT)
            {
                RRM_MEMCPY(&(p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                            meas_result_cdma2000[cdma_cell_index].cgi_info.cell_global_id_hrpd),
                        &(p_meas_results_cdma2000->meas_result_list_cdma2000.
                            meas_result_cdma2000[cdma_cell_index].cgi_info.cell_global_id_hrpd), 
                        RRM_SIXTEEN);

                p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                    meas_result_cdma2000[cdma_cell_index].cgi_info.bitmask |=
                    RRM_UEM_CELL_GLOBAL_ID_CDMA2000_HRPD_PRESENT;
            }
        }
        if(p_meas_results_cdma2000->meas_result_list_cdma2000.
                meas_result_cdma2000[cdma_cell_index].meas_result.bitmask &
                MEAS_RESULT_CDMA2000_PILOT_PN_PHASE_PRESENT)
        {
            p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                meas_result_cdma2000[cdma_cell_index].meas_result.pilot_pn_phase = 
                p_meas_results_cdma2000->meas_result_list_cdma2000.
                meas_result_cdma2000[cdma_cell_index].meas_result.pilot_pn_phase;

            p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
                meas_result_cdma2000[cdma_cell_index].meas_result.bitmask |=
                RRM_UEM_MEAS_RESULT_CDMA2000_PILOT_PN_PHASE_PRESENT;
        }
        /*Coverity_fix_start_54971*/
        p_ue_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.
            meas_result_cdma2000[cdma_cell_index].meas_result.pilot_strength = 
            p_meas_results_cdma2000->meas_result_list_cdma2000.
            meas_result_cdma2000[cdma_cell_index].meas_result.pilot_strength;
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Saved Meas Results Ind in UE Context for CDMA2000");

    RRM_UT_TRACE_EXIT();
    /*Coverity_fix_end_54971*/
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_populate_neighbouring_cells
 *   INPUT      : rrc_rrm_measurment_results_ind,p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Populates measurment result for ecid
 *   RETURNS:
 *   rrm_void_t
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_populate_neighbouring_cells(rrc_rrm_measurment_results_ind_t *rrc_rrm_measurment_results_ind,
                                       rrm_ue_measurment_results_ind_t  * p_ue_proc_data) 
{

    RRM_UT_TRACE_ENTER();    
            if(RRM_MEASURMENT_RESULTS_NEIGH_CELLS_PRESENT
            & rrc_rrm_measurment_results_ind->bitmask)
            {
                if(RRM_MEAS_RESULT_LIST_EUTRA_PRESENT &
                rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    bitmask)
                {
                    rrm_ue_fill_eutran_nbr_list(p_ue_proc_data, 
                    &rrc_rrm_measurment_results_ind->
                            meas_result_neigh_cells.meas_result_list_eutra);
                }
                else if(RRM_MEAS_RESULT_LIST_UTRA_PRESENT &
                rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                        bitmask)
                {
                    rrm_ue_fill_utran_nbr_list(p_ue_proc_data, 
                    &rrc_rrm_measurment_results_ind->
                            meas_result_neigh_cells.meas_result_list_utra);

                }
                else if(RRM_MEAS_RESULT_LIST_GERAN_PRESENT &
                rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                        bitmask)
                {
                    rrm_ue_fill_geran_nbr_list(p_ue_proc_data,
                    &rrc_rrm_measurment_results_ind->
                            meas_result_neigh_cells.meas_result_list_geran);
                }
                else if(RRM_MEAS_RESULTS_CDMA2000_PRESENT &
                rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                      bitmask)
                {
                    rrm_ue_fill_cdma2000_nbr_list(p_ue_proc_data,
                    &rrc_rrm_measurment_results_ind->
                            meas_result_neigh_cells.meas_result_cdma2000);
                }
#ifdef ENDC_ENABLED
                else if(RRM_MEAS_RESULT_LIST_NR_R15_PRESENT &
                rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                      bitmask)
                {
                    rrm_ue_fill_nr_nbr_list(p_ue_proc_data,
                    &rrc_rrm_measurment_results_ind->
                            meas_result_neigh_cells.meas_result_list_nr_r15);
                }
#endif
        if(!(rrc_rrm_measurment_results_ind->meas_result_neigh_cells.bitmask))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                            RRM_WARNING, "No Neighbors detected! ");
                }
            }
RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_populate_measurment_results_for_ecid
 *   INPUT      : rrc_rrm_measurment_results_ind,p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Populates measurment result for ecid 
 *   RETURNS:
 *   rrm_void_t
 *****************************************************************************/
 /*Cov_fix_63676_start*/
rrm_void_t
rrm_ue_rrc_populate_measurment_results_for_ecid(rrc_rrm_measurment_results_ind_t 
                                                   * p_rrc_rrm_measurment_results_ind,
                                                rrm_ue_measurment_results_ind_t
                                                   * p_ue_proc_data)
{
    U8                          index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
            if(RRM_MEASURMENT_RESULTS_FOR_ECID_R9_PRESENT
                    & p_rrc_rrm_measurment_results_ind->bitmask)
            {
                p_ue_proc_data->meas_result_ecid_r9.ue_rxtx_time_diff = 
                    p_rrc_rrm_measurment_results_ind->meas_result_ecid_r9.ue_rxtx_time_diff_result;
                
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                    "Value of UE RxTx time Difference is [%d]",
                    p_ue_proc_data->meas_result_ecid_r9.ue_rxtx_time_diff);

                for(index = RRM_ZERO; index<ECID_CURRENT_SFN_OCTET_SIZE; index++)
                {
                    p_ue_proc_data->meas_result_ecid_r9.current_sfn_r9[index] = 
                        p_rrc_rrm_measurment_results_ind->meas_result_ecid_r9.current_sfn_r9[index];
                    
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                        "Value of index[%d] of current sfn for meas ecid is [%d]",
                        index, p_ue_proc_data->meas_result_ecid_r9.current_sfn_r9[index]);
                }
            }
   RRM_UT_TRACE_EXIT();
}
 /*Cov_fix_63676_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_measurement_results_ind
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the MEAS RESULT IND
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_measurement_results_ind(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
         /*SPR 19071 +-*/
		/*Code removed*/
         /*SPR 19071 +-*/
      )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    /* SPR 22069 Fix Start */
    rrc_rrm_measurment_results_ind_t *p_rrc_rrm_measurment_results_ind = RRM_PNULL;
    /* SPR 22069 Fix End */
    rrm_ue_measurment_results_ind_t *p_ue_proc_data = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    /* SPR 22069 Fix Start */
    p_rrc_rrm_measurment_results_ind = (rrc_rrm_measurment_results_ind_t *)
            rrm_mem_get(sizeof(rrc_rrm_measurment_results_ind_t));
    if(RRM_PNULL == p_rrc_rrm_measurment_results_ind)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Memory allocation failed for p_rrc_rrm_measurment_results_ind");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /**Parse the MEAS RESULT IND */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_measurment_results_ind(
                p_rrc_rrm_measurment_results_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        p_rrm_ue_rrc_msg->ue_index = p_rrc_rrm_measurment_results_ind->ue_index;
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_MEASURMENT_RESULTS_IND successfully parsed");
        p_ue_proc_data = (rrm_ue_measurment_results_ind_t *)
            rrm_mem_get(sizeof(rrm_ue_measurment_results_ind_t));
        if(RRM_PNULL == p_ue_proc_data)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                    "[UE:%d],Failed to allocate the "
                    "proc data for RRC_RRM_MEASURMENT_RESULTS_IND",
                    p_rrc_rrm_measurment_results_ind->ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* Populate the msg data of the serving cell */
            RRM_MEMSET(p_ue_proc_data, RRM_ZERO, sizeof(rrm_ue_measurment_results_ind_t));

            p_ue_proc_data->ue_index = p_rrc_rrm_measurment_results_ind->ue_index;
            p_ue_proc_data->meas_id = p_rrc_rrm_measurment_results_ind->meas_id;

            p_ue_proc_data->meas_result_serv_cell.rsrp_result = 
                p_rrc_rrm_measurment_results_ind->meas_result_serv_cell.
                rsrp_result;

            p_ue_proc_data->meas_result_serv_cell.rsrq_result = 
                p_rrc_rrm_measurment_results_ind->meas_result_serv_cell.
                rsrq_result;
            /* Populate the msg data of the neighbouring cells */
            rrm_ue_rrc_populate_neighbouring_cells(p_rrc_rrm_measurment_results_ind,p_ue_proc_data);
            
            /* UE Positioning start */
            /* Populate the meas result for ECID */
            /*Cov_fix_63676_start*/
            rrm_ue_rrc_populate_measurment_results_for_ecid(p_rrc_rrm_measurment_results_ind,p_ue_proc_data);
            /*Cov_fix_63676_end*/
/* UE Positioning end */


            p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_MEASURMENT_RESULTS_IND parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_rrc_rrm_measurment_results_ind);
    /* SPR 22069 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* UE MEAS CHANGES : ENDS */
/* CSR 00055769  : inter-freq HO code changes start */
/******************************************************************************
 *   FUNCTION NAME: rrm_map_source_meas_config
 *   INPUT      : p_dst_source_meas_config,p_src_source_meas_config
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map source meas_config_t structure of RRC to RRM
 *
 *   RETURNS:
 *          rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_void_t
rrm_map_source_meas_config
    (
    rrm_meas_config_t *p_dst_source_meas_config,
    rrm_meas_config_t *p_src_source_meas_config
    )
{
    U8 index= RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_dst_source_meas_config && RRM_PNULL != p_src_source_meas_config)
    {
        p_dst_source_meas_config->bitmask = p_src_source_meas_config->bitmask;
        if( p_src_source_meas_config->bitmask & UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT)
        {
            p_dst_source_meas_config->meas_object_to_add_mod_list.count =
                p_src_source_meas_config->meas_object_to_add_mod_list.count;
            /*+Coverity : CID 55814*/
            for( index = RRM_ZERO; ((index < p_src_source_meas_config->meas_object_to_add_mod_list.count) && (index < MAX_MEAS_OBJECT_ID ));index++)
            {
                p_dst_source_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index].meas_object_id =
                    p_src_source_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[index].meas_object_id;
            }
        }
        if( p_src_source_meas_config->bitmask & UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT)
        {
            p_dst_source_meas_config->report_config_to_add_mod_list.count =
                p_src_source_meas_config->report_config_to_add_mod_list.count;
            for( index = RRM_ZERO;(( index < p_src_source_meas_config->report_config_to_add_mod_list.count) && (index < MAX_REPORT_CONFIG_ID));index++)
            {
                p_dst_source_meas_config->report_config_to_add_mod_list.report_config_to_add_mod[index].report_config_id =
                    p_src_source_meas_config->report_config_to_add_mod_list.report_config_to_add_mod[index].report_config_id;
            }
        }
        if( p_src_source_meas_config->bitmask & UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT)
        {
            p_dst_source_meas_config->meas_id_to_add_mod_list.count =
                p_src_source_meas_config->meas_id_to_add_mod_list.count;
            for( index = RRM_ZERO;(( index < p_src_source_meas_config->meas_id_to_add_mod_list.count) && (index < MAX_MEAS_ID));index++)
            {
                p_dst_source_meas_config->meas_id_to_add_mod_list.meas_id_to_add_mod[index].meas_id =
                    p_src_source_meas_config->meas_id_to_add_mod_list.meas_id_to_add_mod[index].meas_id;
                p_dst_source_meas_config->meas_id_to_add_mod_list.meas_id_to_add_mod[index].meas_object_id =
                    p_src_source_meas_config->meas_id_to_add_mod_list.meas_id_to_add_mod[index].meas_object_id;
                p_dst_source_meas_config->meas_id_to_add_mod_list.meas_id_to_add_mod[index].report_config_id =
                    p_src_source_meas_config->meas_id_to_add_mod_list.meas_id_to_add_mod[index].report_config_id;
            }
        }
        if( p_src_source_meas_config->bitmask & UE_ADM_MEAS_GAP_CONFIG_PRESENT)
        {
            p_dst_source_meas_config->meas_gap_config.bitmask = p_src_source_meas_config->meas_gap_config.bitmask;
            p_dst_source_meas_config->meas_gap_config.meas_gap_config_type = p_src_source_meas_config->meas_gap_config.meas_gap_config_type;
            if( p_src_source_meas_config->meas_gap_config.bitmask & MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT)
            {
                p_dst_source_meas_config->meas_gap_config.setup_config_info.bitmask = p_src_source_meas_config->meas_gap_config.setup_config_info.bitmask;
                if(p_src_source_meas_config->meas_gap_config.setup_config_info.bitmask & MEAS_GAP_CONFIG_GP0_PRESENT)
                {
                    /* CID 55372*/
                    p_dst_source_meas_config->meas_gap_config.setup_config_info.gp0 = p_src_source_meas_config->meas_gap_config.setup_config_info.gp0;
                }
                else
                {
                    /* CID 55372*/
                    p_dst_source_meas_config->meas_gap_config.setup_config_info.gp1 = p_src_source_meas_config->meas_gap_config.setup_config_info.gp1;
                }
            }
        }
    }
    else
    {
        /* SPR 20636 Changes Start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                " Either p_dst_source_meas_config=%u or p_src_source_meas_config=%u is NULL",(U32_U32Long_Bit)p_dst_source_meas_config,(U32_U32Long_Bit)p_src_source_meas_config);
        /* SPR 20636 Changes End */
    }

    RRM_UT_TRACE_EXIT();
}
/* CSR 00055769  : inter-freq HO code changes end */

/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_req_config_ext 
 *   INPUT      : p_rrc_rrm_ho_adm_req , p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_parse_ho_adm_req_config_ext(rrc_rrm_ue_ho_adm_req_t     *p_rrc_rrm_ho_adm_req ,
                                       rrm_ue_proc_ho_adm_data_t          *p_ue_proc_data)
{
   RRM_UT_TRACE_ENTER();
    /* Carrier_Aggregation_Start */
    U8 scell_count                              = RRM_ZERO;
    /* Carrier_Aggregation_Start */
    if (SRC_TO_TRG_CONTAINER_AS_CONFIG_SCELL_ADD_MOD_LIST_PRESENT & 
            p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config_ext.bitmask)
    {
        p_ue_proc_data->bitmask |= RRM_AS_CONFIG_EXT_SCELL_ADD_MOD_LIST_PRESENT;
        /* Coverity_ID_Fix : 60867 */
        for (scell_count = RRM_ZERO; (((scell_count < p_rrc_rrm_ho_adm_req->src_to_trg_container.\
                            as_config_ext.scell_add_mod_list.count) && (scell_count < MAX_SCELL)) && (scell_count < RRM_MAX_SCELL)); scell_count++)
        {
            /* Coverity_ID_Fix : 60862 */
            p_ue_proc_data->scell_add_mod_list.rrm_scell_to_add_mod[scell_count].scell_index =
                p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config_ext.scell_add_mod_list.rrc_scell_to_add_mod[scell_count].scellIndex;
            if (RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT & p_rrc_rrm_ho_adm_req->src_to_trg_container.\
                    as_config_ext.scell_add_mod_list.rrc_scell_to_add_mod[scell_count].bitmask)
            {
                p_ue_proc_data->scell_add_mod_list.rrm_scell_to_add_mod[scell_count].bitmask |= 
                    RRM_SCELL_ADD_MOD_CELL_ID_PRESENT;
                p_ue_proc_data->scell_add_mod_list.rrm_scell_to_add_mod[scell_count].scell_id.phy_cell_id =
                    p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config_ext.scell_add_mod_list.\
                    rrc_scell_to_add_mod[scell_count].scell_Id.phy_cell_id;
                p_ue_proc_data->scell_add_mod_list.rrm_scell_to_add_mod[scell_count].scell_id.dl_carrier_freq =
                    p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config_ext.scell_add_mod_list.\
                    rrc_scell_to_add_mod[scell_count].scell_Id.dl_carrier_freq;
            }
        }
        p_ue_proc_data->scell_add_mod_list.count = scell_count;
    }
   RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_req_rrm_config_ext
 *   INPUT      : p_rrc_rrm_ho_adm_req , p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_parse_ho_adm_req_rrm_config_ext(rrc_rrm_ue_ho_adm_req_t     *p_rrc_rrm_ho_adm_req ,
                                       rrm_ue_proc_ho_adm_data_t          *p_ue_proc_data)
{
    U8                          index = RRM_NULL;
    RRM_UT_TRACE_ENTER();
    if(p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.bitmask & RRM_CONFIG_EXT_CANDIDATE_CELL_INFO_LIST_PRESENT)
    {
        p_ue_proc_data->bitmask |= RRM_SCELL_CANDIDATE_INFO_PRESENT;

        p_ue_proc_data->scell_candidate_count = p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.count;

        for(index = RRM_ZERO; index < p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.count; index++)
        {
            p_ue_proc_data->candidate_scell_info[index].pci = 
                p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.candidate_cell_info[index].phy_cell_id;

            p_ue_proc_data->candidate_scell_info[index].carrier_freq = 
                p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.candidate_cell_info[index].carrier_freq;

            if(p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.candidate_cell_info[index].bitmask &
                    CANDIDATE_CELL_INFO_RSRP_PRESENT)
            {
                p_ue_proc_data->candidate_scell_info[index].rsrp = 
                    p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.candidate_cell_info[index].rsrp_result;

                p_ue_proc_data->candidate_scell_info[index].bitmask |= CANDIDATE_SCELL_RSRP_PRESENT; 
            }

            if(p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.candidate_cell_info[index].bitmask & 
                    CANDIDATE_CELL_INFO_RSRQ_PRESENT)
            {
                p_ue_proc_data->candidate_scell_info[index].rsrq =
                    p_rrc_rrm_ho_adm_req->src_to_trg_container.rrm_config.candidate_cell_info_list.candidate_cell_info[index].rsrq_result;

                p_ue_proc_data->candidate_scell_info[index].bitmask |= CANDIDATE_SCELL_RSRQ_PRESENT;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_req_sps_config_dl
 *   INPUT      : p_sps_config , p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_parse_ho_adm_req_sps_config_dl(rrc_sps_config_t              *p_sps_config ,
                                          rrm_ue_proc_ho_adm_data_t     *p_ue_proc_data )
{
    RRM_UT_TRACE_ENTER();
    if(p_sps_config->sps_config_dl.bitmask & RRC_SPS_CONFIG_DL_PARAM_PRESENT)
    {
        p_ue_proc_data->sps_config.sps_config_dl.semi_persist_sched_interval_dl = 
            p_sps_config->sps_config_dl.sps_config_dl_param.semi_persist_sched_interval_dl;

        p_ue_proc_data->sps_config.sps_config_dl.number_of_conf_sps_processes = 
            p_sps_config->sps_config_dl.sps_config_dl_param.number_of_conf_sps_processes;
    }

    if (p_sps_config->sps_config_dl.bitmask & RRC_SPS_CONFIG_DL_PARAM_MAX_SPS_HARQ_RETX)
    {
        p_ue_proc_data->sps_config.sps_config_dl.max_sps_harq_retx = 
            p_sps_config->sps_config_dl.max_sps_harq_retx;
    }

    if (p_sps_config->sps_config_dl.bitmask & RRC_SPS_CONFIG_DL_PARAM_EXPLICIT_RELEASE_AFTER)
    {
        p_ue_proc_data->sps_config.sps_config_dl.expilcit_release_after = 
            p_sps_config->sps_config_dl.expilcit_release_after;
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_req_sps_config_ul
 *   INPUT      : p_sps_config , p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_parse_ho_adm_req_sps_config_ul(rrc_sps_config_t              *p_sps_config ,
                                          rrm_ue_proc_ho_adm_data_t     *p_ue_proc_data)
{
    RRM_UT_TRACE_ENTER();

    if(p_sps_config->sps_config_ul.bitmask & RRC_SPS_CONFIG_UL_PARAM_PRESENT)
    {
        p_ue_proc_data->sps_config.sps_config_ul.semi_persist_sched_interval_ul = 
            p_sps_config->sps_config_ul.sps_config_ul_param.semi_persist_sched_interval_ul;

        p_ue_proc_data->sps_config.sps_config_ul.implicit_release_after = 
            p_sps_config->sps_config_ul.sps_config_ul_param.implicit_release_after;

        if (p_sps_config->sps_config_ul.sps_config_ul_param.bitmask & RRC_SPS_CONFIG_UL_P_0_PERSISTENT_PRESENT)
        {
            p_ue_proc_data->sps_config.sps_config_ul.p_zero_nominal_pusch_persistent = 
                p_sps_config->sps_config_ul.sps_config_ul_param.p_zero_persistent.p_zero_nominal_pusch_persistent;

            p_ue_proc_data->sps_config.sps_config_ul.p_zero_ue_pusch_persistent = 
                p_sps_config->sps_config_ul.sps_config_ul_param.p_zero_persistent.p_zero_ue_pusch_persistent;
            /* + SPS_TDD_Changes */
#ifdef TDD_MODE_FLAG
            if (p_sps_config->sps_config_ul.sps_config_ul_param.bitmask & RRC_SPS_CONFIG_UL_TWO_INTERVALS_CONFIG_PRESENT)
            {
                p_ue_proc_data->sps_config.sps_config_ul.two_intervals_config = 
                    p_sps_config->sps_config_ul.sps_config_ul_param.two_intervals_config;
            }
#endif
            /* - SPS_TDD_Changes */
        }
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_req_eutra_radio_capability
 *   INPUT      : p_sps_config , p_ue_proc_data
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
/* SPR 21496 Fix Start */
rrm_void_t
rrm_ue_rrc_parse_ho_adm_req_eutra_radio_capability(rrc_rrm_ue_ho_adm_req_t     *p_rrc_rrm_ho_adm_req ,
                                                   rrm_ue_context_t            *p_ue_context)
                                                   /* SPR 21496 Fix End */
{
  /* SPR 21496 Fix Start */
  rrm_return_et ret_val;
  /* SPR 21496 Fix End */
  /*SPR 18250 Fix Start */
  /* Code Deleted */
  /*SPR 18250 Fix End */

  RRM_UT_TRACE_ENTER();

  /* SPR 21496 Fix Start */
  /** Release UE Capability params from UE Context if UE Capability is received again so
   * that it could not lead to memory leak **/
  rrm_ue_release_ue_capability_params(p_ue_context);
  ret_val = rrm_ue_populate_capability_params(
      &p_rrc_rrm_ho_adm_req->src_to_trg_container.rrc_radio_capability_info,
      &p_ue_context->ue_capability_params
      #ifdef ENDC_ENABLED
        ,
       p_ue_context
      #endif
    );
  if (RRM_SUCCESS == ret_val)
  {
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d],Successfully Populate UE "
        "CAPABILITY in UE Context", p_ue_context->ue_index);
  }
  else
  {
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Populate UE Capability in handover");
  }
  /* SPR 21496 Fix End */

  RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_req
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
/* SPR 21496 Fix Start */
rrm_ue_rrc_parse_ho_adm_req(
        rrc_rrm_ue_ho_adm_req_t *p_rrc_rrm_ho_adm_req,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
	/* SPR 21496 Fix End */
{
	rrm_return_et               ret_val = RRM_SUCCESS;
	rrm_ue_proc_ho_adm_data_t       *p_ue_proc_data = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t       ho_adm_item_list = {RRM_ZERO};
	src_to_trg_container_t            *p_src_to_trg_container = RRM_PNULL;
	as_config_t                       *p_as_config = RRM_PNULL; 
	rrm_drb_to_add_info_list_t        *p_rrm_drb_to_add_info_list = RRM_PNULL;
	U8                                 drb_count = RRM_ZERO;
	U8                          index = RRM_NULL;
	/* SPS related changes start */
	rrc_sps_config_t              *p_sps_config = RRM_PNULL;
	rrc_drx_config_t              *p_drx_config = RRM_PNULL;
	/* SPS related changes end */
	RRM_UT_TRACE_ENTER();

	RRM_MEMSET(&ho_adm_item_list, RRM_ZERO,
			sizeof(rrm_ue_erab_setup_item_list_t));

	/* SPR 21496 Fix Start */
	/* Code removed */
	/* SPR 21496 Fix End */
	/* Raise Event RRM_EVENT_LOCAL_HO_IN_PREP_ATTEMPT START*/
	rrm_raise_event_ho_in_prep_attempt(p_rrc_rrm_ho_adm_req);
	/* Raise Event RRM_EVENT_LOCAL_HO_IN_PREP_ATTEMPT END*/

	p_rrm_ue_rrc_msg->ue_index = p_rrc_rrm_ho_adm_req->ue_index;

	/* Rel10_CRs 420 start */

	p_ue_proc_data = (rrm_ue_proc_ho_adm_data_t*)
		rrm_mem_get(sizeof(rrm_ue_proc_ho_adm_data_t));
	if(RRM_PNULL == p_ue_proc_data)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
				"[UE:%d],Failed to allocate the proc data for "
				"RRC_RRM_HO_ADM_REQ", p_rrc_rrm_ho_adm_req->ue_index);
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_MEMSET(p_ue_proc_data, RRM_ZERO, sizeof(rrm_ue_proc_ho_adm_data_t));
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
				"[UE:%d],Successfully allocated the "
				"proc data for RRC_RRM_HO_ADM_REQ",
				p_rrc_rrm_ho_adm_req->ue_index);
		p_ue_proc_data->ho_type = p_rrc_rrm_ho_adm_req->ho_type;

		p_ue_proc_data->ambr.ue_agg_max_bit_rate_ul =
			p_rrc_rrm_ho_adm_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul;
		p_ue_proc_data->ambr.ue_agg_max_bit_rate_dl =
			p_rrc_rrm_ho_adm_req->ue_agg_max_bit_rate.
			ue_agg_max_bit_rate_dl;
		/*+Coverity : CID  28815 +*/
		/*coverity 11187, rrm_ue_history_t replaced with ue_history_t, aditya rel1.3.1*/
		RRM_MEMCPY(&p_ue_proc_data->ue_history,&p_rrc_rrm_ho_adm_req->src_to_trg_container.ue_history, sizeof(ue_history_t));
		/* Rel10_CRs 420 start */
		if (SRC_TO_TRG_CONTAINER_AS_CONFIG_PRESENT & p_rrc_rrm_ho_adm_req->src_to_trg_container.bitmask)
		{
			p_ue_proc_data->bitmask |= RRM_HO_ADM_REQ_CSG_ID_PRESENCE_FLAG;
			/* copying CSG ID to ue proc data */
			RRM_MEMCPY(p_ue_proc_data->csg_identity, p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.sib_type1_info.\
					cell_access_related_info.csg_identity, CSG_ID_OCTET_SIZE);

			/* SPR 14537 start */
			if(RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAME_PATTERN_CONFIG_R10_PRESENT & 
					p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.radio_resource_config_dedicated.
					rrc_phy_physical_config_dedicated.cqi_report_config_r10.bitmask)
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"MEAS subframe pattern present during HO ADM REQ");
				p_ue_proc_data->bitmask |= RRM_HO_ADM_REQ_MEAS_SUBFRAME_PATTERN_PRESENT;

			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"MEAS subframe pattern not present during HO ADM REQ");
				p_ue_proc_data->bitmask |= RRM_HO_ADM_REQ_MEAS_SUBFRAME_PATTERN_PRESENT;
			}
			/* SPR 14537 end */
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
					"CSG ID in HO ADM Req [0x%x%x%x%x], CSG ID copy to UE proc data [0x%x%x%x%x]"
					"for RRC_RRM_HO_ADM_REQ",p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.sib_type1_info.\
					cell_access_related_info.csg_identity[RRM_ZERO], p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.sib_type1_info.\
					cell_access_related_info.csg_identity[RRM_ONE], p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.sib_type1_info.\
					cell_access_related_info.csg_identity[RRM_TWO], p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.sib_type1_info.\
					cell_access_related_info.csg_identity[RRM_THREE],p_ue_proc_data->csg_identity[RRM_ZERO],p_ue_proc_data->csg_identity[RRM_ONE],\
					p_ue_proc_data->csg_identity[RRM_TWO],p_ue_proc_data->csg_identity[RRM_THREE]);
		}
		/* Rel10_CRs 420 end */

		/* Carrier_Aggregation_Start */
		if (SRC_TO_TRG_CONTAINER_AS_CONFIG_EXT_PRESENT & p_rrc_rrm_ho_adm_req->src_to_trg_container.bitmask)
		{
			/*Klockwork_fix_start*/
			rrm_ue_rrc_parse_ho_adm_req_config_ext(p_rrc_rrm_ho_adm_req ,p_ue_proc_data);
			/*Klockwork_fix_end*/
		}
		/* Carrier_Aggregation_End */

		/* CA: Stage3 HO code start */
		if(SRC_TO_TRG_CONTAINER_RRM_CONFIG_EXT_PRESENT & p_rrc_rrm_ho_adm_req->src_to_trg_container.bitmask)
		{
			/*Klockwork_fix_start*/
			rrm_ue_rrc_parse_ho_adm_req_rrm_config_ext(p_rrc_rrm_ho_adm_req ,p_ue_proc_data);
			/*Klockwork_fix_end*/
		}
		/* CA: Stage3 HO code end */

		/* SPS related changes start */
		p_sps_config = 
			(rrc_sps_config_t *)&(p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.radio_resource_config_dedicated.sps_config);            

		if (p_sps_config->bitmask & RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT)
		{
			/*Klockwork_fix_start*/
			rrm_ue_rrc_parse_ho_adm_req_sps_config_dl(p_sps_config ,p_ue_proc_data);
			/*Klockwork_fix_end*/  
		}

		if (p_sps_config->bitmask & RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT)
		{
			/*Klockwork_fix_start*/
			rrm_ue_rrc_parse_ho_adm_req_sps_config_ul(p_sps_config ,p_ue_proc_data);
			/*Klockwork_fix_end*/
		}

		p_drx_config = 
			(rrc_drx_config_t *)&(p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.radio_resource_config_dedicated.mac_main_config.drx_config);

		if (p_drx_config->bitmask & RRC_DRX_CONFIG_PARAM_PRESENT)
		{
			p_ue_proc_data->drx_config.on_duration_timer = 
				p_drx_config->drx_config_param.on_duration_timer;

			p_ue_proc_data->drx_config.drx_inactivity_timer = 
				p_drx_config->drx_config_param.drx_inactivity_timer;

		}
		/* SPS related changes end */
		if(p_rrc_rrm_ho_adm_req->bitmask & 
				RRC_RRM_UE_HO_ADM_REQ_HO_RESTRICTION_LIST_PRESENT)
		{ 
			/*BUG 680 FIX START*/
			rrm_map_ho_restriction_list(&p_ue_proc_data->ho_restriction_list,&p_rrc_rrm_ho_adm_req->ho_restriction_list);
			/*BUG 680 FIX END*/
		}

		/*SPR_17893_START*/
		if(p_rrc_rrm_ho_adm_req->src_to_trg_container.rrc_radio_capability_info.\
				bitmask & UTRA_RADIO_CAPABILITY_PRESENT)
		{
			p_ue_proc_data->ue_capability_params.bitmask |=
				RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT;
		}
		/*SPR_17893_END*/
        /*SPR_19066_START*/
        /* Code deleted */
        /*SPR_19066_END*/
        /* SPR 22553 FIXED START*/
        if(p_rrc_rrm_ho_adm_req->src_to_trg_container.bitmask & SRC_TO_TRG_CONTAINER_SUB_PROFILE_ID_PRESENT)
        {    
            p_ue_proc_data->sub_profile_id =
                p_rrc_rrm_ho_adm_req->src_to_trg_container.sub_profile_id;

            p_ue_proc_data->bitmask |= RRM_HO_ADM_REQ_SUB_PROFILE_ID_PRESENT;       

        }    
        /* SPR 22553 FIXED START*/

		ho_adm_item_list.num_of_list =
			p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.num_of_list;

		p_src_to_trg_container = (src_to_trg_container_t *) &(p_rrc_rrm_ho_adm_req->src_to_trg_container);
		p_as_config = (as_config_t *)&(p_src_to_trg_container->as_config);
		p_rrm_drb_to_add_info_list = (rrm_drb_to_add_info_list_t *)&(p_as_config->radio_resource_config_dedicated.rrm_drb_to_add_info_list);

		/* SRVCC SUPPORT START */
		if((p_rrc_rrm_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_SRVCC_OP_POSSIBLE_PRESENT)
				&& (RRM_TRUE == p_rrc_rrm_ho_adm_req->srvcc_op_possible))
		{
			p_ue_proc_data->srvcc_op_possible = RRM_TRUE;
		}
		else
		{
			p_ue_proc_data->srvcc_op_possible = RRM_FALSE;
		}
		/* SRVCC SUPPORT END */

		/*csg membership start*/
		if(p_rrc_rrm_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT)            
		{
			p_ue_proc_data->bitmask |= RRM_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT;
			if(p_rrc_rrm_ho_adm_req->csg_membership_status == RRC_MEMBER) /* Coverity: CID 22558 */
			{
				p_ue_proc_data->csg_membership_status = RRM_MEMBER;
			}
			else/*RRC_NOT_MEMBER*/
			{
				p_ue_proc_data->csg_membership_status = RRM_NOT_MEMBER;
			}
		}
		/*csg membership end*/

		for(index=RRM_NULL;index< ho_adm_item_list.num_of_list; index++ )
		{
			ho_adm_item_list.erab_item[index].erab_id =
				p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.
				erab_to_be_setup_item[index].erab_id;
			for(drb_count = RRM_ZERO; drb_count < p_rrm_drb_to_add_info_list->drb_count; drb_count++)
			{
				if(p_rrm_drb_to_add_info_list->drb_config[drb_count].erab_id == 
						ho_adm_item_list.erab_item[index].erab_id)
				{
					ho_adm_item_list.erab_item[index].drb_id = 
						p_rrm_drb_to_add_info_list->drb_config[drb_count].drb_id;
					/*+ SPR 18090 */
					ho_adm_item_list.erab_item[index].lc_id = 
						p_rrm_drb_to_add_info_list->drb_config[drb_count].logical_channel_identity;
					/*- SPR 18090 */
					break;
				}
			}

			ho_adm_item_list.erab_item[index].erab_level_qos_params.
				bitmask = p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.
				erab_to_be_setup_item[index].erab_level_qos_params.
				bitmask;

			ho_adm_item_list.erab_item[index].erab_level_qos_params.
				qci = p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.
				erab_to_be_setup_item[index].erab_level_qos_params.qci;

			ho_adm_item_list.erab_item[index].erab_level_qos_params.
				alloc_and_reten_prior.priority_level =
				p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.
				erab_to_be_setup_item[index].erab_level_qos_params.
				alloc_and_reten_prior.priority_level;

			ho_adm_item_list.erab_item[index].erab_level_qos_params.
				alloc_and_reten_prior.preemption_capability =
				p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.
				erab_to_be_setup_item[index].erab_level_qos_params.
				alloc_and_reten_prior.preemption_capability;

			ho_adm_item_list.erab_item[index].erab_level_qos_params.
				alloc_and_reten_prior.preemption_vulnerability =
				p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.
				erab_to_be_setup_item[index].erab_level_qos_params.
				alloc_and_reten_prior.preemption_vulnerability;

			if (p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].
					erab_level_qos_params.bitmask & ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT)
			{
				ho_adm_item_list.erab_item[index].erab_level_qos_params.
					gbr_qos_info.erab_max_bit_rate_dl = 
					p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].
					erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl;

				ho_adm_item_list.erab_item[index].erab_level_qos_params.
					gbr_qos_info.erab_max_bit_rate_ul = 
					p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].
					erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul;

				ho_adm_item_list.erab_item[index].erab_level_qos_params.
					gbr_qos_info.erab_guar_bit_rate_dl = 
					p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].
					erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;

				ho_adm_item_list.erab_item[index].erab_level_qos_params.
					gbr_qos_info.erab_guar_bit_rate_ul = 
					p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].
					erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;
			}
			/*SPR 5589 Fix START */
			ho_adm_item_list.erab_item[index].dl_fwding =
				p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].dl_fwding;
			/*SPR 5589 Fix END */
			/*SPR_17817_Fix_Start*/
			/*SPR_18138_Fix_Start*/                
			if((p_rrc_rrm_ho_adm_req->erab_to_be_setup_item_list.erab_to_be_setup_item[index].bitmask
						& ERAB_TO_BE_SETUP_DATA_FWDING_NOT_POSSIBLE_INFO_PRESENT_FLAG))
				/*SPR_18138_Fix_End*/          
			{
				ho_adm_item_list.erab_item[index].data_fwding_not_possible =
					RRM_FALSE;
			}
			else
			{
				ho_adm_item_list.erab_item[index].data_fwding_not_possible =
					RRM_TRUE;
			}
			/*SPR_17817_Fix_End*/
		}
		/*SPR 15180 Fix Start*/
		if(p_rrc_rrm_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT)
		{
			p_ue_proc_data->bitmask |= RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT;
			RRM_MEMCPY(&p_ue_proc_data->gummei_info,&p_rrc_rrm_ho_adm_req->gummei_info,
					sizeof(rrm_mme_sel_gummei_info_t));
		}
		/*SPR 10329:fix end*/
		/* CSR 00055769  : inter-freq HO code changes start */
		if( p_rrc_rrm_ho_adm_req->src_to_trg_container.bitmask & SRC_TO_TRG_CONTAINER_AS_CONFIG_PRESENT)
		{
			rrm_map_source_meas_config( &(p_ue_proc_data->meas_config),
					&(p_rrc_rrm_ho_adm_req->src_to_trg_container.as_config.meas_config));
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
					" HO_ADM_REQ p_src_to_trg_container->bitmask =%x",p_src_to_trg_container->bitmask);
		}
		/* CSR 00055769  : inter-freq HO code changes end*/
		RRM_MEMCPY(&p_ue_proc_data->erab_setup_list,&ho_adm_item_list,
				sizeof(rrm_ue_erab_setup_item_list_t));
            
        /* SPR 20632 21459 START */
        if(p_rrc_rrm_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_MME_ID_PRESENT)
        {
            p_ue_proc_data->mme_id = p_rrc_rrm_ho_adm_req->mme_id;
            p_ue_proc_data->bitmask |= RRM_HO_ADM_REQ_MME_ID_PRESENT;
        }
        /* SPR 20632 21459 END */

		p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;
		ret_val = RRM_SUCCESS;
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*MC, MR & HO  START*/

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_cancel_resp
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO CANCEL RESPONSE
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ho_cancel_resp(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ho_cancel_resp_t    rrm_ue_ho_cancel_resp;
    rrm_ue_proc_ho_cancel_resp_t *p_rrm_ho_proc_cancel_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    
    /**Parse the HO_CANCEL_RESP */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ho_cancel_resp(&rrm_ue_ho_cancel_resp,
                                                            p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                                            data_len,
                                                            &length_read))
    {
         p_rrm_ho_proc_cancel_resp = (rrm_ue_proc_ho_cancel_resp_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_ho_cancel_resp_t));
        if (RRM_PNULL == p_rrm_ho_proc_cancel_resp)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],"
                   "Failed to allocate the ho cancel response",rrm_ue_ho_cancel_resp.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_rrm_ue_rrc_msg->ue_index = rrm_ue_ho_cancel_resp.ue_index;
                        /** TO BE UPADTE LATER - when RRC will provide the cell index */
/*BUG 585, Multisector change start*/
            p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ho_proc_cancel_resp->ue_index);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_HO_CANCEL_RESP:[UE:%d] with response: %d",
                    rrm_ue_ho_cancel_resp.ue_index, rrm_ue_ho_cancel_resp.response);
            p_rrm_ho_proc_cancel_resp->ue_index = rrm_ue_ho_cancel_resp.ue_index;
            p_rrm_ho_proc_cancel_resp->response =  rrm_ue_ho_cancel_resp.response;
            p_rrm_ue_rrc_msg->p_msg_data = p_rrm_ho_proc_cancel_resp;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        /*Cov_fix_54424*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->UEM:RRC_RRM_HO_CANCEL_RESP failed to parse");
        /*Cov_fix_54424*/
        ret_val = RRM_FAILURE;
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_failure
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO FAILURE
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ho_failure(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ho_failure_t        rrm_ue_ho_failure = {RRM_NULL};
    rrm_ue_proc_ho_failure_t    *p_rrm_ho_proc_failure = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    
    /**Parse the HO_FAILURE */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ho_failure(
                                & rrm_ue_ho_failure,
                                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                data_len,
                                &length_read))
    {
        p_rrm_ho_proc_failure = (rrm_ue_proc_ho_failure_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_ho_failure_t));
        if (RRM_PNULL == p_rrm_ho_proc_failure)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],"
                   "Failed to allocate the ho failure",rrm_ue_ho_failure.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_rrm_ue_rrc_msg->ue_index = rrm_ue_ho_failure.ue_index;
                        /** TO BE UPADTE LATER - when RRC will provide the cell index */
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
            
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "RRC->UEM:RRC_RRM_HO_FAILURE successfully parsed cause %d type %d",
                    rrm_ue_ho_failure.rrm_cause.value, rrm_ue_ho_failure.rrm_cause.type);
            /*+Coverity : CID 28817 +*/
            /*BUG 680 FIX START*/
            rrm_map_rrm_ue_proc_ho_failure(p_rrm_ho_proc_failure, &rrm_ue_ho_failure);
            /*BUG 680 FIX END*/
            /*-Coverity : CID 28817 -*/
            p_rrm_ue_rrc_msg->p_msg_data = p_rrm_ho_proc_failure;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_HO_FAILURE parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val; 
}    

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_cmd_req
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO CMD REQ
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ho_cmd_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_ho_command_request_t rrm_ue_ho_command_request;
    rrm_ue_proc_ho_command_request_t   *p_rrm_ho_proc_cmd_req = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    
    /**Parse the HO_CMD_REQ */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_ho_command_request(
                                &rrm_ue_ho_command_request,
                                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                data_len,
                                &length_read))
    {
        p_rrm_ho_proc_cmd_req = (rrm_ue_proc_ho_command_request_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_ho_command_request_t));
        if (RRM_PNULL == p_rrm_ho_proc_cmd_req)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],"
                   "Failed to allocate the ho cmd req data",rrm_ue_ho_command_request.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            p_rrm_ue_rrc_msg->ue_index = rrm_ue_ho_command_request.ue_index;
                        /** TO BE UPADTE LATER - when RRC will provide the cell index */
/*BUG 585, Multisector change start*/
         p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "RRC->UEM:RRC_RRM_UE_HO_CMD_REQ successfully parsed");
            
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "[UE:%d],allocated the HO CMD REQ data",\
                                    rrm_ue_ho_command_request.ue_index);
	    /*coverity 11188: rrc_rrm_ue_ho_command_request_t used for size, aditya, rel1.3.1*/
	    /*BUG 680 FIX START*/
            RRM_MEMSET(p_rrm_ho_proc_cmd_req, RRM_ZERO, sizeof(rrm_ue_proc_ho_command_request_t));
            rrm_map_rrm_ue_proc_ho_command_request(p_rrm_ho_proc_cmd_req,&rrm_ue_ho_command_request);
            /*BUG 680 FIX END */
            /* CDMA changes start */
            p_rrm_ho_proc_cmd_req->cdma2000_ho_status[RRM_ZERO] = rrm_ue_ho_command_request.
                cdma2000_ho_status[RRM_ZERO];
            p_rrm_ho_proc_cmd_req->cdma2000_ho_status[RRM_ONE] = rrm_ue_ho_command_request.
                cdma2000_ho_status[RRM_ONE];
            /* CDMA changes end */

            p_rrm_ue_rrc_msg->p_msg_data = p_rrm_ho_proc_cmd_req;
                         
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_UE_HO_CMD_REQ parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*MC, MR & HO  END*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_adm_cnf
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO ADM CNF
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ho_adm_cnf(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_ho_adm_cnf_t     rrc_rrm_ho_adm_cnf;
    rrm_ue_proc_ho_adm_cnf_data_t *p_rrm_proc_ho_cnf_data;
    U8                          index = RRM_NULL;
    rrm_cell_context_t          *p_cell_ctxt = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    RRM_UT_TRACE_ENTER();
    /**Parse the HO_ADM_CNF */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_ho_adm_cnf(
                                &rrc_rrm_ho_adm_cnf,
                                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                data_len,
                                &length_read))
    {
        p_rrm_proc_ho_cnf_data = (rrm_ue_proc_ho_adm_cnf_data_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_ho_adm_cnf_data_t));

        if (RRM_PNULL == p_rrm_proc_ho_cnf_data)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],"
                        "Failed to allocate the ho adm conf data",rrc_rrm_ho_adm_cnf.ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /*+ Valgrind Fix 29 Nov 2013 +*/
            RRM_MEMSET(p_rrm_proc_ho_cnf_data,RRM_ZERO,sizeof(rrm_ue_proc_ho_adm_cnf_data_t));
            /*- Valgrind Fix 29 Nov 2013 -*/

            p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ho_adm_cnf.ue_index;
            /*BUG 585, Multisector change start*/
            p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
            /*BUG 585, Multisector change end*/

            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
            
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_UE_HO_ADM_CNF:[UE:%d] with response: %d",
                    rrc_rrm_ho_adm_cnf.ue_index, rrc_rrm_ho_adm_cnf.response);
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "[UE:%d],allocated the HO ADM CNF data",\
                                    rrc_rrm_ho_adm_cnf.ue_index);

            p_rrm_proc_ho_cnf_data->response =
                    rrc_rrm_ho_adm_cnf.response;
            p_rrm_proc_ho_cnf_data->erab_item_list.count =
                    rrc_rrm_ho_adm_cnf.erab_item_list.count;
            for(index=RRM_NULL;
                index<p_rrm_proc_ho_cnf_data->erab_item_list.count
                ; index++)
            {
                p_rrm_proc_ho_cnf_data->erab_item_list.erab_id[index]=
                        rrc_rrm_ho_adm_cnf.erab_item_list.erab_id[index];
            }

            p_rrm_ue_rrc_msg->p_msg_data = p_rrm_proc_ho_cnf_data;
            ret_val = RRM_SUCCESS;

            /*KPI:start ho success and fail */
            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
                    p_rrm_ue_rrc_msg->cell_index);
            if(RRM_PNULL != p_ue_context)
            {
                p_cell_ctxt =  rrm_cellm_get_cell_context(p_rrm_ue_rrc_msg->cell_index);
                /*cov_fix_65819_start*/
                if (RRM_PNULL == p_cell_ctxt )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                /*cov_fix_65819_end*/

                switch(p_ue_context->ho_typ)
                {
                    case RRM_HANDOVER_TYPE_UTRAN_TO_LTE:
                        {
                            if (RRM_FAILURE == rrc_rrm_ho_adm_cnf.response)
                            {
                                p_cell_ctxt->kpi_stat.kpi.num_of_utran_hi_fail += RRM_ONE;
                            }
                            else
                            {
                                p_cell_ctxt->kpi_stat.kpi.num_of_utran_hi_success += RRM_ONE;
                                /*erb success and fail*/
                                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_success +=
                                    rrc_rrm_ho_adm_cnf.erab_item_list.count;
                                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_fail +=
                                    rrc_rrm_ho_adm_cnf.erab_failed_item_list.count;
                            }
                        }
                        break;
                    case RRM_HANDOVER_TYPE_GERAN_TO_LTE:
                        {
                            if (RRM_FAILURE == rrc_rrm_ho_adm_cnf.response)
                            {
                                p_cell_ctxt->kpi_stat.kpi.num_of_geran_hi_fail += RRM_ONE;
                            }
                            else
                            {
                                p_cell_ctxt->kpi_stat.kpi.num_of_geran_hi_success += RRM_ONE;
                                /*erb success and fail*/
                                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_success +=
                                    rrc_rrm_ho_adm_cnf.erab_item_list.count;
                                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_fail +=
                                    rrc_rrm_ho_adm_cnf.erab_failed_item_list.count;
                            }
                        }
                        break;
                    case RRM_HANDOVER_TYPE_INTRA_CELL:
                    case RRM_HANDOVER_TYPE_INTER_CELL:
                    case RRM_HANDOVER_TYPE_INTRA_LTE_X2:
                        /* SPR 20742 start */
                    case RRM_HANDOVER_TYPE_INTRA_LTE_S1:
                        /* SPR 20742 end */
                        {
                            if (RRM_FAILURE == rrc_rrm_ho_adm_cnf.response)
                            {
                                p_cell_ctxt->kpi_stat.kpi.num_of_eutran_hi_fail += RRM_ONE;
                            }
                            else
                            {
                                p_cell_ctxt->kpi_stat.kpi.num_of_eutran_hi_success += RRM_ONE;
                                /*erb success and fail*/
                                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_success +=
                                    rrc_rrm_ho_adm_cnf.erab_item_list.count;
                                p_cell_ctxt->kpi_stat.kpi.num_of_erb_setup_fail +=
                                    rrc_rrm_ho_adm_cnf.erab_failed_item_list.count;
                            }
                        }
                        break;
                        /* cyclo start */ 
                        break;
                    default:
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                                "HO_ADM_CNF is for[%d] ",p_ue_context->ho_typ);
                        break;
                        /* cyclo end */   
                }
            }
            /* SPR 20652 Fix End */
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                 "UE context not found for [UE:%d] ",p_rrm_ue_rrc_msg->ue_index);
            }
            /*KPI:end*/
            /*Raise Event RRM_EVENT_LOCAL_HO_IN_EXEC_COMPLETE*/
            rrm_raise_event_ho_in_exec_complete();/*SPR 17777 +-*/    
            /*Raise Event RRM_EVENT_LOCAL_HO_IN_EXEC_COMPLETE*/
        }
    }
    else
    {
        /*Cov_fix_54424*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_UE_HO_ADM_CNF->UEM failed to process");
        /*Cov_fix_54424*/
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_restriction_forbidden_la_list
 *   INPUT      : p_rrc_rrm_ho_restriction_ind,p_rrm_plmn_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO RESTRICTION forbidden la list
 *   RETURNS:
 *      rrm_void_t
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_parse_ho_restriction_forbidden_la_list(rrc_rrm_ho_restriction_list_ind_t 
                                                                     *p_rrc_rrm_ho_restriction_ind,
                                   rrm_plmn_identity_t               *p_rrm_plmn_id,      
                                   rrm_ue_proc_ho_restriction_list_t *p_rrm_proc_ho_restriction_ind)
{

    
	forbidden_la_list_t			*p_forbidden_la_list = RRM_PNULL;
	rrm_forbidden_la_list_t		*p_forbidden_la_dst_list = RRM_PNULL;
	forbidden_lac_list_t		*p_forbidden_lac_list = RRM_PNULL;
	rrm_forbidden_lac_list_t	*p_forbidden_lac_dst_list = RRM_PNULL;
	plmn_identity_t             *p_plmn_id = RRM_PNULL;
	U16							la_count = RRM_ZERO;
	U16							lac_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    
			if(p_rrc_rrm_ho_restriction_ind->ho_restriction_list.bitmask & \
					HO_RESTRICTION_FORBIDDEN_LA_LIST_PRESENT)
			{
				p_forbidden_la_list = &(p_rrc_rrm_ho_restriction_ind->\
						ho_restriction_list.forbidden_la_list);
				p_forbidden_la_dst_list = &(p_rrm_proc_ho_restriction_ind->\
						ho_restriction_list.forbidden_la_list);
				p_forbidden_la_dst_list->count = p_forbidden_la_list->count;
				/*SPR 20589 FIX START*/
				p_forbidden_la_dst_list->p_forbidden_la=(rrm_forbidden_la_t *)rrm_mem_get(p_forbidden_la_list->count*sizeof(rrm_forbidden_la_t)); 
				for(la_count = RRM_ZERO; la_count < p_forbidden_la_list->count; \
						la_count++)
				{
					p_rrm_plmn_id = &(p_forbidden_la_dst_list->\
							p_forbidden_la[la_count].plmn_identity);
					/*SPR 20589 FIX END*/
					p_plmn_id = &(p_forbidden_la_list->forbidden_la[la_count].\
							plmn_identity);
					
					if(p_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
					{
						p_rrm_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                                               RRM_MEMCPY(p_rrm_plmn_id->mcc,
                                                          p_plmn_id->mcc,
                                                          MCC_OCTET_SIZE);
					}
					p_rrm_plmn_id->mnc.count = p_plmn_id->mnc.count; 
                                               RRM_MEMCPY(p_rrm_plmn_id->mnc.mnc,
                                                          p_plmn_id->mnc.mnc,
                                                          MAX_MNC_OCTET_SIZE);
					p_forbidden_lac_list = & (p_forbidden_la_list->\
							forbidden_la[la_count].forbidden_lacs_list);
					/*SPR 20589 FIX START*/
					p_forbidden_lac_dst_list = & (p_forbidden_la_dst_list->\
							p_forbidden_la[la_count].forbidden_lacs_list);
					p_forbidden_lac_dst_list->count = p_forbidden_lac_list->count;
					p_forbidden_lac_dst_list->p_forbidden_lac=(rrm_forbidden_lac_t *)rrm_mem_get
						(p_forbidden_lac_dst_list->count*sizeof(rrm_forbidden_lac_t)); 
					for(lac_count=RRM_ZERO; lac_count < p_forbidden_lac_dst_list->count; \
							lac_count++)
					{
                                               RRM_MEMCPY(p_forbidden_lac_dst_list->\
							       p_forbidden_lac[lac_count].lac,p_forbidden_lac_list->\
							       /*SPR 20589 FIX END*/
							       forbidden_lac[lac_count].lac ,RRM_TWO );

					}		
				}
			}
 RRM_UT_TRACE_EXIT();  
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_restriction_forbidden_ta_list
 *   INPUT      : p_rrc_rrm_ho_restriction_ind,p_rrm_plmn_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO RESTRICTION forbidden ta list
 *   RETURNS:
 *      rrm_void_t
 *****************************************************************************/
rrm_void_t
rrm_ue_rrc_parse_ho_restriction_forbidden_ta_list(rrc_rrm_ho_restriction_list_ind_t 
                                                            *p_rrc_rrm_ho_restriction_ind,
                          rrm_plmn_identity_t               *p_rrm_plmn_id,
                          rrm_ue_proc_ho_restriction_list_t *p_rrm_proc_ho_restriction_ind)
{

    
	forbidden_ta_list_t			*p_forbidden_ta_list = RRM_PNULL;
	rrm_forbidden_ta_list_t		*p_forbidden_ta_dst_list = RRM_PNULL;
	forbidden_tac_list_t		*p_forbidden_tac_list = RRM_PNULL;
	rrm_forbidden_tac_list_t	*p_forbidden_tac_dst_list = RRM_PNULL;
	plmn_identity_t             *p_plmn_id = RRM_PNULL;
    U16							ta_count = RRM_ZERO;
	U16							tac_count = RRM_ZERO;
    
    RRM_UT_TRACE_ENTER();
    
			if(p_rrc_rrm_ho_restriction_ind->ho_restriction_list.bitmask & \
					HO_RESTRICTION_FORBIDDEN_TA_LIST_PRESENT)
			{
				p_forbidden_ta_list = &(p_rrc_rrm_ho_restriction_ind->\
                        ho_restriction_list.forbidden_ta_list);	
				p_forbidden_ta_dst_list = &(p_rrm_proc_ho_restriction_ind->\
                        ho_restriction_list.forbidden_ta_list);	
				p_forbidden_ta_dst_list->count = p_forbidden_ta_list->count;
				/*SPR 20589 FIX START*/
				p_forbidden_ta_dst_list->p_forbidden_ta=(rrm_forbidden_ta_t *)rrm_mem_get(p_forbidden_ta_dst_list->\
                                                                         count*sizeof(rrm_forbidden_ta_t)); 
				for(ta_count = RRM_ZERO; ta_count < p_forbidden_ta_list->count; \
						ta_count++)
				{
					p_rrm_plmn_id = &(p_forbidden_ta_dst_list->\
							p_forbidden_ta[ta_count].plmn_identity);
					/*SPR 20589 FIX END*/
					p_plmn_id = &(p_forbidden_ta_list->forbidden_ta[ta_count].\
							plmn_identity);
					
					if(p_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
					{
						p_rrm_plmn_id->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                                               RRM_MEMCPY(p_rrm_plmn_id->mcc,
                                                          p_plmn_id->mcc,
                                                          MCC_OCTET_SIZE);
					}
					p_rrm_plmn_id->mnc.count = p_plmn_id->mnc.count;
                                               RRM_MEMCPY(p_rrm_plmn_id->mnc.mnc,
                                                          p_plmn_id->mnc.mnc,
                                                          MAX_MNC_OCTET_SIZE);
					
					p_forbidden_tac_list = & (p_forbidden_ta_list->\
							forbidden_ta[ta_count].forbidden_tac);
					/*SPR 20589 FIX START*/
					p_forbidden_tac_dst_list = & (p_forbidden_ta_dst_list->\
							p_forbidden_ta[ta_count].forbidden_tac);
					p_forbidden_tac_dst_list->count = p_forbidden_tac_list->count;
					p_forbidden_tac_dst_list->p_forbidden_tac=(rrm_forbidden_tac_t *)rrm_mem_get(p_forbidden_tac_dst_list->\
                                                                                    count*sizeof(rrm_forbidden_tac_t)); 
					for(tac_count = RRM_ZERO; tac_count < p_forbidden_tac_dst_list->count; \
							tac_count++)
					{
						RRM_MEMCPY(p_forbidden_tac_dst_list->\
								p_forbidden_tac[tac_count].tac,p_forbidden_tac_list->\
								/*SPR 20589 FIX END*/
								forbidden_tac[tac_count].tac ,RRM_TWO );
					}		
				}
			}
 RRM_UT_TRACE_EXIT();
}
/* cyclo end */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ho_restriction_ind
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *      Parse the HO RESTRICTION IND message
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ho_restriction_ind(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_ho_restriction_list_ind_t     *p_rrc_rrm_ho_restriction_ind = RRM_PNULL;
	/* UT Fis start */
            /*SPR_20521_FIX_START*/
            /*code deleted*/
            /*SPR_20521_FIX_STOP*/
        rrm_ue_proc_ho_restriction_list_t *p_rrm_proc_ho_restriction_ind = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_ho_restriction_ind = (rrc_rrm_ho_restriction_list_ind_t*)
                                   rrm_mem_get(sizeof(rrc_rrm_ho_restriction_list_ind_t));
    if (RRM_PNULL == p_rrc_rrm_ho_restriction_ind)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    /**Parse the HO_ADM_CNF */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ho_restriction_list_ind(
                                p_rrc_rrm_ho_restriction_ind,
                                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                data_len,
                                &length_read))
    {
        p_rrm_proc_ho_restriction_ind = (rrm_ue_proc_ho_restriction_list_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_ho_restriction_list_t));
        if (RRM_PNULL == p_rrm_proc_ho_restriction_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],"
                        "Failed to allocate the ho restriction ind data",p_rrc_rrm_ho_restriction_ind->ue_index);
            /* BUG_11576_FIX_START */
            RRM_MEM_FREE(p_rrc_rrm_ho_restriction_ind);
            /* BUG_11576_FIX_END */
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        else
        {
            p_rrm_ue_rrc_msg->ue_index = p_rrc_rrm_ho_restriction_ind->ue_index;
                        /** TO BE UPADTE LATER - when RRC will provide the cell index */
/*BUG 585, Multisector change start*/
            p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multisector change end*/
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "RRC->UEM:RRC_RRM_HO_RESTRICTION_LIST_IND successfully parsed");
			/* UT fix start */
            /*SPR_20521_FIX_START*/
            /*code deleted*/
            /*SPR 21848 Start*/
            rrm_map_ho_restriction_list(&(p_rrm_proc_ho_restriction_ind->ho_restriction_list),&(p_rrc_rrm_ho_restriction_ind->ho_restriction_list));
            /*SPR 21848 End*/
            /*SPR_20521_FIX_STOP*/
			
			/* UT fix end */
            p_rrm_ue_rrc_msg->p_msg_data = p_rrm_proc_ho_restriction_ind;
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_HO_RESTRICTION_LIST_IND parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_rrc_rrm_ho_restriction_ind);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_handle_ue_reconfig_req
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION: sends the ue_reconfig_req to rrc
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/

rrm_return_et
rrm_handle_ue_reconfig_req(
        rrm_ue_context_t *p_ue_context
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_ue_reconfig_req_t rrc_rrm_ue_reconfig_req;
    U16 transaction_id = RRM_ONE;

    RRM_MEMSET(&rrc_rrm_ue_reconfig_req,RRM_ZERO,
            sizeof(rrc_rrm_ue_reconfig_req_t));
    RRM_MEMCPY(&rrc_rrm_ue_reconfig_req,
            (rrc_rrm_ue_reconfig_req_t *)
            (p_ue_context->current_procedure.p_proc_data),
            sizeof(rrc_rrm_ue_reconfig_req_t));

    ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                                                 RRM_MODULE_ID,
                                                 RRC_MODULE_ID,
                                                 transaction_id,p_ue_context->cell_index);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "[UE:%d], Failed to send UE RECONFIG REQ"
                 ,p_ue_context->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "[UE:%d], Successfully sent UE RECONFIG REQ"
                ,p_ue_context->ue_index);
            
        /*set the ue reconfig procedural state bitmask*/ 
        p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = RRM_ZERO;
        
        if(RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT & rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
	   rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask
	   )
        {
            p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                        RRM_UE_RECONFIG_PHY_TPC_PDCCH_CONFIG_PUCCH_ROLLBACK_PRESENT; 
	}
     
        if(RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT & rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask
          )
        {
            p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |= 
                RRM_UE_RECONFIG_PHY_TPC_PDCCH_CONFIG_PUSCH_ROLLBACK_PRESENT;
        }

        /*SPR 20461 START*/
        if((rrc_rrm_ue_reconfig_req.bitmask & RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT)&&
                (rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask & RRM_UE_RECONFIG_MAC_CONFIG_PRESENT)&&
                (rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config_extensions.bitmask &
                 RRM_MAC_MAN_CONFIG_EXT_DL_INTERFERENCE_INFO_PRESENT))
        {
            if(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                    mac_main_config_extensions.dl_interference_info == VICTIM)
            {
                p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "Setting victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM");
                p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing= RRM_TRUE;
            }
            else
            {
                p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                        "Setting victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM");
                p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing= RRM_TRUE;
            }    
        }
        /*SPR 20461 END*/
    }
#ifdef LTE_EMBMS_SUPPORTED
    if( RRM_ZERO != p_ue_context->ue_mbms_data.reconfig_bitmask)
    {
        p_ue_context->ue_mbms_data.mbms_reconfig_triggered = RRM_TRUE;
        p_ue_context->ue_mbms_data.mbms_reconfig_count++ ;
    }
#endif
    /* SPR 15441 start */
    /* code removed */
    /* SPR 15441 end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME: rrm_switch_transmission_mode_decision
 *   INPUT      : p_ue_context,port,ue_category,p_transmission_mode
 *   OUTPUT     : none
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_switch_transmission_mode_decision_AN2_AN3(rrm_ue_context_t    *p_ue_context,
                  rrm_ue_category_et                              ue_category,                       
                  transmission_mode_ue_service_profile_et         *p_transmission_mode)
{

    rrm_return_et              ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if((ue_category >= UE_CATEGROY_2) && (ue_category <= UE_CATEGORY_8))/* UE Category 6, 7, 8: supported for CA & Rel-10 */
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                "UE Category is [%d] ,Transmission mode can be any of TM-2,TM-3,TM-4,TM-6,"
                "Decision have to be taken yet", ue_category);
        /*TM mode 7-8 start*/
        /* this function detremine the TM mode among TM-2,TM-3,TM-4 */
        ret_val = rrm_decide_transmisson_mode( p_ue_context,
                p_transmission_mode );

        if( RRM_FAILURE == ret_val )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "Transmission mode decision could not be taken for the UE");
        } 
        /*TM mode 7-8 end*/
    }
    else if( (UE_CATEGORY_1 == ue_category) || (UE_CATEGORY_NONE == ue_category))
    {
        /*TM-2 */
        *p_transmission_mode = TRANSMISSION_MODE_TM2;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
                "UE Category is [%d] or None, so Transmission mode is always TM-2 decided",ue_category);
    }
    /* eMTC chnages stop */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* cyclo end */
/*LTE_RRM_TM_SWITCH_START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_switch_transmission_mode_decision
 *   INPUT      : p_ue_context,port,ue_category,p_transmission_mode
 *   OUTPUT     : none
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_switch_transmission_mode_decision(U8 			port,
        rrm_ue_context_t    *p_ue_context,
        rrm_ue_category_et 	ue_category,
        transmission_mode_ue_service_profile_et   
        *p_transmission_mode
        )
{
    rrm_return_et              ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* SPR 21251 +- */

    if(ANTENNA_PORTS_COUNT_AN1 == port)
    {
        /*TM-1, port count = 1 , */
        *p_transmission_mode = TRANSMISSION_MODE_TM1;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
                "No. of Port[%d], UE Category [%d],Transmission mode TM-1 is decided",port,ue_category);

    }
    else if( ANTENNA_PORTS_COUNT_AN2 == port || ANTENNA_PORTS_COUNT_AN4 == port)
    {
        /* cyclo start */
        ret_val = rrm_switch_transmission_mode_decision_AN2_AN3(p_ue_context,ue_category,p_transmission_mode);
        /* cyclo end */
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Antenna Port[%d] for UE"
                "not supported, UE Category [%d], Failed to select the Transmission Mode",port, ue_category);
        /* SPR 21251 End */

        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;	
}


/******************************************************************************
 *   FUNCTION NAME: rrm_setting_transmission_mode
 *   INPUT      : transmission_mode,p_rrm_antenna_information,cell_index
 *   OUTPUT     : none
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_setting_transmission_mode(transmission_mode_ue_service_profile_et
			              			transmission_mode,
                              rrc_phy_physical_config_dedicated_t
                                                        *p_phy_config_dedicated,
//			      rrc_phy_antenna_information_dedicated_t
//		                                        *p_rrm_antenna_information,
			      rrm_ue_context_t *p_rrm_ue_context)
{

    antenna_info_t *p_antenna_info = rrm_cellm_get_antenna_info(p_rrm_ue_context->cell_index);
    RRM_UT_TRACE_ENTER();
    /*R10 Change : Start*/ 
    /* SPR-16135 START */
    if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_phy_config_dedicated->antenna_info_r10.explicit_value.bitmask = RRM_ZERO;

        p_phy_config_dedicated->antenna_info_r10.explicit_value.ue_transmit_antenna_selection.bitmask = RRM_ZERO;
    }
    else
    {
    p_phy_config_dedicated->antenna_information.antenna_information_explicit_value.bitmask = RRM_ZERO;
 
    p_phy_config_dedicated->antenna_information.antenna_information_explicit_value.
    ue_transmit_antenna_selection.bitmask = RRM_ZERO;
    }
    /*R10 Change : End*/
    tx_mode[transmission_mode]( p_phy_config_dedicated, p_antenna_info,p_rrm_ue_context);
	
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/*TM mode 7-8 start*/

/******************************************************************************
  *   FUNCTION NAME: rrm_get_downlink_sinr_cw1_consider 
  *   INPUT        : transmission_mode,p_rrm_antenna_information,cell_index
  *   OUTPUT       : none
  *   DESCRIPTION  :
  *
  *   RETURNS      :
  *       RRM_FALSE 
  *       RRM_TRUE 
*******************************************************************************/
rrm_bool_et
rrm_get_downlink_sinr_cw1_consider(const rrm_ue_context_t   *p_ue_context )
{

    rrm_bool_et   ret_dl_sinr_cw1 = RRM_FALSE;
    U8            index = RRM_ZERO;
    U8            dl_sinr_cw1_least_report_percentage = RRM_ZERO;
    U8            dl_sinr_cw1 = RRM_ZERO;

    if( RRM_NULL != p_ue_context )
    {

       for( index = RRM_ZERO;( ( index < RRM_MAX_REPORT_STAT_UE ) &&
                               ( index < p_ue_context->p_ue_mac_report->report_index )) ; index++ )
       {
           if( RRM_ZERO != p_ue_context->p_ue_mac_report->ue_stats[index].downlinkSINRValueCW1 )
           {
               dl_sinr_cw1++;
           }
       }

       if( p_ue_context->p_ue_mac_report->report_index >= RRM_MAX_REPORT_STAT_UE )
       {
           dl_sinr_cw1_least_report_percentage = ( ( RRM_MAX_REPORT_STAT_UE * RRM_DELTA_SINR_COUNT_PERCENT ) / RRM_PERCENTAGE ) ;

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
           "Report index are gretar than or equal to RRM_MAX_REPORT_STAT_UE"
           "considering the 70 perent of RRM_MAX_REPORT_STAT_UE [20] reports  as dl_sinr_cw1_least_report_percentage");
       }
       else
       {
           dl_sinr_cw1_least_report_percentage = ( p_ue_context->p_ue_mac_report->report_index + RRM_ONE );

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
           "Report index are less than RRM_MAX_REPORT_STAT_UE"
           "existing report index count as dl_sinr_cw1_least_report_percentage");
       }

       if( dl_sinr_cw1 >= dl_sinr_cw1_least_report_percentage )
       {
           ret_dl_sinr_cw1 = RRM_TRUE;

           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
           "Number of downlink sinr cw1 count [%d] >= dl_sinr_cw1_least_report_percentage count [%d]  ",
           dl_sinr_cw1 , dl_sinr_cw1_least_report_percentage );
       }
       else
       {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "Number of downlink sinr cw1 count [%d] < dl_sinr_cw1_least_report_percentage [%d]  ",
            dl_sinr_cw1 , dl_sinr_cw1_least_report_percentage );
       }

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
        "Null pointer Exception for UE context ");
    }

    return ret_dl_sinr_cw1; 

}
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_sinr_pl_level
 *   INPUT        : p_sinr_level,avg_downlink_sinr,tm_sinr_threshold,p_rrm_ue_context 
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
         rrm_void_t
 *******************************************************************************/
rrm_void_t
rrm_get_sinr_pl_level(rrm_level_t      *p_sinr_level,
                       U32              avg_downlink_sinr,
                       U32              tm_sinr_threshold,
                       rrm_ue_context_t *p_rrm_ue_context)
{
     RRM_UT_TRACE_ENTER();
	/*SPR 17732 Start*/
	if( avg_downlink_sinr > tm_sinr_threshold )
    {
		/*SPR 17732 End*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] SINR is high",
        p_rrm_ue_context->ue_index);
        *p_sinr_level = RRM_HIGH_LEVEL;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] SINR is low",
        p_rrm_ue_context->ue_index);
        *p_sinr_level = RRM_LOW_LEVEL;
    }
     RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME:rrm_get_pathloss_level 
 *   INPUT        :tm_pathloss_threshold,p_pathloss_level,p_rrm_ue_context 
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       rrm_void_t  
 *******************************************************************************/
rrm_void_t
rrm_get_pathloss_level(rrm_level_t      *p_pathloss_level,
                        rrm_ue_context_t *p_rrm_ue_context)
{
    
    RRM_UT_TRACE_ENTER();
    U32 tm_pathloss_threshold = rrm_get_tm_pathloss_threshold(p_rrm_ue_context->cell_index);

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "pathloss threshold [%d] ",tm_pathloss_threshold);
                            /* + SPR 20078 */
    if( p_rrm_ue_context->ue_avg_stats.uplinkPathLossValue > tm_pathloss_threshold )
                            /* - SPR 20078 */
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] pathloss is high",
        p_rrm_ue_context->ue_index);
        *p_pathloss_level = RRM_HIGH_LEVEL;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] pathloss is low",
        p_rrm_ue_context->ue_index);
        *p_pathloss_level = RRM_LOW_LEVEL;
    }
 RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME:rrm_get_mobility_level
 *   INPUT        :p_mobility_level,p_rrm_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       rrm_void_t
 *******************************************************************************/
rrm_void_t
rrm_get_mobility_level(rrm_level_t      *p_mobility_level,
                        rrm_ue_context_t *p_rrm_ue_context)
{

     RRM_UT_TRACE_ENTER();
    if( RRM_UE_SPEED_CATEGORY_2 == p_rrm_ue_context->ue_speed_algo_param.ue_speed_catagory )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] mobility is high",
        p_rrm_ue_context->ue_index);
        *p_mobility_level = RRM_HIGH_LEVEL;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] mobility is low",
        p_rrm_ue_context->ue_index);
        *p_mobility_level = RRM_LOW_LEVEL;
    }
 RRM_UT_TRACE_EXIT();
}
/* cyclo end */

/******************************************************************************
 *   FUNCTION NAME: rrm_get_sinr_pl_mobility_levels 
 *   INPUT        : p_sinr_level , p_pathloss_level , p_mobility_level 
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t
rrm_get_sinr_pl_mobility_levels( rrm_level_t      *p_sinr_level,
                                 rrm_level_t      *p_pathloss_level,
                                 rrm_level_t      *p_mobility_level,
                                 rrm_ue_context_t *p_rrm_ue_context )
{

    RRM_UT_TRACE_ENTER();

    U32 avg_downlink_sinr = RRM_ZERO;

    U32 tm_sinr_threshold = rrm_get_tm_sinr_threshold(p_rrm_ue_context->cell_index);

    /*SPR 17732 Start*/
    if( rrm_get_downlink_sinr_cw1_consider( p_rrm_ue_context ) )
    {
        avg_downlink_sinr = ( p_rrm_ue_context->ue_avg_stats.downlinkSINRValueCW0 + 
                              p_rrm_ue_context->ue_avg_stats.downlinkSINRValueCW1 ) / RRM_TWO;
   
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] Average downlink sinr of avg of cwo and cw1,cosidering both cwo and cw1"
        " for calculating the resultant average[%d]",
        p_rrm_ue_context->ue_index,avg_downlink_sinr );
    }
    else
    {
        avg_downlink_sinr = ( p_rrm_ue_context->ue_avg_stats.downlinkSINRValueCW0 );
 
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "[UE:%d] Average downlink sinr [%d] of cw0 ,considering the only cw0"
        " for calculating the resultant average",
        p_rrm_ue_context->ue_index,avg_downlink_sinr );
    }

    /*SPR 17732 End*/

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "SINR threshold [%d] ",tm_sinr_threshold );
    /* cyclo start */

    rrm_get_sinr_pl_level(p_sinr_level,avg_downlink_sinr,tm_sinr_threshold,p_rrm_ue_context);
    rrm_get_pathloss_level(p_pathloss_level,p_rrm_ue_context);
    rrm_get_mobility_level(p_mobility_level,p_rrm_ue_context);
    /* cyclo end */

    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
 *   FUNCTION NAME:  is_stringent_qci_present
 *   INPUT        :  p_rrm_ue_context 
 *   OUTPUT       :  none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_bool_et
is_stringent_qci_present( rrm_ue_context_t *p_rrm_ue_context )
{

    rrm_bool_et                     strngnt_qci_configd = RRM_FALSE;
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs = RRM_PNULL;
    U8                              index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
                        (p_rrm_ue_context->current_procedure.p_erb_success_list);

    for( index = RRM_ZERO;
         index < p_rrm_ue_context->drb_configured.num_of_list;
         index ++ ) 
    {
       /*qci 3 or 5 is considered as stringent qci*/
       if( ( RRM_THREE == p_rrm_ue_context->drb_configured.erab_item[index].erab_level_qos_params.qci) ||
           ( RRM_FIVE == p_rrm_ue_context->drb_configured.erab_item[index].erab_level_qos_params.qci ) )
       {
           strngnt_qci_configd = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
           "Stringent qci(%d) is present in configured drb %u, eRABId %u ",
           p_rrm_ue_context->drb_configured.erab_item[index].erab_level_qos_params.qci,
           p_rrm_ue_context->drb_configured.erab_item[index].drb_id,
           p_rrm_ue_context->drb_configured.erab_item[index].erab_id);

           break;
       }
   }

   if( ( p_successful_erbs != RRM_NULL )  && ( RRM_TRUE != strngnt_qci_configd ) )
   {
       /* CID 55013*/
       if(p_successful_erbs->num_of_list >= RRM_MAX_NUM_DRB_PER_UE)
       {
          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "For [UE:%d],successful ERBS list count is [%d]",p_rrm_ue_context->ue_index,p_successful_erbs->num_of_list);
           p_successful_erbs->num_of_list = RRM_MAX_NUM_DRB_PER_UE - RRM_ONE;
       }

       for( index = RRM_ZERO; index < p_successful_erbs->num_of_list; index ++ )
       {
           /*qci 3 or 5 is considered as stringent qci*/
           if( ( RRM_THREE == p_successful_erbs->erab_item[index].erab_level_qos_params.qci ) ||
               ( RRM_FIVE == p_successful_erbs->erab_item[index].erab_level_qos_params.qci ) )
           {
               strngnt_qci_configd = RRM_TRUE;  

               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                       "Stringent qci(%d) is present in drb %u, eRABId %u getting admitted",
                       p_rrm_ue_context->drb_configured.erab_item[index].erab_level_qos_params.qci,
                       p_rrm_ue_context->drb_configured.erab_item[index].drb_id,
                       p_rrm_ue_context->drb_configured.erab_item[index].erab_id);
               break;
           }
       }
   }

   RRM_UT_TRACE_EXIT();

   return strngnt_qci_configd ;

}

/* cyclo start */
/*TM mode 7-8 start*/
/******************************************************************************
 *   FUNCTION NAME:  rrm_assign_tm_mode_ue_service_profile
 *   INPUT        :  tm_mode,tm_mode_found,sinr_level 
 *   OUTPUT       :  none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *     rrm_void_t     
 *******************************************************************************/
rrm_void_t
rrm_assign_tm_mode_ue_service_profile(transmission_mode_ue_service_profile_et *tm_mode,
                                      rrm_bool_et                             tm_mode_found,
                                      rrm_level_t                             sinr_level)
{

   RRM_UT_TRACE_ENTER(); 
   if(RRM_FALSE == tm_mode_found)
   {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
        "No proper entry found in TM mode table, switching to fallback mode");

        if(RRM_HIGH_LEVEL == sinr_level)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "TM MODE 3 is selected as SINR is high ");
            *tm_mode = TRANSMISSION_MODE_TM3;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "TM MODE 2 is selected as SINR is low ");
            *tm_mode = TRANSMISSION_MODE_TM2;
        }
   }
   RRM_UT_TRACE_EXIT();
}
/* cyclo end */
/******************************************************************************
 *   FUNCTION NAME:  rrm_assign_tm_mode_from_tbl_entry
 *   INPUT        :  p_rrm_ue_context
 *   OUTPUT       :  none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
transmission_mode_ue_service_profile_et
rrm_assign_tm_mode_from_tbl_entry( rrm_level_t          sinr_level, 
                                   rrm_level_t          pathloss_level,
                                   rrm_level_t          mobility_level,
                                   const rrm_transmission_mode_table_t 
                                                        *p_tm_mode_tbl )
{

   U8                                      index = RRM_ZERO;
   rrm_bool_et                             tm_mode_found = RRM_FALSE;
   transmission_mode_ue_service_profile_et tm_mode = TRANSMISSION_MODE_TM1;

   RRM_UT_TRACE_ENTER();

   RRM_TRACE( g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
   " Decided sinr level [%d],pathloss level [%d], mobility level [%d]",
   sinr_level , pathloss_level , mobility_level );

   for(index = RRM_ZERO; index < p_tm_mode_tbl->count; index ++)
   {
       RRM_TRACE( g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
       " Coming from OAM sinr level [%d],pathloss level [%d], mobility level [%d] at index [%d]",
       p_tm_mode_tbl->rrm_tm_mode_table_row[index].sinr,
       p_tm_mode_tbl->rrm_tm_mode_table_row[index].pathloss,
       p_tm_mode_tbl->rrm_tm_mode_table_row[index].mobility , index );

       if( ( sinr_level == p_tm_mode_tbl->rrm_tm_mode_table_row[index].sinr ) &&
           ( pathloss_level == p_tm_mode_tbl->rrm_tm_mode_table_row[index].pathloss ) &&
           ( mobility_level == p_tm_mode_tbl->rrm_tm_mode_table_row[index].mobility ) )
       {
           tm_mode = p_tm_mode_tbl->rrm_tm_mode_table_row[index].tm_mode;
           tm_mode_found = RRM_TRUE;
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                   "tm mode selected = %d",tm_mode);
           break;
       }
   }
   /* cyclo start */ 
   rrm_assign_tm_mode_ue_service_profile(&tm_mode,tm_mode_found,sinr_level);
   /* cyclo end */
   RRM_UT_TRACE_EXIT();
   return tm_mode;
}



/******************************************************************************
 *   FUNCTION NAME:  rrm_get_tm_mode_based_on_tbl 
 *   INPUT        :  p_rrm_ue_context
 *   OUTPUT       :  none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
transmission_mode_ue_service_profile_et
rrm_get_tm_mode_based_on_tbl( rrm_level_t       sinr_level,
                              rrm_level_t       pathloss_level,
                              rrm_level_t       mobility_level,
                              rrm_ue_context_t  *p_rrm_ue_context )
{

   transmission_mode_ue_service_profile_et      tm_mode = TRANSMISSION_MODE_TM1;
   const rrm_transmission_mode_table_t          *p_tm_mode_tbl = RRM_NULL;

   RRM_UT_TRACE_ENTER();

   p_tm_mode_tbl = rrm_get_tm_mode_table(p_rrm_ue_context->cell_index);
 

  /* coverity : CID 41511 */

   if( RRM_NULL != p_tm_mode_tbl )
   { 
       if( p_tm_mode_tbl->bitmask & RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT ) 
       {

           if( RRM_TRUE == is_stringent_qci_present(p_rrm_ue_context) )
           { 
                tm_mode = p_tm_mode_tbl->tm_mode_for_strngnt_qci;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, "[UE:%u] "
                "Stringent qci(3/5) is present and stringent qci is set as true "
                "in tm mode table, [TM-%d] as configured for stringent qci",
                p_rrm_ue_context->ue_index, tm_mode + 1);

           }
           else
           {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Stringent qci(3/5) rab is  not present for [UE:%d],looking into table ",
                p_rrm_ue_context->ue_index);

                tm_mode = rrm_assign_tm_mode_from_tbl_entry( sinr_level,
                                                             pathloss_level,
                                                             mobility_level,
                                                             p_tm_mode_tbl );
           }
       }
       else
       {
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Stringent qci(3/5) rab configuration is not coming from oam,looking into table for [UE:%u]",
           p_rrm_ue_context->ue_index);

           tm_mode = rrm_assign_tm_mode_from_tbl_entry( sinr_level,
                                                        pathloss_level,
                                                        mobility_level,
                                                        p_tm_mode_tbl );
       }
    }
    else
    {
           /* if transmission mode table doesnot  come from oam than this fucntion will not 
              be called because it callee function have prior check if table exist then only 
              this function is called otherwise we take decision on based of sinr only
              as i prior check has validated for transmission mode table. so again we are not 
              assigniing the transmsision mode on basis of sinr
              Note :  this null check is put due to coveirty warnings */
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
           "p_tm_mode_tbl transmission mode table is not coming from OAM ");
    }


   RRM_UT_TRACE_EXIT();
   return tm_mode;
}






/******************************************************************************
  *   FUNCTION NAME:  is_tm8_supported_by_ue_capa 
  *   INPUT        :  p_rrm_ue_context
  *   OUTPUT       :  none
  *   DESCRIPTION  :
  *
  *   RETURNS      :
  *       RRM_SUCCESS on Success
  *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_bool_et
is_tm8_supported_by_ue_capa
(
    rrm_ue_context_t *p_rrm_ue_context,
    rrm_enb_mode_t mode
)
{
    RRM_UT_TRACE_ENTER();
    rrm_bool_et ret_val = RRM_FALSE;
    if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        if(p_rrm_ue_context->ue_capability_params.
           rrm_eutra_radio_capability_info.bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)
        {
            if(FDD_MODE == mode)
            {
              if(RRM_TRUE == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.phy_layer_parameters_v920.enhanced_dual_layer_fdd_supported_r9)
              {
                  ret_val = RRM_TRUE;
              }
            }
            else //TDD
            {
              if(RRM_TRUE == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.phy_layer_parameters_v920.enhanced_dual_layer_tdd_supported_r9)
              {
                  ret_val = RRM_TRUE;
              }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME:  rrm_fallback_mode_for_TM8_TM7
 *   INPUT        :  transmission_mode,p_ue_context
 *   OUTPUT       :  none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_bool_et
rrm_fallback_mode_for_TM8_TM7(transmission_mode_ue_service_profile_et
                                                    transmission_mode,
                              rrm_ue_context_t      *p_ue_context)
{
   
    
    rrm_enb_mode_t                        mode = FDD_MODE;
    rrm_bool_et                           fallback = RRM_TRUE;
    RRM_UT_TRACE_ENTER();
    if( ( TRANSMISSION_MODE_TM8_V920 == transmission_mode ) ) 
    {
        /* mode of eutran */
        mode = rrm_cellm_get_fdd_tdd_mode( p_ue_context->cell_index );

        /* in existing mode tm-8 is supported by Ue or not  */
        if(  RRM_TRUE == is_tm8_supported_by_ue_capa( p_ue_context, mode ) )
        {
            fallback = RRM_FALSE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "TM-8 is supported by [UE:%d],Fallback is not needed",p_ue_context->ue_index );
        }
        else
        {   
            fallback = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "TM-8 is not supported by [UE:%d],Fallback needed",p_ue_context->ue_index );
        }

    }
    else if( TRANSMISSION_MODE_TM7 == transmission_mode )
    {
        fallback = RRM_FALSE ;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "Fallback of TM-7 is not needed for [UE:%d]",p_ue_context->ue_index );
    }
   RRM_UT_TRACE_EXIT();

   return fallback ;
}

/* cyclo end */

/******************************************************************************
 *   FUNCTION NAME:  is_tm8_supported_by_ue_capa
 *   INPUT        :  p_rrm_ue_context
 *   OUTPUT       :  none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_bool_et
rrm_fallback_mode_for_transmission_mode( transmission_mode_ue_service_profile_et 
                                                          transmission_mode,
                                         rrm_ue_context_t 
                                                          *p_ue_context)
{
    
    rrm_bool_et                           beamforming_vector_present = RRM_FALSE;
    rrm_bool_et                           fallback = RRM_TRUE;
    const rrm_tm_mode_additional_info_t  *p_rrm_tm_mode_additional_info = RRM_NULL;

    const rrm_mac_beam_forming_info_t      *p_rrm_mac_beam_forming_info = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(p_ue_context != RRM_PNULL);

    /*beamforming info */
    p_rrm_mac_beam_forming_info = rrm_cm_get_mac_beam_forming_info( p_ue_context->cell_index );

    /* additional info of tm mode from rrm.cfg  */
    p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info( p_ue_context->cell_index ); 

    if( ( RRM_NULL != p_rrm_tm_mode_additional_info ) &&
           ( RRM_NULL != p_rrm_mac_beam_forming_info )  )
    {
        /* beamformig algo is configured */
        if( RRM_TRUE == p_ue_context->beam_forming_algo_configd_for_TM7_8 )
        {
            /* sinr vector present in rrm.cfg */
            if( ( BEAM_FORMING_SINR == p_rrm_tm_mode_additional_info->beam_forming_algo ) &&
                ( p_rrm_mac_beam_forming_info->bitmask & RRM_SINR_TO_BEAM_FRMNG_CONFIG_PRESENT ) )
            {
                beamforming_vector_present = RRM_TRUE;
            }
            else if( ( BEAM_FORMING_AOA == p_rrm_tm_mode_additional_info->beam_forming_algo ) &&
                   ( p_rrm_mac_beam_forming_info->bitmask & RRM_AOA_TO_BEAM_FRMNG_VECTOR_MPPNG_PRESENT ) )
            {
                beamforming_vector_present = RRM_TRUE;
            }
        }
        if( RRM_TRUE == beamforming_vector_present )
        { 
           /* cyclo start */ 
           fallback = rrm_fallback_mode_for_TM8_TM7(transmission_mode,p_ue_context);
           /* cyclo end */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "Beamforming algo is not configured with its vector at MAC for [UE:%u]"
            " Fallback of transmission mode [%d] is needed ",p_ue_context->ue_index,transmission_mode );

            fallback = RRM_TRUE;
        }
    }
    else
    {
        fallback = RRM_TRUE;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
        "NULL pointer exception for p_rrm_tm_mode_additional_info/p_rrm_mac_beam_forming_info"
        "for [UE:%d]",p_ue_context->ue_index );
    } 
   
    RRM_UT_TRACE_EXIT(); 

    return fallback ;
}
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME: rrm_check_fallback_needed_tm7_tm8
 *   INPUT        : sinr_level, pathloss_level, mobility_level, p_rrm_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
                  transmission_mode
 *******************************************************************************/

transmission_mode_ue_service_profile_et
rrm_check_fallback_needed_tm7_tm8(rrm_level_t       sinr_level,
                                  rrm_level_t       pathloss_level,
                                  rrm_level_t       mobility_level,
                                  rrm_ue_context_t  *p_rrm_ue_context)
{
     
    rrm_bool_et                             fallback = RRM_TRUE;
    transmission_mode_ue_service_profile_et transmission_mode;
    RRM_UT_TRACE_ENTER();
    
    transmission_mode = rrm_get_tm_mode_based_on_tbl( sinr_level,
            pathloss_level,
            mobility_level,
            p_rrm_ue_context );

    /* check for fallback is needed for tm-7/tm8 */
    if( ( TRANSMISSION_MODE_TM7 == transmission_mode ) ||
            ( TRANSMISSION_MODE_TM8_V920 == transmission_mode ) )
    {
        fallback = rrm_fallback_mode_for_transmission_mode(transmission_mode,
                p_rrm_ue_context );
        if( RRM_TRUE ==  fallback )
        {
            if( RRM_HIGH_LEVEL == sinr_level )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, "[UE:%u] "
                        "Fallback to TM-3 is selected as SINR is high ",
                        p_rrm_ue_context->ue_index);
                transmission_mode = TRANSMISSION_MODE_TM3;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, "[UE:%u] "
                        "Fallback to TM-2 is selected as SINR is low ",
                        p_rrm_ue_context->ue_index);
                transmission_mode = TRANSMISSION_MODE_TM2;
            }
        }

    }
    RRM_UT_TRACE_EXIT();
    return transmission_mode;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_decide_transmisson_mode 
 *   INPUT        : p_rrm_ue_context , transmission_mode 
 *   OUTPUT       : none
 *   DESCRIPTION  :
 *
 *   RETURNS      :
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_decide_transmisson_mode(
                            rrm_ue_context_t  *p_rrm_ue_context,
                            transmission_mode_ue_service_profile_et 
                                              *transmission_mode )
{

   rrm_return_et                           ret_val = RRM_SUCCESS;
   const rrm_transmission_mode_table_t    *p_tm_mode_tbl = RRM_NULL;
   rrm_level_t                             sinr_level = RRM_LOW_LEVEL;
   rrm_level_t                             pathloss_level = RRM_LOW_LEVEL;
   rrm_level_t                             mobility_level = RRM_LOW_LEVEL;

   RRM_UT_TRACE_ENTER();

   p_tm_mode_tbl = rrm_get_tm_mode_table(p_rrm_ue_context->cell_index);

   if(RRM_NULL != p_tm_mode_tbl)
   {
        /*decide sinr,pathloss,mobility levels*/
        rrm_get_sinr_pl_mobility_levels(&sinr_level,
                                        &pathloss_level,
                                        &mobility_level,
                                        p_rrm_ue_context);

        /*get the transmission mode from the table*/
        /* cyclo start */
        *transmission_mode = rrm_check_fallback_needed_tm7_tm8(sinr_level,pathloss_level,mobility_level,p_rrm_ue_context);
        /* cyclo end */
   }
   else
   {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                "No transmission mode table is received, switching to fallback mode for [UE:%u]",
        p_rrm_ue_context->ue_index);

        if( RRM_HIGH_LEVEL == sinr_level )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%u] "
                    "TM MODE 3 is selected as SINR is high ",
                    p_rrm_ue_context->ue_index);
            *transmission_mode = TRANSMISSION_MODE_TM3;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%u] "
                    "TM MODE 2 is selected as SINR is low ",
                    p_rrm_ue_context->ue_index);
            *transmission_mode = TRANSMISSION_MODE_TM2;
        }
   }
   
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/*TM mode 7-8 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_transmission_mode
 *   INPUT      : p_rrm_ue_context,p_antenna_match
 *   OUTPUT     : p_rrm_antenna_information
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_transmission_mode( rrm_ue_context_t *p_rrm_ue_context,
                            rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,                 
                            rrm_bool_et *p_antenna_match)
{

    rrm_return_et               ret_val = RRM_SUCCESS;
    U8                  	port = RRM_ZERO;
    rrm_ue_category_et  	ue_category = UE_CATEGORY_NONE;
    transmission_mode_ue_service_profile_et
        transmission_mode = TRANSMISSION_MODE_TM1; /*Kshitij Coverity 16594, assigning lowest TM rel1.3*/


    RRM_UT_TRACE_ENTER();

    if( RRM_SUCCESS == rrm_cellm_get_antenna_port(p_rrm_ue_context->cell_index,&port))
    {
        if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
        {
	    /* ue category */ /* R-10 Change : Start */
            ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_rrm_ue_context);
	    /* R-10 Change : End */
        }

        /*tx mode decision function*/	
        ret_val = rrm_switch_transmission_mode_decision( port,
                                                         p_rrm_ue_context,
                                                         ue_category,
                                                         &transmission_mode );
        if( RRM_SUCCESS == ret_val )
        {
            /* tx mode setting function*/
            rrm_setting_transmission_mode( transmission_mode,
                                           p_phy_config_dedicated,
                                           p_rrm_ue_context );

            /*compare the antenna info with UE's last anetnna info */
            /* R10 Changes : Start */ 
            /* SPR-16135 START */
	    if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
		eutra_radio_capability_info_def.access_stratum_release)
            /* SPR-16135 END */
	    {
                ret_val = rrm_compare_ue_antenna_info_r10(p_rrm_ue_context->ue_index,
                                                          p_rrm_ue_context->cell_index,
                                                          &(p_phy_config_dedicated->antenna_info_r10.
                                                          explicit_value),
                                                          p_antenna_match);
            }
            else
            {
            ret_val = rrm_compare_ue_antenna_info( p_rrm_ue_context->ue_index,
                                                   p_rrm_ue_context->cell_index,
                                                  &(p_phy_config_dedicated->antenna_information.
                                                   antenna_information_explicit_value),
                                                   p_antenna_match );
            /* if tm8 is decided */
            if( (RRM_SUCCESS == ret_val) && (TRANSMISSION_MODE_TM8_V920 == transmission_mode) )
            {
                ret_val = rrm_compare_ue_antenna_info_v920( p_rrm_ue_context,
                                                            &(p_phy_config_dedicated->antenna_info_v920),
                                                            p_antenna_match );
                
            }
            }
            /* R10 Changes : End */

            if(RRM_SUCCESS == ret_val && RRM_FALSE == *p_antenna_match)
            {
                /* back up the antenna info data before updating */
                rrm_backup_ue_antenna_info((rrm_ue_context_t*)p_rrm_ue_context );
                /* SPR-16135 START */
                if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        eutra_radio_capability_info_def.access_stratum_release)
                    /* SPR-16135 END */
		{
                    ret_val = rrm_ue_set_phy_antenna_info_r10(p_rrm_ue_context->ue_index,
                                                              p_rrm_ue_context->cell_index,
                                                              &(p_phy_config_dedicated->antenna_info_r10.
                                                              explicit_value));
                }
                else
                {
                /* update the ue's antenna info*/
                ret_val = rrm_ue_set_phy_antenna_info( p_rrm_ue_context->ue_index,
                                                       p_rrm_ue_context->cell_index,
                                                       &( p_phy_config_dedicated->antenna_information.
                                                       antenna_information_explicit_value ));

                /* if tm8 is selected then only backup the tm8 info's codebook subset*/
                if( TRANSMISSION_MODE_TM8_V920 == transmission_mode )
                {
                    rrm_backup_ue_antenna_info_v920((rrm_ue_context_t*)p_rrm_ue_context) ;
                    
                    ret_val = rrm_set_phy_antenna_info_v920( (rrm_ue_context_t*)p_rrm_ue_context,
                                                             &(p_phy_config_dedicated->antenna_info_v920)  );
                } 
                } 
                        
                /*Transmission mode is switched*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Transmission mode is switched for [UE:%d]",p_rrm_ue_context->ue_index);
            }
        }
    }    

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Uplink power starts */
/******************************************************************************
 *   FUNCTION NAME:rrm_apply_olpc 
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : radio_resource_reconfig
 *   DESCRIPTION:
 *   RETURNS    :
 *              RRM_TRUE 
 *              RRM_FALSE 
*******************************************************************************/
rrm_bool_et
rrm_apply_olpc(rrm_ue_context_t *p_rrm_ue_context,radio_resource_reconfig_t *radio_resource_reconfig)
{

    rrm_cell_index_t                cell_index = RRM_ZERO;
    S8 				olpc_category = RRM_ZERO;
    S8 				ulpc_params_category = RRM_ZERO;
    admission_control_info_t        *p_admission_control_info = RRM_NULL;
    rrm_bool_et			is_power_changed = RRM_FALSE;			
    U8 is_pusch_or_pucch_flag = RRM_ONE;

    cell_index = p_rrm_ue_context->cell_index;
    p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);
    /* Called to find sinr_dep_params_category to decide p0_ue_pusch */
    rrm_find_sinr_dep_params_category
        (p_rrm_ue_context,&ulpc_params_category, is_pusch_or_pucch_flag);

    olpc_category = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.\
                    rrm_olpc_pusch_config_params.olpc_pusch_supported_table[ulpc_params_category-1];
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "[UE:%d] uplink_params_type [%d] to perform olpc_action[%d] ",
            p_rrm_ue_context->ue_index,ulpc_params_category,olpc_category);
/* SPR 8432 Start */
    radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pusch =
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch;
/* SPR 8432 Stop */
    olpc_action[olpc_category](p_rrm_ue_context,&(radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.\
                uplink_power_control_dedicated.p0_ue_pusch),&(p_admission_control_info->snr_map.\
                    snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pusch), is_pusch_or_pucch_flag);
    if(p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch != radio_resource_reconfig->\
            rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pusch)
    {
        is_power_changed = RRM_TRUE;
        /* To update current uplink power of ue */
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch = radio_resource_reconfig->\
             rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pusch;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"No Change in PUSCH power");
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "[UE:%d] Previous value for p0_ue_pusch [%d], New value for p0_ue_pusch [%d]",
            p_rrm_ue_context->ue_index,p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch,\
            radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pusch);

    /* Called to find sinr_dep_params_category to decide p0_ue_pucch */
    is_pusch_or_pucch_flag = RRM_ZERO;

    rrm_find_sinr_dep_params_category
        (p_rrm_ue_context,&ulpc_params_category,is_pusch_or_pucch_flag);

    olpc_category = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_olpc_config_params.\
                    rrm_olpc_pucch_config_params.olpc_pucch_supported_table[ulpc_params_category-1];

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "[UE:%d] uplink_params_type [%d] to perform olpc_action[%d] ",
            p_rrm_ue_context->ue_index,ulpc_params_category,olpc_category);

/* SPR 8432 Start */
    radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pucch =
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch;
/* SPR 8432 Stop */
    olpc_action[olpc_category](p_rrm_ue_context,&(radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.\
                uplink_power_control_dedicated.p0_ue_pucch),&(p_admission_control_info->snr_map.\
                    snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pucch), is_pusch_or_pucch_flag);
    if(p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch != radio_resource_reconfig->\
            rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pucch)
    {
        is_power_changed = RRM_TRUE;
        /* To update current uplink power of ue */
        p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch = radio_resource_reconfig->\
            rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pucch;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"No Change in PUCCH power");
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "[UE:%d] Previous value for p0_ue_pucch [%d], New value for p0_ue_pucch [%d]",
            p_rrm_ue_context->ue_index,p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch,\
            radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p0_ue_pucch);

    /*spr 7918 start*/
    radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.delta_mcs_enabled=
            p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.delta_mcs_enabled;
    radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.accumulation_enabled=
            p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.accumulation_enabled;
    radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.p_srs_offset=
            p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p_srs_offset;
    radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.uplink_power_control_dedicated.filter_coefficient=
            p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.filter_coefficient;
    /*spr 7918 end*/
    return is_power_changed;
}
/* Uplink power end */
/* cyclo start */
/******************************************************************************
 *   FUNCTION NAME : rrm_fill_mac_main_config_extension
 *   INPUT         :p_mac_main_config_extn 
 *   OUTPUT        :p_mac_main_config_extn
 *   DESCRIPTION   :
 *   RETURNS       :rrm_void_t 
 *******************************************************************************/
rrm_return_et
rrm_fill_mac_main_config_extension(rrm_mac_main_config_extensions_t *p_mac_main_config_extn,
                                   rrm_ue_context_t                 *p_rrm_ue_context)
{

   rrm_return_et                         ret_val = RRM_SUCCESS;
    rrc_rrm_ue_service_profile_t          *p_ue_profile_mac_main_config = RRM_NULL;
    admission_control_info_t              *p_admission_control_info = RRM_NULL;
   
   RRM_UT_TRACE_ENTER();
   
    RRM_ASSERT(p_rrm_ue_context != RRM_PNULL);
        p_ue_profile_mac_main_config = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);
   p_admission_control_info = rrm_cellm_get_admission_control_info(p_rrm_ue_context->cell_index);

        if( p_ue_profile_mac_main_config != RRM_NULL )
        {
            if( p_ue_profile_mac_main_config->radio_res_config.mac_config.mac_main_config.
                ul_sch_config.bitmask & RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT ) 
            {
                p_mac_main_config_extn->max_ul_harq_tx = p_ue_profile_mac_main_config->
                radio_res_config.mac_config.mac_main_config.ul_sch_config.max_ul_harq_tx;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR ,
                "Bitmask RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT is not present "
                "for p_ue_profile_mac_main_config->ul_sch_config.bitmask ");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR ,
            "NULL Pointer Exception for p_ue_profile_mac_main_config ");

            ret_val = RRM_FAILURE;
        }
        if( p_admission_control_info != RRM_NULL )
        {
            p_mac_main_config_extn->ul_i_mcs =  p_admission_control_info->snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs;
            
            p_mac_main_config_extn->dl_i_mcs = p_admission_control_info->snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR ,
            "NULL Pointer Exception for p_admission_control_info ");
            ret_val = RRM_FAILURE;
        }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* cyclo end */

/******************************************************************************
 *   FUNCTION NAME : rrm_fill_mac_main_config_extension_for_l3_ue_reconfig
 *   INPUT         : p_rrm_ue_context
 *   OUTPUT        : p_mac_main_config_extn 
 *   DESCRIPTION   :
 *   RETURNS       : RRM_SUCCESS / RRM_FAILURE
*******************************************************************************/
rrm_return_et
rrm_fill_mac_main_config_extension_for_l3_ue_reconfig( rrm_ue_context_t   *p_rrm_ue_context,
                                                       rrm_mac_main_config_extensions_t
                                                                         *p_mac_main_config_extn )                                                      
{

    rrm_return_et                         ret_val = RRM_SUCCESS;
    rrmc_mac_config_t                     *p_rrmc_mac_config = RRM_PNULL;
    U8                                    dl_bandwidth = RRM_ZERO;
    const rrm_tm_mode_additional_info_t   *p_rrm_tm_mode_additional_info = RRM_NULL; 
    U8                                     num_of_layer = RRM_ZERO; 

    RRM_UT_TRACE_ENTER();

    if( ( RRM_NULL != p_rrm_ue_context ) && ( RRM_NULL != p_mac_main_config_extn ) )
    {
        /*fill mandatory params */


        p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(p_rrm_ue_context->cell_index);
 

        p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(p_rrm_ue_context->cell_index);

        p_mac_main_config_extn->ue_priority = MAC_UE_PRIORITY;
 
        if( RRM_NULL !=  p_rrmc_mac_config )
        {
            p_mac_main_config_extn->dl_num_harq_process = p_rrmc_mac_config->dl_num_harq_process;
        }
        else
        {
            ret_val = RRM_FAILURE;
        } 
 
        if(rrm_cellm_get_rrmc_band_width(p_rrm_ue_context->cell_index,&dl_bandwidth) == RRM_SUCCESS)
        {
            p_mac_main_config_extn->dl_max_rb = dl_bandwidth;
        }
        /* num of layer is selection should done after transmission mode selection
           as this algo has transmission mode input param. if current tx mode is not updated
           so it will be using the last stored tx mode  */
        if ( RRM_SUCCESS == rrm_select_num_of_layer_for_ue( p_rrm_ue_context,
                                                            &num_of_layer ) )
        {
            p_mac_main_config_extn->num_of_layer = num_of_layer;
        }
        /* cyclo start */
        ret_val = rrm_fill_mac_main_config_extension(p_mac_main_config_extn,p_rrm_ue_context);
        /* cyclo end */
        
        p_mac_main_config_extn->code_book_index = CODE_BOOK_INDEX;  

        /* rs epre ratio : when transmission mode TRANSMISSION_MODE_TM7 is set  */
        if( TRANSMISSION_MODE_TM7 == (transmission_mode_ue_service_profile_et) p_rrm_ue_context-> \
                                     ue_phy_config_information.ue_antenna_information.transmission_mode )
        { 
            p_mac_main_config_extn->bitmask |= RRM_MAC_MAIN_CONFIG_EXT_PDSCH_EPRE_TO_UE_RS_RATIO_PRESENT;

            p_mac_main_config_extn->pdsch_epre_to_ue_rs_ratio =
            p_rrm_tm_mode_additional_info->pdsch_epre_to_ue_rs_ratio;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR ,
        "NULL Pointer Exception for p_rrm_ue_context/p_mac_main_config_extn ");

         ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/******************************************************************************
 *   FUNCTION NAME: rrm_send_tm_switching_info_in_ue_reconfig
 *   input      : p_rrm_ue_context
 *   output     : none
 *   DESCRIPTION:
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_send_tm_switching_info_in_ue_reconfig(rrm_ue_context_t                     *p_rrm_ue_context,
                                          rrc_rrm_ue_reconfig_req_t            *rrc_rrm_ue_reconfig_req,
                                          rrc_phy_physical_config_dedicated_t  *p_rrc_phy_config_dedicated,
                                          rrm_bool_et                          *reconfig_ue)
{
    rrc_phy_cqi_reporting_t		      rrm_cqi_info_ue_reconfig = {RRM_ZERO};
    /* R-10 Changes: Start */
    rrc_cqi_report_config_r10_t               rrm_cqi_info_ue_reconfig_r10 = {RRM_ZERO};
    rrm_return_et			      ret_val = RRM_SUCCESS;
    
    RRM_UT_TRACE_ENTER();
    /* SPR-16135 START */
    if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
	    /*setting ue context reconfig bitmask in ue context for phy antenna info */
	{
	    /*handling if UE Rel-10*/
	    p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
		RRM_UE_RECONFIG_PHY_ANTENNA_INFO_R10_ROLLBACK_PRESENT;
	}
	else
	{
	    p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
		RRM_UE_RECONFIG_PHY_ANTENNA_CONFIG_ROLLBACK_PRESENT;

	    if( TRANSMISSION_MODE_TM8_V920 == p_rrc_phy_config_dedicated->antenna_information.
		    antenna_information_explicit_value.transmission_mode )
	    {
		p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
		    RRM_UE_RECONFIG_PHY_ANTENNA_INFO_V920_PRESENT;
	    }
	}

/* SPR-16135 START */
	if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
		eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
        {
            /* fill R-10 CQI info */
            ret_val = rrm_cqi_information_reconfig_req_r10( p_rrm_ue_context,
	     	                                            p_rrc_phy_config_dedicated->antenna_information.
		                                            antenna_information_explicit_value.transmission_mode,
		                                            /*rrm_antenna_information_for_ue_reconfig.transmission_mode,*/
		                                            &rrm_cqi_info_ue_reconfig_r10 );
	    if( RRM_SUCCESS == ret_val )
	    {

		rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		    rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
		    RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;
		rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		    rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10 =
		    rrm_cqi_info_ue_reconfig_r10;	
	    }

	    rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
		RRC_PHY_ANTENNA_INFO_R10_PRESENT;

	    rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		rrc_rrm_ue_reconfig_physical_config_dedicated.antenna_info_r10.
		bitmask |= RRC_ANTENNA_INFO_R10_EXPLICIT_VALUE_PRESENT;

	    /*pmi-ri_report will be set if TM8 is selected*/
	    rrm_fill_cqi_report_config_v920
		(p_rrc_phy_config_dedicated,p_rrm_ue_context);

        }
        else
        {
	    ret_val = rrm_cqi_information_reconfig_req( p_rrm_ue_context,
	     	                                        p_rrc_phy_config_dedicated->antenna_information.
		                                        antenna_information_explicit_value.transmission_mode,
		                                        /*rrm_antenna_information_for_ue_reconfig.transmission_mode,*/
		                                        &rrm_cqi_info_ue_reconfig );
	    if( RRM_SUCCESS == ret_val )
	    {

		rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		    rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
		    RRC_PHY_CQI_REPORTING_PRESENT;
		rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		    rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_reporting =
		    rrm_cqi_info_ue_reconfig;	
	    }

	    rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
		RRC_PHY_ANTENNA_INFORMATION_PRESENT;

	    rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
		rrc_rrm_ue_reconfig_physical_config_dedicated.antenna_information.
		bitmask |= RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT;

	    /*pmi-ri_report will be set if TM8 is selected*/
	    rrm_fill_cqi_report_config_v920
		(p_rrc_phy_config_dedicated,p_rrm_ue_context);
        }

        /*TM mode 7-8 start*/

        ret_val = rrm_fill_mac_main_config_extension_for_l3_ue_reconfig( p_rrm_ue_context,
                                                      &( rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config.
                                                      mac_main_config_extensions) );
        if( RRM_SUCCESS == ret_val )
        {
            rrc_rrm_ue_reconfig_req->radio_resource_reconfig.presence_bitmask |= RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
        }

        /*TM mode 7-8 end*/

        *reconfig_ue = RRM_TRUE;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Fix for CSR: 00059124 */
/******************************************************************************
 *   FUNCTION NAME : rrm_fill_cdrx_config_for_ue_reconfig 
 *   INPUT         : p_rrm_ue_context
 *                 : p_cell_context 
 *                 : p_cdrx_config
 *   OUTPUT        : NONE
 *   DESCRIPTION   : Fills cdrx configuration for UE reconfig request
 *   RETURNS       : RRM_SUCCESS/RRM_FAILURE
*******************************************************************************/
rrm_return_et
    rrm_fill_cdrx_config_for_ue_reconfig
(
 rrm_ue_context_t *p_ue_context,
 rrm_cell_context_t *p_cell_context,
 rrc_drx_config_t   *p_cdrx_config
 )
{

    /* CID 116001 Fix Start */
    /* Code Removed */
    /* CID 116001 Fix End */
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if ((RRM_PNULL != p_cell_context) &&
            (RRM_PNULL != p_cdrx_config))
    {
        if (RRMCM_RMIF_MAC_LAYER_PARAM_CDRX_PRESENT & 
                p_cell_context->ran_info.mac_layer_params.bitmask)
        {
            p_cdrx_config->drx_config_type = RRC_DRX_CONFIG_TYPE_SETUP;
            p_cdrx_config->bitmask |= RRC_DRX_CONFIG_PARAM_PRESENT;

            p_cdrx_config->drx_config_param.on_duration_timer = 
                p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.on_duration_timer;

            p_cdrx_config->drx_config_param.drx_inactivity_timer = 
                p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.drx_inactivity_timer;

            p_cdrx_config->drx_config_param.drx_retransmission_timer = 
                p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.drx_retransmission_timer;

            /* CID 116001 Fix Start */
            /* Code Removed */
            if(RRM_TRUE ==  rrm_is_set_fgi_bit(p_ue_context, RRM_FIVE)) 
           /* CID 116001 Fix End */
            {
                file_erb_setup_resp_long_drx_cycle_start_offset
                    (&(p_cdrx_config->drx_config_param.long_drx_cycle_start_offset),
                     p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.long_drx_cycle,
                     p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.drx_start_offset);
               
#ifdef ENDC_ENABLED 
                if ( p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.bitmask & RRMCM_RMIF_CDRX_LONG_DRX_CYCLE_R15_PRESENT )
                {
                    file_erb_setup_resp_long_drx_cycle_start_offset_r15
                        (&(p_cdrx_config->drx_config_param.long_drx_cycle_start_offset_r15),
                         p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.long_drx_cycle_r15,
                         p_cell_context->ran_info.mac_layer_params.rrm_cdrx_config.drx_start_offset);
                    p_cdrx_config->drx_config_param.bitmask |= RRC_DRX_CONFIG_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
                }
#endif
                /*SPR 20533 Fix Start*/
                /*Code Removed*/
                /*SPR 20533 Fix Stop*/
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
                        "[UE:%d] is not supported FGI bit Five for cdrx",
                        p_ue_context->ue_index );
                ret_val = RRM_FAILURE;
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Either p_cell_context or p_cdrx_config is NULL");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Fix for CSR: 00059124 */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tti_info
 *   input      : p_rrm_ue_context
 *   output     : reconfig_ue
 *   DESCRIPTION:
 *   RETURNS    :
 *                void 
 *******************************************************************************/
void
rrm_fill_tti_info(rrm_ue_context_t            *p_rrm_ue_context,
                  rrc_rrm_ue_reconfig_req_t   *rrc_rrm_ue_reconfig_req,
                  rrm_bool_et        *reconfig_ue)
{
    U8 tti_bundling = RRM_FALSE;
    /*Start changes for TTI bundling feature*/
    rrm_mac_config_t   *p_rrm_mac_config = RRM_PNULL;
    /*End changes for TTI bundling feature*/

    /* SPR 18640 Fix Start */
    admission_control_info_t        *p_admission_control_info = RRM_PNULL;
    U8                              ul_mcs = RRM_NULL;
    U8                              dl_mcs = RRM_NULL;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile = RRM_PNULL;
    /* SPR 18640 Fix End */

    RRM_UT_TRACE_ENTER();
    rrm_fill_tti_bundling(&(tti_bundling),
            p_rrm_ue_context);
    if((RRM_TRUE == tti_bundling) &&
            (RRM_FALSE == p_rrm_ue_context->tti_bundling_enabled))
    {
        p_rrm_ue_context->tti_bundling_enabled = RRM_TRUE;
        /* Now fill rrc_rrm_ue_reconfig_req */
        rrc_rrm_ue_reconfig_req->radio_resource_reconfig.presence_bitmask |= 
            RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
        rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config.bitmask |= 
            RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;
        rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config.mac_main_config.bitmask |= 
            RRC_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT;
        p_rrm_mac_config = &(rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config);
        p_rrm_mac_config->mac_main_config.ul_sch_config.tti_bundling = RRM_ONE;

        /* This is Mandatory , so have to fill, Following block shall be removed in future */
        {
            /* SPR 18640 Fix Start */   
            /* Moved variable decleration top */
            /* SPR 18640 Fix End */
            p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);
            p_admission_control_info = rrm_cellm_get_admission_control_info(p_rrm_ue_context->cell_index);
            ul_mcs = p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.ul_mcs; 
            dl_mcs = p_admission_control_info->snr_map.snr_dep_params.downlink_snr_dep_params.dl_mcs;

            fill_erb_setup_resp_time_alignment_timer(
                    &(p_rrm_mac_config->mac_main_config.time_alignment_timer_dedicated),
                    p_rrm_ue_context);
            p_rrm_mac_config->mac_main_config.
                ul_sch_config.retx_bsr_timer = p_rrm_ue_context->ul_sch_config.retx_bsr_timer_present;
            fill_erb_setup_resp_mac_main_config_extensions
                (&(p_rrm_mac_config->mac_main_config_extensions),
                 ul_mcs,dl_mcs,p_rrm_ue_context,p_ue_service_profile);
        }
        *reconfig_ue = RRM_TRUE;
    }
    else if((RRM_FALSE == tti_bundling) &&
            (RRM_TRUE == p_rrm_ue_context->tti_bundling_enabled))
    {
        p_rrm_ue_context->tti_bundling_enabled = RRM_FALSE;
        /* Now fill rrc_rrm_ue_reconfig_req */
        rrc_rrm_ue_reconfig_req->radio_resource_reconfig.presence_bitmask |= 
            RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
        rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config.bitmask |= 
            RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;
        rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config.mac_main_config.bitmask |= 
            RRC_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT;
        p_rrm_mac_config = &(rrc_rrm_ue_reconfig_req->radio_resource_reconfig.mac_config);
        p_rrm_mac_config->mac_main_config.ul_sch_config.tti_bundling = RRM_ZERO;

        /* This is Mandatory , so have to fill, Following block shall be removed in future */
        {
            /* SPR 18640 Fix Start */   
            /* Moved variable decleration top */
            /* SPR 18640 Fix End */
            p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);
            p_admission_control_info = rrm_cellm_get_admission_control_info(p_rrm_ue_context->cell_index);
            ul_mcs = p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.ul_mcs; 
            dl_mcs = p_admission_control_info->snr_map.snr_dep_params.downlink_snr_dep_params.dl_mcs;

            fill_erb_setup_resp_time_alignment_timer(
                    &(p_rrm_mac_config->mac_main_config.time_alignment_timer_dedicated),
                    p_rrm_ue_context);
            p_rrm_mac_config->mac_main_config.ul_sch_config.retx_bsr_timer =
                p_rrm_ue_context->ul_sch_config.retx_bsr_timer_present;
            fill_erb_setup_resp_mac_main_config_extensions
                (&(p_rrm_mac_config->mac_main_config_extensions),
                 ul_mcs,dl_mcs,p_rrm_ue_context,p_ue_service_profile);
        }
        *reconfig_ue = RRM_TRUE;
    }
    else 
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                "No change on TTI bundling feature, no need to reconfig UE");
    }
  RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME:rrm_fill_srs_reconfig 
 *   input      : p_rrm_ue_context,rrc_rrm_ue_reconfig_req
 *   output     : reconfig_ue
 *   DESCRIPTION:
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
/*SPR 19752 changes start*/
rrm_void_t
rrm_fill_srs_reconfig(rrm_ue_context_t            *p_rrm_ue_context,
                      rrm_cell_context_t          *p_cell_context,  
                      rrc_rrm_ue_reconfig_req_t   *rrc_rrm_ue_reconfig_req,
                      rrm_bool_et                 *reconfig_ue)
{
    /*Code removed*/
    /*SPR 19752 changes stop*/
    /* SRS_FREQ_HOPPING_START */
    rrm_bool_t                               srs_hopping_status_changed = RRM_ZERO;
    /* SRS_FREQ_HOPPING_END */
    
    /* SPR 8019 FIX START */
    rrm_frequency_selective_sched_et ul_freq_selective_sched = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
    /* SPR 8019 FIX END*/
    ul_freq_selective_sched =
              p_cell_context->operator_info.rrm_mac_config.enable_frequency_selective_scheduling.ul_freq_selective_enable;

    RRM_UT_TRACE_ENTER();

    if( RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE == ul_freq_selective_sched)
    {
        /* SPR 8019 FIX END*/
        /*			   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                       "SRS Config of UE before reconfig :"
                       "SRS_ANCHOR [%d] ,srs_bandwidth[%d] ,srs_hopping_bandwidth[%d] , frequency_domain_position [%d],"
                       "srs_configuration_index [%d] , transmission_comb[%d] ,cyclic_shift [%d] ",
                       p_rrm_ue_context->srs_params.srs_anchor,
                       p_rrm_ue_context->srs_params.srs_bandwidth,
                       p_rrm_ue_context->srs_params.srs_hopping_bandwidth,
                       p_rrm_ue_context->srs_params.frequency_domain_position,
                       p_rrm_ue_context->srs_params.srs_configuration_index,
                       p_rrm_ue_context->srs_params.transmission_comb,
                       p_rrm_ue_context->srs_params.cyclic_shift);*/
        /* coverity id :29734 ,rel 2.0.1 */
        srs_hopping_status_changed = rrm_check_for_srs_hopping_enable_disable
            ( p_rrm_ue_context, 
              &(rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
                  rrc_rrm_ue_reconfig_physical_config_dedicated.
                  sounding_rs_ul_config_dedicated));

        if(RRM_SUCCESS == srs_hopping_status_changed)
        {
            p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                RRM_UE_RECONFIG_PHY_SOUNDING_RS_UL_CONFIG_ROLLBACK_PRESENT;

            rrc_rrm_ue_reconfig_req->radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask  |= RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;
            /*SPR 19752 changes start*/
            *reconfig_ue = RRM_TRUE;
            /*SPR 19752 changes stop*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "SRS Hopping status for the UE is changed");

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "SRS Config of UE before reconfig :"
                    "SRS_ANCHOR [%d] ,srs_bandwidth[%d] ,srs_hopping_bandwidth[%d] , frequency_domain_position [%d],"
                    "srs_configuration_index [%d] , transmission_comb[%d] ,cyclic_shift [%d], SRS_res_type [%d] i.e. [%s]",
                    p_rrm_ue_context->srs_params_last_used.srs_anchor,
                    p_rrm_ue_context->srs_params_last_used.srs_bandwidth,
                    p_rrm_ue_context->srs_params_last_used.srs_hopping_bandwidth,
                    p_rrm_ue_context->srs_params_last_used.frequency_domain_position,
                    p_rrm_ue_context->srs_params_last_used.srs_configuration_index,
                    p_rrm_ue_context->srs_params_last_used.transmission_comb,
                    p_rrm_ue_context->srs_params_last_used.cyclic_shift,
                    p_rrm_ue_context->srs_params_last_used.srs_res_type,
                    ((RRM_UE_SRS_TYPE_WIDEBAND ==  p_rrm_ue_context->srs_params_last_used.srs_res_type)? "WIDEBAND":"SUBBAND"));

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "SRS Config after  UE reconfig :"
                    "SRS_ANCHOR [%d] ,srs_bandwidth[%d] ,srs_hopping_bandwidth[%d] , frequency_domain_position [%d],"
                    "srs_configuration_index [%d] , transmission_comb[%d] ,cyclic_shift [%d], SRS_res_type [%d] i.e [%s] ",
                    p_rrm_ue_context->srs_params.srs_anchor,
                    p_rrm_ue_context->srs_params.srs_bandwidth,
                    p_rrm_ue_context->srs_params.srs_hopping_bandwidth,
                    p_rrm_ue_context->srs_params.frequency_domain_position,
                    p_rrm_ue_context->srs_params.srs_configuration_index,
                    p_rrm_ue_context->srs_params.transmission_comb,
                    p_rrm_ue_context->srs_params.cyclic_shift,
                    p_rrm_ue_context->srs_params.srs_res_type,
                    ((RRM_UE_SRS_TYPE_WIDEBAND ==  p_rrm_ue_context->srs_params.srs_res_type)? "WIDEBAND":"SUBBAND"));
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "SRS Hopping status for the UE is  NOT changed");
        }
        /*	   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
               "SRS Config after  UE reconfig :"
               "SRS_ANCHOR [%d] ,srs_bandwidth[%d] ,srs_hopping_bandwidth[%d] , frequency_domain_position [%d],"
               "srs_configuration_index [%d] , transmission_comb[%d] ,cyclic_shift [%d] ",
               p_rrm_ue_context->srs_params.srs_anchor,
               p_rrm_ue_context->srs_params.srs_bandwidth,
               p_rrm_ue_context->srs_params.srs_hopping_bandwidth,
               p_rrm_ue_context->srs_params.frequency_domain_position,
               p_rrm_ue_context->srs_params.srs_configuration_index,
               p_rrm_ue_context->srs_params.transmission_comb,
               p_rrm_ue_context->srs_params.cyclic_shift);*/

        /* SPR 8019 FIX START */


    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                " Configured UL Frequency Scheduling Scheme (%d) does'not support SRS reconfiguration "
                " from Subband->Wideband or  Wideband->Subband",ul_freq_selective_sched);
    }
    /* SPR 8019 FIX END */
    RRM_UT_TRACE_EXIT();
    /*SPR 19752 changes start*/
    /* Code removed*/
    /*SPR 19752 changes stop*/
}
/* cyclo end */
/* SPR_15313_Fix_Start */
/******************************************************************************
 *   FUNCTION NAME:find_cqi_offset
 *   INPUT      : p_rrm_ue_context,total_drx_offset
 *   OUTPUT     : p_drx_start_offset
 *   DESCRIPTION:
 *                Finds the drx offset after checking the cqi offset.
 *
 *   RETURNS    :
 *                NONE
 ******************************************************************************/
rrm_void_t find_cqi_offset
(
 U8 cqiPeriodicity,
 U16 cqi_config_index ,
 U16 *cqi_offset_p
 )
{
    /* Calculating Noffsetcqi from cqi Periodicity and Icqi/pmi */
    U16 cqi_offset           = RRM_ZERO;
    U16 cqi_start_index      = RRM_ZERO;
    switch(cqiPeriodicity)
    {
        case CQI_PERIODICITY_0:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_2MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_1MS_TDD_START_INDEX;
#endif
            break;

        case CQI_PERIODICITY_1:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_5MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_5MS_TDD_START_INDEX;
#endif
            break;

        case CQI_PERIODICITY_2:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_10MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_10MS_TDD_START_INDEX;
#endif
            break;


        case CQI_PERIODICITY_3:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_20MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_20MS_TDD_START_INDEX;
#endif
            break;

        case CQI_PERIODICITY_4:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_40MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_40MS_TDD_START_INDEX;
#endif
            break;

        case CQI_PERIODICITY_5:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_80MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_80MS_TDD_START_INDEX;
#endif
            break;

        case CQI_PERIODICITY_6:
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_160MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_160MS_TDD_START_INDEX;
#endif
            break;

        default :
#ifndef TDD_MODE_FLAG
            cqi_start_index = CQI_PERIODICITY_10MS_FDD_START_INDEX;
#else
            cqi_start_index = CQI_PERIODICITY_10MS_TDD_START_INDEX;
#endif
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Default value chosen");

    }
    cqi_offset     = cqi_config_index - cqi_start_index;
    *cqi_offset_p = cqi_offset ;
}
/******************************************************************************
 *   FUNCTION NAME:rrm_find_drx_offset_cqi_based
 *   INPUT      : p_rrm_ue_context,long_drx_cycle
 *   OUTPUT     : p_drx_start_offset
 *   DESCRIPTION:
 *                Finds the drx offset after checking the cqi offset.
 *
 *   RETURNS    :
 *                NONE
 ******************************************************************************/
rrm_void_t rrm_find_drx_offset_cqi_based
(
 rrm_ue_context_t                        *p_rrm_ue_context,
 rrm_oam_long_drx_cycle_start_offset_et  long_drx_cycle,
 U16                                     *p_drx_start_offset,
 /*SPR 15713 Fix Start*/
 U16                                     *p_cqi_offset
 /*SPR 15713 Fix End*/
)
{
    rrm_cell_context_t *p_cell_context        =   RRM_PNULL;
    /*SPR 15663 start*/
    /*code_deleted*/
    /*SPR 15663 end*/
    U16             cqi_periodicity           =   RRM_ZERO ;
    U32             long_drx_cycle_value      =   RRM_ZERO ;

    /* Get the long DRX Decimal value from enum */
    long_drx_cycle_value = rrm_convert_drx_sf_in_ms(long_drx_cycle);

    /* Access Cell Context to check cqiPeriodicity*/
    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*Cov_fix_87121*/        
    if ( RRM_PNULL != p_cell_context )
    {
        find_cqi_periodicity_from_cell_context(p_cell_context, &cqi_periodicity);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                      "p_cell_context is null ");
        return;
    }
    /*Cov_fix_87121*/
    /*SPR 15713 Fix Start*/
    find_cqi_offset(cqi_periodicity,p_rrm_ue_context->cqi_params.cqi_pmi_config_index,p_cqi_offset);
    /*SPR 15713 Fix End*/
    /* Getting the drx_start_offset as cqi_offset modulo DRX Cycle i.e total_drx_offset */
    /*SPR 15713 Fix Start*/
    *p_drx_start_offset = *p_cqi_offset % long_drx_cycle_value;
    /*SPR 15713 Fix End*/
}
/* SPR_15313_Fix_End */

#ifdef ENDC_ENABLED
/******************************************************************************
 *   FUNCTION NAME:rrm_find_drx_offset_cqi_based_r15
 *   INPUT        : p_rrm_ue_context,long_drx_cycle
 *   OUTPUT       : p_drx_start_offset
 *   DESCRIPTION  : Finds the drx offset after checking the cqi offset.
 *   RETURNS      : NONE
 ******************************************************************************/
rrm_void_t rrm_find_drx_offset_cqi_based_r15
(
    rrm_ue_context_t                            *p_rrm_ue_context,
    rrm_oam_long_drx_cycle_start_offset_r15_et  long_drx_cycle,
    U16                                         *p_drx_start_offset,
    U16                                         *p_cqi_offset
)
{
    rrm_cell_context_t *p_cell_context        =   RRM_PNULL;
    U16             cqi_periodicity           =   RRM_ZERO;
    U32             long_drx_cycle_value      =   RRM_ZERO;

    /* Get the long DRX Decimal value from enum */
    long_drx_cycle_value = rrm_convert_drx_sf_in_ms_r15(long_drx_cycle);

    /* Access Cell Context to check cqiPeriodicity*/
    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    if ( RRM_PNULL != p_cell_context )
    {
        find_cqi_periodicity_from_cell_context(p_cell_context, &cqi_periodicity);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                      "p_cell_context is null ");
        return;
    }

    find_cqi_offset(cqi_periodicity,p_rrm_ue_context->cqi_params.cqi_pmi_config_index,p_cqi_offset);

    /* Getting the drx_start_offset as cqi_offset modulo DRX Cycle i.e total_drx_offset */
    *p_drx_start_offset = *p_cqi_offset % long_drx_cycle_value;
}
#endif

rrm_return_et 
send_ue_reconfig_for_scell_addition
(
 rrm_cell_context_t                   *p_cell_context,
 rrm_ue_context_t                     *p_rrm_ue_context,
 U8                                   *scell_count,
 rrm_cell_index_t                     *scell_enough_report,
 rrc_antenna_info_dedicated_r10_t     *p_rrc_phy_config_dedicated_scell, 
 rrm_return_et                        *ret_val,
 rrc_rrm_ue_reconfig_req_t            *rrc_rrm_ue_reconfig_req,
 rrm_bool_et                          *is_power_changed
 )
{
    /*CID 65758:start*/    
    rrm_bool_et   antenna_match     = RRM_TRUE; 
    U64           ca_params_bitmask = RRM_ZERO;
    U8            scell_arr_idx     = RRM_ZERO;
    U8            count             = RRM_ZERO; 

    RRM_UT_TRACE_ENTER();
    if(( p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE ) &&
            ( rrm_check_scell_report_count(p_rrm_ue_context, scell_count, scell_enough_report) == RRM_TRUE)) 
    {
        for(count = RRM_ZERO; ((count < *scell_count) && (count < MAX_SCELL)); count++)  /* Klocwork_fix_27_aug */
        {
            /*UT-Fix*/
            p_rrc_phy_config_dedicated_scell = (rrc_antenna_info_dedicated_r10_t *) rrm_mem_get
                (sizeof(rrc_antenna_info_dedicated_r10_t));
            *ret_val = rrm_fill_scell_transmission_mode_r10( p_rrc_phy_config_dedicated_scell,
                    scell_enough_report[count],
                    p_rrm_ue_context,
                    &antenna_match);

            if((*ret_val == RRM_SUCCESS) && (antenna_match == RRM_FALSE))
            {
                if(rrm_is_scell_valid_for_ue(p_rrm_ue_context,
                            scell_enough_report[count],
                            &scell_arr_idx) == RRM_SUCCESS)
                {
                    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].bitmask |=
                        RRM_UE_RECONFIG_SCELL_TM_INFO_R10_ROLLBACK_PRESENT;


                    RRM_MEMCPY( &(rrc_rrm_ue_reconfig_req->scell_config.scell_add_mod_list.
                                rrc_scell_to_add_mod[count].radio_res_config_dedicated_scell.
                                physical_config_dedicated_scell.radio_res_dedicated_scell_non_ul_config.
                                antenna_info_dedicated_r10), p_rrc_phy_config_dedicated_scell, 
                            sizeof(rrc_antenna_info_dedicated_r10_t));

                    rrc_rrm_ue_reconfig_req->scell_config.scell_add_mod_list.
                        rrc_scell_to_add_mod[count].radio_res_config_dedicated_scell.
                        physical_config_dedicated_scell.radio_res_dedicated_scell_non_ul_config.
                        bitmask |= RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT;
                    /*UT-Fix*/
                    rrc_rrm_ue_reconfig_req->scell_config.scell_add_mod_list.rrc_scell_to_add_mod[count].radio_res_config_dedicated_scell.        
                        physical_config_dedicated_scell.bitmask |=  RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT; 
                }
            }
            RRM_MEM_FREE(p_rrc_phy_config_dedicated_scell);
        }      
        /* Fill the scell Params */
        if(*scell_count > RRM_ZERO)
        {
            rrm_calc_ca_param_bitmask(&ca_params_bitmask); 
            if (RRM_SUCCESS == fill_scell_config_params_in_ue_reconfig(p_rrm_ue_context,
                        *scell_count,
                        scell_enough_report,
                        &(rrc_rrm_ue_reconfig_req->scell_config),
                        ca_params_bitmask))
            {
                /*Only SCell to be added*/
                rrc_rrm_ue_reconfig_req->bitmask |= RRM_UE_RECONFIG_SCELL_CONFIG_PRESENT;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                        "Radio Resource Refonfig params for Scell failed.");
                *ret_val = RRM_FAILURE;
            }
        }
    }

    rrc_rrm_ue_reconfig_req->ue_index = p_rrm_ue_context->ue_index;

    rrc_rrm_ue_reconfig_req->bitmask |= RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;

    rrc_rrm_ue_reconfig_req->radio_resource_reconfig.presence_bitmask |= 
        RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;
    /* BUG_11317_FIX_START */
    /* OLPC will be enabled only when CLPC is disabled at Layer2.
     * Below checks were done to check if CLPC is enabled or disbled
     */
    if ((p_cell_context->operator_info.bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT) &&
            (RRM_FALSE == p_cell_context->operator_info.rrm_mac_config.mac_power_control_enable.harqBlerClpcPucchEnable) &&
            (RRM_FALSE == p_cell_context->operator_info.rrm_mac_config.mac_power_control_enable.cqiSinrClpcPucchEnable) &&
            (RRM_FALSE == p_cell_context->operator_info.rrm_mac_config.mac_power_control_enable.clpcPuschEnable)
       )
    {
        if( p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE )
        {
            *is_power_changed = rrm_apply_olpc((rrm_ue_context_t *)p_rrm_ue_context,
                    &rrc_rrm_ue_reconfig_req->radio_resource_reconfig);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "No. of Fresh Report[%d] for uplink power parameters reconfig is not enough",
                    (p_rrm_ue_context->p_ue_mac_report->report_index % RRM_MAX_REPORT_STAT_UE));
        }
        *is_power_changed = rrm_apply_olpc((rrm_ue_context_t *)p_rrm_ue_context,
                &rrc_rrm_ue_reconfig_req->radio_resource_reconfig);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CLPC is Enabled at Layer2");
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
    /*CID 65758:end*/    
}    

/* SPR 12480 Start */
rrm_bool_et
rrm_uem_find_and_apply_drx_config(
   rrm_ue_context_t                *p_rrm_ue_context,
   radio_resource_reconfig_t       *p_radio_resource_reconfig,
   rrm_cell_drx_config_resources_t *p_rrm_cell_drx_res_pool
)
{

    U8                          count                     = RRM_ZERO;
    U8                          drx_profile_index         = RRM_ZERO;
    U8                          applicable_drx_index      = NO_DRX_PROFILE;
    rrm_bool_et                 drx_config_changed        = RRM_FALSE;
    U16                         new_drx_start_offset      = RRM_ZERO;
    rrmc_mac_config_t           *p_rrmc_mac_config        = RRM_PNULL;
    #ifdef ENDC_ENABLED
    rrm_oam_long_drx_cycle_start_offset_r15_et
        least_long_drx_cycle      = RRM_OAM_R15_SF10240; 
    #else
    rrm_oam_long_drx_cycle_start_offset_et
        least_long_drx_cycle      = RRM_OAM_SF2560; 
    #endif
    admission_control_info_t    *p_admission_control_info = RRM_NULL;
    U8                          dl_bandwidth              = RRM_ZERO;
    U8                          num_of_layer              = RRM_ZERO; 

    rrc_mac_main_config_ue_service_profile_t    
        *p_ue_profile_mac_main_config = RRM_NULL;
    rrc_rrm_ue_service_profile_t
        *p_ue_service_profile         = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    for(count = RRM_ZERO ; count < p_rrm_ue_context->drb_configured.num_of_list ; count++)
    { 
        drx_profile_index = p_rrm_ue_context->drb_configured.erab_item[count].erab_level_qos_params.qci - RRM_ONE;
        if ( RRM_TRUE == p_rrm_cell_drx_res_pool->drx_res_arr[drx_profile_index].drx_enabled )
        {
            #ifdef ENDC_ENABLED
            if( p_rrm_cell_drx_res_pool->drx_res_arr[drx_profile_index].long_drx_cycle_r15
                    <= least_long_drx_cycle )
            {
                least_long_drx_cycle =
                    p_rrm_cell_drx_res_pool->drx_res_arr[drx_profile_index].long_drx_cycle_r15;
                applicable_drx_index = drx_profile_index;
            }
            #else
            if( p_rrm_cell_drx_res_pool->drx_res_arr[drx_profile_index].long_drx_cycle
                    <= least_long_drx_cycle )
            {
                least_long_drx_cycle =
                    p_rrm_cell_drx_res_pool->drx_res_arr[drx_profile_index].long_drx_cycle;
                applicable_drx_index = drx_profile_index;
            }
            #endif
        }
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Applicable DRX Index = %u", applicable_drx_index);
		
    if(NO_DRX_PROFILE != applicable_drx_index)
    {
	    drx_config_changed        = RRM_TRUE;
	    /*
	     ** MAC MAIN Configuration
	     */
	    p_radio_resource_reconfig->presence_bitmask |= RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
	    p_radio_resource_reconfig->mac_config.bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;

	    p_radio_resource_reconfig->mac_config.mac_main_config.bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;

	    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.bitmask |= RRC_DRX_CONFIG_PARAM_PRESENT;
	    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_type = RRC_DRX_CONFIG_TYPE_SETUP; 

	    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.on_duration_timer =
		    p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].on_duration_timer;

	    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.drx_inactivity_timer =
		    p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].drx_inactivity_timer;

	    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.drx_retransmission_timer = 
		    p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].drx_retransmission_timer;

	    /*SPR 19049 Start*/
	    if( (p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].bitmask & RRMCM_SHORT_DRX_CONFIG_PRESENT) && ((rrm_is_set_fgi_bit(p_rrm_ue_context,RRM_FOUR)) == RRM_TRUE))
	    {
            /*SPR 19049 End*/
		    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.bitmask |= RRC_DRX_CONFIG_SHORT_DRX_PRESENT;
		    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.short_drx.short_drx_cycle = 
			    p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].short_drx_cycle_config.short_drx_cycle;

		    p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.short_drx.short_drx_cycle_timer = 
			    p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].short_drx_cycle_config.drx_short_cycle_timer;
	    }

	    rrm_find_free_drx_offset_frm_drx_res_tree(p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].drx_res_tree,
			    p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].total_drx_offset,
			    &new_drx_start_offset);

        file_erb_setup_resp_long_drx_cycle_start_offset
            (&(p_radio_resource_reconfig->mac_config.
               mac_main_config.drx_config.drx_config_param.long_drx_cycle_start_offset),
             p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].long_drx_cycle, 
             new_drx_start_offset);
        
#ifdef ENDC_ENABLED
        if ( p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].bitmask & RRMCM_LONG_DRX_CYCLE_R15_PRESENT )
        {
            file_erb_setup_resp_long_drx_cycle_start_offset_r15
                (&(p_radio_resource_reconfig->mac_config.
                   mac_main_config.drx_config.drx_config_param.long_drx_cycle_start_offset_r15),
                 p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].long_drx_cycle_r15, 
                 new_drx_start_offset);
            p_radio_resource_reconfig->mac_config.mac_main_config.drx_config.drx_config_param.bitmask
                |= RRC_DRX_CONFIG_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
        }
#endif

	    /*
	     ** MAC MAIN Extesion Configuration
	     */
	    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(p_rrm_ue_context->cell_index); 
	    p_admission_control_info = rrm_cellm_get_admission_control_info(p_rrm_ue_context->cell_index);
	    p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);

	    p_ue_profile_mac_main_config =  &(p_ue_service_profile->radio_res_config.mac_config.mac_main_config);
	    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.ue_priority = MAC_UE_PRIORITY;

	    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.dl_num_harq_process 
		    = p_rrmc_mac_config->dl_num_harq_process;

	    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.dl_i_mcs 
		    = p_admission_control_info->snr_map.snr_dep_params.downlink_snr_dep_params.dl_mcs;

	    if(rrm_cellm_get_rrmc_band_width(p_rrm_ue_context->cell_index,&dl_bandwidth) == RRM_SUCCESS)
	    {
		    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.dl_max_rb = dl_bandwidth;
	    } 

	    if(p_ue_profile_mac_main_config->ul_sch_config.bitmask &
			    RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT)
	    {
		    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.max_ul_harq_tx 
			    = p_ue_profile_mac_main_config->ul_sch_config.max_ul_harq_tx;
	    }

	    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.ul_i_mcs 
		    = p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.ul_mcs; 

	    if ( RRM_SUCCESS == rrm_select_num_of_layer_for_ue( p_rrm_ue_context,
				    &num_of_layer) )
	    {
		    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.num_of_layer = num_of_layer; 
	    }

	    p_radio_resource_reconfig->mac_config.mac_main_config_extensions.code_book_index = CODE_BOOK_INDEX;

	    /*spr_12699_fix*/
	    if(NO_DRX_PROFILE != p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index)
	    {

		    rrm_ue_rac_clear_drx_res( p_rrm_ue_context->cell_index,
				    p_rrm_ue_context->applied_drx_config.
				    curr_applied_drx_config.applied_drx_profile_index,
				    p_rrm_ue_context->applied_drx_config.
				    curr_applied_drx_config.applied_drx_offset_val
				    );

	    }
        p_rrm_ue_context->applied_drx_config.
            curr_applied_drx_config.applied_drx_offset_val = new_drx_start_offset;
        p_rrm_ue_context->applied_drx_config.
            curr_applied_drx_config.applied_long_drx_cycle = p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].long_drx_cycle;

        #ifdef ENDC_ENABLED
        p_rrm_ue_context->applied_drx_config.
            curr_applied_drx_config.applied_long_drx_cycle_r15 = p_rrm_cell_drx_res_pool->drx_res_arr[applicable_drx_index].long_drx_cycle_r15;
        #endif

        p_rrm_ue_context->applied_drx_config.
            curr_applied_drx_config.applied_drx_profile_index = applicable_drx_index;
	/*SPR 18924 Fix Start*/
	fill_erb_setup_resp_time_alignment_timer(
			&(p_radio_resource_reconfig->mac_config.mac_main_config.time_alignment_timer_dedicated),
			p_rrm_ue_context);
	/*SPR 18924 Fix End*/
    }
    else
    {
        drx_config_changed = RRM_FALSE;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "New DRX configuration is not Found !!");
    }
    RRM_UT_TRACE_EXIT();
    return drx_config_changed;
}
/* SPR 12480 End */

/* SPR 10450 Fix Start */
rrm_bool_et
rrm_apply_new_drx_configuration
( 
   rrm_ue_context_t                *p_rrm_ue_context,
   radio_resource_reconfig_t       *p_radio_resource_reconfig,
   rrm_cell_drx_config_resources_t *p_rrm_cell_drx_res_pool
)
{
    U8                          count                     = RRM_ZERO;
    rrm_bool_et               process_drx_reconfig      = RRM_FALSE;
    rrm_bool_et                 drx_config_changed        = RRM_FALSE;
    /* SPR 12480 Delete */

   RRM_UT_TRACE_ENTER();
   
   /*
   ** Check whether QCI val corresponding to which DRX configuration was applied for UE
   ** is present or not in the erab release list.
   */
   for( count = RRM_ZERO; count < p_rrm_ue_context->applied_drx_config.num_of_released_erab; count++)
   {
      if( (p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index + RRM_ONE) 
                 == p_rrm_ue_context->applied_drx_config.released_erab_info[count])
      {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "Already applied DRX configuration is for QCI[%d] and ERAB for this QCI is released.",
                       p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index + RRM_ONE);
            process_drx_reconfig = RRM_TRUE;
            break; 
      }
   }

   if(RRM_TRUE == process_drx_reconfig)
   {
      /*
      ** Check whether among the remaining configured ERABs , is there any ERAB with the 
      ** same QCI value as the one for which DRX configuration is applied.
      */
      for(count = RRM_ZERO ; count < p_rrm_ue_context->drb_configured.num_of_list ; count++)
      { 
        if ((p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index + RRM_ONE)
             ==  p_rrm_ue_context->drb_configured.erab_item[count].erab_level_qos_params.qci)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "Already applied DRX configuration is for QCI[%d] and ERAB for this QCI is still configured"
                      "for the UE",
                      p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index + RRM_ONE);
            process_drx_reconfig = RRM_FALSE;
            break;
        }
      }
      

      if(RRM_TRUE == process_drx_reconfig)
      {
          /* SPR 12480 Delete */

          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "Already applied DRX configuration is for QCI[%d] and ERAB for this QCI is NOT configured"
                  "for the UE Now. Find the new applicable DRX configuration" ,
                  p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index + RRM_ONE);

            /* SPR 12480 Start */
            drx_config_changed = rrm_uem_find_and_apply_drx_config(p_rrm_ue_context,
                p_radio_resource_reconfig, p_rrm_cell_drx_res_pool);
            /* SPR 12480 End */

      }
   }
   else
   {
       drx_config_changed   = RRM_FALSE;
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Already applied DRX configuration is for QCI[%d] and ERAB for this QCI is Not released.",
               p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index + RRM_ONE);
   }

   RRM_UT_TRACE_EXIT();
   return drx_config_changed;
}

/* SPR 10450 Fix End */
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_reconfig_req
 *   input      : p_rrm_ue_context
 *   output     : none
 *   DESCRIPTION:
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_build_and_send_ue_reconfig_req(rrm_ue_context_t *p_rrm_ue_context)
{

    rrm_return_et			      ret_val = RRM_SUCCESS;
    U16					      transaction_id = RRM_1;
    rrm_bool_et			              antenna_info_match = RRM_TRUE;
    //    rrc_phy_antenna_information_dedicated_t   rrm_antenna_information_for_ue_reconfig = {RRM_ZERO};
    /* R-10 Changes: End */
    /* Uplink power starts */
    /*spr 8514 fix start*/
    rrm_bool_et 			      is_power_changed = RRM_FALSE;
    /*spr 8514 fix end*/
    /* Uplink power end */
    rrm_bool_et				      reconfig_ue = RRM_FALSE;
    rrc_rrm_ue_reconfig_req_t		      rrc_rrm_ue_reconfig_req = {RRM_ZERO};
    rrc_drx_config_t             *p_rrm_cdrx_config = RRM_PNULL;
    rrc_phy_physical_config_dedicated_t       *p_rrc_phy_config_dedicated = &( rrc_rrm_ue_reconfig_req.
            radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated );



    /*DYNAMIC ICIC START*/
    rrm_bool_et 			      dynaimc_icic_scheme_applied = RRM_TRUE;
    /* FIX UE_RECONFIG_CONDITIONAL START */
    rrm_cell_context_t		      *p_cell_context = RRM_PNULL;
    /* FIX UE_RECONFIG_CONDITIONAL END */
    /*DYNAMIC ICIC END*/
    U8                    scell_count = RRM_ZERO;
    rrm_cell_index_t      scell_enough_report[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
    rrc_antenna_info_dedicated_r10_t    *p_rrc_phy_config_dedicated_scell = RRM_PNULL;


    /* SPR 10450 Fix Start */
    rrm_bool_et     drx_configuration_changed = RRM_FALSE;
    /* SPR 10450 Fix End */
    /* SPR 12480 Start */
    mac_layer_params_t              *p_mac_layer_params = RRM_PNULL;
    /* SPR 12480 End */
    RRM_UT_TRACE_ENTER();

    /* FIX UE_RECONFIG_CONDITIONAL START */
    p_cell_context = rrm_cellm_get_cell_context(
            p_rrm_ue_context->cell_index);
    /* FIX UE_RECONFIG_CONDITIONAL END */
    /*CID 65824:start*/
    if (RRM_PNULL == p_cell_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65824:end*/

    /* setting bitmask with 0x00 */
    p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = RRM_ZERO;

    if( p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                " Report Count [%d] of Fresh Report ",p_rrm_ue_context->p_ue_mac_report->report_count );

        ret_val = rrm_fill_transmission_mode(p_rrm_ue_context,
                p_rrc_phy_config_dedicated,
                &antenna_info_match);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                " Report Count [%d] of Fresh Report, antennaInfomatch [%d] ",p_rrm_ue_context->p_ue_mac_report->report_count, antenna_info_match);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "No. of Fresh Report[%d] for Transmission mode reconfig is not enough",
                (p_rrm_ue_context->p_ue_mac_report->report_count));
    }
   /*klock_works_chnges_start*/   
   send_ue_reconfig_for_scell_addition(p_cell_context,p_rrm_ue_context, &scell_count, scell_enough_report, p_rrc_phy_config_dedicated_scell, &ret_val, &rrc_rrm_ue_reconfig_req,   &is_power_changed); 
   /*klock_works_chnges_end*/
    
    /* BUG_11317_FIX_END */
    if( RRM_SUCCESS == ret_val && RRM_FALSE == antenna_info_match )
    {
        /* cyclo start */  
        ret_val = rrm_send_tm_switching_info_in_ue_reconfig(p_rrm_ue_context,
                &rrc_rrm_ue_reconfig_req,p_rrc_phy_config_dedicated,&reconfig_ue);
        /* cyclo end */ 

    }	
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
        "Transmission mode switching info could not be sent in UE Reconfig");

    }
    /* Uplink power starts */
    if(RRM_TRUE == is_power_changed)
    {
        /*setting ue context reconfig bitmask in ue context for uplink power ctrl */
        p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                          RRM_UE_RECONFIG_PHY_UPLINK_POWER_CONTROL_ROLLBACK_PRESENT;
 
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask  |= RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;
        reconfig_ue = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Power of UE changed");
    }
    /* Uplink power end */

  /*DYNAMIC ICIC START*/
  /*
   ** Check for Inter Cell Interference to reconfig the UE.
   */
  /* FIX UE_RECONFIG_CONDITIONAL START */
/* SPR_8391_CHANGES_START*/
  if( (RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT & p_cell_context->operator_info.bitmask)&&
        ( RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT & 
              p_cell_context->operator_info.dynamic_icic_info.bitmask) &&
          ( (ICIC_SCHEME_FFR == p_cell_context->operator_info.dynamic_icic_info.icic_scheme_type) ||
            (ICIC_SCHEME_SFR == p_cell_context->operator_info.dynamic_icic_info.icic_scheme_type)
          ) &&
         (p_cell_context->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT) &&
         (p_cell_context->operator_info.dynamic_icic_info.ul_resource_partition_info.num_of_cell_edge_region != RRM_ZERO)
/* SPR_8391_CHANGES_END*/
    )
  {
      dynaimc_icic_scheme_applied = rrm_apply_dynamic_icic_schemes
          ((rrm_ue_context_t *)p_rrm_ue_context,
           &rrc_rrm_ue_reconfig_req.radio_resource_reconfig
          );
      if(RRM_TRUE == dynaimc_icic_scheme_applied)
      {
          p_rrm_ue_context->dynamic_icic_info.ue_reconfig_rollback_flag = RRM_TRUE;
          reconfig_ue = RRM_TRUE;
/* SPR_8391_CHANGES_START*/
          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "Dynamic ICIC scheme is applied for the UE ,Check for SRS reconfiguration");
      }
  }
  else
  {
/* SPR_8315_PART2_FIX_START */
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
              "No need to reconfig UE for location  as either ICIC scheme is"
              "not applied OR it is HFR or CE partion is absent");
/* SPR_8315_PART2_FIX_END */
  }
/* SPR_8391_CHANGES_END*/
    /*Start changes for TTI bundling feature*/
    if(p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE)
    {
        /* cyclo start */
        rrm_fill_tti_info(p_rrm_ue_context,&rrc_rrm_ue_reconfig_req,&reconfig_ue);
        /* cyclo end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
        "No. of Fresh Report[%d] for TTI bundling is not enough",
        (p_rrm_ue_context->p_ue_mac_report->report_index % RRM_MAX_REPORT_STAT_UE));
    }
    /*End changes for TTI bundling feature*/
       

/* SPR_8315_PART2_FIX_START */
    /* CHECK for SRS reconfiguration ALSO */
          /*
           ** Check whether the change in hopping status i.e. hopping enabled/disabled
	   ** is required for the UE or not.
	   ** UE is reconfigured if change in hopping status is observed.
          */
       if(RRM_TRUE == rrm_cellm_get_srs_status(p_rrm_ue_context->cell_index))
	   {
        /* SPR 19752 changes start */
        rrm_fill_srs_reconfig(p_rrm_ue_context,p_cell_context,&rrc_rrm_ue_reconfig_req,&reconfig_ue);
        /* SPR 19752 changes stop */
        /* SPR 8019 FIX START */
	   } 
       else
	   {
		   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				   " SRS is Disabled.  SRS reconfiguration can't be done");
	   }
/* SPR_8315_PART2_FIX_END */

  /*DYNAMIC ICIC END*/

  /* Fix for CSR: 00059124 */
  /* Start 12973 Start */
  if (RRM_UE_CDRX_TO_BE_APPLIED == p_rrm_ue_context->cdrx_status)
  /* Start 12973 End */
  {
       rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
       rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;
       rrm_fill_mac_main_config_extension_for_l3_ue_reconfig(
               p_rrm_ue_context,
              &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                mac_main_config_extensions));
       fill_erb_setup_resp_time_alignment_timer(
              &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.time_alignment_timer_dedicated),
               p_rrm_ue_context);
       rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.bitmask |=
           RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;

       p_rrm_cdrx_config = &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config);

       if (RRM_SUCCESS == (rrm_fill_cdrx_config_for_ue_reconfig(p_rrm_ue_context,p_cell_context, p_rrm_cdrx_config)))
       {
           reconfig_ue = RRM_TRUE;
            /* SPR 15539 Start */
            p_rrm_ue_context->is_cgi_process_in_progress = RRM_TRUE;
            /* SPR 15539 End */
       }
       else
       {
          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Unable to fill cdrx configuration for UE reconfig request to RRC [UE:%d]",
                     p_rrm_ue_context->ue_index);
          /* SPR 12480 Start */ 
          p_rrm_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
          /* SPR 12480 End */
       }
  }
  /* SPR 12480 Start */
  else if(RRM_UE_CDRX_TO_BE_REMOVED == p_rrm_ue_context->cdrx_status)
  {
      p_mac_layer_params = rrm_cellm_mac_layer_params(p_rrm_ue_context->cell_index);
#ifndef LTE_EMBMS_SUPPORTED
      if(p_mac_layer_params->mac_layer_param_drx.drx_enabled == RRM_TRUE)
#else
      if((p_mac_layer_params->mac_layer_param_drx.drx_enabled == RRM_TRUE) &&
            (RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled))
#endif
      {
          /* Replace the CDRX configuration applied earlier with DRX configuration */
          if(RRM_TRUE == rrm_uem_find_and_apply_drx_config(p_rrm_ue_context,
                      &rrc_rrm_ue_reconfig_req.radio_resource_reconfig, 
                      &(p_cell_context->rrm_cell_drx_config_resources)))
          {
              RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                      "Sending DRX Configuration to replace the CDRX configuration applied earlier");
          }
      }
      else
      {
          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "[UE:%d],drx is disabled. Removing CDRX configuration", p_rrm_ue_context->ue_index);

          rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
          rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;

          rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;

          rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.drx_config_type = RRC_DRX_CONFIG_TYPE_REL;

          rrm_fill_mac_main_config_extension_for_l3_ue_reconfig(
                  p_rrm_ue_context,
                  &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                      mac_main_config_extensions));
          fill_erb_setup_resp_time_alignment_timer(
                  &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.time_alignment_timer_dedicated),
                  p_rrm_ue_context);

      }
      p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
          RRM_UE_RECONFIG_PHY_DRX_CONFIG_ROLLBACK_PRESENT;

      reconfig_ue = RRM_TRUE;
  }
  /* Fix for CSR: 00059124 */
  /* SPR 10450 Fix Start */
  else if(NO_DRX_PROFILE != p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index)
  /* SPR 12480 End */
  {
      drx_configuration_changed = rrm_apply_new_drx_configuration( p_rrm_ue_context,
              &rrc_rrm_ue_reconfig_req.radio_resource_reconfig,
              &(p_cell_context->rrm_cell_drx_config_resources)
              );

      if(RRM_TRUE == drx_configuration_changed)
      {
          p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
              RRM_UE_RECONFIG_PHY_DRX_CONFIG_ROLLBACK_PRESENT;

          reconfig_ue = RRM_TRUE;
          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "DRX configuration changed for the UE");
      }
  }
  /* SPR 12480 Start */ 
  else
  {
          RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
		"NO DRX configuration changes being applied");
  }
  /* SPR 12480 End */
  /* SPR 10450 Fix End */
  
  if(reconfig_ue)
  {
      if(RRM_UE_ERB_NULL == p_rrm_ue_context->current_procedure.state)
      {
          ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                  RRM_MODULE_ID,
                  RRC_MODULE_ID,
                  transaction_id,
                  p_rrm_ue_context->cell_index);
          if(RRM_SUCCESS == ret_val)
          {
              /*set the UE sub state*/
              RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_RECONFIG_ONGOING);

          }
          else
          {
              RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                      "Unable to send UE reconfig request to RRC.");
              /* if ue reconfig sending error occures then reset the bitmask */
              p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = 0x00;
              /*SPR 7972 FIX START*/
              ret_val = RRM_FAILURE;
              /*SPR 7972 FIX END*/
          }
      }
      /*send the ue reconfig request to RRC*/
      else
      {
          /*enqueue ue_reconfig*/
          rrm_ue_procedure_queue_t    proc_queue;
          proc_queue.api_id = RRC_RRM_UE_RECONFIG_REQ;
          proc_queue.p_proc_data =
              (rrc_rrm_ue_reconfig_req_t *)rrm_mem_get
              (sizeof(rrc_rrm_ue_reconfig_req_t));
          /*BUG 13332:start*/
          proc_queue.trans_id = transaction_id ;
          /*BUG 13332:end*/

          /*Kshitij_start CID:16298*/
          if(RRM_PNULL == proc_queue.p_proc_data)
          {
              RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                      "rrm_build_and_send_ue_reconfig_req: Mem allocation failed");
              return RRM_FAILURE;
          }
          /* Kshitij_end*/

          RRM_MEMCPY((rrc_rrm_ue_reconfig_req_t*)proc_queue.
                  p_proc_data,&rrc_rrm_ue_reconfig_req,
                  sizeof(rrc_rrm_ue_reconfig_req_t));
          /**Enqueue ue reconfig request */
          /*SPR 18241 START*/
          rrm_ue_mgr_enqueue_req( &proc_queue,p_rrm_ue_context, RRM_FALSE);
          /*SPR 18241 END*/
            /* SPR 15441 start */
            RRM_MEM_FREE(proc_queue.p_proc_data);
            /* SPR 15441 end */

      }
  }
  /*SPR 7972 FIX START*/
  else
  {
      ret_val = RRM_FAILURE;
  }
  /*SPR 7972 FIX END*/
  RRM_UT_TRACE_EXIT();
  return ret_val;
  }

/*csg start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_proximity_ind
 *   input      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   output     : none
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_proximity_ind(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et                        ret_val = RRM_SUCCESS;
    rrc_rrm_proximity_ind_t              rrc_rrm_proximity_ind = {RRM_ZERO};
    rrm_proximity_ind_t                  *p_ue_proc_data = RRM_PNULL;
    S32                      length_read = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if( RRM_SUCCESS == rrm_il_parse_rrc_rrm_proximity_ind(&rrc_rrm_proximity_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_proximity_ind.ue_index;
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_PROXIMITY_IND successfully parsed");

        /*alloacate the memory */
        p_ue_proc_data = ( rrm_proximity_ind_t *)
            rrm_mem_get(sizeof(rrm_proximity_ind_t));
	/*coverity 29581, rel2.0.1, aditya*/
	if(RRM_PNULL != p_ue_proc_data)
	{
        RRM_MEMSET(p_ue_proc_data, 0,sizeof(rrm_proximity_ind_t));
        if( RRM_PNULL == p_ue_proc_data )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                    "[UE:%d],Failed to allocate the proc data for "
                    "RRC_RRM_PROXIMITY_IND", rrc_rrm_proximity_ind.ue_index);

            ret_val = RRM_FAILURE;
        }
        else
        {
            /*store the values of received proximity ind*/
            p_ue_proc_data->bitmask  = rrc_rrm_proximity_ind.presence_bitmask;
            /** store proximity ind type*/
            if(rrc_rrm_proximity_ind.proximity_ind_type == RRC_RRM_ENTERING)
            {
                p_ue_proc_data->proximity_ind_type = RRM_ENTERING;
            }
            else if(rrc_rrm_proximity_ind.proximity_ind_type == RRC_RRM_LEAVING)
            {
                p_ue_proc_data->proximity_ind_type = RRM_LEAVING;
            }
            /** store carrier_Freq EUTRA*/
            if(rrc_rrm_proximity_ind.carrier_Freq.presence_bitmask & RRM_PROXIMITY_ARFCN_VALUE_EUTRA_PRESENT)
            {
                p_ue_proc_data->carrier_Freq.bitmask |= RRM_UE_PROXIMITY_ARFCN_VALUE_EUTRA_PRESENT;
                p_ue_proc_data->carrier_Freq.carrier_freq_eutra = rrc_rrm_proximity_ind.carrier_Freq.carrier_freq_eutra;
            }
            /** store carrier_Freq UTRA*/
            if(rrc_rrm_proximity_ind.carrier_Freq.presence_bitmask & RRM_PROXIMITY_ARFCN_VALUE_UTRA_PRESENT)
            {
                p_ue_proc_data->carrier_Freq.bitmask |= RRM_UE_PROXIMITY_ARFCN_VALUE_UTRA_PRESENT;
                p_ue_proc_data->carrier_Freq.carrier_freq_utra = rrc_rrm_proximity_ind.carrier_Freq.carrier_freq_utra;
            }

            ret_val = RRM_SUCCESS;
            p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;
        }
	}
	else
	{
	      RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
	                            "Memory allocation to p_ue_proc_data failed");
	      ret_val = RRM_FAILURE;
	}
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_PROXIMITY_IND parsing failed");
        ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/***************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_mobility_sib_8_params
*   INPUT       : cell_index, ue_index
*   OUTPUT      : p_mobility_parameters,p_add_mobility_parameters
*   DESCRIPTION:
*       Fills csfb mobility paramters
*
*   RETURNS: NONE
******************************************************************************/
rrm_void_t
rrm_rrc_fill_mobility_sib_8_params(
        rrm_cell_index_t cell_index,
         /*SPR 17777 +-*/
        mobility_parameters_t  *p_mobility_parameters,
        additional_mobility_parameters_t  *p_add_mobility_parameters)
{
    idle_mode_mobility_params_t  *p_idle_mode_mobility_params = RRM_PNULL;
    rrmcm_rmif_mobility_sib_8_params_t  *p_cellm_mobility_sib_8_params = \
                                                                RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_idle_mode_mobility_params = rrm_cellm_get_idle_mode_params(cell_index);

    if(RRM_PNULL != p_idle_mode_mobility_params)
    {
        p_cellm_mobility_sib_8_params = (rrmcm_rmif_mobility_sib_8_params_t *)
            &(p_idle_mode_mobility_params-> \
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params);
    }
   
    if(RRM_PNULL != p_cellm_mobility_sib_8_params)
    {
        p_mobility_parameters->sid = p_cellm_mobility_sib_8_params->sid[RRM_ONE];
        p_mobility_parameters->sid = (p_mobility_parameters->sid << RRM_EIGHT) | \
                                      p_cellm_mobility_sib_8_params->sid[RRM_ZERO];
        p_mobility_parameters->bitmask |= SID_INCLUDED_PRESENT;

        p_mobility_parameters->nid = p_cellm_mobility_sib_8_params->nid[RRM_ONE];
        p_mobility_parameters->nid = (p_mobility_parameters->nid << RRM_EIGHT) | \
                                      p_cellm_mobility_sib_8_params->nid[RRM_ZERO];
        p_mobility_parameters->bitmask |= NID_INCLUDED_PRESENT;

        p_mobility_parameters->multi_sids = p_cellm_mobility_sib_8_params-> \
                                            multiple_sid;
        p_mobility_parameters->bitmask |= MULT_SIDS_INCLUDED_PRESENT;

        p_mobility_parameters->multi_nids = p_cellm_mobility_sib_8_params-> \
                                            multiple_nid;
        p_mobility_parameters->bitmask |= MULT_NIDS_INCLUDED_PRESENT;

        p_mobility_parameters->reg_zone = p_cellm_mobility_sib_8_params->reg_zone[RRM_ONE];
        p_mobility_parameters->reg_zone = (p_mobility_parameters->reg_zone << RRM_EIGHT) | \
                                        p_cellm_mobility_sib_8_params->reg_zone[RRM_ZERO]; 
        p_mobility_parameters->bitmask |= REG_ZONE_INCLUDED_PRESENT;

        p_mobility_parameters->total_zones = p_cellm_mobility_sib_8_params-> \
                                             total_zone[RRM_ZERO];
        p_mobility_parameters->bitmask |= TOTAL_ZONES_INCLUDED_PRESENT;

        p_mobility_parameters->zone_timer = p_cellm_mobility_sib_8_params-> \
                                            zone_timer[RRM_ZERO];
        p_mobility_parameters->bitmask |= ZONE_TIMER_INCLUDED_PRESENT;

        if(p_cellm_mobility_sib_8_params->bitmask &
               RRMCM_RMIF_PACKET_ZONE_ID_INCLUDED_PRESENT)
        {
            p_mobility_parameters->packet_zone_id = \
                p_cellm_mobility_sib_8_params->packet_zone_id;
            p_mobility_parameters->bitmask |= PACKET_ZONE_ID_INCLUDED_PRESENT;
        }

        p_mobility_parameters->home_reg = p_cellm_mobility_sib_8_params-> \
                                              home_reg;
        p_mobility_parameters->bitmask |= HOME_REG_INCLUDED_PRESENT;

        p_mobility_parameters->for_sid_reg = p_cellm_mobility_sib_8_params-> \
                                                 foreign_sid_reg;
        p_mobility_parameters->bitmask |= FOR_SID_REG_INCLUDED_PRESENT;

        p_mobility_parameters->for_nid_reg = p_cellm_mobility_sib_8_params-> \
                                             foreign_nid_reg;
        p_mobility_parameters->bitmask |= FOR_NID_REG_INCLUDED_PRESENT;

        p_mobility_parameters->power_up_reg = p_cellm_mobility_sib_8_params-> \
                                              power_up_reg;
        p_mobility_parameters->bitmask |= POWER_UP_REG_INCLUDED_PRESENT;

        if(p_cellm_mobility_sib_8_params->bitmask &
               RRMCM_RMIF_POWER_DOWN_REG_INCLUDED_PRESENT)
        {
            p_add_mobility_parameters->power_down_reg = p_cellm_mobility_sib_8_params-> \
                                                        power_down_reg;
            p_mobility_parameters->bitmask |= POWER_DOWN_REG_INCLUDED_PRESENT;
        }

        p_add_mobility_parameters->parameter_reg = p_cellm_mobility_sib_8_params-> \
                                                   parame_reg;
        p_mobility_parameters->bitmask |= PARAMETER_REG_INCLUDED_PRESENT;

        p_add_mobility_parameters->reg_prd = p_cellm_mobility_sib_8_params-> \
                                             reg_prd;
        p_mobility_parameters->bitmask |= REG_PRD_INCLUDED_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_pz_hyst_params
*   input       : p_rrcm_pz_hyst_params 
*   output      : p_cellm_pz_hyst_params
*   DESCRIPTION:
*       Fills csfb pz hyst params for mobility req
*
*   RETURNS: NONE
******************************************************************************/
rrm_void_t
rrm_rrc_fill_pz_hyst_params(
        pz_hyst_parameters_included_t  *p_rrcm_pz_hyst_params,
        rrmcm_rmif_pz_hyst_parameters_included_t  *p_cellm_pz_hyst_params
        )
{
    RRM_UT_TRACE_ENTER();

    if(p_cellm_pz_hyst_params->bitmask &
           RRMCM_RMIF_PZ_HYST_ENABLD_PRESENT)
    {
        p_rrcm_pz_hyst_params->pz_hyst_enabled = \
            p_cellm_pz_hyst_params->pz_hyst_enabled;
        p_rrcm_pz_hyst_params->bitmask |= \
            PZ_HYST_ENABLD_PRESENT;
    }
    
    if(p_cellm_pz_hyst_params->bitmask &
           RRMCM_RMIF_PZ_HYST_INFO_INCL_PRESENT)
    {
        p_rrcm_pz_hyst_params->pz_hyst_info_incl = \
            p_cellm_pz_hyst_params->pz_hyst_info_incl;
        p_rrcm_pz_hyst_params->bitmask |= \
            PZ_HYST_INFO_INCL_PRESENT;
    }
    
    if(p_cellm_pz_hyst_params->bitmask &
          RRMCM_RMIF_PZ_HYST_LIST_LEN_PRESENT)
    {
        p_rrcm_pz_hyst_params->pz_hyst_list_len = \
            p_cellm_pz_hyst_params->pz_hyst_list_len;
        p_rrcm_pz_hyst_params->bitmask |= \
            PZ_HYST_LIST_LEN_PRESENT;
    }

    if(p_cellm_pz_hyst_params->bitmask &
           RRMCM_RMIF_PZ_HYST_ACT_TIMER_PRESENT)
    {
        p_rrcm_pz_hyst_params->pz_hyst_act_timer = \
            p_cellm_pz_hyst_params->pz_hyst_act_timer;
        p_rrcm_pz_hyst_params->bitmask |= \
            PZ_HYST_ACT_TIMER_PRESENT;
    }
    
    if(p_cellm_pz_hyst_params->bitmask &
           RRMCM_RMIF_PZ_HYST_TIMER_MUL_PRESENT)
    {
        p_rrcm_pz_hyst_params->pz_hyst_timer_mul = \
            p_cellm_pz_hyst_params->pz_hyst_timer_mul;
        p_rrcm_pz_hyst_params->bitmask |= \
            PZ_HYST_TIMER_MUL_PRESENT;
    }
    
    if(p_cellm_pz_hyst_params->bitmask &
           RRMCM_RMIF_PZ_HYST_TIMER_EXP_PRESENT)
    {
        p_rrcm_pz_hyst_params->pz_hyst_timer_exp = \
            p_cellm_pz_hyst_params->pz_hyst_timer_exp;
        p_rrcm_pz_hyst_params->bitmask |= \
            PZ_HYST_TIMER_EXP_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_fpc_fch_params
*   INPUT       : p_rrcm_fpc_fch_incl
*   OUTPUT      : p_cellm_fpc_fch_incl
*   DESCRIPTION:
*       Fills csfb fpc fch info for mobility req
*
*   RETURNS: NONE
******************************************************************************/
rrm_void_t
rrm_rrc_fill_fpc_fch_params(
        fpc_fch_included_t  *p_rrcm_fpc_fch_incl,
        rrmcm_rmif_fpc_fch_included_t  *p_cellm_fpc_fch_incl)
{
    RRM_UT_TRACE_ENTER();

    if(p_cellm_fpc_fch_incl->bitmask &
           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC3_PRESENT)
    {
        p_rrcm_fpc_fch_incl->fpc_fch_init_setpt_rc3 = \
            p_cellm_fpc_fch_incl->fpc_fch_init_setpt_rc3;
        p_rrcm_fpc_fch_incl->bitmask |= \
            FPC_FCH_INIT_SETPT_RC3_PRESENT;
    }

    if(p_cellm_fpc_fch_incl->bitmask &
           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC4_PRESENT)
    {
        p_rrcm_fpc_fch_incl->fpc_fch_init_setpt_rc4= \
            p_cellm_fpc_fch_incl->fpc_fch_init_setpt_rc4;
        p_rrcm_fpc_fch_incl->bitmask |= \
            FPC_FCH_INIT_SETPT_RC4_PRESENT;
    }

    if(p_cellm_fpc_fch_incl->bitmask &
           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC5_PRESENT)
    {
        p_rrcm_fpc_fch_incl->fpc_fch_init_setpt_rc5 = \
            p_cellm_fpc_fch_incl->fpc_fch_init_setpt_rc5;
        p_rrcm_fpc_fch_incl->bitmask |= \
            FPC_FCH_INIT_SETPT_RC5_PRESENT;
    }
    /* Bug 12675 Fix Start */
    if(p_cellm_fpc_fch_incl->bitmask &
            RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC11_PRESENT)
    {
        p_rrcm_fpc_fch_incl->fpc_fch_init_setpt_rc11 = \
            p_cellm_fpc_fch_incl->fpc_fch_init_setpt_rc11;
        p_rrcm_fpc_fch_incl->bitmask |= \
            FPC_FCH_INIT_SETPT_RC11_PRESENT;

    }

    if(p_cellm_fpc_fch_incl->bitmask &
            RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC12_PRESENT)
    {
        p_rrcm_fpc_fch_incl->fpc_fch_init_setpt_rc12 = \
            p_cellm_fpc_fch_incl->fpc_fch_init_setpt_rc12;
        p_rrcm_fpc_fch_incl->bitmask |= \
            FPC_FCH_INIT_SETPT_RC12_PRESENT;

    }
    /* Bug 12675 Fix Start */

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_cell_specific_info
*   INPUT       : p_rrcm_mobility_parameters,p_rrcm_add_mobility_parameters
*   OUTPUT      : p_cellm_cell_specific_params
*   DESCRIPTION:
*       Fills csfb cell specific info for mobility req
*
*   RETURNS: NONE
******************************************************************************/
rrm_void_t
rrm_rrc_fill_cell_specific_info(
        mobility_parameters_t *p_rrcm_mobility_parameters,
        additional_mobility_parameters_t  *p_rrcm_add_mobility_parameters,
        rrmcm_rmif_cell_specific_params_t  *p_cellm_cell_specific_params
        )
{
    RRM_UT_TRACE_ENTER();

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT)
    {
        rrm_rrc_fill_pz_hyst_params(
            &p_rrcm_mobility_parameters->pz_hyst_parameters_included,
            &p_cellm_cell_specific_params->pz_hyst_parameters_included);
       
        p_rrcm_mobility_parameters->bitmask |= \
            PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT;
    }
    
    if(p_cellm_cell_specific_params->bitmask &
        RRMCM_RMIF_P_REV_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->p_rev = \
            p_cellm_cell_specific_params->p_rev;
        p_rrcm_mobility_parameters->bitmask |= \
            P_REV_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_MIN_P_REV_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->min_p_rev = \
            p_cellm_cell_specific_params->min_p_rev;
        p_rrcm_mobility_parameters->bitmask |= \
            MIN_P_REV_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->neg_slot_cycle_index_sup = \
            p_cellm_cell_specific_params->neg_slot_cycle_index_sup;
        p_rrcm_mobility_parameters->bitmask |= \
            NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_ENCRYPT_MODE_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->encrypt_mode = \
            p_cellm_cell_specific_params->encrypt_mode;
        p_rrcm_mobility_parameters->bitmask |= \
            ENCRYPT_MODE_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_ENC_SUPPORTED_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->enc_supported = \
            p_cellm_cell_specific_params->enc_supported;
        p_rrcm_mobility_parameters->bitmask |= \
            ENC_SUPPORTED_INCLUDED_PRESENT;
    }
    
    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_SIG_ENCRYPT_SUP_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->sig_encrypt_sup = \
            p_cellm_cell_specific_params->sig_encrypt_sup;
        p_rrcm_mobility_parameters->bitmask |= \
            SIG_ENCRYPT_SUP_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_MSG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->msg_integrity_sup = \
            p_cellm_cell_specific_params->msg_integrity_sup;
        p_rrcm_mobility_parameters->bitmask |= \
            MSG_INTEGRITY_SUP_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->sig_integrity_sup_incl = \
            p_cellm_cell_specific_params->sig_integrity_sup_incl;
        p_rrcm_mobility_parameters->bitmask |= \
            SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_SIG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->sig_integrity_sup = \
            p_cellm_cell_specific_params->sig_integrity_sup;
        p_rrcm_mobility_parameters->bitmask |= \
            SIG_INTEGRITY_SUP_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->ms_init_pos_loc_sup_ind = \
            p_cellm_cell_specific_params->ms_init_pos_loc_sup_ind;
        p_rrcm_mobility_parameters->bitmask |= \
            MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_BAND_CLASS_INFO_REQ_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->band_class_info_req = \
            p_cellm_cell_specific_params->band_class_info_req;
        p_rrcm_mobility_parameters->bitmask |= \
            BAND_CLASS_INFO_REQ_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_BAND_CLASS_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->band_class = \
            p_cellm_cell_specific_params->band_class;
        p_rrcm_mobility_parameters->bitmask |= \
            BAND_CLASS_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_ALT_BAND_CLASS_INCLUDED_PRESENT)
    {
        p_rrcm_mobility_parameters->alt_band_class = \
            p_cellm_cell_specific_params->alt_band_class;
        p_rrcm_mobility_parameters->bitmask |= \
            ALT_BAND_CLASS_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_TKZ_MODE_SUPPORTED_INCLUDED_PRESENT)
    {
        p_rrcm_add_mobility_parameters->tkz_mode_supported = \
            p_cellm_cell_specific_params->tkz_mode_supported;
        p_rrcm_add_mobility_parameters->bitmask |= \
            TKZ_MODE_SUPPORTED_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_TKZ_ID_INCLUDED_PRESENT)
    {
        p_rrcm_add_mobility_parameters->tkz_id = \
            p_cellm_cell_specific_params->tkz_id;
        /* Bitmask correction */
        p_rrcm_add_mobility_parameters->bitmask |= \
            TKZ_ID_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_FPC_FCH_INCLUDED_PRESENT)
    {
        rrm_rrc_fill_fpc_fch_params(
            &p_rrcm_add_mobility_parameters->fpc_fch_included,
            &p_cellm_cell_specific_params->fpc_fch_included);
        p_rrcm_add_mobility_parameters->bitmask |= \
            FPC_FCH_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_T_ADD_INCLUDED_PRESENT)
    {
        p_rrcm_add_mobility_parameters->t_add = \
            p_cellm_cell_specific_params->t_add;
        p_rrcm_add_mobility_parameters->bitmask |= \
            T_ADD_INCLUDED_PRESENT;
    }

    if(p_cellm_cell_specific_params->bitmask &
           RRMCM_RMIF_PILOT_INC_INCLUDED_PRESENT)
    {
        p_rrcm_add_mobility_parameters->pilot_inc = \
            p_cellm_cell_specific_params->pilot_inc;
        p_rrcm_add_mobility_parameters->bitmask |= \
            PILOT_INC_INCLUDED_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}
   

/****************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_irat_ncl_cdma2000_params
*   INPUT       : cell_index, ue_index
*   OUTPUT      : p_rrcm_mobility_parameters,p_rrcm_add_mobility_parameters
*   DESCRIPTION:
*       Fills csfb ncl info for mobility req
*
*   RETURNS: none
******************************************************************************/
rrm_void_t
rrm_rrc_fill_irat_ncl_cdma2000_params(
        rrm_cell_index_t cell_index,
         /*SPR 17777 +-*/
        mobility_parameters_t *p_rrcm_mobility_parameters,
        additional_mobility_parameters_t  *p_rrcm_add_mobility_parameters)

{
    U8 valid_cdma2000_freq_cells = RRM_ZERO;
    U8 cdma2000_freq_cells = RRM_ZERO;
    U8 found_associated_cell_match = RRM_FALSE;
    
    inter_rat_ncl_t  *p_cellm_irat_ncl = RRM_PNULL;
    idle_mode_mobility_params_t  *p_cellm_idle_mode_mobility_params = RRM_PNULL;
    rrmcm_rmif_cdma2000_cell_param_t  *p_cellm_cdma2000_cell_param = RRM_PNULL;
    rrmcm_rmif_cdma2000_freq_cells_t *p_cellm_cdma2000_freq_cells = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    p_cellm_idle_mode_mobility_params = rrm_cellm_get_idle_mode_params(cell_index);
    
    p_cellm_cdma2000_cell_param = (rrmcm_rmif_cdma2000_cell_param_t *) \
                                    &(p_cellm_idle_mode_mobility_params-> \
                                        idle_mode_mobility_irat_cdma_params. \
                                            cdma2000_cell_param);


    p_cellm_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(cell_index);
    
    if(RRM_PNULL != p_cellm_irat_ncl)
    {
        p_cellm_cdma2000_freq_cells = (rrmcm_rmif_cdma2000_freq_cells_t *) \
                                       p_cellm_irat_ncl->cdma2000_freq_cells;

	/*KLOC FIX */
    valid_cdma2000_freq_cells = p_cellm_irat_ncl->num_valid_cdma2000_freq_cells;
    
    for(cdma2000_freq_cells = RRM_ZERO;
            cdma2000_freq_cells < valid_cdma2000_freq_cells; 
                cdma2000_freq_cells++)
    {
        if (RRM_OAM_NCL_TYPE_1XRTT == \
                p_cellm_cdma2000_freq_cells[cdma2000_freq_cells].type)
        {
            U32         *p_temp_cdma2000_1xrtt_cell_id = RRM_PNULL;
            U32         *p_temp_cid = RRM_PNULL;
            U16         *p_temp_cdma2000_1xrtt_cell_id_1 = RRM_PNULL;
            U16         *p_temp_cid_1 = RRM_PNULL;
            p_temp_cdma2000_1xrtt_cell_id = (U32 *)p_cellm_cdma2000_cell_param->cell_id_1xrtt.cdma2000_1xrtt_cell_id;
            p_temp_cid = (U32*)p_cellm_cdma2000_freq_cells[cdma2000_freq_cells].CID;
            p_temp_cdma2000_1xrtt_cell_id_1 = (U16 *)p_cellm_cdma2000_cell_param->cell_id_1xrtt.cdma2000_1xrtt_cell_id;
            p_temp_cid_1 = (U16*)p_cellm_cdma2000_freq_cells[cdma2000_freq_cells].CID;
            /* SPR-10397-fix start */
                    /* coverity : CID 63694*/
            if((*(p_temp_cdma2000_1xrtt_cell_id) == (*(p_temp_cid))) &&                               /* It compare the first four bytes. */
                    (*(p_temp_cdma2000_1xrtt_cell_id_1 + RRM_TWO )) == (*(p_temp_cid_1 + RRM_TWO))) /* Then it compare the next two bytes. */
            {
                found_associated_cell_match = RRM_TRUE;
                break;
            }
        }
        else if(RRM_OAM_NCL_TYPE_HRPD == \
                    p_cellm_cdma2000_freq_cells[cdma2000_freq_cells].type)
        {
            U64         *p_temp_cdma2000_hrpd_cell_id = RRM_PNULL;
            U64         *p_temp_cid_2 = RRM_PNULL;
            p_temp_cdma2000_hrpd_cell_id = (U64 *)p_cellm_cdma2000_cell_param->cell_id_hrpd.cdma2000_hrpd_cell_id;
            p_temp_cid_2 = (U64*)p_cellm_cdma2000_freq_cells[cdma2000_freq_cells].CID;
            /* SPR-10397-fix start */
                    /* coverity : CID 63692*/
            if((*(p_temp_cdma2000_hrpd_cell_id)  == *(p_temp_cid_2)) &&                      /* It compare the first eight bytes */
                    ((*(p_temp_cdma2000_hrpd_cell_id + RRM_ONE )) == (*(p_temp_cid_2 + RRM_ONE)))) /* Then it compare the next eight bytes */
            {
                found_associated_cell_match = RRM_TRUE;
                break;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                        "failed to parse RRC_RRM_UE_RECONFIG_RESP ");
        }
    }
   
    if(RRM_TRUE == found_associated_cell_match)
    {
        if(p_cellm_cdma2000_freq_cells[cdma2000_freq_cells]. \
            presence_bitmask &
            RRMCM_RMIF_CELL_SPECIFIC_PARAMS_PRESENCE_FLAG)
        {
            rrm_rrc_fill_cell_specific_info(
                    p_rrcm_mobility_parameters,
                      p_rrcm_add_mobility_parameters,
                        &p_cellm_cdma2000_freq_cells[cdma2000_freq_cells]. \
                          cell_specific_params);
        }
    }
    }
    RRM_UT_TRACE_EXIT();
}


/***************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_ue_generic_cdma2000_params
*   INPUT       : cell_index, ue_index
*   OUTPUT      : p_rrcm_mobility_parameters,p_rrcm_add_mobility_parameters
*   DESCRIPTION:
*       Fills csfb ue generic cdma2000 parameters
*
*   RETURNS: NONE
******************************************************************************/
rrm_void_t
rrm_rrc_fill_ue_generic_cdma2000_params(
        rrm_cell_index_t cell_index,
         /*SPR 17777 +-*/
        mobility_parameters_t *p_rrcm_mobility_parameters,
        additional_mobility_parameters_t  *p_rrcm_add_mobility_parameters)
{
    RRM_UT_TRACE_ENTER();

    rrm_irat_params_t  *p_irat_params = RRM_PNULL;
    rrmc_ue_generic_cdma2000_params_t  *p_cellm_ue_generic_cdma2000_params = RRM_PNULL;

    p_irat_params = rrm_cellm_get_connected_mode_irat_params(cell_index);
 
    if(RRM_PNULL != p_irat_params)
    {
        p_cellm_ue_generic_cdma2000_params = \
            (rrmc_ue_generic_cdma2000_params_t *)&p_irat_params-> \
                                       ue_generic_cdma2000_params;
    }
    
    if(RRM_PNULL != p_cellm_ue_generic_cdma2000_params)
    {
        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_AUTH_INCLUDED_PRESENT)
        {
            p_rrcm_mobility_parameters->auth = \
                p_cellm_ue_generic_cdma2000_params->auth;
            p_rrcm_mobility_parameters->bitmask |= \
                AUTH_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_MAX_NUM_ALT_SO_INCLUDED_PRESENT)
        {
            p_rrcm_mobility_parameters->max_num_alt_so = \
                p_cellm_ue_generic_cdma2000_params->max_num_alt_so;
            p_rrcm_mobility_parameters->bitmask |= \
                MAX_NUM_ALT_SO_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_USE_SYNC_ID_INCLUDED_PRESENT)
        {
            p_rrcm_mobility_parameters->use_sync_id = \
                p_cellm_ue_generic_cdma2000_params->use_sync_id;
            p_rrcm_mobility_parameters->bitmask |= \
                USE_SYNC_ID_INCLUDED_PRESENT;
        }
        
        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_MOB_QOS_INCLUDED_PRESENT)
        {
            p_rrcm_mobility_parameters->mob_qos = \
                p_cellm_ue_generic_cdma2000_params->mob_qos;
            p_rrcm_mobility_parameters->bitmask |= \
                MOB_QOS_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_BYPASS_REG_IND_INCLUDED_PRESENT)
        {
            p_rrcm_mobility_parameters->bypass_reg_ind = \
                p_cellm_ue_generic_cdma2000_params->bypass_reg_ind;
            p_rrcm_mobility_parameters->bitmask |= \
                BYPASS_REG_IND_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT)
        {
            p_rrcm_mobility_parameters->max_add_serv_instance = \
                p_cellm_ue_generic_cdma2000_params->max_add_serv_instance;
            p_rrcm_mobility_parameters->bitmask |= \
                MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_PARAMETER_REG_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->parameter_reg = \
                p_cellm_ue_generic_cdma2000_params->parameter_reg;
            p_rrcm_add_mobility_parameters->bitmask |= \
                PARAMETER_REG_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_REG_DIST_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->reg_dist = \
                p_cellm_ue_generic_cdma2000_params->reg_dist;
            p_rrcm_add_mobility_parameters->bitmask |= \
                REG_DIST_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_PREF_MSID_TYPE_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->pref_msid_type = \
                p_cellm_ue_generic_cdma2000_params->pref_msid_type;
            p_rrcm_add_mobility_parameters->bitmask |= \
                PREF_MSID_TYPE_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_EXT_PREF_MSID_TYPE_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->ext_pref_msid_type = \
                p_cellm_ue_generic_cdma2000_params->ext_pref_msid_type;
            p_rrcm_add_mobility_parameters->bitmask |= \
                EXT_PREF_MSID_TYPE_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_MEID_REQD_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->meid_reqd = \
                p_cellm_ue_generic_cdma2000_params->meid_reqd;
            p_rrcm_add_mobility_parameters->bitmask |= \
                MEID_REQD_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_MCC_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->mcc = \
                p_cellm_ue_generic_cdma2000_params->mcc;
            p_rrcm_add_mobility_parameters->bitmask |= \
                MCC_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_IMSI_11_12_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->imsi_11_12 = \
                p_cellm_ue_generic_cdma2000_params->imsi_11_12;
            p_rrcm_add_mobility_parameters->bitmask |= \
                IMSI_11_12_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_IMSI_T_SUPPORTED_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->imsi_t_supported = \
                p_cellm_ue_generic_cdma2000_params->imsi_t_supported;
            p_rrcm_add_mobility_parameters->bitmask |= \
                IMSI_T_SUPPORTED_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_RECONNECT_MSG_IND_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->reconnect_msg_ind = \
                p_cellm_ue_generic_cdma2000_params->reconnect_msg_ind;
            p_rrcm_add_mobility_parameters->bitmask |= \
                RECONNECT_MSG_IND_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_RER_MODE_SUPPORTED_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->rer_mode_supported = \
                p_cellm_ue_generic_cdma2000_params->rer_mode_supported;
            p_rrcm_add_mobility_parameters->bitmask |= \
                RER_MODE_SUPPORTED_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_PILOT_REPORT_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->pilot_report = \
                p_cellm_ue_generic_cdma2000_params->pilot_report;
            p_rrcm_add_mobility_parameters->bitmask |= \
                PILOT_REPORT_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_SDB_SUPPORTED_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->sdb_supported = \
                p_cellm_ue_generic_cdma2000_params->sdb_supported;
            p_rrcm_add_mobility_parameters->bitmask |= \
                SDB_SUPPORTED_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_AUTO_FCSO_ALLOWED_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->auto_fcso_allowed = \
                p_cellm_ue_generic_cdma2000_params->auto_fcso_allowed;
            p_rrcm_add_mobility_parameters->bitmask |= \
                AUTO_FCSO_ALLOWED_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_SDB_IN_RCNM_IND_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->sdb_in_rcnm_ind = \
                p_cellm_ue_generic_cdma2000_params->sdb_in_rcnm_ind;
            p_rrcm_add_mobility_parameters->bitmask |= \
                SDB_IN_RCNM_IND_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_DAYLT_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->daylt = \
                p_cellm_ue_generic_cdma2000_params->daylt;
            p_rrcm_add_mobility_parameters->bitmask |= \
                DAYLT_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->gcsna_l2_ack_timer = \
                p_cellm_ue_generic_cdma2000_params->gcsna_l2_ack_timer;
            p_rrcm_add_mobility_parameters->bitmask |= \
                GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT;
        }

        if(p_cellm_ue_generic_cdma2000_params->bitmask &
               RRMCM_RMIF_GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT)
        {
            p_rrcm_add_mobility_parameters->gcsna_sequence_context_timer = \
                p_cellm_ue_generic_cdma2000_params->gcsna_sequence_context_timer;
            p_rrcm_add_mobility_parameters->bitmask |= \
                GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT;
        }
        /* Bug 12675 Fix Start */
        if(p_cellm_ue_generic_cdma2000_params->bitmask & RRMCM_RMIF_RAND_INCLUDED_PRESENT)
        {
           p_rrcm_add_mobility_parameters->bitmask |= RAND_INCLUDED_PRESENT; 
        }
        
        if(p_cellm_ue_generic_cdma2000_params->bitmask & RRMCM_RMIF_LTM_OFF_INCLUDED_PRESENT)
        {
          p_rrcm_add_mobility_parameters->bitmask |= LTM_OFF_INCLUDED_PRESENT;
        }    
        /* Bug 12675 Fix Stop */
    }
    RRM_UT_TRACE_EXIT();
}


/***************************************************************************
*   FUNCTION NAME: rrm_rrc_fill_cdma2000_csfb_parmas
*   INPUT       : cell_index, ue_index
*   OUTPUT      : p_rrc_rrm_csfb_params_resp
*   DESCRIPTION:
*       Fills csfb mobility paramters
*
*   RETURNS: NONE
******************************************************************************/
rrm_void_t
rrm_rrc_fill_cdma2000_csfb_mobility_params(
        rrm_cell_index_t cell_index,
         /*SPR 17777 +-*/
        rrc_rrm_csfb_parameters_resp_cdma2000_t  *p_rrc_rrm_csfb_params_resp
        )
{
    mobility_parameters_t       *p_mobility_parameters = RRM_PNULL;
    additional_mobility_parameters_t  *p_add_mobility_parameters = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
  
    p_mobility_parameters = 
        (mobility_parameters_t*)&p_rrc_rrm_csfb_params_resp-> \
                                mobility_parameters;
    
    p_add_mobility_parameters =
        (additional_mobility_parameters_t*)&p_rrc_rrm_csfb_params_resp-> \
            add_mobility_parameters;

    p_mobility_parameters->bitmask = RRM_ZERO;
    p_add_mobility_parameters->bitmask = RRM_ZERO;

    rrm_rrc_fill_mobility_sib_8_params(
                    cell_index,
                    /*SPR 17777 +-*/
                    p_mobility_parameters,
                    p_add_mobility_parameters
                           );

    rrm_rrc_fill_irat_ncl_cdma2000_params(
                          cell_index,
                         /*SPR 17777 +-*/
                          p_mobility_parameters,
                          p_add_mobility_parameters);

    rrm_rrc_fill_ue_generic_cdma2000_params(
                        cell_index,
                        /*SPR 17777 +-*/
                        p_mobility_parameters,
                        p_add_mobility_parameters);

    RRM_UT_TRACE_EXIT();
}

/***************************************************************************
*   FUNCTION NAME: rrm_build_and_send_cdma2000_mob_info_resp
*   INPUT       : cell_index, ue_index, trans_id
*   OUTPUT      : none 
*   DESCRIPTION:
*       Fills and sends cdma2000 mobility info resp
*
*   RETURNS:
*       RRM_SUCCESS  on Success
*       RRM_FAILURE  on Failure
******************************************************************************/
rrm_return_et
rrm_build_and_send_cdma2000_mob_info_resp(
        rrm_cell_index_t cell_index,
        rrm_ue_index_t ue_index,
        U8 trans_id
        )
{
    rrm_return_et   ret_val = RRM_SUCCESS;
    rrc_rrm_csfb_parameters_resp_cdma2000_t  \
        *p_rrc_rrm_csfb_params_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_csfb_params_resp = (rrc_rrm_csfb_parameters_resp_cdma2000_t *)
        rrm_mem_get(sizeof(rrc_rrm_csfb_parameters_resp_cdma2000_t));
    if (RRM_PNULL == p_rrc_rrm_csfb_params_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    p_rrc_rrm_csfb_params_resp->ue_index = ue_index;

    rrm_rrc_fill_cdma2000_csfb_mobility_params(
                 cell_index, 
                /*SPR 17777 +-*/
                 p_rrc_rrm_csfb_params_resp);

    if(RRM_FAILURE == rrm_il_send_rrc_rrm_csfb_parameters_resp_cdma2000(
                         p_rrc_rrm_csfb_params_resp,
                         RRM_MODULE_ID,
                         RRC_MODULE_ID,
                         trans_id,cell_index))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                  "failed to send csfb_parameters_resp_cdma2000 [UE:%d]", \
                     ue_index);
        /* COVERITY : RESOURCE LEAK : CID : 54409 fix start */
        ret_val = RRM_FAILURE;
    }

    /* COVERITY : RESOURCE LEAK : CID : 54409 fix start */
    if( RRM_NULL != p_rrc_rrm_csfb_params_resp )
        RRM_MEM_FREE(p_rrc_rrm_csfb_params_resp);
    /* COVERITY : RESOURCE LEAK : CID : 54409 fix start */


    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_cdma2000_mob_info_req
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_glb_ctxt
 *   OUTPUT     : none
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_rrc_process_cdma2000_mob_info_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_global_context_t *p_rrm_ue_glb_ctxt
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    U8                          cell_index = RRM_ZERO;
    /* Bug 12675 Fix Start */
    rrm_ue_index_t              ue_index = RRM_ZERO;
    /* Bug 12675 Fix Stop */
    U8                          trans_id = p_rrm_ue_glb_ctxt->trans_id;
    S32                         length_read = RRM_ZERO;
    rrc_rrm_csfb_parameters_req_cdma2000_t rrm_csfb_params_cdma2000;

    RRM_UT_TRACE_ENTER();

    if (RRM_FAILURE == rrm_il_parse_rrc_rrm_csfb_parameters_req_cdma2000(
                           &rrm_csfb_params_cdma2000,
                           p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                           data_len,
                           &length_read))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->UEM:RRC_RRM_CSFB_PARAMETERS_REQ_CDMA2000 parsing failed");
        return RRM_FAILURE;
    }
    else
    {
  
        ue_index = rrm_csfb_params_cdma2000.ue_index;
        cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(cell_index, ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->UEM:RRC_RRM_CSFB_PARAMETERS_REQ_CDMA2000 successfully parsed");
        if(RRM_FAILURE == rrm_build_and_send_cdma2000_mob_info_resp(
                              cell_index,
                              ue_index,
                              trans_id))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                "[UE:%d],Failed to send CDMA2000 mob info resp ", \
                    rrm_csfb_params_cdma2000.ue_index);
            return RRM_FAILURE;
        }
    }

    RRM_UT_TRACE_EXIT();
    
    return ret_val;
}


/*csg end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_reconfig_resp
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_reconfig_resp(
				  U8 *p_api_buf,
         /*SPR 17777 +-*/
				  U16 data_len,
				  rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
   					)
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    rrc_rrm_ue_reconfig_resp_t		     rrc_rrm_ue_reconfig_resp = {RRM_ZERO};
    rrm_ue_reconfig_response_t		     *p_ue_proc_data = RRM_PNULL;
    S32					     length_read = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_reconfig_resp(&rrc_rrm_ue_reconfig_resp,
					       p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
					       data_len,
					       &length_read))
    {
        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_reconfig_resp.ue_index;
/*BUG 585, Multisector change start*/
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*BUG 585, Multsector change end*/
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_UE_RECONFIG_RESP:[UE:%d] with response: %d",
                rrc_rrm_ue_reconfig_resp.ue_index, rrc_rrm_ue_reconfig_resp.response);
	
	/*alloacate the memory */
	p_ue_proc_data = ( rrm_ue_reconfig_response_t *) 
	                   rrm_mem_get(sizeof(rrm_ue_reconfig_response_t));

        if( RRM_PNULL == p_ue_proc_data )
	{
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
	    "[UE:%d],Failed to allocate the proc data for "
	    "RRC_RRM_MEAS_CONFIG_RESP", rrc_rrm_ue_reconfig_resp.ue_index);

            ret_val = RRM_FAILURE;
	}
	else
	{
	    p_ue_proc_data->bitmask  = rrc_rrm_ue_reconfig_resp.bitmask;
	    p_ue_proc_data->ue_index = rrc_rrm_ue_reconfig_resp.ue_index;
            p_ue_proc_data->response = rrc_rrm_ue_reconfig_resp.response;
		
            if( rrc_rrm_ue_reconfig_resp.bitmask & 
			  RRM_UE_RECONFIG_RESP_CAUSE_PRESENT )
	    {
                p_ue_proc_data->bitmask |= RRM_UE_RECONFIG_RESP_CAUSE_PRESENT;
                p_ue_proc_data->fail_cause = rrc_rrm_ue_reconfig_resp.fail_cause;
	    }

	    ret_val = RRM_SUCCESS;
	    p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_data;

	}
	
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->UEM:RRC_RRM_UE_RECONFIG_RESP failed to parse");

	    ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}




/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm1
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm1
 *   RETURNS:
 *             none 
*******************************************************************************/
rrm_void_t rrm_fill_tm1( rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,
                         antenna_info_t *p_antenna_info_t,
                         rrm_ue_context_t *p_ue_context)
{
    RRM_UT_TRACE_ENTER();
    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
     /* SPR-16135 END */
    {
        p_phy_config_dedicated->antenna_info_r10.explicit_value.transmission_mode = TRANSMISSION_MODE_TM1;
    }
    else
    {
        p_phy_config_dedicated->antenna_information.antenna_information_explicit_value.
        transmission_mode  = TRANSMISSION_MODE_TM1;
    }
    /* R-10 Changes : End */
    /* SPR 21251 +- */
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm2
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm2
 *   RETURNS    :
 *                 none 
*******************************************************************************/
rrm_void_t rrm_fill_tm2( rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,
                         antenna_info_t *p_antenna_info_t,
                         rrm_ue_context_t *p_ue_context)
{
    RRM_UT_TRACE_ENTER();
    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_phy_config_dedicated->antenna_info_r10.explicit_value.transmission_mode = TRANSMISSION_MODE_TM2;
    }
    else
    {
        p_phy_config_dedicated->antenna_information.antenna_information_explicit_value.
        transmission_mode = TRANSMISSION_MODE_TM2;
    }
    /* R-10 Changes : End */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
         /*SPR 17777 +-*/
    "Transmission mode TM-2 is decided and Assigned;Unused variable p_antenna_info_t=%p",p_antenna_info_t);

    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm3
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm3
 *   RETURNS    :
 *                none 
*******************************************************************************/
rrm_void_t rrm_fill_tm3( rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,
                         antenna_info_t *p_antenna_info,
                         rrm_ue_context_t *p_ue_context )
{
    U8                       index = RRM_ZERO;
    U8                       port = RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE; 
    rrc_antenna_info_dedicated_r10_t *p_rrm_antenna_information_r10 = RRM_PNULL;
    rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information = RRM_PNULL;
    /* Coverity: CID 55859 */
    rrm_ue_category_et       ue_category = UE_CATEGORY_NONE; 
    /* ue category */ /* R-10 Change : Start */
    ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_ue_context);
    /* ue category */ /* R-10 Change : End */ 
     
    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10 = 
                                 &(p_phy_config_dedicated->antenna_info_r10.explicit_value);
 
        p_rrm_antenna_information_r10->transmission_mode = TRANSMISSION_MODE_TM3;
    }
    else
    {
        p_rrm_antenna_information =
                                 &(p_phy_config_dedicated->antenna_information.antenna_information_explicit_value);

        p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM3; 
    }

    RRM_UT_TRACE_ENTER();

    /* CID: 60843 - Start */
    if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!");
    }
    /* CID: 60843 - End */

    if( ANTENNA_PORTS_COUNT_AN2 == port )
    {
        type = RRM_ZERO ;
        cbsr_type = N2_TX_ANTENNA_TM3;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM3; 

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N2_TX_ANTENNA_TM3 is configured");
    }
    else if( ANTENNA_PORTS_COUNT_AN4 == port )
    {
        type = RRM_ONE ;
        cbsr_type = N4_TX_ANTENNA_TM3;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM3;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N4_TX_ANTENNA_TM3 is configured");

    }
    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
   /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;
    }
    else
    {
        p_rrm_antenna_information->codebook_subset_restriction.type = cbsr_type;
    }
    /* R-10 Changes : End */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for(index = RRM_ZERO; index < p_antenna_info->num_cbsr; index ++ )
    {
        if( type == p_antenna_info->cbsr[index].type)
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);

            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;

        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        cbsr_mask = cbsr[ RRM_ZERO ];
        RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));

        /*  4 x N mimo selection */
        if( N4_TX_ANTENNA_TM3  == cbsr_type)//p_rrm_antenna_information->codebook_subset_restriction.type )
        {
            /* If UE Category should be less than 5 then configure 4x2 MIMO,
               else if UE Category greater than or equal to 5 then configure 4x4 MIMO */
            /* 4 x 2 mimo selection */
            if( ue_category < UE_CATEGORY_5 )        
            {
                if( cbsr_mask & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM3_MASK )
                {
                    cbsr[ RRM_ZERO ] = cbsr_mask & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM3_MASK; /* 30 : 0011 0000, 0 , 0, 0, 0, 0 ,0 , 0 */

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Anetnna type is N4_TX_ANTENNA_TM3 but ue category is other than 5"
                    "masking the all bits except first byte with 0x30");
                }
                else
                {
                    cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM3_MASK; /* 30 : 0011 0000, 0 , 0, 0, 0, 0 ,0 , 0 */

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Anetnna type is N4_TX_ANTENNA_TM3 and ue category is other than 5"
                    "After masking the required bits becoming zero, so default 4x2 cbsr 0x30 is set");
                }

            }
            else /* 4 x 4 mimo selection */
            {
                cbsr[ RRM_ZERO ] = cbsr_mask & RRM_N4_TX_UE_CAT_5_CBSR_TM3_MASK; /* F0 : 1111 0000, 0 , 0 , 0 ,0 , 0 , 0 , 0 */

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N4_TX_ANTENNA_TM3 but ue category is 5"
                "masking the all bits except first byte with 0xF0");

                if( RRM_ZERO == cbsr[ RRM_ZERO ])
                {
                    cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_5_CBSR_TM3_MASK;

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Anetnna type is N4_TX_ANTENNA_TM3 and ue category is 5"
                    "Afer masking the cbsr becoming zero, so providing default cbsr : oxF0 for 4 x 4");
                }
            }
        }
        /* 2 x 2 mimo selection */
        else if( N2_TX_ANTENNA_TM3  == cbsr_type)//p_rrm_antenna_information->codebook_subset_restriction.type )
        {
            cbsr[ RRM_ZERO ] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM3_MASK; /* C0 : 1100 0000, 0 , 0, 0, 0, 0 ,0 , 0 */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM3,masking first byte with 0xC0");

            if( RRM_ZERO == cbsr[ RRM_ZERO ] )
            {
                cbsr[ RRM_ZERO ] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM3_MASK;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N2_TX_ANTENNA_TM3,After masking cbsr becoming zero"
                "so provinding defaulr cbsr 0xC0 for 2x2");
            }
        }
    }
    else /* if oam info is not coming */
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM.so intializing the" 
        "cbsr by its default value");

        if( ( N4_TX_ANTENNA_TM3 ==  cbsr_type) )
        {
             /* 4 x 4 mimo selction */
            if( (ue_category >= UE_CATEGORY_5) && (ue_category <= UE_CATEGORY_8) )
            {
                cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_5_CBSR_TM3_MASK ; /* 1111 0000, 0 , 0 ....*/

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                "UE category is 5 and antenna type is N4_TX_ANTENNA_TM3 ,"
                "so 4 most significant bits of cbsr are set");
            }
            else /* 4 x 2 mimo selection */
            {
                cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM3_MASK ; /* 0011 0000, 0 , 0 , 0 ....*/

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                "UE category other than 5 and antenna type is N4_TX_ANTENNA_TM3 ,"
                "so 0x30 bit pattern of first byte of cbsr are set");
            }
        }
        /* 2 x 2 mimo selection */
        else if( N2_TX_ANTENNA_TM3 == cbsr_type)
        {
            cbsr[ RRM_ZERO ] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM3_MASK ; /*    C0 :  1100 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM3"
            "so 2 most significant bits of cbsr are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            "Anetnna type and code book subset restrcition value is not configured");
        } 
    }

    /********************* filling the rrc antenna cbsr and its bitmask**********************/
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;
       
        //Copying One Byte only, as CBSR data is within one byte and composer will fill rest 13 bytes with zero
        RRM_MEMCPY( p_rrm_antenna_information_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_ONE );
    }
    else
    { 
        p_rrm_antenna_information->bitmask |= RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

        /* setting the cbsr value in rrc antenna info api */
        RRM_MEMCPY( p_rrm_antenna_information->codebook_subset_restriction.value, cbsr ,RRM_EIGHT );
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
    "Transmission mode TM-3 is decided and Assigned ");
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm4
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm4
 *   RETURNS    :
 *                 none 
*******************************************************************************/
rrm_void_t rrm_fill_tm4( rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,
                         antenna_info_t                      *p_antenna_info,
                         rrm_ue_context_t                    *p_ue_context )
{
    U8                       index = RRM_ZERO;
    U8                       port = RRM_ZERO;
    U8                       type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    U8                       cbsr_mask = RRM_ZERO; 
    rrc_antenna_info_dedicated_r10_t *p_rrm_antenna_information_r10 = RRM_PNULL;
    rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information = RRM_PNULL;
    /* Coverity: CID 55859 */
    rrm_ue_category_et       ue_category = UE_CATEGORY_NONE;

    /* ue category */ /* R-10 Change : Start */
    ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_ue_context);
    /* ue category */ /* R-10 Change : End */    
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10 = 
                                 &(p_phy_config_dedicated->antenna_info_r10.explicit_value);
 
        p_rrm_antenna_information_r10->transmission_mode = TRANSMISSION_MODE_TM4;
    }
    else
    {
        p_rrm_antenna_information =
                                 &(p_phy_config_dedicated->antenna_information.antenna_information_explicit_value);
 
    p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM4;
    }
    RRM_UT_TRACE_ENTER();

    /* CID: 60844 - Start */
    if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!");
    }
    /* CID: 60844 - End */

    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_TWO ;
        cbsr_type = N2_TX_ANTENNA_TM4;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM4;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N2_TX_ANTENNA_TM4 is configured");

    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_THREE ;
        cbsr_type = N4_TX_ANTENNA_TM4;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM4;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N4_TX_ANTENNA_TM4 is configured");

    }

    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
    /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;
    }
    else
    {
        p_rrm_antenna_information->codebook_subset_restriction.type = cbsr_type;
    }
    /* R-10 Changes : End */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    /* loop for number of cbsr configured from OAM */
    for( index = RRM_ZERO; index < p_antenna_info->num_cbsr; index++ )
    {
        if( type  == p_antenna_info->cbsr[index].type )
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);
            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;
        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        /* 4 x N mimo selection */
        if( N4_TX_ANTENNA_TM4 == cbsr_type ) 
        {
            /* 4 x 2*/ 
            if( ue_category < UE_CATEGORY_5 )
            {
                /* at the time of declaration of cbsr we have intialized it with zero */
                cbsr[RRM_ZERO]  = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES; /* masking first 4 byte  */
                cbsr[RRM_ONE]  =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;
                cbsr[RRM_TWO]   =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;
                cbsr[RRM_THREE] =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N4_TX_ANTENNA_TM4 but ue category is other than 5"
                "masking the 32 most significant bits from byte zero");

                /* here we check if remaing cbsr value are zero */
               if( (( cbsr[RRM_FOUR] & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES ) == RRM_ZERO ) && 
                   (( cbsr[RRM_FIVE] & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES ) == RRM_ZERO ) &&
                   (( cbsr[RRM_SIX]  & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES ) == RRM_ZERO ) &&
                   (( cbsr[RRM_SEVEN] & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES ) == RRM_ZERO ) )
               {
                    cbsr[RRM_FOUR]  = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES;
                    cbsr[RRM_FIVE]  = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES;
                    cbsr[RRM_SIX]   = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES;
                    cbsr[RRM_SEVEN] = RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_LAST_4_BYTES;

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Anetnna type is N4_TX_ANTENNA_TM4 and ue category is other than 5"
                    "After masking cbsr becoming zero, so providing cbsr by its default for 4x2");
               }
            }
            else /* 4 x 4 mimo */
            {
                if( (( cbsr[RRM_ZERO] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
                    (( cbsr[RRM_ONE] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
                    (( cbsr[RRM_TWO] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
                    (( cbsr[RRM_THREE] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
                    (( cbsr[RRM_FOUR] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) && 
                    (( cbsr[RRM_FIVE] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) && 
                    (( cbsr[RRM_SIX]  & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
                    (( cbsr[RRM_SEVEN] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ))
                {
                    RRM_MEMSET(cbsr ,RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK , sizeof(cbsr));

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Anetnna type is N4_TX_ANTENNA_TM4 and ue category is 5"
                    "After masking cbsr becoming zero, so providing cbsr by its default for 4x4");
                }
            }

        }
        /* 2 x 2 mimo selection */
        else if( N2_TX_ANTENNA_TM4 == cbsr_type )
        {
            cbsr_mask = cbsr[RRM_ZERO];

            RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));
            cbsr[RRM_ZERO] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM4_MASK; /* FC : 1111 1100, 0 ,0 , 0 , 0, 0 ,0 , 0*/

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM4 , masking first byte of cbsr with 0xFC");

            if( RRM_ZERO == cbsr[RRM_ZERO] )
            {
                cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM4_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N2_TX_ANTENNA_TM4 ,After masking cbsr becoming zero"
                "so providing default cbsr 0xFC for 2X2");
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM intializing the" 
        "cbsr by its default value");

        if( ( N4_TX_ANTENNA_TM4 == cbsr_type ) )
        {
           /* for antenna 4 at eNB, set all the bits of cbsr when TM-4 */
           for( index = RRM_ZERO; index < RRM_EIGHT ; index++ )
           {
               cbsr[ index ] = RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK; 
           }

           /* 4 x 4 mimo selection */
           if( (ue_category >= UE_CATEGORY_5) && (ue_category <= UE_CATEGORY_8) )   /* For UE Cat: 5, 6, 7, 8 */
           {
                /* not bits are required to mask */
               
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                "UE category is 5 and antenna type is N4_TX_ANTENNA_TM4,"
                "so no bits are required to mask ");
           }
           else /*  4 x 2 mimo selection */
           {
               /* masking the most significant 32 bit of cbsr */
               cbsr[RRM_ZERO]  =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;
               cbsr[ RRM_ONE]  =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;
               cbsr[RRM_TWO]   =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;
               cbsr[RRM_THREE] =  RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM4_MASK_FIRST_4_BYTES;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                "UE category is other than 5 and antenna type is N4_TX_ANTENNA_TM4,"
                "so masking most significant 32 bits of cbsr");

           }
          
        }
        /* 2 x 2 mimo selection */
        else if( N2_TX_ANTENNA_TM4 == cbsr_type )
        {
            cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM4_MASK; /*    1111 1100, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM4"
            "so 6 most significant bits of cbsr bits are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            " Anetnna type and code book subset restrcition value is not configured");
        } 
    }

    /********************* filling the rrc antenna cbsr and its bitmask**********************/
    
    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

        //Copying Eight Byte only, as CBSR data is within one byte and composer will fill rest 6 bytes with zero
        RRM_MEMCPY( p_rrm_antenna_information_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_EIGHT );
    }
    else
    {
        p_rrm_antenna_information->bitmask |= RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

        /* setting the cbsr value in rrc antenna info api */
        RRM_MEMCPY( p_rrm_antenna_information->codebook_subset_restriction.value, cbsr ,RRM_EIGHT );
    }
    /* R-10 Changes : End */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "Transmission mode TM-4 is decided and Assigned ");

    RRM_UT_TRACE_EXIT();
}


/* rrm_fill_tm5 this code leg is written for future use */

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm5
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm5
 *   RETURNS    :
 *                none 
*******************************************************************************/
rrm_void_t rrm_fill_tm5( rrc_phy_physical_config_dedicated_t  *p_phy_config_dedicated,
                         antenna_info_t                       *p_antenna_info,
                         rrm_ue_context_t                     *p_ue_context)
{

    RRM_UT_TRACE_ENTER();
    U8                       index = RRM_ZERO;
    U8                       port= RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       cbsr_found = RRM_FALSE; 
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrc_antenna_info_dedicated_r10_t *p_rrm_antenna_information_r10 = RRM_PNULL;
    rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information = RRM_PNULL;
    /* Coverity: CID 55859 */
    rrm_ue_category_et       ue_category = UE_CATEGORY_NONE;

    /* ue category */ /* R-10 Change : Start */
    ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_ue_context);
    /* ue category */ /* R-10 Change : End */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 START */
    {
        p_rrm_antenna_information_r10 =
                                 &(p_phy_config_dedicated->antenna_info_r10.explicit_value);

        p_rrm_antenna_information_r10->transmission_mode = TRANSMISSION_MODE_TM5;
    }
    else
    {
        p_rrm_antenna_information =
                                 &(p_phy_config_dedicated->antenna_information.antenna_information_explicit_value);

    p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM5;
    }
    /* CID: 60845 - Start */
    if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		"Antenna port count = %d", port);
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
		"rrm_cellm_get_antenna_port returned failure!");
    }
    /* CID: 60845 - End */
    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_FOUR ;
        cbsr_type = N2_TX_ANTENNA_TM5;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM5;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N2_TX_ANTENNA_TM5 is configured");
    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_FIVE ;
        cbsr_type = N4_TX_ANTENNA_TM5;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM5;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N4_TX_ANTENNA_TM5 is configured");
    }

    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
    /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;
    }
    else
    {
        p_rrm_antenna_information->codebook_subset_restriction.type = cbsr_type;
    }
    /* R-10 Changes : End */

    RRM_TRACE( g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for(index = RRM_ZERO; index < p_antenna_info->num_cbsr; index++ )
    {
        if( type  == p_antenna_info->cbsr[index].type ) 
        {
            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);

            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;
        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        /* ue category is not 5 then mask all the bits except 6 most significant bits */
        if( ( ue_category < UE_CATEGORY_5 ) && 
            ( N4_TX_ANTENNA_TM5 == cbsr_type ) )
        {
             cbsr_mask = cbsr [ RRM_ZERO ];
             RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));
            /* at the time of declaration of cbsr we have intialized it with zero */
            cbsr[RRM_ZERO] = cbsr_mask & RRM_N4_TX_UE_CAT_NOT_5_CBSR_TM5_MASK; /* F0 :   1111 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N4_TX_ANTENNA_TM4 but ue category is other than 5"
            "masking the all bits except 6 most significant bits");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM. so intializing the" 
        "cbsr by its default value");

        if( ( (ue_category >= UE_CATEGORY_5) && (ue_category <= UE_CATEGORY_8) ) && 
            ( N4_TX_ANTENNA_TM5 ==  cbsr_type ) )
        {
            /*    1111 1111, 1111 1111, 0 ,0 , 0 , 0, 0 , 0 ,0  */
            cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_5_CBSR_TM5_MASK;
            cbsr[ RRM_ONE ] = RRM_N4_TX_UE_CAT_5_CBSR_TM5_MASK;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is 5 and antenna type is N4_TX_ANTENNA_TM5 ,"
            "so 16 most significant bits are set");
          
        }
        /* other the ue category 5 will fall in this condition */
        else if(  N2_TX_ANTENNA_TM5 == cbsr_type )
        {
            cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM5_MASK ; /*    1111 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM4"
            "so 4 most significant bits of cbsr are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            " Anetnna type and code book subset restrcition value is not configured");
        } 
    }

    /********************* filling the rrc antenna cbsr and its bitmask**********************/
    
    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

        //Copying TWO Byte only, as CBSR data is within atmost 2 bytes and composer will fill rest 12 bytes with zero
        RRM_MEMCPY( p_rrm_antenna_information_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_TWO );
    }
    else
    { 
    /* if proper cbsr type is not sent or cbsr info is not coming from OAM */
    p_rrm_antenna_information->bitmask |= RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    /* setting the cbsr value in rrc antenna info api */
    RRM_MEMCPY( p_rrm_antenna_information->codebook_subset_restriction.value, cbsr ,RRM_EIGHT );
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
    "Transmission mode TM-5 is decided and Assigned ");

    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm8
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm7
 *   RETURNS    :
 *                none
 *******************************************************************************/
rrm_void_t rrm_fill_tm8( rrc_phy_physical_config_dedicated_t  *p_phy_config_dedicated,
                         antenna_info_t                       *p_antenna_info,
                         rrm_ue_context_t                     *p_ue_context )
{

    RRM_UT_TRACE_ENTER();

    U8                       index = RRM_ZERO;
    U8                       port= RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_FOUR] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;
    rrc_antenna_info_dedicated_r10_t *p_rrm_antenna_information_r10 = RRM_PNULL;
    rrc_phy_antenna_info_v920_t   *p_rrm_antenna_info_v920 = RRM_PNULL;
    rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information = RRM_PNULL;
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10 = &(p_phy_config_dedicated->antenna_info_r10.explicit_value);

        p_rrm_antenna_information_r10->transmission_mode = TRANSMISSION_MODE_TM8_V920;
    }
    else
    {
        p_rrm_antenna_information = &(p_phy_config_dedicated->antenna_information.antenna_information_explicit_value);

	p_rrm_antenna_info_v920 = &(p_phy_config_dedicated->antenna_info_v920 ); 

    p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM8_V920;
    }
    /* CID: 60847 - Start */
    if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!");
    }
    /* CID: 60847 - End */
    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_EIGHT;

        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM8;
        cbsr_type = N4_TX_ANTENNA_TM8_R9;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N2_TX_ANTENNA_TM8_R9 is configured");
    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_NINE;

        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM8; 
        cbsr_type = N4_TX_ANTENNA_TM8_R9;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N4_TX_ANTENNA_TM8_R9 is configured");
    }

    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
    /* SPR-16135 END */    
    {
        p_rrm_antenna_information_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;
    }
    else
    {
        p_rrm_antenna_info_v920->codebook_subset_restriction_v920.type = cbsr_type;
    }
    /* R-10 Changes : End */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for(index = RRM_ZERO; index < p_antenna_info->num_cbsr; index++ )
    {
        if( type  == p_antenna_info->cbsr[index].type )
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value ,RRM_FOUR );

            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;
        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        /* 2 x 2 mimo selection */
        if( ( /*N2_TX_ANTENNA_TM8_R9*/ N2_TX_ANTENNA_TM8_R9 == cbsr_type ) )
        {
             cbsr_mask = cbsr[RRM_ZERO];

             RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));
            /* at the time of declaration of cbsr we have intialized it with zero */
            cbsr[RRM_ZERO] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM8_MASK ; /* FC :   1111 1100, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM8_R9 , masking all bits except 6 most significant bits");

            if( RRM_ZERO == cbsr[RRM_ZERO] )
            {
                cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM8_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N2_TX_ANTENNA_TM8_R9 ,After masking cbsr"
                "becoming zero, so providing default 0xFC for 2x2");
            }
        }
        else if( N4_TX_ANTENNA_TM8_R9 == cbsr_type )
        {
            if(((cbsr[RRM_ZERO] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) && 
                ((cbsr[RRM_ONE] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) && 
                ((cbsr[RRM_TWO] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) && 
                ((cbsr[RRM_THREE] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) )
            {
                cbsr[RRM_ZERO] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
                cbsr[RRM_ONE] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
                cbsr[RRM_TWO] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
                cbsr[RRM_THREE] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N4_TX_ANTENNA_TM8_R9 ,After masking cbsr"
                "becoming zero, so providing default 0xFF for 4x2 & 4x4 ");
            }
        }

        /* in case of 4 x 4 and 4 x 2 for TM-8 rrm dont neet to mask any bits*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM intializing the" 
        "cbsr by its default value");

        /* 4 x 2 and 4 x 4 mimo selection */
        if( /*N4_TX_ANTENNA_TM8_R9*/ N4_TX_ANTENNA_TM8_R9  ==  cbsr_type )
        {
            for( index = RRM_ZERO; index < RRM_FOUR ; index++ )
            {
                cbsr[ index ] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
            }

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "Antenna type is N4_TX_ANTENNA_TM8_R9 ,so all 32 most significant bits are set");
          
        }
        /*2 x 2 mimo selection */
        else if( /* N2_TX_ANTENNA_TM8_R9*/ N2_TX_ANTENNA_TM8_R9 == cbsr_type )
        {
            cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM8_MASK ; /*    1111 1100, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM8_R9"
            "so 6 most significant bits of cbsr are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            " Anetnna type and code book subset restrcition value is not configured");
        } 
    }


    /****************************filling antenna info in rrc antenna v920 api for tm-8*****************/
    /* R-10 Changes : Start */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
    {
        p_rrm_antenna_information_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

        //Copying Four Byte only, as CBSR data is within Four byte and composer will fill rest 10 bytes with zero
        RRM_MEMCPY( p_rrm_antenna_information_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_FOUR );
    }
    else
    {
    /* SPR 10619 FIX START */
    /*	p_phy_config_dedicated->bitmask |= RRC_PHY_ANTENNA_INFO_V920_PRESENT;*/
    /* SPR 10619 FIX END */
    /* SPR 19078: CID 101190 Fix Start */
    	if(RRM_PNULL != p_rrm_antenna_info_v920)
    	{
    		p_rrm_antenna_info_v920->bitmask |= RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    		RRM_MEMCPY( p_rrm_antenna_info_v920->codebook_subset_restriction_v920.value ,cbsr ,RRM_FOUR );
    	}
    /* SPR 19078: CID 101190 Fix End */
    }
    /* R-10 Changes : End */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
            "Transmission mode TM-8 is decided and assigned");

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm7
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm7
 *   RETURNS    :
 *                none
 *******************************************************************************/
rrm_void_t rrm_fill_tm7( rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,
                         antenna_info_t                      *p_antenna_info,
                         rrm_ue_context_t                    *p_ue_context)
{

    RRM_UT_TRACE_ENTER();
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        rrc_antenna_info_dedicated_r10_t *p_rrm_antenna_information_r10 =
                                 &(p_phy_config_dedicated->antenna_info_r10.explicit_value);

        p_rrm_antenna_information_r10->transmission_mode = TRANSMISSION_MODE_TM7;
    }
    else
    {
    rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information = 
           &(p_phy_config_dedicated->antenna_information.antenna_information_explicit_value);

    p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM7;
    }
         /*SPR 17777 +-*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, \
            "Transmission mode TM-7 is decided. p_antenna_info[%p]", p_antenna_info);
         /*SPR 17777 +-*/

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_tm6
 *   INPUT      : p_rrm_antenna_information
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills tm6
 *   RETURNS    : 
 *                none 
*******************************************************************************/
rrm_void_t rrm_fill_tm6( rrc_phy_physical_config_dedicated_t *p_phy_config_dedicated,
                         antenna_info_t *p_antenna_info,
                         rrm_ue_context_t *p_ue_context)
{

    RRM_UT_TRACE_ENTER();
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;
    U8                       index = RRM_ZERO;
    U8                       port  = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrc_antenna_info_dedicated_r10_t *p_rrm_antenna_information_r10 = RRM_PNULL;
    rrc_phy_antenna_information_dedicated_t *p_rrm_antenna_information = RRM_PNULL;
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
    /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10 =
                                 &(p_phy_config_dedicated->antenna_info_r10.explicit_value);

        p_rrm_antenna_information_r10->transmission_mode = TRANSMISSION_MODE_TM6;
    }
    else
    {
        p_rrm_antenna_information = 
                     &(p_phy_config_dedicated->antenna_information.antenna_information_explicit_value);

    p_rrm_antenna_information->transmission_mode = TRANSMISSION_MODE_TM6;
    }
    /* CID: 60846 - Start */
    if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		"Antenna port count = %d", port);
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
		"rrm_cellm_get_antenna_port returned failure!");
    }
    /* CID: 60846 - End */
    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_SIX ;
        //p_rrm_antenna_information->codebook_subset_restriction.type = N2_TX_ANTENNA_TM6 ;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM6; 
        cbsr_type = N2_TX_ANTENNA_TM6;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N2_TX_ANTENNA_TM6  is configured");
    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_SEVEN ;
        //p_rrm_antenna_information->codebook_subset_restriction.type = N4_TX_ANTENNA_TM6 ;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM6; 
        cbsr_type = N4_TX_ANTENNA_TM6;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N4_TX_ANTENNA_TM6 is configured");

    }

    /* R-10 Changes : Start */
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
    {
        p_rrm_antenna_information_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;
    }
    else
    {
        p_rrm_antenna_information->codebook_subset_restriction.type = cbsr_type;
    }
    /* R-10 Changes : End */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for( index = RRM_ZERO; index < p_antenna_info->num_cbsr; index ++ )
    {
        if( type == p_antenna_info->cbsr[index].type )
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);
            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;

        }
    }


    if( RRM_TRUE == cbsr_found )
    {
        /* 4 x N */
        if( N4_TX_ANTENNA_TM6 == cbsr_type )
        {

            if( ((cbsr[RRM_ZERO] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK) == RRM_ZERO) &&
                ((cbsr[RRM_ONE] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK) == RRM_ZERO) )
            {
                cbsr[RRM_ZERO] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;
                cbsr[RRM_ONE]  = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N4_TX_ANTENNA_TM6, after masking the all bits"
                "are becoming zero, so providing default cbsr for 4 x N");
            }

            RRM_MEMSET( (cbsr + RRM_TWO) ,RRM_ZERO , RRM_SIX );
        }
        /* 2 x 2 mimo selection masking */
        else if( N2_TX_ANTENNA_TM6 == cbsr_type )
        {
             cbsr_mask = cbsr[RRM_ZERO];

             RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));

            /* at the time of declaration of cbsr we have intialized it with zero */
            cbsr[RRM_ZERO] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM6_MASK ; /*    1111 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM6 masking the all bits except 4 most significant bits");

            if( RRM_ZERO == cbsr[RRM_ZERO] )
            {
                cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM6_MASK;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Anetnna type is N2_TX_ANTENNA_TM6,After masking cbsr becoming zero"
                "so providing default cbsr 0xFC for 2x2");
            }
        }
        /* Tm-6 dont care for masking of cbsr in 4 x 4 and 4 x 2 mimo selection 
           RRM sends same bit pattern which is coming from OAM*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM. so intializing the" 
        "cbsr by its default value");

        /* 4 x 4 and 4 x 2 mimo selection */
        if( N4_TX_ANTENNA_TM6 ==  cbsr_type ) 
        {
            cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;
            cbsr[ RRM_ONE ] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "Antenna type is N4_TX_ANTENNA_TM6 , so 16 most significant cbsr bits are set");
          
        }
        /* 2 x 2 mimo selection */
        else if( N2_TX_ANTENNA_TM6 == cbsr_type )
        {
            cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM6_MASK;  /*    1111 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM6"
            "so 6 most significant bits of cbsr bits are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            " Anetnna type and code book subset restricition value is not configured");
        } 
    }


    /****************filling antenna info in rrc api ********************************/
    /* SPR-16135 START */
    if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
           eutra_radio_capability_info_def.access_stratum_release)
    /* SPR-16135 END */
    {
	p_rrm_antenna_information_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

	RRM_MEMCPY(p_rrm_antenna_information_r10->codebook_subset_restriction_r10.value, cbsr , RRM_EIGHT );
    }
    else
    {
    p_rrm_antenna_information->bitmask |= RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    RRM_MEMCPY(p_rrm_antenna_information->codebook_subset_restriction.value, cbsr , RRM_EIGHT );
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
    "Transmission mode TM-6 is decided and Assigned ");


    RRM_UT_TRACE_EXIT();
}
/*******************************************************************************
 *   FUNCTION NAME: rrm_transmission_mode_packet_delay_and_error_rate_constraint
 *   INPUT      : p_ue_context,qci
 *   OUTPUT     : none
 *   DESCRIPTION: 
 *   RETURNS    : none
********************************************************************************/
rrm_void_t 
rrm_transmission_mode_packet_delay_and_error_rate_constraint
					(const rrm_ue_context_t *p_ue_context,
					 U8    	                 qci,
				         rrm_bool_et            *p_tx_diversity)
{
    U16					packet_delay;       
    U32					error_loss_rate = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    packet_delay = rrm_get_packet_delay_budget(p_ue_context->cell_index,
                                              qci);

    if( packet_delay  <= STANDARD_PACKET_DELAY_LOW_BOUNDARY )
    {
        *p_tx_diversity = RRM_TRUE;

	 RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
	 "QCI's sub constraint Packet Delay [%d] <= Standard Packet Delay[%d] is passed ",
	 packet_delay,STANDARD_PACKET_DELAY_LOW_BOUNDARY );
    }
    else
    {
        error_loss_rate = rrm_get_packet_error_loss_rate(p_ue_context->cell_index,
							 qci);

	if( packet_delay <= STANDARD_PACKET_DELAY_HIGH_BOUNDARY &&
	    error_loss_rate <= STANDARD_PACKET_ERROR_LOSS_RATE )
        {
	    *p_tx_diversity = RRM_TRUE;

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
	    "QCI's sub constraint Packet loss [%d] <= Standard Packet loss [%d] is passed ",
	    error_loss_rate,STANDARD_PACKET_ERROR_LOSS_RATE);
        }
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
	"Packet Delay [%d] and error_loss_rate [%d]",
	packet_delay,error_loss_rate); 
    }
    
}



/*LTE_RRM_TM_SWITCH_END*/
/* Loss-less data transfer changes start */
/*******************************************************************************
 *   FUNCTION NAME: fill_dl_data_fwd_erab_list
 *   INPUT      : p_ue_context
 *   OUTPUT     : p_ho_required
 *   DESCRIPTION: This functions fills the erab_list that requires DL data 
 *                forwarding based on the QCI configurations.
 *   RETURNS    :none 
********************************************************************************/
rrm_void_t fill_dl_data_fwd_erab_list(
		rrm_ue_context_t 		*p_ue_context,
		rrc_rrm_ho_required_t	*p_ho_required
        )
{
      /* coverity id :19455 ,rel 2.0.1 */
	rrc_handover_type_et	ho_type =(rrc_handover_type_et) p_ho_required->ho_type;	
    U16					 	index   = RRM_ZERO;
    U16 				 	item_count = RRM_ZERO;
    U8					 	qci = RRM_ZERO;
	U8						erab_count = RRM_ZERO;
	U8						qci_count = RRM_ZERO;
	rrm_cell_context_t		*p_cell_context = RRM_PNULL;
	
	rrm_sourceenb_to_targetenb_transparent_cotainer_t \
			*p_enb_transparent_container = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

	if((ho_type != HANDOVER_TYPE_INTRA_LTE_S1) && \
			(ho_type != HANDOVER_TYPE_INTRA_LTE_X2) &&
            /* SPR 13958 Fix */ 
            (ho_type != HANDOVER_TYPE_INTER_CELL))
	{
	    /* Bug-10188 Fix: Start */
            p_cell_context = rrm_cellm_get_cell_context(
                                         p_ue_context->cell_index);
        /*CID 65766:start*/
        if (RRM_PNULL != p_cell_context)
        {
	    if((p_cell_context->ho_parameters.utra_rnc_direct_fwd_path_available) && 
               (HANDOVER_TYPE_LTE_TO_UTRAN == ho_type))
	    {
		    /* Inform MME that a direct data forward path is availble for RNC */
		    p_ho_required->bitmask |= \
					      RRC_RRM_UE_HO_ADM_REQ_DIRECT_FORWARD_PATH_AVAILABLE_PRESENT;
		    p_ho_required->direct_fwd_path_available = RRM_FALSE;
	    }
            else
            { 
                /* If utra_rnc_direct_fwd_path_available flag FALSE in rrm.cfg then direct path not present
                   indirect DL Data frwding to be done for UTRA.*/
	            RRM_TRACE(
			g_uem_log_on_off, 
			p_rrm_uem_facility_name, 
			RRM_DETAILED, 
	    	        "Data forwarding is not supported for [%u]", ho_type);
            }
            return;
	    /* Bug-10188 Fix: End */
	}
        /*CID 65766:end*/
	}

    item_count = p_ue_context->drb_configured.num_of_list;

    if (item_count > MAX_ERAB_COUNT)
    {
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, 
	    	"Number of DRB is [%d] which is more than [%d]", item_count, MAX_ERAB_COUNT);
        item_count = MAX_ERAB_COUNT;
    }
	p_enb_transparent_container = &(p_ho_required->source_to_target_container.\
			eNBContainer);
	
    p_cell_context = rrm_cellm_get_cell_context(
                            p_ue_context->cell_index);
    /*CID 65766:start*/
    if (RRM_PNULL != p_cell_context)
    {
        /*qci check for existing erab*/
        for( index = RRM_ZERO ; ( index < item_count ) && 
                ( index < RRM_MAX_NUM_DRB_PER_UE )  ; index++ )
        {
            qci = p_ue_context->drb_configured.erab_item[index].\
                  erab_level_qos_params.qci;
            for(qci_count=RRM_ZERO;qci_count < RRM_MAX_QCI; qci_count++)
            {
                /*BUG_11564_CHANGES_START*/
                if((RRM_TRUE == p_cell_context->epc_info.epc_params.\
                            qos_config_params[qci_count].dl_forwarding_applicability) && \
                        (RRMCM_RMIF_DL_FWDING_PRESENT & p_cell_context->\
                         epc_info.epc_params.qos_config_params[qci_count].bitmask))
                    /*BUG_11564_CHANGES_END*/
                {
                    /* klocwork_27Mar: Start */
                    /* High boundary check added for erab_count so that erab_id does not exceed Max limit */
                    if((qci == p_cell_context->epc_info.epc_params.\
                                qos_config_params[qci_count].qci) && ( erab_count < MAX_ERAB_COUNT ))
                        /* klocwork_27Mar: End */
                    {
                        /* This ERAB needs DL data forwarding */
                        /*KLOC FIX */
                        p_enb_transparent_container->\
                            erab_dl_fwding_list.erab_id[erab_count++] = \
                            p_ue_context->drb_configured.erab_item[index].erab_id;
                        p_ue_context->drb_configured.erab_item[index].dl_fwding = \
                                                                                  RRM_TRUE;
                    }
                }
            }
        }
        if(erab_count)
        {
            p_enb_transparent_container->\
                erab_dl_fwding_list.erab_count = erab_count;
            p_enb_transparent_container->bitmask |= \
                                                    SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_ERAB_DL_FWDING_LIST_PRESENT;
        }
        if(p_cell_context->ho_parameters.s1_direct_fwd_path_available)
        {
            /* Direct Path available */
            /* L3-API says for S1 HO this IE shouldn't be set */
            if(ho_type == HANDOVER_TYPE_INTRA_LTE_S1)
            {
                /*Inform MME that a direct data forward path is availble */
                p_ho_required->bitmask |= \
                                          RRC_RRM_UE_HO_ADM_REQ_DIRECT_FORWARD_PATH_AVAILABLE_PRESENT;
                p_ho_required->direct_fwd_path_available = RRM_FALSE;
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
    }
    /*CID 65766:end*/
    RRM_UT_TRACE_EXIT();
    return;
}
/* Loss-less data transfer changes end */
/*LTE_RRM_CQI_CHANGE_START*/

/*******************************************************************************
 *   FUNCTION NAME: rrm_cqi_information_reconfig_req_r10
 *   INPUT      : p_ue_context,transmission_mode
 *   OUTPUT     : p_cqi_updated_info
 *   DESCRIPTION: 
 *   RETURNS    :
 *                RRM_SUCCESS on Success
 *                RRM_FAILURE on Failure
********************************************************************************/
rrm_return_et
rrm_cqi_information_reconfig_req_r10(const rrm_ue_context_t         *p_ue_context,
				     U8			            transmission_mode, 
				     rrc_cqi_report_config_r10_t    *p_cqi_updated_info_r10)
{

    rrc_rrm_ue_service_profile_t    	*p_ue_service_profile   = RRM_PNULL;
    rrm_return_et			ret_val = RRM_FAILURE;
    U8                      cqi_mode_selected = RRM_DISABLE_CQI_REPORTING;

    RRM_UT_TRACE_ENTER();

    p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_ue_context->cell_index);

    if( RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT &
	 p_ue_service_profile->radio_res_config.physical_config_dedicated.bitmask )
    {
        rrm_select_cqi_mode_for_cell(
                    p_ue_service_profile->radio_res_config.physical_config_dedicated.cqi_reporting.rrm_cqi_reporting_mode_configured,
                    (rrm_ue_context_t*)p_ue_context,
                    &cqi_mode_selected);

#ifndef LTE_EMBMS_SUPPORTED
        if(RRM_DISABLE_CQI_REPORTING != (rrm_cqi_reporting_mode_et)cqi_mode_selected)
#else
        if ((RRM_DISABLE_CQI_REPORTING != (rrm_cqi_reporting_mode_et)cqi_mode_selected) &&
            (RRM_ONE != p_ue_context->ue_mbms_data.is_cqi_disabled))
#endif
        {
            rrm_rrc_ue_fill_cqi_reporting_r10(
                    p_cqi_updated_info_r10,
                    &(p_ue_service_profile->radio_res_config.physical_config_dedicated.cqi_reporting),
                    (rrm_ue_context_t*)p_ue_context,
                    transmission_mode);
            /*back up the cqi information*/
            rrm_backup_cqi_information((rrm_ue_context_t *)p_ue_context);

            /*update the cqi information*/
            rrm_set_cqi_information_for_ue_r10((rrm_ue_context_t *)p_ue_context,
                    p_cqi_updated_info_r10);
        }
        else
        {
            p_cqi_updated_info_r10->bitmask = RRM_ZERO;

            p_cqi_updated_info_r10->nomPDSCH_rs_epre_offset =
                p_ue_service_profile->radio_res_config.
                physical_config_dedicated.
                cqi_reporting.nom_pdsch_rs_epre_offset;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d], CQI rreporting is disabled",
                    p_ue_context->ue_index);
        }
	    ret_val = RRM_SUCCESS; 
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*******************************************************************************
 *   FUNCTION NAME: rrm_cqi_information_reconfig_req
 *   INPUT      : p_ue_context,transmission_mode
 *   OUTPUT     : p_cqi_updated_info
 *   DESCRIPTION: 
 *   RETURNS    :
 *                RRM_SUCCESS on Success
 *                RRM_FAILURE on Failure
********************************************************************************/
rrm_return_et
rrm_cqi_information_reconfig_req(const rrm_ue_context_t     *p_ue_context,
				 U8			     transmission_mode, 
				 rrc_phy_cqi_reporting_t    *p_cqi_updated_info)
{

    rrc_rrm_ue_service_profile_t    	*p_ue_service_profile   = RRM_PNULL;
    rrm_return_et			ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_ue_context->cell_index);

    if( RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT &
	 p_ue_service_profile->radio_res_config.physical_config_dedicated.bitmask )
    {
        if(RRM_DISABLE_CQI_REPORTING !=
                p_ue_service_profile->radio_res_config.
                physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured)
        {
            rrm_rrc_ue_fill_cqi_reporting(
                    p_cqi_updated_info,
                    &(p_ue_service_profile->radio_res_config.physical_config_dedicated.cqi_reporting),
                    (rrm_ue_context_t*)p_ue_context,
                    transmission_mode);
            /*back up the cqi information*/
            rrm_backup_cqi_information((rrm_ue_context_t *)p_ue_context);

            /*update the cqi information*/
            rrm_set_cqi_information_for_ue((rrm_ue_context_t *)p_ue_context,
                    p_cqi_updated_info);
        }
        else
        {
            p_cqi_updated_info->bitmask = RRM_ZERO;

            p_cqi_updated_info->nom_pdsch_rs_epre_offset =
                p_ue_service_profile->radio_res_config.
                physical_config_dedicated.
                cqi_reporting.nom_pdsch_rs_epre_offset;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d], CQI rreporting is disabled",
                    p_ue_context->ue_index);
        }
	    ret_val = RRM_SUCCESS; 
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*LTE_RRM_TM_SWITCH_END*/

/*csg start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_meas_config_req_release
 *   INPUT      : p_ue_context
 *   OUTPUT     : none 
 *   DESCRIPTION:
 *                Builds the meas config request for releasing measurement
 *                cell reporting.
 *   RETURNS    :
 *               rrm_return_et (TRUE/FALSE)
 *****************************************************************************/
rrm_return_et
rrm_build_and_send_meas_config_req_release(
        rrm_ue_context_t                *p_ue_context
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    /* 
    ** Coverity 23151, allocated memory dynamically to avoid causing large stack size
    ** for the function rrm_build_and_send_meas_config_req_release in rel1.3: Aditya.
    */
    rrc_rrm_meas_config_req_t      *p_rrc_rrm_meas_config_req = RRM_PNULL;
    U16                             transaction_id = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*) rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    
    if(RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
	          "Memory allocation failure");
	return RRM_FAILURE;
    }

    transaction_id = rrm_generate_txn_id();



    p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
    
    fill_eutran_meas_config_to_remove_list(&(p_rrc_rrm_meas_config_req->meas_config),
                                             p_ue_context);
    /* COMP_WARN_1_FEB:compilation warning removal */
                                             //p_ue_context->trigger_quantity);


    ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
            RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);

    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],Failed to send Meas "
                 "Config Req for release" ,p_ue_context->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"[UE:%d] ,Successfully sent Meas "
                 "Config Req for release" ,p_ue_context->ue_index);
    }
    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*csg end*/

/* SRS_FREQ_HOPPING_START */
/* SPR_8391_CHANGES_START*/
/******************************************************************************
 *   FUNCTION NAME : rrm_check_for_srs_hopping_enable_disable 
 *   INPUT         : p_rrm_ue_context
 *   OUTPUT        : p_srs_ul_config_dedicated
 *   DESCRIPTION   : This checkes whether a UE is at the CELL center or at Cell
 *                   edge.
 *                   It enbales the SRS hopping for the cell edge users,if not 
 *                   already enabled. 
 *                   It disables the SRS hopping for the cell center users,if not 
 *                   already disabled. 
 *   RETURNS:
 *       RRM_TRUE  : If SRS hopping enable/disable is required. 
 *       RRM_FALSE : If SRS hopping enable/disable is required.  
*******************************************************************************/
/* SPR_8391_CHANGES_START*/
rrm_bool_t
rrm_check_for_srs_hopping_enable_disable
( 
  rrm_ue_context_t *p_rrm_ue_context,
  rrc_phy_sounding_rs_ul_config_dedicated_t *p_srs_ul_config_dedicated
)
{
    RRM_UT_TRACE_ENTER();
    U32 ul_path_loss_for_ue = RRM_ZERO;
    U32 ul_path_loss_threshold_for_ue = RRM_ZERO;
    U16 srs_res_anchor_bfr_ue_reconfig = RRM_ZERO;	
    rrm_cell_context_t  *p_cell_ctxt = RRM_PNULL;
    rrm_bool_t ret_val = RRM_FAILURE;
    
    rrm_bool_et  ue_is_eligible_for_reconf  = RRM_FALSE;
  
    ue_is_eligible_for_reconf =  ((RRM_ZERO == (p_rrm_ue_context->p_ue_mac_report->report_index % RRM_MAX_REPORT_STAT_UE)) ?
                                                   RRM_TRUE : RRM_FALSE) ;

    if(RRM_TRUE == ue_is_eligible_for_reconf)
    {
                            /* + SPR 20078 */
        ul_path_loss_for_ue = p_rrm_ue_context->ue_avg_stats.uplinkPathLossValue; 
                            /* - SPR 20078 */
        p_cell_ctxt = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);

        /*cov_fix_65770_start*/
        if (RRM_PNULL == p_cell_ctxt)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt returned from rrm_cellm_get_cell_context is null");
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /*cov_fix_65770_end*/

        ul_path_loss_threshold_for_ue = p_cell_ctxt->rrm_olpc_config_params.ul_pathloss_threshold;

        p_srs_ul_config_dedicated->bitmask = 0x00;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                "UL Path Loss reported from MAC : [%d]"
                "UL Path Loss THRESHOLD for SRS Hopping : [%d]",
                ul_path_loss_for_ue,ul_path_loss_threshold_for_ue);
        /* UE is on Cell Center	*/

        if( (ul_path_loss_for_ue < ul_path_loss_threshold_for_ue ) &&
                ( RRM_UE_SRS_TYPE_SUBBAND == p_rrm_ue_context->srs_params.srs_res_type))
        {
            /* 
             ** If SRS hopping is Enabled for the UE 
             ** - Disable the SRS hopping  OFF for the UE
             ** - Allocate the wideband SRS resources to UE
             ** - Free the subband SRS resource occupied by UE.
             */
            srs_res_anchor_bfr_ue_reconfig = p_rrm_ue_context->srs_params_last_used.srs_anchor;
            ret_val = rrm_cellm_get_wideband_srs_resources(p_rrm_ue_context->cell_index,&(p_rrm_ue_context->srs_params));

            if(RRM_SUCCESS == ret_val)
            {
                ret_val = rrm_cellm_mark_srs_index_free(p_rrm_ue_context->cell_index,srs_res_anchor_bfr_ue_reconfig);
                if(RRM_SUCCESS == ret_val)
                {
                    /* fill the new SRS configuration for ue_reconfig_req */
                    p_srs_ul_config_dedicated->bitmask |= RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PARAM_PRESENT;
                    fill_ue_reconfig_req_for_srs_configuration(p_rrm_ue_context , 
                            &(p_srs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param));

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                            " SRS transition is done for UE from subband -> wideband   as UE moved from CE -> CC");
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                            " SRS hopping is disabled for UE.");
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        " Unable to reconfig SRS for UE as Wideband resources are not available");
            } 
        }
        else if( (ul_path_loss_for_ue >= ul_path_loss_threshold_for_ue ) &&
                ( RRM_UE_SRS_TYPE_WIDEBAND == p_rrm_ue_context->srs_params.srs_res_type))
        {
            /* 
             ** If SRS hopping is Disabled for the UE 
             ** - Enable the SRS hopping for the UE
             ** - Allocate the subband SRS resources to UE
             ** - Free the wideband SRS resource occupied by UE.
             */
            srs_res_anchor_bfr_ue_reconfig = p_rrm_ue_context->srs_params_last_used.srs_anchor;
            ret_val = rrm_cellm_get_subband_srs_resources(p_rrm_ue_context->cell_index,&(p_rrm_ue_context->srs_params));

            if(RRM_SUCCESS == ret_val)
            {
                ret_val = rrm_cellm_mark_srs_index_free(p_rrm_ue_context->cell_index,srs_res_anchor_bfr_ue_reconfig);
                if(RRM_SUCCESS == ret_val)
                {
                    /* fill the new SRS configuration for ue_reconfig_req */
                    p_srs_ul_config_dedicated->bitmask |= RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PARAM_PRESENT;
                    fill_ue_reconfig_req_for_srs_configuration(p_rrm_ue_context , 
                            &(p_srs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param));

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                            " SRS transition is done for UE from wideband->subband  as UE moved from CC -> CE");
                    if(p_rrm_ue_context->srs_params.srs_bandwidth != p_rrm_ue_context->srs_params.srs_hopping_bandwidth)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                                " SRS hopping is enabled for UE ");
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                                " SRS hopping is disabled for UE ");
                    }
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                        " Unable to reconfig SRS for UE as Subband resources are not available");
            }

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "Proper SRS resource type [%d] i.e [%s] is allocated. No reconfiguration is required",
                    p_rrm_ue_context->srs_params.srs_res_type, 
                    ( (RRM_UE_SRS_TYPE_WIDEBAND ==  p_rrm_ue_context->srs_params.srs_res_type)? "WIDEBAND":"SUBBAND"));
        }
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR_8391_CHANGES_END*/

/******************************************************************************
*   FUNCTION NAME : fill_ue_reconfig_req_for_srs_configuration 
*   INPUT         : p_rrm_ue_context
*   OUTPUT        : p_ue_srs_params
*   DESCRIPTION   : This function fills reconfig request of ue for srs configuration
*   RETURNS       : none  
*******************************************************************************/

rrm_void_t
fill_ue_reconfig_req_for_srs_configuration
(
   rrm_ue_context_t *p_rrm_ue_context , 
   rrc_phy_sounding_rs_ul_config_dedicated_param_t *p_ue_srs_params 
)
{
   RRM_UT_TRACE_ENTER();

  p_ue_srs_params->srs_bandwidth = p_rrm_ue_context->srs_params.srs_bandwidth;
  p_ue_srs_params->srs_hopping_bandwidth = p_rrm_ue_context->srs_params.srs_hopping_bandwidth;
  p_ue_srs_params->frequency_domain_position = p_rrm_ue_context->srs_params.frequency_domain_position;
  p_ue_srs_params->duration = p_rrm_ue_context->srs_params.duration;
  p_ue_srs_params->srs_configuration_index = p_rrm_ue_context->srs_params.srs_configuration_index;
  p_ue_srs_params->transmission_comb = p_rrm_ue_context->srs_params.transmission_comb;
  p_ue_srs_params->cyclic_shift = p_rrm_ue_context->srs_params.cyclic_shift;
 
   RRM_UT_TRACE_EXIT();
}

/* SRS_FREQ_HOPPING_END */
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_build_ecid_meas_response
 * Inputs         : p_ue_context
 : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Fill and send the ECID Meas response
 ****************************************************************************/
rrm_return_et
rrm_build_ecid_meas_response(rrm_ue_context_t                      *p_ue_context,
                             U32                                   esmlc_meas_id,
                             s1ap_rrm_lppa_ecid_meas_init_resp_t   *p_lppa_ecid_meas_init_resp)
{
    rrm_return_et                          ret_val = RRM_SUCCESS;
    U16                                    transaction_id = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(!(p_ue_context->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD) &&
            !(p_ue_context->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD))
    {
        /* coverity : CID 54427*/
        p_lppa_ecid_meas_init_resp->bitmask |=  LPPA_MEAS_INIT_RESP_ECID_MEAS_RESULT_PRESENT;
        rrm_fill_eutran_access_point(p_ue_context->cell_index,&(p_lppa_ecid_meas_init_resp->e_cid_meas_result));
        ret_val = rrm_fill_serv_cell_ecid_info(p_ue_context->cell_index,&p_lppa_ecid_meas_init_resp->e_cid_meas_result);
    }
    if(RRM_SUCCESS == ret_val )
    {
        transaction_id = rrm_generate_txn_id();
        ret_val = rrm_il_send_s1ap_rrm_lppa_ecid_meas_init_resp(p_lppa_ecid_meas_init_resp,
                RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,p_ue_context->cell_index );
        if(ret_val == RRM_FAILURE)
        {
            /*+- coverity 94024*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "[UE:%d] Failed to send LPPA ECID[%d] meas RESP",
                    p_ue_context->ue_index,p_ue_context->p_ue_positioing_data[esmlc_meas_id].e_smlc_ue_meas_id);
        }               
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                    "[UE:%d]sent LPPA ECID[%d] meas RESP",
                    p_ue_context->ue_index,p_ue_context->p_ue_positioing_data[esmlc_meas_id].e_smlc_ue_meas_id);
        }
    }
    else
    {
        /*+- coverity 94024*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "Failed to fill the LPPA ECID MEAS[%d] RESP Message for the [UE:%d]",
                p_ue_context->p_ue_positioing_data[esmlc_meas_id].e_smlc_ue_meas_id, p_ue_context->ue_index);
        ret_val=RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/* UE Positioing code changes start */
/****************************************************************************
 * Function Name  : rrm_build_and_send_ecid_meas_response
 * Inputs         : p_ue_context
                  : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Fill and send the ECID Meas response 
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_ecid_meas_response 
(
rrm_ue_context_t   *p_ue_context,
U32                esmlc_meas_id
)
{
    s1ap_rrm_lppa_ecid_meas_init_resp_t   *p_lppa_ecid_meas_init_resp = RRM_PNULL;
    rrm_return_et                          ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    
    if((RRM_PNULL  != p_ue_context) &&
       (esmlc_meas_id < RRM_MAX_ESMLC_MEAS_ID))
    {
        p_lppa_ecid_meas_init_resp = (s1ap_rrm_lppa_ecid_meas_init_resp_t *) 
                                      rrm_mem_get(sizeof(s1ap_rrm_lppa_ecid_meas_init_resp_t))  ;
        if(RRM_PNULL == p_lppa_ecid_meas_init_resp)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory for [UE:%u] ESMLC MEAS[%u] ",
                                        p_ue_context->ue_index,esmlc_meas_id);
            return RRM_FAILURE;
        }
        /*Cov_fix_start_54427*/
        RRM_MEMSET(p_lppa_ecid_meas_init_resp,RRM_NULL,sizeof(s1ap_rrm_lppa_ecid_meas_init_resp_t));
        p_lppa_ecid_meas_init_resp->bitmask = RRM_ZERO;
        /*Cov_fix_end_54427*/
        p_lppa_ecid_meas_init_resp->mme_id                 = p_ue_context->p_ue_positioing_data[esmlc_meas_id].mme_id;
        p_lppa_ecid_meas_init_resp->ue_index               = p_ue_context->ue_index;
        p_lppa_ecid_meas_init_resp->routing_id             = p_ue_context->p_ue_positioing_data[esmlc_meas_id].routing_id;
        p_lppa_ecid_meas_init_resp->lppa_trans_id          = p_ue_context->p_ue_positioing_data[esmlc_meas_id].lppa_trans_id;
        p_lppa_ecid_meas_init_resp->e_smlc_ue_meas_id      = p_ue_context->p_ue_positioing_data[esmlc_meas_id].e_smlc_ue_meas_id;
        p_lppa_ecid_meas_init_resp->enb_ue_meas_id         = p_ue_context->p_ue_positioing_data[esmlc_meas_id].enb_ue_meas_id;
        /*Klockwork_fix_start*/
        /*Cov_fix_start_54427*/
        ret_val = rrm_build_ecid_meas_response(p_ue_context ,esmlc_meas_id ,
                                      p_lppa_ecid_meas_init_resp);
        /*Klockwork_fix_end*/
        RRM_MEM_FREE( p_lppa_ecid_meas_init_resp );
        
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Either p_ue_context is NULL or esmlc_meas_id[%u] >= 15 "
                      ,esmlc_meas_id);
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_build_and_send_ecid_meas_failure
 * Inputs         : p_ue_context
                  : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Fill and send the ECID Meas Failure 
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_ecid_meas_failure (
    rrm_ue_index_t ue_index,
    rrm_cell_index_t cell_index,
    U8 mme_id,
    U8 routing_id,
    U32 lppa_trans_id,
    U32 e_smlc_meas_id,
    rrm_cause_t cause)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    s1ap_rrm_lppa_ecid_meas_init_fail_t *p_s1ap_rrm_lppa_ecid_meas_init_fail = RRM_NULL;
    U16                             transaction_id = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    
    p_s1ap_rrm_lppa_ecid_meas_init_fail = (s1ap_rrm_lppa_ecid_meas_init_fail_t*)
                                rrm_mem_get(sizeof(s1ap_rrm_lppa_ecid_meas_init_fail_t));
    if (RRM_NULL == p_s1ap_rrm_lppa_ecid_meas_init_fail)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Failed to allocate the "
                 "[UE:%d] proc data for S1AP_RRM_LPPA_ECID_MEAS_INIT_FAIL",ue_index);
        return RRM_FAILURE;
    }

    transaction_id = rrm_generate_txn_id();

    /* Filling ecid meas init fail params */
    p_s1ap_rrm_lppa_ecid_meas_init_fail->mme_id = mme_id;
    p_s1ap_rrm_lppa_ecid_meas_init_fail->ue_index = ue_index;
    p_s1ap_rrm_lppa_ecid_meas_init_fail->routing_id = routing_id;
    p_s1ap_rrm_lppa_ecid_meas_init_fail->lppa_trans_id = lppa_trans_id;
    p_s1ap_rrm_lppa_ecid_meas_init_fail->e_smlc_ue_meas_id = e_smlc_meas_id;
    p_s1ap_rrm_lppa_ecid_meas_init_fail->cause.type = cause.type;
    p_s1ap_rrm_lppa_ecid_meas_init_fail->cause.value = cause.value;
    
    ret_val = rrm_il_send_s1ap_rrm_lppa_ecid_meas_init_fail(p_s1ap_rrm_lppa_ecid_meas_init_fail,
                    RRM_MODULE_ID,RRC_MODULE_ID,transaction_id,cell_index);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
            "[UE:%d], Failed to send S1AP_RRM_LPPA_ECID_MEAS_INIT_FAIL" ,ue_index); 
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
            "[UE:%d], Successfully send S1AP_RRM_LPPA_ECID_MEAS_INIT_FAIL" ,ue_index);
    }
    
    RRM_MEM_FREE(p_s1ap_rrm_lppa_ecid_meas_init_fail);
    RRM_UT_TRACE_EXIT();

    return ret_val;

}


/****************************************************************************
 * Function Name  : rrm_build_and_send_ecid_meas_failure_indication
 * Inputs         : p_ue_context
                  : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Fill and send the ECID Meas Failure indication
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_ecid_meas_failure_indication (
    rrm_ue_index_t ue_index,
    rrm_cell_index_t cell_index,
    U8 mme_id,
    U8 routing_id,
    U32 lppa_trans_id,
    U32 e_smlc_meas_id,
    U32 enb_ue_meas_id,
    rrm_cause_t cause)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    s1ap_rrm_lppa_ecid_meas_fail_ind_t *p_s1ap_rrm_lppa_ecid_meas_fail_ind = RRM_NULL;
    U16                             transaction_id = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    
    p_s1ap_rrm_lppa_ecid_meas_fail_ind = (s1ap_rrm_lppa_ecid_meas_fail_ind_t*)
                                rrm_mem_get(sizeof(s1ap_rrm_lppa_ecid_meas_fail_ind_t));
    if (RRM_NULL == p_s1ap_rrm_lppa_ecid_meas_fail_ind)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Failed to allocate the "
                 "[UE:%d] proc data for S1AP_RRM_LPPA_ECID_MEAS_FAIL_IND",ue_index);
        return RRM_FAILURE;
    }

    transaction_id = rrm_generate_txn_id();

    /* Filling ecid meas init fail params */
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->mme_id = mme_id;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->ue_index = ue_index;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->routing_id = routing_id;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->lppa_trans_id = lppa_trans_id;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->e_smlc_ue_meas_id = e_smlc_meas_id;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->enb_ue_meas_id = enb_ue_meas_id;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->cause.type = cause.type;
    p_s1ap_rrm_lppa_ecid_meas_fail_ind->cause.value = cause.value;
    
    ret_val = rrm_il_send_s1ap_rrm_lppa_ecid_meas_fail_ind (p_s1ap_rrm_lppa_ecid_meas_fail_ind,
                    RRM_MODULE_ID,RRC_MODULE_ID, transaction_id,cell_index);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
            "[UE:%d], Failed to send S1AP_RRM_LPPA_ECID_MEAS_FAIL_IND" ,ue_index); 
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
            "[UE:%d], Successfully send S1AP_RRM_LPPA_ECID_MEAS_FAIL_IND" ,ue_index);
    }
    
    RRM_MEM_FREE(p_s1ap_rrm_lppa_ecid_meas_fail_ind);
    RRM_UT_TRACE_EXIT();
    
    return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_build_and_send_ecid_meas_error_req
 * Inputs         : p_ue_context
                  : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Fill and send the ECID Meas error
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_ecid_meas_error_req (
    rrm_ue_index_t ue_index,
    rrm_cell_index_t cell_index,
    U8 mme_id,
    U8 routing_id,
    U32 lppa_trans_id,
    rrm_cause_t cause,
    lppa_criticality_diagno_t  criticality_diagnostics)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    s1ap_rrm_lppa_error_ind_req_t *p_s1ap_rrm_lppa_error_ind_req = RRM_NULL;
    U16                             transaction_id = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_s1ap_rrm_lppa_error_ind_req = (s1ap_rrm_lppa_error_ind_req_t*)
        rrm_mem_get(sizeof(s1ap_rrm_lppa_error_ind_req_t));
    if (RRM_NULL == p_s1ap_rrm_lppa_error_ind_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Failed to allocate the "
                "[UE:%d] proc data for S1AP_RRM_LPPA_ERROR_IND_REQ",ue_index);
        return RRM_FAILURE;
    }

    /*coverity_54426 ++*/
    RRM_MEMSET(p_s1ap_rrm_lppa_error_ind_req,RRM_NULL,sizeof(s1ap_rrm_lppa_error_ind_req_t));
    /*coverity_54426 --*/

    transaction_id = rrm_generate_txn_id();

    /* Filling ecid meas init fail params */
    p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.bitmask = RRM_ZERO;
    p_s1ap_rrm_lppa_error_ind_req->mme_id = mme_id;
    /* coverity : CID 54426 */
    p_s1ap_rrm_lppa_error_ind_req->bitmask = RRM_ZERO;
    p_s1ap_rrm_lppa_error_ind_req->bitmask |= LPPA_ERROR_IND_UE_INDEX_PRESENT;
    p_s1ap_rrm_lppa_error_ind_req->ue_index = ue_index;
    p_s1ap_rrm_lppa_error_ind_req->routing_id = routing_id;
    p_s1ap_rrm_lppa_error_ind_req->lppa_trans_id = lppa_trans_id;
    p_s1ap_rrm_lppa_error_ind_req->cause.type = cause.type;
    p_s1ap_rrm_lppa_error_ind_req->cause.value = cause.value;
    if (RRM_LPPA_CRIT_DIAGNO_PROCEDURE_CODE_PRESENT & criticality_diagnostics.bitmask)
    {
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.bitmask |= LPPA_CRIT_DIAGNO_PROCEDURE_CODE_PRESENT; 
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.procedure_code 
                            = criticality_diagnostics.procedure_code;
    }
    if (RRM_LPPA_CRIT_DIAGNO_TRIGERRING_MSG_PRESENT & criticality_diagnostics.bitmask)
    {
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.bitmask |= LPPA_CRIT_DIAGNO_TRIGERRING_MSG_PRESENT; 
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.triggering_msg 
                            = criticality_diagnostics.triggering_msg;
    }
    if (RRM_LPPA_CRIT_DIAGNO_PROC_CRITICALITY_PRESENT & criticality_diagnostics.bitmask)
    {
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.bitmask |= LPPA_CRIT_DIAGNO_PROC_CRITICALITY_PRESENT; 
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.proc_critic 
                            = criticality_diagnostics.proc_critic;
    }
    if (RRM_LPPA_CRIT_DIAGNO_TRANS_ID_PRESENT & criticality_diagnostics.bitmask)
    {
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.bitmask |= LPPA_CRIT_DIAGNO_TRANS_ID_PRESENT; 
        p_s1ap_rrm_lppa_error_ind_req->criticality_diagnostics.lppa_trans_id 
                            = criticality_diagnostics.lppa_trans_id;
    }

    ret_val = rrm_il_send_s1ap_rrm_lppa_error_ind_req (p_s1ap_rrm_lppa_error_ind_req,
            RRM_MODULE_ID,RRC_MODULE_ID, transaction_id,cell_index);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d], Failed to send S1AP_RRM_LPPA_ERROR_IND_REQ" ,ue_index); 
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "[UE:%d], Successfully send S1AP_RRM_LPPA_ERROR_IND_REQ" ,ue_index);
    }

    RRM_MEM_FREE(p_s1ap_rrm_lppa_error_ind_req);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*klock_works_changes_start*/
rrm_return_et
check_and_send_meas_config_req(
    rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req, 
    U8                         *meas_object_id, 
    rrm_ue_context_t           *p_ue_context, 
    U32                         esmlc_meas_id, 
    rrm_lppa_meas_peridicity_et report_interval, 
    U32                         report_type,                
    U8                          report_config_trigger_qty_bitmask, 
    rrm_bool_et                 is_req_for_rach_info,
    U16                         transaction_id
    )
{   
    
    rrm_return_et      ret_val = RRM_FAILURE;
    rrm_meas_config_t               *p_meas_config     = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    if(*meas_object_id <= MAX_MEAS_OBJECT_ID)
            {
                p_meas_config   =  &(p_rrc_rrm_meas_config_req->meas_config);

                /* Fill serving Cell frequency on same meas_object sent in erb_setup */
        ret_val = rrm_fill_meas_config_req_for_ue_positioning(p_meas_config,*meas_object_id,p_ue_context,
                                                                      esmlc_meas_id,report_interval,report_type,
                                                                      report_config_trigger_qty_bitmask,
                                                                      is_req_for_rach_info);
                 if(ret_val == RRM_SUCCESS)
                 {
                    ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
                    if(ret_val == RRM_FAILURE)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to send MEAS CONFIG REQUEST for [UE:%d]",
                                p_ue_context->ue_index);
                        /* Reset the ue_meas_config_req_required if failing to send the ue_meas_config_req */
                        /*
                        p_ue_context->ue_positioing_data[esmlc_meas_id].ue_meas_config_req_required = RRM_FALSE;
                        rrm_uem_deallocate_meas_user_id_for_ue_positioing(p_ue_context,
                                                            p_ue_context->ue_positioing_data[esmlc_meas_id].meas_id,
                                                            p_ue_context->ue_positioing_data[esmlc_meas_id].report_config_id);
                        */
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Successfully sent MEAS CONFIG REQUEST for [UE:%d]",
                                p_ue_context->ue_index);
                    }
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                          "Invalid meas_object_id[%d] found for INTRA_FREQ for [UE:%d]",
                *meas_object_id,
                           p_ue_context->ue_index);
            }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_meas_config_req_for_ue_positioning
 *   INPUT      : p_ue_context,report_interval,report_type,esmlc_meas_id
 *   OUTPUT     : none
 *   DESCRIPTION:
 *               Builds the meas config request and sends to RRC for UE Positioing.  
 *   RETURNS    :
 *                rrm_return_et (TRUE/FALSE)
 *****************************************************************************/
rrm_return_et
rrm_build_and_send_meas_config_req_for_ue_positioning(
	rrm_ue_context_t                *p_ue_context,
    U32                              esmlc_meas_id,
    rrm_lppa_meas_peridicity_et      report_interval,
    U32                              report_type,
    U8                               report_config_trigger_qty_bitmask,
    rrm_bool_et                      is_req_for_rach_info
    )
{
    rrm_return_et                   ret_val = RRM_FAILURE;
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRM_PNULL;
    rrm_cell_context_t             *p_cell_context     = RRM_PNULL;
    U16                             transaction_id     = RRM_NULL; /*RRM_MEAS Changes */
    U8                              meas_object_id     = MAX_MEAS_OBJECT_ID + RRM_ONE;
    /* SPR 21768 Fix Start */
    U16                             tbl_size = RRM_ZERO;
    /* SPR 21768 Fix End */


    RRM_UT_TRACE_ENTER();

    if((p_ue_context != RRM_PNULL) &&
            (esmlc_meas_id <RRM_MAX_ESMLC_MEAS_ID))
    {
	    /* SPR 21768 Fix Start */ 
	    if (RRM_PNULL == p_ue_context->p_ue_positioing_data)
	    {
		    tbl_size = sizeof(rrm_ue_positioing_data) * RRM_MAX_ESMLC_MEAS_ID;
		    p_ue_context->p_ue_positioing_data = (rrm_ue_positioing_data*)rrm_mem_get(tbl_size);
		    if (RRM_PNULL == p_ue_context->p_ue_positioing_data)
		    {
			    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					    "Failed to allocate memory for p_ue_positioing_data");
			    RRM_UT_TRACE_EXIT();
			    return RRM_FAILURE;
		    }
		    RRM_MEMSET(p_ue_context->p_ue_positioing_data, RRM_ZERO, tbl_size);
	    }
	    /* SPR 21768 Fix End */ 

        if((RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT & p_ue_context->ue_capability_params.bitmask) &&
                /*Start:Bug 762*/
                (RRM_TRUE == rrm_is_set_fgi_bit(p_ue_context,RRM_SIXTEEN)))
            /*End:Bug 762*/
        {
            p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
                rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));

            p_cell_context = rrm_cellm_get_cell_context(
                    p_ue_context->cell_index);                

            /*cov_fix_65769_start*/
            if (RRM_PNULL == p_rrc_rrm_meas_config_req || (RRM_PNULL == p_cell_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory either p_rrc_rrm_meas_config_req or p_cell_context ");
                /*CID 66687:start*/
                if (RRM_PNULL != p_rrc_rrm_meas_config_req)
                {
                    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
                }
                /*CID 66687:end*/
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
            /*cov_fix_65769_end*/
            /* BLR Meas Changes Start */
            transaction_id = rrm_generate_txn_id(); /*RRM_MEAS Changes */

            /* BLR Meas Changes End */

            RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL, 
                    sizeof(rrc_rrm_meas_config_req_t));

            p_rrc_rrm_meas_config_req->ue_index= p_ue_context->ue_index;
            rrm_search_ho_meas_object(p_ue_context, p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn, &meas_object_id);
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "For UE positioning intra freq = %d HO created Meas object id = %d", 
					p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn, meas_object_id);
            /*klock_works_changes_start*/ 
            ret_val = check_and_send_meas_config_req(p_rrc_rrm_meas_config_req, &meas_object_id, p_ue_context, esmlc_meas_id, report_interval, report_type, report_config_trigger_qty_bitmask, is_req_for_rach_info, transaction_id); 
            /*klock_works_changes_end*/
            /*SPR 16656 START*/
            if(ret_val!= RRM_FAILURE)
            p_ue_context->current_procedure.state=RRM_UE_MEAS_CONFIG_REQ_ONGOING;
            /*SPR 16656 END*/
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);

        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_ue_context  is NULL");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* UE Positioning code changes end */
/*  DYNAMIC ICIC CHANGES START  */
/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_reconfig_req_icic_action
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION: This function build and send ue reconfig request.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_build_and_send_ue_reconfig_req_for_icic_action(rrm_ue_context_t *p_rrm_ue_context)
{

    rrm_return_et			      ret_val = RRM_SUCCESS;
    U16					          transaction_id = RRM_ONE;
    rrc_rrm_ue_reconfig_req_t	  rrc_rrm_ue_reconfig_req = {RRM_ZERO};
   

    RRM_UT_TRACE_ENTER();
   
    /*KLOC FIX */	 
    RRM_ASSERT(p_rrm_ue_context != RRM_PNULL);
    /* setting bitmask with 0x00 */
    p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = RRM_ZERO;


    rrc_rrm_ue_reconfig_req.ue_index = p_rrm_ue_context->ue_index;

    rrc_rrm_ue_reconfig_req.bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= 
        RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;

    /* Uplink power starts */
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask  = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask  |= RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.
        uplink_power_control_dedicated.p0_ue_pusch = RRM_ZERO;
    p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch = RRM_ZERO;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.
        uplink_power_control_dedicated.delta_mcs_enabled = p_rrm_ue_context->ue_uplink_power_control_dedicated.delta_mcs_enabled;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.
        uplink_power_control_dedicated.accumulation_enabled = p_rrm_ue_context->ue_uplink_power_control_dedicated.accumulation_enabled;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.
        uplink_power_control_dedicated.p0_ue_pucch = p_rrm_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.
        uplink_power_control_dedicated.p_srs_offset = p_rrm_ue_context->ue_uplink_power_control_dedicated.p_srs_offset;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.
        uplink_power_control_dedicated.filter_coefficient = p_rrm_ue_context->ue_uplink_power_control_dedicated.filter_coefficient;

    /*setting ue context reconfig bitmask in ue context for uplink power ctrl */
    p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                      RRM_UE_RECONFIG_PHY_UPLINK_POWER_CONTROL_ROLLBACK_PRESENT;
 
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
            "Power of UE changed during ICIC");
    /* Uplink power end */

    ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
            RRM_MODULE_ID,
            RRC_MODULE_ID,
            transaction_id,
            p_rrm_ue_context->cell_index);
    if(RRM_SUCCESS == ret_val)
    {
        /*set the UE sub state*/
        RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_RECONFIG_ONGOING);
        
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                "Unable to send UE reconfig request to RRC.");
        /* if ue reconfig sending error occures then reset the bitmask */
        p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = RRM_ZERO;
    }
    /*send the ue reconfig request to RRC*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_14564_fix: start */
/******************************************************************************
 * FUNCTION NAME : rrm_get_freq_type_from_cell_type 
 * DESCRIPTION   : This function returns the irat priority on the basis of 
 *               : which rat type CGI repporting needs to be done.
 *  RETURNS      : irat_priority
 ******************************************************************************/
    rrm_irat_priority_et
rrm_get_freq_type_from_cell_type(
        rrm_ue_rat_et rrm_cell_type
        )
{
    RRM_UT_TRACE_ENTER();

    /* Start fix for Coverity_ID : 81738 */
    /* SPR 20653 Fix Start */
    rrm_irat_priority_et    freq_type = RRM_IRAT_PRIORITY_MAX;
    /* SPR 20653 Fix End */

    switch (rrm_cell_type)
    {
        case EUTRAN_RAT:
            freq_type = RRM_IRAT_PRIORITY_EUTRAN;
            break;
        case UTRAN_FDD_RAT:
        case UTRAN_TDD_RAT:
            freq_type = RRM_IRAT_PRIORITY_UTRAN;
            break;
        case GERAN_RAT:
            freq_type = RRM_IRAT_PRIORITY_GERAN;
            break;
        case CDMA_RAT:
            freq_type = RRM_IRAT_PRIORITY_CDMA2000;
            break;
        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                    RRM_DETAILED,
                    "Falling in default case");
            break;
    }

    RRM_UT_TRACE_EXIT();
    return freq_type;
    /* End fix for Coverity_ID : 81738 */
}

/* SPR_14564_fix: end */
/* Fix for CSR 58972 start */
/******************************************************************************
 * FUNCTION NAME : rrm_build_and_send_meas_config_req_for_cgi
 * DESCRIPTION   : Builds the meas config request and sends to RRC for CGI 
 *               : reporting.
 * RETURNS       : rrm_return_et(RRM_SUCCESS/RRM_FAILURE)
 *****************************************************************************/
/* SPR_14564_fix: start */
rrm_return_et
rrm_build_and_send_meas_config_req_for_cgi
(
    rrm_ue_context_t *p_ue_context,
         /*SPR 17777 +-*/
 rrm_ue_rat_et     rrm_cell_rat_type
 )
    /* SPR_14564_fix: end */
{


    YLNODE                       *p_node = RRM_PNULL;
    meas_report_info_node_t      *p_meas_report_info = RRM_PNULL;
    U8                           meas_id;
    U16                          carrier_earfcn = RRM_NULL;
    U8                           band_indicator = RRM_NULL;
    rrc_rrm_meas_config_req_t    *p_rrc_rrm_meas_config_req = RRM_PNULL;
    rrm_return_et                ret_val = RRM_SUCCESS;
    U16                          transaction_id    = RRM_NULL; /*RRM_MEAS Changes */
    meas_object_to_add_mod_t     *p_meas_object_to_add_mod = RRM_PNULL;
    /* Coverity fix 88484*/
    meas_report_info_node_t      *p_meas_object_config = RRM_PNULL;
    /* Coverity fix 88484*/
    U8                           report_config_id;
    rrm_cell_context_t           *p_cell_ctxt = RRM_PNULL;
    /*inter_freq_params_t          *p_cell_ctx_inter_params = RRM_PNULL; */
    U32                          self_earfcn        = RRM_NULL;
    /* SPR_14564_fix: start */
    /* SPR 20653 Fix Start */
    rrm_irat_priority_et         freq_type = RRM_IRAT_PRIORITY_MAX;
    /* SPR 20653 Fix End */
    /* SPR_14564_fix: end */


    /* SPR-22211 START */
    U8  freq_count         = RRM_ZERO;
    U8 valid_freqs         = RRM_ZERO;
    idle_mode_mobility_params_t   *p_idle_mode_mobility_params = RRM_PNULL;
    meas_object_eutra_t        *p_meas_object_eutra = RRM_PNULL;
    /* SPR-22211 END */

    RRM_UT_TRACE_ENTER();

    /* CSR-86373[SPR-12963]-fix start */
    /* Code Deleted*/
    /* CSR-86737[SPR-12963]-fix end */
    /* SPR_14564_fix: start */
    freq_type = rrm_get_freq_type_from_cell_type(rrm_cell_rat_type);

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
            RRM_DETAILED,
            "Freq Type selected: %d", freq_type);
    /* SPR_14564_fix: end */

    p_node = ylFirst(&(p_ue_context->meas_report_list));

    while (p_node) 
    {
        /* CSR-86373[SPR-12963]-fix start */
        p_meas_report_info = (meas_report_info_node_t*) p_node;
        /* SPR 16406 21AUG Start */
        if (p_meas_report_info->carrier_earfcn == p_ue_context->cgi_trigerred_for_earfcn) 
        /* SPR 16406 21AUG End */
        {
            carrier_earfcn = p_meas_report_info->carrier_earfcn;
            band_indicator = p_meas_report_info->band_indicator;

            p_ue_context->stored_meas_id_for_cgi = RRM_ZERO;
            /* CSR-86737[SPR-12963]-fix end */
            break;
        }
        p_node = ylNext(p_node);
    }

    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
        rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));

    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    /* SPR 16406 21AUG Start */
    p_cell_ctxt = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /* SPR 16406 21AUG End */
    transaction_id = rrm_generate_txn_id();

    RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL, sizeof(rrc_rrm_meas_config_req_t));
    /* SPR 16406 8SEP start */
    if (RRM_SUCCESS != rrm_remove_previous_cgi_from_ue(p_ue_context, p_rrc_rrm_meas_config_req))
    {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                    "No previous information regarding the measurement needs to be removed");
    }
    /* SPR 16406 8SEP end */


    p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
    p_rrc_rrm_meas_config_req->meas_config.bitmask  |= UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT;
    p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.count = RRM_ONE;

    p_meas_object_to_add_mod = &(p_rrc_rrm_meas_config_req->meas_config.meas_object_to_add_mod_list.meas_object_to_add_mod[RRM_ZERO]);


    /* SPR 16406 21AUG Start */
    /* Code removed */
    /* SPR 16406 21AUG End */
    
    /* SPR-10397-fix start */
    if ((RRM_NULL != carrier_earfcn) && (RRM_PNULL != p_cell_ctxt))
    /* SPR-10397-fix end */
    {

        /* SPR_14564_fix: start */
        if( RRM_TRUE == rrm_is_meas_object_configured_for_frequency(p_ue_context,
                    carrier_earfcn, band_indicator, freq_type ,&p_meas_object_config))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    " Inter-freq meas_object=%d is already configured for carrier_freq =%d band indicator %d"
                    " Freq Type [%d] for  [UE:%d]",
                    p_meas_object_config->meas_object_id,carrier_earfcn,band_indicator, freq_type, p_ue_context->ue_index);
            switch(rrm_cell_rat_type)
            {
                case EUTRAN_RAT:
                    {
                        p_meas_object_to_add_mod->meas_object_id      =  p_meas_object_config->meas_object_id;
                        p_meas_object_to_add_mod->meas_object.bitmask |= MEAS_OBJECT_TO_ADD_EUTRA_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_eutra.carrier_freq = carrier_earfcn;
                        /*
                         ** Filling cell context param
                         */
                        self_earfcn = p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
                        if (carrier_earfcn == self_earfcn)
                        {
                            p_meas_object_to_add_mod->meas_object.meas_object_eutra.
                                offset_freq = RRM_OAM_Q_OFFESET_RANGE_DB0;

                            if(p_cell_ctxt->operator_info.sib_3_info.intra_freq_reselection_info.
                                    bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT) 
                            {
                                p_meas_object_to_add_mod->meas_object.meas_object_eutra.
                                    allowed_meas_bandwidth =  
                                    p_cell_ctxt->operator_info.sib_3_info.intra_freq_reselection_info.
                                    measurement_bandwidth;
                            }
                            p_meas_object_to_add_mod->meas_object.meas_object_eutra.
                                presence_antenna_port1 =
                                p_cell_ctxt->operator_info.sib_3_info.intra_freq_reselection_info.
                                presence_antenna_port1;

                            p_meas_object_to_add_mod->meas_object.meas_object_eutra.
                                neigh_cell_config = 
                                p_cell_ctxt->ran_info.mobility_params.
                                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
                                neigh_cell_config;

                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Intra Freq meas object created.");
                        }
                        else
                        {
                            /* SPR-22211 START */
                            p_idle_mode_mobility_params = rrm_cellm_get_idle_mode_params\
                                                          (p_ue_context->cell_index);


                            p_meas_object_eutra = &(p_meas_object_to_add_mod->meas_object.meas_object_eutra);


                            if(RRM_PNULL != p_idle_mode_mobility_params)
                            {
                                valid_freqs =  p_idle_mode_mobility_params->num_valid_inter_freq_list;
                            }

                            for(freq_count=RRM_ZERO; freq_count < valid_freqs; freq_count++)
                            {
                                if(carrier_earfcn == 
                                        p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[freq_count].
                                        eutra_carrier_arfcn)
                                {
                                    break;
                                }
                            }

                            if(freq_count < valid_freqs)
                            {
                                p_meas_object_eutra->allowed_meas_bandwidth =
                                    p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[freq_count].
                                    inter_freq_params_op_specific.\
                                    allowed_meas_bandwidth;

                                p_meas_object_eutra->presence_antenna_port1 =
                                    p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[freq_count].
                                    inter_freq_params_op_specific.presence_antenna_port1;

                                p_meas_object_eutra->neigh_cell_config =
                                    p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[freq_count].
                                    neigh_cell_config;

                                p_meas_object_eutra->offset_freq =
                                    p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[freq_count].
                                    cm_offset_freq;

                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Inter Freq meas object created.");
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                        "Inter Freq meas object cannot be created as not carrier present for earfcn %d",
                                        carrier_earfcn);
                                if( RRM_NULL != p_rrc_rrm_meas_config_req )
                                    RRM_MEM_FREE( p_rrc_rrm_meas_config_req );
                                return RRM_FAILURE;
                            }
                            /* SPR-22211 END */

                        }

                        /*
                         ** For CGI reporting.
                         */
                        p_meas_object_to_add_mod->meas_object.meas_object_eutra.bitmask |= MEAS_OBJECT_EUTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_eutra.cell_for_which_to_report_cgi = p_ue_context->pci_for_which_cgi_required;
                    }
                    break;
                case UTRAN_FDD_RAT:
                    {
                        p_meas_object_to_add_mod->meas_object_id      =  p_meas_object_config->meas_object_id;
                        p_meas_object_to_add_mod->meas_object.bitmask |= MEAS_OBJECT_TO_ADD_UTRA_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_utra.carrier_freq = carrier_earfcn;

                        p_meas_object_to_add_mod->meas_object.meas_object_utra.bitmask |= MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_utra.cell_for_which_to_report_cgi.bitmask |=
                            MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_FDD_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_utra.cell_for_which_to_report_cgi.utra_fdd =
                            p_ue_context->pci_for_which_cgi_required;
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "UTRA FDD meas object created.");
                    }
                    break;
                case UTRAN_TDD_RAT:
                    {
                        p_meas_object_to_add_mod->meas_object_id      =  p_meas_object_config->meas_object_id;
                        p_meas_object_to_add_mod->meas_object.bitmask |= MEAS_OBJECT_TO_ADD_UTRA_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_utra.carrier_freq = carrier_earfcn;

                        p_meas_object_to_add_mod->meas_object.meas_object_utra.bitmask |= MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_utra.cell_for_which_to_report_cgi.bitmask |=
                            MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_TDD_PRESENT;
                        p_meas_object_to_add_mod->meas_object.meas_object_utra.cell_for_which_to_report_cgi.utra_tdd =
                            p_ue_context->pci_for_which_cgi_required;
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "UTRA TDD meas object created.");
                    }
                    break;
                default:
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "RAT is not supported for CGI reporting.");
            }
        }
        /* SPR_14564_fix: end */
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "failed to fetch the meas object for [UE:%u]" ,
                    p_ue_context->ue_index);
            /* COVERITY : RESOURCE LEAK : CID : 63262 fix start */
            if( RRM_NULL != p_rrc_rrm_meas_config_req )
                RRM_MEM_FREE( p_rrc_rrm_meas_config_req );
            /* COVERITY : RESOURCE LEAK : CID : 63262 fix end */
            return RRM_FAILURE;
        }

        /* SPR 16406 8SEP start */
        /* Code removed */
        /* SPR 16406 8SEP end */

        report_config_id = rrm_uem_allocate_free_id (p_ue_context, REP_CONFIG);
        /* SPR_15852_fix: start*/
        meas_id = rrm_uem_allocate_free_id (p_ue_context, MEAS_REPORT);
        if((report_config_id <= MAX_REPORT_CONFIG_ID)&& (meas_id <= MAX_MEAS_ID))
        /* SPR_15852_fix: start*/
        {
            /*SPR 17256 Start*/
            p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;
            /*SPR 17256 End*/

            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.count = RRM_ONE;
            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.report_config_to_add_mod[RRM_ZERO].report_config_id = report_config_id;

            /* SPR_14564_fix: start */
            switch(rrm_cell_rat_type)
            {
                case EUTRAN_RAT:
                    {
            fill_eutran_report_config_to_add_mod_list(
                    &p_rrc_rrm_meas_config_req->meas_config.\
                    report_config_to_add_mod_list.report_config_to_add_mod[RRM_ZERO], RRM_RRC_REPORT_CGI, report_config_id);

        if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
                (RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                 eutra_radio_capability_info_def.access_stratum_release) &&
        /* SPR 12897 Start */
                 (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status))
        /* SPR 12897 End */
        {
            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list. \
                report_config_to_add_mod[RRM_ZERO].report_config. \
                bitmask |= REPORT_CONFIG_EUTRA_EXT_PRESENT;

            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list. \
                report_config_to_add_mod[RRM_ZERO].report_config. \
                report_config_eutra_ext.bitmask |= SI_REQUEST_FOR_HO_R9_EUTRA_PRESENT;

            p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list. \
                report_config_to_add_mod[RRM_ZERO].report_config. \
                report_config_eutra_ext.si_request_for_ho_r9 = RRM_RRC_SETUP_R9;
        }
                    }
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "EUTRA report config created for CGI reporting.");
                    break;
                case UTRAN_FDD_RAT:
                case UTRAN_TDD_RAT:
                    {
                        /* New function to be created for CGI report config*/
                        /* Coverity 81727 Fix Start */
                        fill_interrat_report_config_to_add_mod_list(
                                p_ue_context,
                                &p_rrc_rrm_meas_config_req->meas_config.report_config_to_add_mod_list.
                                report_config_to_add_mod[RRM_ZERO], RRM_INTERRAT_REPORT_STRONGEST_CELLS_FOR_SON,
                                report_config_id);
                        /* Coverity 81727 Fix Start */
                    }
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UTRA report config created for CGI reporting.");
                    break;
                default:
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "RAT not supported.");
            }

            /* SPR_15852_fix: start */
            p_rrc_rrm_meas_config_req->meas_config.bitmask  |= UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT;
            p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.count = RRM_ONE;
            p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                                    meas_id_to_add_mod[RRM_ZERO].meas_id          = meas_id;
            p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                                      meas_id_to_add_mod[RRM_ZERO].meas_object_id = p_meas_object_to_add_mod->meas_object_id;
            p_rrc_rrm_meas_config_req->meas_config.meas_id_to_add_mod_list.
                                     meas_id_to_add_mod[RRM_ZERO].report_config_id = report_config_id;
            /* SPR_15852_fix: end*/
        }
        else
        {
            /* SPR_15852_fix: start */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Maximum Report Config Id[%u] or meas id[%u] reached for [UE:%u]", 
                    report_config_id,meas_id,p_ue_context->ue_index);
            /* In case the report config id is not available, return failure and free the memory */
            if(report_config_id <= MAX_REPORT_CONFIG_ID)
            {
                rrm_uem_deallocate_used_id(p_ue_context,
                                            REP_CONFIG,
                                            report_config_id);
            }
            else if( meas_id <= MAX_MEAS_ID)
            {
                rrm_uem_deallocate_used_id(p_ue_context,
                                            MEAS_REPORT,
                                            meas_id);

            }
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            return RRM_FAILURE;
            /* SPR_15852_fix: end */
        }
        /* SPR_14564_fix: end */


        /* SPR 15509 start*/
        p_meas_report_info = RRM_PNULL;
        p_meas_report_info       =(meas_report_info_node_t*) rrm_mem_get(sizeof(meas_report_info_node_t));
        if (p_meas_report_info == RRM_PNULL)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Memory Allocation Failure");
            RRM_UT_TRACE_EXIT();
            /* SPR_15852_fix: start */
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            /* SPR_15852_fix: end */
            return RRM_FAILURE;
        }

        RRM_MEMSET(p_meas_report_info, RRM_ZERO, sizeof(meas_report_info_node_t));
        p_meas_report_info->meas_object_id = p_meas_object_to_add_mod->meas_object_id;
        p_meas_report_info->report_config_id = report_config_id;
        p_meas_report_info->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
        p_meas_report_info->meas_id = meas_id;  
        p_meas_report_info->reporting_event = MEAS_REP_EVENT_FOR_CGI;  

        /* SPR 15853 Start */
        p_ue_context->stored_meas_id_for_cgi = meas_id; 
        /* SPR 15853 End */
        /* SPR 15860 Start */
        /* SPR 15861 Start */
        /* SPR 15862 Start */
        p_meas_report_info->is_meas_report_pending = RRM_TRUE;
        /* SPR 15860 End */
        /* SPR 15861 End */
        /* SPR 15862 End */

        /* SPR 15598 Start */
        p_meas_report_info->carrier_earfcn = carrier_earfcn;  
        /* SPR 15598 End */

        /*SPR 16292 Fix Start*/
        if((p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn == p_meas_report_info->carrier_earfcn) &&
                (MEAS_REP_EVENT_A3 == p_ue_context->ho_params.last_reported_meas_event))
        {
            p_meas_report_info->is_ask_cgi_configured_via_intra_a3 = RRM_TRUE;
        }
        /*SPR 16292 Fix Stop*/

        ylPushTail(&(p_ue_context->meas_report_list),&(p_meas_report_info->sNode));

        /* SPR 15509 end */
        if(p_rrc_rrm_meas_config_req->meas_config.bitmask)
        {
            ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);

            if(ret_val == RRM_FAILURE)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send MEAS CONFIG REQUEST for [UE:%d]",
                        p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Successfully sent MEAS CONFIG REQUEST for [UE:%d]",
                        p_ue_context->ue_index);
                p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;/*RRM_MEAS Changes */
                /* SPR 15797 Start */
                RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_MEAS_CONFIG_REQ_ONGOING);
                /* SPR 15797 End */
            }
        }
    }
    else

    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "failed to fetch the carrier_earfcn and band_indicator values for [UE:%u]" ,
                p_ue_context->ue_index);
        ret_val = RRM_FAILURE;
    }

    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);

    RRM_UT_TRACE_EXIT();

    return ret_val;

}
/* Fix for CSR 58972 end */

/******************************************************************************
 *   FUNCTION NAME : rrm_get_updated_dl_p_a_for_ue 
 *   INPUT         : p_rrm_ue_context,ue_position_change_status
 *   OUTPUT        : none
 *   DESCRIPTION   : This function calculates the new p_a value for the UE as 
 *                   per the UE posotion change order i.e. (CC->CE) or (CE->CC) 
 *                   and DL SINRa and BLER values and then updates p_a value accordingly.
 *   RETURNS:
 *       RRM_TRUE  : If p_a value is updated.
 *       RRM_FALSE : If p_a value is not updated. 
*******************************************************************************/
rrm_bool_et
rrm_get_updated_dl_p_a_for_ue
(
 rrm_ue_context_t *p_rrm_ue_context,
 rrm_ue_position_et ue_position_change_status
)
{
    U8       p_a_ramping_step_val = RRM_ZERO;
    rrm_cell_context_t  *p_cell_ctxt = RRM_PNULL;
    rrm_bool_et dl_p_a_updated = RRM_FALSE;
    U32      dl_sinr_for_ue = RRM_ZERO;
    U32      dl_bler_for_ue = RRM_ZERO;
    U32      sinr_threshold_for_ue = RRM_ZERO;
    U32      bler_threshold_for_ue = RRM_ZERO;
    U8       p_a_configured_for_ce_ue = RRM_NULL;
    U8       updated_p_a_val = RRM_NULL;
    /* BUG_876_CHANGES_START */
    /* Start: BUG 379 */
    //U8       max_value_for_pa = RRM_NULL; 
    /* End: BUG 379 */
    /* BUG_876_CHANGES_END */
    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*cov_fix_65814_start*/
    if (RRM_PNULL == p_cell_ctxt )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
        RRM_UT_TRACE_EXIT();
        /*CID 66684:start*/
        return RRM_FALSE;
        /*CID 66684:end*/
    }
    /*cov_fix_65814_end*/
    dl_sinr_for_ue = p_rrm_ue_context->ue_avg_stats.downlinkSINRValueCW0;
    dl_bler_for_ue = p_rrm_ue_context->ue_avg_stats.downlinkBlerValueCW0;
/* BUG_11317_FIX_START */
    bler_threshold_for_ue = p_cell_ctxt->pusch_bler_threshold; 
/* BUG_11317_FIX_END */
    p_a_ramping_step_val = p_cell_ctxt->dynamic_icic_data.pdsch_config_params.pdsch_dedicated_config.p_a_ramping_step;
    p_a_configured_for_ce_ue = p_cell_ctxt->dynamic_icic_data.pdsch_config_params.pdsch_dedicated_config.pa_for_ce_ue;

    /* BUG_876_CHANGES_START */
    //max_value_for_pa = MAX_BETWEEN_TWO( p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a,
    //        p_a_configured_for_ce_ue);
    /* BUG_876_CHANGES_END */
    
    /*
     ** CASE 1: UE has changed it's position from Cell Edge to Cell Center
     */
    if( RRM_UE_POSITION_FRM_CE_to_CC == ue_position_change_status )
    {
        /*
         ** Update that what type of operation is performed on P_A value
         */
        /*SPR 7892 FIX START*/
        if(p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured >
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a)
        {
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_DECREMENTED;
            dl_p_a_updated = RRM_TRUE;
        }
        else if (p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured < 
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a)

        {
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_INCREMENTED;
            dl_p_a_updated = RRM_TRUE;
        }
        else
        {
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_NOT_UPDATED;
        } 

        /*
        ** change the P_A value for the UE to the P_A value configured for CC UE's if required
        */
        if(RRM_TRUE == dl_p_a_updated)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "P_A is changed from [%d] to [%d]  due to position change",
                    p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured,
                    p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a);
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured =
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a;
        }
        /*SPR 7892 FIX END*/
    }
    /*
     ** CASE 2: UE has changed it's position from Cell Center to Cell Edge
     */
    else if( RRM_UE_POSITION_FRM_CC_to_CE == ue_position_change_status )
    {
        /*SPR 7892 FIX START*/
        /*
        ** Update that what type of operation is performed on P_A value
        */
        if(p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured >
                p_a_configured_for_ce_ue)
        {
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_DECREMENTED;
            dl_p_a_updated = RRM_TRUE;
        }
        else if (p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured < 
                p_a_configured_for_ce_ue) 
        {
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_INCREMENTED;
            dl_p_a_updated = RRM_TRUE;
        }
        else
        {
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_NOT_UPDATED;
        } 

        /*
        ** Update that what type of operation is performed on P_A value
        */
        if(RRM_TRUE == dl_p_a_updated)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "P_A value is changed from [%d] to [%d]  due to position change",
                    p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured,
                    p_a_configured_for_ce_ue);
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured = p_a_configured_for_ce_ue;
        }
        /*SPR 7892 FIX END*/
    }
    /*
     ** CASE 4: UE has not changed it's position . It remains in Cell Edge/Centre.
     */
    else 
    {
        /* BUG_11317_FIX_START */
        if (RRM_UE_POSITION_AT_CELL_CENTER == p_rrm_ue_context->dynamic_icic_info.
                                              rrm_ue_dynamic_icic_present_data.ue_present_position)
        {
            sinr_threshold_for_ue = p_cell_ctxt->rrm_olpc_config_params.
                                    rrm_olpc_pusch_config_params.
                                    olpc_pusch_snr_threshold_for_cell_center_ue; 
        }
        else
        {
            sinr_threshold_for_ue = p_cell_ctxt->rrm_olpc_config_params.
                                    rrm_olpc_pusch_config_params.
                                    olpc_pusch_snr_threshold_for_cell_edge_ue; 
        }
        /* BUG_11317_FIX_END */
        /* BUG_876_CHANGES_START */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "SINR [%d] Threshold [%d] BLER[%d] Threshold[%d]",
                  dl_sinr_for_ue, sinr_threshold_for_ue, dl_bler_for_ue, bler_threshold_for_ue);
        if((dl_sinr_for_ue <= sinr_threshold_for_ue) && (dl_bler_for_ue >= bler_threshold_for_ue))
        {
            /* 
             **Update the P_A only if it has not reached it's maximum limit
             */
            /*SPR 7892 FIX START*/
            if( MAX_VALUE_FOR_P_A !=  p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured)
            {
                /* BUG_876_CHANGES_END */
                updated_p_a_val = p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured 
                                             + p_a_ramping_step_val;

                /* Limit the P_A value within the allowed range */
                /* BUG_876_CHANGES_START */
                if( updated_p_a_val >= MAX_VALUE_FOR_P_A)
                {
                    updated_p_a_val = MAX_VALUE_FOR_P_A; 
                    /*SPR 7892 FIX END*/
                    /* BUG_876_CHANGES_END */
                    rrm_cellm_increment_dynamic_icic_counter_in_cell(p_rrm_ue_context->cell_index,
                            RRM_CELLM_DYNAMIC_ICIC_P_MAX_UES);
                }

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "P_A value is changed from [%d] to [%d]  due to bad SINR/BLER",
                        p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured,
                        updated_p_a_val);
                p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type = RRM_UE_P_A_INCREMENTED;
                p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured = updated_p_a_val;
                dl_p_a_updated = RRM_TRUE;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "P_A is already at MAX possible value , can't increase further");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "UE is facing good network conditions,no change in P_A is required");
        }
    }

    RRM_UT_TRACE_EXIT();
    return dl_p_a_updated;
}


/******************************************************************************
 *   FUNCTION NAME : rrm_reconfig_ue_for_icic 
 *   INPUT         : p_rrm_ue_context,p_ue_position_change_status
 *   OUTPUT        : NONE
 *   DESCRIPTION   : This function idenifies the UE posotion change
 *                   order i.e. (CC->CE) or (CE->CC) and calls the function to 
 *                   update p_a value accordingly.
 *   RETURNS:
 *       RRM_TRUE  : If p_a value is updated  & UE should be 
 *                   reconfigured for ICIC also.
 *       RRM_FALSE : If p_a value is not updated & UE should not 
 *                   be reconfigured for ICIC.
*******************************************************************************/
rrm_bool_et
rrm_reconfig_ue_for_icic
(
 rrm_ue_context_t *p_rrm_ue_context,
 rrm_ue_position_et *p_ue_position_change_status 
)
{
    rrm_bool_et reconfig_ue = RRM_FALSE;
	rrm_ue_position_et ue_position_change_status ;
	RRM_UT_TRACE_ENTER();

    /* UE changes it's position from Cell Edge (CE) to Cell Center (CC)*/
    if( (RRM_UE_POSITION_AT_CELL_CENTER == p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position) &&
        (RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position) )
	{
	       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			     "UE changed it's postion from CE -> CC");
	  	   ue_position_change_status = RRM_UE_POSITION_FRM_CE_to_CC;
	}
    /* UE changes it's position from Cell Center (CC) to Cell Edge (CE)*/
	else
    if( (RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position) &&
        (RRM_UE_POSITION_AT_CELL_CENTER == p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position) )
	{
		
	       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			     "UE changed it's postion from CC -> CE");
	  	   ue_position_change_status = RRM_UE_POSITION_FRM_CC_to_CE;
	}
    /* UE changes doesn't change it's position from  Cell Edge (CE)*/
	else 
    if( (RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position) &&
        (RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position) )
	{
	       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			     "UE remains at Cell Edge , no change ");
	  	   ue_position_change_status = RRM_UE_POSITION_AT_CELL_EDGE;
	}
    /* UE changes doesn't change it's position from  Cell Center (CC)*/
    else
	{
	       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			     "UE remains at Cell Center , no change ");
	  	   ue_position_change_status = RRM_UE_POSITION_AT_CELL_CENTER;
	}

    /*
	** Check whether UE reconfiguration is required for P_A values
	** as per the UE position change order
	*/
    *p_ue_position_change_status = ue_position_change_status;
	reconfig_ue = rrm_get_updated_dl_p_a_for_ue(p_rrm_ue_context,ue_position_change_status);
    
	RRM_UT_TRACE_EXIT();
	return reconfig_ue;
}


/******************************************************************************
 *   FUNCTION NAME :  rrm_apply_dynamic_icic_schemes
 *   INPUT         : p_rrm_ue_context,radio_resource_reconfig
 *   OUTPUT        : none
 *   DESCRIPTION   : This function identifies whether a UE is at the CELL center
 *                   or at Cell edge and the SINR/BLER for a particular UE.
 *                   on the basis of these factors , it applies the appropriate 
 *                   Dynamic ICIC scheme.
 *   RETURNS:
 *       RRM_TRUE  : If some dynamic ICIC scheme is applied & UE should be 
 *                   reconfigured for ICIC also.
 *       RRM_FALSE : If No dynamic ICIC scheme is applied & UE should not 
 *                   be reconfigured for ICIC.
*******************************************************************************/
rrm_bool_et
rrm_apply_dynamic_icic_schemes
(
   rrm_ue_context_t *p_rrm_ue_context,
   radio_resource_reconfig_t *radio_resource_reconfig
)
{
   rrm_ue_position_et ue_position_change_status ;
   /* SPR-19276 START */
   rrm_ue_position_et ue_location = RRM_UE_POSITION_AT_CELL_CENTER;
   /* SPR-19276 END */
   rrm_bool_et ret_val = RRM_FALSE;
   /* SPR-19276 START */
   /* code deleted */
   /* SPR-19276 END */
   RRM_TIME_T          time_vn_ue_reconfig_initiated;
   time_vn_ue_reconfig_initiated.sec = RRM_ZERO;
   time_vn_ue_reconfig_initiated.msec = RRM_ZERO;
   unsigned long seconds_elapsed = RRM_ZERO;
   rrm_bool_et fresh_reports_count_is_valid = RRM_FALSE; /* coverity fix : assigning its enum value for enum type  */
   rrm_bool_et  ue_is_eligible_for_reconf  = RRM_FALSE;
   /*
   ** Get the current System time
   */
   time_vn_ue_reconfig_initiated = rrm_get_system_time();

    
   /*
   **  Check whether cool-off period for particular UE is over or not.
   **  i.e.  Check from the time when UE was last reconfigured , 
   **  whether we can now re-configure the UE again or not.
   */

   if(!p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_time_ue_reconfigured.sec)
   {
     ue_is_eligible_for_reconf = RRM_TRUE;
   }
   else if((seconds_elapsed = (time_vn_ue_reconfig_initiated.sec - 
       p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.
        last_time_ue_reconfigured.sec)) > COOL_OFF_PERIOD_FOR_UE_RECONFIG )
   {
     ue_is_eligible_for_reconf = RRM_TRUE;
   }
   else
   {
      ue_is_eligible_for_reconf = RRM_FALSE;
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                 "UE is Not eligible to be reconfigured for Dynamic ICIC."
                 "Since Cool-Off period of UE is ongoing."
                "Sec elapsed since last Successful UE reconfig [%lu]",seconds_elapsed);
   }

   RRM_UT_TRACE_ENTER();

  fresh_reports_count_is_valid =  ((RRM_ZERO == (p_rrm_ue_context->p_ue_mac_report->report_index % RRM_MAX_REPORT_STAT_UE)) ?
                                                   RRM_TRUE : RRM_FALSE) ;

  if(ue_is_eligible_for_reconf == RRM_TRUE)
  {
     if(RRM_TRUE == fresh_reports_count_is_valid)
     {
             ue_is_eligible_for_reconf = RRM_TRUE;
     }
     else
     {
             ue_is_eligible_for_reconf = RRM_FALSE;
             RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                 "UE is Not eligible to be reconfigured for Dynamic ICIC."
                 "Since enough ue stats reports are not recieved.");
     }
  }
  if( RRM_TRUE == ue_is_eligible_for_reconf )
  {
	  RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			     " UE is eligible to be reconfigured !!!");
      /* SPR-19276 START */
      ue_location = rrm_get_ue_location(p_rrm_ue_context);

      /*
	  ** Keep the copy of the present dynamic icic data to be used 
	  ** if the ue reconfig is unsuccessful
	  */
	  p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_past_data =
                 p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data;

      if(RRM_UE_POSITION_AT_CELL_EDGE == ue_location)
      {
          /* SPR-19276 END */
          /*
      	  ** Change the position of the UE to Cell Edge IF not in cell edge presently.
		  */
			 if(RRM_UE_POSITION_AT_CELL_EDGE != p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)
          {
              /*
			  ** Keep the copy of the last position of the UE , before updating it with the 
			  ** new position
			  */
			  p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position = 
                  p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position;

              p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_EDGE;
			 
			  /*
			  ** Upadate the dynamic ICIC counters for the UE's as per the new positions
			  */
			  rrm_cellm_increment_dynamic_icic_counter_in_cell(p_rrm_ue_context->cell_index,
							 RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
			  rrm_cellm_decrement_dynamic_icic_counter_in_cell(p_rrm_ue_context->cell_index,
							 RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
          }
      }
      /*
	  ** If the avg reported PL from UE is lesser than the threshold , 
	  ** UE is concidered to be at Cell Center (CC)
	  */
      else
      {
          /*
      	  ** Change the position of the UE to Cell Center ,IF not in cell center presently.
		  */
          if(RRM_UE_POSITION_AT_CELL_CENTER != p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)
          {
              /*
			  ** Keep the copy of the last position of the UE , before updating it with the 
			  ** new position
			  */
              p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position = 
                  p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position;
              p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_CENTER;
			
			  /*
			  ** Upadate the dynamic ICIC counters for the UE's as per the new positions
			  */
			  rrm_cellm_increment_dynamic_icic_counter_in_cell(p_rrm_ue_context->cell_index,
							 RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
			  rrm_cellm_decrement_dynamic_icic_counter_in_cell(p_rrm_ue_context->cell_index,
							 RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
          }
      }

      /*
	  ** After updating UE's present position in cell , check whether it's power
	  ** is to be updated or not as per the current Inter cell interference
  	  */
	  ret_val = rrm_reconfig_ue_for_icic(p_rrm_ue_context , &ue_position_change_status);
  
      /*
	  ** P_A value is updated as per the dynamic icic scheme applied , and ue reconfig
	  ** request is populated with the updated p_a value.
	  */

	  if(RRM_TRUE == ret_val)
      {
        radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.pdsch_configuration_dedicated.p_a =
                        p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured;
		radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask 
                                                    |= RRC_PHY_PDSCH_CONFIGURATION_DEDICATED_PRESENT;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "P_A update is required in UE reconfig req!!");
      }
      else
      {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                  "P_A update is Not required in UE reconfig req!!");
      }

      /*Location update fix in UE RECONFIG*/
      if((RRM_UE_POSITION_FRM_CE_to_CC == ue_position_change_status) ||
              (RRM_UE_POSITION_FRM_CC_to_CE == ue_position_change_status ))
      {
          p_rrm_ue_context->dynamic_icic_info.location_update_req_for_ue_reconfig = RRM_TRUE;
      }
      /*Location update fix in UE RECONFIG*/
  }
  
  RRM_UT_TRACE_EXIT();
  return ret_val;
}
/*  DYNAMIC ICIC CHANGES END  */
/*****************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_rrc_registered_lai_t
 *   INPUT      : p_ue_register_lai,p_rrc_ue_erb_registered_lai
 *   OUTPUT     : none
 *   DESCRIPTION:
 *               Maps the register_lai structure of RRC and RRM
 *   RETURNS:
 *               rrm_return_et (TRUE/FALSE)
 *****************************************************************************/

rrm_return_et
rrm_map_rrm_rrc_registered_lai_t(
    rrm_uem_registered_lai_t *p_ue_register_lai,
    registered_lai_t *p_rrc_ue_erb_registered_lai
)
{
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_ue_erb_registered_lai && RRM_PNULL != p_ue_register_lai)
    {
        rrm_map_rrm_rrc_plmn_identity(&(p_ue_register_lai->plmn_identity), &(p_rrc_ue_erb_registered_lai->plmn_identity));
        rrm_map_rrm_rrc_lac(&(p_ue_register_lai->lac), &(p_rrc_ue_erb_registered_lai->lac));
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_ue_erb_registered_lai is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*****************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_rrc_plmn_identity
 *   INPUT      : p_ue_plmn_id,p_rrc_ue_erb_plmn_id
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Maps the plmn_identity value of RRC and RRM structure
 *
 *   RETURNS:
 *          rrm_return_et (TRUE/FALSE)
 *****************************************************************************/
rrm_return_et
rrm_map_rrm_rrc_plmn_identity(
    rrm_uem_plmn_identity_lai_t *p_ue_plmn_id,
    plmn_identity_lai_t *p_rrc_ue_erb_plmn_id
)
{
    U8 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_ue_plmn_id && RRM_PNULL != p_rrc_ue_erb_plmn_id)
    {
        p_ue_plmn_id->num = p_rrc_ue_erb_plmn_id->num;
        for(index = RRM_ZERO; index < RRM_UEM_MAX_PLMN_ID_NUMOCTS; index++)
        {
            p_ue_plmn_id->data[index] = p_rrc_ue_erb_plmn_id->data[index];
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_ue_plmn_id or p_rrc_ue_erb_plmn_id is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*****************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_rrc_lac
 *   INPUT      : p_ue_register_lac,p_rrc_ue_erb_lac
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Maps the lac_t values of RRC and RRM structure
 *
 *   RETURNS:
 *          rrm_return_et (TRUE/FALSE)
 *****************************************************************************/
rrm_return_et
rrm_map_rrm_rrc_lac(
    rrm_uem_lac_t *p_ue_register_lac,
    lac_t *p_rrc_ue_erb_lac
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ue_register_lac && RRM_PNULL != p_rrc_ue_erb_lac)
    {
        p_ue_register_lac->num = p_rrc_ue_erb_lac->num;
        for(index = RRM_ZERO; index < RRM_UEM_MAX_LAC_NUMOCTS; index++)
        {
            p_ue_register_lac->data[index] = p_rrc_ue_erb_lac->data[index];
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_ue_register_lac or p_rrc_ue_erb_lac is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
 /*BUG 680 FIX START */
/******************************************************************************
 *   FUNCTION NAME: rrm_map_ho_restriction_list
 *   INPUT      : p_ho_restriction_list,p_rrc_ho_restriction_list
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map ho_restriction_list_t structure of RRC to RRM  
 *
 *   RETURNS:
 *          rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_ho_restriction_list
(
    rrm_ho_restriction_list_t *p_ho_restriction_list,
    ho_restriction_list_t     *p_rrc_ho_restriction_list
)
{
    U16           index   = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    
    if(RRM_PNULL != p_rrc_ho_restriction_list && RRM_PNULL != p_ho_restriction_list)
    {
         p_ho_restriction_list->bitmask = p_rrc_ho_restriction_list->bitmask;
    
         rrm_map_rrm_plmn_identity(&p_ho_restriction_list->serving_plmn_identity,
                                   &p_rrc_ho_restriction_list->serving_plmn_identity);
 
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_EQUIV_PLMN_LIST_PRESENT)
        {
              rrm_map_rrm_equiv_plmn_list(&p_ho_restriction_list->equiv_plmn_list,
                                          &p_rrc_ho_restriction_list->equiv_plmn_list);
        }
          
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_TA_LIST_PRESENT)
        {
              p_ho_restriction_list->forbidden_ta_list.count =  p_rrc_ho_restriction_list->forbidden_ta_list.count;
              /*SPR 21848 start*/
              p_ho_restriction_list->forbidden_ta_list.p_forbidden_ta=(rrm_forbidden_ta_t *)rrm_mem_get(
                                                                       p_rrc_ho_restriction_list->forbidden_ta_list.count*
                                                                       sizeof(rrm_forbidden_ta_t));
              /*SPR 21848 End*/
              for(index=RRM_ZERO ; index < p_rrc_ho_restriction_list->forbidden_ta_list.count ;index++)
              {
            /*SPR 20589 FIX START*/
                  rrm_map_rrm_forbidden_ta(&p_ho_restriction_list->forbidden_ta_list.p_forbidden_ta[index],
            /*SPR 20589 FIX END*/
                                           &p_rrc_ho_restriction_list->forbidden_ta_list.forbidden_ta[index]);
              }
        }
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_LA_LIST_PRESENT)
        {
            p_ho_restriction_list->forbidden_la_list.count =  p_rrc_ho_restriction_list->forbidden_la_list.count;
            /*SPR 21848 start*/
            p_ho_restriction_list->forbidden_la_list.p_forbidden_la=(rrm_forbidden_la_t *)rrm_mem_get(
                    p_rrc_ho_restriction_list->forbidden_la_list.count*
                    sizeof(rrm_forbidden_la_t));
            /*SPR 21848 End*/
            for(index=RRM_ZERO ; index < p_rrc_ho_restriction_list->forbidden_la_list.count ;index++)
            {
            /*SPR 20589 FIX START*/
                rrm_map_rrm_forbidden_la(&p_ho_restriction_list->forbidden_la_list.p_forbidden_la[index],
            /*SPR 20589 FIX END*/
                                         &p_rrc_ho_restriction_list->forbidden_la_list.forbidden_la[index]);
            }
        }
        if(p_rrc_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT)
        {
            p_ho_restriction_list->forbidden_inter_rat = p_rrc_ho_restriction_list->forbidden_inter_rat;
        }
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                  RRM_ERROR," p_rrc_ho_restriction_list or p_ho_restriction_list is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_plmn_identity
 *   INPUT      : p_rrm_plmn_identity,p_rrc_plmn_identity
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map plmn_identity_t structure of RRC to RRM  
 *
 *   RETURNS:
 *          rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_rrm_plmn_identity(
    rrm_plmn_identity_t *p_rrm_plmn_identity ,
    plmn_identity_t  *p_rrc_plmn_identity
    )
{
    U8 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_plmn_identity && RRM_PNULL != p_rrm_plmn_identity)
    {
        p_rrm_plmn_identity->presence_bitmask = p_rrc_plmn_identity->presence_bitmask;
        if(p_rrc_plmn_identity->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
        {
            p_rrm_plmn_identity->presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

            for(index = RRM_ZERO ; index < MCC_OCTET_SIZE ; index++)
            {
                p_rrm_plmn_identity->mcc[index] = p_rrc_plmn_identity->mcc[index];
            } 
        }  
        p_rrm_plmn_identity->mnc.count = p_rrc_plmn_identity->mnc.count;
 
        for(index = RRM_ZERO ; index < p_rrc_plmn_identity->mnc.count ; index++)
        {
              p_rrm_plmn_identity->mnc.mnc[index] = p_rrc_plmn_identity->mnc.mnc[index];
        }
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR," p_rrc_plmn_identity or p_rrm_plmn_identity is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_equiv_plmn_list
 *   INPUT      : p_rrm_equiv_plmn_list,p_rrc_equiv_plmn_list
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map equiv_plmn_list_t structure of RRC to RRM  
 *
 *   RETURNS:
 *          rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_rrm_equiv_plmn_list(
    rrm_equiv_plmn_list_t *p_rrm_equiv_plmn_list,
    equiv_plmn_list_t *p_rrc_equiv_plmn_list
    )
{ 
    rrm_return_et ret_val = RRM_FAILURE;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_equiv_plmn_list && RRM_PNULL != p_rrm_equiv_plmn_list)
    {
        p_rrm_equiv_plmn_list->count = p_rrc_equiv_plmn_list->count;
        /*SPR 21848 Start */
        p_rrm_equiv_plmn_list->p_equiv_plmn=(rrm_equiv_plmn_t *)
                                            rrm_mem_get(p_rrc_equiv_plmn_list->count*sizeof(rrm_equiv_plmn_t));
        /*SPR 21848 End */
        for(index = RRM_ZERO ; index < p_rrc_equiv_plmn_list->count ; index++)
        {
            /*SPR 20589 FIX START*/
            rrm_map_rrm_plmn_identity(&p_rrm_equiv_plmn_list->p_equiv_plmn[index].plmn_identity,
            /*SPR 20589 FIX END*/
                                      &p_rrc_equiv_plmn_list->equiv_plmn[index].plmn_identity);
        }
        ret_val = RRM_SUCCESS;
    }
    else
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_equiv_plmn_list or p_rrm_equiv_plmn_list is NULL");
         ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_forbidden_ta
 *   INPUT      : p_rrm_forbidden_ta,p_rrc_forbidden_ta
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map forbidden_ta_t structure of RRC to RRM  
 *
 *   RETURNS:
 *           rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_rrm_forbidden_ta(
             rrm_forbidden_ta_t *p_rrm_forbidden_ta,
             forbidden_ta_t *p_rrc_forbidden_ta
             )
{

    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_forbidden_ta && RRM_PNULL != p_rrm_forbidden_ta)
    {
        rrm_map_rrm_plmn_identity(&p_rrm_forbidden_ta->plmn_identity,&p_rrc_forbidden_ta->plmn_identity);
        
        rrm_map_forbidden_tac(&p_rrm_forbidden_ta->forbidden_tac , &p_rrc_forbidden_ta->forbidden_tac);
        ret_val = RRM_SUCCESS;
    }
    else
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_forbidden_ta or p_rrm_forbidden_ta  is NULL");
         ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_forbidden_tac
 *   INPUT      : p_rrm_forbidden_tac_list,p_rrc_forbidden_tac_list
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map forbidden_tac_list_t structure of RRC to RRM  
 *
 *   RETURNS:
 *         rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_forbidden_tac(
    rrm_forbidden_tac_list_t *p_rrm_forbidden_tac_list,
    forbidden_tac_list_t *p_rrc_forbidden_tac_list
    )
{
    U16 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_forbidden_tac_list && RRM_PNULL != p_rrm_forbidden_tac_list)
    {
        p_rrm_forbidden_tac_list->count = p_rrc_forbidden_tac_list->count;
        /*SPR 21848 Start*/
        p_rrm_forbidden_tac_list->p_forbidden_tac=(rrm_forbidden_tac_t *)rrm_mem_get(
                p_rrc_forbidden_tac_list->count*sizeof(p_rrc_forbidden_tac_list->count));
        /*SPR 21848 End*/
        for(index = RRM_ZERO ; index < p_rrc_forbidden_tac_list->count ; index++)
        {
            /*SPR 20589 FIX START*/
            rrm_map_tac(&p_rrm_forbidden_tac_list->p_forbidden_tac[index],
            /*SPR 20589 FIX END*/
                        &p_rrc_forbidden_tac_list->forbidden_tac[index]);
        }
        ret_val = RRM_SUCCESS;
    }
    else
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_forbidden_tac_list or p_rrm_forbidden_tac_list is NULL");
         ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_map_tac
 *   INPUT      : p_rrm_forbidden_tac,p_rrc_forbidden_tac
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map forbidden_tac_t of RRC to RRM  
 *
 *   RETURNS:
 *       rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_tac(
    rrm_forbidden_tac_t *p_rrm_forbidden_tac,
    forbidden_tac_t *p_rrc_forbidden_tac
    )
{
 
    U16 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_forbidden_tac && RRM_PNULL != p_rrm_forbidden_tac)
    {
        for(index = RRM_ZERO ; index < MAX_TAC_SIZE; index++)
        {
            p_rrm_forbidden_tac->tac[index] = p_rrc_forbidden_tac->tac[index];
        }
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR," p_rrc_forbidden_tac or p_rrm_forbidden_tac is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_forbidden_la
 *   INPUT      : p_rrm_forbidden_la,p_rrc_forbidden_la
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Map forbidden_la_t of RRC to RRM  
 *
 *   RETURNS:
 *           rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_rrm_forbidden_la(
    rrm_forbidden_la_t *p_rrm_forbidden_la,
    forbidden_la_t *p_rrc_forbidden_la
    )
{
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_forbidden_la && RRM_PNULL != p_rrm_forbidden_la)
    { 
        rrm_map_rrm_plmn_identity(&p_rrm_forbidden_la->plmn_identity,
                                  &p_rrc_forbidden_la->plmn_identity);
        
        rrm_map_forbidden_lac(&p_rrm_forbidden_la->forbidden_lacs_list,
                              &p_rrc_forbidden_la->forbidden_lacs_list);
        ret_val = RRM_SUCCESS;
    } 
    else
    {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_forbidden_la or p_rrm_forbidden_la is NULL");
         ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_forbidden_lac
 *   INPUT      : p_rrm_forbidden_lac_list,p_rrc_forbidden_lac_list
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *              Map forbidden_lac_list_t of RRC to RRM  
 *
 *   RETURNS    :
 *                rrm_return_et(SUCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_forbidden_lac(
    rrm_forbidden_lac_list_t *p_rrm_forbidden_lac_list, 
    forbidden_lac_list_t *p_rrc_forbidden_lac_list
    )
{
    U16 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_forbidden_lac_list && RRM_PNULL != p_rrm_forbidden_lac_list)
    { 
        p_rrm_forbidden_lac_list->count = p_rrc_forbidden_lac_list->count;
        /*SPR 21848 Start*/
        p_rrm_forbidden_lac_list->p_forbidden_lac=(rrm_forbidden_lac_t *)rrm_mem_get(
                p_rrc_forbidden_lac_list->count*sizeof(rrm_forbidden_lac_t));
        /*SPR 21848 End*/
        for(index = RRM_ZERO ; index < p_rrc_forbidden_lac_list->count ; index++)
        {
            /*SPR 20589 FIX START*/
            rrm_map_lac(&p_rrm_forbidden_lac_list->p_forbidden_lac[index],&p_rrc_forbidden_lac_list->forbidden_lac[index]);
            /*SPR 20589 FIX END*/
        }
        ret_val = RRM_SUCCESS;
    } 
    else
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_forbidden_lac_list or p_rrm_forbidden_lac_list is NULL");
       ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_lac
 *   INPUT      : p_rrm_forbidden_lac,p_rrc_forbidden_lac
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *                Map forbidden_lac_t structure of RRC to RRM  
 *   RETURNS    :
 *              rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_lac(
    rrm_forbidden_lac_t *p_rrm_forbidden_lac,
    forbidden_lac_t *p_rrc_forbidden_lac
    )
{
    rrm_return_et ret_val = RRM_FAILURE;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_forbidden_lac && RRM_PNULL != p_rrm_forbidden_lac)
    {
      for(index = RRM_ZERO; index < MAX_LAC_SIZE; index++)
      {
        p_rrm_forbidden_lac->lac[index] = p_rrc_forbidden_lac->lac[index];
      }
      ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR," p_rrc_forbidden_lac or p_rrm_forbidden_lac is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_ue_proc_ho_command_request
 *   INPUT      : p_rrm_ho_proc_cmd_req,p_rrc_rrm_ue_ho_command_request
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *                Map rrc_rrm_ue_ho_command_request_t structure of RRC to RRM  
 *
 *   RETURNS    :
 *                rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_rrm_ue_proc_ho_command_request(
     rrm_ue_proc_ho_command_request_t *p_rrm_ho_proc_cmd_req,
     rrc_rrm_ue_ho_command_request_t *p_rrc_rrm_ue_ho_command_request
    )
{
    U32 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_rrm_ue_ho_command_request && RRM_PNULL != p_rrm_ho_proc_cmd_req)
    {
        p_rrm_ho_proc_cmd_req->bitmask = p_rrc_rrm_ue_ho_command_request->bitmask;
        p_rrm_ho_proc_cmd_req->ue_index = p_rrc_rrm_ue_ho_command_request->ue_index;
        if(p_rrc_rrm_ue_ho_command_request->bitmask & RRC_RRM_UE_HO_CMD_REQ_NAS_SECURITY_PARAM_PRESENT)
        {
            p_rrm_ho_proc_cmd_req->bitmask |= RRC_RRM_UE_HO_CMD_REQ_NAS_SECURITY_PARAM_PRESENT;
            p_rrm_ho_proc_cmd_req->nas_security_param.nas_msg_length = 
                                          p_rrc_rrm_ue_ho_command_request->nas_security_param.nas_msg_length;
            for(index = RRM_ZERO ; index < p_rrm_ho_proc_cmd_req->nas_security_param.nas_msg_length ; index++)
            {
               p_rrm_ho_proc_cmd_req->nas_security_param.nas_security_param[index] = 
                 p_rrc_rrm_ue_ho_command_request->nas_security_param.nas_security_param[index];
            }
      }
      if(p_rrc_rrm_ue_ho_command_request->bitmask & 
                      RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT)
      {
          p_rrm_ho_proc_cmd_req->bitmask |= 
                      RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT ;
          rrm_map_erab_sub_to_fwd_list(&p_rrm_ho_proc_cmd_req->erab_sub_to_fwd_list , 
                                       &p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list);
      }
      if(p_rrc_rrm_ue_ho_command_request->bitmask & 
                           RRC_RRM_UE_HO_CMD_REQ_ERAB_TO_RELEASE_LIST_PRESENT)
      {
          p_rrm_ho_proc_cmd_req->bitmask |= 
                           RRC_RRM_UE_HO_CMD_REQ_ERAB_TO_RELEASE_LIST_PRESENT ;
          rrm_map_erab_to_release_list(&p_rrm_ho_proc_cmd_req->erab_to_release_list,
                                       &p_rrc_rrm_ue_ho_command_request->erab_to_release_list);
      }
      if(p_rrc_rrm_ue_ho_command_request->bitmask & 
                            RRC_RRM_UE_HO_CMD_REQ_CDMA2000_HO_STATUS_PRESENT)
      {
          p_rrm_ho_proc_cmd_req->bitmask |= 
                            RRC_RRM_UE_HO_CMD_REQ_CDMA2000_HO_STATUS_PRESENT;
          for(index = RRM_ZERO ; index <MAX_CDMA2000_NETWORK_TYPES ; index++)
          {
              p_rrm_ho_proc_cmd_req->cdma2000_ho_status[index] = 
                          p_rrc_rrm_ue_ho_command_request->cdma2000_ho_status[index];
          }
      }
        ret_val = RRM_SUCCESS;
    } 
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR," p_rrc_rrm_ue_ho_command_request or p_rrm_ho_proc_cmd_req is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_erab_sub_to_fwd_list
 *   INPUT      : p_rrm_ue_ho_erab_info_list,p_rrc_erab_info_list
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *                Maps rrm_map_erab_sub_to_fwd_list structure of RRC to RRM
 *
 *   RETURNS    :
 *                rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_erab_sub_to_fwd_list(
    rrm_ue_ho_erab_info_list_t *p_rrm_ue_ho_erab_info_list , 
    rrc_erab_info_list_t *p_rrc_erab_info_list)
{
    U8 index = RRM_NULL;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_erab_info_list && RRM_PNULL != p_rrm_ue_ho_erab_info_list)
    { 
        p_rrm_ue_ho_erab_info_list->erab_count = p_rrc_erab_info_list->erab_count;
        for(index = RRM_ZERO ; index < p_rrc_erab_info_list->erab_count ;index++)
        {
            p_rrm_ue_ho_erab_info_list->drb_sub_to_fwd[index].forward_direction = 
                               p_rrc_erab_info_list->drb_sub_to_fwd[index].forward_direction;
            p_rrm_ue_ho_erab_info_list->drb_sub_to_fwd[index].erab_id = 
                               p_rrc_erab_info_list->drb_sub_to_fwd[index].erab_id;
        }
        ret_val = RRM_SUCCESS;
    } 
    else
    {
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR," p_rrc_erab_info_list or p_rrm_ue_ho_erab_info_list is NULL");
       ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_erab_to_release_list
 *   INPUT      : p_rrm_ue_ho_erab_to_release_list,p_rrc_erab_to_release_list
 *   OUTPUT     : NONE
 *   DESCRIPTION:
 *       Maps rrm_map_erab_to_release_list structure of RRC to RRM  
 *
 *   RETURNS:
 *          rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_erab_to_release_list(
    rrm_ue_ho_erab_to_release_list_t *p_rrm_ue_ho_erab_to_release_list,
    erab_to_release_list_t *p_rrc_erab_to_release_list)
{
    U8 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrc_erab_to_release_list && RRM_PNULL != p_rrm_ue_ho_erab_to_release_list)
    { 
        p_rrm_ue_ho_erab_to_release_list->erab_count = p_rrc_erab_to_release_list->erab_count;
        for(index = RRM_ZERO ; index< p_rrc_erab_to_release_list->erab_count ; index++)
        {
            rrm_map_erab_to_release(&p_rrm_ue_ho_erab_to_release_list->erab_to_release[index],&p_rrc_erab_to_release_list->erab_to_release[index]);
        }
        ret_val = RRM_SUCCESS;
    } 
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR," p_rrc_erab_to_release_list or p_rrm_ue_ho_erab_to_release_list is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_erab_to_release
 *   INPUT      : p_rrm_ue_ho_erab_to_release,p_erab_to_release
 *   OUTPUT     : NONE
 *   DESCRIPTION: 
 *                Maps ho_erab_to_release structure of RRC to RRM  
 *
 *   RETURNS    :
 *                  rrm_return_et(SUCCESS/FAILURE)
 *****************************************************************************/
rrm_return_et rrm_map_erab_to_release(
    rrm_ue_ho_erab_to_release_t *p_rrm_ue_ho_erab_to_release ,
    erab_to_release_t *p_erab_to_release
    )
{
    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_FAILURE;
    if(RRM_PNULL != p_erab_to_release && RRM_PNULL != p_rrm_ue_ho_erab_to_release)
    {
        p_rrm_ue_ho_erab_to_release->erab_id = p_erab_to_release->erab_id;
        p_rrm_ue_ho_erab_to_release->rrm_cause.type = p_erab_to_release->rrm_cause.type;
        p_rrm_ue_ho_erab_to_release->rrm_cause.value = p_erab_to_release->rrm_cause.value;
        ret_val = RRM_SUCCESS;
    } 
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_erab_to_release or p_rrm_ue_ho_erab_to_release  is NULL");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_rrm_ue_proc_ho_failure
 *   INPUT      : p_rrm_ue_proc_ho_failure,p_rrm_ue_ho_failure
 *   OUTPUT     : NONE
 *   DESCRIPTION: maps the value of ue_proc_ho_failure from RRC to RRM
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/

rrm_return_et
rrm_map_rrm_ue_proc_ho_failure(
    rrm_ue_proc_ho_failure_t  *p_rrm_ue_proc_ho_failure,
    rrc_rrm_ho_failure_t       *p_rrm_ue_ho_failure
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrm_ue_proc_ho_failure && RRM_PNULL != p_rrm_ue_ho_failure)
    {
        p_rrm_ue_proc_ho_failure->ue_index = p_rrm_ue_ho_failure->ue_index;
        p_rrm_ue_proc_ho_failure->rrm_cause.type = p_rrm_ue_ho_failure->rrm_cause.type;
        p_rrm_ue_proc_ho_failure->rrm_cause.value = p_rrm_ue_ho_failure->rrm_cause.value;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrm_ue_proc_ho_failure or p_rrm_ue_ho_failure is null");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_map_lai_info
 *   INPUT      : p_rrc_rrm_lai_info,p_rrm_lai_info
 *   OUTPUT     : NONE
 *   DESCRIPTION: maps the value of lai_info_t from RRM to RRC
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et rrm_map_lai_info(
         rrm_lai_info_t *p_rrc_rrm_lai_info,
         lai_info_t     *p_rrm_lai_info)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_rrm_lai_info && RRM_PNULL != p_rrc_rrm_lai_info)
    {
        rrm_map_rrm_plmn_identity((rrm_plmn_identity_t *)(&p_rrc_rrm_lai_info->plmn_identity),&p_rrm_lai_info->plmn_identity);
        for(index = RRM_ZERO ;index < RRM_OAM_MAX_NUM_LAC_OCTETS ; index++)
        {
            p_rrc_rrm_lai_info->location_area_code[index] =p_rrm_lai_info->lac[index];
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_rrc_rrm_lai_info or p_rrm_lai_info is null");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG 680 FIX END */
/* SPR 12512 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_ue_sync_status_ind
 *   DESCRIPTION:
 *   Parse the UE SYNC status ind request
 *   RETURNS:
 *   RRM_SUCCESS on Success
 *   RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_parse_ue_sync_status_ind(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et                            ret_val = RRM_SUCCESS;
    S32                                      length_read = RRM_NULL;
    rrm_ue_sync_staus_ind_data_t             *p_sync_status_ind_data = RRM_PNULL;
    rrc_rrm_ue_sync_status_t                 rrc_ue_sync_status_ind;

    RRM_UT_TRACE_ENTER();
    /** Parse the ue ERAB release request */

    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_sync_status(
                &rrc_ue_sync_status_ind,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))

    {
        p_sync_status_ind_data = (rrm_ue_sync_staus_ind_data_t *)
            rrm_mem_get(sizeof(rrm_ue_sync_staus_ind_data_t));
        
		if(RRM_PNULL == p_sync_status_ind_data)
        {
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_ERROR,
                    "rrm_rrc_parse_sync_status_ind: Mem allocation failed");
            return RRM_FAILURE;
        }

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                "[UE:%d],Parsed successfully RRC_RRM_SYNC_STATUS_IND",rrc_ue_sync_status_ind.ue_index);

        p_rrm_ue_rrc_msg->ue_index = rrc_ue_sync_status_ind.ue_index;

        p_sync_status_ind_data->ue_sync_status = rrc_ue_sync_status_ind.rrc_rrm_ue_sync_status;
        p_rrm_ue_rrc_msg->p_msg_data = (void *)p_sync_status_ind_data;
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,
                p_rrm_uem_facility_name, RRM_ERROR,"Failed parse RRC_RRM_SYNC_STATUS_IND");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_ue_reconfig_req_on_ue_insync
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_build_and_send_ue_reconfig_req_on_ue_insync(
                                  rrm_ue_context_t *p_rrm_ue_context
                                  )
{

    rrm_return_et                               ret_val = RRM_FAILURE;
    U16                                         transaction_id = RRM_1;
    rrc_phy_cqi_reporting_t                     rrm_cqi_info_ue_reconfig = {RRM_ZERO};
    rrm_bool_et                                 reconfig_ue = RRM_FALSE;
    rrc_rrm_ue_reconfig_req_t                   rrc_rrm_ue_reconfig_req = {RRM_ZERO};
    rrc_phy_physical_config_dedicated_t         *p_rrc_phy_physical_config_dedicated = RRM_PNULL;
    U8                                          transmission_mode= RRM_ZERO;


    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(&rrc_rrm_ue_reconfig_req, RRM_ZERO, sizeof(rrc_rrm_ue_reconfig_req_t));

    rrc_rrm_ue_reconfig_req.ue_index = p_rrm_ue_context->ue_index;

    rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |=
        RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;
    /*Bug 353 Fix Start */
    transmission_mode =  p_rrm_ue_context->ue_phy_config_information.ue_antenna_information.transmission_mode;
    /*Bug 353 Fix End */
    ret_val = rrm_cqi_information_reconfig_req(p_rrm_ue_context,
            transmission_mode,
            &rrm_cqi_info_ue_reconfig);
    if( RRM_SUCCESS == ret_val )
    {

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
            RRC_PHY_CQI_REPORTING_PRESENT;
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_reporting =
            rrm_cqi_info_ue_reconfig;
        p_rrc_phy_physical_config_dedicated =
            &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated);
        p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated.bitmask = 0x00;

        if(RRM_TRUE == rrm_cellm_get_srs_status(p_rrm_ue_context->cell_index))
        {
            /* Filling the sounding reference signal parameters */
            /* SRS start */
            p_rrc_phy_physical_config_dedicated->bitmask |=
                RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;
			/*spr_19392_changes_start*/
			ret_val = rrm_rrc_ue_adm_resp_fill_sounding_reference_signal
                (&(p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated),
                 p_rrm_ue_context);
			if(RRM_SUCCESS == ret_val)
			{
				p_rrc_phy_physical_config_dedicated->bitmask |=
					RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;
			}
			/*spr_19392_changes_end*/

        }
        /* SRS end */
        p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT;
        rrm_rrc_ue_adm_resp_fill_scheduling_request_config
            (&(p_rrc_phy_physical_config_dedicated->scheduling_request_config),\
             p_rrm_ue_context);

        reconfig_ue = RRM_TRUE;
    }
    if(reconfig_ue)
    {

        ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                transaction_id,
                 p_rrm_ue_context->cell_index);
        if(RRM_SUCCESS == ret_val)
        {
            /*set the UE sub state*/
            RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_RECONFIG_ONGOING);

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Unable to send UE reconfig request to RRC.");
        }
        /*send the ue reconfig request to RRC*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 12512 Fix End */

/* CA Scell Release functions : Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_remove_scell_data_from_ue_context
 *   INPUT      : p_rrm_ue_context, num_of_scell, p_arr_cell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Removes Scell data from UE context.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_remove_scell_data_from_ue_context(
rrm_ue_context_t     *p_rrm_ue_context,
U8                    num_of_scell,
rrm_cell_index_t     *p_arr_cell_index)
{
    U8 count    =  RRM_ZERO;
    U8 count2   =  RRM_ZERO;
    rrm_cell_context_t *p_cell_ctx= RRM_PNULL;

    
    RRM_UT_TRACE_ENTER();
    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65812:start*/
    if (RRM_PNULL == p_cell_ctx )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*CID 65812:end*/

    for(count2 = RRM_ZERO; count2 < num_of_scell; count2++)
    {
        for(count = RRM_ZERO; count < RRM_MAX_SCELL; count++)
        {
	    if(p_arr_cell_index[count2] == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index)
	    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                  "SCell Cell Index: %d, SCell Index: %d Removed.",
                                   p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index,
                                   p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index);
			p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_state = SCELL_DEACTIVE; /* CID: 60874 - Fix */
			p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index = RRM_ZERO;
			p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index = RRM_INVALID_CELL_ID;
            /*CA Stage2: start*/

            if ((INVALID_FRAME != p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].cqi_params.cqi_res_row )&&
                    (INVALID_SLOT != p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].cqi_params.cqi_res_col))
            {
                rrm_cellm_mark_cqi_index_free(p_rrm_ue_context->cell_index,
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].cqi_params.cqi_res_row,
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].cqi_params.cqi_res_col);

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "CA:Releasing CQI Resources released for [UE:%d]Row(%d), Column(%d)",
                        p_rrm_ue_context->ue_index,
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].cqi_params.cqi_res_row,
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].cqi_params.cqi_res_col);
            }
            /* CA TDD changes start */
            /* We have to release resources for second PUCCH resource only if
             * resource for n1_pucch_an_cs_second_index was reserved. Earlier no
             * such check was required because we always use to reserve two
             * resources but now in some cases(1 TB case) we will be reserving only one
             * resource.*/
            p_cell_ctx->sps_n1_pucch_an_marked_st[p_rrm_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[count].ue_format1b_resc.n1_pucch_an_cs_first_index]  = RRM_ZERO;
            /*p_cell_ctx->sps_n1_pucch_an_marked_st[p_rrm_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[count].ue_format1b_resc.n1_pucch_an_cs_second_index] = RRM_ZERO;*/
            /* Coverity 69718, 69722 Fix Start */
            if (RRM_OUT_OF_RANGE_TWO_BYTE != 
                    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].
                    ue_format1b_resc.n1_pucch_an_cs_second_index) 	
            /* Coverity 69718, 69722 Fix End */
            {
            p_cell_ctx->sps_n1_pucch_an_marked_st[p_rrm_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[count].ue_format1b_resc.n1_pucch_an_cs_second_index] = RRM_ZERO;

            }
            /* CA TDD changes end */
            if(p_cell_ctx->operator_info.ca_config.is_ca_eligible)
            {
                p_cell_ctx->sps_n1_pucch_an_marked_st[p_rrm_ue_context->ue_sps_data.pucch_an_list_resource_index]=RRM_ZERO;
                p_cell_ctx->sps_n1_pucch_an_marked_st[p_rrm_ue_context->ue_sps_data.pucch_an_list_resource_index + RRM_ONE]=RRM_ZERO;
            }

            /*CA Stage2: end*/
            p_rrm_ue_context->ue_scell_add_params.count -= RRM_ONE;

            }
            }
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: build_and_send_scell_release_to_ue
 *   INPUT      : p_rrm_ue_context, scell_rel_count, p_scell_cell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Creates UE Reconfig Req. for Scell release.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
build_and_send_scell_release_to_ue(
rrm_ue_context_t            *p_rrm_ue_context,
U8                           scell_rel_count,
rrm_cell_index_t             *p_scell_cell_index,
/*SPR 13316:start*/
U16                          transaction_id)
/*SPR 13316:end*/
{
    rrm_return_et                             ret_val = RRM_FAILURE;
    rrc_rrm_ue_reconfig_req_t                 rrc_rrm_ue_reconfig_req = {RRM_ZERO};
    U8                                        scell_count = RRM_ZERO;
    U8                                        ue_scell_count = RRM_ZERO;
    U8                                        count = RRM_ZERO;
    U8                                        scell_cell_index = RRM_ZERO;
    U8                                        scell_index = RRM_ZERO;
    U8                                        scell_counter = RRM_ZERO;
    rrm_bool_et                               scell_found = RRM_FALSE;
    rrm_cell_index_t                          scells_removed[RRM_MAX_SCELL] = {RRM_ZERO}; 
    rrm_ue_procedure_queue_t                  proc_queue = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();
    /*KLOC FIX */
    rrc_rrm_ue_reconfig_req.bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_SCELL_CONFIG_PRESENT;

    rrc_rrm_ue_reconfig_req.ue_index = p_rrm_ue_context->ue_index;

    rrc_rrm_ue_reconfig_req.scell_config.bitmask |= RRM_SCELL_RELEASE_LIST_PRESENT;

    ue_scell_count = p_rrm_ue_context->ue_scell_add_params.count;
    for(count = RRM_ZERO; ((count < scell_rel_count) &&(count < MAX_SCELL)); count++)   /* Klocwork_fix_27_aug */
    {
        rrc_rrm_ue_reconfig_req.scell_config.scell_release_list.rrc_scell_to_release[count].bitmask = RRM_ZERO;
        for(scell_count = RRM_ZERO; scell_count < ue_scell_count; scell_count++)
        {
            if(p_scell_cell_index[count] == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_cell_index)
            {
                scell_index = p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_index;
                scell_cell_index = p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_cell_index;
                scell_found = RRM_TRUE;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "SCell Index sent to UE for deletion: %d ", scell_index);
                break;
            }
        }
        if(scell_found == RRM_TRUE)
        {
            rrc_rrm_ue_reconfig_req.scell_config.scell_release_list.count = (count + RRM_ONE);
            rrc_rrm_ue_reconfig_req.scell_config.scell_release_list.rrc_scell_to_release[count].bitmask |= RRM_SCELL_TO_RELEASE_CELL_INDEX_PRESENT;
            rrc_rrm_ue_reconfig_req.scell_config.scell_release_list.rrc_scell_to_release[count].cell_index = scell_cell_index;
            rrc_rrm_ue_reconfig_req.scell_config.scell_release_list.rrc_scell_to_release[count].scellIndex = scell_index;
            /* STAGE3: Start */
            scells_removed[scell_counter] = scell_cell_index;
            scell_counter++;
            /* STAGE3: End */
            ret_val = RRM_SUCCESS;
        }
    }

   
    /*cov fix start 63894 */
    if((ret_val == RRM_SUCCESS) && (p_rrm_ue_context->current_procedure.state == RRM_UE_ERB_NULL))
    {
    /*cov fix end 63894 */
        ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                transaction_id,
                p_rrm_ue_context->cell_index);

        if(RRM_SUCCESS == ret_val)
        {
            RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_SCELL_PROCEDURE_ONGOING);
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Scell Counter: [%d] ", scell_counter);
            //Remove SCELL data from UE Context.
            rrm_remove_scell_data_from_ue_context(p_rrm_ue_context,
                    scell_counter,
                    scells_removed);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "UE reconfig request sent to RRC for SCell Deletion. ");
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Unable to send UE reconfig request to RRC.");
            ret_val = RRM_FAILURE;
        }
    }
    else if((ret_val == RRM_SUCCESS) && (p_rrm_ue_context->current_procedure.state != RRM_UE_ERB_NULL))
    {
        /* Enqueue RRC_RRM_UE_RECONFIG_REQ in case UE reconfig could not be sent at first attempt */
        proc_queue.api_id = RRC_RRM_UE_RECONFIG_REQ; 
        proc_queue.p_proc_data = (rrm_void_t *)(&rrc_rrm_ue_reconfig_req);
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue, p_rrm_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,\
                "Unable to send or enqueue UE reconfig request to RRC.");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_to_remove_list
 *   INPUT      : p_rrm_ue_context, pcell_index, num_of_scell, p_arr_cell_index
 *                ca_bitmask  
 *   OUTPUT     : None
 *   DESCRIPTION: Extract UE context from Scell list & send for the Scell Release
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
/*If want to release Scell fron some specific UE then send valid UE Context as input,
 *eg.: In case of change of UE CSG status not compatible with SCell CSG status.
 *If want to release all UEs associated with some SCell then send UE Context as RRM_PNULL
 *eg.: Incase of SCell is deleted, blocked, Cell Type changed to Non-CA and blacklisted.
*/

rrm_return_et
rrm_fill_scell_to_remove_list(
rrm_ue_context_t            *p_rrm_ue_context,
rrm_cell_index_t             pcell_index,
U8                           num_of_scell,
rrm_cell_index_t            *p_arr_cell_index,
U64                          ca_bitmask,
/*SPR 13316:start*/
U16                          trans_id
/*SPR 13316:end*/
)
{
    rrm_return_et                             ret_val = RRM_SUCCESS;
    U8                                        count = RRM_ZERO;
    U8                                        curr_scell_index = RRM_ZERO;
    rrm_cell_context_t                        *pcell_ctx = RRM_PNULL;
    rrm_ue_context_t                          *p_rrm_ue_ctxt = RRM_PNULL;
    rrm_cell_index_t                          arr_cell_index_rel[RRM_MAX_SCELL]; 
    YLNODE                                    *p_node = RRM_PNULL;
    /* BUG_11907_FIX_START */
    /* +- SPR 18268 */
    U16                                        scell_ue_count = RRM_ZERO;
    /* +- SPR 18268 */
    /* BUG_11907_FIX_END */


    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        /* coverity:65754 start*/
        p_rrm_ue_context->ue_scell_add_params.bitmask |= RRM_SCELL_DELETE_SCENARIO;
        p_rrm_ue_context->ue_scell_add_params.scell_cell_index = p_arr_cell_index[RRM_ZERO]; 
        /* coverity:65754 end*/
        /*SPR 13316:start*/
        if(RRM_FAILURE == build_and_send_scell_release_to_ue(p_rrm_ue_context, num_of_scell, p_arr_cell_index, trans_id))
        /*SPR 13316:end*/
        {
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
        if(num_of_scell <= RRM_MAX_SCELL)
        {
            for(count = RRM_ZERO; count < num_of_scell; count++)
            {
                curr_scell_index = p_arr_cell_index[count];
                /*Traverse Scell array and when SCell matches with the SCell sent to the fuction as parameter,
                  then traverse the UE Context associated to that SCell and get the SCell released from all UEs
                  one by one*/
                pcell_ctx = rrm_cellm_get_cell_context(pcell_index);
                /*CID 65813:start*/
                if (RRM_PNULL == pcell_ctx )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"pcell_ctx is null");
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                /*CID 65813:end*/

                if(pcell_ctx->scell_info[curr_scell_index].scell_index == curr_scell_index)
                {
                    p_node = ylFirst(&(pcell_ctx->scell_info[curr_scell_index].list));
                    /* BUG_11907_FIX_START */
                    scell_ue_count = ylCount(&(pcell_ctx->scell_info[curr_scell_index].list));
                    /* BUG_11907_FIX_END */

                    while(p_node)
                    {
                        p_rrm_ue_ctxt = ( (rrm_scell_node_t *)p_node)->p_ue_context; 
                        /* CID: 61287 */
                        /* coverity:65754 start*/
                        if (RRM_PNULL != p_rrm_ue_ctxt)
                        {
                        /* coverity:65754 end*/
                            p_rrm_ue_ctxt->ue_scell_add_params.bitmask |= RRM_SCELL_DELETE_SCENARIO;
                            p_rrm_ue_ctxt->ue_scell_add_params.scell_cell_index = curr_scell_index; 
                            if( ca_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_COMMON_SCELL )
                            {
                                /* A flag will be set in UE context in the case when Scell is to be deleted & then added again
                                   on UE along with the Scell's Cell Index & these params will be used when UE Reconfig Resp. is 
                                   success for scell delete.
                                   In case UE Reconfig Resp. is failure then nothing has to be done for scell addition and the 
                                   Flag set here & Scell value needs to be reset. for the UE. */
                                p_rrm_ue_ctxt->ue_scell_add_params.bitmask |= RRM_SCELL_RADIO_RESOURCE_CONFIG_COMMON_PARAM_CHANGE;
                            }
                            arr_cell_index_rel[RRM_ZERO] = curr_scell_index;
                            /*SPR 13316:start*/
                            ret_val = build_and_send_scell_release_to_ue(p_rrm_ue_ctxt, RRM_ONE, arr_cell_index_rel, trans_id);
                            /*SPR 13316:end*/
                            if(ret_val == RRM_SUCCESS)
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                        "Scell with cell Index %d released for [UE:%d]",
                                        curr_scell_index, p_rrm_ue_ctxt->ue_index);
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                        "UE Reconfig failed for SCell Release for Scell with cell Index %d",
                                        curr_scell_index);
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                    "UE not in correct state for UE Reconfig. Current UE state is other than RRM_UE_ERB_NULL");
                        }
                        p_node = ylNext(p_node);
                    }
                /* BUG_11907_FIX_START */

                    if ((ca_bitmask & RRM_CA_CELL_DELETE_BITMASK) && (scell_ue_count == RRM_ZERO))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                    "UE count is zero");
                        /*SPR 13316:start*/
                        rrm_send_cell_info_change_ind_resp(pcell_index , curr_scell_index, RRM_SUCCESS, trans_id);
                        /*SPR 13316:end*/
                    }    
                }
                else 
                {   
                    /* SPR 21251 +- */
                    if( ca_bitmask & RRM_CA_CELL_DELETE_BITMASK )
                    {
                        /* build & send response to CM */
                        /*SPR 13316:start*/
                        rrm_send_cell_info_change_ind_resp(pcell_index , curr_scell_index, RRM_SUCCESS,trans_id);
                        /*SPR 13316:end*/
                    }
                }
                /* BUG_11907_FIX_END */
            }
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* CA Scell Release functions : End */

/* CA Scell Addition functions : Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_non_ul_config_pdsch_config_common
 *   INPUT      : p_pdsch_config_common, scell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Fill Scell's Non-Ul config pdsch config common params
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_non_ul_config_pdsch_config_common(
pdsch_config_common_t *p_pdsch_config_common,
rrm_cell_index_t scell_index)
{
    rrm_return_et                           ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_pdsch_config_common->ref_signal_power = rrm_cellm_get_scell_non_ul_config_pdsch_ref_signal_power(scell_index);

    p_pdsch_config_common->pb = rrm_cellm_get_scell_non_ul_config_pdsch_pb(scell_index);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_non_ul_config_phich_config
 *   INPUT      : p_phich_config, scell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Fill Scell's Non-Ul config phich config params in UE Reconfig
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_non_ul_config_phich_config(
phich_config_t *p_phich_config,
rrm_cell_index_t scell_index)
{
    rrm_return_et                           ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_phich_config->phich_resource = rrm_cellm_get_scell_non_ul_config_phich_resource(scell_index);

    p_phich_config->phich_duration = rrm_cellm_get_scell_non_ul_config_phich_duration(scell_index);
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_cqi_reporting_selective_scheduling
 *   INPUT      : p_rrc_phy_cqi_reporting_periodic_setup_param,
 *                p_ue_profile_phy_cqi_reporting_periodic_param,
 *                p_rrm_ue_cntxt,transmission_mode,
 *                rrm_freq_selective_sched
 *   OUTPUT     : None
 *   DESCRIPTION: Fill r-10 Periodic CQI params for Scell
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_cqi_reporting_selective_scheduling(rrc_phy_cqi_report_periodic_r10_setup_t 
                                                                               *p_rrc_phy_cqi_reporting_periodic_setup_param ,
                                          rrm_ul_dl_freq_selective_sched_et    rrm_freq_selective_sched ,
                                          rrm_cell_index_t                     scell_index , 
                                          rrm_ue_context_t                     *p_rrm_ue_cntxt)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if ((RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH == rrm_freq_selective_sched) ||
            (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY == rrm_freq_selective_sched))
    {
        /* Wide Band CQI start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"Wide Band Configured");
        p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_format_ind_periodic.bitmask |= 
            RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_PRESENT;

    }
    else if ((RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY == rrm_freq_selective_sched) ||
            (RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH == rrm_freq_selective_sched))
    {
        if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[scell_index]->ran_info.rf_params.\
                rf_configurations.dl_bandwidth == RRM_OAM_BW_N_6)
        {
            /*Aperiodic CQI/PMI/RI reporting are not supported for DL RB's
             *less than 7 (i.e. when Cell bandwidth configured as 1.4 Mhz).
             *Refer spec 36.213 v 9.2.0 sec 7.2.1
             */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                    "Aperiodic mode not supported for DL RB's less than 7");
            ret_val = RRM_SUCCESS;
        }
        else
        {
            if((rrm_is_set_fgi_bit(p_rrm_ue_cntxt,RRM_TWO)) == RRM_TRUE)
            {
                p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_format_ind_periodic.
                    bitmask |= RRC_PHY_CQI_FORMAT_IND_PERIODIC_SUBBAND_CQI_PRESENT;
                /*configuration from OAM*/
                p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_format_ind_periodic.
                    cqi_format_ind_subband.k = rrm_cellm_subband_cqi_param(p_rrm_ue_cntxt->cell_index);
                p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_format_ind_periodic.
                    cqi_format_ind_subband.periodicy_factor = 
                    rrm_cellm_subband_periodic_reporting(p_rrm_ue_cntxt->cell_index);
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Sub Band Configured:- k(%d)", 
                        p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_format_ind_periodic.
                        cqi_format_ind_subband.k);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_cqi_reporting_periodic_param_scell_r10
 *   INPUT      : p_rrc_phy_cqi_reporting_periodic_setup_param,
 *                p_ue_profile_phy_cqi_reporting_periodic_param,
 *                p_rrm_ue_cntxt,transmission_mode,
 *                rrm_freq_selective_sched
 *   OUTPUT     : None
 *   DESCRIPTION: Fill r-10 Periodic CQI params for Scell
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_cqi_reporting_periodic_param_scell_r10(
    rrc_phy_cqi_report_periodic_r10_setup_t *p_rrc_phy_cqi_reporting_periodic_setup_param,
         /*SPR 17777 +-*/
    rrm_ue_context_t *p_rrm_ue_cntxt,
    U8          transmission_mode,
    rrm_ul_dl_freq_selective_sched_et
                    rrm_freq_selective_sched,
    rrm_cell_index_t scell_index)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = RRM_PNULL;
    rrm_cqi_reporting_mode_et rrm_enable_cqi_reporting = RRM_DISABLE_CQI_REPORTING;
    U16           ri_index          = INVALID_RI_INDEX;
    U8            cqi_res_index     = INVALID_RES_INDEX;
    U16           cqi_config_index  = INVALID_CQI_CFG_INDEX;
    U8            row_num           = INVALID_FRAME;
    U16           col_num           = INVALID_SLOT;
    U8            scell_array_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
   
   /*Find scell context and chechk cqi reporting mode configured*/
    if (RRM_FAILURE == rrm_find_scell_index_position(scell_index, &(p_rrm_ue_cntxt->ue_scell_add_params), &scell_array_index))
    {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "Scell_index[%u] not found in ue_scell_add_params for [UE:%u]", scell_index, p_rrm_ue_cntxt->ue_index) ;
        return RRM_FAILURE;
    }
    p_ue_service_profile = rrm_cellm_get_ue_service_profile(scell_index);
    rrm_enable_cqi_reporting = p_ue_service_profile->radio_res_config.
                               physical_config_dedicated.cqi_reporting.
                                                          rrm_cqi_reporting_mode_configured;
    
    
    if (RRM_DISABLE_CQI_REPORTING != rrm_enable_cqi_reporting)
    {
        row_num             = INVALID_FRAME;
        col_num             = INVALID_SLOT;
        p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.cqi_res_row = row_num;
        p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.cqi_res_col = col_num;

        /* SPR 19359 Fix Start */
        /* CQI Config Index allocated to UE for PCELL is stored in cqi_config_index so that
         * same cqi_config_index is not allocated to UE for Scell */
        cqi_config_index = p_rrm_ue_cntxt->cqi_params.cqi_pmi_config_index;
        /* SPR 19359 Fix End */        
        if( RRM_SUCCESS == rrm_cellm_get_cqi_resources( p_rrm_ue_cntxt->cell_index, 
                    &cqi_res_index, &cqi_config_index,
                    &ri_index, p_rrm_ue_cntxt->sr_params.sr_configuration_index, 
                    &row_num, &col_num, 
                    /* SPR14123start */
    /* eICIC_PHASE_1_2_CHANGES_START */
                    RRM_EICIC_ABS_NULL))
    /* eICIC_PHASE_1_2_CHANGES_END*/
                    /* SPR14123end*/
        {
            /* Store cqi_res_index and cqi_config_index in UE context */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                    "cqi_pucch_res_index(%d), cqi_config_index(%d),ri_index(%d),row_num(%d), col_num(%d)", 
                    cqi_res_index, cqi_config_index, ri_index, row_num, col_num);
            p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_pucch_resource_index = cqi_res_index;
            p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_pmi_config_index = cqi_config_index;
            if ((transmission_mode == TRANSMISSION_MODE_TM3) ||
                    (transmission_mode == TRANSMISSION_MODE_TM4) ||
                    (transmission_mode == TRANSMISSION_MODE_TM8_V920))
            {
                p_rrc_phy_cqi_reporting_periodic_setup_param->ri_config_index = ri_index;
                p_rrc_phy_cqi_reporting_periodic_setup_param->bitmask |= RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT;
                p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.
                    ri_index = ri_index;
            }
            /*Storing the resources in ue_context*/
            p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.
                                 cqi_pucch_res_index = cqi_res_index;
            p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.
                                 cqi_pmi_config_index = cqi_config_index;
            p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.cqi_res_row = row_num;
            p_rrm_ue_cntxt->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].cqi_params.cqi_res_col = col_num;

            /*For SCells this field is not applicable and the UE shall ignore the value*/
            p_rrc_phy_cqi_reporting_periodic_setup_param->simultaneous_ack_nack_cqi = RRC_FALSE;
            p_rrc_phy_cqi_reporting_periodic_setup_param->cqi_format_ind_periodic.bitmask = RRM_ZERO;
            
            /*Klockwork_fix_start*/
            rrm_fill_cqi_reporting_selective_scheduling(p_rrc_phy_cqi_reporting_periodic_setup_param ,
                                           rrm_freq_selective_sched ,scell_index ,p_rrm_ue_cntxt);
            /*Klockwork_fix_end*/

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,"CQI resources could not be allocated.");
        }
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_cqi_reporting_periodic_scell_r10
 *   INPUT      : p_rrc_phy_cqi_reporting_periodic,
 *                p_ue_profile_phy_cqi_reporting_periodic,
 *                p_rrm_ue_cntxt,
 *                transmission_mode,
 *                rrm_freq_selective_sched
 *   OUTPUT     : None 
 *   DESCRIPTION: Fills r-10 CQI Reporting parameters for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_ue_fill_cqi_reporting_periodic_scell_r10(
    rrc_phy_cqi_report_periodic_r10_t *p_rrc_phy_cqi_reporting_periodic,
    rrc_phy_cqi_reporting_periodic_ue_service_profile_t
                           *p_ue_profile_phy_cqi_reporting_periodic,
    rrm_ue_context_t
                           *p_rrm_ue_cntxt,
    U8                     transmission_mode,
    rrm_ul_dl_freq_selective_sched_et
                           rrm_freq_selective_sched,
    rrm_cell_index_t       scell_index)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    
    p_rrc_phy_cqi_reporting_periodic->bitmask = RRM_ZERO;
    if(p_ue_profile_phy_cqi_reporting_periodic->bitmask &
       RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT)
    {
        p_rrc_phy_cqi_reporting_periodic->bitmask |= RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT;
        p_rrc_phy_cqi_reporting_periodic->request_type = RRM_ONE;
        ret_val = rrm_fill_cqi_reporting_periodic_param_scell_r10(&(p_rrc_phy_cqi_reporting_periodic->setup),
         /*SPR 17777 +-*/
				      p_rrm_ue_cntxt,
				      transmission_mode,
				      rrm_freq_selective_sched,scell_index);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_ue_fill_cqi_reporting_scell_r10
 *   INPUT      : p_rrc_phy_cqi_reporting, p_ue_profile_phy_cqi_reporting,
 *                p_rrm_ue_cntxt, transmission_mode, p_scell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Fills r-10 CQI Reporting parameters for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_rrc_ue_fill_cqi_reporting_scell_r10(
    rrc_cqi_report_config_scell_r10_t              *p_rrc_phy_cqi_reporting,
    rrc_phy_cqi_reporting_ue_service_profile_t     *p_ue_profile_phy_cqi_reporting,
    rrm_ue_context_t                               *p_rrm_ue_cntxt,
    U8                                              transmission_mode,
    rrm_cell_index_t                                scell_index)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U32                             aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_phy_cqi_reporting->bitmask = RRM_ZERO;

    p_rrc_phy_cqi_reporting->nomPDSCH_RS_EPRE_Offset =
        p_ue_profile_phy_cqi_reporting->nom_pdsch_rs_epre_offset; 
    
    if((p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
       (p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED))
    {
       if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[scell_index]->ran_info.rf_params.\
                              rf_configurations.dl_bandwidth == RRM_OAM_BW_N_6)
       {
	   /*Aperiodic CQI/PMI/RI reporting are not supported for DL RB's
	    *less than 7 (i.e. when Cell bandwidth configured as 1.4 Mhz).
	    *Refer spec 36.213 v 10.11.0 sec 7.2.1
	    */
	   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
		   "Aperiodic mode not supported for DL RB's less than 7");
	   ret_val = RRM_SUCCESS;
       }
       else {
           p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(scell_index);
           ret_val = rrm_assign_aperiodic_mode_from_tm_mode_r10(
						  p_rrm_ue_cntxt,
						  p_ue_profile_phy_cqi_reporting->rrm_ul_dl_freq_selective_sched,
						  transmission_mode,
						  &aperiodic_mode,
                                                  p_rrm_tm_mode_additional_info);
           if(RRM_SUCCESS == ret_val)
           {
               p_rrc_phy_cqi_reporting->bitmask |=
                     RRM_SCELL_CQI_REPORT_CONFIG_APERIODIC_PRESENT;
	   
               RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
		         "Aperiodic mode selected : [%d]", aperiodic_mode);

               p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic = aperiodic_mode;
           }
       }
    }

    if((p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
       (p_ue_profile_phy_cqi_reporting->rrm_cqi_reporting_mode_configured == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED) )
    {
        ret_val =  rrm_ue_fill_cqi_reporting_periodic_scell_r10(
                          &(p_rrc_phy_cqi_reporting->cqi_report_periodic_r10),
                          &(p_ue_profile_phy_cqi_reporting->cqi_reporting_periodic),
                          p_rrm_ue_cntxt, transmission_mode,
                          p_ue_profile_phy_cqi_reporting->rrm_ul_dl_freq_selective_sched, scell_index);

        if(RRM_SUCCESS == ret_val)
           {
               p_rrc_phy_cqi_reporting->bitmask |= RRM_SCELL_CQI_REPORT_CONFIG_PERIODIC_PRESENT;
           }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_cqi_report_config_v920
 *   INPUT      : , scell_index, p_rrm_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION: Fills r-10 CQI Reporting parameters for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t
rrm_fill_cqi_report_config_r10(rrc_cqi_report_config_scell_r10_t *p_cqi_report_config_scell,
         /*SPR 17777 +-*/
                                rrm_cell_index_t                   scell_index,
                                U8                                 transmission_mode)
{
    RRM_UT_TRACE_ENTER();
    const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info = RRM_NULL;
    p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(scell_index);

    if((transmission_mode == TRANSMISSION_MODE_TM8_V920) && 
       (p_rrm_tm_mode_additional_info->enable_pmi_ri_report_r9 == RRM_TRUE))
    {
        p_cqi_report_config_scell->bitmask = RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT;
        p_cqi_report_config_scell->cqi_report_pmi_ri_report_r10 = 
                                             PMI_RI_REPORT_R9_SETUP; 
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: fill_rrc_cqi_report_config_scell_r10
 *   INPUT      : p_cqi_report_config_scell, scell_index, p_rrm_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION: Fills r-10 CQI Reporting parameters for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_rrc_cqi_report_config_scell_r10(
rrc_cqi_report_config_scell_r10_t *p_cqi_report_config_scell,
rrm_cell_index_t                   scell_index,
rrm_ue_context_t                  *p_rrm_ue_context,
U8                                 transmission_mode)
{
    rrm_return_et                      ret_val = RRM_SUCCESS;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = RRM_PNULL;
    rrc_phy_physical_config_dedicated_ue_service_profile_t
        *p_ue_profile_physical_config_dedicated = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_ue_service_profile = rrm_cellm_get_ue_service_profile(scell_index);
    p_ue_profile_physical_config_dedicated = &(p_ue_service_profile->radio_res_config.physical_config_dedicated);

    if(RRM_DISABLE_CQI_REPORTING !=
            p_ue_profile_physical_config_dedicated->cqi_reporting.
            rrm_cqi_reporting_mode_configured)
    {   
        if(p_ue_profile_physical_config_dedicated->bitmask &
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT)
        {
            ret_val = rrm_rrc_ue_fill_cqi_reporting_scell_r10(p_cqi_report_config_scell,
                    &(p_ue_profile_physical_config_dedicated->cqi_reporting),
                    p_rrm_ue_context,
                    transmission_mode,
                    scell_index);
        }
        /* Fills PMI-RI reporting bitmask & IE */
        rrm_fill_cqi_report_config_r10( p_cqi_report_config_scell,
         /*SPR 17777 +-*/
                                        scell_index,
                                        transmission_mode );
    }
    else
    {
        p_cqi_report_config_scell->bitmask = RRM_ZERO;

        p_cqi_report_config_scell->nomPDSCH_RS_EPRE_Offset =
            p_ue_profile_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_radio_res_dedicated_scell_non_ul_config
 *   INPUT      : p_radio_res_dedicated_scell_non_ul_config, scell_index,
 *                ca_params_bitmask
 *   OUTPUT     : None
 *   DESCRIPTION: Fills Radio Resource Dedicated Non-UL config params for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_radio_res_dedicated_scell_non_ul_config(
rrc_radio_res_dedicated_scell_non_ul_config_t *p_radio_res_dedicated_scell_non_ul_config,
rrm_ue_context_t                              *p_rrm_ue_context,
rrm_cell_index_t                               scell_index,
U64                                            ca_params_bitmask)
{
    rrm_return_et                      ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if(ca_params_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_NON_UL_TM_MODE_CHANGE)
    {
        if(RRM_SUCCESS == fill_antenna_info_dedicated_r10(&(p_radio_res_dedicated_scell_non_ul_config->antenna_info_dedicated_r10),
                    scell_index, p_rrm_ue_context))
        {
            p_radio_res_dedicated_scell_non_ul_config->bitmask |= RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT;
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Radio Resource Dedicated UL Config for SCell's Antenna Info Dedicated Failed");
        }
    }
    if(ca_params_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_NON_UL_PA_CHANGE)
    {
        if((RRM_SUCCESS == fill_pdsch_configuration_dedicated(&(p_radio_res_dedicated_scell_non_ul_config->pdsch_configuration_dedicated),
                         p_rrm_ue_context, scell_index)) &&
                ret_val == RRM_SUCCESS)
        {
            p_radio_res_dedicated_scell_non_ul_config->bitmask |= RRM_SCELL_DEDICATED_NON_UL_PDSCH_CONFIG_DEDICATED_PRESENT;
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Radio Resource Dedicated UL Config for SCell's PDSCH Config Dedicated Failed");
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_pdsch_configuration_dedicated
 *   INPUT      : p_pdsch_configuration_dedicated, scell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Fills PDSCH Configuration Dedicated for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_pdsch_configuration_dedicated(
rrc_phy_pdsch_configuration_dedicated_t *p_pdsch_configuration_dedicated,
rrm_ue_context_t                        *p_rrm_ue_context,
rrm_cell_index_t                        scell_index)
{
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if(RRM_UE_POSITION_AT_CELL_EDGE ==
            p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)
    {
        p_pdsch_configuration_dedicated->p_a = rrm_cellm_get_scell_phy_pdsch_config_pa_for_ce_ue(scell_index);
    }
    else
    {
        p_pdsch_configuration_dedicated->p_a = rrm_cellm_get_scell_phy_pdsch_config_pa(scell_index);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_mac_main_config_extensions
 *   INPUT      : p_mac_main_config_extensions, scell_index, p_rrm_ue_context,
 *                ca_param_bitmask
 *   OUTPUT     : None
 *   DESCRIPTION: Fill Mac Main Config Ext. for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_mac_main_config_extensions(
rrc_scell_mac_main_config_extensions_t *p_mac_main_config_extensions,
rrm_cell_index_t                        scell_index,
rrm_ue_context_t                       *p_rrm_ue_context,
U64                                     ca_param_bitmask)
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    U8                                  dl_num_harq_process = RRM_ZERO;
    U8                                  dl_i_mcs = RRM_ZERO;
    U8                                  num_of_layer = RRM_ZERO;
    U8                                  code_book_index = RRM_ZERO;
    U8                                  user_location_type = RRM_ZERO;
    U8                                  rf_params_half_duplex_fdd = RRM_ZERO;
    U8                                  scell_activate_status = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    p_mac_main_config_extensions->bitmask = RRM_ZERO;
    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_DL_NUM_HARQ_PROCESS)
    {
        if(RRM_SUCCESS == get_scell_mac_main_config_ext_dl_num_harq_process(scell_index,
                    &dl_num_harq_process))
        {
            p_mac_main_config_extensions->bitmask |= RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_NUM_HARQ_PROC_PRESENT;
            p_mac_main_config_extensions->dl_num_harq_process = dl_num_harq_process;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "dl_num_harq_process for Scell: %d ", dl_num_harq_process);
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }

    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_DL_I_MCS)
    {
        if(RRM_SUCCESS == get_scell_mac_main_config_ext_dl_i_mcs(scell_index,
                    &dl_i_mcs) &&
                ret_val == RRM_SUCCESS)
        {
            p_mac_main_config_extensions->bitmask |= RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_INIT_MCS_PRESENT;
            p_mac_main_config_extensions->dl_i_mcs = dl_i_mcs;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "dl_i_mcs for Scell: %d ", dl_i_mcs);
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }

    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_NUM_OF_LAYER)
    {
        if(RRM_SUCCESS == get_scell_mac_main_config_ext_num_of_layer(scell_index, &num_of_layer, p_rrm_ue_context) &&
                ret_val == RRM_SUCCESS)
        {
            p_mac_main_config_extensions->bitmask |= RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_NUM_OF_LAYER_INFO_PRESENT;
            p_mac_main_config_extensions->num_of_layer = num_of_layer;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "num_of_layer configured for Scell: %d", num_of_layer);
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }

    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_CODE_BOOK_INDEX)
    {
         /*SPR 17777 +-*/
        if(RRM_SUCCESS == get_scell_mac_main_config_ext_code_book_index(&code_book_index) &&
                ret_val == RRM_SUCCESS)
        {
            p_mac_main_config_extensions->bitmask |= RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_CODE_BOOK_INDEX_INFO_PRESENT;
            p_mac_main_config_extensions->code_book_index = code_book_index;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "code_book_index of Scell: %d", code_book_index); 
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }

    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_USER_LOCATION_TYPE)
    {
         /*SPR 17777 +-*/
        if(RRM_SUCCESS == get_scell_mac_main_config_ext_user_location_type(&user_location_type) &&
                ret_val == RRM_SUCCESS)
        {

            p_mac_main_config_extensions->bitmask |= RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_USER_LOCATION_TYPE_PRESENT;
            p_mac_main_config_extensions->user_location_type =  
                p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "user_location_type of User on Scell: %d ", 
                    p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position); 
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }

    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_HALF_DUPLEX_FDD)
    {
        p_mac_main_config_extensions->bitmask |= RRM_MAC_MAIN_CONFIG_EXT_RF_PARAMS_PRESENT;
        p_mac_main_config_extensions->rf_params_half_duplex_fdd = rf_params_half_duplex_fdd;

        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "rf_params_half_duplex_fdd of Scell: %d ", rf_params_half_duplex_fdd);
    }

    if(ca_param_bitmask & RRM_MAC_MAIN_CONFIG_EXT_SCELL_ACTIVATE_STATUS)
    {
         /*SPR 17777 +-*/
        if(RRM_SUCCESS == get_scell_mac_main_config_ext_scell_activate_status(&scell_activate_status) &&
                ret_val == RRM_SUCCESS)
        {
            p_mac_main_config_extensions->bitmask |= RRM_MAC_SCELL_ACTIVATE_STATUS_PRESENT;
            p_mac_main_config_extensions->scell_activate_status = scell_activate_status;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "SCell Activate status set to Active at Scell addition time");
        }
        else
        {
            ret_val = RRM_FAILURE;
        }
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_antenna_info_dedicated_r10
 *   INPUT      : p_antenna_info_dedicated_r10, scell_index
 *   OUTPUT     : None
 *   DESCRIPTION: Fills Antenna Info dedicated for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_antenna_info_dedicated_r10(
rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
rrm_cell_index_t                  scell_index,
rrm_ue_context_t                 *p_rrm_ue_context)
{
    rrm_return_et                              ret_val = RRM_SUCCESS;
    
    RRM_UT_TRACE_ENTER();
    p_antenna_info_dedicated_r10->bitmask = RRM_ZERO;
    rrm_bool_et                   antenna_match = RRM_TRUE;
    
    /* CA implementation for Scell's Transmission Mode changes */
    if(RRM_SUCCESS == rrm_fill_scell_transmission_mode_r10(p_antenna_info_dedicated_r10,
                                                         scell_index,
                                                         p_rrm_ue_context,
                                                        &antenna_match))
    {
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
		"TRANSMISSION_MODE selected for Scell Index[%d] is [%d].",
                scell_index, p_antenna_info_dedicated_r10->transmission_mode);
    }
    else
    {
        ret_val = RRM_FAILURE;
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
		"TRANSMISSION_MODE selection failed for Scell Index[%d].",
		scell_index);
    }
    
    p_antenna_info_dedicated_r10->ue_transmit_antenna_selection.bitmask = RRM_ZERO;

    p_antenna_info_dedicated_r10->ue_transmit_antenna_selection.request_type = RRM_ZERO; 

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_radio_res_dedicated_scell_ul_config
 *   INPUT      : p_radio_res_dedicated_scell_ul_config, scell_index,
 *                ca_param_bitmask, p_rrm_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION: Fill Radio Res. Dedicated scell UL config params for Scell.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_radio_res_dedicated_scell_ul_config(
rrc_radio_res_dedicated_scell_ul_config_t *p_radio_res_dedicated_scell_ul_config,
rrm_cell_index_t                           scell_index,
U64                                        ca_param_bitmask,
rrm_ue_context_t                          *p_rrm_ue_context,
U8                                         transmission_mode)
{
    rrm_return_et                      ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_radio_res_dedicated_scell_ul_config->bitmask = RRM_ZERO;
    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_UL_CQI_PARAM_CHANGE)
    { 
	if(RRM_SUCCESS == fill_rrc_cqi_report_config_scell_r10(&(p_radio_res_dedicated_scell_ul_config->cqi_report_config_scell),
							       scell_index, p_rrm_ue_context, transmission_mode))
	{
	    p_radio_res_dedicated_scell_ul_config->bitmask |= RRM_SCELL_DEDICATED_UL_CQI_CONFIG_SCELL_PRESENT;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                     "Radio Resource Dedicated UL Config for SCell -> CQI Report SCELL");
	}
	else
	{
	    ret_val = RRM_FAILURE;
	    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
		     "Radio Resource Dedicated UL Config for SCell -> CQI Report SCELL failed");
	}
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*  LAA Rel13 Code + */
/*  LAA Rel13 Code - */
/******************************************************************************
 *   FUNCTION NAME: fill_radio_res_config_dedicated_scell_phy_config
 *   INPUT      : p_physical_config_dedicated_scell, scell_index, 
 *                 ca_param_bitmask, p_rrm_ue_context
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_radio_res_config_dedicated_scell_phy_config(
rrc_physical_config_dedicated_scell_t *p_physical_config_dedicated_scell,
rrm_cell_index_t                       scell_index,
U64                                    ca_param_bitmask,
rrm_ue_context_t                      *p_rrm_ue_context)
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    U8                                  scell_arr_idx = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_NON_UL)
    {
        if(RRM_SUCCESS == fill_radio_res_dedicated_scell_non_ul_config(&(p_physical_config_dedicated_scell->radio_res_dedicated_scell_non_ul_config),
                    p_rrm_ue_context, scell_index, ca_param_bitmask))
        {
            p_physical_config_dedicated_scell->bitmask |= RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT;
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Radio Resource Dedicated non-UL Config for SCell failed");
        }
    }
    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_UL)
    {
        if(rrm_is_scell_valid_for_ue(p_rrm_ue_context, scell_index, &scell_arr_idx))
        /* SPR_11927_fix: End */
        {
            if((RRM_SUCCESS == fill_radio_res_dedicated_scell_ul_config(&(p_physical_config_dedicated_scell->radio_res_dedicated_scell_ul_config),
                            scell_index, ca_param_bitmask, p_rrm_ue_context, 
                            p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].
                            scell_antenna_info_dedicated_r10.transmission_mode)) && 
                    ret_val == RRM_SUCCESS)
            {
                p_physical_config_dedicated_scell->bitmask |= RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_UL_CONFIG_PRESENT;
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "Radio Resource Dedicated UL Config for SCell failed");
            }
        }
    }
    /*  LAA Rel13 Code + */
    /*  LAA Rel13 Code - */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: fill_radio_res_common_scell_non_ul_config
 *   INPUT      : p_radio_res_common_scell_non_ul_config, scell_index
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_radio_res_common_scell_non_ul_config(
rrc_radio_res_common_scell_non_ul_config_t *p_radio_res_common_scell_non_ul_config,
rrm_cell_index_t                            scell_index)
{
    rrm_return_et                           ret_val = RRM_SUCCESS;
    
    RRM_UT_TRACE_ENTER();
/* CA TDD changes start */
#ifdef TDD_MODE_FLAG
    tdd_frame_structure_t tdd_config = 
    {RRM_OAM_SA0, RRM_OAM_SSP0}; /* Coverity 69720 Change */
    p_radio_res_common_scell_non_ul_config->bitmask = RRM_SCELL_COMMOM_NON_UL_TDD_CONFIG_PRESENT;
    tdd_config = rrm_cellm_get_scell_tdd_config(scell_index);
    p_radio_res_common_scell_non_ul_config->tdd_config.sub_frame_assignment = (U8)(tdd_config.sub_frame_assignment);
    p_radio_res_common_scell_non_ul_config->tdd_config.special_sub_frame_pattern = (U8)(tdd_config.
            special_sub_frame_patterns);
/* CA TDD changes end */
#else
    p_radio_res_common_scell_non_ul_config->bitmask = RRM_ZERO;
#endif

    p_radio_res_common_scell_non_ul_config->dl_bandwidth = rrm_cellm_get_scell_non_ul_config_dl_bandwidth
									 (scell_index);

    p_radio_res_common_scell_non_ul_config->antenna_port_count = rrm_cellm_get_scell_non_ul_config_antenna_port_count
									 (scell_index);

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
		     "Num of Scell's Antenna Ports are: %d", p_radio_res_common_scell_non_ul_config->antenna_port_count);

    ret_val = rrm_fill_scell_non_ul_config_phich_config(&(p_radio_res_common_scell_non_ul_config->phich_config),
						        scell_index); 

    ret_val = rrm_fill_scell_non_ul_config_pdsch_config_common(&(p_radio_res_common_scell_non_ul_config->pdsch_config_common),
                                                               scell_index);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_radio_res_config_common
 *   INPUT      : p_radio_res_config_common_scell, scell_index
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_radio_res_config_common(
rrc_radio_res_config_common_scell_t    *p_radio_res_config_common_scell,
rrm_cell_index_t                        scell_index)
{
    rrm_return_et                              ret_val=RRM_SUCCESS;
    p_radio_res_config_common_scell->bitmask = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    ret_val = fill_radio_res_common_scell_non_ul_config(&(p_radio_res_config_common_scell->radio_res_common_scell_non_ul_config),
                                                        scell_index);
    /* UL Config not supported by RRC curently */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_cell_Identification
 *   INPUT      : p_scell_Id, scell_index
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_cell_Identification(
rrc_scell_Identification_t  *p_scell_Id,
rrm_cell_index_t             scell_index)
{
    rrm_return_et        ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_scell_Id->phy_cell_id = rrm_cellm_get_scell_pci(scell_index);
    p_scell_Id->dl_carrier_freq = rrm_cellm_get_scell_dl_carrier_freq(scell_index);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_bkp_scell_index_for_fail_resp_from_rrc
 *   INPUT      : p_rrm_ue_context, p_scell_cell_index
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_bkp_scell_index_for_fail_resp_from_rrc(
rrm_ue_context_t  *p_rrm_ue_context,
rrm_cell_index_t  scell_cell_index)
{
    U8 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_rrm_ue_context->ue_scell_add_params.scell_bkp_count = p_rrm_ue_context->ue_scell_add_params.count;
    for(count = RRM_ZERO; count < RRM_MAX_SCELL ; count++)
    {
        if(p_rrm_ue_context->ue_scell_add_params.scell_cell_index_add_bkp[count] == RRM_OUT_OF_RANGE)
	{
            p_rrm_ue_context->ue_scell_add_params.bitmask |= RRM_SCELL_INDEX_BACKUP_PRESENT;
	    p_rrm_ue_context->ue_scell_add_params.scell_cell_index_add_bkp[count] = scell_cell_index;
            break;
	}
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_store_scell_list_rcv_in_ho_adm_req
 *   INPUT      : p_rrm_ue_context, count, cell_index, scell_index
 *   OUTPUT     : None
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
/* Carrier_Aggregation_Start */
rrm_void_t
rrm_store_scell_list_rcv_in_ho_adm_req
(
    rrm_ue_context_t *p_rrm_ue_context,
         /*SPR 17777 +-*/
    U8 count,
    rrm_cell_index_t cell_index,
    rrm_cell_index_t scell_index
)
{
    RRM_UT_TRACE_ENTER();

    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index = cell_index;
    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index = scell_index;
    p_rrm_ue_context->ue_scell_add_params.count = count + RRM_ONE;
    RRM_UT_TRACE_EXIT();
}
/* Carrier_Aggregation_End */

/******************************************************************************
 *   FUNCTION NAME: rrm_find_valid_scell_index_for_ue
 *   INPUT      : p_rrm_ue_context, scell_cell_index, p_scellIndex
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_find_valid_scell_index_for_ue(
rrm_ue_context_t  *p_rrm_ue_context,
rrm_cell_index_t   scell_cell_index,
U8                *p_scellIndex,
U64                ca_param_bitmask)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    U8               count = RRM_ZERO;
    /* Check if count of Scell is valid */
    *p_scellIndex = RRM_ZERO;           /* Invalid SCell Index*/
    if(p_rrm_ue_context->ue_scell_add_params.count == RRM_ZERO)
    {
        /* add at first index */
        
	 p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].scell_state = SCELL_ACTIVE;  /* CID: 60875 - Fix */
	 p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].scell_index = RRM_ONE;
	 p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].scell_cell_index = scell_cell_index;
         p_rrm_ue_context->ue_scell_add_params.count += RRM_ONE;
        *p_scellIndex = RRM_ONE;
         rrm_fill_bkp_scell_index_for_fail_resp_from_rrc(p_rrm_ue_context, scell_cell_index);
    }
    else
    {
        if(p_rrm_ue_context->ue_scell_add_params.count == RRM_MAX_SCELL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                      "Already Max Scells are added ");
            ret_val = RRM_FAILURE;
        }
        else
        {
            for(count = RRM_ZERO; count < RRM_MAX_SCELL; count++)
            {
                if(scell_cell_index == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index)
                {
                    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_SCELL)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "SCell Index already present as SCell array, So sending Reconfig for the same scell");
                        *p_scellIndex = p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index;
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "Cell Index already present as SCell, Same cell cannot be added as Scell more than once for same UE");
                        *p_scellIndex = p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index;
                    }
                }
            }
            if(*p_scellIndex == RRM_ZERO)    /* No SCell with Input Cell Index Present in the added Scell array */
            {
                 for(count = RRM_ZERO; count < RRM_MAX_SCELL; count++)
                 {
                     if(p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index == RRM_ZERO)
                     {
                         p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_state = SCELL_ACTIVE; /* CID: 61038 - Fix */
                         p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index = (count+RRM_ONE);
                         p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index = scell_cell_index;
                         p_rrm_ue_context->ue_scell_add_params.count += RRM_ONE;
                         *p_scellIndex = (count+RRM_ONE);
                         rrm_fill_bkp_scell_index_for_fail_resp_from_rrc(p_rrm_ue_context, scell_cell_index);
                         break;
                     }
                     else
                     {
                         continue;
                     }
                 }
            }
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                      "Scell Index: %d ", *p_scellIndex);
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_radio_res_config_dedicated
 *   INPUT      : p_radio_res_config_dedicated_scell, scell_index,
 *                ca_param_bitmask, p_rrm_ue_context
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_radio_res_config_dedicated(
rrc_radio_res_config_dedicated_scell_t *p_radio_res_config_dedicated_scell,
rrm_cell_index_t                        scell_index,
U64                                     ca_param_bitmask,
rrm_ue_context_t                       *p_rrm_ue_context)
{
    rrm_return_et                        ret_val = RRM_SUCCESS;
    
    RRM_UT_TRACE_ENTER();
    p_radio_res_config_dedicated_scell->bitmask = RRM_ZERO;
    ret_val = fill_radio_res_config_dedicated_scell_phy_config(&(p_radio_res_config_dedicated_scell->physical_config_dedicated_scell),
							       scell_index,
                                                               ca_param_bitmask,
                                                               p_rrm_ue_context);

    if(ret_val == RRM_SUCCESS)
    {
	p_radio_res_config_dedicated_scell->bitmask |= RRM_PHYSICAL_CONFIG_DEDICATED_SCELL_CONFIG_PRESENT;
    }
    else
    {   
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                      "Radio Resource Config Dedicated Failed for Scell."); 
	ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_to_add_mod_list
 *   INPUT      : p_rrm_ue_context, num_of_scell, p_arr_cell_index,
 *                p_scell_add_mod_list, ca_param_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_to_add_mod_list(
rrm_ue_context_t                 *p_rrm_ue_context,
U8                                num_of_scell,
rrm_cell_index_t                 *p_arr_cell_index,
rrc_scell_to_add_mod_list_t      *p_scell_add_mod_list,
U64                               ca_param_bitmask)
{
    rrm_return_et                             ret_val = RRM_SUCCESS;
    rrm_cell_index_t                          scell_cell_index = RRM_ZERO;
    U8                                        count = RRM_ZERO;                                       

    RRM_UT_TRACE_ENTER();
    
    /*fill Scell list*/
    for(count = RRM_ZERO; ((count < num_of_scell) && (count < MAX_SCELL)); count++)   /* Klocwork_fix_27_aug */
    {
        p_scell_add_mod_list->count++;             /* Klocwork_fix_27_aug */

        p_scell_add_mod_list->rrc_scell_to_add_mod[count].bitmask = RRM_ZERO;
	if(RRM_SUCCESS == rrm_find_valid_scell_index_for_ue(p_rrm_ue_context, p_arr_cell_index[count], &scell_cell_index, ca_param_bitmask))
        {
	    p_scell_add_mod_list->rrc_scell_to_add_mod[count].scellIndex = scell_cell_index; 
        /* SPR_11026_Fix: Start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                " Scell Index = %d",
                p_scell_add_mod_list->rrc_scell_to_add_mod[count].scellIndex);

        if(ca_param_bitmask & RRM_SCELL_ADD_MOD_SCELL_IDX_AND_ID)
        {
            p_scell_add_mod_list->rrc_scell_to_add_mod[count].cell_index = p_arr_cell_index[count];

            p_scell_add_mod_list->rrc_scell_to_add_mod[count].bitmask |= RRM_SCELL_ADD_MOD_CELL_INDEX_PRESENT;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Scell Cell Index = %d ",
                    p_scell_add_mod_list->rrc_scell_to_add_mod[count].cell_index);
            ret_val = rrm_fill_cell_Identification(&(p_scell_add_mod_list->rrc_scell_to_add_mod[count].scell_Id), 
                                p_arr_cell_index[count]
                                );
            if(ret_val == RRM_SUCCESS)
            {
                p_scell_add_mod_list->rrc_scell_to_add_mod[count].bitmask |= RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT;
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "Scell Identification returned failed");
                break;
            }
        }
        /* SPR_11026_Fix: End */

        /* SPR 21251 +- */
	    /*Use bitmask to fill this Structure*/
	    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_COMMON_SCELL)
        {
            if(rrm_fill_scell_radio_res_config_common(&(p_scell_add_mod_list->rrc_scell_to_add_mod[count].radio_res_config_common_scell),
                        p_arr_cell_index[count]) &&
                    RRM_SUCCESS == ret_val)
            {
                p_scell_add_mod_list->rrc_scell_to_add_mod[count].bitmask |= RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT;
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "SCell Radio Resource Config Common failed.");
                break;
            }
        }

	    /*Use bitmask to fill this Structure*/
	    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_SCELL)
	    {
		if( rrm_fill_scell_radio_res_config_dedicated(&(p_scell_add_mod_list->rrc_scell_to_add_mod[count].radio_res_config_dedicated_scell),
								     p_arr_cell_index[count],
								     ca_param_bitmask,
                                                                     p_rrm_ue_context) &&
                                                                     ret_val == RRM_SUCCESS)
		{
		    p_scell_add_mod_list->rrc_scell_to_add_mod[count].bitmask |= RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT;
		}
		else
		{
		    ret_val = RRM_FAILURE;
		    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                          "SCell Radio Resource Config Dedicated failed.");
		    break;
		}
	    }
	    /*Use bitmask to fill this Structure*/
	    if(ca_param_bitmask & RRM_SCELL_ADD_MOD_MAC_MAIN_CONFIG_EXT_SCELL)
	    {
		if(rrm_fill_scell_mac_main_config_extensions(&(p_scell_add_mod_list->rrc_scell_to_add_mod[count].mac_main_config_extensions),
								    p_arr_cell_index[count],
								    p_rrm_ue_context,
								    ca_param_bitmask) &&
                                                                    ret_val == RRM_SUCCESS)
		{
		    p_scell_add_mod_list->rrc_scell_to_add_mod[count].bitmask |= RRM_SCELL_ADD_MOD_MAC_SCELL_CONFIG_EXTENSION_SCELL_PRESENT;
		}
		else
		{
		    ret_val = RRM_FAILURE;
		    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                          "Scell Mac Main Config Ext. failed.");
		    break;
		}
	    }
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                       "Valid Scell Index could not be allotted to Scell.");
            /*MAX SCell count reached at UE or Scell already added as Scell on UE */
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_physical_config_dedicated_extended
 *   INPUT      : p_phy_physical_config_dedicated_extended, p_rrm_ue_context
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_physical_config_dedicated_extended(
rrc_phy_physical_config_dedicated_extended_t *p_phy_physical_config_dedicated_extended,
rrm_ue_context_t        *p_rrm_ue_context)
{
    rrm_return_et         ret_val = RRM_FAILURE;
    rrm_cell_context_t    *p_cell_ctx = RRM_PNULL;
    U16                   n1_pucch_an_remaining = RRM_ZERO;
    U16                   index = RRM_ZERO;
    U8                    n1_pucch_an_cs_count = RRM_ZERO;
    /* CA TDD changes start */
    transmission_mode_ue_service_profile_et transmission_mode = 
        TRANSMISSION_MODE_TM1;
#ifdef TDD_MODE_FLAG
    rrm_cell_index_t      scell_index;
    tdd_frame_structure_t tdd_config = 
    {RRM_OAM_SA0, RRM_OAM_SSP0}; /* Coverity 69720 Change */
#endif
    /* CA TDD changes end */

    RRM_UT_TRACE_ENTER();
    /* CA TDD changes start */
    /* Coverity 69718, 69722 Fix Start */
    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].
        ue_format1b_resc.n1_pucch_an_cs_first_index = RRM_OUT_OF_RANGE_TWO_BYTE;
    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].
        ue_format1b_resc.n1_pucch_an_cs_second_index = RRM_OUT_OF_RANGE_TWO_BYTE;
    /* Coverity 69718, 69722 Fix End */
    /* CA TDD changes end */

    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65826:start*/
    if ( RRM_PNULL != p_cell_ctx )
    {
    n1_pucch_an_remaining = 
                (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an + RRM_ONE) +
                (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an * 
                 (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift + RRM_ONE))
                - 
                    p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Remaining PUCCH resources are [%d] and Total N1 PUCCH resources configured are [%d] and "
            "last index for SR resources is [%d]", 
            n1_pucch_an_remaining, 
            p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an, 
            p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx);
        /* CA TDD changes start */
        transmission_mode = (transmission_mode_ue_service_profile_et)p_rrm_ue_context->
            ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].\
            scell_antenna_info_dedicated_r10.transmission_mode;
#ifdef TDD_MODE_FLAG
        scell_index = p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].scell_cell_index;
        tdd_config = rrm_cellm_get_scell_tdd_config(scell_index);
#endif

        /*p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
          channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.count  = RRM_TWO;*/
        /* CA TDD changes end */

    for (index = 0; (index < n1_pucch_an_remaining) && 
		    (RRM_PNULL != &( p_cell_ctx->sps_n1_pucch_an_marked_st[index])); index++)
    {
            /* CA TDD changes start */
            /* Acc. to RRM design doc Rel6.1 Rev 2.20 Sec-5.4.52.2.8- size of
             * an-cs-list will vary according to TM mode and duplex mode*/
#ifdef TDD_MODE_FLAG
            if(((RRM_OAM_SA0 == (U8)tdd_config.sub_frame_assignment) ||
                        (RRM_OAM_SA6 == (U8)tdd_config.sub_frame_assignment)) &&
                    (TRANSMISSION_MODE_TM1 == transmission_mode || TRANSMISSION_MODE_TM2 == transmission_mode ||
                     TRANSMISSION_MODE_TM6 == transmission_mode || TRANSMISSION_MODE_TM7 == transmission_mode))
#else
                if(TRANSMISSION_MODE_TM1 == transmission_mode || TRANSMISSION_MODE_TM2 == transmission_mode ||
                        TRANSMISSION_MODE_TM6 == transmission_mode || TRANSMISSION_MODE_TM7 == transmission_mode)
#endif
                {
                    if (RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_marked_st[index])
                    {
                        /*Format1b for one scell.so storing the value in index zero
                         * of scell*/
                        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                            channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.
                            n1_pucch_an_cs[RRM_ZERO].count  = RRM_ONE; 
                        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                            channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs
                            [n1_pucch_an_cs_count].n1_pucch_an_cs[RRM_ZERO] = p_cell_ctx->sps_n1_pucch_an_start_indx + index;
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].ue_format1b_resc.n1_pucch_an_cs_first_index
                            =  index;
                        p_cell_ctx->sps_n1_pucch_an_marked_st[index] = RRM_ONE;
                        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                            channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.count  = RRM_ONE;
                        ret_val = RRM_SUCCESS;
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "CA:format1b resource allocated at index n[%d] ",
                                p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs[RRM_ZERO].n1_pucch_an_cs[RRM_ZERO]);
                        break;
                    }
                }
                else
                {
	    /*Index n and n+1 need to be available*/
	    if (((index +RRM_ONE) < n1_pucch_an_remaining) && 
			    ((RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_marked_st[index]) && 
			     (RRM_ZERO == p_cell_ctx->sps_n1_pucch_an_marked_st[index +RRM_ONE])))
	    {
                        /* SPR 13701 Fix Start */
/*SPR 17323 fix start*/
#ifndef TDD_MODE_FLAG

                        if((p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].\
                                    scell_antenna_info_dedicated_r10.transmission_mode == TRANSMISSION_MODE_TM2) ||
                                (p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].\
                                 scell_antenna_info_dedicated_r10.transmission_mode == TRANSMISSION_MODE_TM1))

                        {
                            p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.count  = RRM_ONE;
                        /*Format1b for one scell.so storing the vale in index zero of scell*/
                        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                            channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.
                            n1_pucch_an_cs[RRM_ZERO].count  = RRM_ONE; 


                        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                            channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs
                            [n1_pucch_an_cs_count].n1_pucch_an_cs[RRM_ZERO] = p_cell_ctx->sps_n1_pucch_an_start_indx + index;
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].ue_format1b_resc.n1_pucch_an_cs_first_index
                            =  index;
                        p_cell_ctx->sps_n1_pucch_an_marked_st[index] = RRM_ONE;
                            /* SPR_13701_Fix_Stop */
                            ret_val = RRM_SUCCESS;
                            /* SPR_13701_Fix_Stop */
                            break;
                        }
                        else
                        {
#endif
/*SPR 17323 fix end*/
                            p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.count  = RRM_TWO;

                            /*Format1b for one scell.so storing the vale in index zero of scell*/
                            p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.
                                n1_pucch_an_cs[RRM_ZERO].count  = RRM_ONE;


                            p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs
                                [n1_pucch_an_cs_count].n1_pucch_an_cs[RRM_ZERO] = p_cell_ctx->sps_n1_pucch_an_start_indx + index;

                            p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].ue_format1b_resc.n1_pucch_an_cs_first_index
                                =  index;
                            p_cell_ctx->sps_n1_pucch_an_marked_st[index] = RRM_ONE;

		    p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
			    channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.
			    n1_pucch_an_cs[RRM_ONE].count  = RRM_ONE; 
		    p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
			    channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs
			    [RRM_ONE].n1_pucch_an_cs[RRM_ZERO] = p_cell_ctx->sps_n1_pucch_an_start_indx + index +RRM_ONE;
		    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[RRM_ZERO].ue_format1b_resc.n1_pucch_an_cs_second_index
			    = index + RRM_ONE ;

		    p_cell_ctx->sps_n1_pucch_an_marked_st[index + RRM_ONE] = RRM_ONE;
                        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                            channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.count  = RRM_TWO;

                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "CA:format1b resource allocated at index n[%d] and index n+1[%d]",
                                p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs[RRM_ZERO].n1_pucch_an_cs[RRM_ZERO],
                                p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
                                channel_selection_n1_pucch_an_cs_r10.n1pucch_an_cs_list_r10.n1_pucch_an_cs[RRM_ONE].n1_pucch_an_cs[RRM_ZERO]);
                        ret_val = RRM_SUCCESS;
                        break;
/*SPR 17323 fix start*/
#ifndef TDD_MODE_FLAG
            }
#endif
/*SPR 17323 fix end*/
	        }
                    /* SPR 13701 Fix Stop */
                }
    }
    if (RRM_SUCCESS == ret_val)
    {
        p_phy_physical_config_dedicated_extended->bitmask |= RRC_PHY_PUCCH_CHANNEL_SELECTION_CONFIG_R10_PRESENT; 
        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.bitmask |=
            RRC_N1PUCCH_AN_CS_R10_PRESENT;
        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
            channel_selection_n1_pucch_an_cs_r10.request_type = RRM_ONE;

        p_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020.
            channel_selection_n1_pucch_an_cs_r10.bitmask |= 
            RRC_N1PUCCH_AN_CS_LIST_R10_PRESENT;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CA:Failed to allocate format1b");
    }
    }
    /*CID 65826:end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_scell_config_params_in_ue_reconfig
 *   INPUT      : p_rrm_ue_context, num_of_scell, p_arr_cell_index
 *                p_scell_config, ca_params_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_scell_config_params_in_ue_reconfig(
rrm_ue_context_t        *p_rrm_ue_context,
U8                       num_of_scell,
rrm_cell_index_t        *p_arr_cell_index,
rrm_scell_config_t      *p_scell_config,
U64                      ca_params_bitmask)
{
    rrm_return_et                             ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /*fill scell list to be added*/
    if(RRM_SUCCESS == rrm_fill_scell_to_add_mod_list(p_rrm_ue_context, num_of_scell, p_arr_cell_index, 
                                                    &(p_scell_config->scell_add_mod_list), ca_params_bitmask))
    {
        p_scell_config->bitmask |= RRM_SCELL_ADD_MOD_LIST_PRESENT;
    }
    else
    {
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: fill_pcell_physical_config_dedicated_r10
 *   INPUT      : p_rrc_phy_physical_config_dedicated, p_rrm_ue_context,
 *                ca_params_bitmask
 *   OUTPUT     :
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_void_t
fill_pcell_physical_config_dedicated_r10_antenna_info( rrm_ue_context_t   *p_rrm_ue_context,
                                     rrc_phy_physical_config_dedicated_t  *p_rrc_phy_physical_config_dedicated)
{
    RRM_UT_TRACE_ENTER();
    /* SPR-16135 START */
    if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.access_stratum_release)
        /* SPR-16135 END */
        /*setting ue context reconfig bitmask in ue context for phy antenna info */
    {
        /*handling if UE Rel-10*/
        p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
            RRM_UE_RECONFIG_PHY_ANTENNA_INFO_R10_ROLLBACK_PRESENT;

        p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_ANTENNA_INFO_R10_PRESENT;

        p_rrc_phy_physical_config_dedicated->antenna_info_r10.
            bitmask |= RRC_ANTENNA_INFO_R10_EXPLICIT_VALUE_PRESENT;

    }
    else
    {

        p_rrc_phy_physical_config_dedicated->bitmask |=
            RRC_PHY_ANTENNA_INFORMATION_PRESENT;

        p_rrc_phy_physical_config_dedicated->antenna_information.
            bitmask |= RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT;

        p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
            RRM_UE_RECONFIG_PHY_ANTENNA_CONFIG_ROLLBACK_PRESENT;

        if( TRANSMISSION_MODE_TM8_V920 == p_rrc_phy_physical_config_dedicated->antenna_information.
                antenna_information_explicit_value.transmission_mode )
        {
            p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                RRM_UE_RECONFIG_PHY_ANTENNA_INFO_V920_PRESENT;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/******************************************************************************
 *   FUNCTION NAME: fill_pcell_physical_config_dedicated_r10
 *   INPUT      : p_rrc_phy_physical_config_dedicated, p_rrm_ue_context, 
 *                ca_params_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
fill_pcell_physical_config_dedicated_r10(
rrc_phy_physical_config_dedicated_t            *p_rrc_phy_physical_config_dedicated,
rrm_ue_context_t                               *p_rrm_ue_context,
U64                                             ca_params_bitmask)
{
    rrm_return_et                    ret_val = RRM_SUCCESS;  
    U8                              cqi_mode_selected = RRM_ZERO;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = RRM_PNULL;
    rrc_phy_physical_config_dedicated_ue_service_profile_t
        *p_ue_profile_physical_config_dedicated = RRM_PNULL;
    p_rrc_phy_physical_config_dedicated->bitmask = RRM_ZERO;
    /* Coverity_ID : 61449*/
    rrm_bool_et antenna_info_match               = RRM_TRUE;
     RRM_UT_TRACE_ENTER();
     
     if(ca_params_bitmask & PCELL_ANTENNA_INFO_R10_PRESENT)
     {
	 /* Fill R-10 Antenna Info */
	 if( p_rrm_ue_context->p_ue_mac_report->report_count >= RRM_MAX_REPORT_STAT_UE )
	 {
	     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
		     " Report Count [%d] of Fresh Report ",p_rrm_ue_context->p_ue_mac_report->report_count );

	     ret_val = rrm_fill_transmission_mode(p_rrm_ue_context,
		     p_rrc_phy_physical_config_dedicated,
		     &antenna_info_match);
	     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
		     " Report Count [%d] of Fresh Report ",p_rrm_ue_context->p_ue_mac_report->report_count );
	 }
	 else
	 {
	     RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
		     "No. of Fresh Report[%d] for Transmission mode reconfig is not enough",
		     (p_rrm_ue_context->p_ue_mac_report->report_count));
	 }

	 if( (RRM_SUCCESS == ret_val) && (RRM_FALSE == antenna_info_match) )
	 {
	     /* R-10 Changes: Start */
         /*Klockwork_fix_start*/
         fill_pcell_physical_config_dedicated_r10_antenna_info(p_rrm_ue_context,p_rrc_phy_physical_config_dedicated);
         /*Klockwork_fix_end*/
	 }
     }

     if(ca_params_bitmask & PCELL_CQI_INFO_R10_PRESENT)
     {
	 //Fill R-10 CQI INFO for P-CELL
	 p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->cell_index);
	 p_ue_profile_physical_config_dedicated = &(p_ue_service_profile->radio_res_config.physical_config_dedicated); 

     /* CA_SATGE3: Start */
     rrm_select_cqi_mode_for_cell(p_ue_profile_physical_config_dedicated->cqi_reporting.rrm_cqi_reporting_mode_configured,
            p_rrm_ue_context,
            &cqi_mode_selected);
     /* CA_SATGE3: End */

#ifndef LTE_EMBMS_SUPPORTED
	 if(RRM_DISABLE_CQI_REPORTING != (rrm_cqi_reporting_mode_et)cqi_mode_selected)
#else
     if((RRM_DISABLE_CQI_REPORTING != (rrm_cqi_reporting_mode_et)cqi_mode_selected) &&
            (RRM_ONE != p_rrm_ue_context->ue_mbms_data.is_cqi_disabled))
#endif
	 {  
	    if(p_ue_profile_physical_config_dedicated->bitmask &
		    RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT)
	    {
		p_rrc_phy_physical_config_dedicated->bitmask |=
		    RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;
		ret_val =rrm_rrc_ue_fill_cqi_reporting_r10
			    (&(p_rrc_phy_physical_config_dedicated->cqi_report_config_r10),
			     &(p_ue_profile_physical_config_dedicated->cqi_reporting),
			     p_rrm_ue_context,
                 /* CA_SATGE3: Start */
			     p_rrm_ue_context->ue_phy_config_information.ue_antenna_info_r10
                                                   .transmission_mode);
                 /* CA_SATGE3: Start */
	    }

            /*back up the cqi information*/
            rrm_backup_cqi_information((rrm_ue_context_t *)p_rrm_ue_context);

	        rrm_set_cqi_information_for_ue_r10(p_rrm_ue_context,           
			        &(p_rrc_phy_physical_config_dedicated->cqi_report_config_r10));

            rrm_fill_cqi_report_config_v920
                                 (p_rrc_phy_physical_config_dedicated,p_rrm_ue_context);
	 }
	 else
	 {
	     p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;

	     p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.bitmask = RRM_ZERO;

	     p_rrc_phy_physical_config_dedicated->cqi_report_config_r10.nomPDSCH_rs_epre_offset =
		     p_ue_profile_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset;
	 }
     }

     //Antenna UL Info not supported
     if(ca_params_bitmask & PCELL_PHY_CONFIG_DEDICATED_EXT_PRESENT)
     {
         //phy config dedicated extended for SCELL add scenario only.
         ret_val = rrm_fill_physical_config_dedicated_extended(
                &(p_rrc_phy_physical_config_dedicated->phy_physical_config_dedicated_extended),
                 p_rrm_ue_context);
         if (RRM_SUCCESS == ret_val)
         {
             p_rrc_phy_physical_config_dedicated->bitmask |= RRC_PHY_CONFIG_DEDICATED_EXTENDED_PRESENT;
         }
     }
     RRM_UT_TRACE_EXIT();
     return ret_val; 
}

/******************************************************************************
 *   FUNCTION NAME: fill_phy_config_dedicated_for_pcell
 *   INPUT      : p_rrm_ue_context, p_rrc_rrm_ue_reconfig_physical_config_dedicated,
 *                ca_params_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_phy_config_dedicated_for_pcell(
rrm_ue_context_t                     *p_rrm_ue_context,
rrc_phy_physical_config_dedicated_t  *p_rrc_rrm_ue_reconfig_physical_config_dedicated,
U64                                   ca_params_bitmask)
{
    rrm_return_et                   ret_val = RRM_FAILURE;
    admission_control_info_t        *p_admission_control_info = RRM_NULL;
    rrm_cell_index_t                cell_index = p_rrm_ue_context->cell_index;

    RRM_UT_TRACE_ENTER();
    p_admission_control_info = rrm_cellm_get_admission_control_info(cell_index);

    if(p_admission_control_info != RRM_PNULL)
    {
	ret_val = fill_pcell_physical_config_dedicated_r10
	    (p_rrc_rrm_ue_reconfig_physical_config_dedicated,
	     p_rrm_ue_context,
	     ca_params_bitmask);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: fill_mac_config_for_pcell
 *   INPUT      : p_rrm_ue_context, p_mac_config, ca_params_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
fill_mac_config_for_pcell(rrm_ue_context_t             *p_rrm_ue_context,
rrm_mac_config_t             *p_mac_config)
         /*SPR 17777 +-*/
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    rrm_cell_context_t              *p_cell_ctx = RRM_PNULL;
    U8                              scell_deact_timer = RRM_OUT_OF_RANGE;    /*0xFF -> Scell Deact Timer is Infinity (as per discussion with RRC) */

    RRM_UT_TRACE_ENTER();
    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    /*CID 65825:start*/
    if (RRM_PNULL != p_cell_ctx)
    {
        /* SPR 13896 Fix Start*/
        p_mac_config->mac_main_config.time_alignment_timer_dedicated = rrm_cellm_get_time_alignment_timer(p_rrm_ue_context->cell_index);
        /* SPR 13896 Fix End*/
        p_mac_config->bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;

        p_mac_config->mac_main_config.bitmask |= RRC_MAC_MAIN_CONFIG_V1020_PRESENT;

        p_mac_config->mac_main_config.mac_main_config_v1020.bitmask |= RRC_MAC_MAIN_CONFIG_V1020_SCELL_DEACTIVATION_TIMER_PRESENT;

        if((p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_CA_CONFIG_INFO_PRESENT) &&
                p_cell_ctx->operator_info.ca_config.bitmask & RRM_SCELL_DEACTIVATION_TIMER_PRESENT)
        {
            rrm_get_scell_deact_timer_for_rrc(p_cell_ctx->operator_info.ca_config.scell_deactivation_timer, &scell_deact_timer);
            p_mac_config->mac_main_config.mac_main_config_v1020.scell_deactivation_timer = scell_deact_timer;
        }

        /* Fill mandatory Mac_main_config_ext params */
        ret_val = rrm_fill_mac_main_config_extension_for_l3_ue_reconfig(p_rrm_ue_context, 
                &(p_mac_config->mac_main_config_extensions));
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        return RRM_FAILURE;
    }
    /*CID 65825:end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_radio_resource_reconfig_params_pcell
 *   INPUT      : p_rrm_ue_context, radio_resource_reconfig, ca_params_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_radio_resource_reconfig_params_pcell(
rrm_ue_context_t             *p_rrm_ue_context,
radio_resource_reconfig_t    *radio_resource_reconfig,
U64                          ca_params_bitmask)
{
    rrm_return_et                             ret_val = RRM_SUCCESS;
    radio_resource_reconfig->presence_bitmask = RRM_ZERO;    
    RRM_UT_TRACE_ENTER();
    if(ca_params_bitmask & RRM_PCELL_PHY_CONFIG_DEDICATED_PRESENT)
    {
	//Fill Phy Config Dedicated info
	ret_val = fill_phy_config_dedicated_for_pcell(p_rrm_ue_context,
						     &(radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated),
                                                      ca_params_bitmask);

	if(ret_val == RRM_SUCCESS)
	{
	    radio_resource_reconfig->presence_bitmask |= RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;
	}
	else
	{
	    ret_val = RRM_FAILURE;
        return ret_val;
	}
    }

/*+ SPR 20609 fix*/
    /*INTEL_COMMON flag removed*/
/*- SPR 20609 fix*/
    if(ca_params_bitmask & RRM_PCELL_MAC_CONFIG_PARAM_PRESENT)
    {
	//Fill Mac config info
	if(RRM_SUCCESS == fill_mac_config_for_pcell(p_rrm_ue_context,
					  &(radio_resource_reconfig->mac_config)) && 
         /*SPR 17777 +-*/
					   (RRM_SUCCESS == ret_val))
	{
	    radio_resource_reconfig->presence_bitmask |= RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;
	}
	else
	{
	    ret_val = RRM_FAILURE;
	}
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 11284:start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_ca_lc_bandwidth_for_scell 
 *   INPUT        : p_rrm_ue_context, p_scell_config
 *   DESCRIPTION: Fill the band_width_distribution % for each scell 
 *   RETURNS: NONE
*******************************************************************************/
rrm_void_t rrm_fill_ca_lc_bandwidth_for_scell(rrm_ue_context_t *p_rrm_ue_context,
                                              rrm_scell_config_t *p_scell_config)
{
    U8 index = RRM_ZERO;
    rrm_cell_context_t                        *p_cell_ctx[RRM_MAX_SCELL] = {RRM_PNULL};
    U16                                       total_avl_capacity_pcell_scell = RRM_ZERO; /*store total pcell & scell cell_cap_val*/ 
    U8                                        avail_scell_cap[RRM_MAX_SCELL] = {RRM_ZERO};
    U16                                       cell_cap_of_scell = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
  
    /*Storing pcell context*/
    p_cell_ctx[RRM_ZERO] = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);        
    if (RRM_PNULL != p_cell_ctx[RRM_ZERO])
    {
        total_avl_capacity_pcell_scell = p_cell_ctx[RRM_ZERO]->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val;
        /*Calculating total cell_cap_val*/
        for(index = RRM_ZERO; index < p_rrm_ue_context->ue_scell_add_params.count; index++)
        {
            p_cell_ctx[index + RRM_ONE] = rrm_cellm_get_cell_context(
                    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_cell_index);
            if ((RRM_PNULL != p_cell_ctx[index + RRM_ONE]) && 
                (SCELL_ACTIVE == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state))
            {
                avail_scell_cap[index] = (p_cell_ctx[index + RRM_ONE]->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val *
                                        get_dl_res_block_from_dl_bandwidth(p_cell_ctx[index + RRM_ONE])) / RRM_HUNDRED;
                total_avl_capacity_pcell_scell += avail_scell_cap[index];
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "available scell capacity[%d] for scell_index[%d]",avail_scell_cap[index],
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_cell_index);
            }
        }
        /*Filling band_width_distribution of scell for ue_reconfig message*/
        for (index = RRM_ZERO; index < p_rrm_ue_context->ue_scell_add_params.count; index++)
        {
            if ((RRM_PNULL != p_cell_ctx[index + RRM_ONE]) && 
                (SCELL_ACTIVE == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state))
            {
                /*SPR 21092 Fix Start*/
                if(RRM_ZERO == total_avl_capacity_pcell_scell)
                {     
                    p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution[
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index] = RRM_ZERO;
                }     
                else  
                {     
                p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution[
                    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index] = 
                    (avail_scell_cap[index] * RRM_HUNDRED) / 
                    total_avl_capacity_pcell_scell;
                }
                /*SPR 21092 Fix Stop*/

                cell_cap_of_scell += p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution[
                    p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index];


                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "ca_lc_bandwidth[%d] for scell_index[%d]",
                        p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution[
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index],
                        p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index);

            }
        }
        p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution[RRM_ZERO] = 
                (RRM_MAX_AVLB_CAPCTY - cell_cap_of_scell);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "ca_lc_bandwidth[%d] for pcell",
                        p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution[RRM_ZERO]);
        p_scell_config->bitmask |= RRM_SCELL_CONFIG_CA_LC_BANDWIDTH_DIST_INFO_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}
/*SPR 11284end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_add_params
 *   INPUT      : p_rrm_ue_context, num_of_scell, p_arr_cell_index
 *                ca_params_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_add_params(
rrm_ue_context_t *p_rrm_ue_context,
U8 num_of_scell,
rrm_cell_index_t *p_arr_cell_index,
U64               ca_params_bitmask)
{
    U8                                        transaction_id = RRM_ONE;
    rrm_return_et                             ret_val = RRM_SUCCESS;
    rrc_rrm_ue_reconfig_req_t                 rrc_rrm_ue_reconfig_req = {RRM_ZERO};
    rrc_rrm_ue_reconfig_req_t                 *p_queue_reconfig = RRM_PNULL;
    rrm_ue_procedure_queue_t    proc_queue = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();
    //fill ue index
    rrc_rrm_ue_reconfig_req.ue_index = p_rrm_ue_context->ue_index;
    /*KLOC FIX */
    rrc_rrm_ue_reconfig_req.bitmask = RRM_ZERO;
    if(ca_params_bitmask & RRM_UE_RECONFIG_REQ_SCELL_CONFIG_PARAMS_PRESENT)
    {
        /*fill scell config -> scell add mod list*/
        if (RRM_SUCCESS == fill_scell_config_params_in_ue_reconfig(p_rrm_ue_context,
                    num_of_scell,
                    p_arr_cell_index,
                    &(rrc_rrm_ue_reconfig_req.scell_config),
                    ca_params_bitmask))
        {
            /*Only SCell to be added*/
            rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_SCELL_CONFIG_PRESENT;

            /*SPR 11284:start*/
            rrm_fill_ca_lc_bandwidth_for_scell(p_rrm_ue_context,&rrc_rrm_ue_reconfig_req.scell_config);
            /*SPR 11284:end*/
            /*SPR 16638 Fix Start*/
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.
                time_alignment_timer_dedicated = rrm_cellm_get_time_alignment_timer(p_rrm_ue_context->cell_index);
            /*SPR 16638 Fix End*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Radio Resource Refonfig params for Scell failed.");
            ret_val = RRM_FAILURE;
        }
    }

    if(ca_params_bitmask & RRM_UE_RECONFIG_REQ_RR_RECONFIG_PARAMS_PCELL_PRESENT)
    {
        if((RRM_SUCCESS == rrm_fill_radio_resource_reconfig_params_pcell(p_rrm_ue_context,
                        &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig),
                        ca_params_bitmask)) &&
                ret_val == RRM_SUCCESS)
        {
            rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;
            /*SPR 16638 Fix Start*/
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.
                time_alignment_timer_dedicated = rrm_cellm_get_time_alignment_timer(p_rrm_ue_context->cell_index);
            /*SPR 16638 Fix End*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Radio Resource Refonfig params for PCell failed.");
            /*UT-Fix*/
            ret_val = RRM_FAILURE;
        }
    }
    /*UT-Fix*/
    if((RRM_UE_ERB_NULL != p_rrm_ue_context->current_procedure.state) && (ret_val == RRM_SUCCESS)
      )
    {
        /*cov fix start 63898*/
        if ((p_queue_reconfig = rrm_mem_get(sizeof(rrc_rrm_ue_reconfig_req_t))) != RRM_PNULL)
        {
            RRM_MEMCPY(p_queue_reconfig, 
                    &rrc_rrm_ue_reconfig_req, sizeof(rrc_rrm_ue_reconfig_req_t));
            /*If already ue reconfiguration is going on with rrc. queue new reconfiguration*/
            proc_queue.api_id = RRC_RRM_UE_RECONFIG_REQ; 
            proc_queue.p_proc_data= p_queue_reconfig;
            /*SPR 18241 START*/
            rrm_ue_mgr_enqueue_req( &proc_queue, p_rrm_ue_context,RRM_FALSE);
            /*SPR 18241 END*/
            /*Coverity 94017 Fix Start*/
            RRM_MEM_FREE(proc_queue.p_proc_data);
            /*Coverity 94017 Fix End*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Unable to allocate memory to p_queue_reconfig.");
        }
        /*cov fix end 63898 */
    }

    else
    {

        if(ret_val == RRM_SUCCESS)
        {               
            ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                    RRM_MODULE_ID,
                    RRC_MODULE_ID,
                    transaction_id,
                    p_rrm_ue_context->cell_index);

            if(RRM_SUCCESS == ret_val)
            {
                //Make new state for UE Reconfig for SCELL Addition & Deletion
                RRM_SET_UE_PROCEDURE_STATE(&p_rrm_ue_context->current_procedure, RRM_UE_SCELL_PROCEDURE_ONGOING);
                //Save SCELL data to UE Context when 
                /*rrm_fill_scell_data_in_ue_context(p_rrm_ue_context,
                  num_of_scell,
                  p_arr_cell_index); */
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                        "Unable to send UE reconfig request to RRC.");
                rrm_remove_scell_data_from_ue_context(p_rrm_ue_context,
                        num_of_scell,
                        p_arr_cell_index);
                ret_val = RRM_FAILURE;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "PCell or Scell param filling failed.");
            ret_val = RRM_FAILURE;
        }
    }    

    RRM_UT_TRACE_EXIT();
    return ret_val;   
}
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_release_params
 *   INPUT      : p_rrm_ue_context, rrc_rrm_ue_reconfig_req
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:   void
*******************************************************************************/

/******************************************************************************
 *   FUNCTION NAME: rrm_calc_ca_param_bitmask
 *   INPUT      : ca_param_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_void_t
rrm_calc_ca_param_bitmask(U64    *ca_params_bitmask)
{
    *ca_params_bitmask = (RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_UL |
                          RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_SCELL |
                          RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_UL_CQI_PARAM_CHANGE);
}

/******************************************************************************
 *   FUNCTION NAME: fill_init_bitmask_for_cell_addition
 *   INPUT      : ca_param_bitmask
 *   OUTPUT     : 
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_void_t
fill_init_bitmask_for_cell_addition(U64 *ca_param_bitmask)
{
    RRM_UT_TRACE_ENTER();
    *ca_param_bitmask = (RRM_UE_RECONFIG_REQ_RR_RECONFIG_PARAMS_PCELL_PRESENT |
	    RRM_UE_RECONFIG_REQ_SCELL_CONFIG_PARAMS_PRESENT |
        /* SPR_11026_Fix: Start */
        RRM_SCELL_ADD_MOD_SCELL_IDX_AND_ID |
        /* SPR_11026_Fix: End */
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_COMMON_SCELL |
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_SCELL |
	    RRM_SCELL_ADD_MOD_MAC_MAIN_CONFIG_EXT_SCELL |
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_NON_UL |
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_UL |
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_NON_UL_TM_MODE_CHANGE |
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_NON_UL_PA_CHANGE |
	    RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_UL_CQI_PARAM_CHANGE |
	    RRM_MAC_MAIN_CONFIG_EXT_DL_NUM_HARQ_PROCESS |
	    RRM_MAC_MAIN_CONFIG_EXT_DL_I_MCS |
	    RRM_MAC_MAIN_CONFIG_EXT_NUM_OF_LAYER |
	    RRM_MAC_MAIN_CONFIG_EXT_CODE_BOOK_INDEX |
	    RRM_MAC_MAIN_CONFIG_EXT_USER_LOCATION_TYPE |
	    RRM_MAC_MAIN_CONFIG_EXT_HALF_DUPLEX_FDD |
	    RRM_MAC_MAIN_CONFIG_EXT_SCELL_ACTIVATE_STATUS |
	    RRM_PCELL_PHY_CONFIG_DEDICATED_PRESENT |
	    RRM_PCELL_MAC_CONFIG_PARAM_PRESENT |
	    PCELL_ANTENNA_INFO_R10_PRESENT |
	    PCELL_CQI_INFO_R10_PRESENT |
	    PCELL_PHY_CONFIG_DEDICATED_EXT_PRESENT);
    RRM_UT_TRACE_ENTER();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_add_scell_to_ue
 *   input      : Num of SCells to be added, array of Cell Indexes
 *   output     : none
 *   DESCRIPTION:Function send the UE Reconfig Req if Scell is to be added on UE.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_add_scell_to_ue(
	rrm_ue_context_t *p_rrm_ue_context, 
	U8 num_of_scell, 
	rrm_cell_index_t *p_arr_cell_index)
{
    rrm_return_et                             ret_val = RRM_SUCCESS;
    U64                                       ca_param_bitmask = RRM_ZERO;

    /*  LAA Rel13 Code + */
    /*  LAA Rel13 Code - */

    RRM_UT_TRACE_ENTER();
    if( RRM_PNULL != p_rrm_ue_context )
    {
        if(num_of_scell > RRM_ZERO)      /*Validate if any SCells provided were valid & in Active State*/
        {
            RRM_MEMSET(p_rrm_ue_context->ue_scell_add_params.scell_cell_index_add_bkp, RRM_OUT_OF_RANGE, RRM_MAX_SCELL);
            fill_init_bitmask_for_cell_addition(&ca_param_bitmask);

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Num of Scell count: %d", num_of_scell);
            /*populate the ue_reconfig_req parameters*/
            ret_val = rrm_fill_scell_add_params(p_rrm_ue_context, num_of_scell , p_arr_cell_index, ca_param_bitmask);
            if(ret_val == RRM_FAILURE)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "SCell addition failed. Failed to send UE Reconfig Req. to RRC.");
            }
        }
        else
        {
            /* If all the Scell Reported after Scell selection is 0xFF or they are not in Active state at time of addition */
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "There are no valid cells for Scell addition");
        }
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not add scell for the Null UE Context!");
    }
    RRM_UT_TRACE_EXIT(); 
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_find_scell_index_position 
 *   input      : Scell index, array of Cell Indexes
 *   output     : none
 *   DESCRIPTION:Function search scell index in array of rrm_scell_info_for_ue_t.
 *   RETURNS    :
 *               RRM_SUCCESS/RRM_FAILURE
 *******************************************************************************/
rrm_return_et
rrm_find_scell_index_position(rrm_cell_index_t scell_index,
    rrm_ue_scell_add_params_t *p_scell_param, rrm_cell_index_t *p_rrm_cell_index)
{
    U8 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    
    RRM_UT_TRACE_ENTER();
    for (index = RRM_ZERO;index <p_scell_param->count; index++)
    {
        if(p_scell_param->rrm_scell_info_for_ue[index].scell_cell_index == scell_index)
        {
            *p_rrm_cell_index = index;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Scell index found at index:%d", index);
            ret_val = RRM_SUCCESS;
            break;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val ;
}
/* CA Scell Addition functions : End */

/* SPR 9216:MRO enhancement start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_reestab_config_cnf 
 *   INPUT        : p_api_buf, api_id, data_len, p_rrm_ue_rrc_msg
 *   OUTPUT       : none
 *   DESCRIPTION  : Parse the UE reestablishment config cnf API.
 *   RETURNS      : RRM_SUCCESS on Success
 *                  RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_reestab_config_cnf
(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
)
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    S32                              length_read = RRM_NULL;
    rrc_rrm_ue_reestab_config_cnf_t  rrc_rrm_ue_reestab_config_cnf = {RRM_ZERO};
    /* SPR 17843 Fix Start */
    U8                                  *p_response = RRM_PNULL;
    /* SPR 17843 Fix End */

    RRM_UT_TRACE_ENTER();

    /* SPR 17843 Fix Start */
    p_response = (U8 *)rrm_mem_get(sizeof(U8));
    if(RRM_PNULL == p_response)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    " Memory Allocation failed for p_response");
            return RRM_FAILURE;
        }
    /* SPR 17843 Fix End */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_reestab_config_cnf(
                            &rrc_rrm_ue_reestab_config_cnf,
                            p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                            data_len,
                            &length_read))
    {
        p_rrm_ue_rrc_msg->ue_index = rrc_rrm_ue_reestab_config_cnf.ue_index;
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_UE_REESTAB_CONFIG_CNF:[UE:%d] with response: %d",
                rrc_rrm_ue_reestab_config_cnf.ue_index, rrc_rrm_ue_reestab_config_cnf.response);

        /* SPR 17843 Fix Start */
        *p_response = rrc_rrm_ue_reestab_config_cnf.response;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "*p_response [%d]",
                  *p_response);

        p_rrm_ue_rrc_msg->p_msg_data = p_response;
        /* SPR 17843 Fix End */
   }
   else
   {
       /*Cov_fix_54424*/
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->UEM:RRC_RRM_UE_REESTAB_CONFIG_CNF parsing failed");

       /*Cov_fix_54424*/
       ret_val = RRM_FAILURE;
   }

   RRM_UT_TRACE_EXIT();

   return ret_val;
}
/* SPR 9216:MRO enhancement end */



/******************************************************************************
 *   FUNCTION NAME: rrm_select_cqi_mode_for_cell 
 *   INPUT      : p_rrm_ue_context, *scell_count, scell_enough_report[]
 *   OUTPUT     : none
 *   DESCRIPTION: This function selects CQI mode for Pcell based on CQI of 
 *                Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_select_cqi_mode_for_cell( rrm_cqi_reporting_mode_et oam_config_cqi_mode,
                               rrm_ue_context_t      *p_rrm_ue_context,
                               U8                    *selected_cqi_mode)
{
    U8 scell_count = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_ue_service_profile_t    *p_ue_service_profile   = RRM_PNULL;
    rrc_phy_physical_config_dedicated_ue_service_profile_t
                                    *p_ue_profile_physical_config_dedicated = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
     
    *selected_cqi_mode = oam_config_cqi_mode;

    if(p_rrm_ue_context != RRM_PNULL)
    {
        /*UT-Fix*/
        if( p_rrm_ue_context->ue_scell_add_params.count > RRM_ZERO &&
            p_rrm_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL )
        {
            for(scell_count = RRM_ZERO; scell_count < p_rrm_ue_context->ue_scell_add_params.count; scell_count++)
            {
                p_ue_service_profile = rrm_cellm_get_ue_service_profile(p_rrm_ue_context->ue_scell_add_params.
                                                                    rrm_scell_info_for_ue[scell_count].scell_cell_index);
                p_ue_profile_physical_config_dedicated = &(p_ue_service_profile->radio_res_config.physical_config_dedicated);

                switch(p_ue_profile_physical_config_dedicated->cqi_reporting.
                             rrm_cqi_reporting_mode_configured)
                {  
                    case RRM_DISABLE_CQI_REPORTING:
                    case RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED:
                         break;
                    /* In case the Pcell supports No CQI mode or Periodic CQI mode & any of the scell supports 
                       Aperiodic or Periodic-Aperiodic mode then for Pcell the CQI mode will be changed accordingly 
                       at runtime. */
                    case RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED:
                    case RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED:
                         if(oam_config_cqi_mode == RRM_DISABLE_CQI_REPORTING)
                         {
                             *selected_cqi_mode = RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED;
                         }
                         else if(oam_config_cqi_mode == RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED)
                         {
                             *selected_cqi_mode = RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED;
                         }
                         break;
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "CQI mode is not selected as no Scell is present for UE");
        }
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "NULL POINTER EXCEPTION for ue context!!");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_check_scell_report_count
 *   INPUT      : p_rrm_ue_context, *scell_count, scell_enough_report[]
 *   OUTPUT     : none
 *   DESCRIPTION: 
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_bool_et
rrm_check_scell_report_count( rrm_ue_context_t      *p_rrm_ue_context,
                              U8                    *scell_valid_rep_count,
                              rrm_cell_index_t      *p_arr_cell_index)
{
    U8 scell_count = RRM_ZERO;
    rrm_bool_et ret_val = RRM_FALSE;
    
    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        if(p_rrm_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL )
        {
            for(scell_count = RRM_ZERO; scell_count < p_rrm_ue_context->ue_scell_add_params.count; scell_count++)
            {
                if(p_rrm_ue_context->ue_scell_add_params.
                      rrm_scell_info_for_ue[scell_count].scell_periodic_stats.scell_report_count >= RRM_MAX_REPORT_STAT_UE)
                {
                    p_arr_cell_index[*scell_valid_rep_count] =
                                p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_cell_index;
                    (*scell_valid_rep_count)++;

                    ret_val = RRM_TRUE;
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "NULL POINTER EXCEPTION for ue context!!");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_aperiodic_csi_trigger
 *   INPUT      : p_aperiodic_csi_trigger
 *   OUTPUT     : none
 *   DESCRIPTION: fills the trigger1-r10 & trigger2-r10 if Aperiodic Mode is 
 *                selected for the UE with Scells configured.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_aperiodic_csi_trigger(
             rrm_ue_context_t *p_rrm_ue_context,
             rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger_t *p_aperiodic_csi_trigger )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 count = RRM_ZERO;
    U8 trigger_val = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if( p_rrm_ue_context != RRM_NULL)
    {
        if(p_rrm_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL)
        {
            for(count = RRM_ZERO; count < p_rrm_ue_context->ue_scell_add_params.count; count++)
            {
                /* To check if scell also support Aperiodic Mode, else for that Scell Trigger bit will be zero */
                if(rrm_check_cqi_mode_config_aperiodic_on_scell(p_rrm_ue_context->ue_scell_add_params.
                                              rrm_scell_info_for_ue[count].scell_cell_index) == RRM_TRUE)
                {
                    trigger_val |= (0x80>>(p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index));
                }
            }
        }

        p_aperiodic_csi_trigger->trigger1 = trigger_val;
        p_aperiodic_csi_trigger->trigger2 = (0x80 | trigger_val);
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
		"Null pointer Exception for UE context ");
        ret_val = RRM_FAILURE;
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_check_scell_index_report_received
 *   INPUT      : p_rrm_ue_context, index, count
 *   OUTPUT     : none
 *   DESCRIPTION: Checks if reports received from L2 for given scell index.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_bool_et
rrm_check_scell_index_report_received( rrm_ue_context_t *p_rrm_ue_context,
                                   U8 index,
                                   U8 count )
{
    rrm_bool_et ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    /* + SPR 20078 */
    if((p_rrm_ue_context->p_ue_mac_report->ue_stats[count].bitMask & RRM_MAC_UE_PERIODIC_SCELL_REPORT_PRESENCE_BITMASK) &&
	    (p_rrm_ue_context->p_ue_mac_report->ue_stats[count].scellReportBitMask & (RRM_ONE<<index)))
    /* - SPR 20078 */
    {
	ret_val =  RRM_TRUE; 
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_dl_sinr_cw1_consider_scell
 *   INPUT      : p_rrm_ue_context, scell_index, count, index
 *   OUTPUT     : none
 *   DESCRIPTION: Returns TRUE if dl sinr cw1 to be considered for scell, else
 *                FALSE. 
 *   RETURNS    :
 *               RRM_TRUE if dl_sinr_cw1 to be considered for scell. 
 *               RRM_FALSE if dl_sinr_cw1 not to be considered for scell.
*******************************************************************************/
rrm_bool_et
rrm_get_dl_sinr_cw1_consider_scell( rrm_ue_context_t *p_rrm_ue_context,
         /*SPR 17777 +-*/
                                    U8 index )
{
    U8 dl_sinr_cw1_least_report_percentage = RRM_ZERO;
    U8 dl_sinr_scell_cw1 = RRM_ZERO; 
    U8 count = RRM_ZERO;
    rrm_bool_et ret_dl_sinr_scell_cw1 = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    if( RRM_NULL != p_rrm_ue_context )
    {
        for( count = RRM_ZERO;(( count < RRM_MAX_REPORT_STAT_UE ) &&
                    ( count < p_rrm_ue_context->p_ue_mac_report->report_index )) ; count++ )
        {
            if( (RRM_TRUE == rrm_check_scell_index_report_received(p_rrm_ue_context, index, count)) &&
                    (p_rrm_ue_context->p_ue_mac_report->ue_stats[count].scellReport[index].downlinkSINRValueCW1))
            {
                dl_sinr_scell_cw1++;
            }
        }
        if( p_rrm_ue_context->p_ue_mac_report->report_index >= RRM_MAX_REPORT_STAT_UE )
        {
            dl_sinr_cw1_least_report_percentage = ( ( RRM_MAX_REPORT_STAT_UE * RRM_DELTA_SINR_COUNT_PERCENT ) / RRM_PERCENTAGE ) ;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                    "Report index are gretar than or equal to RRM_MAX_REPORT_STAT_UE"
                    "considering the 70 perent of RRM_MAX_REPORT_STAT_UE [20] reports  as dl_sinr_cw1_least_report_percentage");
        }
        else
        {
            dl_sinr_cw1_least_report_percentage = ( p_rrm_ue_context->p_ue_mac_report->report_index + RRM_ONE );

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                    "Report index are less than RRM_MAX_REPORT_STAT_UE"
                    "existing report index count as dl_sinr_cw1_least_report_percentage");
        }

        if( dl_sinr_scell_cw1 >= dl_sinr_cw1_least_report_percentage )
        {
            ret_dl_sinr_scell_cw1 = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                    "Number of downlink sinr cw1 count [%d] >= dl_sinr_cw1_least_report_percentage count [%d]  ",
                    dl_sinr_scell_cw1 , dl_sinr_cw1_least_report_percentage );
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                    "Number of downlink sinr cw1 count [%d] < dl_sinr_cw1_least_report_percentage [%d]  ",
                    dl_sinr_scell_cw1 , dl_sinr_cw1_least_report_percentage );
        }
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
		"Null pointer Exception for UE context ");
    }

    RRM_UT_TRACE_EXIT();
    return ret_dl_sinr_scell_cw1;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_scell_sinr_pathloss_mobility_levels
 *   INPUT      : p_sinr_level, p_pathloss_level, p_mobility_level, 
 *                scell_index, p_rrm_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION: Gives value for p_sinr_level, p_pathloss_level & 
 *                p_mobility_level for a given UE using the given scell index.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_get_scell_sinr_pathloss_mobility_levels( rrm_level_t      *p_sinr_level,
                                             rrm_level_t      *p_pathloss_level,
                                             rrm_level_t      *p_mobility_level,
                                             rrm_cell_index_t  scell_index,
                                             rrm_ue_context_t *p_rrm_ue_context )
{
    U8 report_count = RRM_ZERO;
    U8 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    U32 avg_downlink_sinr_scell = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    U32 tm_scell_sinr_threshold = rrm_get_tm_sinr_threshold(scell_index);

    U32 tm_scell_pathloss_threshold = rrm_get_tm_pathloss_threshold(scell_index);

    if( ( p_rrm_ue_context != RRM_NULL ) &&
	    ( RRM_SUCCESS == rrm_get_scell_index_for_scell_cell_index(p_rrm_ue_context, 
								      scell_index, 
								      &index, 
								      &report_count)))
    {
	if( report_count <= RRM_MAX_REPORT_STAT_UE )
	{
         /*SPR 17777 +-*/
		if( rrm_get_dl_sinr_cw1_consider_scell(p_rrm_ue_context,index))
		{
		    avg_downlink_sinr_scell = ( (p_rrm_ue_context->ue_avg_stats.scellReport[index].downlinkSINRValueCW0 + 
				p_rrm_ue_context->ue_avg_stats.scellReport[index].downlinkSINRValueCW1) / RRM_TWO);

		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] Scell's Average downlink sinr of avg of cw0 and cw1,cosidering both cw0 and cw1"
			    " for calculating the resultant average[%d]",
			    p_rrm_ue_context->ue_index,avg_downlink_sinr_scell );
		}
		else
		{
		    avg_downlink_sinr_scell = ( p_rrm_ue_context->ue_avg_stats.scellReport[index].downlinkSINRValueCW0 );

		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] Scell's Average downlink sinr [%d] of cw0 ,considering the only cw0"
			    " for calculating the resultant average",
			    p_rrm_ue_context->ue_index,avg_downlink_sinr_scell );
		}

		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Scell Index[%d] SINR threshold [%d], pathloss threshold [%d] ",
			scell_index, tm_scell_sinr_threshold, tm_scell_pathloss_threshold );

		if( avg_downlink_sinr_scell > tm_scell_sinr_threshold )
		{
		    /*SINR level HIGH for Scell */
		    *p_sinr_level = RRM_HIGH_LEVEL;
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] SINR is high for Scell Cell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}
		else
		{
		    /*SINR level LOW for Scell */
		    *p_sinr_level = RRM_LOW_LEVEL;
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] SINR is low for Scell Cell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}

		/*Note: Currently considering Pathloss for Scell to be equivalent to that of Pcell.
		  1. Pathloss currently not reported by L2 to RRM for any Scell.
		  2. Pcell & Scell are both broadcasted by same eNB and are overlapping cells. Hence the coverage area is almost same. 
		  3. UE location is relatively same for both Pcell & Scell. Hence Enviromental conditions will be same.
		 *** Implementation likely to be changed if Pathloss params are also reported from L2 in future. *** */
                            /* + SPR 20078 */
		if( p_rrm_ue_context->ue_avg_stats.uplinkPathLossValue > tm_scell_pathloss_threshold )
                            /* - SPR 20078 */
		{ 
		    /*Pathloss is HIGH for Scell*/
		    *p_pathloss_level = RRM_HIGH_LEVEL;
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] pathloss is high for Scell Cell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}
		else
		{
		    /*Pathloss is LOW for Scell*/
		    *p_pathloss_level = RRM_LOW_LEVEL;
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] pathloss is low for Scell Cell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}

		if(p_rrm_ue_context->ue_speed_algo_param.ue_speed_param_scell[scell_index].ue_speed_category == RRM_UE_SPEED_CATEGORY_2)
		{
		    /* High Mobility with reference to Scell */
		    *p_mobility_level = RRM_HIGH_LEVEL;
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] mobility is high for Scell Cell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}
		else
		{
		    /* Low Mobility with reference to Scell */
		    *p_mobility_level = RRM_LOW_LEVEL;
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			    "[UE:%d] mobility is low for Scell Cell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		} 
	 }
   }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_tm_mode_based_on_scell_tbl
 *   INPUT      : sinr_level, pathloss_level, mobility_level, p_rrm_ue_context,
 *                scell_index
 *   OUTPUT     : Transmission Mode for the given scell
 *   DESCRIPTION: returns the TM for the given scell index, based on the
 *                tm_mode_tbl & sinr, pathloss & mobility levels.
 *   RETURNS    :
 *               Transmission Mode for the given scell index.
 *               
*******************************************************************************/
transmission_mode_ue_service_profile_et rrm_get_tm_mode_based_on_scell_tbl(
                              rrm_level_t       sinr_level,
                              rrm_level_t       pathloss_level,
                              rrm_level_t       mobility_level,
                              rrm_ue_context_t  *p_rrm_ue_context,
                              rrm_cell_index_t  scell_index )
{
   transmission_mode_ue_service_profile_et      tm_mode = TRANSMISSION_MODE_TM1;
   const rrm_transmission_mode_table_t          *p_tm_mode_tbl = RRM_NULL;

   RRM_UT_TRACE_ENTER();

   p_tm_mode_tbl = rrm_get_tm_mode_table(scell_index);

   if( RRM_NULL != p_tm_mode_tbl )
   { 
       if(( p_tm_mode_tbl->bitmask & RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT ) &&
          ( is_stringent_qci_present(p_rrm_ue_context) == RRM_TRUE))
       {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%u] "
                   "Stringent qci(3/5) is present and stringent qci is set as true "
                   "in tm mode table, proving tm mode as configured for stringent qci",
                   p_rrm_ue_context->ue_index);

           tm_mode = p_tm_mode_tbl->tm_mode_for_strngnt_qci;
       }
       else
       {
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Stringent qci(3/5) rab is  not present for UE ,looking into table "
                    "Stringent qci(3/5) rab configuration is not coming from oam,looking into table for [UE:%u]",
                   p_rrm_ue_context->ue_index);

           tm_mode = rrm_assign_tm_mode_from_tbl_entry( sinr_level,
                   pathloss_level,
                   mobility_level,
                   p_tm_mode_tbl );
       }
   }
   else
   {
       /* if transmission mode table does not come from oam than this fucntion will not
          be called because it callee function have prior check if table exist then only
          this function is called otherwise we take decision on based of sinr only
          as i prior check has validated for transmission mode table. so again we are not
          assigniing the transmsision mode on basis of sinr
          Note :  this null check is put due to coveirty warnings */
       RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
               "p_tm_mode_tbl transmission mode table is not coming from OAM ");
   }

   RRM_UT_TRACE_EXIT();
   return tm_mode;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fallback_mode_for_transmission_mode_on_scell
 *   INPUT      : transmission_mode, p_ue_context, scell_index
 *   OUTPUT     : none
 *   DESCRIPTION: returns TRUE/FALSE if fallback needed in case of TM-7 or TM-8
 *   RETURNS    :
 *               RRM_TRUE 
 *               RRM_FALSE
*******************************************************************************/
rrm_bool_et
rrm_fallback_mode_for_transmission_mode_on_scell( transmission_mode_ue_service_profile_et
                                                                       transmission_mode,
                                                  rrm_ue_context_t     *p_ue_context,
                                                  rrm_cell_index_t      scell_index)
{
    rrm_bool_et                           beamforming_vector_present = RRM_FALSE;
    rrm_enb_mode_t                        mode = FDD_MODE;
    rrm_bool_et                           fallback = RRM_TRUE;
    const rrm_tm_mode_additional_info_t  *p_rrm_tm_mode_additional_info = RRM_NULL;

    const rrm_mac_beam_forming_info_t      *p_rrm_mac_beam_forming_info = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    /*beamforming info */
    p_rrm_mac_beam_forming_info = rrm_cm_get_mac_beam_forming_info( scell_index );

    /* additional info of tm mode from rrm.cfg  */
    p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info( scell_index );

    if( ( RRM_NULL != p_rrm_tm_mode_additional_info ) &&
	    ( RRM_NULL != p_rrm_mac_beam_forming_info )  )
    {
	/* beamformig algo is configured */
	if( RRM_TRUE == p_ue_context->beam_forming_algo_configd_for_TM7_8 )
	{
	    /* sinr vector present in rrm.cfg */
	    if( ( BEAM_FORMING_SINR == p_rrm_tm_mode_additional_info->beam_forming_algo ) &&
		    ( p_rrm_mac_beam_forming_info->bitmask & RRM_SINR_TO_BEAM_FRMNG_CONFIG_PRESENT ) )
	    {
		beamforming_vector_present = RRM_TRUE;
	    }
	    else if( ( BEAM_FORMING_AOA == p_rrm_tm_mode_additional_info->beam_forming_algo ) &&
		    ( p_rrm_mac_beam_forming_info->bitmask & RRM_AOA_TO_BEAM_FRMNG_VECTOR_MPPNG_PRESENT ) )
	    {
		beamforming_vector_present = RRM_TRUE;
	    }
	}

	if( RRM_TRUE == beamforming_vector_present )
	{
	    if( ( TRANSMISSION_MODE_TM8_V920 == transmission_mode ) )
	    {
		/* mode of eutran */
		mode = rrm_cellm_get_fdd_tdd_mode( scell_index );

		/* in existing mode tm-8 is supported by Ue or not  */
		if(  RRM_TRUE == is_tm8_supported_by_ue_capa( p_ue_context, mode ) )
		{
		    fallback = RRM_FALSE;

		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			    "TM-8 is supported by [UE:%d],Fallback is not needed",p_ue_context->ue_index );
		}
		else
		{
		    fallback = RRM_TRUE;

		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			    "TM-8 is not supported by [UE:%d],Fallback is needed",p_ue_context->ue_index );
		}

	    }
	    else if( TRANSMISSION_MODE_TM7 == transmission_mode )
	    {
		fallback = RRM_FALSE ;

		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			"Fallback of TM-7 is not needed for [UE:%d]",p_ue_context->ue_index );
	    }
	}
	else
	{
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Beamforming algo is not configured with its vector at MAC for [UE:%u]"
		    "Fallback of transmission mode [%d] is needed ",p_ue_context->ue_index,transmission_mode );

	    fallback = RRM_TRUE;
	}
    }
    else
    {
	fallback = RRM_TRUE;

	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
		"NULL pointer exception for p_rrm_tm_mode_additional_info/p_rrm_mac_beam_forming_info"
		"for [UE:%d]",p_ue_context->ue_index );
    }

    RRM_UT_TRACE_EXIT();
    return fallback ;
}


/* SPR-19276 START */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_ue_location
 *   DESCRIPTION:   To get the ue_location as CC or CE
 *   RETURNS:
 *       RRM_UE_POSITION_AT_CELL_CENTER
 *       RRM_UE_POSITION_AT_CELL_EDGE
 ******************************************************************************/
rrm_ue_position_et
rrm_get_ue_location
(
rrm_ue_context_t            *p_ue_ctxt
)
{
    U32      ul_path_loss_for_ue = RRM_ZERO;
    U32      ul_path_loss_threshold_for_ue = RRM_ZERO;
    rrm_cell_context_t  *p_cell_ctxt = RRM_PNULL;
    rrm_ue_position_et ue_location = RRM_UE_POSITION_AT_CELL_CENTER;


    p_cell_ctxt = rrm_cellm_get_cell_context(p_ue_ctxt->cell_index);
    if(p_cell_ctxt != RRM_PNULL)
    {

        /* Avg UL PL reported by UE */
                            /* + SPR 20078 */
        ul_path_loss_for_ue = p_ue_ctxt->ue_avg_stats.uplinkPathLossValue;
                            /* - SPR 20078 */

        /* UL PL threshold specified by User*/
        ul_path_loss_threshold_for_ue = p_cell_ctxt->rrm_olpc_config_params.ul_pathloss_threshold;
        /*
         ** If the avg reported PL from UE is greater than the threshold , 
         ** UE is concidered to be at Cell Edge (CE)
         */
        if( ul_path_loss_for_ue > ul_path_loss_threshold_for_ue )
        {
            ue_location = RRM_UE_POSITION_AT_CELL_EDGE;
        }
        else
        {
            ue_location = RRM_UE_POSITION_AT_CELL_CENTER;
        }
    }
    return ue_location;


}
/* SPR-19276 END */


/******************************************************************************
 *   FUNCTION NAME: rrm_scell_select_tx_mode
 *   INPUT      : p_ue_context, scell_index, p_transmission_mode
 *   OUTPUT     : none
 *   DESCRIPTION: Finds the best suitable TX Mode based on several params 
 *                calculated from L2 reports.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_scell_select_tx_mode(rrm_ue_context_t   *p_rrm_ue_context,
                         rrm_cell_index_t    scell_index,
                         transmission_mode_ue_service_profile_et
                                            *p_transmission_mode)
{
    rrm_return_et                           ret_val = RRM_SUCCESS;
    const rrm_transmission_mode_table_t    *p_tm_mode_tbl = RRM_NULL;
    rrm_level_t                             sinr_level = RRM_LOW_LEVEL;
    rrm_level_t                             pathloss_level = RRM_LOW_LEVEL;
    rrm_level_t                             mobility_level = RRM_LOW_LEVEL;
    rrm_bool_et                             fallback = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    /* Get TM mode table of Scell from scell's cell index */
    p_tm_mode_tbl = rrm_get_tm_mode_table(scell_index);
    
    /* Check Scell's SINR, Pathloss & Mobility levels */
	/* Note: 1. Only SINR being reported currently by MAC layer.
	   2. Pathloss of Scell will be similar to Pcell.
	   3. Mobility of Scell shall bepend on SINR reported.
	 */
	rrm_get_scell_sinr_pathloss_mobility_levels(&sinr_level,
   		                                    &pathloss_level,
		                                    &mobility_level,
                                            scell_index,
		                                    p_rrm_ue_context);

    if(RRM_NULL != p_tm_mode_tbl)
    {
    /*get the transmission mode from the table*/
	*p_transmission_mode = rrm_get_tm_mode_based_on_scell_tbl( sinr_level,
		                                                 pathloss_level,
		                                                 mobility_level,
		                                                 p_rrm_ue_context,
		                                                 scell_index );

	/* check for fallback is needed for tm-7/tm8 */
	if( ( TRANSMISSION_MODE_TM7 == *p_transmission_mode ) ||
		( TRANSMISSION_MODE_TM8_V920 == *p_transmission_mode ) )
	{
	    fallback = rrm_fallback_mode_for_transmission_mode_on_scell( *p_transmission_mode,
		                                                          p_rrm_ue_context,
                                                                          scell_index );
	    if( RRM_TRUE ==  fallback )
	    {
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
			"fallingback for [UE:%d]", p_rrm_ue_context->ue_index );

		if( RRM_HIGH_LEVEL == sinr_level )
		{
		    *p_transmission_mode = TRANSMISSION_MODE_TM3;

		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%d] "
			    "TM MODE 3 is selected as SINR is high for Scell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}
		else
		{
		    *p_transmission_mode = TRANSMISSION_MODE_TM2;

		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%d] "
			    "TM MODE 2 is selected as SINR is low for Scell Index[%d]",
			    p_rrm_ue_context->ue_index, scell_index);
		}
	    }
	}
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
		"No transmission mode table is received for [UE:%d], switching to fallback mode for Scell Index[%d]",
		p_rrm_ue_context->ue_index, scell_index);

	if( RRM_HIGH_LEVEL == sinr_level )
	{
	    *p_transmission_mode = TRANSMISSION_MODE_TM3;

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%d] "
		    "TM MODE 3 is selected as SINR is high for Scell Index[%d]",
		    p_rrm_ue_context->ue_index, scell_index);
	}
	else
	{
	    *p_transmission_mode = TRANSMISSION_MODE_TM2;

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "[UE:%d] "
		    "TM MODE 2 is selected as SINR is low for Scell Index[%d]",
		    p_rrm_ue_context->ue_index, scell_index);
	}
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_scell_check_scell_tm_change_condition
 *   INPUT      : port, p_ue_context, ue_category, scell_index,
 *                p_transmission_mode
 *   OUTPUT     : none
 *   DESCRIPTION: Checks which TX modes will be best suitable for given 
 *                antenna count & UE category.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_scell_check_scell_tm_change_condition(U8                   port,
                                          rrm_ue_context_t    *p_ue_context,
                                          rrm_ue_category_et   ue_category,
                                          rrm_cell_index_t     scell_index,
                                          transmission_mode_ue_service_profile_et
                                                              *p_transmission_mode)
{
    rrm_return_et              ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* SPR 21251 +- */

    if(ANTENNA_PORTS_COUNT_AN1 == port)
    {
	/*TM-1, port count = 1 , */
	*p_transmission_mode = TRANSMISSION_MODE_TM1;
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
		"No. of Port[%d], UE Category [%d],Transmission mode TM-1 is decided",port,ue_category);

    }

    else if( ANTENNA_PORTS_COUNT_AN2 == port || ANTENNA_PORTS_COUNT_AN4 == port)
    {
	if((ue_category >= UE_CATEGORY_6) && (ue_category <= UE_CATEGORY_8))/* UE Category 6, 7, 8: supported for CA & Rel-10 */
	{
	    /* this function detremine the TM mode among TM-2,TM-3,TM-4 */
	    ret_val = rrm_scell_select_tx_mode( p_ue_context,
		                                scell_index,
		                                p_transmission_mode );

	    if( RRM_FAILURE == ret_val )
	    {
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
			"No. of port [%d], UE Category is [%d] ,Transmission mode decision could not be taken for the UE",
            port, ue_category);
	    }
	}
	else
	{
            /* For CA, UE shall be UE Cat. 6-8 so this code will not be hit ever. Only for error handling 
               default TM-2 is assigned for scell. */
	    /*TM-2 */
	    *p_transmission_mode = TRANSMISSION_MODE_TM2;

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, \
		    "No. of port [%d], UE Category is [%d] or None, For CA UE cat shall be greater than 5. TM-2 selected.",
            port, ue_category);
	}
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Antenna Port[%d] for UE Category [%d]"
                "not supported,Failed to select the Transmission Mode",port, ue_category);

        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_set_scell_transmission_mode
 *   INPUT      : transmission_mode, p_antenna_info_dedicated_r10, 
 *                p_rrm_ue_context, scell_index
 *   OUTPUT     : none
 *   DESCRIPTION: calls the TX Mode functions based on the transmission mode. 
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_set_scell_transmission_mode(transmission_mode_ue_service_profile_et 
                                                          transmission_mode,
                        	rrc_antenna_info_dedicated_r10_t 
                                                    *p_antenna_info_dedicated_r10,
	                        rrm_ue_context_t    *p_rrm_ue_context,
                                rrm_cell_index_t     scell_index )
{
    antenna_info_t *p_antenna_info = rrm_cellm_get_antenna_info( scell_index );
    RRM_UT_TRACE_ENTER();

    /* Create new array for Scell's TM mode */
    tx_mode_scell[transmission_mode]( p_antenna_info_dedicated_r10, p_antenna_info, 
                                          p_rrm_ue_context, scell_index);
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_transmission_mode_r10
 *   INPUT      : p_antenna_info_dedicated_r10, scell_index, p_rrm_ue_context,
 *                p_antenna_match
 *   OUTPUT     : none
 *   DESCRIPTION: Select & set the TX mode for scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_return_et
rrm_fill_scell_transmission_mode_r10(
rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
rrm_cell_index_t                  scell_index,
rrm_ue_context_t                 *p_rrm_ue_context,
rrm_bool_et                      *p_antenna_match)
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    U8                          port = RRM_ZERO;
    rrm_ue_category_et          ue_category = UE_CATEGORY_NONE;
    transmission_mode_ue_service_profile_et
	transmission_mode = TRANSMISSION_MODE_TM1;

    RRM_UT_TRACE_ENTER();

    /* Check Scell for Antenna Port Count & Ue Capa for UE Category */
    if( RRM_SUCCESS == rrm_cellm_get_antenna_port(scell_index,&port))
    {
        if(p_rrm_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
        {
            /* ue category */
            ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_rrm_ue_context);
        }

        /* Check if Scell's TM Mode shall be changed */
        ret_val = rrm_scell_check_scell_tm_change_condition(port,
                p_rrm_ue_context,
                ue_category,
                scell_index,
                &transmission_mode );
        /* Set the Scell's TM params, if TM needs to be changed for Scell */
        if(ret_val == RRM_SUCCESS)
        {
            rrm_set_scell_transmission_mode(transmission_mode,
                    p_antenna_info_dedicated_r10,
                    p_rrm_ue_context,
                    scell_index );

            ret_val = rrm_compare_scell_ue_antenna_info_r10(p_rrm_ue_context,
                    p_antenna_info_dedicated_r10,
                    scell_index,
                    p_antenna_match);

            if( (RRM_SUCCESS == ret_val) && (RRM_FALSE == *p_antenna_match) )
            {
                /* backup the antenna_info_dedicated_r10 for scell in ue_context */
                rrm_backup_tm_scell_info(p_rrm_ue_context, scell_index);

                /* store the scell's TM mode info in ue_context */
                ret_val = rrm_set_scell_tm_info_r10( p_rrm_ue_context, 
                        scell_index,
                        p_antenna_info_dedicated_r10);

                /*Transmission mode is switched*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "Transmission mode "
                        "is switched for [UE:%d] on scell cell index[%d]",p_rrm_ue_context->ue_index, scell_index);

            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Scell_CBSR_fill: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm1
 *   INPUT      : 
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-1 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm1( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{
    RRM_UT_TRACE_ENTER();
    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM1;

         /*SPR 17777 +-*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
	    "Transmission mode TM-1 is decided and Assigned for scell Cell Index[%d]"
        "Unused variable p_antenna_info=%p p_ue_context=%p ",scell_index,p_antenna_info,p_ue_context);
         /*SPR 17777 +-*/

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm2
 *   INPUT      : 
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-2 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm2( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{
    RRM_UT_TRACE_ENTER();
    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM2;

         /*SPR 17777 +-*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
	    "Transmission mode TM-2 is decided and Assigned for scell Cell Index[%d]"
        "Unused variable p_antenna_info=%p p_ue_context=%p ",scell_index,p_antenna_info,p_ue_context);
         /*SPR 17777 +-*/

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm3
 *   INPUT      : 
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-3 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm3( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{

    U8                       index = RRM_ZERO;
    U8                       port = RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;
    
    RRM_UT_TRACE_ENTER();

    /* Set TM-3 for Scell */
    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM3;

    if(RRM_SUCCESS == rrm_cellm_get_antenna_port( scell_index, &port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
         /*SPR 17777 +-*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!;Unused variable p_ue_context=%p",p_ue_context);
         /*SPR 17777 +-*/
    }

    if( ANTENNA_PORTS_COUNT_AN2 == port )
    {
        type = RRM_ZERO ;
        cbsr_type = N2_TX_ANTENNA_TM3;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM3;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N2_TX_ANTENNA_TM3 is configured");
    }
    else if( ANTENNA_PORTS_COUNT_AN4 == port )
    {
        type = RRM_ONE ;
        cbsr_type = N4_TX_ANTENNA_TM3;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM3;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N4_TX_ANTENNA_TM3 is configured");

    }

    /* Set Num cbsr bits of CBSR to be sent to UE */
    p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for(index = RRM_ZERO; index < p_antenna_info->num_cbsr; index ++ )
    {
        if( type == p_antenna_info->cbsr[index].type)
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);

            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;

        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        cbsr_mask = cbsr[ RRM_ZERO ];
        RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));

        if( N4_TX_ANTENNA_TM3  == cbsr_type )
        /* For Scell addition the UE will always be Rel 10 & UE Category will always be greater than 5 and these 
           conditions are checked at time of Scell selection logic only. So only 4x4 & 2x2 modes will be valid for 
           Scell.*/
	{
            /* 4x4 TX-RX mode */
	    cbsr[ RRM_ZERO ] = cbsr_mask & RRM_N4_TX_UE_CAT_5_CBSR_TM3_MASK; /* 0xF0 : 1111 0000, 0 , 0 , 0 ,0 , 0 , 0 , 0 */

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Anetnna type is N4_TX_ANTENNA_TM3 but ue category is greater than 5"
		    "masking the all bits except first byte with 0xF0");

	    if( RRM_ZERO == cbsr[ RRM_ZERO ])
	    {
		cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_5_CBSR_TM3_MASK;

		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Anetnna type is N4_TX_ANTENNA_TM3 and ue category is greater than 5"
			"Afer masking the cbsr becoming zero, so providing default cbsr : 0xF0 for 4 x 4");
	    }
        }
        else if( N2_TX_ANTENNA_TM3  == cbsr_type )
        {
            /* 2x2 TX-RX mode */
            cbsr[ RRM_ZERO ] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM3_MASK; /* C0 : 1100 0000, 0 , 0, 0, 0, 0 ,0 , 0 */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM3,masking first byte with 0xC0");

            if( RRM_ZERO == cbsr[ RRM_ZERO ] )
            {
                cbsr[ RRM_ZERO ] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM3_MASK;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N2_TX_ANTENNA_TM3,After masking cbsr becoming zero"
                "so provinding defaulr cbsr 0xC0 for 2x2");
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "CBSR type is not found in info coming from OAM.so intializing the"
                  "cbsr by its default value"); 

        if( N4_TX_ANTENNA_TM3 ==  cbsr_type)
	{
            /* 4x4 MIMO selection */
	    cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_5_CBSR_TM3_MASK ; /* 0xF0: 1111 0000, 0 , 0 ....*/

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
		    "UE category is 5 and antenna type is N4_TX_ANTENNA_TM3 ,"
		    "so 4 most significant bits of cbsr are set");
	}
        else if( N2_TX_ANTENNA_TM3 == cbsr_type )
        {
            /* 2x2 MIMO selection */
            cbsr[ RRM_ZERO ] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM3_MASK ; /* 0xC0 :  1100 0000, 0, 0, 0, 0, 0, 0, 0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
                     "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM3"
                     "so 2 most significant bits of cbsr are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            "Anetnna type and code book subset restrcition value is not configured");
        }
    }

    /* Fill the CBSR bytes */
    p_antenna_info_dedicated_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    /*Copying One Byte only, as CBSR data is within one byte and composer will fill rest 13 bytes with zero*/
    RRM_MEMCPY( p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_ONE );


    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
	    "Transmission mode TM-3 is decided and Assigned for scell Cell Index[%d]",
	    scell_index);

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm4
 *   INPUT      :
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-4 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm4( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{

    U8                       index = RRM_ZERO;
    U8                       port = RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;
    
    RRM_UT_TRACE_ENTER();

    /* Set TM-4 for Scell */
    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM4;

    if(RRM_SUCCESS == rrm_cellm_get_antenna_port( scell_index, &port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
         /*SPR 17777 +-*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!Unused variable p_ue_context=%p",p_ue_context);
         /*SPR 17777 +-*/
    }

    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_TWO ;
        cbsr_type = N2_TX_ANTENNA_TM4;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM4;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N2_TX_ANTENNA_TM4 is configured");
    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_THREE ;
        cbsr_type = N4_TX_ANTENNA_TM4;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM4;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Anetnna type N4_TX_ANTENNA_TM4 is configured");
    }

    /* Set Num cbsr bits of CBSR to be sent to UE */
    p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for(index = RRM_ZERO; index < p_antenna_info->num_cbsr; index ++ )
    {
        if( type == p_antenna_info->cbsr[index].type)
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);

            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;
        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        /* 4x4 MIMO selection */
        if( N4_TX_ANTENNA_TM4 == cbsr_type )
	{
	    if( (( cbsr[RRM_ZERO] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_ONE] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_TWO] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_THREE] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_FOUR] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_FIVE] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_SIX]  & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ) &&
		    (( cbsr[RRM_SEVEN] & RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK ) == RRM_ZERO ))
	    {
		RRM_MEMSET(cbsr ,RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK , sizeof(cbsr));

		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Anetnna type is N4_TX_ANTENNA_TM4 and ue category is 5"
			"After masking cbsr becoming zero, so providing cbsr by its default for 4x4");
	    }
	}
        /* 2x2 MIMO selection */
        else if( N2_TX_ANTENNA_TM4 == cbsr_type )
	{
	    cbsr_mask = cbsr[RRM_ZERO];

	    RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));
	    cbsr[RRM_ZERO] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM4_MASK; /* FC : 1111 1100, 0 ,0 , 0 , 0, 0 ,0 , 0*/

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Anetnna type is N2_TX_ANTENNA_TM4 , masking first byte of cbsr with 0xFC");

	    if( RRM_ZERO == cbsr[RRM_ZERO] )
	    {
		cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM4_MASK;

		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Anetnna type is N2_TX_ANTENNA_TM4 ,After masking cbsr becoming zero"
			"so providing default cbsr 0xFC for 2X2");
	    }
	}
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		"CBSR type is not found in info coming from OAM intializing the"
		"cbsr by its default value");

	/* 4x4 MIMO selection */
	if( ( N4_TX_ANTENNA_TM4 == cbsr_type ) )
	{
	    /* for antenna 4 at eNB, set all the bits of cbsr when TM-4 */
	    for( index = RRM_ZERO; index < RRM_EIGHT ; index++ )
	    {
		cbsr[ index ] = RRM_N4_TX_UE_CAT_5_CBSR_TM4_MASK;
	    }

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
		    "UE category is 5 and antenna type is N4_TX_ANTENNA_TM4,"
		    "so no bits are required to mask ");
	}
	/* 2 x 2 MIMO selection */
	else if( N2_TX_ANTENNA_TM4 == cbsr_type )
	{
	    cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM4_MASK; /*    1111 1100, 0 ,0 , 0 , 0, 0 , 0 ,0  */

	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
		    "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM4"
		    "so 6 most significant bits of cbsr bits are set");
	}
	else /* this condition should not happen */
	{
	    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
		    " Anetnna type and code book subset restrcition value is not configured");
	}
    }

    /* Fill the CBSR bytes */
    p_antenna_info_dedicated_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    /*Copying One Byte only, as CBSR data is within one byte and composer will fill rest 13 bytes with zero*/
    RRM_MEMCPY( p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_EIGHT );

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
	    "Transmission mode TM-4 is decided and Assigned for scell Cell Index[%d]",
	    scell_index);

    RRM_UT_TRACE_EXIT();
}

/* rrm_fill_scell_tm5 this code leg to be implemented for future use */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm5
 *   INPUT      :
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-5 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm5( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{ 

         /*SPR 17777 +-*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "TM-5 not supported currently!"
                  "Unused variable p_ue_context=%p p_antenna_info_dedicated_r10=%p p_antenna_info=%p scell_index=%u"
                  ,p_ue_context,p_antenna_info_dedicated_r10,p_antenna_info,scell_index);
         /*SPR 17777 +-*/
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm6
 *   INPUT      :
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-6 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm6( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{

    U8                       index = RRM_ZERO;
    U8                       port = RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_EIGHT] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;
    
    RRM_UT_TRACE_ENTER();

    /* Set TM-6 for Scell */
    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM6;

    if(RRM_SUCCESS == rrm_cellm_get_antenna_port( scell_index, &port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
         /*SPR 17777 +-*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!Unused variable p_ue_context=%p",p_ue_context);
         /*SPR 17777 +-*/
    }

    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_SIX ;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM6;
        cbsr_type = N2_TX_ANTENNA_TM6;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N2_TX_ANTENNA_TM6  is configured");
    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_SEVEN ;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM6;
        cbsr_type = N4_TX_ANTENNA_TM6;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N4_TX_ANTENNA_TM6 is configured");
    }

    /* Set Num cbsr bits of CBSR to be sent to UE */
    p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;
    
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for( index = RRM_ZERO; index < p_antenna_info->num_cbsr; index ++ )
    {
        if( type == p_antenna_info->cbsr[index].type )
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value , RRM_EIGHT);
            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;
        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        /* 4x4 MIMO selection */
        if( N4_TX_ANTENNA_TM6 == cbsr_type )
        {

            if( ((cbsr[RRM_ZERO] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK) == RRM_ZERO) &&
                ((cbsr[RRM_ONE] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK) == RRM_ZERO) )
            {
                cbsr[RRM_ZERO] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;
                cbsr[RRM_ONE]  = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N4_TX_ANTENNA_TM6, after masking the all bits"
                "are becoming zero, so providing default cbsr for 4 x N");
            }

            RRM_MEMSET( (cbsr + RRM_TWO) ,RRM_ZERO , RRM_SIX );
        }
        /* 2x2 MIMO selection */
        else if( N2_TX_ANTENNA_TM6 == cbsr_type )
        {
             cbsr_mask = cbsr[RRM_ZERO];

             RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));

            /* at the time of declaration of cbsr we have intialized it with zero */
            cbsr[RRM_ZERO] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM6_MASK ; /*    1111 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM6 masking the all bits except 4 most significant bits");

            if( RRM_ZERO == cbsr[RRM_ZERO] )
            {
                cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM6_MASK;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Anetnna type is N2_TX_ANTENNA_TM6,After masking cbsr becoming zero"
                "so providing default cbsr 0xFC for 2x2");
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM. so intializing the"
        "cbsr by its default value");

        /* 4 x 4 MIMO selection */
        if( N4_TX_ANTENNA_TM6 ==  cbsr_type )
        {
            cbsr[ RRM_ZERO ] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;
            cbsr[ RRM_ONE ] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM6_MASK;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "Antenna type is N4_TX_ANTENNA_TM6 , so 16 most significant cbsr bits are set");
        }
        /* 2 x 2 MIMO selection */
        else if( N2_TX_ANTENNA_TM6 == cbsr_type )
        {
            cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM6_MASK;  /*    1111 0000, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM6"
            "so 6 most significant bits of cbsr bits are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            " Anetnna type and code book subset restricition value is not configured");
        }
    }

    /* Fill the CBSR bytes */
    p_antenna_info_dedicated_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    /*Copying One Byte only, as CBSR data is within one byte and composer will fill rest 13 bytes with zero*/
    RRM_MEMCPY( p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_EIGHT );

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
	    "Transmission mode TM-6 is decided and Assigned for scell Cell Index[%d]",
	    scell_index);

    RRM_UT_TRACE_EXIT(); 
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm7
 *   INPUT      :
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-7 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm7( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{
    RRM_UT_TRACE_ENTER();

    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM7;
    
         /*SPR 17777 +-*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
	    "Transmission mode TM-6 is decided and Assigned for scell Cell Index[%d]"
	    "Unused variable p_antenna_info=%p p_ue_context=%p ",scell_index,p_antenna_info,p_ue_context);
         /*SPR 17777 +-*/

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fill_scell_tm8
 *   INPUT      :
 *   OUTPUT     : none
 *   DESCRIPTION: Sets params required for TM-8 for Scell.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
*******************************************************************************/
rrm_void_t 
rrm_fill_scell_tm8( rrc_antenna_info_dedicated_r10_t *p_antenna_info_dedicated_r10,
                              antenna_info_t                   *p_antenna_info,
                              rrm_ue_context_t                 *p_ue_context,
                              rrm_cell_index_t                  scell_index)
{
    U8                       index = RRM_ZERO;
    U8                       port= RRM_ZERO;
    U8                       type = RRM_ZERO;
    U8                       cbsr[RRM_FOUR] = { RRM_ZERO };
    U8                       cbsr_mask = RRM_ZERO;
    U8                       num_cbsr_bit = RRM_ZERO;
    U16                      cbsr_type = RRM_ZERO;
    rrm_bool_et              cbsr_found = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_antenna_info_dedicated_r10->transmission_mode = TRANSMISSION_MODE_TM8_V920;

        if(RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna port count = %d", port);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "rrm_cellm_get_antenna_port returned failure!");
    }

    if(ANTENNA_PORTS_COUNT_AN2 == port)
    {
        type = RRM_EIGHT;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N2_TX_ANTENNA_TM8;
        cbsr_type = N4_TX_ANTENNA_TM8_R9;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N2_TX_ANTENNA_TM8_R9 is configured");
    }
    else if(ANTENNA_PORTS_COUNT_AN4 == port)
    {
        type = RRM_NINE;
        num_cbsr_bit = RRM_NUM_CBSR_BITS_N4_TX_ANTENNA_TM8;
        cbsr_type = N4_TX_ANTENNA_TM8_R9;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Antenna type N4_TX_ANTENNA_TM8_R9 is configured");
    }
    
    /* Set Num cbsr bits of CBSR to be sent to UE */
    p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.num_bits = num_cbsr_bit;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
    "number of cbsr [ %d ] coming from oam ", p_antenna_info->num_cbsr );

    for(index = RRM_ZERO; index < p_antenna_info->num_cbsr; index++ )
    {
        if( type  == p_antenna_info->cbsr[index].type )
        {

            RRM_MEMCPY( cbsr , p_antenna_info->cbsr[index].value ,RRM_FOUR );

            cbsr_found = RRM_TRUE;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "CBSR type is matched coming from OAM");

            break;
        }
    }

    if( RRM_TRUE == cbsr_found )
    {
        RRM_MEMSET(cbsr ,RRM_ZERO , sizeof(cbsr));
        /* 2 x 2 mimo selection */
        if( ( N2_TX_ANTENNA_TM8_R9 == cbsr_type ) )
        {
             cbsr_mask = cbsr[RRM_ZERO];

            cbsr[RRM_ZERO] = cbsr_mask & RRM_N2_TX_UE_CAT_ANY_CBSR_TM8_MASK ; /* FC :   1111 1100, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Anetnna type is N2_TX_ANTENNA_TM8_R9 , masking all bits except 6 most significant bits");

            if( RRM_ZERO == cbsr[RRM_ZERO] )
            {
                cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM8_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N2_TX_ANTENNA_TM8_R9 ,After masking cbsr"
                "becoming zero, so providing default 0xFC for 2x2");
            }
        }
        else if( N4_TX_ANTENNA_TM8_R9 == cbsr_type )
        {
            if(((cbsr[RRM_ZERO] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) &&
                ((cbsr[RRM_ONE] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) &&
                ((cbsr[RRM_TWO] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) &&
                ((cbsr[RRM_THREE] & RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK) == RRM_ZERO) )
            {
                cbsr[RRM_ZERO] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
                cbsr[RRM_ONE] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
                cbsr[RRM_TWO] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
                cbsr[RRM_THREE] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Anetnna type is N4_TX_ANTENNA_TM8_R9 ,After masking cbsr"
                "becoming zero, so providing default 0xFF for 4x4 ");
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "CBSR type is not found in info coming from OAM intializing the"
        "cbsr by its default value");

        /* 4x4 MIMO selection */
        if( N4_TX_ANTENNA_TM8_R9  ==  cbsr_type )
        {
            for( index = RRM_ZERO; index < RRM_FOUR ; index++ )
            {
                cbsr[ index ] = RRM_N4_TX_UE_CAT_ANY_CBSR_TM8_MASK;
            }

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "Antenna type is N4_TX_ANTENNA_TM8_R9 ,so all 32 most significant bits are set");

        }
        /*2x2 MIMO selection */
        else if( N2_TX_ANTENNA_TM8_R9 == cbsr_type )
        {
            cbsr[RRM_ZERO] = RRM_N2_TX_UE_CAT_ANY_CBSR_TM8_MASK ; /*    1111 1100, 0 ,0 , 0 , 0, 0 , 0 ,0  */

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED ,
            "UE category is other than 5 and antenna type is N2_TX_ANTENNA_TM8_R9"
            "so 6 most significant bits of cbsr are set");
        }
        else /* this condition should not happen */
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
            " Anetnna type and code book subset restrcition value is not configured");
        }
    }

    /* Fill the CBSR bytes */
    p_antenna_info_dedicated_r10->bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

    /*Copying One Byte only, as CBSR data is within one byte and composer will fill rest 13 bytes with zero*/
    /*cov fix start 63899*/
    RRM_MEMCPY( p_antenna_info_dedicated_r10->codebook_subset_restriction_r10.value, cbsr ,RRM_FOUR);
    /*cov fix end 63899*/

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
	    "Transmission mode TM-8 is decided and Assigned for scell Cell Index[%d]",
	    scell_index);

    RRM_UT_TRACE_EXIT();
}
/* Scell_CBSR_fill: End */


/*ho_report_change start */
/******************************************************************************
 *   FUNCTION NAME: rrm_fill_reestab_ho_failure_report 
 *   INPUT      : UE context and the reestablishment request message
 *   OUTPUT     : none
 *   DESCRIPTION: This function fills Reestablish ho failure report to be sent to son 
 *                  in case of early handover
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_fill_reestab_ho_failure_report(
         /*SPR 17777 +-*/
        rrm_ue_context_t                  *p_ue_context
)
{
    rrmuem_rmif_ho_failure_report_t rrmuem_rmif_ho_failure_report = {RRM_ZERO};
    rrm_return_et                   ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL !=  p_ue_context);
    p_ue_context->is_ho_failed = RRM_TRUE;

    if(RRM_TRUE == rrm_cellm_get_ho_failure_report_attr_status(p_ue_context->cell_index))
    {
        /*check whether ho is initiated */
        if(RRM_TRUE == p_ue_context->ho_params.ho_ue_attempt_ind_sent)
        {
            /*Fill src and targer cgi's from handover report 
              which was filled in ho report */

            /* SPR-13375-fix start */
            RRM_MEMCPY(&(rrmuem_rmif_ho_failure_report.src_cgi),
                    &(p_ue_context->ue_handover_report.src_cgi),
                    sizeof(rrm_oam_eutran_global_cell_id_t));

            RRM_MEMCPY(&(rrmuem_rmif_ho_failure_report.trgt_cgi),
                    &(p_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id),
                    sizeof(rrm_oam_eutran_global_cell_id_t));
            /* SPR-13375-fix end */

            /* As Ue-context is still present and ho is initiated so rrm will consider 
               it as too early handover  */


            rrmuem_rmif_ho_failure_report.ho_cause = RRMUEM_RMIF_HO_TOO_EARLY;

            /* No need to fill the reestablishment cgi in ho report as it has reestabilshed
               on the source cell, need to fill reestablish cgi only when the reestablished
               cgi is other than the source or the target cgi's */

            /*Raise notification for early ho failure */
            rrm_raise_event_too_early_ho(p_ue_context);

            if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                        RRMUEM_RMIF_HO_FAILURE_REPORT, sizeof(rrmuem_rmif_ho_failure_report_t),
                        (void *)(&rrmuem_rmif_ho_failure_report)))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                        "HO_failure_report: Sent Handover failure report to mif [UE:%d]",
                        p_ue_context->ue_index);
                /* SPR-13375-fix start */
                RRM_MEMSET (&(p_ue_context->ue_handover_report), RRM_ZERO, sizeof(rrmuem_rmif_ho_report_t));
                /* SPR-13375-fix end */
                /* SPR 22184/SES-478 Fix Start */
                p_ue_context->ho_params.ho_ue_attempt_ind_sent = RRM_FALSE; 
                /* SPR 22184/SES-478 Fix End */
            }
            else
            {
            
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
                        "HO_failure_report: Failed to send Handover failure report to miffor [UE:%d]",p_ue_context->ue_index);
                        
                ret_val= RRM_FAILURE;
            }
        }
        else
        {
                 RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
                    " Not sending ho failure report for [UE:%d] as"
                    "ho ue attempt ind is not true",p_ue_context->ue_index);

                ret_val= RRM_FAILURE;
        }
    }
	else
    {
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
		"  cell ind %d Attribute status is false so not sending ho report ", p_ue_context->cell_index);
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*ho_report_change end */

/* SPR 14326 Fix Start */
rrm_bool_et
rrm_check_send_meas_gap_is_enabled
(
 U32 operating_freq,
 U32 measuring_freq,
 rrm_ue_context_t           *p_ue_context,
  rrm_meas_gap_band_type_et
      meas_gap_band_type,
rrm_meas_gap_freq_type_et
            meas_gap_freq_type,
 rrm_cdma_meas_gap_config_t *p_cdma_meas_gap_config
)
{
    U8   operating_band = RRM_ZERO;
    U8   measuring_band = RRM_ZERO;

                /* SPR_17797_FIX_START */
    U8   operating_band_idx = MAX_BAND_EUTRA; 
    U8   measuring_band_idx = MAX_BAND_EUTRA;
                /* SPR_17797_FIX_END */
    rrm_bool_et send_meas_gap_enabled = RRM_FALSE;
    rrm_ue_band_list_eutra_t       *p_band_list_eutra = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    if ( p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        operating_band  = rrm_ue_get_dl_freq_specific_band(operating_freq);

        if(CDMA_FREQ == meas_gap_freq_type)
        {
            if(PNULL != p_cdma_meas_gap_config)
            {
                /* SPR_17797_FIX_START */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        " For CDMA freq, consider the configured CDMA Band Class (%d) " , p_cdma_meas_gap_config->band_class);
                /* SPR_17797_FIX_END */
                measuring_band = p_cdma_meas_gap_config->band_class;
                rrm_get_pos_in_supported_band_list(&(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            eutra_radio_capability_info_def),
                        measuring_band,
                        meas_gap_freq_type,
                        &measuring_band_idx,
                        p_cdma_meas_gap_config->cdma_type
                        );
            }
        }
        else
        {
            rrm_get_freq_specific_bands(measuring_freq,meas_gap_freq_type,&measuring_band);
            rrm_get_pos_in_supported_band_list(&(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        eutra_radio_capability_info_def),
                    measuring_band,
                    meas_gap_freq_type,
                    &measuring_band_idx,
                /* SPR_17797_FIX_START */
                    RRM_INVALID_RETURN 
                /* SPR_17797_FIX_END */
                    );
        }


        rrm_get_pos_in_supported_band_list(&(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def),
                operating_band,
                EUTRA_FREQ,
                &operating_band_idx,
                /* SPR_17797_FIX_START */
                RRM_INVALID_RETURN 
                /* SPR_17797_FIX_END */
                );

        p_band_list_eutra = &(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.meas_parameters.band_list_eutra);

                /* SPR_17797_FIX_START */
        if((operating_band_idx < MAX_BAND_EUTRA) && ( measuring_band_idx < MAX_BAND_EUTRA))
                /* SPR_17797_FIX_END */
        {
            if(meas_gap_band_type == INTER_FREQ_BAND_LIST)
            {
                /* SPR_17797_FIX_START */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Check Inter FREQ band List to decide Meas gap is to be sent or not");
                /* SPR_17797_FIX_END */
                if( RRM_ONE == p_band_list_eutra->p_band_info_eutra[operating_band_idx].
                        inter_freq_band_list.
                        inter_freq_band_info[measuring_band_idx].inter_freq_need_for_gaps)
                {
                    send_meas_gap_enabled = RRM_TRUE;
                }
            }
            else
            {
                /* SPR_17797_FIX_START */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Check Inter RAT Band List to decide Meas gap is to be sent or not");
                if((p_band_list_eutra->p_band_info_eutra[operating_band_idx].bitmask &
                          RRM_UE_EUTRA_INTER_RAT_BAND_LIST_PRESENT) &&
                     (RRM_ZERO == p_band_list_eutra->p_band_info_eutra[operating_band_idx].
                        inter_rat_band_list.
                        inter_rat_band_info[measuring_band_idx].inter_rat_need_for_gaps))
                /* SPR_17797_FIX_END */
                {
                    send_meas_gap_enabled = RRM_FALSE;
                }
                /* SPR_17797_FIX_START */
                else
                {
                    send_meas_gap_enabled = RRM_TRUE;
                }
                /* SPR_17797_FIX_END */
            }
        }
        else if( UTRAN_TDD_FREQ == meas_gap_freq_type)
        {
                /* SPR_17797_FIX_START */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Cuurently allow meas gap for CDMA/UTRAN_TDD_FREQ  frequencies");
                /* SPR_17797_FIX_END */
            send_meas_gap_enabled = RRM_TRUE;
        }
    }
                /* SPR_17797_FIX_START */
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "Send Meas Gap is [%d] for operating_freq(%d),measuring_freq(%d),operating_band(%d),measuring_band(%d)",
            send_meas_gap_enabled,operating_freq,measuring_freq,operating_band,measuring_band);
                /* SPR_17797_FIX_END */
    RRM_UT_TRACE_EXIT();
    return send_meas_gap_enabled;
}

/* SPR_17797_FIX_START */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_index_of_inter_rat_band_list 
 *   INPUT      : p_inter_rat_parameters, p_count, meas_gap_freq_type
 *   OUTPUT     : updates the index which is mapped to freq being checked. 
 *   DESCRIPTION: this function maps the suppotred rat band to corresponding
 *                InterRAT-BandList.
 *
 *   RETURNS: RRM_SUCCESS/RRM_FAILURE 
 *******************************************************************************/
rrm_return_et
rrm_get_index_of_inter_rat_band_list(
  rrm_ue_inter_rat_Parameters_t *p_inter_rat_parameters,
  U8                            *p_count,
  rrm_meas_gap_freq_type_et     meas_gap_freq_type,
  U8                            cdma_type
 )
{
    U8     count1 = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    count1 = *p_count;
    switch(meas_gap_freq_type)
    {
        case CDMA_FREQ:
                {    
                    if (RRM_INTER_RAT_GERAN_PRESENT & p_inter_rat_parameters->bitmask)
                    {
                        count1 = (count1 + p_inter_rat_parameters->geran.count);
                    }
                    if (RRM_ONE == cdma_type)
                    {
                        if (RRM_INTER_RAT_CDMA2000_HRPD_PRESENT & p_inter_rat_parameters->bitmask)
                        {
                            count1 = (count1 + p_inter_rat_parameters->cdma2000_hrpd.supported_band_list_hrpd.count);
                        }
                    }
                }
        case GERAN_FREQ:
                {
                    if (RRM_INTER_RAT_UTRA_FDD_PRESENT & p_inter_rat_parameters->bitmask)
                    {
                        count1 = (count1 + p_inter_rat_parameters->utra_fdd.count);
                    }
                    if (RRM_INTER_RAT_UTRA_TDD_128_PRESENT & p_inter_rat_parameters->bitmask)
                    {
                        count1 = (count1 + p_inter_rat_parameters->utra_tdd128.count);
                    }
                    if (RRM_INTER_RAT_UTRA_TDD_384_PRESENT & p_inter_rat_parameters->bitmask)
                    {
                        count1 = (count1 + p_inter_rat_parameters->utra_tdd384.count);
                    }
                    if (RRM_INTER_RAT_UTRA_TDD_768_PRESENT & p_inter_rat_parameters->bitmask)
                    {
                        count1 = (count1 + p_inter_rat_parameters->utra_tdd768.count);
                    }
                }
          break;
        case UTRAN_TDD_FREQ:
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    " checking UTRA TDD ");
          break;
        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    " Invalid Freq type [%d]", meas_gap_freq_type);
            *p_count = MAX_BAND_EUTRA;
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }

    *p_count = count1;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* SPR_17797_FIX_END */

rrm_void_t
rrm_get_pos_in_supported_band_list
(
  rrm_ue_eutra_radio_capability_info_def_t *p_radio_capability_info,
  U8   operating_band,
  rrm_meas_gap_freq_type_et
            meas_gap_freq_type,
  U8   *p_operating_band_idx,
  U8   cdma_type
 )
{
    U8 count = RRM_ZERO;
    rrm_bool_et band_found = RRM_FALSE;
    rrm_ue_geran_t *p_geran_band_list = PNULL;
    rrm_ue_utra_fdd_t *p_utra_fdd_band_list = PNULL;
    rrm_ue_supported_band_list_eutra_t *p_eutra_band_list = PNULL;
    rrm_ue_supported_band_list_hrpd_t  *p_cdma_hrpd_band_list = PNULL;
    rrm_ue_supported_band_list_1xrtt_t *p_cdma_1xrtt_band_list= PNULL;
    RRM_UT_TRACE_ENTER();

    switch(meas_gap_freq_type)
    {
        case EUTRA_FREQ:
        {
            p_eutra_band_list = &(p_radio_capability_info->rf_parameters.supported_band_list_eutra);
            for(count = RRM_ZERO; count < p_eutra_band_list->count ; count++)
            {
                if( operating_band == p_eutra_band_list->supported_band_eutra[count].band_eutra)
                {
                    *p_operating_band_idx = count;
                    band_found = RRM_TRUE;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                            " Band (%d) is present at %d in EUTRA Supported band list",operating_band, *p_operating_band_idx);
                    break;
                }
            }
        }
        break;
        case GERAN_FREQ:
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " Check BAND support for GERAN freq");
            p_geran_band_list = &(p_radio_capability_info->inter_rat_parameters.geran);
            for(count = RRM_ZERO; count < p_geran_band_list->count ; count++)
            {
                if( operating_band == p_geran_band_list->supported_band_geran[count] )
                {
                    *p_operating_band_idx = count;
                /* SPR_17797_FIX_START */
                    if (RRM_SUCCESS != rrm_get_index_of_inter_rat_band_list(
                                           &(p_radio_capability_info->inter_rat_parameters),
                                            p_operating_band_idx, GERAN_FREQ, cdma_type))
                    {
                        band_found = RRM_FALSE;
                        *p_operating_band_idx = MAX_BAND_EUTRA;
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            " Band (%d) is present but rrm_get_index_of_inter_rat_band_list returned failure",operating_band);
                    }
                    else
                    {
                /* SPR_17797_FIX_END */
                    band_found = RRM_TRUE;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                            " Band (%d) is present at %d in GERAN Supported band list",operating_band, *p_operating_band_idx);
                /* SPR_17797_FIX_START */
                    }
                /* SPR_17797_FIX_END */
                    break;
                }
            }
        }
        break;
        case UTRAN_FDD_FREQ:
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " Check BAND support for UTRAN FDD freq ");
            p_utra_fdd_band_list = &(p_radio_capability_info->inter_rat_parameters.utra_fdd);
            for(count = RRM_ZERO; count < p_utra_fdd_band_list->count ; count++)
            {
                if( operating_band == p_utra_fdd_band_list->supported_band_utra_fdd[count] )
                {
                    *p_operating_band_idx = count;
                    band_found = RRM_TRUE;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                            " Band (%d) is present at %d in UTRA_FDD Supported band list",operating_band, *p_operating_band_idx);
                    break;
                }
            }
        }
        break;
        case CDMA_FREQ:
        {
            if( RRM_ONE == cdma_type)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        " Check BAND support for CDMA HRPD freq ");
                p_cdma_hrpd_band_list = &(p_radio_capability_info->inter_rat_parameters.cdma2000_hrpd.supported_band_list_hrpd);
                for(count = RRM_ZERO; count < p_cdma_hrpd_band_list->count ; count++)
                {
                    if( operating_band == p_cdma_hrpd_band_list->band_class_cdma2000[count] )
                    {
                        *p_operating_band_idx = count;
                    /* SPR_17797_FIX_START */
                        if (RRM_SUCCESS != rrm_get_index_of_inter_rat_band_list(
                                    &(p_radio_capability_info->inter_rat_parameters),
                                    p_operating_band_idx, CDMA_FREQ, cdma_type))
                        {
                            band_found = RRM_FALSE;
                            *p_operating_band_idx = MAX_BAND_EUTRA;
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    " Band (%d) is present but rrm_get_index_of_inter_rat_band_list returned failure for HRPD",operating_band);
                        }
                        else
                        {
                    /* SPR_17797_FIX_END */
                        band_found = RRM_TRUE;
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                                " Band (%d) is present at %d in CDMA HRPD Supported band list",operating_band, *p_operating_band_idx);
                    /* SPR_17797_FIX_START */
                        }
                    /* SPR_17797_FIX_END */
                        break;
                    }
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        " Check BAND support for CDMA 1XRTT freq ");
                p_cdma_1xrtt_band_list = &(p_radio_capability_info->inter_rat_parameters.cdma2000_1x_rtt.supported_band_list_1xrtt);
                for(count = RRM_ZERO; count < p_cdma_1xrtt_band_list->count ; count++)
                {
                    if( operating_band == p_cdma_1xrtt_band_list->band_class_cdma2000[count] )
                    {
                        *p_operating_band_idx = count;
                 /* SPR_17797_FIX_START */
                        if (RRM_SUCCESS != rrm_get_index_of_inter_rat_band_list(
                                    &(p_radio_capability_info->inter_rat_parameters),
                                    p_operating_band_idx,
                                    CDMA_FREQ, cdma_type))
                        {
                            band_found = RRM_FALSE;
                            *p_operating_band_idx = MAX_BAND_EUTRA;
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    " Band (%d) is present but rrm_get_index_of_inter_rat_band_list returned failure for 1xRTT",operating_band);
                        }
                        else
                        {
                 /* SPR_17797_FIX_END */
                        band_found = RRM_TRUE;
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                                " Band (%d) is present at %d in CDMA 1XRTT Supported band list",operating_band, *p_operating_band_idx);
                /* SPR_17797_FIX_START */
                        }
                /* SPR_17797_FIX_END */
                        break;
                    }
                }
            }
        }
        break;
        case UTRAN_TDD_FREQ:
        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " (%d) Check for BAND for UTRAN TDD or Invalid Freq type ", meas_gap_freq_type);
        }
    }
    if( RRM_FALSE ==  band_found)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
                " Band (%d) is Not present in RAT specific Supported band list",operating_band);
    }
    RRM_UT_TRACE_EXIT();
}

rrm_void_t
rrm_get_freq_specific_bands
(
 U32    measuring_freq,
    rrm_meas_gap_freq_type_et
            meas_gap_freq_type,
    U8     *p_measuring_band
)
{
    RRM_UT_TRACE_ENTER();

    switch(meas_gap_freq_type)
    {
        case EUTRA_FREQ:
            {
                *p_measuring_band  = rrm_ue_get_dl_freq_specific_band(measuring_freq);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                           " BAND [%d] is returned for EUTRA freq [%d]", *p_measuring_band, measuring_freq);
            }
            break;

        case GERAN_FREQ:
            {
                *p_measuring_band  = rrm_ue_get_geran_freq_band(measuring_freq);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                           " BAND [%d] is returned for GERAN freq [%d]", *p_measuring_band, measuring_freq);
            }
            break;

        case UTRAN_FDD_FREQ:
            {
                *p_measuring_band  = rrm_ue_get_utra_freq_band(measuring_freq);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                           " BAND [%d] is returned for UTRAN freq [%d]", *p_measuring_band, measuring_freq);
            }
            break;

        case UTRAN_TDD_FREQ:
        default:
            {
                *p_measuring_band  = RRM_INVALID_RETURN;

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                           " (%d) Check for BAND for UTRAN TDD or Invalid Freq type ", meas_gap_freq_type);
            }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 14326 Fix End */

/* SPR 16406 8SEP start */
/******************************************************************************
 *   FUNCTION NAME: rrm_remove_previous_cgi_from_ue
 *   INPUT      : p_ue_context, p_rrc_rrm_meas_config_req
 *   OUTPUT     : NONE
 *   DESCRIPTION: Remove any previously configured CGI reports from UE
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_remove_previous_cgi_from_ue(
        rrm_ue_context_t *p_ue_context,
        rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req
		)
{
    meas_report_info_node_t     *p_meas_report_node = RRM_PNULL;
    rrm_cell_context_t          *p_cell_ctxt        = RRM_PNULL;
    U32                         i                   = RRM_ZERO;
    U16                         report_index        = RRM_ZERO;
    rrm_bool_et                 inter_freq          = RRM_FALSE;
    rrm_bool_et                 report_id_found     = RRM_FALSE;
    rrm_bool_et                 meas_object_id_found = RRM_FALSE;
    U32				            meas_id	            = RRM_ZERO;
    rrm_return_et               ret_val             = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();
    p_meas_report_node = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));
    p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /* SPR 17225 start */
    p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
    //p_rrc_rrm_meas_config_req->cell_index = p_ue_context->cell_index;
    /* SPR 17225 end */
    /*Coverity 94805 Fix Start*/
    if (RRM_PNULL == p_cell_ctxt )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*Coverity 94805 Fix End*/
    p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count = RRM_ZERO;
    p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count = RRM_ZERO;
    while (p_meas_report_node)
    {
        meas_object_id_found = RRM_FALSE;
        report_id_found = RRM_FALSE;
        if(p_meas_report_node->reporting_event == MEAS_REP_EVENT_FOR_CGI)
        {
            if (p_meas_report_node->meas_status != RRM_MEAS_CONFIG_TO_DELETE)
            {
                p_meas_report_node->meas_status = RRM_MEAS_CONFIG_TO_DELETE;
                if(p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn != p_meas_report_node->carrier_earfcn)
                {
                    /* SPR 16406 24Sep Start */
                    if(p_ue_context->ho_params.a2_event_received == RRM_FALSE)
                    {
                        /* SPR 16406 24Sep End */
                        for (i = RRM_ZERO; i < p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count; i++)
                        {
                            if (p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.meas_object_id[i] == p_meas_report_node->meas_object_id)
                            {
                                meas_object_id_found = RRM_TRUE;
                                break;
                            }
                        }
                        if (RRM_FALSE == meas_object_id_found)
                        {
                            p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.meas_object_id[p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count]
                                = p_meas_report_node->meas_object_id;
                            p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count++;
                        }
                    }
                    /* SPR 18194 fix start */
                    /* Code deleted */
                    /* SPR 16406 24Sep Start */	
                    /* SPR 16406 24Sep Start */	
                }
                for(report_index = RRM_ZERO; report_index < p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count; report_index++)
                {
                    if(p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[report_index] == p_meas_report_node->report_config_id)
                    {
                        report_id_found = RRM_TRUE;
                        break;
                    }
                }
                if(RRM_FALSE == report_id_found)
                {
                    p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count]
                        = p_meas_report_node->report_config_id;
                    p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count++;
                }
                /* SPR 18194 fix stop */
                /* SPR 16406 24Sep End */
            }
        }
        else
        {
            if(p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn != p_meas_report_node->carrier_earfcn)
            {
                inter_freq = RRM_TRUE;
            }
        }
        p_meas_report_node = (meas_report_info_node_t*)ylNext(&p_meas_report_node->sNode);
    }
    for(meas_id = RRM_ZERO; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
    {
        meas_object_id_found = RRM_FALSE;
        report_id_found = RRM_FALSE;

        if((RRM_MEAS_CONFIG_REQ_SENT == p_ue_context->p_meas_config[meas_id].meas_config_status)
                ||(RRM_MEAS_CONFIG_RESP_SUCCESS == p_ue_context->p_meas_config[meas_id].meas_config_status) )
        {
            p_ue_context->p_meas_config[meas_id].obj_created_at_ue = RRM_FALSE;
            p_ue_context->p_meas_config[meas_id].meas_config_status = RRM_MEAS_CONFIG_TO_DELETE;
            if (p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn != p_ue_context->p_meas_config[meas_id].carr_freq)
            {
                for (i = RRM_ZERO; i < p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count; i++)
                {
                    if (p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.meas_object_id[i] == p_ue_context->p_meas_config[meas_id].meas_obj_id)
                    {
                        meas_object_id_found = RRM_TRUE;
                        break;
                    }
                }
                if (RRM_FALSE == meas_object_id_found)
                {
                    p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.meas_object_id[p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count]
                        = p_ue_context->p_meas_config[meas_id].meas_obj_id;
                    p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count++;
                }
            }
            /*SPR 18194 Fix start */
            /* Code removed */
            /*SPR 18194 Fix end */
            for (i = RRM_ZERO; i < p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count; i++)
            {
                if (p_ue_context->p_meas_config[meas_id].report_id ==
                        p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[i])
                {
                    report_id_found = RRM_TRUE;
                    break;
                }
            }
            /* Spr 18488 Changes Start */
		    if ((RRM_FALSE == report_id_found) && (p_ue_context->p_meas_config[meas_id].report_id != RRM_NULL)) 
            /* Spr 18488 Changes End */
            {
                p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count]
                    = p_ue_context->p_meas_config[meas_id].report_id;
                p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count++;
            } 
        }
    } 
    if (RRM_ZERO != p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count)
    {
        p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT; 
        ret_val = RRM_SUCCESS;
    }

    if (RRM_ZERO != p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count)
    {
        p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT; 
        ret_val = RRM_SUCCESS;
    }

    if ((RRM_ZERO == p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count) &&
            (RRM_ZERO == p_rrc_rrm_meas_config_req->meas_config.meas_object_to_remove_list.count))
    {
        RRM_UT_TRACE_EXIT(); 
        return RRM_FAILURE;
    }
    if (RRM_FALSE == inter_freq)
    {
        if(RRM_ZERO !=  p_ue_context->meas_gap_config.meas_gap_config_type)
        {
            p_rrc_rrm_meas_config_req->meas_config.bitmask  |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;
            /* SPR-18140 START */
            p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask = RRM_ZERO;
            /* SPR-18140 END */
            p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type = RRM_ZERO;
            ret_val = RRM_SUCCESS;
        }
    }
    RRM_UT_TRACE_EXIT(); 
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_clear_pending_anr_cgi
 *   INPUT      : p_ue_context
 *   OUTPUT     : NONE
 *   DESCRIPTION: Remove any pending ANR CGI to be requested from UE
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
rrm_return_et
rrm_clear_pending_anr_cgi(
        rrm_ue_context_t *p_ue_context)
{
    rrm_ue_procedure_record_t      *p_rrm_ue_procedure_record   = RRM_PNULL;
    rrm_ue_procedure_record_t      *p_next_node                 = RRM_PNULL;
    rrm_ue_meas_config_cgi_queue_node_t *p_cgi_node             = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    while (RRM_PNULL != p_ue_context->p_proc_queue_first_meas_node)
    {
        p_rrm_ue_procedure_record = p_ue_context->p_proc_queue_first_meas_node;
        p_next_node = (rrm_ue_procedure_record_t *)ylNext(&p_rrm_ue_procedure_record->s_node);
        if (RRC_RRM_MEAS_CONFIG_REQ == p_rrm_ue_procedure_record->proc_queue.api_id) 
        {
            p_cgi_node = (rrm_ue_meas_config_cgi_queue_node_t*)p_rrm_ue_procedure_record->proc_queue.p_proc_data;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Deleting queued procedure for CGI Req for ARFCN = %d, RAT = %d"
                    " as corresponding meas object is being removed", p_cgi_node->arfcn,
                    p_cgi_node->rat_type);

            ylDelete(&p_ue_context->procedure_queue, &p_rrm_ue_procedure_record->s_node);
            RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
            RRM_MEM_FREE(p_rrm_ue_procedure_record);
        }
        p_ue_context->p_proc_queue_first_meas_node = p_next_node;
    }
    RRM_UT_TRACE_EXIT(); 
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_remove_previous_pending_measurement
 *   INPUT      : p_ue_context
 *   OUTPUT     : NONE
 *   DESCRIPTION: Removes any pending measurement left over the UE
 *   RETURNS:
 *       RRM_SUCCESS on successfully sending the measurement removal request
 *       RRM_FAILURE on not able to send the measurement removal request
 *******************************************************************************/
rrm_return_et
rrm_remove_previous_pending_measurement(
        rrm_ue_context_t *p_ue_context)
{
    /*Coverity 93561 Fix Start*/
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req;

    RRM_UT_TRACE_ENTER();
    
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t *)rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    if (p_rrc_rrm_meas_config_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
            "Memory allocation to p_rrc_rrm_meas_config_req failed" );
            RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_ZERO,
            (sizeof(rrc_rrm_meas_config_req_t)));
    /*Coverity 93561 Fix End*/
    /*Coverity 93561 Fix Start*/
    if (RRM_SUCCESS == rrm_remove_previous_cgi_from_ue(p_ue_context, p_rrc_rrm_meas_config_req))
    {
        if (RRM_SUCCESS == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID, rrm_generate_txn_id(),p_ue_context->cell_index))
    /*Coverity 93561 Fix End*/
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Successfully sent measurement configuration for removal of residual measurement");
            RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure, RRM_UE_MEAS_CONFIG_REQ_ONGOING);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to send measurement configuration for residual measurement");
            RRM_UT_TRACE_EXIT(); 
            /*Coverity 93561 Fix Start*/
            if(RRM_PNULL != p_rrc_rrm_meas_config_req)
            {
                RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            }
            /*Coverity 93561 Fix End*/
            return RRM_FAILURE;
        }
    }
    else
    {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Nothing needs to be removed from the UE regarding the measurement");
    }
    
    /*Coverity 93561 Fix Start*/
    if(RRM_PNULL != p_rrc_rrm_meas_config_req)
    {
        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    }
    /*Coverity 93561 Fix End*/
    RRM_UT_TRACE_EXIT(); 
    return RRM_SUCCESS;
}
/* SPR 16406 8SEP end */

/* Spr 18401 Changes Start */
/************************************************************************************
 *   FUNCTION NAME: fill_geran_meas_object_to_add_mod_list_for_cgi
 *   INPUT      : p_cell_ctx,p_meas_geran_node,p_meas_object_to_add_mod,meas_obj_id,
 *                geran_arfcn_on_report_cgi
 *   OUTPUT     : p_meas_object_to_add_mod
 *   DESCRIPTION: Fills the geran configuration in the meas object for cgi reporting. 
 *   RETURNS: NONE
 ************************************************************************************/
rrm_void_t
fill_geran_meas_object_to_add_mod_list_for_cgi(
        rrm_cell_context_t          *p_cell_ctx,
        meas_geran_node_t           *p_meas_geran_node,
        meas_object_to_add_mod_t    *p_meas_object_to_add_mod,
        U8                          meas_obj_id,
        U16                         geran_arfcn_on_report_cgi
        )
{
    idle_mode_mobility_irat_geran_params_t   *p_cell_ctx_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params);

    /* Fill meas_object_to_add_mod[index] */
    p_meas_object_to_add_mod->meas_object_id = meas_obj_id;

    p_meas_object_to_add_mod->meas_object.bitmask |=
        MEAS_OBJECT_TO_ADD_GERAN_PRESENT;

    /* Fill meas_object_geran */

    /* Fil the carrier freq present in meas reuslt indication for RSC */
    p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
        starting_arfcn = geran_arfcn_on_report_cgi;

   /* Hardcoading the values for eqally spaced earfcn, as any one 
    * of the following earfcn is mendatory*/
   p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
      following_arfcns.presence_bitmask |= GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

   p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
       following_arfcns.equally_spaced_arfcns.arfcn_spacing = RRM_ONE;

   p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
       following_arfcns.equally_spaced_arfcns.num_of_following_arfcns = RRM_NULL;

   p_meas_object_to_add_mod->meas_object.meas_object_geran.
       offset_freq = p_meas_geran_node->geran_config.offset_frequency;

   p_meas_object_to_add_mod->meas_object.meas_object_geran.carrier_freqs.
       band_indicator = p_cell_ctx_params->irat_eutran_to_geran_list.
       irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].
       geran_car_freqs.band_ind;

   p_meas_object_to_add_mod->meas_object.meas_object_geran.ncc_Permitted
       = p_cell_ctx_params->irat_eutran_to_geran_list.
       irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].ncc_permitted;

   RRM_UT_TRACE_EXIT();
}
/* Spr 18401 Changes End */

/*SPR_17893_START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_process_ue_capability_enq_resp 
 *   INPUT      : p_api_buf,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Process the UE Capability Enquiry Response. 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
    rrm_return_et
rrm_ue_rrc_process_ue_capability_enq_resp(
        U8 *p_api_buf,
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et        ret_val = RRM_SUCCESS;
    S32                  length_read = RRM_NULL;
    rrc_rrm_ue_capability_enquiry_resp_t  *p_ue_cap_resp = RRM_PNULL;
    rrm_ue_capability_enq_res_t *p_rrm_ue_capability_enq_res = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_ue_cap_resp = (rrc_rrm_ue_capability_enquiry_resp_t *)rrm_mem_get(sizeof(rrc_rrm_ue_capability_enquiry_resp_t));
    if(RRM_PNULL == p_ue_cap_resp)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Mem allocation failed");

        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }   
    
    RRM_MEMSET(p_ue_cap_resp,RRM_ZERO,sizeof(rrc_rrm_ue_capability_enquiry_resp_t));
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_capability_enquiry_resp(
                p_ue_cap_resp,
                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                data_len,
                &length_read))
    {
	    p_rrm_ue_rrc_msg->ue_index = p_ue_cap_resp->ue_Index;
/*SPR 21653 changes start*/
	    p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
/*SPR 21653 changes end*/
        /* SPR 21251 Start */
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->UEM:RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP:[UE:%d] with response: %d",
                p_ue_cap_resp->ue_Index, p_ue_cap_resp->result);
        /* SPR 21251 End */
	    p_rrm_ue_capability_enq_res = (rrm_ue_capability_enq_res_t *)rrm_mem_get(sizeof(rrm_ue_capability_enq_res_t));
	    if (RRM_PNULL == p_rrm_ue_capability_enq_res)
	    {
		    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory for Ue Capability enq resp ");
		    ret_val = RRM_FAILURE;
	    }
	    else
	    {
		    if((p_ue_cap_resp->radio_capability_info.bitmask & UTRA_RADIO_CAPABILITY_PRESENT) &&
				    (RRC_SUCCESS ==  p_ue_cap_resp->result))
		    {
			    p_rrm_ue_capability_enq_res->is_utran_cap_present  = RRM_TRUE;
			    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d],Received UTRAN  UE CAPABILITY", 
                        p_rrm_ue_rrc_msg->ue_index);
		    }
		    else
		    {
			    p_rrm_ue_capability_enq_res->is_utran_cap_present  = RRM_FALSE;
			    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Not Received UTRAN UE CAPABILITY for [UE:%d]", 
                        p_rrm_ue_rrc_msg->ue_index);
		    }
		    p_rrm_ue_rrc_msg->p_msg_data = p_rrm_ue_capability_enq_res;
	    }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->UEM:RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_ue_cap_resp);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_process_ue_capability_enq_resp 
 *   INPUT      : p_ue_context 
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Populate and send the UE Capability Enquiry Request for UTRAN 
 *   RETURNS:
 *        RRM_TRUE:- On Success
 *        RRM_FALSE:- On Failure
 *****************************************************************************/
rrm_bool_et
rrm_populate_and_send_utran_cap_enq_req(rrm_ue_context_t *p_ue_context)
{
     rrm_bool_et retval  = RRM_FALSE;
     RRM_UT_TRACE_ENTER();

     rrc_rrm_ue_capability_enquiry_req_t  ue_cap_req = {RRM_ZERO};
     ue_cap_req.bitmask    |=  RAT_TYPE_INFO_PRESENT;
/*SPR 21653 changes start*/
     //ue_cap_req.cell_index  =  p_ue_context->cell_index;
/*SPR 21653 changes end*/
     ue_cap_req.ue_Index    =  p_ue_context->ue_index;

     ue_cap_req.rat_type_info.rat_type_count  = RRM_ONE;
     ue_cap_req.rat_type_info.rat_type[RRM_ZERO] = RRC_RAT_TYPE_UTRA;

     if(RRM_SUCCESS == rrm_il_send_rrc_rrm_ue_capability_enquiry_req(
                    &ue_cap_req,RRM_MODULE_ID,RRC_MODULE_ID,rrm_generate_txn_id(),
                    p_ue_context->cell_index))
     {
         retval = RRM_TRUE;
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, 
                "Utran Capability Enq Sent, for [UE:%d]",
                         p_ue_context->ue_index);
     } 
     else
     {
         retval = RRM_FALSE;
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "Utran Capability Enq Failed to Sent, for [UE:%d]",
                         p_ue_context->ue_index);
     }
     RRM_UT_TRACE_EXIT();
     return retval;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_check_if_utran_cap_enq_reqd  
 *   INPUT      : p_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Checks for the conditions if the Utran capability Enq is required 
 *   RETURNS:
 *       RRM_TRUE on Success
 *       RRM_FALSE on Failure
 *****************************************************************************/
rrm_bool_et
rrm_check_if_utran_cap_enq_reqd(rrm_ue_context_t *p_ue_context)
{
	rrm_bool_et retval  = RRM_FALSE;
	meas_report_info_node_t* p_meas_report_node = RRM_PNULL;
	RRM_UT_TRACE_ENTER();

	if((RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES != p_ue_context->ue_state) &&
			(!(p_ue_context->ue_capability_params.bitmask & RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT)))
	{
		if(MEAS_REP_EVENT_A2 == p_ue_context->meas_rep_event) 
		{ 
			p_meas_report_node = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));
			while (p_meas_report_node)
			{
				if ((RRM_MEAS_CONFIG_REQ_SENT == p_meas_report_node->meas_status) &&
						(MEAS_REP_EVENT_B2 ==  p_meas_report_node->reporting_event) &&
						(RRM_IRAT_PRIORITY_UTRAN == p_meas_report_node->rat_type))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
							"B2-UTRAN configuration to be sent for [UE:%d]",
							p_ue_context->ue_index);
					retval = RRM_TRUE;
					break;
				}
				p_meas_report_node = (meas_report_info_node_t*)ylNext(&p_meas_report_node->sNode);
			}
		}

		if(((RRC_RRM_ERB_SETUP_CNF_EVENT == p_ue_context->ue_event) || 
					(RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT ==  p_ue_context->ue_event)))
		{
			p_meas_report_node = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));
			while (p_meas_report_node)
			{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
							"Event Recevived is RRC_RRM_ERB_SETUP_CNF_EVENT or RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT ");

				if ((RRM_MEAS_CONFIG_REQ_SENT == p_meas_report_node->meas_status) &&
						(MEAS_REP_EVENT_B1 ==  p_meas_report_node->reporting_event) &&
						(RRM_IRAT_PRIORITY_UTRAN == p_meas_report_node->rat_type))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
							"B1-UTRAN configuration to be sent for [UE:%d]",
							p_ue_context->ue_index);
					retval = RRM_TRUE;
					break;
				}
				p_meas_report_node = (meas_report_info_node_t*)ylNext(&p_meas_report_node->sNode);
			}
		}
	}
	RRM_UT_TRACE_EXIT();
	return retval;
}
/*SPR_17893_END*/
/* SPR 21958 PUSCH RAT1 Support Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_check_is_ue_support_uplink_rat1
 *   INPUT      : p_rrm_ue_context
 *   OUTPUT     : none
 *   DESCRIPTION: This function checks if UE is Capable for Uplink RAT1 Resource 
                  Allocation
 *   RETURNS:
 *       RRM_TRUE/RRM_FALSE
 *****************************************************************************/
rrm_bool_et
rrm_check_is_ue_support_uplink_rat1(rrm_ue_context_t *p_rrm_ue_context)
{
    rrm_bool_et ret_val = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if(p_rrm_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.bitmask &
            RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)
    {
        if(p_rrm_ue_context->ue_capability_params.
                rrm_eutra_radio_capability_info.
                ue_eutra_capability_v920_ies.bitmask &
                RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) 

        {
            if(p_rrm_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.bitmask &
                    RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT)
            {
                if(p_rrm_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_V1020_PHYLAYERS_PARAMETERS_PRESENT)
                {

                    if(p_rrm_ue_context->ue_capability_params.
                            rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.
                            ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.
                            phylayer_parameter_v1020.bitmask &
                            RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT)
                    {
                        if(RRM_MULTI_CLUSTER_SUPPORTED == p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                                multi_cluster_pusch_withincc_r10)
                        {
                            ret_val  = RRM_TRUE; 
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                    " UE supports RAT1 allocation in uplink");
                        } 
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                                    " Invalid value for multi-cluster support[%d]\n",
                                    p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.multi_cluster_pusch_withincc_r10);
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                                " Bitmask for multicluster support in UE EUTRA capability is not set as UE does not support RAT1.");
                    }
                        } 
                        else
                        {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            " Bitmask for RRM_UE_EUTRA_CAPABILITY_V1020_PHYLAYERS_PARAMETERS_PRESENT is not set as UE does not support RAT1.");
                        }
                    }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        " Bitmask for RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT is not set as UE does not support RAT1.");
            }
                }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                    " Bitmask for RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT is not set as UE does not support RAT1");
            } 
        }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                " Bitmask for RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT is not set as UE does not support RAT1.");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 21958 PUSCH RAT1 Support End */



#ifdef ENDC_ENABLED
/* MENB_CHANGES_START */
/***********************************************************************************
 *   FUNCTION NAME: rrm_uem_fill_ue_eutra_endc_capability_v1510_ies 
 *   INPUT        : p_rrc_ue_eutra_capability_v1510_ies_t
 *   OUTPUT       : p_rrm_ue_eutra_capability_v1510_ies
 *   DESCRIPTION  : Populate the EN-DC ue capability params received UE Capability
 *                  Ind from RRC in rrm_ue_rrc_msg_t pointer.
 *   RETURNS      : none
 ***********************************************************************************/
rrm_void_t
rrm_uem_fill_ue_eutra_endc_capability_v1510_ies
(
    rrm_ue_eutra_capability_v1510_ies_t *p_rrm_ue_eutra_capability_v1510_ies,
    ue_eutra_capability_v1510_ies_t     *p_rrc_ue_eutra_capability_v1510_ies
)
{
    RRM_UT_TRACE_ENTER();

    if ( RRC_RRM_UE_EUTRA_CAPABILITY_ENDC_PARAMETERS_R15_PRESENT &
        p_rrc_ue_eutra_capability_v1510_ies->bitmask )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "EN-DC capability is received from RRC");
        p_rrm_ue_eutra_capability_v1510_ies->bitmask |=
            RRM_UE_EUTRA_CAPABILITY_ENDC_PARAMETERS_R15_PRESENT;

        if( RRC_RRM_IRAT_PARAMETERS_NR_R15_PRESENT &
                p_rrc_ue_eutra_capability_v1510_ies->endcParameters.bitmask )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "EN-DC IRAT parameters is received from RRC");
            p_rrm_ue_eutra_capability_v1510_ies->endcParameters.bitmask |=
                RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_NR_R15_PRESENT;
            if( RRC_RRM_EN_DC_R15_PRESENT &
                   p_rrc_ue_eutra_capability_v1510_ies->endcParameters.
                   iratParametersNrR15.bitmask )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "EN-DC R15 is received from RRC");
                p_rrm_ue_eutra_capability_v1510_ies->endcParameters.iratParametersNrR15.
                    bitmask |=
                    RRM_UE_EUTRA_CAPABILITY_EN_DC_R15_PRESENT;
                p_rrm_ue_eutra_capability_v1510_ies->endcParameters.iratParametersNrR15.
                    enDcR15Supported =
                    p_rrc_ue_eutra_capability_v1510_ies->endcParameters.iratParametersNrR15.
                    enDcR15Supported;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        "EN-DC R15 is not received from RRC");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                    "EN-DC IRAT parameters is not received from RRC");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "EN-DC capability is not received from RRC");
    }
}
/* MENB_CHANGES_END */

/* OPTION3X Changes Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_parse_ue_dc_bearer_change_cnf 
 *   INPUT      : p_api_buf,api_id,data_len,p_rrm_ue_rrc_msg
 *   OUTPUT     : none
 *   DESCRIPTION:
 *       Parse the UE DC Bearer Change CNF message from L3 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *****************************************************************************/
rrm_return_et
rrm_ue_rrc_parse_ue_dc_bearer_change_cnf(
        U8 *p_api_buf,
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )    
{
/* ENDC_MEAS_CHANGES_START */
    rrm_return_et               ret_val = RRM_SUCCESS;
    S32                         length_read = RRM_NULL;
    rrc_rrm_dc_bearer_change_cnf_t     rrc_ue_dc_bearer_change_cnf;
    U8								index = RRM_NULL;
    rrm_ue_proc_dc_bearer_change_cnf_data_t
        *p_ue_proc_dc_bearer_change_cnf_data = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /** Parse the UE DC Bearer Change CNF */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_dc_bearer_change_cnf(
                    		&rrc_ue_dc_bearer_change_cnf,
                    		p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                    		data_len,
                    		&length_read))
    {
        p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));

        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, rrc_ue_dc_bearer_change_cnf.ue_index);
        
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,\
                "RRC->UEM:RRC_RRM_DC_BEARER_CHANGE_CNF:[UE:%d] with response: %d",
                rrc_ue_dc_bearer_change_cnf.ue_index, rrc_ue_dc_bearer_change_cnf.response);

        p_ue_proc_dc_bearer_change_cnf_data = (rrm_ue_proc_dc_bearer_change_cnf_data_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_dc_bearer_change_cnf_data_t));

        if(RRM_PNULL == p_ue_proc_dc_bearer_change_cnf_data)
        {
             RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                       "rrm_ue_rrc_parse_ue_dc_bearer_change_cnf: Mem allocation failed");
             return RRM_FAILURE;
        }

        RRM_MEMSET(p_ue_proc_dc_bearer_change_cnf_data,RRM_ZERO,\
                   sizeof(rrm_ue_proc_dc_bearer_change_cnf_data_t));

        p_rrm_ue_rrc_msg->ue_index = rrc_ue_dc_bearer_change_cnf.ue_index;
        p_ue_proc_dc_bearer_change_cnf_data->bitmask = 0x00;
//TB_FIX
        p_ue_proc_dc_bearer_change_cnf_data->response = 
                         rrc_ue_dc_bearer_change_cnf.response;

        if(rrc_ue_dc_bearer_change_cnf.bitmask &
                 RRC_RRM_DC_BEARER_CHANGE_CNF_ERAB_CNF_LIST_PRESENT)
        {
            p_ue_proc_dc_bearer_change_cnf_data->bitmask |= 
                    RRM_UEM_DC_BEARER_CHANGE_CNF_ERAB_CNF_LIST_PRESENT;

        p_ue_proc_dc_bearer_change_cnf_data->erab_cnf_list.erab_count = 
                rrc_ue_dc_bearer_change_cnf.erab_cnf_list.erab_count;
        for(index=RRM_NULL; 
            index<p_ue_proc_dc_bearer_change_cnf_data->erab_cnf_list.erab_count; 
            index++)
        {
        	p_ue_proc_dc_bearer_change_cnf_data->erab_cnf_list.erab_cnf_info[index].
                    erab_id = 
                    rrc_ue_dc_bearer_change_cnf.erab_cnf_list.erab_cnf_info[index].
                    erab_id;
        } 
        }
        if(rrc_ue_dc_bearer_change_cnf.bitmask &
                 RRC_RRM_DC_BEARER_CHANGE_CNF_ERAB_ERROR_LIST_PRESENT)
        {
            p_ue_proc_dc_bearer_change_cnf_data->bitmask |= 
                RRM_UEM_DC_BEARER_CHANGE_CNF_ERAB_ERROR_LIST_PRESENT;

        p_ue_proc_dc_bearer_change_cnf_data->erab_error_list.erab_count = 
                rrc_ue_dc_bearer_change_cnf.erab_error_list.erab_count;
        for(index=RRM_NULL; 
            index<p_ue_proc_dc_bearer_change_cnf_data->erab_error_list.erab_count; 
            index++)
        {
        	p_ue_proc_dc_bearer_change_cnf_data->erab_error_list.
                    erab_error_info[index].erab_id = 
                    rrc_ue_dc_bearer_change_cnf.erab_error_list.erab_error_info[index].
                    erab_id;
            p_ue_proc_dc_bearer_change_cnf_data->erab_error_list.
                    erab_error_info[index].error_code = 
                    rrc_ue_dc_bearer_change_cnf.erab_error_list.erab_error_info[index].
                    error_code;
       	}
        }
/* ENDC_MEAS_CHANGES_END */
        p_rrm_ue_rrc_msg->p_msg_data = p_ue_proc_dc_bearer_change_cnf_data;   
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRC->RRC_RRM_DC_BEARER_CHANGE_CNF->UEM failed to process");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_fill_dc_bearer_change_req 
 *   INPUT      : p_rrm_ue_context, p_erab_item
 *   OUTPUT     : p_dc_bearer_change_req
 *   DESCRIPTION:
 *                 Fills the DC Bearer change Request  
 *   RETURNS    :
 *                 RRM_SUCCESS  on Success
 *                 RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_void_t
rrm_ue_fill_dc_bearer_change_req
(
 rrm_ue_context_t               *p_rrm_ue_context, 
 rrc_rrm_dc_bearer_change_req_t *p_dc_bearer_change_req,
    endc_eligible_erab_list_t      *p_erb_change_list,
    U8                              erb_change_list_count,
    rrm_meas_result_nr_neighbour_list_r15_t  *p_meas_result_nr,
    rrm_x2_gb_gnb_id_t             *p_selected_gnb_id
)
{
    rrm_drb_config_t        *p_rrm_drb_config = RRM_NULL;
    radio_bearer_config_t   *p_mcg_rb_config = RRM_PNULL;
    rrm_ue_erab_setup_item_t *p_erab_item = RRM_NULL;
    rrm_endc_nr_meas_data_t  *p_b1_meas_data    = RRM_PNULL;
    rrm_endc_nr_sgnb_meas_data_t *p_b1_sgnb_meas_data = RRM_PNULL;
    U8                        sgnb_count        = RRM_ZERO;
    U8                        meas_obj_count     = RRM_ZERO;
    U8                        meas_id_count      = RRM_ZERO;
    U8                        meas_count        = RRM_ZERO;
    U8                        rep_count        = RRM_ZERO;
    meas_gap_setup_config_info_t *p_meas_gap_config = RRM_PNULL;
//    rrm_endc_nr_cell_meas_info_t *p_b1_sgnb_cell_meas_data = RRM_PNULL;
    meas_object_to_remove_list_t      *p_meas_obj_remove_list = RRM_PNULL;
    report_config_to_remove_list_t    *p_report_cfg_remove_list = RRM_PNULL;
    meas_id_to_remove_list_t          *p_meas_id_remove_list = RRM_PNULL;
    U8                                 erb_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT( RRM_NULL != p_rrm_ue_context); 
    RRM_ASSERT( RRM_NULL != p_dc_bearer_change_req); 

    do
    {
        RRM_MEMSET(p_dc_bearer_change_req, RRM_ZERO,
                (sizeof(rrc_rrm_dc_bearer_change_req_t)));

        p_dc_bearer_change_req->bitmask = RRM_ZERO;
        p_dc_bearer_change_req->ue_index = p_rrm_ue_context->ue_index;

        /* Fill Erab_info */
            p_dc_bearer_change_req->bitmask |=
                RRM_DC_BEARER_CHANGE_REQ_DRB_TO_MODIFY_LIST_PRESENT;

            p_mcg_rb_config = 
            &(p_dc_bearer_change_req->sgnb_add_param.cg_config_info.
                    mcg_rb_config);

        for ( erb_count = RRM_ZERO;
                erb_count < erb_change_list_count; erb_count++)
            {
            p_erab_item = (rrm_ue_erab_setup_item_t *)
                &(p_rrm_ue_context->drb_configured.\
                        erab_item[p_erb_change_list[erb_count].drb_index]);

            p_rrm_drb_config = &(p_dc_bearer_change_req->drb_to_modify_list.drb_config[erb_count]);

                /* Fill e_rab_id */
                {
                    p_rrm_drb_config->erab_id = p_erab_item->erab_id;

                    p_rrm_drb_config->bitmask |=
                        RRM_DRB_CONFIG_BEARED_ID_PRESENT;
                }
                /* Fill new_drb_id */
                p_rrm_drb_config->drb_id = p_erab_item->new_drb_id;

                /* Fill new_lc_id*/
                {
                    p_rrm_drb_config->logical_channel_identity = p_erab_item->new_lc_id;

                    p_rrm_drb_config->bitmask |=
                        RRM_DRB_CONFIG_LOGICAL_CHANNEL_IDENTITY_PRESENT;
                }
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "DRB type is [%d]:[%d]",erb_count,p_erb_change_list[erb_count].drb_type);

            switch (p_erb_change_list[erb_count].drb_type)
                    {
                        case DRB_TYPE_SN_TERMINATED_SPLIT:
                        {
                            p_rrm_drb_config->dc_bearer_type = SN_TERMINATED_SPLIT_BEARER;

                            p_rrm_drb_config->bitmask |= RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT;

                            /* Filling DRB ID here in DRB_To_AddMod_List in MCG_RB_Config
                             * of Cg-Config-Info.
                             * Bitmask in th Cg-Config-Info and MCG_RB_Config will be updated
                             * in function rrm_fill_nr_cg_config_info based on the
                             * count of DRB_To_AddMod_List.
                             */
                            /* Fill DRB_ID in DRB_to_AddMod_List*/
                            p_mcg_rb_config->drb_to_add_mod_list.
                                drb_to_add_mod[p_mcg_rb_config->drb_to_add_mod_list.count].
                                drb_id = 
                                p_erab_item->new_drb_id;

                            /* Increment the DRB to AddModList Count */
                            p_mcg_rb_config->drb_to_add_mod_list.count++;

                            /* Fill CN association in DRB_to_AddMod_List*/
                            p_mcg_rb_config->drb_to_add_mod_list.
                                drb_to_add_mod[p_mcg_rb_config->drb_to_add_mod_list.count].
                                bitmask |=
                                DRB_TO_ADD_MOD_CN_ASSOCIATION_PRESENT;

                            /* Fill ERAB_ID in CN association */
                            p_mcg_rb_config->drb_to_add_mod_list.
                                drb_to_add_mod[p_mcg_rb_config->drb_to_add_mod_list.count].
                                cn_association.erab_id = p_erab_item->erab_id;

                            p_mcg_rb_config->drb_to_add_mod_list.
                                drb_to_add_mod[p_mcg_rb_config->drb_to_add_mod_list.count].
                                cn_association.bitmask |=
                                CN_ASSOCIATION_ERAB_ID_PRESENT;

#if 0
                            /* Fill PDCP config in DRB_to_AddMod_List*/
                            p_mcg_rb_config->drb_to_add_mod_list.
                                drb_to_add_mod[p_mcg_rb_config->drb_to_add_mod_list.count].
                                bitmask |=
                                DRB_TO_ADD_MOD_PDCP_CONFIG_PRESENT;

                            p_epc_params = rrm_cellm_get_erb_service_profile(p_rrm_ue_context->cell_index);
                            for ( qos_count = RRM_ZERO;
                                qos_count < p_epc_params->num_valid_qos_profiles; qos_count++ )
                            {
                                fill_erb_setup_modify_resp_pdcp_config
                                    (&(p_mcg_rb_config->drb_to_add_mod_list.
                                       drb_to_add_mod[p_mcg_rb_config->drb_to_add_mod_list.count].
                                       pdcp_config),
                                     &(p_epc_params->qos_config_params[qos_count].erb_service_profile.pdcp_config),
                                     p_epc_params->qos_config_params[qos_count],
                                     p_rrm_ue_context,
                                     p_erab_item->data_transfer_mode,
                                     p_erab_item->erab_id);
                            }
#endif
                            break;
                        }
                        default:
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "DRB type is [%d]",p_erab_item->drb_type);
                    }
                p_dc_bearer_change_req->drb_to_modify_list.drb_count++;
        }

        /* Fill NR config info */
        /*check if sgnb_add_param_reqd then update cg_config_info*/
        //if(p_rrm_ue_context->is_sgnb_param_reqd)
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[DC_BEARER_CHANGE_REQ] Fill cg config info");
            p_dc_bearer_change_req->bitmask |=
                RRM_DC_BEARER_CHANGE_REQ_SGNB_ADD_PARAMS_PRESENT;

            rrm_fill_nr_cg_config_info(p_rrm_ue_context,
                &(p_dc_bearer_change_req->sgnb_add_param),p_selected_gnb_id,p_meas_result_nr);

        /* fill endc meas config */
        if(RRM_PNULL != p_meas_result_nr)
        {
            p_dc_bearer_change_req->bitmask |= RRM_DC_BEARER_REQ_MEAS_CONFIG_PRESENT;       
            p_meas_obj_remove_list = 
                &(p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                        meas_object_to_remove_list);
            p_report_cfg_remove_list =
                &(p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                        report_config_to_remove_list);
            p_meas_id_remove_list = 
                &(p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                        meas_id_to_remove_list);

            p_b1_meas_data = &(p_rrm_ue_context->rrm_endc_nr_data.\
                    rrm_endc_nr_meas_data[RRM_ZERO]);

            for(sgnb_count = RRM_ZERO ;
                    sgnb_count < p_b1_meas_data->sgnb_count ;sgnb_count++)
            {
                p_b1_sgnb_meas_data = 
                    &(p_b1_meas_data->rrm_endc_nr_sgnb_meas_data[sgnb_count]);
                for(meas_count = RRM_ZERO ; 
                        meas_count < p_b1_sgnb_meas_data->meas_count; meas_count++)
                {
                   p_meas_id_remove_list->meas_id[meas_id_count] =
                        p_b1_sgnb_meas_data->rrm_endc_nr_sgnb_meas_info[meas_count].\
                                meas_id;
                   meas_id_count++;
                }
                for(meas_count = RRM_ZERO ; 
                        meas_count < p_b1_sgnb_meas_data->cell_count; meas_count++)
                {
                    p_meas_obj_remove_list->meas_object_id[meas_obj_count] = 
                        p_b1_sgnb_meas_data->rrm_endc_nr_cell_meas_info[meas_count].\
                                meas_object_id;
                    meas_obj_count++;
                }
            }
            for(rep_count = RRM_ZERO ; 
                        rep_count < p_b1_meas_data->report_config_id_count; rep_count++)
            {
                p_report_cfg_remove_list->report_config_id[rep_count] = 
                       p_b1_meas_data->report_config_id_list[rep_count];
            }

            p_meas_obj_remove_list->count = meas_obj_count;
            p_report_cfg_remove_list->count = p_b1_meas_data->report_config_id_count;
            p_meas_id_remove_list->count = meas_id_count;

            /* fill meas gap */
            p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                meas_gap_config.bitmask = 0x00;
            p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                meas_gap_config.bitmask |= MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT;
            p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                meas_gap_config.meas_gap_config_type = RRM_ONE;
            p_meas_gap_config = &( p_dc_bearer_change_req->rrc_rrm_endc_meas_config.\
                    meas_gap_config.setup_config_info);

            if(p_rrm_ue_context->rrm_endc_nr_data.\
                    lte_meas_gap_type == RRM_MEAS_GAP_TYPE_0)
            {
                p_meas_gap_config->bitmask |= MEAS_GAP_CONFIG_GP0_PRESENT;
                p_meas_gap_config->gp0 = 
                    p_rrm_ue_context->rrm_endc_nr_data.lte_meas_gap_offset;
            }
            else if (p_rrm_ue_context->rrm_endc_nr_data.\
                    lte_meas_gap_type == RRM_MEAS_GAP_TYPE_1)
            {
                p_meas_gap_config->bitmask |= MEAS_GAP_CONFIG_GP1_PRESENT;
                p_meas_gap_config->gp1 =
                    p_rrm_ue_context->rrm_endc_nr_data.lte_meas_gap_offset;
            }
        }
    } while(0);
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_build_and_send_dc_bearer_change_req
 *   INPUT      : p_rrm_ue_cntxt,p_erab_item
 *   OUTPUT     : response
 *   DESCRIPTION:
 *                 Fills and sends DC Bearer Change Request
 *   RETURNS    :
 *                 RRM_SUCCESS  on Success
 *                 RRM_FAILURE  on Failure
 ******************************************************************************/
rrm_return_et
rrm_build_and_send_dc_bearer_change_req
(
        rrm_ue_context_t            *p_ue_context,
    endc_eligible_erab_list_t    *p_erb_change_list,
    U8                           erb_change_list_count,
    rrm_meas_result_nr_neighbour_list_r15_t  *p_meas_result_nr,
    rrm_x2_gb_gnb_id_t            *p_selected_gnb_id
)
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U16                             transaction_id = RRM_ONE;

    rrc_rrm_dc_bearer_change_req_t 
           *p_rrc_rrm_dc_bearer_change_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_ue_context);

    p_rrc_rrm_dc_bearer_change_req  = (rrc_rrm_dc_bearer_change_req_t *)\
                                  rrm_mem_get(sizeof(rrc_rrm_dc_bearer_change_req_t));

    if (RRM_PNULL == p_rrc_rrm_dc_bearer_change_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Failed to Allocate Memory "
                "for RRC_RRM_DC_BEARER_CHANGE_REQ");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_rrc_rrm_dc_bearer_change_req, RRM_ZERO,
            sizeof(rrc_rrm_dc_bearer_change_req_t));

    rrm_ue_fill_dc_bearer_change_req(p_ue_context,
            p_rrc_rrm_dc_bearer_change_req, p_erb_change_list,erb_change_list_count,\
            p_meas_result_nr,p_selected_gnb_id);

        ret_val = rrm_il_send_rrc_rrm_dc_bearer_change_req(p_rrc_rrm_dc_bearer_change_req,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                transaction_id,
                p_ue_context->cell_index);
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "[UE:%d], Failed to send "
                    "RRC_RRM_DC_BEARER_CHANGE_REQ",p_ue_context->ue_index);
        }
        else
        {
            RRM_SET_UE_PROCEDURE_STATE(&p_ue_context->current_procedure,
                    RRM_UE_DC_BEARER_CHANGE_PROCEDURE_ONGOING);
        p_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_INITIATED;

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "[UE:%d], Successfully sent "
                    "RRC_RRM_DC_BEARER_CHANGE_REQ",p_ue_context->ue_index);
    }

    RRM_MEM_FREE(p_rrc_rrm_dc_bearer_change_req);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* OPTION3X Changes End */
#endif
