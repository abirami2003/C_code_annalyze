/* vim:ts=4:et:ai:ci:sw=4
*/
/******************************************************************************
 *
 * ARICENT -
 *
 * Copyright (C) 2012 Aricent Inc . All Rights Reserved.
 *
 *******************************************************************************
 *
 * $$Id: rrm_ue_fsm.c $
 *
 *******************************************************************************
 *
 * File Description:This file contains the functions for handling incoming 
 *                  messages of this module
 *        
 *
 *******************************************************************************
 *Revision Details
 *----------------------
 *   DATE            AUTHOR      REFERENCE       REASON
 *   4 Apr,2012      gur26991    Initial
 *   2 MAY,2012      gur30487                    Fix regarding the bearer
 *                                               admission control according
 *                                               to the max no of bearer 
 *                                               configured by OAM
 *   13 MAY,2012     gur30487                    CLPC regarding changes
 *   7 June,2012     gur29220                    CS-Fallback & Redirection
 *   4 July,2012     gur30784                    Added function to print drb_
 *                                               configured and fix for mapping
 *                                               QOS params
 *   5 July,2012     gur30784                    Added configured RABs check
 *   11 Oct,2012     gur30784                    TNL calculation
 *   29 Jan, 2013    gur27278                    Added code for SPS feature
 *   21 Feb, 2013    gur11056                    Added fix for SPR 5476
 *   16 Jul, 2013    gur11056                    Added code changes for SPR 490
 *   16 Apr, 2014    gur32417                    Carrier Aggregation Stage 3 code
 *                                               added
 *   25 Apr 2014    gur31824      SPR 10729      RRM is not releasing the UE
 *                                               when RRC sends
 *                                               RRC_RRM_LOCAL_ERROR_IND to
 *                                               RRM for UE with single rabs
 *   1  May, 2014    gur26515                    Added code changes for SPR 10751
 *   2 May 2014     gur25767     SPR 10538       Queueing implemented for Meas Config
 *                               /CSR 69389      CGI req.
 *   27 May 2014    gur29831  prb per ue fix     prb per ue fixed    
 *   30 May 2014    gur29831  SPR 11368          Added fix for SPR 11368     
 *   30 May 2014    gur34951      SPR 8004       ECID Enhancement for inter 
 *                                               Frequency Cells
 *   13 Jun 2014     gur27356    11489           Support additional causes in RWR.
 *   18 Jun 2014     gur26515    11966           Crash fixed when UE admission CNF is coming as
 *                                               Failure.
 *   17 June,2014    gur35095    SPR-11943       rrmh_fsm calls is replaced with
 *                                               rrm_uem_process_fsm and initilize
 *                                               proc variable with PNULL.
 *   19 Jun 2014    gur27356     SPR 10489       Support additional causes in RWR.
 *   20 Jun 2014    gur13083     SPR 12008       RRM should not allow Scell
 *                                               adddition only when band also
 *                                               match along with bandwidth
 *   24 Jun 2014    gur29831     SPR 12095       Fix Provided for spr 12095 
 *   28 Jun 2014    gur21481     SPR 12269       meas ind handle for ANR
 *    2 Jul 2014    gur35095     SPR 11907       Broadcast cell_del_req to all cells
 *                                               after resp from all cells, Send
 *                                               cell_del_req to rrc
 *   1  Jul, 2014    gur27356    12325           RRM crash during basic UE-attach.
 *   30 Jun, 2014    gur27356    12178           supported_rats bitmask in rrm_ue_context not
 *                                               set after handover to target cell is done
 *   02 Jul 2014     gur27356    12241           p_proc_data not set to NULL in some scenarios.
 *   30 Jun, 2014    gur27356    12178           supported_rats bitmask in rrm_ue_context not
 *                                               set after handover to target cell is done
 *   02 Jul, 2014    gur26515    10450           Implemented DRX Staggering.
 *   14 Jul, 2014    gur30784    12545           Updated KPI stat info
*   14 Jul, 2014    gur27356    12570           RRM should not send “ho_report” to SON for UTRA DAHO cell.
*   14 Jul, 2014    gur27356    12572           RRM sending HO_REPORT to SON for UTRA NCL cell with wrong Cell Identity.
*                                               
*   02 Jul 2014     gur27356    12241           p_proc_data not set to NULL in some scenarios.
*   30 Jun, 2014    gur27356    12178           supported_rats bitmask in rrm_ue_context not
*                                               set after handover to target cell is done
*   02 Jul, 2014    gur26515    10450           Implemented DRX Staggering.
*   14 Jul, 2014    gur30784    12545           Updated KPI stat info
*   21 Jul, 2014    gur29831    12699           RRM Crash Fix against spr 12699
*   22 July,2014    gur27356    SPR-12644       Some issue in Too Late Handover (MRO).
*   21 Jul  2014   gur13083     SPR 12705       RRM not Updating UTRAN HO
*                                               FAILURE KPI if Handover Failed by Network
*   30 July,2014    gur35095    SPR 12745       RRM not send any resp to l3 if UE reconfig 
*                                               resp is failure.
*   05 Aug,2014     gur21481    SPR 12686       erb_setup fail list is not updated for KPI
*   08 Aug,2014     gur27356    SPR 12923       Handover failure report not sends when too late handover is triggered.
*   14 Aug,2014     gur29831                    Handover failure report not sends when too early handover failure.
*   27 Aug,2014     gur21481    SPR 13355       Scell is not getting deactivate when A2 report is
*                                               triggered in case of "MASA" enabled .
*   27 Aug,2014     gur27356    SPR 13375       RRM sending HO Failure report with value 0.
*   05 Sep 2014     gur31264    SPR 13205       Changes incorporated for addition of SPID configuration 
*                                               of CDMA.
*   06 Nov,2014     gur33103    SPR 13332       Fix regarding Issue in RRM enqueue if Erb delete message
between ongoing Meas config procedure
******************************************************************************/

/*****************************************************************************
 * Project includes 
 ******************************************************************************/
#include "rrm_stats.h"
#include "rrm_defines.h"
#include "rrm_utils.h"
#include "rrm_ue_fsm.h"
#include "rrm_ue_context.h"
#include "rrm_ue_mgr.h"
#include "rrm_cell_mgr.h"
#include "l3_api_composer.h"
#include "s1ap_rrm_composer.h"
#include "rrm_rrc_ue_intf.h"
#include "rrm_uem_rrmim_intf.h"
/* warnings removal: file "rrm_mif_fsm.h" is included, 10/15/2012 */
#include "rrm_mif_fsm.h"
/* Event handler header file */
#include "rrm_events.h"
#include "rrm_ue_ho_utils.h"

#ifdef LTE_EMBMS_SUPPORTED
#include "rrm_ue_embms.h"
#endif
/* Variable storing the CellM name for logging */
S8 *p_g_rrm_uem_facility_name = (S8 *)"RRM_UEM";
extern rrm_uem_global_proc_t g_uem_gbl_proc;
/* Global variable storing the status (Enabled/Disabled) of UEM logging */
rrm_bool_et g_uem_log_on_off = RRM_TRUE;

/*SPR 17646 +-*/


/*************************************************************************
 ** external functions ********
 **********************************************************************/
/*SPR 17777 +-*/

extern rrm_void_t
update_meas_config_status(
		rrm_ue_context_t              *p_rrm_ue_ctx,
		rrm_bool_et                   *p_is_ecid_meas_resp,
		U8                            *p_meas_id,
		rrm_meas_ecid_resp_et         *p_ecid_meas_resp_action
		);

rrm_return_et
rrm_ue_handle_meas_results_ind_for_ho (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		);
rrm_void_t rrm_detect_ho_oscillation
(
 rrm_ue_context_t                 *p_ue_context
 );

U16 rrm_ue_get_next_strongest_phy_cell_id_for_ho (
		rrm_ue_context_t* p_ue_ctxt
		);
rrm_return_et
rrm_ue_handle_meas_results_ind_for_ue_positioing(
		rrm_ue_measurment_results_ind_t    *p_ue_meas_results,
		rrm_ue_context_t                   *p_ue_context,
		U8                                  ecid_meas_req_index
		);

/* SPR 16042 Start */
rrm_bool_et
rrm_uem_check_cgi_report_pending_in_proc_queue(rrm_ue_context_t *p_ue_context);
/* SPR 16042 End */

/* Inter RAT changes start */
extern rrm_timer_t rrm_ue_start_csfb_blind_timer(
		rrm_ue_context_t *p_ue_context);
/* Inter RAT changes end */
extern RRM_TIME_T rrm_get_system_time(void);
extern signed long rrm_time_diff ( const RRM_TIME_T* ptm_one,   const RRM_TIME_T* ptm_two);

/* SPR 16099 fix start */
rrm_bool_et
rrm_ue_check_if_dequeued_api_to_be_discarded
(
 rrm_ue_procedure_record_t  *p_rrm_ue_procedure_record,
 rrm_ue_global_context_t    *p_rrm_ue_global_context,
 rrm_cell_context_t         *p_rrm_cell_context
 );

/*******************************************************************************
 *   FUNCTION NAME:  rrm_ue_check_if_dequeued_api_to_be_discarded
 *   DESCRIPTION:
 *                   1)Check for the meas_config_req and verify that PCI
 *                   EARFCN for a procedure data already configured or
 *                   Not.
 *                   2)Check if CGI procedure already ongoing for a PCI
 *                     and EARFCN then also discard the dequeued API
 *   RETURNS: TRUE/FALSE
 ******************************************************************************/
rrm_bool_et
	rrm_ue_check_if_dequeued_api_to_be_discarded
(
 rrm_ue_procedure_record_t  *p_rrm_ue_procedure_record,
 rrm_ue_global_context_t    *p_rrm_ue_global_context,
 rrm_cell_context_t         *p_rrm_cell_context
 )
{
	rrm_bool_et                         discard_queued_msg = RRM_FALSE;
	lte_ncl_t                           *p_rrm_ncl_params = RRM_PNULL;
	rrm_ue_meas_config_cgi_queue_node_t *p_report_cgi_req_info = RRM_PNULL;
	/* SPR 16406 8SEP start */
	/* SPR 16406 18sep Start  */
	phy_cell_id_info_t                  phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
	/* SPR 16406 18sep End */
	/* SPR 16406 8SEP end */
	U8                                  ncl_count_index = RRM_ZERO;
	/* SPR 16219 fix start */
	rrm_ue_meas_config_t    *p_meas_config_info         = RRM_PNULL;
	/* SPR 16219 fix end */


	RRM_UT_TRACE_ENTER();

	/* Get the NCL params for intra and inter frequency */
	p_rrm_ncl_params = rrm_cellm_get_ncl_params(p_rrm_cell_context->cell_index);

	/* Get the PCI and EARFCN for reported CGI */
	p_report_cgi_req_info = (rrm_ue_meas_config_cgi_queue_node_t *)(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
	if ((RRM_PNULL != p_report_cgi_req_info) && (RRM_EUTRAN_CELL == p_report_cgi_req_info->rat_type))
	{
		phy_cell_id_info.phy_cell_id = p_report_cgi_req_info->cgi;
		phy_cell_id_info.carr_earfcn = p_report_cgi_req_info->arfcn;
		if (RRM_PNULL != p_rrm_ncl_params)
		{

			/* Case Intra freq cells */
			if (phy_cell_id_info.carr_earfcn == p_rrm_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
			{
				for(ncl_count_index = RRM_ZERO;
						ncl_count_index < p_rrm_ncl_params->num_valid_intra_freq_cell;
						ncl_count_index++)
				{
					if (phy_cell_id_info.phy_cell_id == p_rrm_ncl_params->intra_freq_cells[ncl_count_index].phy_cell_id)
					{
						discard_queued_msg = RRM_TRUE;
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"Intra frequency Neighbor cell PCI[%d] Earfcn[%d], is present in NCL",
								phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
						RRM_UT_TRACE_EXIT();
						return discard_queued_msg;
					}
				}
			}
			/* Case Inter freq cells */
			else
			{
				for(ncl_count_index = RRM_ZERO;
						ncl_count_index < p_rrm_ncl_params->num_valid_inter_freq_cell;
						ncl_count_index++)
				{
					if((phy_cell_id_info.phy_cell_id == p_rrm_ncl_params->inter_freq_cells[ncl_count_index].phy_cell_id) &&
							(phy_cell_id_info.carr_earfcn == p_rrm_ncl_params->inter_freq_cells[ncl_count_index].eutra_carrier_arfcn))
					{
						discard_queued_msg = RRM_TRUE;
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"Inter frequency Neighbor cell PCI[%d] Earfcn[%d], is present in NCL",
								phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);
						RRM_UT_TRACE_EXIT();
						return discard_queued_msg;
					}
				}
			}
		}
		/*Coverity 87529 Fix Start*/
		/* SPR 16219 fix start */
                /* SPR 21496 Fix Start */ 
		p_meas_config_info = rrm_find_obj_in_ue_meas_config(p_report_cgi_req_info->rat_type,
				p_report_cgi_req_info->arfcn,
				p_report_cgi_req_info->band_ind,
				p_report_cgi_req_info->band_class,
				p_rrm_ue_global_context->p_ue_context->p_meas_config);
                /* SPR 21496 Fix End */ 
		/* SPR 16219 fix end */
		/*Coverity 87529 Fix End*/
		/* SPR 17599 FIX START*/
		if(RRM_PNULL == p_meas_config_info)
		{
			discard_queued_msg = RRM_TRUE;
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"No valid meas object is not found");
		}
		else if (RRM_ZERO == p_meas_config_info->meas_id)
		{
			discard_queued_msg = RRM_TRUE;
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"No valid meas_id is not found");
		}
		/* SPR 17599 FIX END*/
	}



	RRM_UT_TRACE_EXIT();
	return discard_queued_msg;
}
/* SPR 16099 fix end */


/****************************************************************************
 * Function Name  : rrm_ho_to_utra_daho
 * Inputs         : rrm_ue_context_t *p_ue_ctxt,trans id
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Hands over UE to utra Daho cell
 ****************************************************************************/
static rrm_bool_t rrm_check_if_ue_support_ps_ho_utran(
		rrm_ue_context_t  *p_ue_context)

{
	rrm_bool_t ue_support_ps_ho_utran = RRM_FALSE;
	RRM_UT_TRACE_ENTER();
	if (RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT &
			p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
			eutra_radio_capability_info_def.bitmask)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT");

	}
	/*Start:Bug 762*/
	if(rrm_is_set_fgi_bit(p_ue_context,RRM_EIGHT) &&
			rrm_is_set_fgi_bit(p_ue_context,RRM_TWENTY_TWO))
		/*End:Bug 762*/
	{
		ue_support_ps_ho_utran = RRM_TRUE;
	}
	RRM_UT_TRACE_EXIT();
	return ue_support_ps_ho_utran;
}

/*****************************************************************************
 * Function Name  : rrm_uem_find_aggressor_node_list_key 
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None 
 * Returns        :
 * Description    : This function is the keyof function for the nmmctl_scan_record_t
 *                  linked list.
 ****************************************************************************/
static const rrm_void_t* rrm_uem_find_aggressor_node_list_key(const YLNODE *p_ylnode)
{                   
	/* bug_13914_start */
	return  &(((aggressor_node_t *)p_ylnode)->aggressor_node_data.pci);
	/* bug_13914_start */
} 

/*****************************************************************************
 * Function Name  : rrm_uem_aggressor_node_data_compare 
 * Inputs         : p_key1 - Pointer to the data1 to be compaired
 *                  p_key2 - Pointer to the data2 to be compaired
 * Outputs        : None
 * Returns        : 0 if data1 is same as data2
 *                  1 if data1 is not same as data2
 * Description    : This function compares the key passed to retrieve correct
 *                  node from linked list.
 ****************************************************************************/
	static int rrm_uem_aggressor_node_data_compare
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
	if (*(UInt16* )p_key1 == *(UInt16* )p_key2)
	{
		return (RRM_FAILURE);
	}
	else
	{       
		return (RRM_SUCCESS);
	}
}

/* eICIC_PHASE_1_2_CHANGES_START */
/* eICIC_PHASE_1_2_CHANGES_END */

/* CSR00069389 Start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_process_dequeued_msg
 *   DESCRIPTION:
 *       Processes the message dequeued from UE procedure queue.
 *   RETURNS: None
 ******************************************************************************/

/*SPR 17061 Start*/
/* SPR 15397 Start */
/* SPR 15314 Start */
rrm_void_t
rrm_ue_process_dequeued_msg (
		rrm_ue_procedure_record_t  *p_rrm_ue_procedure_record,
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_cell_context_t *p_cell_context = RRM_PNULL;
	rrm_bool_et enqueue_back = RRM_FALSE;
	rrm_bool_et configure_autonomous_gap = RRM_FALSE;
	/* SPR 16099 fix start */
	rrm_bool_et             discard_queued_msg = RRM_FALSE;
	/* SPR 16099 fix end */

	RRM_UT_TRACE_ENTER();

	/* SPR 12512 Fix Start */
	if (RRM_PNULL != p_rrm_ue_procedure_record)
	{
		/* SPR 12512 Fix End */

		if (p_rrm_ue_procedure_record->proc_queue.api_id == RRC_RRM_MEAS_CONFIG_REQ)
		{
			p_cell_context = rrm_cellm_get_cell_context(p_g_rrm_ue_ctx->p_ue_context->cell_index);
			/* SPR 16099 fix start */
			/* 1. Check if the PCI and EARFCN of the procedure data already present in the intra and inter frequency
			 *    NCL then discard the dequeued API.
			 * 2. Check if CGI procedure already ongoing for a PCI and EARFCN then also discard the dequeued API.
			 */
			if (p_cell_context != RRM_PNULL)
			{
				discard_queued_msg = rrm_ue_check_if_dequeued_api_to_be_discarded(p_rrm_ue_procedure_record,
						p_g_rrm_ue_ctx,
						p_cell_context);
				if (RRM_FALSE == discard_queued_msg)
				{
					if (p_g_rrm_ue_ctx->p_ue_context->cdrx_status == RRM_UE_CDRX_DISABLED)
					{
						if ((RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT & p_g_rrm_ue_ctx->p_ue_context->ue_capability_params.bitmask) &&
								(RRM_REL9 <= p_g_rrm_ue_ctx->p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
								 eutra_radio_capability_info_def.access_stratum_release))
						{   
							configure_autonomous_gap = 
								rrm_uem_check_configure_auto_gap_or_cdrx_for_eutra(p_cell_context, p_g_rrm_ue_ctx->p_ue_context);
						}

						if (RRM_FALSE == configure_autonomous_gap)
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
									"CDRX will be applied to the UE at the time of CGI reporting");
							/* SPR_16061_Fix: Start */
							if ((RRM_UE_ERB_NULL == p_g_rrm_ue_ctx->p_ue_context->current_procedure.state) &&
									(p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state == RRM_UE_ERB_NULL))
							{
								p_g_rrm_ue_ctx->p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_APPLIED;
								if (RRM_FAILURE == rrm_build_and_send_ue_reconfig_req(p_g_rrm_ue_ctx->p_ue_context))
								{
									RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
											"Failed to send UE reconfig request, UE index[%d]",
											p_g_rrm_ue_ctx->p_ue_context->ue_index);
									p_g_rrm_ue_ctx->p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
								}
								else
								{
									RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
											"UE reconfig request sent to UE index[%d] for rat type [%d]"
											" to apply CDRX for CGI reporting",
											p_g_rrm_ue_ctx->p_ue_context->ue_index,  p_g_rrm_ue_ctx->p_ue_context->rat_configured);

									/* SPR 15539 Start */
									p_g_rrm_ue_ctx->p_ue_context->is_cgi_process_in_progress = RRM_TRUE;
									/* SPR 15539 End */
								}
							}
							/* SPR_16061_Fix: End */
						}
					}

					/* SPR 15860 Start */
					/* SPR 15861 Start */
					/* SPR 15862 Start */
					/* SPR 15608 Start */
					/* SPR_16053_Fix: Start */
					if ((p_g_rrm_ue_ctx->p_ue_context->current_procedure.state == RRM_UE_REESTABLISH_PROCEDURE_ONGOING) ||
							/* SPR_16053_Fix: End */
							((configure_autonomous_gap != RRM_TRUE) && (p_g_rrm_ue_ctx->p_ue_context->cdrx_status != RRM_UE_CDRX_APPLIED)) ||
							(RRM_TRUE == rrm_ue_is_cgi_report_pending(p_g_rrm_ue_ctx->p_ue_context)))
						/* SPR 15608 End */

						/* SPR 15860 End */
						/* SPR 15861 End */
						/* SPR 15862 End */
					{
						enqueue_back = RRM_TRUE;         
					}
				}
			}
			/* SPR 16099 fix end */
		}

		/* Meas Config CGI Req will be processed if no meas results are awaited and
		   Meas Results for HO will be processed if no meas config req is ongoing */
		/* SPR 15745 Start */
		/* SPR 16099 fix start */
		if(RRM_TRUE == discard_queued_msg)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"Dequeued procedure is Meas Config CGI Req/Meas Results for HO."
					"Discarding as Cell already added in NCL or CGI procedure ongoing for the same PCI & EARFCN!!");
		}
		else if ((enqueue_back == RRM_TRUE) || (((p_rrm_ue_procedure_record->proc_queue.api_id == RRC_RRM_MEAS_CONFIG_REQ) && 
						(RRM_UE_MEAS_RESULTS_AWAITED == p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state)) ||
					/* SPR 16099 fix end */
					/* SPR_15755_Fix: Start */
					(p_g_rrm_ue_ctx->p_ue_context->current_procedure.state == RRM_UE_MEAS_CONFIG_REQ_ONGOING)))
			/* SPR_15755_Fix: End */
		{

			/* Enqueue Meas Config CGI req back to the procedure queue */
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"Dequeued procedure is Meas Config CGI Req/Meas Results for HO." 
					"Enqueuing it back as Meas Results are awaited");
			/* SPR 16456 Fix Start */
			/* SPR 18925 Fix Start */
                        /* Code Removed */
                        rrm_ue_mgr_enqueue_back_req(&p_rrm_ue_procedure_record->proc_queue, p_g_rrm_ue_ctx->p_ue_context);
                        /* SPR 18925 Fix End */
			/* SPR 16456 Fix Stop */
		}
		else
		{
			/* SPR 15441 start */
			if(RRM_PNULL != p_rrm_ue_procedure_record->proc_queue.p_proc_data)
			{
				p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data = 
					p_rrm_ue_procedure_record->proc_queue.p_proc_data;
				/*CA HARDENING CHANGES 6.3.0*/
				rrm_ue_handle_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx,p_g_rrm_ue_ctx->p_ue_context->cell_index);

			}
			/* SPR 15441 end */
		}

		/* SPR 15441 start */
		if(RRM_PNULL != p_rrm_ue_procedure_record->proc_queue.p_proc_data)
		{
			RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
		}
		RRM_MEM_FREE(p_rrm_ue_procedure_record);
		/* SPR 15441 end */

		/* SPR 12512 Fix Start */
	}
	/* SPR 12512 Fix End */
	RRM_UT_TRACE_EXIT();
}
/* CSR00069389 End */
/* SPR 15314 End */
/* SPR 15397 End */
/*SPR 17061 End*/
/*TM mode 7-8 start*/
/****************************************************************************
 * Function Name  : rrm_build_and_mac_ue_reconfig_req_beamforming_algo
 * Inputs         : rrm_ue_context_t 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : sends mac_ue_reconfig_req with beamforming algo
 ****************************************************************************/
	rrm_return_et
rrm_build_and_mac_ue_reconfig_req_beamforming_algo(
		rrm_ue_context_t            *p_ue_context
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et ret_val=RRM_SUCCESS;
	const rrm_tm_mode_additional_info_t *p_rrm_tm_mode_additional_info=
		rrm_cm_get_mrrm_tm_mode_additional_info(p_ue_context->cell_index);
    /* Coverity FIX 99694 Start */
	RrmMacUeReconfigReq *p_mac_ue_reconfig_req = RRM_PNULL;
    p_mac_ue_reconfig_req = (RrmMacUeReconfigReq *)
            rrm_mem_get(sizeof(RrmMacUeReconfigReq));
    if( RRM_PNULL ==  p_mac_ue_reconfig_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_mac_ue_reconfig_req,
               RRM_ZERO,
               sizeof(RrmMacUeReconfigReq)); 
	p_mac_ue_reconfig_req->bitmask |= UE_BEAM_FORMING_ALGO_RECONFIG_BIT;
	p_mac_ue_reconfig_req->ueBeamformingAlgoToBeUsedInfo.numOfUE = RRM_ONE;
	p_mac_ue_reconfig_req->ueBeamformingAlgoToBeUsedInfo.ueBeamformingAlgo[RRM_ZERO].
		ueIndex = p_ue_context->ue_index; 
    /* Coverity FIX 99694 End */
	if(BEAM_FORMING_SINR == p_rrm_tm_mode_additional_info->beam_forming_algo)
	{
    /* Coverity FIX 99694 Start */
		p_mac_ue_reconfig_req->ueBeamformingAlgoToBeUsedInfo.ueBeamformingAlgo[RRM_ZERO].
			beamformingAlgoToBeUsed =  RRM_ZERO;
    /* Coverity FIX 99694 End */
	}
	else if(BEAM_FORMING_AOA == p_rrm_tm_mode_additional_info->beam_forming_algo)
	{
    /* Coverity FIX 99694 Start */
		p_mac_ue_reconfig_req->ueBeamformingAlgoToBeUsedInfo.ueBeamformingAlgo[RRM_ZERO].
			beamformingAlgoToBeUsed = RRM_ONE;
    /* Coverity FIX 99694 End */
	}

	/*SPR 7892 FIX START*/
	if( MAC_UE_RECONF_NOT_ONGOING  == rrm_get_mac_ue_reconfig_mutex( p_ue_context->cell_index))
	{
    /* Coverity FIX 99694 Start */
		ret_val = rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req,
				RRM_MODULE_ID,
				RRM_ZERO,
				p_ue_context->cell_index );

    /* Coverity FIX 99694 End */
		if( RRM_FAILURE == ret_val )
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
					"Failed to Send to RRM_MAC_UE_RECONFIG_REQ to L2 with beamforming algo");
		}
		else
		{
			rrm_set_mac_ue_reconfig_mutex(p_ue_context->cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_BEAMFRMG);

			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
					"Successfully Sent RRM_MAC_UE_RECONFIG_REQ to L2 with beamforming algo");
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
				"MAC UE reconfig is already ongoing for this cell index[%d]",p_ue_context->cell_index);
		ret_val = RRM_FAILURE; 
	}
	/*SPR 7892 FIX END*/
    /* Coverity FIX 99694 Start */
    RRM_MEM_FREE(p_mac_ue_reconfig_req);
    /* Coverity FIX 99694 End */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*TM mode 7-8 end*/

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_admission_cnf 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_admission_cnf message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_admission_cnf(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et                ret_val = RRM_SUCCESS;
	rrm_ue_context_t	       	*p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	U8                          *p_response = RRM_NULL;
	U8                           port = RRM_ZERO;
	/* BUG_876_CHANGES_START*/
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	/* BUG_876_CHANGES_END*/

	RRM_UT_TRACE_ENTER();    

	/* BUG_876_CHANGES_START*/
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_ue_context->cell_index];
	RRM_ASSERT(RRM_PNULL != p_rrm_cell_ctx);
	/* BUG_876_CHANGES_END*/

	p_response = (U8 *)(p_ue_context->current_procedure.p_proc_data);

	if (*p_response == RRM_SUCCESS)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,\
				"UE_INDEX[%d],S_TMSI [0x%x%x%x%x%x]RRC_RRM_UE_ADMISSION_CNF response SUCCESS",\
				p_ue_context->ue_index,p_ue_context->ue_s_tmsi[RRM_ZERO],p_ue_context->ue_s_tmsi[RRM_ONE],\
				p_ue_context->ue_s_tmsi[RRM_TWO],p_ue_context->ue_s_tmsi[RRM_THREE],p_ue_context->ue_s_tmsi[RRM_FOUR]);
		rrm_ue_set_state(p_ue_context, RRM_UE_WAIT_FOR_CAP_IND);
		/*Initialize procedure queue*/
		rrm_init_queue(&p_g_rrm_ue_ctx->p_ue_context->procedure_queue);
		/* CSR00069389 Start */
		p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state = RRM_UE_ERB_NULL;
		p_g_rrm_ue_ctx->p_ue_context->p_proc_queue_first_meas_node = RRM_PNULL;
		/* CSR00069389 End */
		/**Increment clpc ue counter*/
		p_g_rrm_ue_ctx->clpc_ue_counter +=RRM_ONE;         

		/* Setting Lowest Priority for UE - with No ERABS till now*/
		p_ue_context->ue_priority = RRM_ZERO;
		/* SPR 17564 Fix Start */
		if (RRM_FALSE == rrm_is_ue_special_previledge (p_ue_context))
			/* SPR 17564 Fix End */
		{
			/* Updating the UE Priority*/
			if (RRM_FAILURE == rrm_ue_insert_ue_to_priority_list(p_ue_context))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"UE_INDEX[%d]: Failure received while updating the  \
						ue_priority", p_ue_context->ue_index);
			}
		}
		else
		{
			p_ue_context->ue_priority = RRM_UE_NO_PRIORITY;
		}
		/* BUG_876_CHANGES_START*/
		/*DYNAMIC ICIC START*/
		/*
		 ** After a successful UE attach ,increment the counter for CE UE's in the repective Cell.
		 */
		if( RRM_UE_POSITION_AT_CELL_EDGE == 
				p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)   
		{
			rrm_cellm_increment_dynamic_icic_counter_in_cell( p_ue_context->cell_index ,
					RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
		}
		else
		{
			rrm_cellm_increment_dynamic_icic_counter_in_cell( p_ue_context->cell_index ,
					RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
		}
		/*
		 ** If at the time of attach , P_A for ue is the MAX poosible value 
		 ** increment the counter for UE's with MAX p_a in the repective Cell.
		 */
		/* This means that RM has increased the pA to maximum number and this counter will be incremented
		 * only when the pA was increased through ramping step. in this case, this should be decremented
		 */
		if( (MAX_VALUE_FOR_P_A == p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured) &&
				(MAX_VALUE_FOR_P_A != p_rrm_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a) &&
				(MAX_VALUE_FOR_P_A != p_rrm_cell_ctx->dynamic_icic_data.pdsch_config_params.pdsch_dedicated_config.pa_for_ce_ue))
		{
			rrm_cellm_increment_dynamic_icic_counter_in_cell( p_ue_context->cell_index ,
					RRM_CELLM_DYNAMIC_ICIC_P_MAX_UES );
		}
		/*DYNAMIC ICIC END*/
		/* BUG_876_CHANGES_END*/
		if( RRM_SUCCESS == rrm_cellm_get_antenna_port(p_ue_context->cell_index,&port))
		{
			if( ( ANTENNA_PORTS_COUNT_AN2 == port ) || ( ANTENNA_PORTS_COUNT_AN4 == port ) )
			{
				if(RRM_SUCCESS == rrm_build_and_mac_ue_reconfig_req_beamforming_algo(p_ue_context))
				{
					/* CSR 58774 Fix Start */
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"UE_INDEX[%d]: Succesfully sent mac ue reconfig req "
							"with beamforming algo as configured in rrm.cfg", 
							p_ue_context->ue_index);
					/* CSR 58774 Fix End */
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
							"UE_INDEX[%d]: Failed to send  mac ue reconfig req "
							"with beamforming algo",
							p_ue_context->ue_index);
				}
			}
		}
		/* BUG_12217_CHANGES_START */
		/* SPR 11966 Fix Start */
		/* SPR 15441 start */
		/* code removed */
		/* SPR 15441 end */
		/* SPR 11127 Fix Start */
		/* SPR 11127 Fix End */
		/* SPR 11966 Fix End */
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,\
				"UE_INDEX[%d],S_TMSI [0x%x%x%x%x%x]RRC_RRM_UE_ADMISSION_CNF response FAILED",\
				p_ue_context->ue_index,p_ue_context->ue_s_tmsi[RRM_ZERO],p_ue_context->ue_s_tmsi[RRM_ONE],\
				p_ue_context->ue_s_tmsi[RRM_TWO],p_ue_context->ue_s_tmsi[RRM_THREE],p_ue_context->ue_s_tmsi[RRM_FOUR]);
		/** Delete UE Contex */
		/* CID: 11465 */
		/* SPR Fix 14575 Start */
		if( RRM_UE_POSITION_AT_CELL_EDGE == 
				p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)   
		{
			rrm_cellm_increment_dynamic_icic_counter_in_cell( p_ue_context->cell_index ,
					RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
		}
		else
		{
			rrm_cellm_increment_dynamic_icic_counter_in_cell( p_ue_context->cell_index ,
					RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
		}
		/* SPR Fix 14575 end */
		/* BUG_12217_CHANGES_START */
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				"UE_INDEX[%d] with S_TMSI [0x%x%x%x%x%x] is going for deletion",
				p_ue_context->ue_index,p_ue_context->ue_s_tmsi[RRM_ZERO],p_ue_context->ue_s_tmsi[RRM_ONE],
				p_ue_context->ue_s_tmsi[RRM_TWO],p_ue_context->ue_s_tmsi[RRM_THREE],p_ue_context->ue_s_tmsi[RRM_FOUR]);
		if(RRM_FAILURE == rrm_ue_delete_context(p_ue_context->cell_index, 
					p_ue_context->ue_index))
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"Failed to delete ue context");
			ret_val = RRM_FAILURE;
		}
		else
		{
			/*SPR 16504 fix start*/
			/* Trace removed */
			/*SPR 16504 fix stop*/
			/* SPR 16403  FIX START*/ 
			p_g_rrm_ue_ctx->p_ue_context=NULL;
			p_ue_context=NULL; 
			/* SPR 16403  FIX STOP*/

			ret_val = RRM_SUCCESS;

		}
		/* BUG_12217_CHANGES_END */
	}
	/* BUG_12217_CHANGES_START */
	/* SPR 16403  FIX START*/
	if(p_ue_context != NULL)
		/* SPR 16403  FIX STOP*/
		p_ue_context->current_procedure.p_proc_data = RRM_PNULL;
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	/* BUG_12217_CHANGES_END */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/*LTE_RRM_KLOCWORK_WARN_9_JULY_START*/
/****************************************************************************
 * Function Name  : rrm_ue_does_erb_exist
 * Inputs         : rrm_ue_context_t *p_ue_context RRM UE Context.
 rrm_ue_erab_setup_item_list_t *p_erb_setup_item_list.
 * Outputs        : U8 *erb_exist
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Check that erb already exist or not.
 ****************************************************************************/
	rrm_return_et
rrm_ue_does_erb_exist(
		const rrm_ue_erab_setup_item_list_t	*p_erb_setup_item_list,
		const rrm_ue_context_t			*p_ue_context,
		U8    					*erb_exist
		)
{
	rrm_return_et		ret_val = RRM_SUCCESS;
	U8                          erb_requested_index = RRM_ZERO;
	U8				drb_configured_index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	/** Check and return FAILURE if the erab already exist*/
	for(erb_requested_index = RRM_ZERO;
			erb_requested_index < p_erb_setup_item_list->num_of_list;
			erb_requested_index++)
	{
		for(drb_configured_index = RRM_ZERO;
				drb_configured_index < p_ue_context->drb_configured.num_of_list;
				drb_configured_index++)
		{
			if(p_erb_setup_item_list->erab_item[erb_requested_index].erab_id ==
					p_ue_context->drb_configured.erab_item
					[drb_configured_index].erab_id)
			{
				*erb_exist = RRM_TRUE;
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d]"
						"Requested Rab already exist for the UE" ,
						p_ue_context->ue_index);

				/* Raise Event RRM_EVENT_LOCAL_ERAB_ADMISSION_REJECT START*/
				rrm_raise_event_erab_adm_rej(
						p_erb_setup_item_list->erab_item[erb_requested_index].erab_id,
						RRM_EVENT_ERAB_ID_CONFLICT);
				/*SPR 17777 +-*/
				/* Raise Event RRM_EVENT_LOCAL_ERAB_ADMISSION_REJECT END*/
				break;
			}
		}
		if(*erb_exist == RRM_TRUE)
		{
			break;
		}
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_9_JULY_END*/

/* CA Stage 3 Start */
/****************************************************************************
 * Function Name  : rrm_check_scell_csg_status_when_ue_mem_to_non_mem
 * Inputs         : rrm_ue_context_t   *p_ue_context
 * Outputs        : None
 * Returns        : SUCCESS or FAILURE
 * Description    : Checks the compatibility of the SCell's CSG status when the 
 CSG status of the UE changes from MEMBER to NON-MEMBER.
 ****************************************************************************/
	rrm_return_et
rrm_check_scell_csg_status_when_ue_mem_to_non_mem(
		rrm_ue_context_t   *p_ue_context
		)
{
	U8                     index = RRM_ZERO;
	U8                     counter = RRM_ZERO;
	U8                     scell_cell_index = RRM_ZERO;
	rrm_cell_context_t    *p_scell_context = RRM_PNULL;
	rrm_cell_context_t    *p_cell_ctx = RRM_PNULL;
	/*cov fix start 63900*/
	rrm_cell_index_t       arr_scell_index[RRM_MAX_SCELL];
	/*cov fix end 63900*/
	rrm_return_et          ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();
	p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);

	if(RRM_PNULL != p_cell_ctx)
	{
		/*cov fix start 63900*/
		for(index = RRM_ZERO; (index < RRM_MAX_SCELL) && (index < p_ue_context->ue_scell_add_params.count) ; index++)
			/*cov fix end 63900*/
		{
			scell_cell_index = p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_cell_index;
			p_scell_context = rrm_cellm_get_cell_context(scell_cell_index); 

			if(RRM_PNULL != p_scell_context)
			{
				/* If the UE becomes NON-MEMBER, then the CSG status 
				 ** of the SCell should not be CLOSED. If it is, then 
				 ** release the SCell */
				if(RRM_OAM_ACCESS_MODE_HYBRID == p_cell_ctx->access_mgmt_params.access_mode)
				{
					if(RRM_OAM_ACCESS_MODE_CLOSE == p_scell_context->access_mgmt_params.access_mode)
					{
						arr_scell_index[counter] = scell_cell_index;   
						counter++;

						RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
								"Scell Index: [%d] to be released", p_cell_ctx->scell_info[index].scell_index);
					}
					else
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"SCell's CSG status is not Closed, so it is CSG compatible with the UE");
						ret_val = RRM_FAILURE;
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"PCell's CSG status is not Hybrid, so it is CSG compatible with the UE");
					ret_val = RRM_FAILURE;

				}
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"SCell's Cell context is NULL");
				ret_val = RRM_FAILURE;
			}
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				"PCell's Cell context is NULL");
		ret_val = RRM_FAILURE;
	}

	/*cov fix start 63900*/
	if((counter > RRM_ZERO) && (counter < RRM_MAX_SCELL))
		/*cov fix end 63900*/
	{
		/*SPR 13316:start*/
		ret_val = rrm_fill_scell_to_remove_list(p_ue_context, p_cell_ctx->cell_index, counter, arr_scell_index, RRM_ZERO, RRM_ZERO);
		/*SPR 13316:end*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* CA Stage 3 End */
/****************************************************************************
 * Function Name  : rrm_adjust_csg_nsg_counter
 * Inputs         : rrm_csg_membership_status_et old_membership_status
 rrm_ue_context_t   *p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Increments csg non_csg.
 ****************************************************************************/
void rrm_adjust_csg_nsg_counter(
		rrm_csg_membership_status_et old_membership_status,
		rrm_ue_context_t   *p_ue_context
		)
{
	rrm_cell_info_for_ue_mgr_t *p_rrm_cell_info_for_ue_mgr = RRM_NULL;
	/* CSR 00070663 FIX START */
	rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;
	/* CSR 00070663 FIX END */

	RRM_UT_TRACE_ENTER();

	p_rrm_cell_info_for_ue_mgr = rrm_cellm_get_cell_resource_info(p_ue_context->cell_index);

	/* CSR 00070663 FIX START */
	p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	RRM_ASSERT(RRM_PNULL != p_cell_ctx);
	/* Coverity 93976 Fix Start */
	if (RRM_PNULL == p_cell_ctx)
	{
		RRM_UT_TRACE_EXIT();
		return;
	}
	/* Coverity 93976 Fix End */    
	/* CSR 00070663 FIX END */
	switch(old_membership_status)
	{
		case RRM_INVALID:
			if(p_ue_context->rrm_csg_membership.rrm_csg_membership_status == RRM_MEMBER)
			{
				(p_rrm_cell_info_for_ue_mgr->admitted_csg_user) += RRM_ONE;
				/* CSR 00070663 FIX START */
				/*spr_12545_changes_start*/
				p_cell_ctx->kpi_stat.kpi.num_of_admitted_csg_user += RRM_ONE;
				/*spr_12545_changes_end*/
				/* CSR 00070663 FIX END */
			}
			else if(p_ue_context->rrm_csg_membership.rrm_csg_membership_status == RRM_NOT_MEMBER)
			{
				(p_rrm_cell_info_for_ue_mgr->admitted_non_csg_user) += RRM_ONE;
				/* CSR 00070663 FIX START */
				/*spr_12545_changes_start*/
				p_cell_ctx->kpi_stat.kpi.num_of_admitted_non_csg_user += RRM_ONE;
				/*spr_12545_changes_end*/
				/* CSR 00070663 FIX END */
			}
			break;
		case RRM_MEMBER:
			/*membership status changed to non member,
			  increment non_csg counter, decrement csg counter*/
			if(p_ue_context->rrm_csg_membership.rrm_csg_membership_status == RRM_NOT_MEMBER)
			{
				(p_rrm_cell_info_for_ue_mgr->admitted_non_csg_user) += RRM_ONE;
				(p_rrm_cell_info_for_ue_mgr->admitted_csg_user) -= RRM_ONE;
				/* CSR 00070663 FIX START */
				/*spr_12545_changes_start*/
				p_cell_ctx->kpi_stat.kpi.num_of_admitted_csg_user -= RRM_ONE;
				p_cell_ctx->kpi_stat.kpi.num_of_admitted_non_csg_user += RRM_ONE;
				/*spr_12545_changes_end*/
				/* CSR 00070663 FIX END */
			}
			break;
		case RRM_NOT_MEMBER:
			/*membership status changed to member,
			  increment csg counter, decrement non csg counter*/
			if(p_ue_context->rrm_csg_membership.rrm_csg_membership_status == RRM_MEMBER)
			{
				(p_rrm_cell_info_for_ue_mgr->admitted_csg_user) += RRM_ONE;
				(p_rrm_cell_info_for_ue_mgr->admitted_non_csg_user) -= RRM_ONE;
				/* CSR 00070663 FIX START */
				/*spr_12545_changes_start*/
				p_cell_ctx->kpi_stat.kpi.num_of_admitted_csg_user += RRM_ONE;
				p_cell_ctx->kpi_stat.kpi.num_of_admitted_non_csg_user -= RRM_ONE;
				/*spr_12545_changes_end*/
				/* CSR 00070663 FIX END */
			}
			break;
		default:
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Not of any valid membership status");
			break;

	}
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_decrease_csg_non_csg_counter
 * Inputs         : rrm_csg_membership_status_et old_membership_status
 rrm_ue_context_t   *p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Increments csg non_csg.
 ****************************************************************************/
	void
rrm_decrease_csg_non_csg_counter(
		rrm_ue_context_t *p_ue_context 
		)
{
	rrm_cell_info_for_ue_mgr_t *p_rrm_cell_info_for_ue_mgr = RRM_NULL;
	p_rrm_cell_info_for_ue_mgr = rrm_cellm_get_cell_resource_info(p_ue_context->cell_index);
	RRM_UT_TRACE_ENTER();


	if(p_ue_context->rrm_csg_membership.rrm_csg_membership_status == RRM_MEMBER)
	{
		(p_rrm_cell_info_for_ue_mgr->admitted_csg_user) -= RRM_ONE;

		/* CSR 00070663 FIX START */
		/*spr_12545_changes_start*/
		/*spr_12545_changes_end*/
		/* CSR 00070663 FIX END */
	}
	else/*not member*/
	{
		(p_rrm_cell_info_for_ue_mgr->admitted_non_csg_user) -= RRM_ONE;

		/* CSR 00070663 FIX START */
		/*spr_12545_changes_start*/
		/*spr_12545_changes_end*/
		/* CSR 00070663 FIX END */
	}
	RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_erb_setup_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_setup_req message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_erb_setup_req (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et					ret_val = RRM_SUCCESS;
	rrm_ue_context_t            	*p_ue_context = RRM_PNULL;
	rrm_ue_proc_erab_setup_data_t 	*p_rrm_ue_proc_erab_setup_data = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t 	erb_setup_item_list;
	rrm_bool_t 						erb_exist = RRM_FALSE;
	/*BUG 13332:start*/
	U16                             trans_id = p_g_rrm_ue_ctx->trans_id;
	/*BUG 13332:end*/
    /*SPR 18241 START*/
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
    /*SPR 18241 END*/
	rrm_ue_erab_setup_item_list_t   *p_erab_setup_item_success_list = RRM_PNULL;
	rrm_ue_erab_failed_item_list_t  *p_erab_setup_item_failed_list = RRM_PNULL;
	U8                              index = RRM_NULL;
	rrm_bool_t                                          congestion_flag = RRM_FALSE;
	/*csg start*/
	access_mgmt_params_t            *p_access_mgmt_params = RRM_PNULL;
	rrm_csg_membership_status_et    old_membership_status;
	/*csg end*/
	inter_rat_ncl_t  *p_irat_ncl = RRM_PNULL;

    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */

	rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;
	/* Coverity_fix_start_62517 */
	/* Coverity_fix_end_62517 */
	rrm_bool_et  is_daho_present = RRM_FALSE;

	RRM_UT_TRACE_ENTER();
	/** Store the UE context in local pointer to this function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);
    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */


	/*Coverity 93972 Fix Start*/
	if (RRM_PNULL == p_cell_ctx)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Cell Context not found");
		return RRM_FAILURE;
	}
	/*CID 65803:start*/
	if (p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_DAHO_CELL_LIST)
		/*CID 65803:send*/
	{
		is_daho_present = RRM_TRUE;
	}
	/*Coverity 93972 Fix End*/

    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */

	/* coverity : CID 30227*/
	p_ue_context->cdma2000_capabilities.is_utran_geran_present = 
		(rrm_bool_et) ((RRM_ZERO < p_irat_ncl->num_valid_utran_freq_cell) ||
				(RRM_ZERO < p_irat_ncl->num_valid_geran_cell) ||
				(is_daho_present));



	/* SPR 17600 Fix Start */
	/* Code Removed */
	/* SPR 17600 Fix Stop */

	/*SPR 16944 START*/
	/*code deleted*/
	/*SPR 16944 END*/
	switch (rrm_cellm_erb_setup_and_modification_allowed(p_ue_context->cell_index))
	{
		case RRM_ALL_CALLS:
			break;

		case RRM_EMRGCY_CALLS:
			congestion_flag = RRM_FALSE;
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
					"ERB Addition %s on cell [%u]",
					(congestion_flag == RRM_TRUE? "not allowed due to load condition":"allowed"),p_ue_context->cell_index);
			break;
		case RRM_PRIVILEGE_CALLS:
			/* SPR 17564 Fix Start */
			if (RRM_TRUE == rrm_is_ue_special_previledge (p_ue_context))
				/* SPR 17564 Fix End */
			{
				congestion_flag = RRM_FALSE;
			}
			else
			{
				congestion_flag = RRM_TRUE;
			}
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
					"ERB Addition %s on cell [%u]",
					(congestion_flag == RRM_TRUE? "not allowed due to load condition":"allowed"),p_ue_context->cell_index);
			break;
		default:
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
					"ERB Addition not allowed on cell [%u]",
					p_ue_context->cell_index);
			congestion_flag = RRM_TRUE;
			break;
	}

	p_erab_setup_item_success_list = (rrm_ue_erab_setup_item_list_t *)
		rrm_mem_get(sizeof(rrm_ue_erab_setup_item_list_t));
	
	/*SPR 19013 Start*/
	if(RRM_PNULL != p_erab_setup_item_success_list)
	{
		RRM_MEMSET(p_erab_setup_item_success_list,
				RRM_ZERO,
				sizeof(rrm_ue_erab_setup_item_list_t));
	}
	/*SPR 19013 End*/

	if( RRM_PNULL == p_erab_setup_item_success_list)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
		return RRM_FAILURE;
	}
	p_erab_setup_item_failed_list = (rrm_ue_erab_failed_item_list_t *)
		rrm_mem_get(sizeof(rrm_ue_erab_failed_item_list_t));
	
	/*SPR 19013 Start*/
	if(RRM_PNULL != p_erab_setup_item_failed_list)
	{
		RRM_MEMSET(p_erab_setup_item_failed_list,
				RRM_ZERO,
				sizeof(rrm_ue_erab_failed_item_list_t));
	}
	/*SPR 19013 End*/

	if( RRM_PNULL == p_erab_setup_item_failed_list)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
		RRM_MEM_FREE(p_erab_setup_item_success_list);
		return RRM_FAILURE;
	}
	/** Check for current procedure state and perform the check for DRB 
	  configured in the UE context */
	if (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], Current procedure \
				is ERB NULL for the UE" ,p_ue_context->ue_index);
		p_rrm_ue_proc_erab_setup_data = (rrm_ue_proc_erab_setup_data_t *)
			p_ue_context->current_procedure.p_proc_data;

		if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_HO_RESTRICTION_LIST_PRESENT)
		{
            /*SPR 21848 Start*/
			rrm_ue_fill_restriction_list_from_proc_data_to_ue_context(&p_ue_context->ho_restriction_list,
					&p_rrm_ue_proc_erab_setup_data->ho_restriction_list);
            rrm_release_ho_restriction_list(&p_rrm_ue_proc_erab_setup_data->ho_restriction_list);
            /*SPR 21848 End*/
		}
		/*csg start*/
		old_membership_status = p_ue_context->rrm_csg_membership.rrm_csg_membership_status;

		/* SPR 10079 Fix Start */
		p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
		if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_CSG_MEM_STATUS_PRESENT)
		{
			p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
				p_rrm_ue_proc_erab_setup_data->csg_membership_status;
		}
		/* SPR 16996 Fix Start */
		else if(p_cell_ctx->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
		{
			if(p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_CLOSE)
			{
				p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
					RRM_MEMBER;
			}
			else
			{
				p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
					RRM_NOT_MEMBER;
			}
		}
		/* SPR 16996 Fix Stop */
		else if(p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_CLOSE)
		{
			p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
				RRM_MEMBER;
		}
		else
		{
			p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
				RRM_NOT_MEMBER;
		}

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Cell access mode =  %d old_membership_status = %d rrm_csg_membership_status = %d",
				p_access_mgmt_params->access_mode, old_membership_status, p_ue_context->rrm_csg_membership.rrm_csg_membership_status);

		rrm_adjust_csg_nsg_counter(old_membership_status,p_ue_context);
		/* SPR 10079 Fix End */

		/*in case of erb_setup_req handle csg membership only if the
		  cell hybrid*/
		if(p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_HYBRID)
		{
			if(p_access_mgmt_params->max_csg_members != RRM_MINUS_ONE)
			{
				ret_val = rrm_handle_csg_membership_hybrid(p_ue_context,p_access_mgmt_params->max_csg_members,
						p_access_mgmt_params->max_non_csg_members);
			}
			else /*max_csg_member is set as -1*/
			{
				ret_val = rrm_handle_max_csg_mem_minus_one_hybrid(p_ue_context,p_access_mgmt_params);
			}

			/*if csg validation fails check UE establishment cause*/
			if(ret_val == RRM_FAILURE )
			{
				/*if establishment cause is EMERGENCY or HIGH PIRORITY release lowst priority UE and admit
				  the current UE*/
				/* SPR 17564 Fix Start */
				ret_val = rrm_ue_emergency_establishment_operation(p_ue_context,
						/* SPR 17564 Fix End */
						trans_id,p_ue_context->cell_index);
			}

			p_ue_context->rrm_ue_in_hold = RRM_FALSE;
			if(RRM_FAILURE == ret_val)
			{
				if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
							p_ue_context->ue_index,
							RADIO_NETWORK_LAYER_TYPE,
							S1AP_INVALID_CSG_ID,
							trans_id,
							RRM_PNULL,
							/* SPR_10729_fix */
							p_ue_context->cell_index))
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
					ret_val = RRM_SUCCESS;
					if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_g_rrm_uem_facility_name,
								RRM_DETAILED,
								"ue_connection_release_ind sent, \
								Failed to clean up ue resources");
						ret_val = RRM_FAILURE;

					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
							"Failed to send release connection ind for UE index:%d",
							p_ue_context->ue_index);
					ret_val = RRM_FAILURE;

				}
				/* COVERITY : RESOURCE LEAK : CID : 54361,54362 fix start */
				if( RRM_NULL != p_erab_setup_item_success_list )
					RRM_MEM_FREE(p_erab_setup_item_success_list);
				if( RRM_NULL != p_erab_setup_item_failed_list )
					RRM_MEM_FREE( p_erab_setup_item_failed_list );
				/* COVERITY : RESOURCE LEAK : CID : 54361,54362 fix end*/
				return ret_val;
			}
		}
		else
		{
			/* CSR 58774 Fix Start */
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"UE_INDEX[%d], cell is not hybrid, skipping csg validation",
					p_ue_context->ue_index);
			/* CSR 58774 Fix End */
		}
		/*end csg membership*/

		/* CS-Fallback: update ue_context params of rrm_ue_context_mod_req_t */
		if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_SPID_PRESENT)
		{
			/* InterRAT changes start */
            /*SPR 22553 FIXED START*/
            /*Code Remove */
            p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = p_rrm_ue_proc_erab_setup_data->spid;
            p_ue_context->rrm_sub_profile_id_info.bitmask |= RRM_UEM_CTX_TRANSE_PID_PRESENT;
            /*SPR 22553 FIXED END*/

			/* InterRAT changes end */
		}

		/* SRVCC SUPPORT START */
		if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_SRVCC_OP_POSSIBLE_PRESENT)
		{
			p_ue_context->srvcc_config_info.srvcc_ho_op_possible =
				p_rrm_ue_proc_erab_setup_data->srvcc_op_possible;
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"SRVCC Op Possible = %d present in erab setup req",
					p_ue_context->srvcc_config_info.srvcc_ho_op_possible);
		}
        /*SPR 20634 Fix Start*/
        /*Code Removed*/
        /*SPR 20634 Fix Stop*/
		/* SRVCC SUPPORT END */

		if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_CSF_INDICATOR_PRESENT)
		{
			p_ue_context->ue_context_mod_req.csf_indicator = p_rrm_ue_proc_erab_setup_data->csf_indicator;
			/* InterRAT changes start */
			p_ue_context->ue_context_mod_req.bitmask |= RRM_UEM_CTX_CSF_INDICATOR_PRESENT;
			p_ue_context->ho_params.bitmask |= RRM_UE_CSFB_RECD;
			/* InterRAT changes end */
		}
		if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_REGISTERED_LAI_PRESENT)
		{
			RRM_MEMCPY(&(p_ue_context->ue_context_mod_req.registered_lai), 
					&(p_rrm_ue_proc_erab_setup_data->registered_lai), sizeof(rrm_uem_registered_lai_t));
			p_ue_context->ue_context_mod_req.bitmask |= RRM_UEM_CTX_REGISTERED_LAI_PRESENT;
		}
		/* CS-Fallback: changes ends */

		erb_setup_item_list = p_rrm_ue_proc_erab_setup_data->erab_setup_list;

		/*LTE_RRM_KLOCWORK_WARN_9_JULY_START*/
		/*this function determine that erab exist already or not*/
		rrm_ue_does_erb_exist(&erb_setup_item_list,
				p_ue_context,
				&erb_exist
				);
		/*LTE_RRM_KLOCWORK_WARN_9_JULY_END*/


		if((RRM_TRUE == congestion_flag) || (erb_exist ||  (erb_setup_item_list.num_of_list == RRM_NULL)))
		{
			//# increment counter for erb exists
			if(RRM_TRUE == erb_exist)
			{
#ifdef RRM_UT_FLAG       
				RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_erb_setup_resp_F_erb_exist);
#endif                
			}

			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], Either \
					ERB exist or default bearer does not exist or rab \
					request list zero for the UE or congestion occured" ,
					p_ue_context->ue_index);
			p_erab_setup_item_success_list->num_of_list = RRM_ZERO;
			if(erb_setup_item_list.num_of_list != RRM_NULL)
			{
				p_erab_setup_item_failed_list->num_of_list = 
					erb_setup_item_list.num_of_list;
				/* Coverity_ID_Fix_55332 */
				for(index = RRM_NULL; 
						((index< erb_setup_item_list.num_of_list) &&
						 (index < RRM_MAX_NUM_DRB_PER_UE)); index++)
				{
					p_erab_setup_item_failed_list->
						erab_to_be_release_item[index].erab_id =
						erb_setup_item_list.erab_item[index].erab_id;
					/*Update type and cause */
					p_erab_setup_item_failed_list->
						erab_to_be_release_item[index].cause.type= RADIO_NETWORK_LAYER_TYPE;
					p_erab_setup_item_failed_list->
						erab_to_be_release_item[index].cause.value= NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL;
				}
			}
			else
			{
				p_erab_setup_item_failed_list->num_of_list = RRM_ZERO;
			}

			p_ue_context->current_procedure.p_erb_success_list =
				(rrm_void_t*)p_erab_setup_item_success_list;
			p_ue_context->current_procedure.p_erb_failed_list =
				(rrm_void_t*)p_erab_setup_item_failed_list;

			/** fill and send erb setup resp*/
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], Sending ERB \
					SETUP RESP with response FAILURE for the UE" ,
					p_ue_context->ue_index);
			ret_val = rrm_build_and_send_erb_setup_resp (RRM_UE_FAILURE,
					p_ue_context,
					trans_id);
#ifdef RRM_UT_FLAG       
			RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_erb_setup_resp_F);    //# total failure
#endif                
			/* SPR 15441 start */
			/* code removed */
			/* SPR 15441 end */

			/*clean_up_start*/
			RRM_MEM_FREE(p_erab_setup_item_success_list);
			RRM_MEM_FREE(p_erab_setup_item_failed_list);
			p_ue_context->current_procedure.p_erb_success_list = RRM_PNULL;
			p_ue_context->current_procedure.p_erb_failed_list = RRM_PNULL;
			/*clean_up_end*/

                /*SPR 18241 START*/
                if ((ret_val == RRM_SUCCESS)&&(rrm_get_queue_count(&p_ue_context->procedure_queue)))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UE_INDEX[%d], dequeue queued message",
                            p_ue_context->ue_index);
                    /** Dequeue the events from event queue and call message handler */
                    p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                    if(RRM_PNULL != p_rrm_ue_procedure_record)
                    {
                        rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
                    }
                }
                /*SPR 18241 END*/
		}
		else
		{
			/* SPR 19968 START */
                if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_AMBR_PRESENT)
                {
                    /** Store the AMBR value in UE context for RBC */
                    p_g_rrm_ue_ctx->p_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
                        p_rrm_ue_proc_erab_setup_data->ambr.ue_agg_max_bit_rate_ul;
                    p_g_rrm_ue_ctx->p_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
                        p_rrm_ue_proc_erab_setup_data->ambr.ue_agg_max_bit_rate_dl;
                }
                #ifdef ENDC_ENABLED
                if(p_rrm_ue_proc_erab_setup_data->bitmask & RRM_UEM_ERAB_SETUP_REQ_AMBR_PRESENT)
                {
                    if(p_rrm_ue_proc_erab_setup_data->ambr.bitmask & RRM_EXT_UE_AGG_MAX_BITRATE_EXT_PRESENT)
                    {
                        p_g_rrm_ue_ctx->p_ue_context->ue_agg_max_bit_rate.bitmask |=
                            RRM_EXT_UE_AGG_MAX_BITRATE_EXT_PRESENT;

                        /** Store the AMBR value in UE context for RBC */
                        p_g_rrm_ue_ctx->p_ue_context->ue_agg_max_bit_rate.ue_ambr_ext.ue_agg_max_bit_rate_ul_ext =
                            p_rrm_ue_proc_erab_setup_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_ul_ext;
                        p_g_rrm_ue_ctx->p_ue_context->ue_agg_max_bit_rate.ue_ambr_ext.ue_agg_max_bit_rate_dl_ext =
                            p_rrm_ue_proc_erab_setup_data->ambr.ue_ambr_ext.ue_agg_max_bit_rate_dl_ext;
                    }
                }
                #endif
			/*clean_up_start*/
			rrm_handle_erb_setup_modify_procedure(p_g_rrm_ue_ctx,
					p_erab_setup_item_success_list,
					p_erab_setup_item_failed_list,
					ERAB_SETUP);
			/*clean_up_end*/

			/* SPR 19968 END */
		}
	}
	else
	{
		/*SPR 19819 30JUN START*/
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING, "UE_INDEX[%d], Current procedure \
				is not ERB NULL, enqueue message for the UE" ,
				p_ue_context->ue_index);
		/*SPR 19819 30JUN END*/
		rrm_ue_procedure_queue_t    proc_queue;
		proc_queue.api_id = p_g_rrm_ue_ctx->api_id; 
		proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data; 
		/*BUG 13332:start*/
		proc_queue.trans_id = trans_id;
		/*BUG 13332:end*/
		/**Enqueue ERAB setup request */
        /*SPR 18241 START*/
		rrm_ue_mgr_enqueue_req( &proc_queue, p_g_rrm_ue_ctx->p_ue_context, RRM_FALSE);
        /*SPR 18241 END*/

		/* Memory resource borrowed from system for erb list are useless when 
		   UE's sub state in not valid to process the erb setup req. in this case
		   function enque the proc date later to be processed and erb's list memory
		   reference is lost and memory is leaked.*/
		/* COVERITY : RESOURCE LEAK : CID : 54361,54362 fix start */
		if( RRM_NULL != p_erab_setup_item_success_list )
			RRM_MEM_FREE(p_erab_setup_item_success_list);
		if( RRM_NULL != p_erab_setup_item_failed_list )
			RRM_MEM_FREE( p_erab_setup_item_failed_list );
		/* COVERITY : RESOURCE LEAK : CID : 54361,54362 fix end*/

	} 
	/* SPR 10751 Fix Start */
	/* SPR 17600 Fix Start */
	/* Code Removed */
	/* SPR 17600 Fix Stop */
	/* SPR 10751 Fix End */
	RRM_UT_TRACE_EXIT();
	return ret_val;  
}

/****************************************************************************
 * Function Name  : rrm_ho_to_geran_daho
 * Inputs         : rrm_ue_context_t *p_ue_ctxt,trans id
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Hands over UE to geran Daho cell 
 ****************************************************************************/
	rrm_return_et
rrm_ho_to_geran_daho(
		rrm_ue_context_t  *p_ue_context,
		U16   trans_id
		)
{
	/* SPR 15674 Start */
	/* SPR 16406 8SEP start */
	/* SPR 16406 18sep Start  */
	phy_cell_id_info_t phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
	/* SPR 16406 18sep End */
	/* SPR 16406 8SEP end */
	/* SPR 15674 End */
	rrm_return_et ret_val = RRM_FAILURE;
	rrm_bool_t   cco_suppoted = RRM_FALSE;
	rrm_bool_t   ps_ho_enabled_for_csfb = RRM_FALSE;

    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */
	RRM_UT_TRACE_ENTER();
	/* SPR 15674 Start */
    /* SPR 19364 start */
    /* Code removed */
    /* SPR 19364 end */
	/*If PS HO supported OR (PS HO not supported however CCO supported)
	  then call HO REQUIRED else release UE*/
	if((phy_cell_id_info.phy_cell_id != INVALID_PHYSICAL_CELL_ID) &&
			(RRM_CELL_DTM_SUPPORTED & phy_cell_id_info.bitmask))
		/* SPR 15336 Fix End */
	{ 
		p_ue_context->ho_params.target_phys_cell_id = phy_cell_id_info.phy_cell_id;
		p_ue_context->ho_params.target_earfcn = phy_cell_id_info.carr_earfcn;
		ps_ho_enabled_for_csfb = rrm_cellm_get_ps_ho_flag(p_ue_context->cell_index);
		/* SPR_14067_Fix_Start */
        /* SPR 19364 start */
		cco_suppoted = rrm_ue_check_for_cco(p_ue_context, &phy_cell_id_info);
        /* SPR 19364 end */
		/* SPR_14067_Fix_End */
		if ((RRM_TRUE == ps_ho_enabled_for_csfb)||
				((RRM_FALSE == ps_ho_enabled_for_csfb) && (RRM_TRUE == cco_suppoted)))
		{

			/* CSR 55938: code changes start */
			/* CSR 55938: code changes end */
			ret_val = rrm_build_and_send_ho_required (
					phy_cell_id_info,
					p_ue_context,
					trans_id);
			if (RRM_SUCCESS == ret_val) {
				/* SPR 16406 8SEP start */
				/* Code removed */
				/* SPR 16406 8SEP end */
				RRM_TRACE(g_cellm_log_on_off,
						p_rrm_cellm_facility_name,
						RRM_DETAILED,
						"HO triggered towards PCI[%d], Earfcn[%d]"
						"for UE: [%d]", phy_cell_id_info.phy_cell_id,
						phy_cell_id_info.carr_earfcn,
						p_ue_context->ue_index);
				/* SPR 15674 End */
			}
			else {
				p_ue_context->ue_state = RRM_UE_STATE_ACTIVE;
			}
		}/*If HO_REQ to be called*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ho_to_utra_daho
 * Inputs         : rrm_ue_context_t *p_ue_ctxt,trans id
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Hands over UE to utra Daho cell
 ****************************************************************************/
	rrm_return_et
rrm_ho_to_utra_daho(
		rrm_ue_context_t  *p_ue_context,
		U16   trans_id
		)
{
	/* SPR 15674 Start */
	/* SPR 16406 8SEP start */
	/* SPR 16406 18sep Start  */
	phy_cell_id_info_t phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
	/* SPR 16406 18sep End */
	/* SPR 16406 8SEP end */
	/* SPR 15674 End */
	rrm_return_et ret_val = RRM_FAILURE;
	rrm_bool_t   ps_ho_enabled_for_csfb = RRM_FALSE;
    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */
	RRM_UT_TRACE_ENTER();

    /* SPR 17850 Fix Start */
    /* Code Deleted */
    /* SPR 17850 Fix End */
	/*Note here PCI is actually PSC configured for UTRAN*/
	/* SPR 15674 Start */
	phy_cell_id_info = rrm_validate_and_get_utran_daho_pci(p_ue_context);
	/*If PS HO supported then call HO REQUIRED else release UE*/
	if(phy_cell_id_info.phy_cell_id != INVALID_PHYSICAL_CELL_ID)
	{
		p_ue_context->ho_params.target_phys_cell_id = phy_cell_id_info.phy_cell_id;
		p_ue_context->ho_params.target_earfcn = phy_cell_id_info.carr_earfcn;
		ps_ho_enabled_for_csfb = rrm_cellm_get_ps_ho_flag(p_ue_context->cell_index);
        /* SPR 17850 Fix Start */
        if (RRM_TRUE == ps_ho_enabled_for_csfb) 
        /* SPR 17850 Fix End */
        {
			/* CSR 55938: code changes start */
			/* CSR 55938: code changes end */
            /*SPR_17893_START*/
            if((UTRA_CELL == p_ue_context->target_cell_type) &&
                    !(RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT & p_ue_context->ue_capability_params.bitmask))
            {    
                if((RRM_UE_STATE_ACTIVE == p_ue_context->ue_state))
                {
                    rrm_populate_and_send_utran_cap_enq_req(p_ue_context);
                    rrm_ue_set_state(p_ue_context,RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES);
                    rrm_set_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_FALSE);
                    p_ue_context->is_ho_reqd_on_recv_utan_cap  = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,
                            RRM_DETAILED,"Utran Capability is triggered for UE: [%d]",
                            p_ue_context->ue_index);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,
                            RRM_DETAILED,"Utran Capability has already been asked for UE: [%d]",
                            p_ue_context->ue_index);
                }
                ret_val = RRM_SUCCESS;
            }
            else
            {
            /*SPR_17893_END*/
			ret_val = rrm_build_and_send_ho_required (
					phy_cell_id_info,
					p_ue_context,
					trans_id);
			if (RRM_SUCCESS == ret_val)
			{
				/* SPR 16406 8SEP start */
				/* Code removed */
				/* SPR 16406 8SEP end */
				RRM_TRACE(g_cellm_log_on_off,
						p_rrm_cellm_facility_name,
						RRM_DETAILED,
						"HO triggered towards PCI[%d], Earfcn[%d]"
						"for UE: [%d]", phy_cell_id_info.phy_cell_id,
						phy_cell_id_info.carr_earfcn,
						p_ue_context->ue_index);
			}
			else
			{
				p_ue_context->ue_state = RRM_UE_STATE_ACTIVE;
			}
            /*SPR_17893_START*/
            }
            /*SPR_17893_END*/
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
					"PS HO is not possible for UE[%d] with PCI[%d] Earfcn[%d]",p_ue_context->ue_index,
					phy_cell_id_info.phy_cell_id, phy_cell_id_info.carr_earfcn);

		}
	}
	/* SPR 15674 End */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_ho_to_eutra_daho
 * Inputs         : rrm_ue_context_t *p_ue_ctxt,trans id
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Hands over UE to eutra Daho cell
 ****************************************************************************/
	rrm_return_et
rrm_ho_to_eutra_daho(
		rrm_ue_context_t  *p_ue_context,
		U16   trans_id
		)
{
	/* SPR 15674 Start */
	/* SPR 16406 8SEP start */
	/* SPR 16406 18sep Start  */
	phy_cell_id_info_t phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
	/* SPR 16406 18sep End */
	/* SPR 16406 8SEP end */
	/* SPR 15674 End */
	rrm_return_et ret_val = RRM_SUCCESS; 
	RRM_UT_TRACE_ENTER();
	/* SPR 15674 Start */
	phy_cell_id_info = rrm_validate_and_get_eutran_daho_pci(p_ue_context);
	if(phy_cell_id_info.phy_cell_id != INVALID_PHYSICAL_CELL_ID)
	{
		/* CSR 55938: code changes start */
		/* CSR 55938: code changes end */
		ret_val = rrm_build_and_send_ho_required (
				phy_cell_id_info,
				p_ue_context,
				trans_id);
		if (RRM_SUCCESS == ret_val) {
			/* SPR 16406 8SEP start */
			/* Code removed */
			/* SPR 16406 8SEP end */
			RRM_TRACE(g_cellm_log_on_off,
					p_rrm_cellm_facility_name,
					RRM_DETAILED,
					"HO triggered towards PCI[%d], Earfcn[%d]"
					"for UE: [%d]", phy_cell_id_info.phy_cell_id,
					phy_cell_id_info.carr_earfcn,
					p_ue_context->ue_index);
			/* SPR 15674 End */
		}
		else {
			p_ue_context->ue_state = RRM_UE_STATE_ACTIVE;
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* SPR 17850 Fix Start */
/****************************************************************************
 * Function Name  : rrm_ue_is_ue_supported_utra
 * Inputs         : rrm_ue_context_t *p_ue_context RRM UE Context.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE 
 * Description    : Is UE supports UTRA.
 ****************************************************************************/
rrm_bool_et
rrm_ue_is_ue_supported_utra
(
    rrm_ue_context_t* p_ue_context
)
{
    rrm_bool_et                     is_ue_supported_utra = RRM_FALSE;

    rrm_ue_inter_rat_Parameters_t   *p_ue_inter_rat_param = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if (RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT & 
          p_ue_context->ue_capability_params.bitmask) 
    {
        p_ue_inter_rat_param =(rrm_ue_inter_rat_Parameters_t *) &(p_ue_context->\
                                   ue_capability_params.rrm_eutra_radio_capability_info.\
                                   eutra_radio_capability_info_def.inter_rat_parameters);

        if ((RRM_INTER_RAT_UTRA_FDD_PRESENT & p_ue_inter_rat_param->bitmask) && 
            (p_ue_inter_rat_param->utra_fdd.count)) 
        {
            is_ue_supported_utra = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "UE supports UTRAN FDD Bands");
        }
        else if ((RRM_INTER_RAT_UTRA_TDD_128_PRESENT & p_ue_inter_rat_param->bitmask) &&
                 (p_ue_inter_rat_param->utra_tdd128.count))
        {
            is_ue_supported_utra = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "UE supports UTRAN TDD128 Bands");
        }
        else if ((RRM_INTER_RAT_UTRA_TDD_384_PRESENT & p_ue_inter_rat_param->bitmask) &&
                 (p_ue_inter_rat_param->utra_tdd384.count))
        {
            is_ue_supported_utra = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "UE supports UTRAN TDD384 Bands");

        }
        else if ((RRM_INTER_RAT_UTRA_TDD_768_PRESENT & p_ue_inter_rat_param->bitmask) &&
                 (p_ue_inter_rat_param->utra_tdd768.count))
        {
            is_ue_supported_utra = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                      "UE supports UTRAN TDD768 Bands");
        }
    }

    RRM_UT_TRACE_EXIT();
    return is_ue_supported_utra;
}
/* SPR 17850 Fix End */
/****************************************************************************
 * Function Name  : rrm_get_hghst_prorty_rat_basd_on_spid
 * Inputs         : rrm_ue_context_t *p_ue_context RRM UE Context.
 * Outputs        : None
 * Returns        : Cell type
 * Description    : Returns highest priority rat based on spid
 ****************************************************************************/
    rrm_cell_type_t
rrm_get_hghst_prorty_inter_rat_basd_on_spid(
        rrm_ue_context_t  *p_ue_ctxt
        )
{
    /* SPR 20653 Fix Start */
    rrm_oam_rat_priority_info_et get_eutran_priority = RRM_OAM_RAT_PRIORITY_LEAST;
    rrm_oam_rat_priority_info_et get_utran_priority = RRM_OAM_RAT_PRIORITY_LEAST;
    rrm_oam_rat_priority_info_et get_geran_priority = RRM_OAM_RAT_PRIORITY_LEAST;
    /* SPR 13205 Fix Start */
    rrm_oam_rat_priority_info_et get_cdma_priority = RRM_OAM_RAT_PRIORITY_LEAST;
    /* SPR 13205 Fix End */
    rrm_oam_rat_priority_info_et highest_priority = RRM_OAM_RAT_PRIORITY_LEAST;    
    /* SPR 20653 Fix End */

    rrm_oam_spid_table_t        *spid_table_params = RRM_PNULL;
    rrm_bool_et                 spid_found = RRM_FALSE;
    rrm_cell_type_t             rat_type = INVALID;
    U32 i = RRM_ZERO;
    rrm_cell_context_t   *p_cell_ctx = RRM_PNULL;
    U8 index = RRM_ZERO;
    rrm_bool_et  FLAG = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    p_cell_ctx = rrm_cellm_get_cell_context(p_ue_ctxt->cell_index);

    /*CID 65787:start*/
    if (RRM_PNULL != p_cell_ctx)
    {
    /*SPR 22553 FIXED START*/
    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
            "p_ue_ctxt->rrm_sub_profile_id_info.sub_profile_id = %d", p_ue_ctxt->rrm_sub_profile_id_info.sub_profile_id);

    spid_table_params = rrm_cellm_get_spid_table_params(p_ue_ctxt->cell_index);
    if(RRM_PNULL != spid_table_params && RRM_ZERO != spid_table_params->spid_count)
    {
        for(i =RRM_ZERO; i < spid_table_params->spid_count ; i++)/*CCO-fix-21-feb*/
        {
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                    "SPID Table Params:\n SPID = %d", spid_table_params->spid_config[i].spid);

            if(spid_table_params->spid_config[i].spid == p_ue_ctxt->rrm_sub_profile_id_info.sub_profile_id)
            {
/*SPR 22553 FIXED END*/
                /* SPR 20653 Fix Start */
                get_rat_priority(&spid_table_params->spid_config[i].rrm_rat_priority_list,
                         &get_eutran_priority, &get_utran_priority, &get_geran_priority, &get_cdma_priority);
                /* SPR 20653 Fix End */
                /* SPR 13205 Fix End */

                spid_found = RRM_TRUE;
                break;
            }
        }
    }
    if(RRM_TRUE == spid_found)
    {
        highest_priority = RRM_GET_MIN(get_utran_priority,get_geran_priority);
        /* SPR 13205 Fix Start */
        highest_priority = RRM_GET_MIN(highest_priority,get_cdma_priority);
        /* SPR 13205 Fix End */
        if (!(p_ue_ctxt->ho_params.bitmask & RRM_UE_CSFB_RECD))
        {
            highest_priority = RRM_GET_MIN(highest_priority, get_eutran_priority);
        }
/* SPR 17850 Fix Start */
        if(get_utran_priority == highest_priority) 
        {
            if((p_ue_ctxt->supported_rats & UE_SUPPORT_UTRAN_RAT) || 
               (RRM_TRUE == rrm_ue_is_ue_supported_utra(p_ue_ctxt)))
                rat_type = UTRA_CELL; 
            else if(p_ue_ctxt->supported_rats & UE_SUPPORT_GERAN_RAT)
                rat_type = GERAN_CELL;
            else if((p_ue_ctxt->supported_rats & UE_SUPPORT_HRPD_RAT) ||
                    (p_ue_ctxt->supported_rats & UE_SUPPORT_1XRTT))
                rat_type = CDMA2000_CELL;
            else
                rat_type = EUTRA_CELL;
        }
        else if(get_geran_priority == highest_priority) 
        {
            if(p_ue_ctxt->supported_rats & UE_SUPPORT_GERAN_RAT)
                rat_type = GERAN_CELL;
            else if((p_ue_ctxt->supported_rats & UE_SUPPORT_UTRAN_RAT) || 
               (RRM_TRUE == rrm_ue_is_ue_supported_utra(p_ue_ctxt)))
                rat_type = UTRA_CELL; 
            else if((p_ue_ctxt->supported_rats & UE_SUPPORT_HRPD_RAT) ||
                    (p_ue_ctxt->supported_rats & UE_SUPPORT_1XRTT))
                rat_type = CDMA2000_CELL;
            else
                rat_type = EUTRA_CELL;
        }
        /* SPR 13205 Fix Start */
        else if(get_cdma_priority == highest_priority) 
        {
            if((p_ue_ctxt->supported_rats & UE_SUPPORT_HRPD_RAT) ||
               (p_ue_ctxt->supported_rats & UE_SUPPORT_1XRTT))
                rat_type = CDMA2000_CELL;
            else if((p_ue_ctxt->supported_rats & UE_SUPPORT_UTRAN_RAT) || 
               (RRM_TRUE == rrm_ue_is_ue_supported_utra(p_ue_ctxt)))
                rat_type = UTRA_CELL; 
            else if(p_ue_ctxt->supported_rats & UE_SUPPORT_GERAN_RAT)
                rat_type = GERAN_CELL;
            else
                rat_type = EUTRA_CELL;
        }
        /* SPR 13205 Fix End */
/* SPR 17850 Fix End */
        else if (get_eutran_priority == highest_priority)
        {
            rat_type = EUTRA_CELL;
        }
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                "SPID Found! highest_priority = %d, rat_type = %d", highest_priority, rat_type);
    }
		else if(p_cell_ctx->operator_info.bitmask &
				RRMCM_RMIF_RAT_PRIORITY_INFO_CFG_PRESENT)
		{
			for(index = RRM_ZERO; index < RRM_IRAT_TYPE; index++)
			{
				switch(p_cell_ctx->operator_info.rat_priority_info.
						irat_priority_list_cfg[index])
                {
                    case RRM_IRAT_PRIORITY_EUTRAN:
                        if(p_ue_ctxt->ho_params.bitmask & RRM_UE_CSFB_RECD)
                        {
                            continue;
                        }
                        rat_type = EUTRA_CELL;
                        break;
                        /* SPR 17850 Fix Start */
                    case RRM_IRAT_PRIORITY_UTRAN:
                        if((p_ue_ctxt->supported_rats & UE_SUPPORT_UTRAN_RAT) || 
                                (RRM_TRUE == rrm_ue_is_ue_supported_utra(p_ue_ctxt)))
                        {
                            rat_type = UTRA_CELL;
                            FLAG = RRM_TRUE;
                        }
                        else
                            continue;
                        break;
                    case RRM_IRAT_PRIORITY_GERAN:
                        if(p_ue_ctxt->supported_rats & UE_SUPPORT_GERAN_RAT)
                        {
                            rat_type = GERAN_CELL;
                            FLAG = RRM_TRUE;
                        }
                        else
                            continue;
                        break;
                    case RRM_IRAT_PRIORITY_CDMA2000:
                        /*CID 97127 Start*/
                        if((p_ue_ctxt->supported_rats & UE_SUPPORT_HRPD_RAT) ||
                                (p_ue_ctxt->supported_rats & UE_SUPPORT_1XRTT))
                            /*CID 97127 End*/
                        {
                            rat_type = CDMA2000_CELL;
                            FLAG = RRM_TRUE;
                        }
                        else
                            continue;
                        break;
                        /* SPR 17850 Fix End */
                    default:
                        rat_type = INVALID;
                        break;
                }

				RRM_TRACE(g_uem_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
						"irat_priority_list_cfg[%d] = %d irat_type = %d", index,
						p_cell_ctx->operator_info.rat_priority_info.irat_priority_list_cfg[index], rat_type);
				if(RRM_TRUE == FLAG)
					break;
			}
		}
		else
		{
            /*SPR 22553 FIXED START*/
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"UE_INDEX[%d],SPID[%d], spid not found in "
					" spid table", p_ue_ctxt->ue_index,p_ue_ctxt->rrm_sub_profile_id_info.sub_profile_id);
            /*SPR 22553 FIXED END*/
			rat_type = INVALID;
		}
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return INVALID;
    }
	/*CID 65787:end*/

	RRM_UT_TRACE_EXIT();
	return rat_type;
}

/*LTE_RRM_KLOCWORK_WARN_9_JULY_START*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_cs_fallback
 * Inputs         : Pointer to RRM Global context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the CS fallback when ERAB setup/UE context modification 
 *                  is recived with CS fallback indicator.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_cs_fallback(const rrm_ue_global_context_t     *p_g_rrm_ue_ctx,
		rrm_bool_et *is_ue_released
		)
{

	rrm_return_et       ret_val = RRM_SUCCESS;
	rrm_ue_context_t        *p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	/* SPR 13734 Fix Start */
	//rrm_cell_type_t target_rat_type = INVALID;
	/* SPR 13734 Fix End */
	rrm_meas_config_info_t *p_rrm_meas_config_info = RRM_NULL;
	rrm_ho_params_t        *p_ho_params = RRM_PNULL;
	rrm_cell_context_t  *p_cell_ctx = RRM_PNULL;
	rrm_bool_et  ps_ho_flag = RRM_FALSE;
	/* SPR 13734 Fix Start */
	U8 index_rat = RRM_ZERO;
	rrm_bool_et is_eutran_supported_by_spid = RRM_FALSE;
	rrm_bool_et is_utran_supported_by_spid = RRM_FALSE;
	rrm_bool_et is_geran_supported_by_spid = RRM_FALSE;
	rrm_bool_et is_cdma2000_supported_by_spid = RRM_FALSE;
	rrm_bool_et spid_found = RRM_FALSE;
	rrm_bool_et priority_rat_flag = RRM_FALSE;
	/* SPR 13734 Fix End */
	/*SPR 21687 +- */

	/* Coverity 65022 Fix Start */
	RRM_UT_TRACE_ENTER();
	/* Coverity_fix_start_62537 */
	if (p_ue_context != RRM_PNULL)
	{
		/* Coverity_fix_end_62537 */
		p_ho_params = &(p_ue_context->ho_params);

		/*coverity 25400: p_idle_mode_mobility_params removed, , rel 1.3.1*/
		p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
		/*coverity 30228, , typecasted to rrm_bool_et*/
		/*CID 65801:start*/
		if (RRM_PNULL != p_cell_ctx)
		{
			ps_ho_flag = p_cell_ctx->ran_info.connected_mode_mobility_params.
				common_params_for_eutra.ps_ho_enabled;
			/* SPR 15455 Changes Starts */
			inter_rat_ncl_t *p_ncl_params = 
				rrm_cellm_get_inter_rat_ncl_info(p_ue_context->cell_index);
			/* SPR 15455 Changes Ends */

			if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
			{
				/*SPR 21687 +-*/
				/* SPR 13734 Fix Start */
				//target_rat_type = rrm_get_hghst_prorty_inter_rat_basd_on_spid(p_ue_context);
				p_rrm_meas_config_info = rrm_cellm_get_meas_config_info(p_ue_context->cell_index);
				/*get supported rats based on spid priority*/
				rrm_get_rat_priority_from_spid(p_ue_context,
						&is_eutran_supported_by_spid,
						&is_utran_supported_by_spid,
						&is_geran_supported_by_spid,
						&is_cdma2000_supported_by_spid,
						&spid_found);

				if(RRM_TRUE == spid_found)
				{
					p_ue_context->spid_found = RRM_TRUE;

					if(RRM_TRUE == is_eutran_supported_by_spid)
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"eutran is supported by spid");
					}

					if(RRM_TRUE == is_utran_supported_by_spid)
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"utran is supported by spid");
					}

					if(RRM_TRUE == is_geran_supported_by_spid)
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"geran is supported by spid");
					}

					if(RRM_TRUE == is_cdma2000_supported_by_spid)
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"cdma is supported by spid");
					}
				}
				/* If there is no frequency info configured for the highest priority RAT then
				 * we will consider the other low priority RATs */
				while(index_rat < RRM_IRAT_TYPE) 
				{
					/* In case the PS_HO_ENABLED flag is FALSE then we'll move out of the loop & move to RWR directly. */
					/* SPR 15336 Fix Start */
					if(RRM_FALSE == ps_ho_flag)
					{
						/*PS HO not possible so do release/redirection*/
					/* SPR 18892 Fix Start */
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
								"ps_ho_flag is not Enabled For RRM_IRAT_TYPE [%d] ",RRM_IRAT_TYPE);
					/* SPR 18892 Fix END */
						ret_val = RRM_FAILURE;
						break;
					}
					/* SPR 15336 Fix End */
					switch(get_next_priority_rat(index_rat, p_ue_context))
                    {
                        case RRM_IRAT_PRIORITY_EUTRAN:
                            break;
                        case RRM_IRAT_PRIORITY_UTRAN:
                            /* SPR 14239 Fix Start */
                            /* Check if UTRAN is restricted in forbidden inter rat list
                             * present in ho_restriction list */
                        /*SPR 21687 Start*/
                        if(is_ue_restricted_for_given_rat(p_ue_context, RRM_UTRAN_CELL))
                        {
                            /* SPR 22491 Fix Start */
                            ret_val = RRM_FAILURE;
                            /* SPR 22491 Fix End */
                            break;
                        }
                        /* SPR 21687 End */
                        /* SPR 14239 Fix End */
                        p_ue_context->target_cell_type = UTRA_CELL;
                        if(p_rrm_meas_config_info->csfb_tgt_selection.bitmask &
                                RRMCM_RMIF_UTRAN_CSFB_TGT_SELECTION_PRESENT ) 
                        {
                            if(RRM_CSFB_TGT_SELECT_MAHO ==\
                                    p_rrm_meas_config_info->csfb_tgt_selection.utran_csfb_tgt_selection)
                            {
                                /* SPR 15455 Changes Starts */
                                if(p_ncl_params->num_valid_utran_freq_cell == RRM_ZERO) 
                                {
                                    ret_val = RRM_FAILURE  ;
                                    break;    
                                }      
                                /* SPR 15455 Changes Ends */

                                if(!(rrm_check_if_ue_support_ps_ho_utran(p_ue_context)))
                                {
                                    /*PS HO not possible so do release/redirection*/
                                    ret_val = RRM_FAILURE;
                                }
                                /* If B1 is not already configured then configure now */
                                else if(!(p_ue_context->ho_params.bitmask & \
                                            RRM_UE_B1_MEAS_OBJ_CONFIGURED))
                                {
                                    ret_val = rrm_build_and_send_meas_config_req(\
                                            p_ue_context,MEAS_TYPE_HO);
                                    /*Start blind timer*/
                                    if(RRM_FAILURE !=ret_val)
                                    {
                                        rrm_ue_start_csfb_blind_timer(p_ue_context);
                                        priority_rat_flag = RRM_TRUE;
                                    }

                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                            "UE_INDEX[%u], B1 meas object is already configured"
                                            , p_ue_context->ue_index);
                                }
                            }
                            else if(RRM_CSFB_TGT_SELECT_DAHO ==\
                                    p_rrm_meas_config_info->csfb_tgt_selection.utran_csfb_tgt_selection)
                            {
                                /* SPR 15336 Fix Start */
                                /* In case of CSFB to DAHO it is not required to send SRVCC IE in HO required, So when DAHO PCI 
                                   needs to be validated it is required that ue_srvcc_criteria needs to be RRM_UE_SRVCC_IND_NOT_TO_BE_INCLUDED */
                                p_ue_context->srvcc_config_info.ue_srvcc_criteria = RRM_UE_SRVCC_IND_NOT_TO_BE_INCLUDED; 
                                /* SPR 15336 Fix End */
                                ret_val = rrm_ho_to_utra_daho(p_ue_context,p_g_rrm_ue_ctx->trans_id);
                                if(RRM_SUCCESS == ret_val)
                                {
                                    priority_rat_flag = RRM_TRUE;
                                }
                            }
                        }
                        break;
                        case RRM_IRAT_PRIORITY_GERAN:
                        /* SPR 15455 Changes Starts */
                        if(p_ncl_params->num_valid_geran_cell == RRM_ZERO)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "NO Geran NCL Present");
                            ret_val = RRM_FAILURE  ;
                            break;    
                        }      
                        /* SPR 15455 Changes Ends */
                        /* SPR 14239 Fix Start */
                        /* Check if GERAN is restricted in forbidden inter rat list
                         * present in ho_restriction list */
                        /*SPR 21687 Start*/
                        if(is_ue_restricted_for_given_rat(p_ue_context, RRM_GERAN_CELL))
                        {
                            /* SPR 22491 Fix Start */
                            ret_val = RRM_FAILURE;
                            /* SPR 22491 Fix End */
                            break;
                        }
                        /* SPR 21687 End */
                        /* SPR 14239 Fix End */
                        p_ue_context->target_cell_type = GERAN_CELL;
                        if(p_rrm_meas_config_info->csfb_tgt_selection.bitmask &
                                RRMCM_RMIF_GERAN_CSFB_TGT_SELECTION_PRESENT)
                        {
                            if(RRM_CSFB_TGT_SELECT_MAHO ==\
                                    p_rrm_meas_config_info->csfb_tgt_selection.geran_csfb_tgt_selection)
                            {
                                /* If B1 is not already configured then configure now */
                                if(!(p_ue_context->ho_params.bitmask & \
                                            RRM_UE_B1_MEAS_OBJ_CONFIGURED))
                                {
                                    ret_val = rrm_build_and_send_meas_config_req(\
                                            p_ue_context,MEAS_TYPE_HO);
                                    /*Start blind timer*/
                                    if(RRM_FAILURE !=ret_val)
                                    {
                                        rrm_ue_start_csfb_blind_timer(p_ue_context);
                                        priority_rat_flag = RRM_TRUE;
                                    }
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                            "UE_INDEX[%d], B1 meas object is already configured"
                                            , p_ue_context->ue_index);

                                }
                            }
                            else if(RRM_CSFB_TGT_SELECT_DAHO ==\
                                    p_rrm_meas_config_info->csfb_tgt_selection.geran_csfb_tgt_selection)
                            {
                                ret_val = rrm_ho_to_geran_daho(p_ue_context,p_g_rrm_ue_ctx->trans_id);
                                if(RRM_SUCCESS == ret_val)
                                {
                                    priority_rat_flag = RRM_TRUE;
                                }
                            }
                        }
                        break;
                        case RRM_IRAT_PRIORITY_CDMA2000:
                        if(p_ue_context->cdma2000_capabilities.is_cdma2000_present)
                        {
                            /* SPR 14239 Fix Start */
                            /* Check if CDMA is restricted in forbidden inter rat list
                             * present in ho_restriction list */
                            /*SPR 21687 Start*/
                            if(is_ue_restricted_for_given_rat(p_ue_context, RRM_CDMA_CELL))
                            {
                                /* SPR 22491 Fix Start */
                                ret_val = RRM_FAILURE;
                                /* SPR 22491 Fix End */
                                break;
                            }
                            /* SPR 14239 Fix End */
                            /* SPR_14216_start */
                            if(p_ue_context->ue_context_mod_req.bitmask & RRM_UEM_CTX_CSF_INDICATOR_PRESENT)
                            {
                                if(RRM_CSFB_PRESENT == p_ue_context->ue_context_mod_req.csf_indicator)
                                    /* SPR_14216_stop */
                                {
                                    /* CSFB With High Priority */
                                    /* If daho of 1xrtt */
                                    if((RRM_TRUE == ps_ho_flag) && 
                                            (!(p_ue_context->cdma2000_capabilities.is_dual_rx_mode_present)) &&
                                            (p_ue_context->cdma2000_capabilities.is_ecsfb_present))
                                    {
                                        /* CSR 55938: code changes start */
                                        /* CSR 55938: code changes end */
                                        ret_val = rrm_build_and_send_daho_1xrtt_ho_required (
                                                p_ue_context,
                                                p_g_rrm_ue_ctx->trans_id);
                                        if (RRM_SUCCESS == ret_val)
                                        {
                                            RRM_TRACE(g_cellm_log_on_off,
                                                    p_rrm_cellm_facility_name,
                                                    RRM_DETAILED,
                                                    "HO triggered for UE: [%d]",
                                                    p_ue_context->ue_index);
                                        }
                                    }
                                    else
                                    {
                                        /* else RWR 1xrtt */
                                        /* Bug 16121 Fix Start */
                                        if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                                                    p_ue_context->ue_index,
                                                    RADIO_NETWORK_LAYER_TYPE,
                                                    /* SPR-10489-fix start */
                                                    REDIRECTION_TOWARDS_1XRTT,
                                                    /* SPR-10489-fix end */
                                                    p_g_rrm_ue_ctx->trans_id,
                                                    p_ue_context,
                                                    /*CA HARDENING CHANGES 6.3.0*/
                                                    p_ue_context->cell_index))
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                    "ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
                                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                                            {
                                                RRM_TRACE(g_uem_log_on_off,
                                                        p_rrm_uem_facility_name,
                                                        RRM_DETAILED,
                                                        "ue_connection_release_ind sent, \
                                                        Failed to clean up ue resources");
                                            }
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                                    "Failed to send release connection ind for UE index:%d",
                                                    p_ue_context->ue_index);
                                        }
                                    }
                                    RRM_UT_TRACE_EXIT();
                                    /* Bug 16121 Fix End */

                                    return RRM_SUCCESS;
                                }
                            }

                            if(p_ue_context->cdma2000_capabilities.is_dual_rx_mode_present || 
                                    !((p_ue_context->cdma2000_capabilities.is_ecsfb_present)))
                            {
                                /* for Dual RX UE, Do RWR */
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                        "Release the UE [%d], Dual Rx Mode = %d eCSFB = %d",
                                        p_ue_context->ue_index,
                                        p_ue_context->cdma2000_capabilities.is_dual_rx_mode_present,
                                        p_ue_context->cdma2000_capabilities.is_ecsfb_present);

                                /* Bug 16121 Fix Start */
                                if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                                            p_ue_context->ue_index,
                                            RADIO_NETWORK_LAYER_TYPE,
                                            /* SPR-10489-fix start */
                                            /* SPR-12518-fix start */
                                            CS_FALLBACK_TRIGGERED,
                                            /* SPR-12518-fix end */
                                            /* SPR-10489-fix end */
                                            p_g_rrm_ue_ctx->trans_id,
                                            p_ue_context,
                                            p_ue_context->cell_index))
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                            "ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
                                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                                    {
                                        RRM_TRACE(g_uem_log_on_off,
                                                p_rrm_uem_facility_name,
                                                RRM_DETAILED,
                                                "ue_connection_release_ind sent, \
                                                Failed to clean up ue resources");
                                    }
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                            "Failed to send release connection ind for UE index:%d",
                                            p_ue_context->ue_index);
                                }
                                RRM_UT_TRACE_EXIT();
                                /* Bug 16121 Fix End */
                                return RRM_SUCCESS;
                            }
                            /* Check for TGT Cell Selection */
                            p_rrm_meas_config_info = rrm_cellm_get_meas_config_info(p_ue_context->cell_index);

                            if((RRM_CSFB_TGT_SELECT_MAHO == p_rrm_meas_config_info->
                                        csfb_tgt_selection.cdma2000_csfb_tgt_selection) &&
                                    (!(p_ue_context->cdma2000_capabilities.is_dual_rx_mode_present)))
                            {
                                if(p_ho_params->csfb_blind_timer)
                                {
                                    /* If CSFB blind timer is running then stop it as we got the inter RAT
                                     * MR */
                                    rrm_ue_stop_ho_timers(p_ue_context);
                                }
                                ret_val = rrm_build_and_send_meas_config_req(\
                                        p_ue_context,MEAS_TYPE_HO);
                                /* Start Blind Timer for CSFB Measurement Req */
                                if(!p_ue_context->ho_params.csfb_blind_timer)
                                {
                                    p_ue_context->ho_params.csfb_blind_timer = 
                                        rrm_ue_start_csfb_blind_timer(p_ue_context);
                                    if(p_ue_context->ho_params.csfb_blind_timer == RRM_PNULL)
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                                "Failed to start CSFB Blind Timer for UE Index [%d]",
                                                p_ue_context->ue_index);
                                        ret_val = RRM_FAILURE;
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                                "CSFB Blind Timer started for UE Index [%d]",
                                                p_ue_context->ue_index);
                                        priority_rat_flag = RRM_TRUE;
                                    }
                                }
                            }
                            else if((RRM_CSFB_TGT_SELECT_DAHO == p_rrm_meas_config_info->
                                        csfb_tgt_selection.cdma2000_csfb_tgt_selection) &&
                                    (!(p_ue_context->cdma2000_capabilities.is_dual_rx_mode_present)))
                            {
                                if(RRM_TRUE == ps_ho_flag)
                                {
                                    /* HO to DAHO if PS_HO Enabled */
                                    /* CSR 55938: code changes start */
                                    /* CSR 55938: code changes end */
                                    ret_val = rrm_build_and_send_daho_cdma2000_ho_required (
                                            p_ue_context,
                                            p_g_rrm_ue_ctx->trans_id);
                                    if (RRM_SUCCESS == ret_val)
                                    {
                                        RRM_TRACE(g_cellm_log_on_off,
                                                p_rrm_cellm_facility_name,
                                                RRM_DETAILED,
                                                "HO triggered for UE: [%d]",
                                                p_ue_context->ue_index);
                                        priority_rat_flag = RRM_TRUE;
                                    }
                                }
                                /* SPR: 15922 : Start */
                                /* SPR: 15922 : End */
                            }
                        }
                        /* Coverity 65022 Changes End */
                        break; 
                        default:
                        /* Bug 16121 Fix Start */
                        if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                                    p_ue_context->ue_index,
                                    RADIO_NETWORK_LAYER_TYPE,
                                    CS_FALLBACK_TRIGGERED,
                                    p_g_rrm_ue_ctx->trans_id,
                                    p_ue_context,
                                    /* SPR_10729_fix */
                                    p_ue_context->cell_index))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                            {
                                RRM_TRACE(g_uem_log_on_off,
                                        p_rrm_uem_facility_name,
                                        RRM_DETAILED,
                                        "ue_connection_release_ind sent, \
                                        Failed to clean up ue resources");
                                ret_val = RRM_FAILURE;
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "Failed to send release connection ind for UE index:%d",
                                    p_ue_context->ue_index);
                            ret_val = RRM_FAILURE;
                        }
                        /* Bug 16121 Fix End */
                        break;
                    }/*end switch*/
					/*Cov_fix_start_65022*/

					if(priority_rat_flag == RRM_TRUE)
					{
						break;
					}
					++index_rat;

				}/* end while*/
				/* SPR 13734 Fix End */
				if(RRM_FAILURE == ret_val)
				{
					if(RRM_FAILURE == rrm_build_and_send_ue_connection_release_ind(
								p_ue_context->ue_index,
								RADIO_NETWORK_LAYER_TYPE,
								CS_FALLBACK_TRIGGERED,
								p_g_rrm_ue_ctx->trans_id,
								p_ue_context,
								/* SPR_10729_fix */
								p_ue_context->cell_index))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_g_rrm_uem_facility_name,
								RRM_DETAILED,
								"UE_INDEX[%u]: Failure Received While Sending"
								" ue_connection_release_ind",
								p_ue_context->ue_index);
						ret_val = RRM_FAILURE;
					}
					else
					{
						if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
						{
							RRM_TRACE(g_uem_log_on_off,
									p_g_rrm_uem_facility_name,
									RRM_DETAILED,
									"ue_connection_release_ind sent, \
									Failed to clean up ue resources");
							ret_val = RRM_FAILURE;

						}
						else
						{
							*is_ue_released = RRM_TRUE;
						}
					}
				}
				/*Cov_fix_end_65022*/
			}/*end of if */
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		/*CID 65801:end*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
	/* Coverity 65022 Fix End */
}

/*SPR 22151 Fix Start*/
/*SPR 18654 START*/
/*Code deleted*/
/*SPR 18654 END*/

/****************************************************************************
 * Function Name  : rrm_ue_clean_rab_resrc_at_ho_adm_cnf_complete_failure
 * Inputs         : rrm_ue_context_t *p_ue_context
 *          rrm_ue_erab_setup_item_list_t *p_rrm_ue_erab_success_list       
 * Outputs        : None
 * Returns        : Void 
 * Description    : If RRC_RRM_HO_ADMISSION_CNF Failure is received
 *                  (Not partial Success) 
 *                  then free all the resources allocated.
 ****************************************************************************/
rrm_void_t
    rrm_ue_clean_rab_resrc_at_ho_adm_cnf_complete_failure
(
 rrm_ue_context_t                *p_ue_context,
 rrm_ue_erab_setup_item_list_t  *p_rrm_ue_erab_success_list
 )
{
    U8                              qci = RRM_ZERO;
    rrm_prb_t                       dl_prbs_to_release = RRM_ZERO;
    rrm_prb_t                       ul_prbs_to_release = RRM_ZERO;
    U64                             dl_bitrate = RRM_ZERO;
    U64                             ul_bitrate = RRM_ZERO;
    U8                              success_erab_index = RRM_ZERO;
    rrm_cell_context_t *p_cell_context = PNULL;
    RRM_UT_TRACE_ENTER();

    p_cell_context = rrm_cellm_get_cell_context (p_ue_context->cell_index);
    if(RRM_PNULL == p_cell_context)
	{
        RRM_TRACE( g_uem_log_on_off, p_g_rrm_uem_facility_name,
                RRM_ERROR,
                " cell index not found ");
		RRM_UT_TRACE_EXIT();
        return ;
    }


    for(success_erab_index = RRM_ZERO;
            ((success_erab_index < p_rrm_ue_erab_success_list->num_of_list) && 
             (success_erab_index < RRM_MAX_NUM_DRB_PER_UE));
            success_erab_index++)
    {
        /* Start release PRB data per UE basis */
        qci = p_rrm_ue_erab_success_list->erab_item[success_erab_index].erab_level_qos_params.qci;
        if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "UE_ID[%d]:Processing erb_id[%d]",
                    p_ue_context->ue_index,
                    p_rrm_ue_erab_success_list->erab_item[success_erab_index].erab_id);

            dl_bitrate = p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
                         erab_level_qos_params.\
                         gbr_qos_info.erab_guar_bit_rate_dl;
            ul_bitrate = p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
                         erab_level_qos_params.\
                         gbr_qos_info.erab_guar_bit_rate_ul;

            rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, dl_bitrate);
            rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, ul_bitrate);
            dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,dl_bitrate); 
            ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,ul_bitrate); 
            rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
            rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
        }
	}
    RRM_UT_TRACE_EXIT();
}
/*SPR 22151 Fix End*/

/*SPR 19819 START*/
/****************************************************************************
 * Function Name  : rrm_ue_clean_rab_resrc_at_ho_adm_cnf_failure
 * Inputs         : rrm_ue_context_t *p_ue_context
 * Outputs        : None
 * Returns        : Void 
 * Description    : If ho_admission confirmation is received 
 *                  with Error ERAB list.
 ****************************************************************************/
rrm_void_t
rrm_ue_clean_rab_resrc_at_ho_adm_cnf_failure
(
    rrm_ue_context_t                *p_ue_context,
    rrm_ue_proc_ho_adm_cnf_data_t 	*p_rrm_ue_proc_ho_cnf_data, 
    rrm_ue_erab_setup_item_list_t 	*p_rrm_ue_erab_success_list
)
{
    U8                              qci = RRM_ZERO;
    /*SPR 22151 Fix Start*/
    rrm_prb_t                       dl_prbs_to_release = RRM_ZERO;
    rrm_prb_t                       ul_prbs_to_release = RRM_ZERO;
    /*SPR 22151 Fix End*/
    U64                             dl_bitrate = RRM_ZERO;
    U64                             ul_bitrate = RRM_ZERO;
    U8                              fail_erab_index = RRM_ZERO;
    U8                              success_erab_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for (fail_erab_index = RRM_ZERO;
            ((fail_erab_index < p_rrm_ue_proc_ho_cnf_data->erab_failed_item_list.count) &&
             (fail_erab_index < RRM_UE_MAX_ERB_COUNT));
            fail_erab_index++)
    {
        for(success_erab_index = RRM_ZERO;
                ((success_erab_index < p_rrm_ue_erab_success_list->num_of_list) && 
                 (success_erab_index < RRM_MAX_NUM_DRB_PER_UE));
                success_erab_index++)
        {
            if(p_rrm_ue_proc_ho_cnf_data->erab_failed_item_list.erab_id[fail_erab_index] == 
                    p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
                    erab_id)
            {
                /* Start release PRB data per UE basis */
                qci = p_rrm_ue_erab_success_list->erab_item[success_erab_index].erab_level_qos_params.qci;
                if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UE_ID[%d]:Processing erb_id[%d]",
                            p_ue_context->ue_index,
                            p_rrm_ue_erab_success_list->erab_item[success_erab_index].erab_id);

                    dl_bitrate = p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
                                 erab_level_qos_params.\
                                 gbr_qos_info.erab_guar_bit_rate_dl;
                    ul_bitrate = p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
                                 erab_level_qos_params.\
                                 gbr_qos_info.erab_guar_bit_rate_ul;

                    rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, dl_bitrate);
                    rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, ul_bitrate);
                    /*SPR 22151 Fix Start*/
                    dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,dl_bitrate); 
                    ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,ul_bitrate); 
                    /*SPR 22151 Fix End*/
                    rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
                    rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
                    break;
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_ue_clean_prb_usage_proc_data_at_cnf_failure 
 * Inputs         : rrm_ue_context_t *p_ue_context
 * Outputs        : None
 * Returns        : Void 
 * Description    : If erab setup/modify confirmation is received 
 *                  with Error ERAB list.
 ****************************************************************************/
rrm_void_t
rrm_ue_clean_prb_usage_proc_data_at_cnf_failure
(
    rrm_ue_context_t                *p_ue_context,
    rrm_ue_proc_erab_cnf_data_t 	*p_rrm_ue_proc_erab_cnf_data, 
    rrm_ue_erab_setup_item_list_t 	*p_rrm_ue_erab_success_list,
    rrm_erab_procedure_et            rrm_erab_procedure
)
{
    U8                              qci = RRM_ZERO;
    /*SPR 22151 Fix Start*/
    rrm_prb_t                       dl_prbs_to_release = RRM_ZERO;
    rrm_prb_t                       ul_prbs_to_release = RRM_ZERO;
    /*SPR 22151 Fix End*/
    U64                             dl_bitrate = RRM_ZERO;
    U64                             ul_bitrate = RRM_ZERO;
    U64                             diff_dl_bitrate = RRM_ZERO;
    U64                             diff_ul_bitrate = RRM_ZERO;
    U64                             prev_dl_bitrate = RRM_ZERO;
    U64                             prev_ul_bitrate = RRM_ZERO;
    U8                              fail_erab_index = RRM_ZERO;
    U8                              drb_configured_index = RRM_ZERO;
    U8                              success_erab_index = RRM_ZERO;
    /*SPR 22151 Fix Start*/
    /*SPR 19968 Fix code deleted*/
    /*SPR 22151 Fix End*/
   /*SPR 22036 Fix Start*/
    rrm_cell_context_t *p_cell_context = rrm_cellm_get_cell_context (p_ue_context->cell_index);
    /*SPR 22036 Fix Stop*/

    RRM_UT_TRACE_ENTER();
    /* SPR 22310 CID 115901 Fix Start */
    if(RRM_PNULL != p_cell_context)
    {
	    for (fail_erab_index = RRM_NULL;
			    ((fail_erab_index < p_rrm_ue_proc_erab_cnf_data->erab_error_list.erab_count) &&
			     (fail_erab_index < RRM_UE_MAX_ERB_COUNT));
			    fail_erab_index++)
	    {
		    for(success_erab_index = RRM_NULL;
				    ((success_erab_index < p_rrm_ue_erab_success_list->num_of_list) && 
				     (success_erab_index < RRM_MAX_NUM_DRB_PER_UE));
				    success_erab_index++)
		    {
			    if(p_rrm_ue_proc_erab_cnf_data->erab_error_list.\
					    erab_error_info[fail_erab_index].erab_id == 
					    p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
					    erab_id)
			    {
				    /* Start release PRB data per UE basis */
				    qci = p_rrm_ue_erab_success_list->erab_item[success_erab_index].erab_level_qos_params.qci;
				    if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
				    {
					    dl_bitrate = p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
							 erab_level_qos_params.\
							 gbr_qos_info.erab_guar_bit_rate_dl;
					    ul_bitrate = p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
							 erab_level_qos_params.\
							 gbr_qos_info.erab_guar_bit_rate_ul;
					    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							    "UE_ID[%d]:Processing erb_id[%d] for erab_setup_procedure",
							    p_ue_context->ue_index,
							    p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
							    erab_id);
					    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							    "dl_bitrate =[%llu],ul_bitrate =[%llu]",
							    dl_bitrate,ul_bitrate);

					    switch(rrm_erab_procedure)
					    {
						    case ERAB_SETUP :
							    { 
								    rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, dl_bitrate);
								    rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, ul_bitrate);

                                /*SPR 22151 Fix Start*/
                                /*SPR 19968 Fix code deleted*/
                                dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,dl_bitrate); 
                                ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,ul_bitrate); 
								    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
										    "[UE:%d]:erb_id[%d] Deallocating dl_gbr_prbs(%d)",
										    p_ue_context->ue_index,
										    p_rrm_ue_erab_success_list->erab_item[success_erab_index].erab_id,
										    dl_prbs_to_release);
                                /*SPR 22151 Fix End*/
								    rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
								    rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
							    }
							    break;

						    case ERAB_MODIFY:
							    {
								    for(drb_configured_index = RRM_ZERO;
										    drb_configured_index < p_ue_context->drb_configured.num_of_list;
										    drb_configured_index++)
								    {
									    if( p_rrm_ue_erab_success_list->erab_item[success_erab_index].\
											    erab_id == p_ue_context->drb_configured.erab_item[drb_configured_index].erab_id)
									    {
										    prev_dl_bitrate = p_ue_context->drb_configured.erab_item[drb_configured_index].erab_level_qos_params.\
												      gbr_qos_info.erab_guar_bit_rate_dl;
										    prev_ul_bitrate = p_ue_context->drb_configured.erab_item[drb_configured_index].erab_level_qos_params.\
												      gbr_qos_info.erab_guar_bit_rate_ul;
										    break;
									    }
								    }     
								    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
										    "prev_dl_bitrate =[%llu],dl_bitrate = [%llu],prev_ul_bitrate[%llu],ul_bitrate =[%llu] ",
										    prev_dl_bitrate,dl_bitrate,prev_ul_bitrate,ul_bitrate);

								    if(prev_dl_bitrate > dl_bitrate)
								    {
									    diff_dl_bitrate = prev_dl_bitrate - dl_bitrate;

									    rrm_cellm_set_used_dl_bitrate_during_erb_setup_modify(p_ue_context->cell_index,diff_dl_bitrate);

								    }
								    else if(prev_dl_bitrate < dl_bitrate)
								    {
									    diff_dl_bitrate = dl_bitrate - prev_dl_bitrate;

									    rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, diff_dl_bitrate);
									    /*SPR 22036 Fix Start*/
                                    					    /*SPR 22151 Fix Start*/
				                                    	    dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,diff_dl_bitrate); 

					                                    /*SPR 22151 Fix End*/

									    /*SPR 22036 Fix Stop*/

									    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
											    "dl_prbs_to_release = [%u]",dl_prbs_to_release);
									    rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
								    }
								    else
								    {
									    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
											    "dl_birate_value is not modified");
								    }
								    if(prev_ul_bitrate > ul_bitrate)
								    {
									    diff_ul_bitrate = prev_ul_bitrate - ul_bitrate;
									    rrm_cellm_set_used_ul_bitrate_during_erb_setup_modify(p_ue_context->cell_index,diff_ul_bitrate);
								    }
								    else if(prev_ul_bitrate < ul_bitrate)
								    {
									    diff_ul_bitrate = ul_bitrate - prev_ul_bitrate;

									    rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, diff_ul_bitrate);
									    /*SPR 22036 Fix Start*/
                                    				            /*SPR 22151 Fix Start*/
				                                	    ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,diff_ul_bitrate); 
                        					            /*SPR 22151 Fix End*/

									    /*SPR 22036 Fix Start*/
									    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
											    "ul_prbs_to_release = [%u]",ul_prbs_to_release);
									    rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
								    }
								    else
								    {
									    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
											    "ul_birate_value is not modified");
								    }
							    }
							    break;
						    default :
							    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
									    "Incorrect procecudre");
							    return;
					    }    
					    break;
				    }
			    }
		    }
	    }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_cell_context is NULL");
    }
    /* SPR 22310 CID 115901 Fix End */
    RRM_UT_TRACE_EXIT();
}
/*SPR 19819 END*/
/*LTE_RRM_KLOCWORK_WARN_9_JULY_END*/

#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/ 
/****************************************************************************
 * Function Name  : rrm_check_is_endc_x2ap_link_established 
 * Inputs         : Npde 
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Check if any ENDC X2AP link is established.
 ****************************************************************************/
rrm_bool_et rrm_check_is_endc_x2ap_link_established()
{
    rrm_bool_et         result = RRM_FALSE;
    YLNODE              *p_node = RRM_PNULL;
	rrm_x2ap_enb_node_t *p_x2ap_enb_node = RRM_PNULL;

    p_node = ylFirst(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));
    while(p_node)
    {
        p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;

        if(p_x2ap_enb_node->link_up_data.bitmask &
                RRM_NR_CELL_INFO_PRESENT)
        {
            result = RRM_TRUE;
            break;
        }
        p_node = ylNext(p_node);
    }

    return result;
}
/*NR_DC Code Change Stop*/

/* MENB_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME: rrm_check_is_sgnb_beaer_required
 *   INPUT        : p_cell_context
 *   OUTPUT       : is sgnb bearer
 *   DESCRIPTION  : return if qci need to configure SGNB bearere 
 *   RETURNS      : Check if band of MeNB matched with bands receieved in UE
 *                  MRDC capability
 ******************************************************************************/
rrm_bool_et
rrm_check_is_sgnb_beaer_required(
rrm_cell_context_t       *p_cell_context,
U8                       qci)
{
 U8 index = RRM_ZERO;
/* coverity_277505_fix_start */
   for(index = RRM_ZERO;index < RRM_MAX_QCI;index++)
   {
       if(qci == p_cell_context->epc_info.epc_params.qos_config_params[index].qci)
       {
           return p_cell_context->epc_info.epc_params.qos_config_params[index].sgnb_bearer_required;
       }
   }
   /* coverity_277505_fix_end */
   return RRM_FALSE;
}
/* NR_BAND_FIX_START */
rrm_bool_et 
check_ue_freq_ind_supported_by_default_sgnb
(
    U64                       nr_band_bitmap_fdd[],
    rrm_ue_index_t              ue_index 
)
{
    rrm_bool_et         result        = RRM_FALSE;
    YLNODE                *p_node           = RRM_PNULL;
    rrm_x2ap_enb_node_t       *p_x2ap_enb_node  = RRM_PNULL;
    rrm_x2ap_srvd_nr_cell_info_t *p_rrm_x2ap_srvd_nr_cell_info = RRM_PNULL;
    rrm_freq_band_nr_info_t      *p_rrm_freq_band_nr_info = RRM_PNULL;
    U16         cell_count = RRM_ZERO;
    U16         freq_count = RRM_ZERO;
    U64        freq_band_bitmask = RRM_ZERO;
    U16        freq_ind_nr = RRM_ZERO;
    U16        freq_band_arr_index = RRM_ZERO;

    p_node = ylFirst(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));

    while(p_node)
    {
        p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;
        if(p_x2ap_enb_node && (p_x2ap_enb_node->link_up_data.bitmask & RRM_NR_CELL_INFO_PRESENT))
        {
            if( RRM_TRUE == p_x2ap_enb_node->link_up_data.nr_cell_info.default_sgnb)
            {
               RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                         "Default Sgnb whose freq band ind is to be verified is [%d][%d][%d][%d] \n",
                         p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.gNB_id[RRM_ZERO],
                         p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.gNB_id[RRM_ONE],
                         p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.gNB_id[RRM_TWO],
                         p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.gNB_id[RRM_THREE]);
                break;
            }
        }
        p_x2ap_enb_node = NULL;
        p_node = ylNext(p_node);
    }

    if(p_x2ap_enb_node != NULL)
    {
        for(cell_count = RRM_ZERO;
                (cell_count < MAX_CELL_REPORT )&&
                ( cell_count < p_x2ap_enb_node->link_up_data.nr_cell_info.\
                  num_served_nr_cell);
                cell_count++)
        {
            p_rrm_x2ap_srvd_nr_cell_info =
                &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                        cell_info[cell_count].served_cell_info);

            if(p_rrm_x2ap_srvd_nr_cell_info->choice_nr_mode.bitmask &
                    RRM_X2AP_NR_MODE_FDD_PRESENT)
            {
                for(freq_count = 0;
                        freq_count < p_rrm_x2ap_srvd_nr_cell_info->choice_nr_mode.fdd_info.
                        nr_dl_freq_info.num_freq_nr;
                        freq_count++)
                {
                    p_rrm_freq_band_nr_info = &p_rrm_x2ap_srvd_nr_cell_info->choice_nr_mode.fdd_info.
                        nr_dl_freq_info.freq_band_nr_info[freq_count];

                    freq_ind_nr = p_rrm_freq_band_nr_info->freq_band_indicator_nr;
                    freq_band_bitmask |= (1<<(freq_ind_nr-1));

                    freq_band_arr_index = freq_ind_nr / (sizeof(U64) * 8);
                    
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "DL Freq band of SgNB Cell[%d] is [%u]",cell_count,freq_ind_nr);

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "Freq band indicator of UE [%d] is:%u",
                                ue_index,nr_band_bitmap_fdd[freq_band_arr_index]);
                    if(nr_band_bitmap_fdd[freq_band_arr_index] & freq_band_bitmask)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "Freq band is matched with UE supported freq Band \n");
                        return RRM_TRUE; 
                    }
                    freq_band_bitmask = RRM_ZERO;
                }
            }
        }
    }
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "None of the Frequemcy bands is matched with the UE supported freq Band");
    return result;
/* NR_BAND_FIX_END */
}
/******************************************************************************
 *   FUNCTION NAME: rrm_check_frequancy_band
 *   INPUT        : p_rrm_ue_context
 *   OUTPUT       : p_rrm_ue_context
 *   DESCRIPTION  : Fills the allowedBC-ListMRDC in RRM UE context
 *   RETURNS      : Check if band of MeNB matched with bands receieved in UE
 *                  MRDC capability
 ******************************************************************************/
rrm_bool_et
rrm_check_frequancy_band
(
    rrm_ue_context_t              *p_rrm_ue_context
)
{
    rrm_bool_et         result        = RRM_FALSE;
    U8                  band_count    = RRM_ZERO;
    U8                  nr_band_count = RRM_ZERO;
    U8                  nr_count      = RRM_ZERO;

    rrm_rf_parameters_mrdc_t     *p_rf_parameters_mrdc = RRM_NULL;
    rrm_band_combination_band_list_t *p_band_combination_list = RRM_NULL;

    if ( RRM_UE_EUTRA_NR_RADIO_CAPABILITY_PRESENT &
        p_rrm_ue_context->ue_capability_params.bitmask )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "EUTRA NR Radio capabiltity is present");

        p_rf_parameters_mrdc = &(p_rrm_ue_context->ue_capability_params.
                rrm_eutra_nr_radio_capability_info.rf_parameters_mrdc);

        if ( RRM_RF_PARAMETERS_MRDC_SUPPORTED_BAND_COMB_LIST_PRESENT &
            p_rf_parameters_mrdc->bitmask )
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "EUTRA NR Radio capabiltity RF Parameetrs MRDC is present");

            for ( band_count = RRM_ZERO; band_count <
                p_rf_parameters_mrdc->supported_band_comb_list.count;
                    band_count++ )
            {
                p_band_combination_list = &(p_rf_parameters_mrdc->supported_band_comb_list.
                    band_combination_list[band_count].band_combination_band_list);

                if ( RRM_TWO == p_band_combination_list->count )
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "EUTRA band combination count is two in MRDC capability");

                    for ( nr_band_count = RRM_ZERO; nr_band_count <
                        p_band_combination_list->count; nr_band_count++ )
                    {
                        if ( RRM_BAND_PARAMETERS_EUTRA_PRESENT &
                            p_band_combination_list->band_list[nr_band_count].bitmask )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "EUTRA band parameters is present in MRDC capability");

                            rrm_cell_context_t       *p_cell_context = RRM_PNULL;
                            p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);

                            /*coverity_254836_fix_start*/
                            if (RRM_PNULL != p_cell_context)
                            {
                            if ( p_band_combination_list->band_list[nr_band_count].
                                    eutra.band_eutra ==
                                p_cell_context->ran_info.rf_params.rf_configurations.
                                    frequency_band_indicator )
                            {
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                   "EUTRA band parameters matched with band present in MRDC capability");

                                nr_count = p_rrm_ue_context->allowed_bc_list_mrdc.
                                    band_comb_count;

                                p_rrm_ue_context->allowed_bc_list_mrdc.
                                    band_comb_index[nr_count] = band_count + RRM_ONE;

                                p_rrm_ue_context->allowed_bc_list_mrdc.
                                    band_comb_count++;

                                result = RRM_TRUE;
                            }
                        }
                            else
                            {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                            "p_cell_context is null in rrm_check_frequancy_band");
                            }
                            /*coverity_254836_fix_end*/
                        }
                    }
                }
            }
        }
    }
    return result;
}
 
/****************************************************************************
 * Function Name  : rrm_check_is_ue_support_endc 
 * Inputs         : Npde 
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Check if UE supports ENDC.
 ****************************************************************************/
rrm_bool_et rrm_check_is_ue_support_endc
(
    rrm_ue_context_t    *p_ue_context
)
{
    rrm_bool_et         result = RRM_FALSE;
    rrm_ue_eutra_capability_v1330_ies_t    *p_ue_eutra_capability_v1330 = RRM_PNULL;
    rrm_ue_eutra_capability_v1430_ies_t    *p_ue_eutra_capability_v1430 = RRM_PNULL;
    RrmUeEutraCapabilityEndcParamaters_t   *p_ue_eutra_capability_endc_paramaters = RRM_PNULL;

    if ( RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT &
        p_ue_context->ue_capability_params.bitmask )
    {
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE EUTRA radio capability is present");

        if ( RRM_UE_EUTRA_CAPABILITY_V1310_IES_PRESENT &
            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "UE EUTRA radio capability v1310 is present");

            if ( RRM_UE_EUTRA_CAPABILITY_v1320_IES_PRESENT &
                    p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v1310_ies.bitmask )
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UE EUTRA radio capability v1320 is present");

                if ( RRM_UE_EUTRA_CAPABILITY_v1330_IES_PRESENT &
                        p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v1310_ies.ue_eutra_capability_v1320_ies.bitmask )
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UE EUTRA radio capability v1330 is present");

                    p_ue_eutra_capability_v1330 = &(p_ue_context->ue_capability_params.
                            rrm_eutra_radio_capability_info.ue_eutra_capability_v1310_ies.
                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies);

                    if ( RRM_UE_EUTRA_CAPABILITY_v1340_IES_PRESENT &
                            p_ue_eutra_capability_v1330->bitmask )
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UE EUTRA radio capability v1340 is present");

                        if ( RRM_UE_EUTRA_CAPABILITY_v1350_IES_PRESENT &
                                p_ue_eutra_capability_v1330->ue_eutra_capability_v1340_ies.bitmask )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "UE EUTRA radio capability v1350 is present");

                            if ( RRM_UE_EUTRA_CAPABILITY_v1360_IES_PRESENT &
                                    p_ue_eutra_capability_v1330->ue_eutra_capability_v1340_ies.
                                    ue_eutra_capability_v1350_ies.bitmask )
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE EUTRA radio capability v1360 is present");

                                if ( RRM_UE_EUTRA_CAPABILITY_v1430_IES_PRESENT &
                                        p_ue_eutra_capability_v1330->ue_eutra_capability_v1340_ies.
                                        ue_eutra_capability_v1350_ies.ue_eutra_capability_v1360_ies.
                                        bitmask )
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "UE EUTRA radio capability v1430 is present");

                                    p_ue_eutra_capability_v1430 = &(p_ue_eutra_capability_v1330->
                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                            ue_eutra_capability_v1360_ies.ue_eutra_capability_v1430_ies);

                                    if ( RRM_UE_EUTRA_CAPABILITY_v1440_IES_PRESENT &
                                            p_ue_eutra_capability_v1430->bitmask )
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                            "UE EUTRA radio capability v1440 is present");

                                        if ( RRM_UE_EUTRA_CAPABILITY_v1450_IES_PRESENT &
                                                p_ue_eutra_capability_v1430->ue_eutra_capability_v1440_ies.
                                                bitmask )
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                "UE EUTRA radio capability v1450 is present");

                                            if ( RRM_UE_EUTRA_CAPABILITY_v1460_IES_PRESENT &
                                                    p_ue_eutra_capability_v1430->ue_eutra_capability_v1440_ies.
                                                    ue_eutra_capability_v1450_ies.bitmask )
                                            {
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                    "UE EUTRA radio capability v1460 is present");

                                                if ( RRM_UE_EUTRA_CAPABILITY_v1510_IES_PRESENT &
                                                        p_ue_eutra_capability_v1430->ue_eutra_capability_v1440_ies.
                                                        ue_eutra_capability_v1450_ies.ue_eutra_capability_v1460_ies.
                                                        bitmask )
                                                {
                                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                        "UE EUTRA radio capability v1510 is present");

                                                    if ( RRM_UE_EUTRA_CAPABILITY_ENDC_PARAMETERS_R15_PRESENT &
                                                            p_ue_eutra_capability_v1430->ue_eutra_capability_v1440_ies.
                                                            ue_eutra_capability_v1450_ies.ue_eutra_capability_v1460_ies.
                                                            ue_eutra_capability_v1510_ies.bitmask )
                                                    {
                                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                            "UE EUTRA radio capability ENDC R15 is present");

                                                        p_ue_eutra_capability_endc_paramaters =
                                                            &(p_ue_eutra_capability_v1430->
                                                                    ue_eutra_capability_v1440_ies.
                                                                    ue_eutra_capability_v1450_ies.
                                                                    ue_eutra_capability_v1460_ies.
                                                                    ue_eutra_capability_v1510_ies.endcParameters);
                                                        if ( RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_NR_R15_PRESENT &
                                                                p_ue_eutra_capability_endc_paramaters->bitmask )
                                                        {
                                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                "UE EUTRA radio capability Irat Params NR is present");

                                                            if ( RRM_UE_EUTRA_CAPABILITY_EN_DC_R15_PRESENT &
                                                                    p_ue_eutra_capability_endc_paramaters->
                                                                    iratParametersNrR15.bitmask )
                                                            {
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "UE EUTRA radio capability EN DC R15 is present");

                                                                if ( RRM_ONE == p_ue_eutra_capability_endc_paramaters->
                                                                        iratParametersNrR15.enDcR15Supported )
                                                                {
                                                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                        "UE EUTRA radio capability EN DC R15 is one");

                                                                    result = RRM_TRUE;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return result;
}

/****************************************************************************
 * Function Name  : rrm_check_if_ue_has_dc_bearer 
 * Inputs         : Npde 
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Check if UE has any bearer having SN_TERMINATED_SCG_BEARER.
 ****************************************************************************/
rrm_bool_et rrm_check_if_ue_has_dc_bearer 
(
    rrm_ue_context_t    *p_ue_context
)
{
    rrm_bool_et         result      = RRM_FALSE;
    U8                  erab_count  = RRM_ZERO;

    for(erab_count = RRM_ZERO; 
            erab_count < p_ue_context->drb_configured.num_of_list; 
            erab_count++)
    {
        if( DRB_TYPE_SN_TERMINATED_SCG ==
                p_ue_context->drb_configured.erab_item[erab_count].drb_type)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ERAB_ID[%d] with DRB ID[%d] is already SN_TERMINATED_SCG_BEARER "
                    "for UE[%d]", p_ue_context->drb_configured.erab_item[erab_count].erab_id,
                    p_ue_context->drb_configured.erab_item[erab_count].drb_id,
                    p_ue_context->ue_index);

            result = RRM_TRUE;
            break;
        }
/* OPTION3X Changes Start */
        else if( DRB_TYPE_SN_TERMINATED_SPLIT ==
                p_ue_context->drb_configured.erab_item[erab_count].drb_type)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ERAB_ID[%d] with DRB ID[%d] is already SN_TERMINATED_SPLIT_BEARER "
                    "for UE[%d]", p_ue_context->drb_configured.erab_item[erab_count].erab_id,
                    p_ue_context->drb_configured.erab_item[erab_count].drb_id,
                    p_ue_context->ue_index);

            result = RRM_TRUE;
            break;
        }
/* OPTION3X Changes End */
    }
    return result;
}
/****************************************************************************
 * Function Name  : rrm_check_if_ue_has_dc_split_bearer 
 * Inputs         : Npde 
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Check if UE has any bearer having SN_TERMINATED_SCG_BEARER.
 ****************************************************************************/
rrm_bool_et rrm_check_if_ue_has_dc_split_bearer 
(
    rrm_ue_context_t    *p_ue_context
)
{
    rrm_bool_et         result      = RRM_FALSE;
    U8                  erab_count  = RRM_ZERO;

    for(erab_count = RRM_ZERO; 
            erab_count < p_ue_context->drb_configured.num_of_list; 
            erab_count++)
    {
/* OPTION3X Changes Start */
        if( DRB_TYPE_SN_TERMINATED_SPLIT ==
                p_ue_context->drb_configured.erab_item[erab_count].drb_type)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ERAB_ID[%d] with DRB ID[%d] is already SN_TERMINATED_SPLIT_BEARER "
                    "for UE[%d]", p_ue_context->drb_configured.erab_item[erab_count].erab_id,
                    p_ue_context->drb_configured.erab_item[erab_count].drb_id,
                    p_ue_context->ue_index);

            result = RRM_TRUE;
            break;
        }
/* OPTION3X Changes End */
    }
    return result;
}
/* MENB_CHANGES_END */
/* OPTION3X Changes Start */
/****************************************************************************
 * Function Name  : rrm_ue_get_new_lc_id_for_bearer_change
 * Inputs         : rrm_ue_context_t, rrm_ue_erab_setup_item_t
 * Outputs        : None
 * Returns        : Success/Failure
 * Description    : Assign new lc_id for existing erab
 ***************************************************************************/
rrm_return_et
rrm_ue_get_new_lc_id_for_bearer_change(
        rrm_ue_context_t           *p_ue_context,
        rrm_ue_erab_setup_item_t   *p_erab_item
        )
{
    rrm_return_et           ret_val = RRM_FAILURE;
    U8                      lc_id_list[MAX_LC_ID_INDEX]=RRM_MAX_DEFAULT_LCID_VALUES;         /*{3,4,5,6,7,8,9,10};*/
    U8                      lc_id_index = RRM_NULL;
    U8                      drb_configured_index = RRM_NULL;
    rrm_bool_et 			non_configured_lc_id = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    for( lc_id_index = RRM_NULL; lc_id_index < MAX_LC_ID_INDEX; 
            lc_id_index++ )
    {
        non_configured_lc_id = RRM_TRUE;
        for ( drb_configured_index = RRM_NULL;
                drb_configured_index < p_ue_context->drb_configured.
                num_of_list;
                drb_configured_index++ )
        {
            if ( (p_ue_context->drb_configured.
                    erab_item[drb_configured_index].lc_id ==
                    lc_id_list[lc_id_index]) ||
                   ((p_ue_context->drb_configured.erab_item[drb_configured_index].new_lc_id != 0xFF) &&
                    (p_ue_context->drb_configured.erab_item[drb_configured_index].new_lc_id ==
                   lc_id_list[lc_id_index]))
               )
            {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "can't Assign NEW_LC_ID[%d] for ERAB_ID[%d] DRB_ID[%d] OLD_LC_ID[%d]",
                    p_erab_item->new_lc_id,
                    p_erab_item->erab_id, p_erab_item->drb_id, p_erab_item->lc_id);
                non_configured_lc_id = RRM_FALSE;
                break;
            }
        }

        if (RRM_TRUE == non_configured_lc_id)
        {
            p_erab_item->new_lc_id = lc_id_list[lc_id_index];

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "Assigning NEW_LC_ID[%d] for ERAB_ID[%d] DRB_ID[%d] OLD_LC_ID[%d]",
                    p_erab_item->new_lc_id,
                    p_erab_item->erab_id, p_erab_item->drb_id, p_erab_item->lc_id);
            ret_val = RRM_SUCCESS;

            break;
        }

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*DRB_ID_CHANGE START*/
/****************************************************************************
 * Function Name  : rrm_ue_get_new_drb_id_for_bearer_change
 * Inputs         : rrm_ue_context_t, rrm_ue_erab_setup_item_t
 * Outputs        : None
 * Returns        : Success/Failure
 * Description    : Assign new drb_id for existing erab
 ***************************************************************************/
rrm_return_et
rrm_ue_get_new_drb_id_for_bearer_change(
        rrm_ue_context_t           *p_ue_context,
        rrm_ue_erab_setup_item_t   *p_erab_item
        )
{
    rrm_return_et           ret_val = RRM_FAILURE;
    U8                      drb_id_list[RRM_MAX_DRB_ID_INDEX]= RRM_MAX_DEFAULT_DRB_ID_VALUES;
    U8                      drb_id_index = RRM_NULL;
    U8                      drb_configured_index = RRM_NULL;
    rrm_bool_et 			non_configured_drb_id = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    for( drb_id_index = RRM_NULL; drb_id_index < RRM_MAX_DRB_ID_INDEX; 
            drb_id_index++ )
    {
        non_configured_drb_id = RRM_TRUE;
        for ( drb_configured_index = RRM_NULL;
                drb_configured_index < p_ue_context->drb_configured.
                num_of_list;
                drb_configured_index++ )
        {
            if (( p_ue_context->drb_configured.
                        erab_item[drb_configured_index].drb_id ==
                        drb_id_list[drb_id_index]) ||
                    ((p_ue_context->drb_configured.erab_item[drb_configured_index].new_drb_id != RRM_ZERO) &&
                     (p_ue_context->drb_configured.erab_item[drb_configured_index].new_drb_id ==
                      drb_id_list[drb_id_index]))
               )
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                        "can't Assign NEW_DRB_ID[%d] for ERAB_ID[%d] OLD_DRB_ID[%d] ",
                        p_erab_item->new_drb_id,
                        p_erab_item->erab_id, p_erab_item->drb_id);
                non_configured_drb_id = RRM_FALSE;
                break;
            }
        }

        if (RRM_TRUE == non_configured_drb_id)
        {
            p_erab_item->new_drb_id = drb_id_list[drb_id_index];

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "Assigning NEW_DRB_ID[%d] for ERAB_ID[%d] OLD_DRB_ID[%d]", 
                    p_erab_item->new_drb_id,
                    p_erab_item->erab_id, p_erab_item->drb_id );
            ret_val = RRM_SUCCESS;

            break;
        }

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*DRB_ID_CHANGE STOP*/

/****************************************************************************
 * Function Name  : rrm_ue_handle_dc_bearer_change_cnf 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the dc_bearer_change_cnf message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_dc_bearer_change_cnf
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
	rrm_return_et					ret_val = RRM_SUCCESS;
	rrm_ue_context_t            	*p_ue_context = RRM_PNULL;
	rrm_ue_proc_dc_bearer_change_cnf_data_t
        *p_rrm_ue_proc_dc_bearer_change_cnf_data = RRM_PNULL;
	U8								cnf_index = RRM_NULL;
	U8								erab_index = RRM_NULL;
	U8								fail_erab_index = RRM_NULL;

	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	/** Store Update Configured DRBs list */
	if (p_ue_context != RRM_PNULL)
	{
		p_rrm_ue_proc_dc_bearer_change_cnf_data =
			(rrm_ue_proc_dc_bearer_change_cnf_data_t *)p_ue_context->current_procedure.
			p_proc_data;
		if(PNULL == p_rrm_ue_proc_dc_bearer_change_cnf_data)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"p_rrm_ue_proc_dc_bearer_change_cnf_data is NULL");
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}

		/** Change procedure state to RRM_UE_ERB_NULL */
		p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"p_rrm_ue_proc_dc_bearer_change_cnf_data->response [%d]",p_rrm_ue_proc_dc_bearer_change_cnf_data->response);
        if( RRM_ZERO != p_rrm_ue_proc_dc_bearer_change_cnf_data->response ) 
        {
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"RRM_ENDC_ENABLE_SUCCESSFUL\n");
            p_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_SUCCESSFUL; 
        }
        else
        {
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"RRM_ENDC_ENABLE_FAILED\n");
            p_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_FAILED; 
        }

        /* Update Configured DRBs list based on received Success List in DC Bearer Change CNF */
        if( p_rrm_ue_proc_dc_bearer_change_cnf_data->bitmask &
                RRM_UEM_DC_BEARER_CHANGE_CNF_ERAB_CNF_LIST_PRESENT)
        {
        for(cnf_index = RRM_NULL;
                (cnf_index < p_rrm_ue_proc_dc_bearer_change_cnf_data->erab_cnf_list.erab_count)
                && ( cnf_index < RRM_UE_MAX_ERB_COUNT);
                cnf_index++)
        {
            for(erab_index = RRM_NULL;
                    (erab_index < p_ue_context->drb_configured.num_of_list) 
                    && (erab_index < RRM_MAX_NUM_DRB_PER_UE);
                    erab_index++)
            {
                if(p_rrm_ue_proc_dc_bearer_change_cnf_data->erab_cnf_list.
                        erab_cnf_info[cnf_index].erab_id == 
                        p_ue_context->drb_configured.erab_item[erab_index].
                        erab_id 
                        &&
                        (
                         (
                          RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG & 
                          p_ue_context->drb_configured.erab_item[erab_index].
                          bitmask
                         ) &&  
                             ((DRB_TYPE_SN_TERMINATED_SPLIT ==
                         p_ue_context->drb_configured.erab_item[erab_index].
                             drb_type) || (DRB_TYPE_SN_TERMINATED_SCG == 
                            p_ue_context->drb_configured.erab_item[erab_index].drb_type))
                        )
                        &&
                        (RRM_ZERO != p_ue_context->drb_configured.erab_item[erab_index].
                        new_lc_id) 
                        &&
                        (RRM_ZERO != p_ue_context->drb_configured.erab_item[erab_index].
                         new_drb_id)
                  )
                {
                    /* Update the Stored LC_ID with the new LC_ID allocated for
                     * DC_BEARER_CHANGE Procedure.
                     */
                    p_ue_context->drb_configured.erab_item[erab_index].lc_id =
                        p_ue_context->drb_configured.erab_item[erab_index].new_lc_id;
                    
                    /* Reset New LC ID to RRM_ZERO do that no conflict with other update */
                    p_ue_context->drb_configured.erab_item[erab_index].new_lc_id = RRM_ZERO;
                    
                    /* Update the Stored DRB_ID with the new DRB_ID allocated for
                     * DC_BEARER_CHANGE Procedure.
                     */
                    p_ue_context->drb_configured.erab_item[erab_index].drb_id =
                        p_ue_context->drb_configured.erab_item[erab_index].new_drb_id;
                    
                    /* Reset New DRB ID to RRM_ZERO do that no conflict with other update */
                    p_ue_context->drb_configured.erab_item[erab_index].new_drb_id = RRM_ZERO;

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, 
                            "UE_INDEX[%d], Success for DC Bearer Change ERAB_ID[%d] LC_ID[%d]"
                            " DRBID[%d]",
                            p_ue_context->ue_index,
                            p_ue_context->drb_configured.erab_item[erab_index].erab_id,
                            p_ue_context->drb_configured.erab_item[erab_index].lc_id,
                            p_ue_context->drb_configured.erab_item[erab_index].drb_id
                            );
                            }
                }
            }
        }

        /* Update Configured DRBs list based on received failuer List in DC Bearer Change CNF */
        if( p_rrm_ue_proc_dc_bearer_change_cnf_data->bitmask &
                RRM_UEM_DC_BEARER_CHANGE_CNF_ERAB_ERROR_LIST_PRESENT)
        {
        for (fail_erab_index = RRM_ZERO;
                (fail_erab_index < p_rrm_ue_proc_dc_bearer_change_cnf_data->erab_error_list.erab_count)
                && (fail_erab_index < RRM_UE_MAX_ERB_COUNT);
                fail_erab_index++)
        {
            for(erab_index = RRM_NULL;
                    (erab_index < p_ue_context->drb_configured.num_of_list) 
                    && (erab_index < RRM_MAX_NUM_DRB_PER_UE);
                    erab_index++)
            {
                if(p_rrm_ue_proc_dc_bearer_change_cnf_data->erab_error_list.
                        erab_error_info[fail_erab_index].erab_id == 
                        p_ue_context->drb_configured.erab_item[erab_index].
                        erab_id 
                        &&
                        (
                         (
                          RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG & 
                          p_ue_context->drb_configured.erab_item[erab_index].
                          bitmask
                         ) &&  
                            ((DRB_TYPE_SN_TERMINATED_SPLIT ==
                         p_ue_context->drb_configured.erab_item[erab_index].
                             drb_type) || (DRB_TYPE_SN_TERMINATED_SCG == 
                            p_ue_context->drb_configured.erab_item[erab_index].drb_type))
                        )
                  )
                {
                    /* Failure for ERAB Received,
                     * Update the Stored New LC_ID to RRM_ZERO.
                     * Reset drb_type for ERAB_ID to RRM_ZERO.
                     * Unset Bitmask for DRB_TYPE
                     * DC_BEARER_CHANGE Procedure.
                     */
                    /*coverity_<277524>_fix_start*/
                    p_ue_context->drb_configured.erab_item[erab_index].drb_type = DRB_TYPE_INVALID;
                    /*coverity_<277524>_fix_end*/ 
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, 
                            "UE_INDEX[%d], Failure for DC Bearer Change for ERAB_ID[%d] \
                            OLD_LC_ID[%d] NEW_LC_ID[%d] OLD_DRB_ID[%d] NEW_DRB_ID[%d]",
                            p_ue_context->ue_index,
                            p_ue_context->drb_configured.erab_item[erab_index].erab_id,
                            p_ue_context->drb_configured.erab_item[erab_index].lc_id,
                            p_ue_context->drb_configured.erab_item[erab_index].new_lc_id, 
                            p_ue_context->drb_configured.erab_item[erab_index].drb_id,
                            p_ue_context->drb_configured.erab_item[erab_index].new_drb_id
                            );

                    /* Reset bitmask for DRB Type Present */
                    p_ue_context->drb_configured.erab_item[erab_index].bitmask &=
                        ~RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG;

                    /* Reset New LC ID to RRM_ZERO do that no conflict with other update */
                    p_ue_context->drb_configured.erab_item[erab_index].new_lc_id = RRM_ZERO;

                    /* Reset New DRB ID to RRM_ZERO do that no conflict with other update */
                    p_ue_context->drb_configured.erab_item[erab_index].new_drb_id = RRM_ZERO;

                    /* Reset drb_type  to RRM_ZERO */
                    /* coverity_<277524>_fix_start */
                    p_ue_context->drb_configured.erab_item[erab_index].drb_type = DRB_TYPE_INVALID;
                    /* coverity_<277524>_fix_end */
                    }

                }
            }
        }
    }
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"p_ue_context is equal to RRM_PNULL");
		ret_val = RRM_FAILURE;

    }

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* OPTION3X Changes End */
#endif

/****************************************************************************
 * Function Name  : rrm_ue_handle_erb_setup_cnf 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_setup_cnf message received from RRC.
 ****************************************************************************/
rrm_return_et
	rrm_ue_handle_erb_setup_cnf 
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
	rrm_return_et					ret_val = RRM_SUCCESS;
	U8								cnf_index = RRM_NULL;
	U8								success_index = RRM_NULL;
	rrm_ue_context_t            	*p_ue_context = RRM_PNULL;
	rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
	rrm_ue_proc_erab_cnf_data_t 	*p_rrm_ue_proc_erab_cnf_data = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t 	*p_rrm_ue_erab_success_list = RRM_PNULL;
	U8		                         erab_index = RRM_NULL;
	rrm_ue_erb_t			ue_erb = {RRM_ZERO};
	rrm_bool_et        is_ue_released = RRM_FALSE;
	U8                 sort_index = RRM_ZERO;
	U8								fail_erab_index = RRM_NULL;
	/* SPS related changes start */
	rrm_bool_et                     fail_sps_erab_found = RRM_FALSE;
	/* SPS related changes end */
	/*SPR 10329:start*/
	U8                               mme_id_index = RRM_ZERO;        
	/*SPR 10329:end*/
	/* Start fix for SPR 14987 */
	rrm_cell_context_t *p_cell_context = RRM_NULL;
	rrm_bool_et                     send_request_for_anr = RRM_FALSE; /* SPR17088 */
	/* End fix for SPR 14987 */
    /* SPR 18418 Fix Start */
    U8 index = RRM_ZERO;
    /* SPR 18418 Fix Stop */
    /* SPR 21367 Fix Start */
    U64                         ul_total_gbr_ue = RRM_ZERO;
    U64                         dl_total_gbr_ue = RRM_ZERO;
    /* SPR 21367 Fix End */
    #ifdef ENDC_ENABLED
    U8                          drb_list_count = RRM_ZERO;
    rrm_bool_et                 atleast_one_sn_rab = RRM_FALSE;
    #endif

	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	/** Srore ERAB success list */
	/* Coverity_fix_start_62538 */
	/*Coverity_fix_start_62521*/
	if (p_ue_context != RRM_PNULL)
	{
		p_rrm_ue_erab_success_list = 
			(rrm_ue_erab_setup_item_list_t *)p_ue_context->current_procedure.
			p_erb_success_list;
		/* SPR 16786 Fix Start */
		p_rrm_ue_proc_erab_cnf_data =
			(rrm_ue_proc_erab_cnf_data_t *)p_ue_context->current_procedure.
			p_proc_data;
		if(PNULL == p_rrm_ue_proc_erab_cnf_data)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"p_rrm_ue_proc_erab_cnf_data is NULL");
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		/* SPR 16786 Fix Stop */

		/** Change procedure state to RRM_UE_ERB_NULL */
		p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
		/* CS-Fallback Feature */
		if(p_ue_context->ue_context_mod_req.bitmask & RRM_UEM_CTX_CSF_INDICATOR_PRESENT)
		{

            /*SPR 22553 FIXED START*/
            if(p_ue_context->rrm_sub_profile_id_info.bitmask & RRM_UEM_CTX_TRANSE_PID_PRESENT )
            {    
                p_ue_context->rrm_sub_profile_id_info.sub_profile_id = p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id;
                p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = RRM_ZERO;
                p_ue_context->rrm_sub_profile_id_info.bitmask &= ~RRM_UEM_CTX_TRANSE_PID_PRESENT; 
            }
            /*SPR 22553 FIXED END*/

			/* SPR 15441 start */    
			/* code removed */
			/* SPR 15441 start */    
			/*LTE_RRM_KLOCWORK_WARN_9_JULY_START*/
			ret_val = rrm_ue_handle_cs_fallback(p_g_rrm_ue_ctx,&is_ue_released);
			/*LTE_RRM_KLOCWORK_WARN_9_JULY_END*/
		}
		else
		{
			/* SPR 16786 Fix Start */
			//Code Removed
			/* SPR 16786 Fix Stop */
			/* Transmission mode  related change start */
			if( p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count )
			{
				/* this report count is set to zero for UE mac reports. because
				   decision has been taken for transmission mode on the base
				   of existing samples of UE mac stats. and ue reconfig should
				   be sent when fresh next set of data are available at UE.
				   this report count is set to zero to limit the ue reconfig
				   request for transmission mode switching only. when erb 
				   response goes then decision is taken of the basis of existing UE
				   mac reports.  */
                          /* SPR 21496 Fix Start */ 
                          p_ue_context->p_ue_mac_report->report_count = RRM_ZERO;
                          /* SPR 21496 Fix End */ 
#ifdef ENDC_ENABLED
                if( RRM_NR_MEAS_REQ_FILLED == p_ue_context->rrm_endc_nr_data.\
                    rrm_endc_nr_meas_stats.nr_meas_req_status )
                {
                    p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_stats.\
                        nr_meas_req_status = RRM_NR_MEAS_REQ_INITIATED;
                }
#endif
			}
			/* Transmission mode related change end */

			/* Start fix for SPR 14987 */
			if ((RRM_ZERO == p_ue_context->drb_configured.num_of_list) && (RRM_ZERO != p_rrm_ue_erab_success_list->num_of_list))
			{
				/* This is for the first time when UE is attaching */
                /* coverity_88391 start */
				send_request_for_anr = RRM_TRUE; /* SPR 17088 */
                /*SPR 22553 FIXED START*/
                if(p_ue_context->rrm_sub_profile_id_info.bitmask & RRM_UEM_CTX_TRANSE_PID_PRESENT )
                {    
                    p_ue_context->rrm_sub_profile_id_info.sub_profile_id = p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id;
                    p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = RRM_ZERO;
                    p_ue_context->rrm_sub_profile_id_info.bitmask &= ~RRM_UEM_CTX_TRANSE_PID_PRESENT; 
                }
                /*SPR 22553 FIXED END*/

                /* coverity_88391 stop */
			}
			/* End fix for SPR 14987 */
			for(cnf_index = RRM_NULL;
					/*CID 55001:start*/
					(cnf_index < p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count)
					&& ( cnf_index < RRM_UE_MAX_ERB_COUNT);
					/*CID 55001:end*/
					cnf_index++)
			{
				for(success_index = RRM_NULL;
						(success_index < p_rrm_ue_erab_success_list->num_of_list) 
						/* Coverity 21oct Start : 55001 */
						&& (success_index < RRM_MAX_NUM_DRB_PER_UE);
						/* Coverity 21oct End : 55001 */
						success_index++)
				{
					/* BUG_FIX_837_START */
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, 
							"Success RABs In Question:- RabId(%d), Rab Id in Success List(%d)",
							p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_cnf_info[cnf_index].erab_id,
							p_rrm_ue_erab_success_list->erab_item[success_index].erab_id);
					/* BUG_FIX_837_END */
					if(p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.
							erab_cnf_info[cnf_index].erab_id == 
							p_rrm_ue_erab_success_list->erab_item[success_index].
							erab_id)
					{
						/* BUG_FIX_837_START */
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, 
								"RabId(%d), UE Context->DRB Confugured->NumList(%d)",
								p_rrm_ue_erab_success_list->erab_item[success_index].erab_id, 
								p_ue_context->drb_configured.num_of_list);
						/* BUG_FIX_837_END */
						RRM_MEMCPY(&p_ue_context->drb_configured.
								erab_item[p_ue_context->drb_configured.num_of_list],
								&p_rrm_ue_erab_success_list->erab_item[success_index] ,
								sizeof(rrm_ue_erab_setup_item_t));
						p_ue_context->drb_configured.num_of_list++;
                        #ifdef ENDC_ENABLED
                        for( drb_list_count = 0 ; drb_list_count < p_ue_context->drb_configured.num_of_list ; drb_list_count++)
                        {
                            p_ue_context->drb_configured.erab_item[drb_list_count].new_lc_id =  0xFF;
                            if((p_ue_context->drb_configured.erab_item[drb_list_count].\
                                drb_type == DRB_TYPE_SN_TERMINATED_SCG) || 
                              (p_ue_context->drb_configured.erab_item[drb_list_count].\
                                drb_type == DRB_TYPE_SN_TERMINATED_SPLIT))
                            {
                                atleast_one_sn_rab = RRM_TRUE;
                                p_ue_context->is_sgnb_param_reqd = RRM_FALSE;
                                p_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_SUCCESSFUL; 
                            }
                        }
                        #endif
						/* KPI: update kpi param, erb_setup_success*/
						erab_index++;
						/* Inserting the ue erb info to the priority list*/
						ue_erb.p_rrm_ue_context = p_ue_context;
						ue_erb.erab_id = p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_cnf_info[cnf_index].erab_id;

						if(RRM_FAILURE == rrm_ue_insert_erb_entity(&ue_erb))
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
									"UE_INDEX[%d], Insertion to ERAB priority list FAILED %d",
									p_ue_context->ue_index,
									p_rrm_ue_erab_success_list->erab_item[success_index].
									erab_id);
						}

                    /* SPR 18418 Fix Start */
                    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
                    if(p_cell_context == RRM_PNULL)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Cell Context is NULL ");
                        RRM_UT_TRACE_EXIT();
                        return RRM_FAILURE;
                    }
                    else
                    {
                        for ( index = RRM_ZERO; index < p_cell_context->epc_info.
                                epc_params.num_valid_qos_profiles; index++ )
                        {
                            if ( (p_rrm_ue_erab_success_list->erab_item[success_index].
                                        erab_level_qos_params.qci == p_cell_context->epc_info.epc_params.
                                        qos_config_params[index].qci ) &&
                                    (RRM_TRUE == p_cell_context->epc_info.epc_params.qos_config_params[index].
                                     sps_config_enabled))
                            {
                                p_ue_context->ue_sps_data.is_sps_erab_established = RRM_TRUE;
                            }
                        }
                    }
                    /* SPR 18418 Fix Stop */

						/*SPR 5169 start*/
						/*Update the value of sr_prohibit_timer_r9*/
						p_ue_context->sr_timer_r9_bkp = p_ue_context->sr_timer_r9_new;
						/*SPR 5169 end*/
						p_ue_context->ul_sch_config.retx_bsr_timer_past = p_ue_context->ul_sch_config.retx_bsr_timer_present;

						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, 
								"UE_INDEX[%d], Success Erab is setup for erab id %d",
								p_ue_context->ue_index,
								p_rrm_ue_erab_success_list->erab_item[success_index].
								erab_id);
					}
				}
			}
            #ifdef ENDC_ENABLED
            if( (RRM_TRUE ==  p_ue_context->is_sgnb_param_reqd ) &&
                (RRM_FALSE == atleast_one_sn_rab))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "RRM_ENDC_ENABLE_FAILED2\n");
                p_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_FAILED; 
                p_ue_context->is_sgnb_param_reqd = RRM_FALSE;
            }
            #endif
			/* CA: SCell Selection start */
			if(RRM_SUCCESS != rrm_check_for_ca_need_thru_erab_setup_or_ho_cnf(p_ue_context))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"Identified that UE does not require CA during ERAB setup");
			}
			/* CA: SCell Selection end */
			/* SPR 17564 Fix Start */
			/* Updating the UE Priority*/
			if ((erab_index > RRM_ZERO) && (RRM_FALSE == rrm_is_ue_special_previledge (p_ue_context)))
			{
				if (RRM_FAILURE == rrm_ue_update_ue_priority_list(p_ue_context))                
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							"UE_INDEX[%d]: Failure received while updating the ue_priority", 
							p_ue_context->ue_index);
				}
			}
			else
			{
				if ( RRM_SUCCESS == rrm_ue_delete_ue_from_priority_list (p_ue_context) )
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
							"UE_INDEX[%d]: Deleted the UE from UE priority List", 
							p_ue_context->ue_index);
				}	
			}
			/* SPR 17564 Fix End */

			/* SPS related changes start */
			/* Reset the SPS ERAB info for UE and Decrment active SPS_count  */
			if(p_rrm_ue_proc_erab_cnf_data->sps_error == RRM_TRUE)
			{
				for (fail_erab_index = RRM_NULL;
						/*CID 55001:start*/
						(fail_erab_index < p_rrm_ue_proc_erab_cnf_data->erab_error_list.erab_count)
						&& (fail_erab_index < RRM_UE_MAX_ERB_COUNT);
						/*CID 55001:end*/
						fail_erab_index++)
				{
					if(p_rrm_ue_proc_erab_cnf_data->erab_error_list.erab_error_info[fail_erab_index].erab_id == 
							p_ue_context->ue_sps_data.sps_erab_id) 
					{
						if(p_ue_context->ue_sps_data.is_sps_erab_established == RRM_TRUE)
						{
							rrm_ue_reset_sps_info(p_ue_context);
							rrm_cellm_decrement_num_sps_active_ue(p_ue_context->cell_index,p_ue_context->ue_sps_data.pucch_an_list_resource_index);
						}
						fail_sps_erab_found= RRM_TRUE;
						break;
					}
				}
				if(fail_sps_erab_found == RRM_FALSE )
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
							"UE_INDEX[%d], ERAB_ID[%d]: Not found sps ERAB in fail list (ERB_SETUP_CNF)", 
							p_ue_context->ue_index,p_ue_context->ue_sps_data.sps_erab_id);
				}
			}
			/* SPS related changes end */
			/* MAX_CID Changes Start */
			for (fail_erab_index = RRM_ZERO;
					/*CID 55001:start*/
					(fail_erab_index < p_rrm_ue_proc_erab_cnf_data->erab_error_list.erab_count)
					&& (fail_erab_index < RRM_UE_MAX_ERB_COUNT);
					/*CID 55001:end*/
					fail_erab_index++)
			{
				for(erab_index = RRM_ZERO; 
						/*CID 55001:start*/
						(erab_index < p_ue_context->map_data_drb_rohc.total_drb_count) 
						&& (erab_index < RRM_MAX_NUM_DRB_PER_UE); erab_index++)
					/*CID 55001:end*/
				{
					if(p_rrm_ue_proc_erab_cnf_data->erab_error_list.erab_error_info[fail_erab_index].erab_id ==
							p_ue_context->map_data_drb_rohc.map_data_rohc[erab_index].rab_id)
					{
						p_ue_context->map_data_drb_rohc.map_data_rohc[erab_index].is_rohc_enable
							= RRM_FALSE;
						p_ue_context->map_data_drb_rohc.count_drbs_cid_allocated--;
						p_ue_context->map_data_drb_rohc.total_drb_count--;

						/*Sorting the rohc map structure array if any info deleted*/
						for(sort_index = erab_index; 
								/*CID 55001:start*/
								(sort_index < p_ue_context->map_data_drb_rohc.total_drb_count)
								/*CID 66795:start*/
								&& (sort_index < RRM_MAX_NUM_DRB_PER_UE - RRM_ONE); sort_index++)
							/*CID 66795:end*/
							/*CID 55001:end*/
						{
							p_ue_context->map_data_drb_rohc.map_data_rohc[sort_index] =
								p_ue_context->map_data_drb_rohc.map_data_rohc[sort_index + RRM_ONE];

						}
						break;
					}
				}
			}
			/* MAX_CID Changes End */
			/*SPR 10329:fix start*/
			if(p_rrm_ue_proc_erab_cnf_data->bitmask & RRM_UEM_ERAB_SETUP_CNF_GUMMEI_INFO_PRESENT)
			{
				p_ue_context->is_gu_grp_info_present = RRM_TRUE;
				RRM_MEMCPY(&p_ue_context->gu_group_id.plmn_id.mcc,
						&p_rrm_ue_proc_erab_cnf_data->gummei_info.plmn_identity.mcc,
						RRM_THREE);
				RRM_MEMCPY(&p_ue_context->gu_group_id.plmn_id.num_mnc_digit,
						&p_rrm_ue_proc_erab_cnf_data->gummei_info.plmn_identity.mnc.count,
						RRM_ONE);
				RRM_MEMCPY(&p_ue_context->gu_group_id.plmn_id.mnc,
						&p_rrm_ue_proc_erab_cnf_data->gummei_info.plmn_identity.mnc.mnc,
						RRM_THREE);
				for(mme_id_index = RRM_ZERO; mme_id_index < RRM_MAX_MME_GRP_BYTES; mme_id_index ++)
				{
					p_ue_context->gu_group_id.mme_group_id[mme_id_index]= p_rrm_ue_proc_erab_cnf_data->gummei_info.mme_group_id[mme_id_index];
				}

			}
			/*SPR 10329:fix end*/
            /* SPR_21459 Fix - Start */
            if(p_rrm_ue_proc_erab_cnf_data->bitmask & RRM_UEM_ERAB_SETUP_CNF_MME_ID_PRESENT)
            {
                p_ue_context->mme_id = p_rrm_ue_proc_erab_cnf_data->mme_id;
            }
            /* SPR_21459 Fix - End */
		}
		/* SPR 17564 Fix Start */
		if((RRM_FALSE == is_ue_released) && (RRM_PNULL != p_ue_context))
        /* SPR 17564 Fix End */
		{    
			rrm_ue_print_drb_configured(p_ue_context);

			/*SPR 19819 START*/
			if((RRM_PNULL != p_rrm_ue_proc_erab_cnf_data) &&
					(RRM_PNULL != p_rrm_ue_erab_success_list))
			{
				rrm_ue_clean_prb_usage_proc_data_at_cnf_failure(p_ue_context,
						p_rrm_ue_proc_erab_cnf_data,
						p_rrm_ue_erab_success_list,ERAB_SETUP);
			}
			/*SPR 19819 END*/
 /*SPR 22553 FIXED START*/ 
/* CODE REMOVE */
 /*SPR 22553 FIXED END*/ 
            /*SPR_15839 fix start*/
            /*code removed as accessing NULL pointer*/
            /*SPR_15839 fix end*/

			/** if queue not empty then dequeue the events */
			if (rrm_get_queue_count(&p_ue_context->procedure_queue))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
						"UE_INDEX[%d], dequeue queued message",
						p_ue_context->ue_index);
				/** Dequeue the events from event queue and call message handler */
				/* SPR 15849 Start */
				p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
				/* SPR 15849 End */
				if(RRM_PNULL != p_rrm_ue_procedure_record)
				{ 
					/* CSR00069389 Start */
					rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
					/* CSR00069389 End */
				}
			}
			/*SPR 19819 START*/ 
			/* SPR 16331 Fix start */
			/* SPR 16812 Fix Start */
			/*if((RRM_PNULL != p_rrm_ue_proc_erab_cnf_data) &&
					(RRM_PNULL != p_rrm_ue_erab_success_list))
			{
				rrm_ue_clean_prb_usage_proc_data_at_cnf_failure(p_ue_context,
						p_rrm_ue_proc_erab_cnf_data,
						p_rrm_ue_erab_success_list);
			}*/
			/* SPR 16812 Fix Start */
			/* SPR 16331 Fix end */
			/*SPR 19819 START*/ 

			/*bug 10104 Fix - Start */
			if(RRM_PNULL != p_ue_context->current_procedure.p_erb_success_list)
			{
				RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_success_list);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED," erb_success_list is empty ");
			}

			if(RRM_PNULL != p_ue_context->current_procedure.p_erb_failed_list)
			{
				RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_failed_list);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"erb_failed_list is empty");
			}

			/* SPR 15441 start */
			/* code removed */
			/* SPR 15441 end */
			/*bug 10104 Fix - End */
			/* RACH_OPTIMIZATION_CHANGES_START */
			if(RRM_TRUE == p_g_rrm_ue_ctx->rrm_uem_rach_info_data.is_ue_rach_report_active)
			{
				/* SPR-18787 START */
				if((RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
							eutra_radio_capability_info_def.access_stratum_release) && \
						(rrm_is_set_fgi_bit(p_ue_context, RRM_SIXTEEN)))

				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"RACH_OPT: Sending UE info req \
							to RRC as RRM has received erb_setup_cnf. UE_INDEX[%d]", p_ue_context->ue_index);
					/*Second parameter is for prach cause as RRC_CONNECTED_UE*/
					/* coverity : CID 41551 */
					build_and_send_ue_info_req_to_rrc(p_ue_context, RRC_CONNECTED_UE);
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
							"RACH_OPT: UE_INDEX[%d] has accessStratumRelease less than release9 or FGI bit 16 is not set."\
							"Not sending UE Info req as conditions not met. access_stratum_release = %d",\
							p_ue_context->ue_index,\
							p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
							eutra_radio_capability_info_def.access_stratum_release);
				}
				/* SPR-18787 END */

			}

			/* RACH_OPTIMIZATION_CHANGES_END */

		/* Start fix for SPR 14987 */
        /* SPR 18418 Fix Start */
        /* Code Removed */
        if ((RRM_PNULL != p_cell_context) && (RRM_TRUE == send_request_for_anr))
			{
            /* SPR 18418 Fix Stop */
				if ((RRM_TRUE == p_cell_context->apply_anr_on_ue_attach_in_all_cycles) ||
						(RRM_TRUE == p_cell_context->is_anr_first_cycle))
				{
					if ((p_cell_context->p_son_info != RRM_PNULL) && 
							(p_cell_context->p_son_info->p_anr_info != RRM_PNULL) &&
							(p_cell_context->num_anr_strong_cell_req_sent < p_cell_context->ue_meas_cnt))
					{
						if ( (RRM_TRUE == rrm_is_ue_supporting_autonomous_gap(p_ue_context)) ||
								(RRM_TRUE == is_ue_supported_fgi_for_cdrx(p_ue_context)) )
						{
							rrm_send_meas_config_request_for_anr(p_cell_context, p_ue_context);
						}
						else
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"CDRX/Autonomous gaps not supported by UE rquired for ANR");
						}
					}
					else
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], ANR is disabled"
								" or MAX UE limit reached for ANR configuration %d",p_ue_context->ue_index,
								p_cell_context->num_anr_strong_cell_req_sent);
					}
				}
			}        
            /* SPR 21367 Fix Start */
            rrm_ue_calculate_total_bit_rate(p_ue_context,&ul_total_gbr_ue,
                    &dl_total_gbr_ue);
            if (RRM_PNULL != p_cell_context)
            {
                (p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate)+= ul_total_gbr_ue;
                (p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate)+= dl_total_gbr_ue;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,"Total used bitrate UL[%lu] DL[%lu] after this RAB procedure", 
                        p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate, p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate);
            }
            /* SPR 21367 Fix End */
		}
        /* SPR 18418 Fix Start */
        /* Code Removed */
        /* SPR 18418 Fix Stop */
		/* End fix for SPR 14987 */


        /* COV_113046_Fix_Start */
        /* COV_113046_Fix_End */
    }
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"p_ue_context is equal to RRM_PNULL");
		ret_val = RRM_FAILURE;

    }

    /* OPTION3X Changes Start */
#if 0
//#ifdef ENDC_ENABLED


    /* TO Remove , Just for providing delay in triggering DC_BEARER_CHANGE after receiving
     * ERAB_SETUP_CNF
     */
#include <unistd.h>
    sleep(2);
    /* Call for Triggering RRM_RRC_DC_BEARER_CHNAGE_REQ 
     * To Do: Some logic needs to be provided for handling of this trigger.
     */
    if ( RRM_FALSE == rrm_check_if_ue_has_dc_bearer(p_ue_context) )
    {
        U8 drb_index = RRM_ZERO;
        rrm_bool_t erab_id_matched      = RRM_FALSE;
        rrm_bool_t split_bearer_present = RRM_FALSE;
        rrm_bool_t um_bearer_present    = RRM_FALSE;
        rrm_ue_erab_setup_item_t *p_erab_item = RRM_NULL;

        /* Check for if any SN_TERMINATED_SPLIT_BEARER is already present or not */
        for ( drb_index = 0;
                (drb_index < p_ue_context->drb_configured.num_of_list) && (RRM_TRUE != split_bearer_present);
                drb_index++)
        {
            p_erab_item = (rrm_ue_erab_setup_item_t *)&(p_ue_context->drb_configured.\
                          erab_item[drb_index]);
            if (PNULL != p_erab_item)
            {
                if (
                        RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG & p_erab_item->bitmask &&
                        DRB_TYPE_SN_TERMINATED_SPLIT == p_erab_item->drb_type
                   )
                {
                    /* If one Bearer is already DRB_TYPE_SN_TERMINATED_SPLIT  type then don't go for
                     * Triggering DC_BEARER_CHANGE_REQ for this.
                     */
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                            "SN_TERMINATE_SPLIT_BEARER is already present. ERAB_ID[%d] DRB_ID[%d] LC_ID[%d]",
                            p_erab_item->erab_id, p_erab_item->drb_id, p_erab_item->lc_id);
                    split_bearer_present = RRM_TRUE;
                    break;
                }
                if(UM_MODE == p_erab_item->data_transfer_mode)
                {
                    um_bearer_present = RRM_TRUE;
                }
                p_erab_item = PNULL;
            }
        }

        if (RRM_TRUE != split_bearer_present && RRM_TRUE == um_bearer_present)
        {
            erab_id_matched = RRM_FALSE;
            for ( drb_index = 0;
                    (drb_index < p_ue_context->drb_configured.num_of_list);
                    drb_index++)
            {
                p_erab_item = (rrm_ue_erab_setup_item_t *)&(p_ue_context->drb_configured.\
                              erab_item[drb_index]);

                if (PNULL != p_erab_item)
                {
                    /* If ERAB type is  DRB_TYPE_SN_TERMINATED_SCG then don't trigger DC_BEARER_CHANGE_REQ.
                     * As DC_BEARER_CHANGE_REQ can only be terminated for MN_TERMINATED_MCG_BEARER.
                     */
                    if (
                            (RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG & p_erab_item->bitmask &&
                            DRB_TYPE_SN_TERMINATED_SCG == p_erab_item->drb_type)
                            ||
                            AM_MODE == p_erab_item->data_transfer_mode
                       )
                    {
                        continue;
                    }

                    for(success_index = RRM_NULL;
                            (success_index < p_rrm_ue_erab_success_list->num_of_list);
                            success_index++)
                    {
                        if(p_rrm_ue_erab_success_list->erab_item[success_index].erab_id
                                == p_erab_item->erab_id)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                                    "ERAB_ID[%d] DRB_ID[%d] LC_ID[%d] matched from success list",
                                    p_erab_item->erab_id, p_erab_item->drb_id, p_erab_item->lc_id);

                            erab_id_matched = RRM_TRUE;
                            break;
                        }
                    }

                    if(!erab_id_matched)
                    {
                        continue;
                    }

                    /* Initiate RRM_RRC_DRB_CHANGE_REQ with current erab item */
                    if (RRM_TRUE == rrm_check_is_endc_x2ap_link_established())
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "[DC Bearer Change] ENDC X2AP Setup is established");
                        if (RRM_TRUE == rrm_check_is_ue_support_endc(p_ue_context))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "[DC Bearer Change] UE supports ENDC ");

                            rrm_check_frequancy_band(p_ue_context);

                            if((RRM_SUCCESS == 
                                        rrm_ue_get_new_lc_id_for_bearer_change(p_ue_context, p_erab_item)) &&
                                    (RRM_SUCCESS == 
                                     rrm_ue_get_new_drb_id_for_bearer_change(p_ue_context, p_erab_item))
                               )
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "[DC Bearer Change] Initiate DC Bearchange for ERAB ID[%d]",
                                        p_erab_item->erab_id);

                                p_erab_item->bitmask |=
                                    RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG;
                                /*update the drb_type*/
                                p_erab_item->drb_type =
                                    DRB_TYPE_SN_TERMINATED_SPLIT;

                                p_ue_context->is_sgnb_param_reqd = RRM_TRUE;
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "[DC Bearer Change] Unable to allocate new LC ID or new DRB ID for ERAB_ID[%d]",
                                        p_erab_item->erab_id);
                            }
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "[ERB setup] ENDC X2AP Setup is not established");
                    }

                    /* If Current ERAB is set DRB_TYPE_SN_TERMINATED_SPLIT then build and send
                     * DC_BEARER_CHANGE_REQ to RRC.
                     */
                    if( DRB_TYPE_SN_TERMINATED_SPLIT == p_erab_item->drb_type &&
                            RRM_FAILURE == rrm_build_and_send_dc_bearer_change_req(p_ue_context,
                                p_erab_item))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "[RRM_RRC_DC_BEARER_CHANGE_REQ] sending failed.");

                        p_erab_item->new_lc_id = RRM_ZERO;
                        p_erab_item->new_drb_id = RRM_ZERO;
                        /* Do return value need to be change to Failure ???*/
                    }

                    p_erab_item = PNULL;
                    break;
                }
            }
        }
    }
#endif
/* OPTION3X Changes End */

	RRM_UT_TRACE_EXIT();
	return ret_val;
	/* Coverity_fix_end_62538 */
	/*Coverity_fix_end_62521*/
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_erb_modify_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_modify_req message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_erb_modify_req (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et					ret_val = RRM_SUCCESS;
	rrm_ue_context_t            	*p_ue_context;
	rrm_ue_proc_erab_setup_data_t 	*p_rrm_ue_proc_erab_setup_data = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t 	erb_modify_item_list;
	U8 								drb_configured_index = RRM_NULL;
	U8 								erb_requested_index = RRM_NULL;
    /*SPR 18241 START*/
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
    /*SPR 18241 END*/
	rrm_bool_et 						erb_exist = RRM_TRUE;
	rrm_bool_et 						flag = RRM_FALSE;
	/*BUG 13332:start*/
	U16                             trans_id = p_g_rrm_ue_ctx->trans_id;
	/*BUG 13332:end*/
	/*clean_up_start*/
	rrm_ue_erab_setup_item_list_t   *p_erab_modify_item_success_list = RRM_PNULL;
	rrm_ue_erab_failed_item_list_t  *p_erab_modify_item_failed_list = RRM_PNULL;
	U8                              index = RRM_NULL;
	/*clean_up_end*/

	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the file */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	/* Handling of the ERAB_MODIFY_REQ after the A2 configuration
	 * After A2 configuration if we receive the ERAB_MODIFY_REQ then we will reject the request
	 * and will send the response cause for S1 AP Handover as   and for X2 AP Handover as*/

    /*SPR 18241 START*/
    if(p_ue_context->ue_state == RRM_UE_STATE_HO_ONGOING )
    /*SPR 18241 END*/
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"sending ERB_MODIFY_RESP FAIL becz either RRM_UE_STATE_HO_ONGOING"
				"or RRM_UE_SECONDARY_MEAS_OBJ_CONFIGURED");
		ret_val = rrm_build_and_send_erb_modify_resp(RRM_UE_FAILURE,
				p_ue_context,
				trans_id);
	}


	if (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Current procedure \
				is ERB NULL",p_ue_context->ue_index);
		p_rrm_ue_proc_erab_setup_data = 
			(rrm_ue_proc_erab_setup_data_t *)p_ue_context->current_procedure.
			p_proc_data;
		erb_modify_item_list = p_rrm_ue_proc_erab_setup_data->erab_setup_list;

		/*clean_up_start*/
		p_erab_modify_item_success_list = (rrm_ue_erab_setup_item_list_t *)
			rrm_mem_get(sizeof(rrm_ue_erab_setup_item_list_t));
		if( RRM_PNULL == p_erab_modify_item_success_list)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
			return RRM_FAILURE;
		}
		p_erab_modify_item_failed_list = (rrm_ue_erab_failed_item_list_t *)
			rrm_mem_get(sizeof(rrm_ue_erab_failed_item_list_t));
		if( RRM_PNULL == p_erab_modify_item_failed_list)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
			RRM_MEM_FREE(p_erab_modify_item_success_list);
			return RRM_FAILURE;
		}
		/*clean_up_end*/

		/*Check and return FAILURE if the erab do not exist*/
		/* Coverity_ID_Fix_55332 */
		for(erb_requested_index = RRM_NULL ;
				((erb_requested_index < erb_modify_item_list.num_of_list) &&
				 (erb_requested_index < RRM_MAX_NUM_DRB_PER_UE));erb_requested_index++)
		{
			flag = RRM_FALSE;
			for(drb_configured_index = RRM_NULL;
					drb_configured_index < p_ue_context->drb_configured.
					num_of_list;drb_configured_index++)
			{
				if(erb_modify_item_list.erab_item[erb_requested_index].
						erab_id == 
						p_ue_context->drb_configured.
						erab_item[drb_configured_index].erab_id)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Erab \
							exists for erab modification",
							p_ue_context->ue_index);
					flag = RRM_TRUE;
					break;
				}
			}
			if(flag == RRM_FALSE)

			{
				erb_exist = RRM_FALSE; 
				break;
			}
		}
		if((erb_exist == RRM_FALSE) || (erb_modify_item_list.num_of_list == 
					RRM_NULL))
		{
			/*fill and send erb setup resp*/
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Either erab does \
					not exist for erab modification of requested no. of list \
					is zero",p_ue_context->ue_index);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Sending erb \
					modify resp with response FAILURE",
					p_ue_context->ue_index);

			p_erab_modify_item_success_list->num_of_list = RRM_ZERO;
			if(erb_modify_item_list.num_of_list != RRM_NULL)
			{
				p_erab_modify_item_failed_list->num_of_list =
					erb_modify_item_list.num_of_list;
				/* Coverity_ID_Fix_55332 */
				for(index = RRM_NULL;
						((index< erb_modify_item_list.num_of_list) &&
						 (erb_requested_index < RRM_MAX_NUM_DRB_PER_UE)); index++)
				{
					p_erab_modify_item_failed_list->
						erab_to_be_release_item[index].erab_id =
						erb_modify_item_list.erab_item[index].erab_id;
				}
			}
			else
			{
				p_erab_modify_item_failed_list->num_of_list = RRM_ZERO;
			}

			/*clean_up_start*/
			p_ue_context->current_procedure.p_erb_success_list =
				(void *)p_erab_modify_item_success_list;
			p_ue_context->current_procedure.p_erb_failed_list =
				(void *)p_erab_modify_item_failed_list;
			/*clean_up_end*/

			ret_val = rrm_build_and_send_erb_modify_resp(RRM_UE_FAILURE,
					p_ue_context,
					trans_id);
			/* SPR 15441 start */
			/* code removed */    
			/* SPR 15441 end */

			/*clean_up_start*/
			RRM_MEM_FREE(p_erab_modify_item_success_list);
			RRM_MEM_FREE(p_erab_modify_item_failed_list);
			p_ue_context->current_procedure.p_erb_success_list = RRM_PNULL;
			p_ue_context->current_procedure.p_erb_failed_list = RRM_PNULL;
			/*clean_up_end*/
            /*SPR 18241 START*/
            if ( (ret_val == RRM_SUCCESS) && (rrm_get_queue_count(&p_ue_context->procedure_queue)))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UE_INDEX[%d], dequeue queued message",
                        p_ue_context->ue_index);
                /** Dequeue the events from event queue and call message handler */
                /* SPR 15849 Start */
                p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                /* SPR 15849 End */
                if(RRM_PNULL != p_rrm_ue_procedure_record)
                {
                    /* CSR00069389 Start */
                    rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record,p_g_rrm_ue_ctx);
                    /* CSR00069389 End */
                }
            }
            /*SPR 18241 END*/

		}
		else
		{

			/*clean_up_start*/
			rrm_handle_erb_setup_modify_procedure(p_g_rrm_ue_ctx,
					p_erab_modify_item_success_list,
					p_erab_modify_item_failed_list,
					ERAB_MODIFY);
			/*clean_up_end*/
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Current procedure is \
				not ERB NULL,enqueue message",
				p_ue_context->ue_index);
		rrm_ue_procedure_queue_t    proc_queue;
		proc_queue.api_id = p_g_rrm_ue_ctx->api_id; 
		proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data; 
		/*BUG 13332:start*/
		proc_queue.trans_id = trans_id;
		/*BUG 13332:end*/
		/**Enqueue ERAB modify request */
         /*SPR 18241 START*/
		rrm_ue_mgr_enqueue_req( &proc_queue, p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
         /*SPR 18241_END*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_erb_modify_cnf 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_modify_cnf message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_erb_modify_cnf (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et					ret_val = RRM_SUCCESS;
	rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
	rrm_ue_proc_erab_cnf_data_t 	*p_rrm_ue_proc_erab_cnf_data = RRM_PNULL;
	rrm_ue_context_t				*p_ue_context = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t 	*p_rrm_ue_erab_success_list = RRM_PNULL;
	U8								cnf_index = RRM_NULL;
	U8								success_index =RRM_NULL;
	U8					            old_erab_priority = RRM_NULL;
	U8					            new_erab_priority = RRM_NULL;
	U8					            old_preemption_vulnerability = RRM_FALSE;
	U8					            new_preemption_vulnerability = RRM_FALSE;
	rrm_ue_erb_t			        ue_erb = {RRM_ZERO};
	U8 					            erab_index = RRM_NULL;    
    /* SPR 21367 Fix Start */
    rrm_cell_context_t              *p_cell_ctxt = RRM_PNULL;
    U64                             prev_ul_total_gbr_ue = RRM_ZERO;
    U64                             prev_dl_total_gbr_ue = RRM_ZERO;
    U64                             ul_total_gbr_ue = RRM_ZERO;
    U64                             dl_total_gbr_ue = RRM_ZERO;
    /* SPR 21367 Fix End */
	RRM_UT_TRACE_ENTER();
	/**Commit all resources */
	p_g_rrm_ue_ctx->p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    /*spr 17437 fix start*/
     p_rrm_ue_erab_success_list = 
         (rrm_ue_erab_setup_item_list_t *)p_ue_context->current_procedure.p_erb_success_list;
    /*spr 17437 fix stop*/

	p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

	p_rrm_ue_proc_erab_cnf_data = (rrm_ue_proc_erab_cnf_data_t *)p_ue_context->
		current_procedure.p_proc_data;

	/*SPR 19819 START*/
    if((PNULL != p_rrm_ue_proc_erab_cnf_data) && (RRM_PNULL != p_rrm_ue_erab_success_list))
    {
        if((RRM_PNULL != p_rrm_ue_proc_erab_cnf_data) &&
                (RRM_PNULL != p_rrm_ue_erab_success_list))
        {
            rrm_ue_clean_prb_usage_proc_data_at_cnf_failure(p_ue_context,
                    p_rrm_ue_proc_erab_cnf_data,
                    p_rrm_ue_erab_success_list,ERAB_MODIFY);
        }
        /*SPR 19819 END*/
        for(cnf_index = RRM_NULL;
                cnf_index < p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count;
                cnf_index++)
        {
            for(success_index = RRM_NULL;
                    success_index < p_rrm_ue_erab_success_list->num_of_list;
                    success_index++)
            {
                if(p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.
                        erab_cnf_info[cnf_index].erab_id == 
                        p_rrm_ue_erab_success_list->erab_item[success_index].erab_id)
                {
                    for( erab_index = RRM_NULL; 
                            erab_index < p_ue_context->drb_configured.num_of_list; erab_index++)
                    {
                        if(p_rrm_ue_erab_success_list->erab_item[success_index].
                                erab_id == p_ue_context->drb_configured.erab_item[erab_index].erab_id)
                        {
                            break;
                        }
                    }
                    old_erab_priority = p_ue_context->drb_configured.erab_item[erab_index].
                        erab_level_qos_params.alloc_and_reten_prior.priority_level;
                    new_erab_priority = p_rrm_ue_erab_success_list->erab_item[success_index].
                        erab_level_qos_params.alloc_and_reten_prior.priority_level;
                    old_preemption_vulnerability = p_ue_context->drb_configured.erab_item[erab_index].
                        erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;
                    new_preemption_vulnerability = p_rrm_ue_erab_success_list->erab_item[success_index].
                        erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;

                    ue_erb.p_rrm_ue_context = p_ue_context;
                    ue_erb.erab_id = p_ue_context->drb_configured.erab_item[erab_index].erab_id;
                    if((old_erab_priority != new_erab_priority)||
                            (old_preemption_vulnerability != new_preemption_vulnerability))
                    {
                        if(RRM_FAILURE == rrm_ue_delete_erb_entity(&ue_erb))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, 
                                    RRM_ERROR, "UE_INDEX[%d],  Erab Deletion to \
                                    priority list failed for erab id %d",p_ue_context->ue_index,
                                    p_rrm_ue_erab_success_list->erab_item[success_index].
                                    erab_id);

                        }   
                    }
                    RRM_MEMCPY(&p_ue_context->drb_configured.
                            erab_item[erab_index],
                            &p_rrm_ue_erab_success_list->erab_item[success_index] ,
                            sizeof(rrm_ue_erab_setup_item_t));

                    if((old_erab_priority != new_erab_priority)||
                            (old_preemption_vulnerability != new_preemption_vulnerability))
                    {
                        if(RRM_FAILURE == rrm_ue_insert_erb_entity(&ue_erb))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, 
                                    RRM_ERROR, "UE_INDEX[%d],  Erab insertion \
                                    to priority list failed for erab id [%d]",p_ue_context->ue_index,
                                    p_rrm_ue_erab_success_list->erab_item[success_index].
                                    erab_id);
                        }
                    }

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, 
                            RRM_DETAILED, "UE_INDEX[%d], Erab is \
                            modified for erab id %d",p_ue_context->ue_index,
                            p_rrm_ue_erab_success_list->erab_item[success_index].
                            erab_id);
                }
            }
        }
        /*SPR 19819 START*/
    }
    /*SPR 19819 END*/
    /* SPR 17564 Fix Start */
/* CID 111517 Fix Start */
if ( (RRM_PNULL != p_rrm_ue_proc_erab_cnf_data) &&
        (p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count) && 
    (RRM_FALSE == rrm_is_ue_special_previledge (p_ue_context)))
    /* CID 111517 Fix Stop */
    {
        if (RRM_FAILURE == rrm_ue_update_ue_priority_list(p_ue_context))                
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "UE_INDEX[%d]: Failure received while updating the ue_priority", 
                    p_ue_context->ue_index);
        }
    }
    else
    {
        if ( RRM_SUCCESS == rrm_ue_delete_ue_from_priority_list (p_ue_context) )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "UE_INDEX[%d]: Deleted the UE from UE priority List", 
                    p_ue_context->ue_index);
        }	
    }
    /* SPR 17564 Fix End */
    /* SPR 21367 Fix Start */
    p_cell_ctxt = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    rrm_ue_calculate_total_bit_rate(p_ue_context,&ul_total_gbr_ue,
            &dl_total_gbr_ue);
    if (RRM_PNULL != p_cell_ctxt)
    {
        if(ul_total_gbr_ue > prev_ul_total_gbr_ue)
        {
            (p_cell_ctxt->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate)+= (ul_total_gbr_ue - prev_ul_total_gbr_ue);
        }
        else
        {
            (p_cell_ctxt->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate)-= (prev_ul_total_gbr_ue - ul_total_gbr_ue);
        }

        if(dl_total_gbr_ue > prev_dl_total_gbr_ue)
        {
            (p_cell_ctxt->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate)+= (dl_total_gbr_ue - prev_dl_total_gbr_ue);
        }
        else
        {
            (p_cell_ctxt->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate)-= (prev_dl_total_gbr_ue - dl_total_gbr_ue);
        }
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,"Total admitted bitrate UL[%lu] DL[%lu] after this RAB procedure", 
                p_cell_ctxt->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate, p_cell_ctxt->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate);
    }
    /* SPR 21367 Fix End */
    /*Coverity 88578 Fix End*/
	rrm_ue_print_drb_configured(p_ue_context);

	/* SPR 17564 Fix Start */
	/* Code Removed */
	/* SPR 17564 Fix End */

	/*SPR 19819 START*/
	/* SPR 16331 Fix start */
	/* SPR 16812 Fix Start */
	/*if((RRM_PNULL != p_rrm_ue_proc_erab_cnf_data) &&
			(RRM_PNULL != p_rrm_ue_erab_success_list))
	{
		rrm_ue_clean_prb_usage_proc_data_at_cnf_failure(p_ue_context,
				p_rrm_ue_proc_erab_cnf_data,
				p_rrm_ue_erab_success_list);
	}*/
	/* SPR 16812 Fix Stop */
	/* SPR 16331 Fix end */
	/*SPR 19819 END*/ 
	
	/* SPR 20007 : CID 77082, 54360 Start */
	if(RRM_PNULL != p_ue_context->current_procedure.p_erb_success_list)
	{
		RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_success_list);
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING," erb_success_list is empty ");
	}

	if(RRM_PNULL != p_ue_context->current_procedure.p_erb_failed_list)
	{
		RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_failed_list);
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"erb_failed_list is empty");
	}
	/*SPR 20007 : CID 77082, 54360 End */


    /*spr 17437 fix start*/
    if(RRM_PNULL != p_ue_context->current_procedure.p_erb_success_list)
    {
        RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_success_list);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING," erb_success_list is empty ");
    }

    if(RRM_PNULL != p_ue_context->current_procedure.p_erb_failed_list)
    {
        RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_failed_list);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"erb_failed_list is empty");
    }
    /*spr 17437 fix stop*/

	/** if queue not empty then dequeue the events */
	if (rrm_get_queue_count(&p_ue_context->procedure_queue))
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], dequeue queued \
				message",p_ue_context->ue_index);
		/** Dequeue the events from event queue and call message handler */
		/* SPR 15849 Start */
		p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
		/* SPR 15849 End */
		/*LTE_RRM_KLOCWORK_WARN_6_JULY_12_START*/
		if(RRM_PNULL != p_rrm_ue_procedure_record)
		{ 
			/* CSR00069389 Start */
			rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx); 
			/* CSR00069389 End */
		}
		/*LTE_RRM_KLOCWORK_WARN_6_JULY_12_END*/
	}
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/*LTE_RRM_KLOCWORK_WARN_30_JULY_START*/
/****************************************************************************
 * Function Name  : rrm_ue_update_erb_failed_success_list
 * Inputs         : const rrm_ue_erab_to_be_released_item_list_t *
 p_erab_to_release 
 * Outputs        : rrm_ue_context_t *p_ue_context
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_release_req message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_update_erb_failed_success_list(const rrm_ue_erab_to_be_released_item_list_t
		*p_erab_to_release,
		rrm_ue_context_t       *p_ue_context
		)
{
	rrm_return_et			     ret_val = RRM_SUCCESS;
	rrm_ue_erab_setup_item_list_t           *p_erab_setup_item_success_list = RRM_PNULL;
	rrm_ue_erab_failed_item_list_t          *p_erab_setup_item_failed_list = RRM_PNULL;
	U8                                       success_count = RRM_ZERO;
	U8                                       failure_count = RRM_ZERO;
	U8                                       drb_configured_index = RRM_ZERO;
	U8     				     erb_requested_index = RRM_ZERO;
	rrm_bool_t                               erb_exist = RRM_FALSE;
	RRM_UT_TRACE_ENTER();

	do
	{
		if(RRM_PNULL == p_erab_to_release)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"NULL Pointer Exception");
			ret_val = RRM_FAILURE;
			break;
		}

		p_erab_setup_item_success_list = (rrm_ue_erab_setup_item_list_t *)
			rrm_mem_get(sizeof(rrm_ue_erab_setup_item_list_t));
		if( RRM_PNULL == p_erab_setup_item_success_list)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
			ret_val = RRM_FAILURE;
			break;
		}
		/* SPR_15601_Fix: Start */
		RRM_MEMSET(p_erab_setup_item_success_list,
				RRM_ZERO,
				sizeof(rrm_ue_erab_setup_item_list_t));
		/* SPR_15601_Fix: End */

		p_erab_setup_item_failed_list = (rrm_ue_erab_failed_item_list_t *)
			rrm_mem_get(sizeof(rrm_ue_erab_failed_item_list_t));
		if( RRM_PNULL == p_erab_setup_item_failed_list)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
			RRM_MEM_FREE(p_erab_setup_item_success_list);
			ret_val = RRM_FAILURE;
			break;
		}
		/* SPR_15601_Fix: Start */
		RRM_MEMSET(p_erab_setup_item_failed_list,
				RRM_ZERO,
				sizeof(rrm_ue_erab_failed_item_list_t));
		/* SPR_15601_Fix: End */
#ifdef ENDC_ENABLED
        rrm_bool_t scg_rab_for_release = RRM_FALSE;
        for(erb_requested_index = RRM_ZERO ;
                (RRM_FALSE == scg_rab_for_release) &&
                (erb_requested_index < p_erab_to_release->num_of_list);
                erb_requested_index++)
		{
            for(drb_configured_index = RRM_ZERO;
                    (RRM_FALSE == scg_rab_for_release) &&
                    (drb_configured_index < p_ue_context->drb_configured.num_of_list);
                    drb_configured_index++)
			{
				if(
                        (p_erab_to_release->
						erab_to_be_release_item[erb_requested_index].erab_id ==
						p_ue_context->drb_configured.
						erab_item[drb_configured_index].erab_id)
                        &&
                        (DRB_TYPE_SN_TERMINATED_SCG == p_ue_context->drb_configured.
						erab_item[drb_configured_index].drb_type)
                  )
                {
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"UE_INDEX[%d], ERAB [%d] to release is SN Terminated SCG Bearer, fail other LTE RAB if Present in ERAB Release.",
							p_ue_context->ue_index,
                            p_erab_to_release->erab_to_be_release_item[erb_requested_index].erab_id);
                    scg_rab_for_release = RRM_TRUE;
                }
            }
        }
#endif
		for(erb_requested_index = RRM_ZERO ;
				erb_requested_index < p_erab_to_release->num_of_list;
				erb_requested_index++)
		{
			for(drb_configured_index = RRM_ZERO;
					drb_configured_index < p_ue_context->drb_configured.num_of_list;
					drb_configured_index++)
			{
				if(p_erab_to_release->
						erab_to_be_release_item[erb_requested_index].erab_id ==
						p_ue_context->drb_configured.
						erab_item[drb_configured_index].erab_id)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"UE_INDEX[%d], Requested erb exists for release",
							p_ue_context->ue_index);
#ifdef ENDC_ENABLED
                    if (
                            (RRM_FALSE == scg_rab_for_release) ||
                            (
                             (RRM_TRUE == scg_rab_for_release) &&
                             (DRB_TYPE_SN_TERMINATED_SCG == p_ue_context->drb_configured.
                              erab_item[drb_configured_index].drb_type)
                            )
                       )
                    {
#endif
                        p_erab_setup_item_success_list->erab_item[success_count].erab_id =
                            p_erab_to_release->erab_to_be_release_item[erb_requested_index].erab_id;
                        success_count++;
                        erb_exist=RRM_TRUE;
                        break;
#ifdef ENDC_ENABLED
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                                "UE_INDEX[%d], Requested SN_TERMINATED_SCG_BEARER release, failing NON-SCG ERAB[%d] Release",
                                p_ue_context->ue_index,
                                p_erab_to_release->erab_to_be_release_item[erb_requested_index].erab_id
                                );

                        p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].erab_id =
                            p_erab_to_release->erab_to_be_release_item[erb_requested_index].erab_id;

                        p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                            cause.type = RADIO_NETWORK_LAYER_TYPE; 
                        p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                            cause.value = UNSPECIFIED;
                        failure_count++;
                        erb_exist=RRM_TRUE;
                        break;
                    }
#endif
				}
				else
				{
					erb_exist = RRM_FALSE;
				}
			}
			if(RRM_FALSE == erb_exist)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"UE_INDEX[%d], Requested erb does not exist for release",
						p_ue_context->ue_index);
				p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].erab_id =
					p_erab_to_release->erab_to_be_release_item[erb_requested_index].erab_id;
				/* SPR_15601_Fix: Start */
				p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
					cause.type = RADIO_NETWORK_LAYER_TYPE; 

				p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
					cause.value = UNKNOWN_ERAB_ID;
				/* SPR_15601_Fix: End */
				failure_count++;
			}
		}
		p_erab_setup_item_success_list->num_of_list = success_count;
		p_erab_setup_item_failed_list->num_of_list = failure_count;
		p_ue_context->current_procedure.p_erb_success_list =
			(void *)p_erab_setup_item_success_list;
		p_ue_context->current_procedure.p_erb_failed_list =
			(void *)p_erab_setup_item_failed_list;

	}while(RRM_FALSE);

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_30_JULY_END*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_erb_release_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_release_req message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_erb_release_req (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et							ret_val = RRM_SUCCESS;
	rrm_ue_context_t						*p_ue_context = RRM_PNULL;
	rrm_ue_erab_to_be_released_item_list_t 	erab_to_release;
	rrm_ue_proc_erab_release_data_t			*p_erab_release_data = RRM_PNULL;
	/*BUG 13332:start*/
	U16                                     trans_id = p_g_rrm_ue_ctx->trans_id;
	/*BUG 13332:end*/
    /*SPR 18241 START*/
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
    /*SPR 18241 END*/
	U8                                      success_count = RRM_ZERO;
	U8                                      failure_count = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    /* TC_45 test fix */
	if ( p_g_rrm_ue_ctx->p_ue_context->current_procedure.state == 
			RRM_UE_ERB_NULL )
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], Current procedure \
				is ERB_NULL",p_ue_context->ue_index);
		/* SPR 15462 Fix Code Deleted */
		p_erab_release_data = (rrm_ue_proc_erab_release_data_t *)
			(p_ue_context->current_procedure.p_proc_data);

		erab_to_release = p_erab_release_data->erab_setup_list;

		/*update the erb release of success and failure list*/
		/*LTE_RRM_KLOCWORK_WARN_30_JULY_START*/
		ret_val = rrm_ue_update_erb_failed_success_list(&erab_to_release,
				p_ue_context);
		/*LTE_RRM_KLOCWORK_WARN_30_JULY_END*/

		/* expel the success count which is updated above*/
		if(RRM_FAILURE != ret_val)
		{
			success_count =((rrm_ue_erab_setup_item_list_t *)(p_ue_context->current_procedure
						.p_erb_success_list))->num_of_list;

			failure_count = erab_to_release.num_of_list - success_count;
		}

		/** Send ERB release response message to RRC */
		if(failure_count == erab_to_release.num_of_list)
		{
			/** fill and send erb release resp */
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],  \
					Sending erb release response with response FAILURE ",
					p_ue_context->ue_index);
			ret_val = rrm_build_and_send_erb_release_resp( RRM_UE_FAILURE,
					p_ue_context,
					trans_id );
            /*SPR 18241 START*/
            if ( (ret_val == RRM_SUCCESS) && (rrm_get_queue_count(&p_ue_context->procedure_queue)))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UE_INDEX[%d], dequeue queued message",
                        p_ue_context->ue_index);
                /** Dequeue the events from event queue and call message handler */
                /* SPR 15849 Start */
                p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                /* SPR 15849 End */
                if(RRM_PNULL != p_rrm_ue_procedure_record)
                {
                    /* CSR00069389 Start */
                    rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
                    /* CSR00069389 End */
                }
            }
            /*SPR 18241 END*/
		}
		else if((success_count > RRM_ZERO) && (failure_count > RRM_ZERO))
		{
			/** fill and send erb release resp */
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],  \
					Sending erb release response with response PARTIAL SUCCESS ",
					p_ue_context->ue_index);
			ret_val = rrm_build_and_send_erb_release_resp(RRM_UE_PARTIAL_SUCCESS,
					p_ue_context,
					trans_id );
		}
		else if(success_count == erab_to_release.num_of_list)
		{
			/** fill and send erb release resp */
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],  \
					Sending erb release response with response SUCCESS",
					p_ue_context->ue_index);
			ret_val = rrm_build_and_send_erb_release_resp (RRM_UE_SUCCESS,
					p_ue_context,
					trans_id);
		}
		/* SPR 15441 start */
		/* code removed */
		/* SPR 15441 end */

	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],  \
				Current procedure is not ERB_NULL,enqueue message",
				p_ue_context->ue_index);
		rrm_ue_procedure_queue_t    proc_queue;
		proc_queue.api_id = p_g_rrm_ue_ctx->api_id; 
		proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data; 
		/*BUG 13332:start*/
		proc_queue.trans_id = trans_id;
		/*BUG 13332:end*/
		/**Enqueue ERAB release request */
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue,p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

	void
rrm_ue_decrease_um_am_mode_couter(
		rrm_ue_erab_setup_item_list_t *p_drb_configured,
		U8 erab_index
		)
{
	if(p_drb_configured->erab_item[erab_index].data_transfer_mode == AM_MODE )	
	{
		p_drb_configured->num_am_drb = 
			p_drb_configured->num_am_drb -RRM_ONE;	
	}
	else/*UM Mode*/
	{
		p_drb_configured->num_um_drb = 
			p_drb_configured->num_um_drb -RRM_ONE;
	}
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_erb_release_cnf 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_release_cnf message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_erb_release_cnf (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et					ret_val = RRM_SUCCESS;
	rrm_ue_context_t				*p_ue_context = RRM_PNULL;
	rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
	rrm_ue_proc_erab_cnf_data_t 	*p_rrm_ue_proc_erab_cnf_data = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t 	*p_rrm_ue_erab_success_list = RRM_PNULL;
	U8								cnf_index = RRM_NULL;
	U8								success_index = RRM_NULL;
	U8                              erab_index = RRM_NULL;
	rrm_ue_erb_t			        ue_erb = {RRM_ZERO};
	U8                sort_index = RRM_ZERO;
	/* Review Comments incorporated*/
    /*SPR 19968 START*/
	U64 ul_prbs_to_be_released = RRM_ZERO; 
	U64 dl_prbs_to_be_released = RRM_ZERO;
    /*SPR 19968 END*/

	/*Bug_776_changes_start*/
	S16                             prb_result = RRM_ZERO;
	/*Bug_776_changes_end*/
	/* SPR 10450 Fix Start */
	U8 released_erb_count = RRM_ZERO;
	/* SPR 10450 Fix Start */
	/* SPR 16331 Fix start */
    /*SPR 22151 Fix Start*/
    /*SPR 18654 START*/
    rrm_prb_t                        dl_prbs_to_release = RRM_ZERO;
    rrm_prb_t                        ul_prbs_to_release = RRM_ZERO;
    /*SPR 18654 START*/
    /*SPR 22151 Fix End*/
	U8                              qci = RRM_ZERO;
	U64                             dl_bitrate = RRM_ZERO;
	U64                             ul_bitrate = RRM_ZERO;
	/* SPR 16331 Fix end */
#ifdef ENDC_ENABLED
    rrm_bool_et                     sn_rab_present = RRM_FALSE;
#endif

	RRM_UT_TRACE_ENTER();

	/**Commit all resources */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	p_ue_context->current_procedure.state= RRM_UE_ERB_NULL;
	/* CID 109671 fix Start */
        p_rrm_ue_erab_success_list = &(p_ue_context->drb_configured);
	/* CID 109671 fix Stop */
	p_rrm_ue_proc_erab_cnf_data = (rrm_ue_proc_erab_cnf_data_t *)
		p_ue_context->current_procedure.p_proc_data;

    /*SPR 22151 Fix Start*/
    /*SPR 18654 FIX code deleted*/
    /*SPR 22151 Fix End*/

	/* Raise Event - RRM_EVENT_LOCAL_EVENT_ERAB_RELEASE_INFO Start */
	rrm_raise_event_erab_release_info(p_ue_context, p_rrm_ue_proc_erab_cnf_data);
	/* Raise Event - RRM_EVENT_LOCAL_EVENT_ERAB_RELEASE_INFO End */

	/*MAX_CID Changes Start*/
	for(cnf_index = RRM_NULL;
			cnf_index < p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count;
			cnf_index++)
	{
		for(erab_index = RRM_ZERO; erab_index <
				p_ue_context->map_data_drb_rohc.total_drb_count;
				erab_index++)
		{
			if(p_rrm_ue_proc_erab_cnf_data->erab_error_list.erab_error_info[cnf_index].erab_id
					==
					p_ue_context->map_data_drb_rohc.map_data_rohc[erab_index].rab_id)
			{
				/*Decrementing the count for DRBs for which CID was allocated as RAB
				 * is getting deleted and also disabling the ROHC flag in map
				 * structure*/
				p_ue_context->map_data_drb_rohc.map_data_rohc[erab_index].is_rohc_enable
					=
					RRM_FALSE;
				p_ue_context->map_data_drb_rohc.count_drbs_cid_allocated--;
				p_ue_context->map_data_drb_rohc.total_drb_count--;
				/*Sorting the rohc map structure array if any info deleted*/

				for(sort_index = erab_index; sort_index <
						p_ue_context->map_data_drb_rohc.total_drb_count;
						sort_index++)
				{
					p_ue_context->map_data_drb_rohc.map_data_rohc[sort_index]
						=
						p_ue_context->map_data_drb_rohc.map_data_rohc[sort_index
						+ 1];

				}
				break;
			}
		}
	}

	/*MAX_CID Changes End*/

	if(RRM_PNULL != p_rrm_ue_erab_success_list)
	{
		for(cnf_index = RRM_NULL;
				cnf_index < p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count;
				cnf_index++)
		{
			for(success_index = RRM_NULL;
					success_index < p_rrm_ue_erab_success_list->num_of_list;
					success_index++)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "RRC Rcvd Rab Id:%d, Stored Rab Id:%d",
						p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_cnf_info[cnf_index].erab_id, 
						p_rrm_ue_erab_success_list->erab_item[success_index].erab_id);

				if(p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.
						erab_cnf_info[cnf_index].erab_id ==
						p_rrm_ue_erab_success_list->erab_item[success_index].
						erab_id)
				{
					/* SPR 10450 Fix Start */
					if( NO_DRX_PROFILE != 
							p_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index)
					{
						p_ue_context->applied_drx_config.released_erab_info[released_erb_count++] = 
							p_rrm_ue_erab_success_list->erab_item[success_index].erab_level_qos_params.qci;
					}
					/* SPR 10450 Fix End */
					/*CID 47684*/
					for(erab_index = RRM_ZERO; (erab_index < p_ue_context->drb_configured.num_of_list) &&
							( erab_index < RRM_MAX_NUM_DRB_PER_UE ); erab_index++)
					{
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "RRC Rcvd Rab Id:%d, Stored Rab Id:%d",
								p_rrm_ue_erab_success_list->erab_item[success_index].erab_id,
								p_ue_context->drb_configured.erab_item[erab_index].erab_id);

						if(p_rrm_ue_erab_success_list->erab_item[success_index].
								erab_id == p_ue_context->drb_configured.erab_item[erab_index].erab_id)
						{

							/*Bug_776_changes_start*/
							if((p_ue_context->drb_configured.erab_item[erab_index].erab_level_qos_params.qci >= RRM_ONE) &&
									(p_ue_context->drb_configured.erab_item[erab_index].erab_level_qos_params.qci <= RRM_FOUR))
							{
								ul_prbs_to_be_released = rrm_cellm_get_ul_allocated_gbr_prb_per_ue(
										p_ue_context, p_ue_context->drb_configured.erab_item[erab_index].erab_id);
								dl_prbs_to_be_released = rrm_cellm_get_dl_allocated_gbr_prb_per_ue(
										p_ue_context, p_ue_context->drb_configured.erab_item[erab_index].erab_id);

								if(ul_prbs_to_be_released > RRM_ZERO)
								{
									U8 ul_allocated_gbr_prb = rrm_cellm_get_ul_allocated_gbr_prb(p_ue_context->cell_index);

									rrm_cellm_decrement_ul_allocated_gbr_prb_per_ue(p_ue_context,
											p_ue_context->drb_configured.erab_item[erab_index].erab_id);

									/* Below check is added as a precautionary check in the code.
									 * In case the difference of the result is negetive then the Cell Context
									 * should be explicitly set to RRM_ZERO. Although this is very unlikely to happen
									 * but still on precautionary basis check is added.
									 */
									prb_result = ul_allocated_gbr_prb - ul_prbs_to_be_released;
									if (prb_result < RRM_ZERO)
									{
										rrm_cellm_set_ul_allocated_gbr_prb(p_ue_context->cell_index, RRM_ZERO);
									}
									else
									{
										rrm_cellm_set_ul_allocated_gbr_prb(p_ue_context->cell_index,
												(ul_allocated_gbr_prb
												 - ul_prbs_to_be_released));
									}
								}

								if(dl_prbs_to_be_released > RRM_ZERO)
								{
									U8 dl_allocated_gbr_prb = rrm_cellm_get_dl_allocated_gbr_prb(p_ue_context->cell_index);

									rrm_cellm_decrement_dl_allocated_gbr_prb_per_ue( p_ue_context,
											p_ue_context->drb_configured.erab_item[erab_index].erab_id);

									/* Below check is added as a precautionary check in the code.
									 * In case the difference of the result is negetive then the Cell Context
									 * should be explicitly set to RRM_ZERO. Although this is very unlikely to happen
									 * but still on precautionary basis check is added.
									 */
									prb_result = dl_allocated_gbr_prb - dl_prbs_to_be_released;
									if (prb_result < RRM_ZERO)
									{
										rrm_cellm_set_dl_allocated_gbr_prb(p_ue_context->cell_index, RRM_ZERO);
									}
									else
									{
										rrm_cellm_set_dl_allocated_gbr_prb(p_ue_context->cell_index,
												(dl_allocated_gbr_prb
												 - dl_prbs_to_be_released));
									}
								}
							}
							/*Bug_776_changes_end*/

							/* Deleting the ue erb info from the priority list*/
							ue_erb.p_rrm_ue_context = p_ue_context;
							ue_erb.erab_id = p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_cnf_info[cnf_index].erab_id;

							if(RRM_FAILURE == rrm_ue_delete_erb_entity(&ue_erb))
							{
								RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
										"UE_INDEX[%d]: Failure received while deletion from erab priority  \
										list", p_ue_context->ue_index);
							}


							/* SPR 16331 Fix start */
							qci = p_rrm_ue_erab_success_list->erab_item[success_index].erab_level_qos_params.qci;
							if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
							{
								/*GBR LIMIT START */
								dl_bitrate = p_ue_context->drb_configured.erab_item[erab_index].
									erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;
								ul_bitrate = p_ue_context->drb_configured.erab_item[erab_index].
									erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;

								rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, dl_bitrate);
								rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, ul_bitrate);
								/*GBR LIMIT END */
                                /*SPR 22151 Fix Start*/
                                /*SPR 18654 Fix code deleted*/
                                dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,dl_bitrate); 
                                ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,ul_bitrate); 
                                /*SPR 22151 Fix End*/

								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
										"UE_ID[%d]:erb_id[%d] Deallocating dl_gbr_prbs(%d)",
										p_ue_context->ue_index,
										p_rrm_ue_erab_success_list->erab_item[success_index].erab_id,
										dl_prbs_to_release);

								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
										"UE_ID[%d]:erb_id[%d] Deallocating ul_gbr_prbs(%d)",
										p_ue_context->ue_index,
										p_rrm_ue_erab_success_list->erab_item[success_index].erab_id,
										ul_prbs_to_release);

								rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
								rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
							}
							/* SPR 16331 fix end */

							/* SPS related changes start */
							if(p_rrm_ue_erab_success_list->erab_item[success_index].erab_id == 
									p_ue_context->ue_sps_data.sps_erab_id) 
							{
								/* Reset the SPS ERAB info from UE and Decrment active SPS_count  */
								if(p_ue_context->ue_sps_data.is_sps_erab_established == RRM_TRUE)
								{
									rrm_ue_reset_sps_info(p_ue_context);
									rrm_cellm_decrement_num_sps_active_ue(p_ue_context->cell_index,p_ue_context->ue_sps_data.pucch_an_list_resource_index);
								}
							}
							/* SPS related changes end */
							/*Start changes for TTI bundling feature*/
							if(RRM_TRUE == p_ue_context->tti_bundling_enabled)
							{
								U8 qci_count = RRM_ZERO;
								U8 qci = p_rrm_ue_erab_success_list->erab_item[success_index].erab_level_qos_params.qci;
								rrm_cell_context_t *p_cell_context = rrm_cellm_get_cell_context(
										p_ue_context->cell_index);
								/*CID 65802:start*/
								if (RRM_PNULL != p_cell_context)
								{
									for(qci_count=0;qci_count < RRM_MAX_QCI; qci_count++)
									{
										if((RRM_TRUE == p_cell_context->epc_info.epc_params.\
													qos_config_params[qci_count].erb_service_profile.\
													rrc_ul_sch_config_profile.tti_bundling))
										{
											if(qci == p_cell_context->epc_info.epc_params.\
													qos_config_params[qci_count].qci)
											{
												/* decrement the count of ERABs associated with TTI bundling */
												p_ue_context->num_tti_bundling_erb--;
												if(RRM_ZERO == p_ue_context->num_tti_bundling_erb)
												{
													p_ue_context->tti_bundling_enabled = RRM_FALSE;
												}
												break;
											}
										}
									}
								}
								/*CID 65802:end*/
							}
							/*End changes for TTI bundling feature*/

							if (erab_index ==  (p_ue_context->drb_configured.num_of_list - RRM_ONE))
							{
								RRM_MEMSET(&p_ue_context->drb_configured.erab_item[erab_index],
										RRM_ZERO,
										sizeof(rrm_ue_erab_setup_item_t));
							}
							else
							{
								if (erab_index < (p_ue_context->drb_configured.num_of_list - RRM_ONE))
								{
									RRM_MEMCPY(&p_ue_context->drb_configured.erab_item[erab_index],
											&p_ue_context->drb_configured.erab_item[p_ue_context->
											drb_configured.num_of_list - RRM_ONE], 
											sizeof(rrm_ue_erab_setup_item_t));
									RRM_MEMSET(&p_ue_context->drb_configured.
											erab_item[p_ue_context->drb_configured.num_of_list - RRM_ONE],
											RRM_NULL ,sizeof(rrm_ue_erab_setup_item_t));
								}
							}


							p_ue_context->drb_configured.num_of_list--;
							break;
						}
					}

					/* SPR 10450 Fix Start */
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Released Rab Id:%d",
							p_ue_context->ue_index,
							p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_cnf_info[cnf_index].erab_id); 

				}
			}
		}
		p_ue_context->applied_drx_config.num_of_released_erab = released_erb_count;
		/* SPR 10450 Fix End */
		rrm_ue_print_drb_configured(p_ue_context);
		/* SPR 17564 Fix Start */
		/* Updating the UE Priority*/
		if ((p_rrm_ue_proc_erab_cnf_data->erab_cnf_list.erab_count > RRM_ZERO) && 
				(RRM_FALSE == rrm_is_ue_special_previledge (p_ue_context)))
		{
			if (RRM_FAILURE == rrm_ue_update_ue_priority_list(p_ue_context))                
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
						"UE_INDEX[%d]: Failure received while updating the  \
						ue_priority", p_ue_context->ue_index);
			}
		}
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                    "UE_INDEX[%d],Updation of priority List not required",
                    p_ue_context->ue_index);
        }
        /* SPR 17564 Fix End */
#ifdef ENDC_ENABLED
        for(erab_index = RRM_ZERO; (erab_index < p_ue_context->drb_configured.num_of_list) &&
                ( erab_index < RRM_MAX_NUM_DRB_PER_UE ); erab_index++)
        {
            if ( ( DRB_TYPE_SN_TERMINATED_SCG ==
                        p_ue_context->drb_configured.erab_item[erab_index].drb_type ) ||
                    ( DRB_TYPE_SN_TERMINATED_SPLIT ==
                      p_ue_context->drb_configured.erab_item[erab_index].drb_type ) )
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                        "For UE_INDEX[%d],after rab release, still SN rab is present\n",
                        p_ue_context->ue_index);
                sn_rab_present = RRM_TRUE;
            }
        }

        if( ( RRM_ENDC_ENABLE_SUCCESSFUL == p_ue_context->rrm_endc_nr_data.endc_enable_status)
            && (RRM_FALSE == sn_rab_present) )
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                    "For UE_INDEX[%d],after rab release, NO SN rab is present & ENDC was enabled\n",
                    p_ue_context->ue_index);
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                    "So reset the stats , so that RRM again tries to enable ENDC for UE [%d] \n",
                     p_ue_context->ue_index);
            p_ue_context->is_sgnb_param_reqd = RRM_FALSE;
            RRM_MEMSET(p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_data,
                    RRM_ZERO,sizeof(rrm_endc_nr_meas_data_t) * RRM_TWO); 
            RRM_MEMSET(&(p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_stats),
                    RRM_ZERO,sizeof(rrm_endc_nr_meas_stats_t));
            p_ue_context->rrm_endc_nr_data.endc_enable_status = RRM_ENDC_ENABLE_NOT_INITIATED;
        }
#endif
	}
	/* Updating the UE Priority*/


	/* SPR 17564 Fix Start */
	/* Code Removed */
	/* SPR 17564 Fix End */




	/** if queue not empty then dequeue the events */
	if (rrm_get_queue_count(&p_ue_context->procedure_queue))
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], dequeue queued \
				message",p_ue_context->ue_index);
		/** Dequeue the events from event queue and call message handler */
		/* SPR 15849 Start */
		p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
		/* SPR 15849 End */
		/*LTE_RRM_KLOCWORK_WARN_6_JULY_12_START*/
		if(RRM_PNULL != p_rrm_ue_procedure_record)
		{ 
			/* CSR00069389 Start */
			rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
			/* CSR00069389 End */
		}
		/*LTE_RRM_KLOCWORK_WARN_6_JULY_12_END*/
	}
	else
	{
        /*++ SPR 20078 code removed --*/
		/*TM mode switch decision */
		if( RRM_SUCCESS == rrm_build_and_send_ue_reconfig_req( p_ue_context ))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
					"UE Reconfig Successfully Sent for UE_INDEX[%d]",
					p_ue_context->ue_index);
		}
        /*++ SPR 20078 code removed --*/
	}
	/* SPR 15441 start */
	/* code removed */    
	/* SPR 15441 end */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_release_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_release_req message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_release_req (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et				ret_val			= RRM_SUCCESS;
	rrm_bool_et                 anr_ho_report_to_son_status    = RRM_FALSE; 
	rrm_bool_et                 mlb_ho_report_to_son_status    = RRM_FALSE; 
	/* CSR-79374[SPR-11578]-fix start */
	rrm_ue_release_req_t        *p_rrm_ue_release_req        = RRM_PNULL;

	/* BLR Team HO status report to Son Start */
	/* warning removal: unused variable 'handover_report' and 'ret_val_ho_report' 
	   is commented, 10/04/2012 */
	/* rrmuem_rmif_ho_report_t     handover_report; 
	   rrm_return_et               ret_val_ho_report       = RRM_SUCCESS; */
	/*  rrm_bool_et                 ho_report_to_son_status    = RRM_FALSE; */

	/* BLR Team HO status report to Son End */

	RRM_UT_TRACE_ENTER();

	if(RRM_PNULL == p_g_rrm_ue_ctx )
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "p_g_rrm_ue_ctx is NULL");
		return RRM_FAILURE; 
	}
	if (RRM_PNULL == p_g_rrm_ue_ctx->p_ue_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "p_g_rrm_ue_ctx->p_ue_context is NULL");
		return RRM_FAILURE; 
	}

	/* Fetch the current procedure data from the UE context */
	p_rrm_ue_release_req = (rrm_ue_release_req_t *)
		p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data;

	/*
	 ** In the case of HANDOVER_CANCELLED RRC will set the cause and on the basis of cause RRM will send the HO_REPORT
	 ** to the ANR or ANR/MLB modules.
	 **
	 ** Second in the case of HO_FAILURE, RRM already sent the HO_REPORT to ANR module, so skipping the HO_REPORT from here
	 ** and its take care with the help of ue_ho_current_state.
	 */
	/* SPR-12570-fix start */
	if ((p_g_rrm_ue_ctx->p_ue_context->ue_ho_current_state == RRM_HO_STATE_WAIT_FOR_REL) &&
			(p_g_rrm_ue_ctx->p_ue_context->handover_on_daho_cell_skip_ho_status_report != RRM_TRUE))
		/* SPR-12570-fix end */
	{
		anr_ho_report_to_son_status = rrm_cellm_get_ho_report_status(p_g_rrm_ue_ctx->p_ue_context->cell_index);
		mlb_ho_report_to_son_status = rrm_cellm_get_mlb_ho_report_status(p_g_rrm_ue_ctx->p_ue_context->cell_index);
		p_g_rrm_ue_ctx->p_ue_context->ue_handover_report.result = RRM_SUCCESS;

		if (p_rrm_ue_release_req != PNULL) 
		{
			if ((p_rrm_ue_release_req->bitmask & RRM_UE_RELEASE_CAUSE_PRESENCE_FLAG) &&
					(p_rrm_ue_release_req->cause.type == RADIO_NETWORK_LAYER_TYPE))
			{
				if((p_rrm_ue_release_req->cause.value == HANDOVER_CANCELLED) ||
						(p_rrm_ue_release_req->cause.value == HANDOVER_FAILURE_IN_TARGET_EPC_ENB_OR_TARGET_SYSTEM))
				{
					/* Update the result code in the case of FAILURE */
					p_g_rrm_ue_ctx->p_ue_context->ue_handover_report.result = RRM_FAILURE;
					/* In the case of FAILURE, no need to send the report to the MLB module. */
					mlb_ho_report_to_son_status = RRM_FALSE;
				}
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"result->[%d] type [%d] cause->[%d]",
						p_g_rrm_ue_ctx->p_ue_context->ue_handover_report.result,p_rrm_ue_release_req->cause.type, p_rrm_ue_release_req->cause.value);

			}
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"anr_ho_report_to_son_status->[%d] mlb_ho_report_to_son_status->[%d]",
					anr_ho_report_to_son_status,mlb_ho_report_to_son_status);
			/* SPR 15441 start */ 
			/* code removed */
			/* SPR 15441 end */ 
		}


		/* BLR Team HO status report to SON Changes Start */
		if (((anr_ho_report_to_son_status == RRM_TRUE) ||
					(mlb_ho_report_to_son_status == RRM_TRUE)) &&
				/* SPR 9216:MRO enhancement start */
				(RRM_FALSE == p_g_rrm_ue_ctx->p_ue_context->is_ho_failed))
			/* SPR 9216:MRO enhancement end */
		{
			if(anr_ho_report_to_son_status == RRM_TRUE)
			{
				p_g_rrm_ue_ctx->p_ue_context->ue_handover_report.rrm_dst_son_mod_ho_rep |= RRMUEM_RMIF_DST_SON_MOD_ANR_HOR;
			}
			if(mlb_ho_report_to_son_status == RRM_TRUE)
			{
				p_g_rrm_ue_ctx->p_ue_context->ue_handover_report.rrm_dst_son_mod_ho_rep |= RRMUEM_RMIF_DST_SON_MOD_MLB_HOR;
			}
			if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
						RRMUEM_RMIF_HO_REPORT, sizeof(rrmuem_rmif_ho_report_t),
						(void *)(&(p_g_rrm_ue_ctx->p_ue_context->ue_handover_report))))
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"HO_Failure Sent Handover report for UE_INDEX[%d]",
						p_g_rrm_ue_ctx->p_ue_context->ue_index);
				RRM_MEMSET (&(p_g_rrm_ue_ctx->p_ue_context->ue_handover_report), RRM_ZERO, sizeof(rrmuem_rmif_ho_report_t));

			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"Not able to send the HO_Failure Report for UE_INDEX[%d] to SON",
						p_g_rrm_ue_ctx->p_ue_context->ue_index);
			}
		}
		/* BLR Team HO status report to SON Changes End */
	}
	/* CSR-79374[SPR-11578]-fix end */

	/* eICIC_PHASE_1_2_CHANGES_START */
	ret_val=rrm_ue_release_process( p_g_rrm_ue_ctx);
	/* eICIC_PHASE_1_2_CHANGES_END */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/*  MRO code changes start */
/****************************************************************************
 * Fucnction Name  : rrm_ue_release_process 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_release_req message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_release_process (
		/* eICIC_PHASE_1_2_CHANGES_START */
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		/* eICIC_PHASE_1_2_CHANGES_END */
		)
{
	rrm_return_et				ret_val			= RRM_SUCCESS;
	rrm_ue_index_t				ue_index		= RRM_NULL;
	rrm_cell_index_t            cell_index      = RRM_NULL;
        /* SPR 21527 Start */
	U16                         num_active_ue   = RRM_NULL;
        /* SPR 21527 End */
	rrm_best_cell_for_ue_node_t  *p_best_cell = RRM_PNULL;
	/* Soft Lock start - Global variable removal */
	rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
	/* coverity : CID 16383*/
	rrm_ue_response_et     response = RRM_UE_FAILURE ; 
	/*SPR 16222 START */
	YLNODE *p_tmp_node = RRM_PNULL;
	YLNODE *p_node = RRM_PNULL;
	meas_report_info_node_t *p_cell_to_add_mode_node = RRM_PNULL;
	YLNODE * p_inner_node = RRM_PNULL; 
	YLNODE * p_tmp_inner_node = RRM_PNULL; 
	/*SPR 16222 END */

	/* eICIC_PHASE_1_2_CHANGES_START */
	U16 trans_id = RRM_ZERO; 
	rrm_ue_context_t *p_ue_context = RRM_PNULL;   


	trans_id = p_g_rrm_ue_ctx->trans_id;
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	YLIST victim_ue_list;
	ylInit(&victim_ue_list);
	victim_ue_node_t *p_victim_node = RRM_PNULL;
	/* eICIC_PHASE_1_2_CHANGES_END */

	p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
	if (RRM_PNULL == p_cell_ctxt)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
				"Cell Context not found");
		return RRM_FAILURE;
	}
	/* Soft Lock end - Global variable removal */

	RRM_UT_TRACE_ENTER();

	ue_index = p_ue_context->ue_index;
	cell_index = p_ue_context->cell_index;
	/**CLPC_MR_START*/
	rrm_de_allocate_tpc_rnti(
			p_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch,
			p_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch,
			p_ue_context->rrm_ue_clpc_params.
			tpc_rnti_index_pucch,
			p_ue_context->rrm_ue_clpc_params.
			tpc_rnti_index_pusch,
			cell_index);

	/*SPR_8372_CHANGES_START*/
	p_cell_ctxt->kpi_stat.kpi.num_of_erb_release_success +=
		p_ue_context->drb_configured.num_of_list;
	/*SPR_8372_CHANGES_END*/


	/**CLPC_MR_END**/
	/*csg id start*/
	rrm_decrease_csg_non_csg_counter(p_ue_context);
	/*csg id end*/
	/* Freq-Priority fix changes start  */ 
	rrm_ue_stop_ho_timers(p_ue_context);
	/* Freq-Priority fix changes end  */ 

	/* Review_comment_for_SPR_7996_nd_8345_start */
    /* SPR-17852 START */
    if (RRM_PNULL != p_ue_context->csg_subscription_expiry_timer)
    {
    /* SPR-17852 END */
/* SPR 20636 Changes Start*/
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Stoping CSG subscription expiry timer[0x%u] for [UE:%u]",
				(U32_U32Long_Bit)p_ue_context->csg_subscription_expiry_timer,ue_index);
/* SPR 20636 Changes End*/
		/* CSR-58333-fix start*/
		rrm_ue_stop_timer(p_ue_context->csg_subscription_expiry_timer);
		/* CSR-58333-fix end*/
		p_ue_context->csg_subscription_expiry_timer = RRM_PNULL;
	}
	/* Review_comment_for_SPR_7996_nd_8345_end */

		/*Stop the running timer*/
        /* SPR-17852 START */
        if (RRM_PNULL != p_ue_context->carrier_redirect_ue)
        {
            /* SPR-17852 END */
		{
			/* CSR-58333-fix start*/
			rrm_ue_stop_timer(p_ue_context->carrier_redirect_ue);
			/* CSR-58333-fix end*/
			p_ue_context->carrier_redirect_ue = RRM_PNULL;
		}
		/*Free the list*/
		while(RRM_PNULL != (p_best_cell = (rrm_best_cell_for_ue_node_t *)ylPopHead(&p_ue_context->best_cell_for_ue)))
		{
			RRM_MEM_FREE(p_best_cell);	
		}
	}
	/* For releasing gap offset for UE start */
	rrm_ue_release_gap_offset(p_ue_context);
	/* For releasing gap offset for UE end */
	ret_val = rrm_ue_clean_proc_queue(p_ue_context);	

	/* Deleting the ue entry from the UE piority List */
	/* SPR 17564 Fix Start */
	if (RRM_FALSE == rrm_is_ue_special_previledge (p_ue_context))
		/* SPR 17564 Fix End */
	{
		if(RRM_FAILURE == rrm_ue_delete_ue_from_priority_list(p_ue_context))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
					"[UE:%d],Failure in Deletetion from priority List",  
					ue_index);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
				"[UE:%d],Deletion not required from priority List",
				ue_index);
	}
	/* Deleting All erbs for the released UE from erb priority list*/
	if(RRM_SUCCESS == rrm_ue_update_erb_priority_list(p_ue_context))
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "All erbs deleted successfully");
	}

	/*Raising event RRM_EVENT_LOCAL_HO_OUT_EXEC_COMPLETE-START
	  When an outgoing handover execution UE task is confirmed*/
	if( p_ue_context->ue_ho_current_state == RRM_HO_STATE_WAIT_FOR_REL )
	{
		rrm_raise_event_ho_out_exec_complete();/*SPR 17777 +-*/
	}
	/*Raising event RRM_EVENT_LOCAL_HO_OUT_EXEC_COMPLETE-END*/
	/*SPR 16222 START*/
	p_node = ylFirst(&(p_ue_context->meas_report_list));
	while (p_node)
	{
		p_cell_to_add_mode_node = YMEMBEROF(meas_report_info_node_t, sNode, p_node);
		p_inner_node = ylFirst(&p_cell_to_add_mode_node->cells_to_add_mod_list);
		while(p_inner_node)
		{
			p_tmp_inner_node = p_inner_node;
			p_inner_node = ylNext(p_inner_node);

			ylDelete(&p_cell_to_add_mode_node->cells_to_add_mod_list,p_tmp_inner_node);
			RRM_MEM_FREE(p_tmp_inner_node);
		}
		p_tmp_node = p_node;
		p_node = ylNext(p_node);
		ylDelete(&(p_ue_context->meas_report_list),p_tmp_node);
		RRM_MEM_FREE(p_tmp_node);
	}
	/*SPR 16222 END*/

	/* eICIC_PHASE_1_2_CHANGES_START */
	/* Removing UE from Victim UE List if present */
	/* SPR 14285 start */
	if((RRM_UE_VICTIM_STATE == p_ue_context->rrm_ue_eicic_info.victim_ue)||
			(RRM_TRUE == p_ue_context->rrm_ue_eicic_info.scheduled_on_abs))
	{
		/* SPR 14285 end */
		victim_ue_list = p_g_rrm_ue_ctx->victim_ue_info.
			rrm_victim_ue_on_cell[cell_index].victim_ue_list;

		p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);

		while(p_victim_node)
		{
			if(p_victim_node->victim_ue_node_data.ue_index == p_ue_context->ue_index)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"removing ue[%d] from victim list", p_ue_context->ue_index);

				ylDelete(&victim_ue_list, (YLNODE *)p_victim_node);

				RRM_MEM_FREE(p_victim_node);
				p_victim_node = RRM_PNULL;

				p_g_rrm_ue_ctx->victim_ue_info.
					rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
			}
			else
			{
				p_victim_node = (victim_ue_node_t *)ylNext(&(p_victim_node->node));
			}
		}
	}
	/* eICIC_PHASE_1_2_CHANGES_END */

	/* SPR 16373 FIX START */
	/* Check and Decrement ANR Counter if any Anr is ongoing*/
	rrm_check_and_dec_num_anr_strong_cell_req_count(p_ue_context);
	/* SPR 16373 FIX END */
    /* Spr 18620 fix Start*/
    if(RRM_ZERO != ylCount(&(p_ue_context->meas_report_list)))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Before Cleanup:Meas Report List size:%u",ylCount(&(p_ue_context->meas_report_list)));

        p_node = ylFirst(&(p_ue_context->meas_report_list));
        while (RRM_PNULL !=  p_node)
    {
            p_tmp_node = p_node;
            p_node = ylNext(p_node);
            ylDelete(&(p_ue_context->meas_report_list),p_tmp_node);
            RRM_MEM_FREE(p_tmp_node);
    }
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                " After Cleanup:Meas Report List size:%u",ylCount(&(p_ue_context->meas_report_list)));
    }
    /* Spr 18620 fix End*/

    /* SPR 21496 Fix Start */
    rrm_ue_release_ue_capability_params(p_ue_context);
    /* SPR 21496 Fix End */ 

	if(ret_val == RRM_SUCCESS)
	{
		if(RRM_FAILURE == rrm_ue_delete_context(cell_index,ue_index))
        {
            /* BUG_12217_CHANGES_START */
            /* Coverity: CID 29029 Rel 2.1.3 */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                    "Failed to delete UE context");
            /* BUG_12217_CHANGES_END */
        }
        /*SPR 16257 FIX START*/
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                    "UE context delete successful, Make it NULL in global context as well.");
            p_g_rrm_ue_ctx->p_ue_context = RRM_NULL;
        }
        /*SPR 16257 FIX STOP*/

    }

    /* coverity : CID 16383*/
    if(RRM_SUCCESS == ret_val)
    {
        response = RRM_UE_SUCCESS;
    }
    else
    {
        response = RRM_UE_FAILURE;
    }

    /* coverity : CID 16383*/
    ret_val = rrm_build_and_send_ue_release_resp (cell_index, ue_index,response,trans_id); 

    /* Get Num Active UE count from Cell Context */
    /* SPR 21527 Start */
    num_active_ue = rrm_cellm_get_num_active_ue(cell_index);
    /* SPR 21527 End */

    if((RRM_SUCCESS == ret_val) && (RRM_ZERO == num_active_ue))
    {
        if (p_cell_ctxt->administrative_procedure_ongoing)
        {
            /* STOP GLOBAL TIMER and Wait for A4 report Timer (If running ) and Send Response success to MIF */
            /* Start fix for soft lock core dump during HO procedure */
            /*SPR 16364 START*/
            /* SPR-17852 START */
            if (RRM_PNULL != g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_A4_REPORT_TIMER]) 
            {  
                /* SPR-17852 END */
                /* End fix for soft lock core dump during HO procedure */
                /* CSR-58333-fix start*/
                rrm_ue_stop_timer (g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_A4_REPORT_TIMER]);
                /* CSR-58333-fix end*/
                g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_A4_REPORT_TIMER] = RRM_PNULL;
            }
            /* Start fix for soft lock core dump during HO procedure */
            /* SPR-17852 START */
            if (RRM_PNULL != g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER])
            {
                /* SPR-17852 END */
                /* End fix for soft lock core dump during HO procedure */
                /* CSR-58333-fix start*/
                rrm_ue_stop_timer (g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER]);

                /* CSR-58333-fix end*/
                g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER] = RRM_PNULL;
            }
            /*SPR 16364 END*/

            /* Soft Lock start - Global variable removal */
            p_cell_ctxt->administrative_procedure_ongoing = RRM_FALSE;
            /* Soft Lock end - Global variable removal */

            /* coverity : CID 16382*/
            ret_val = rrm_uem_send_rmif_non_emrgncy_active_calls_ho_resp (g_uem_gbl_proc.trans_id,
                    g_uem_gbl_proc.cell_index,
                    RRM_TRUE);
            if (RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UEM Successfully sent non_emrgncy_active_calls_ho_resp to MIF");
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "UEM Failed to Send non_emrgncy_active_calls_ho_resp to MIF");
            }
        }

        rrmuem_rmif_no_active_ue_ind_t *p_rrmuem_rmif_no_active_ue_ind = RRM_PNULL;
        /* BUG_11576_FIX_START */
        p_rrmuem_rmif_no_active_ue_ind = rrm_mem_get
            (sizeof(rrmuem_rmif_no_active_ue_ind_t));
        /* BUG_11576_FIX_END */

        if(RRM_PNULL == p_rrmuem_rmif_no_active_ue_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
            return RRM_FAILURE;
        }

        RRM_MEMSET(p_rrmuem_rmif_no_active_ue_ind, RRM_ZERO, 
                sizeof(rrmuem_rmif_no_active_ue_ind_t));

        p_rrmuem_rmif_no_active_ue_ind->cell_index = cell_index;
        if (RRM_FAILURE == rrm_uem_send_internal_msg(RRM_MIF_MODULE_ID,
                    RRMUEM_RMIF_NO_ACTIVE_UE_IND,
                    sizeof(rrmuem_rmif_no_active_ue_ind_t),
                    p_rrmuem_rmif_no_active_ue_ind))
        {
            /* Coverity: CID 29030 - Rel 2.1.3 */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "UEM send to MIF failed");
        }
        /* BUG_11576_FIX_START */
        RRM_MEM_FREE(p_rrmuem_rmif_no_active_ue_ind);
        /* BUG_11576_FIX_END */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*  MRO code changes end */

/****************************************************************************
 * Function Name  : rrm_ue_wait_for_cap_ind_handle_ue_release_req
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_release_req message received from RRC
 * 		    in state wait for capability indication
 ****************************************************************************/
rrm_return_et
rrm_ue_wait_for_cap_ind_handle_ue_release_req
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
    rrm_return_et				ret_val			= RRM_SUCCESS;
    rrm_ue_index_t				ue_index		= RRM_NULL;
    rrm_ue_context_t			*p_ue_context	= p_g_rrm_ue_ctx->p_ue_context;
    U16							trans_id		= p_g_rrm_ue_ctx->trans_id;
    rrm_cell_index_t            cell_index      = RRM_NULL;
    rrm_ue_response_et response = RRM_UE_INDEX_ERR; 
    /* SPR 14610 start */
    /* eICIC_PHASE_1_2_CHANGES_START */

    YLIST victim_ue_list;
    ylInit(&victim_ue_list);
    victim_ue_node_t *p_victim_node = RRM_PNULL;
    /* eICIC_PHASE_1_2_CHANGES_END */
    /* SPR 14610 end */
    RRM_UT_TRACE_ENTER();

    ue_index = p_ue_context->ue_index;
    cell_index = p_ue_context->cell_index;

    ret_val = rrm_ue_clean_proc_queue(p_ue_context);	
    /* Deleting the ue entry from the UE piority List */
    if(RRM_SUCCESS == rrm_ue_delete_ue_from_priority_list(p_ue_context))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Deleted from priority List",
                ue_index);
    }
    /* SPR 14610 start */
    /* eICIC_PHASE_1_2_CHANGES_START */
    /* Removing UE from Victim UE List if present */
    /* SPR 14285 start */
    if((RRM_UE_VICTIM_STATE == p_ue_context->rrm_ue_eicic_info.victim_ue)||
            (RRM_TRUE == p_ue_context->rrm_ue_eicic_info.scheduled_on_abs))
    {
        /* SPR 14285 end */
        victim_ue_list = p_g_rrm_ue_ctx->victim_ue_info.
            rrm_victim_ue_on_cell[cell_index].victim_ue_list;

        p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);

        while(p_victim_node)
        {
            if(p_victim_node->victim_ue_node_data.ue_index == p_ue_context->ue_index)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                        "removing ue[%d] from victim list", p_ue_context->ue_index);

                ylDelete(&victim_ue_list, (YLNODE *)p_victim_node);

                RRM_MEM_FREE(p_victim_node);
                p_victim_node = RRM_PNULL;

                p_g_rrm_ue_ctx->victim_ue_info.
                    rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
            }
            else
            {
                p_victim_node = (victim_ue_node_t *)ylNext(&(p_victim_node->node));
            }
        }
    }
    /* SPR 14610 end */
    if(ret_val == RRM_SUCCESS)
    {
        if(RRM_FAILURE == rrm_ue_delete_context(cell_index,ue_index))
        {
            /* BUG_12217_CHANGES_START */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                    "Failed to delete UE context");
            /* BUG_12217_CHANGES_END */
        }
    }

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Sending UE RELEASE RESPONSE",
            ue_index);
    /*coverity 16383, , rel2.0.1*/
    response = rrm_map_ue_response_value(ret_val);
    ret_val = rrm_build_and_send_ue_release_resp (cell_index, ue_index, response ,trans_id);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

    rrm_ue_response_et
rrm_map_ue_response_value(rrm_return_et rrm_response)
{
    rrm_ue_response_et ue_response = RRM_UE_INDEX_ERR;

    switch(rrm_response)
    {
        case RRM_FAILURE:
            ue_response = RRM_UE_FAILURE;
            break;

        case RRM_SUCCESS:
            ue_response = RRM_UE_SUCCESS;
            break;

        case RRM_PARTIAL_SUCCESS:
            ue_response = RRM_UE_PARTIAL_SUCCESS;
            break;

        case RRM_INDEX_ERR:
        default:
            ue_response = RRM_UE_INDEX_ERR;
    }
    return ue_response;
}

/* UE MEAS CHANGES :STARTS */

/****************************************************************************
 * Function Name  : rrm_ue_print_meas_config_struct
 * Inputs         : meas_config : structure containing the status parameters
 *		    corresponding to MEAS CONFIG REQ
 * Outputs        : None
 * Returns        : None
 * Description    : Prints the meas config struct params.
 ****************************************************************************/
/* Start: Enh 317 */
rrm_void_t
rrm_ue_print_meas_config_struct(
        rrm_ue_meas_config_t meas_config)
{
    /*SPR 15314 Start*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Obj ID: %d RAT type: %d, Carr Freq: %d, Meas Config Status: %d, CGI Req Count:%d, "
            "CGI Success cnt: %d, CGI Resp Status: %d Obj Created at UE = %d Report Counter Value: %d", 
            meas_config.meas_obj_id, meas_config.rat_type,
            meas_config.carr_freq, meas_config.meas_config_status,
            meas_config.cgi_req_cnt, meas_config.cgi_success_cnt,
            meas_config.cgi_resp_status, meas_config.obj_created_at_ue,meas_config.report_counter);
    /* End: Enh 317 */
    /*SPR 15314 End*/
}

/****************************************************************************
 * Function Name  : rrm_uem_send_meas_config_resp
 * Inputs         : p_ue_context - Pointer to the UE Context
 *		    response - the result corresponding to the meas config 
 *	 	    req received from RRC. Failure if any of the request fails
 *		    otherwise Success
 *		    error_code - Cause in case of failure
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Sends the meas_config_resp message to RMIF.
 ****************************************************************************/
rrm_return_et
rrm_uem_send_meas_config_resp(
        rrm_ue_context_t 	*p_ue_context,
        rrm_return_et           response,
        U16                     error_code
        )
{
    rrmuem_rmif_meas_config_resp_t 	meas_config_resp = {RRM_ZERO};
    rrm_return_et 		 	ret_val 	= RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    meas_config_resp.cellindex = p_ue_context->cell_index;
    meas_config_resp.transaction_id = p_ue_context->cgi_req_trans_id;
    meas_config_resp.response = response;
    meas_config_resp.fail_cause = error_code;

    if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                RRMUEM_RMIF_MEAS_CONFIG_RES, 
                sizeof(rrmuem_rmif_meas_config_resp_t),
                (void *)(&meas_config_resp)))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Sent MEAS Config Resp for UE_INDEX[%d]",
                p_ue_context->ue_index);
        ret_val = RRM_SUCCESS;
    }
    else
    {
        /*Cov_fix_start_54425*/    
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Failed to send MEAS Config Resp for UE ");
        /*Cov_fix_end_54425*/		
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 15860 Start */
/* SPR 15861 Start */
/* SPR 15862 Start */

/* SPR 15843 Start */
    rrm_bool_et
rrm_uem_check_is_cgi_config_pending(rrm_ue_context_t* p_rrm_ue_ctx)
{
    rrm_bool_et              is_cgi_config_pending = RRM_FALSE;
    YLNODE*                  p_node                = RRM_PNULL;
    meas_report_info_node_t* p_meas_report_node    = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_node = ylFirst(&(p_rrm_ue_ctx->meas_report_list));

    while (p_node)
    {
        p_meas_report_node = (meas_report_info_node_t*)p_node;
        p_node = ylNext(p_node);

        if(p_meas_report_node->reporting_event == MEAS_REP_EVENT_FOR_CGI)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "CGI config node is pending for meas id = %u",
                    p_meas_report_node->meas_id);
            is_cgi_config_pending = RRM_TRUE;
            break;
        }
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, "is_cgi_config_pending = %u", is_cgi_config_pending);

    RRM_UT_TRACE_EXIT();
    return is_cgi_config_pending;
}
/* SPR 15843 End */
/* SPR 15860 End */
/* SPR 15861 End */
/* SPR 15862 End */

/* SPR 16053 start */
/****************************************************************************
 * Function Name  : rrm_update_interfreq_interrat_info
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : Void
 * Description    : Updates the corresponding flags to according to the inter
 *                  freq/inter RAT measurement objects configured
 ****************************************************************************/
rrm_void_t rrm_update_interfreq_interrat_info(
        rrm_ue_context_t *p_ue_context)
{
    RRM_UT_TRACE_ENTER();
    /*SPR_17047_START*/
    if(RRM_SET == p_ue_context->meas_gap_sent_status)
    {
        p_ue_context->meas_gap_config.meas_gap_config_type = RRM_ONE;
    }
    else if(RRM_UNSET == p_ue_context->meas_gap_sent_status)
    {
        p_ue_context->meas_gap_config.meas_gap_config_type = RRM_ZERO;
    }
    p_ue_context->meas_gap_sent_status = RRM_SET_INVALID;
    /*SPR_17047_END*/

    if(RRM_TRUE == rrm_is_any_interfreq_interrat_meas_configured(p_ue_context))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                " Inter-freq/Inter-RAT measurment is/are configured for UE_INDEX[%d], previous value=%d",
                p_ue_context->ue_index,p_ue_context->interfreq_interrat_meas_configured);
        p_ue_context->interfreq_interrat_meas_configured = RRM_TRUE;
        // p_ue_context->meas_gap_config.meas_gap_config_type = RRM_ONE;
        /*SPR_17047_START*/
        /*Code Removed */
        /*SPR_17047_END*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                " Inter-freq/Inter-RAT measurment is/are not configured for UE_INDEX[%d], previous value=%d",
                p_ue_context->ue_index,p_ue_context->interfreq_interrat_meas_configured);
        p_ue_context->interfreq_interrat_meas_configured = RRM_FALSE;       //p_ue_context->meas_gap_config.meas_gap_config_type = RRM_ZERO;
        /*SPR_17047_START*/
        /*Code Removed */
        /*SPR_17047_END*/
    }

    /*    if ((RRM_ZERO == p_ue_context->meas_gap_config.meas_gap_config_type) &&
          (RRM_TRUE == rrm_is_anr_configured_for_inter_object(p_ue_context)))
          {
          p_ue_context->meas_gap_config.meas_gap_config_type = RRM_ONE;
          }*/
    /*SPR_17047_START*/
    /*Code Removed */
    /*SPR_17047_END*/

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "MeasGap for UE_INDEX[%d], is %s",
            p_ue_context->ue_index, (RRM_ONE == p_ue_context->meas_gap_config.meas_gap_config_type)? "Configured" : "Not Configured");
    RRM_UT_TRACE_EXIT();
    return;
}
/* SPR 16053 end */

/****************************************************************************
 * Function Name  : rrm_ue_handle_meas_config_resp 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_config_resp message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_meas_config_resp(
        rrm_ue_global_context_t *p_g_rrm_ue_ctx
        )
{
    rrm_return_et		            ret_val         = RRM_SUCCESS;
    rrm_ue_meas_config_response_t   *p_proc_data    = RRM_PNULL;
    U8				                meas_id	        = RRM_NULL;
    rrm_bool_et                     meas_resp_valid = RRM_FALSE;
    U16                     	    error_code      = RRM_NO_ERROR;
    rrm_bool_et                     is_ecid_meas_resp     = RRM_FALSE;
    rrm_meas_ecid_resp_et          ecid_meas_resp_action = RRM_ECID_MEAS_CONTINUE; 
    rrm_ue_procedure_record_t      *p_rrm_ue_procedure_record = RRM_PNULL;
    /* SPR 15860 Start */
    rrm_bool_et              is_cgi_config_pending = RRM_FALSE;
    /* SPR 15860 End */
    /* SPR 16053 start */
    rrm_bool_et                         req_for_cgi = RRM_FALSE;
    rrm_ue_meas_config_cgi_queue_node_t *p_cgi_node = RRM_PNULL;
    rrm_ue_procedure_record_t           *p_next_node = RRM_PNULL;
    /* SPR 16053 end */

    /* SPR 16373 FIX START */ 
    rrm_cell_context_t       *p_cell_context = RRM_PNULL;
    /* SPR 16373 FIX END */ 
    /* SPR 17837 FIX START */
    meas_report_info_node_t  *p_meas_report_info = RRM_PNULL;
    /* SPR 17837 FIX END */

    RRM_UT_TRACE_ENTER();

    p_proc_data = (rrm_ue_meas_config_response_t *)
        p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data;

    /* Store the Success status in order to send meas results to SON */
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
            "Meas Config Status params for UE index = %d",
            p_g_rrm_ue_ctx->p_ue_context->ue_index);
    for(meas_id = RRM_ZERO; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
    {
        /* CSR00069389 Start */
        /* If a Meas Config Request to report strongest cells has been sent */
      /* SPR 21496 Fix Start */ 
        if(RRM_MEAS_CONFIG_REQ_SENT == 
                p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status)
        {
            /* CSR00069389 End */

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Updated status for MeasID:- %d", meas_id + RRM_MEAS_OBJ_ID_OFFSET); 
            rrm_ue_print_meas_config_struct(
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id]);

            /* If Report CGI Reuest has been sent for the meas_id */
            if(p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].cgi_req_cnt > RRM_NULL)
            {
                /* SPR 16053 start */
                req_for_cgi = RRM_TRUE;
                /* SPR 16053 end */
                meas_resp_valid = RRM_TRUE;
                if(RRM_SUCCESS == p_proc_data->response)
                {
                    /*SPR 17061 Start*/
                    /*SPR 15835:Start*/
                    p_g_rrm_ue_ctx->p_ue_context->report_amount_ue += p_g_rrm_ue_ctx->p_ue_context->temp_report_amt_ue; 
                    p_g_rrm_ue_ctx->p_ue_context->temp_report_amt_ue = RRM_ZERO; 
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SUCCESS Resp received for Report CGI Request report amt[%d]",
                            p_g_rrm_ue_ctx->p_ue_context->report_amount_ue);
                    /*SPR 15835:End*/
                    /*SPR 17061 End*/

                    /* CSR00069389 Start */
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status =
                        RRM_MEAS_CONFIG_RESP_SUCCESS;
                    /* CSR00069389 End */
                    /*SPR 17061 Start*/
                    /* SPR 15397 Start */
                    p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state = RRM_UE_MEAS_RESULTS_AWAITED;
                    /* SPR 15397 End */
                    /*SPR 17061 End*/

                    /* SPR 16053 start */
                    /* Code deleted */
                    /* SPR 16053 end */
#ifdef RRM_UT_FLAG       
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_S);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.meas_config_resp_S);            
#endif                
                }   
                else
                {
                    /*SPR 17061 Start*/
                    /*SPR 15835:Start*/
                    p_g_rrm_ue_ctx->p_ue_context->temp_report_amt_ue = RRM_ZERO; 
                    /*SPR 15835:End*/
                    /*SPR 17061 End*/
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "FAILURE Resp received for Report CGI Request");

                    /* CSR00069389 Start */
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status =
                        RRM_MEAS_CONFIG_NULL;
                    /* CSR00069389 End */

                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].cgi_resp_status =
                        RRM_FAILURE;
                    error_code = RRM_ERR_RRC_FAILURE;
#ifdef RRM_UT_FLAG       
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.meas_config_resp_F);            
#endif                
                }   
                /*Cov_fix_start_65021*/
                /* Decrement the req count for which resp is awaited */
                p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].cgi_req_cnt--;
                /*Cov_fix_end_65021*/
                /* CSR00069389 Start */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Updated status for MeasID:- %d", meas_id + RRM_MEAS_OBJ_ID_OFFSET); 
                rrm_ue_print_meas_config_struct(
                        p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id]);
                /* CSR00069389 End */

                if(p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].cgi_req_cnt ==
                        RRM_NULL)
                {
                    /* send resp to RMIF */
                    rrm_uem_send_meas_config_resp(p_g_rrm_ue_ctx->p_ue_context,
                            p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].
                            cgi_resp_status, error_code);
                }

                /* CSR00069389 Start */   
            }
            else
            {
                /* CSR00069389 End */
                meas_resp_valid = RRM_TRUE;
                /* Update the Meas config request status in UE context */
                if(RRM_SUCCESS == p_proc_data->response)
                {
                    /*SPR 17061 Start*/
                    /*SPR 15835:Start*/
                    p_g_rrm_ue_ctx->p_ue_context->report_amount_ue += p_g_rrm_ue_ctx->p_ue_context->temp_report_amt_ue; 
                    p_g_rrm_ue_ctx->p_ue_context->temp_report_amt_ue = RRM_ZERO; 
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "SUCCESS Resp received for Report Strongest Cell Request, report amt[%d]",
                            p_g_rrm_ue_ctx->p_ue_context->report_amount_ue);
                    /*SPR 15835:End*/
                    /*SPR 17061 End*/
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status = 
                        RRM_MEAS_CONFIG_RESP_SUCCESS;
                    /* Start: Enh 317 */ 
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].obj_created_at_ue =
                        RRM_TRUE;
                    /*SPR 17061 Start*/
                    /* SPR 15397 Start */
                    p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state = RRM_UE_MEAS_RESULTS_AWAITED;
                    /* SPR 15397 End */
                    /*SPR 17061 End*/

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "Updated status for MeasID:- %d", meas_id + RRM_MEAS_OBJ_ID_OFFSET); 
                    rrm_ue_print_meas_config_struct(
                            p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id]);
                    /* End: Enh 317 */

#ifdef RRM_UT_FLAG       
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_S);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.meas_config_resp_S);            
#endif                
                }
                /* If Failure response is received from RRC, Nullify the corresponding  
                   meas config status */
                else
                {
                    /*SPR 17061 Start*/
                    /*SPR 15835:Start*/
                    p_g_rrm_ue_ctx->p_ue_context->temp_report_amt_ue = RRM_ZERO; 
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "FAILURE Resp received for Report Strongest Cell Request. report amt[%d]",
                            p_g_rrm_ue_ctx->p_ue_context->report_amount_ue);
                    /* SPR 16406 Start */ 
                    /* SPR 16373 FIX START */ 
                    /*Decrementing num_anr_strong_cell_req_sent counter */
                    p_cell_context  = rrm_cellm_get_cell_context(p_g_rrm_ue_ctx->p_ue_context->cell_index);
                    if (RRM_PNULL != p_cell_context)
                    {
                        if(p_cell_context->num_anr_strong_cell_req_sent > RRM_ZERO)
                        { 
                            p_cell_context->num_anr_strong_cell_req_sent--;  
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "After Decrementing num_anr_strong_cell_req_sent = %d",
                                    p_cell_context->num_anr_strong_cell_req_sent);
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Failed to Decrease num_anr_strong_cell_req_sent as it is = %d",
                                    p_cell_context->num_anr_strong_cell_req_sent);
                        }
                    }
                    /* SPR 16373 FIX END */ 
                    /* SPR 16406 End */
                    /*SPR 15835:End*/
                    /*SPR 17061 End*/
                    /* Fix 8570 Start */
                    /* Start: Enh 317 */
                    if(RRM_FALSE == p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].obj_created_at_ue)
                    {
                        rrm_uem_reset_meas_config_struct(&p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id]);
                    }
                    /* CSR00069389 Start */
                    else
                    {
                        p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status =
                            RRM_MEAS_CONFIG_RESP_SUCCESS;
                    }
                    /* CSR00069389 End */
                    /* End: Enh 317 */
                    /* Fix 8570 End */
#ifdef RRM_UT_FLAG       
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.meas_config_resp_F);
#endif                
                }		
                /* Start: Enh 317 - Delete */
            }
        }
        /* SPR_16053_Fix: Start */
        /* SPR 16053 start */
        else if(RRM_MEAS_CONFIG_TO_DELETE ==
                p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status)
        {
            if (RRM_SUCCESS == p_proc_data->response)
            {
                /* SPR 16373 FIX START */
                p_cell_context  = rrm_cellm_get_cell_context(p_g_rrm_ue_ctx->p_ue_context->cell_index);
                if (RRM_PNULL != p_cell_context)
                {
                    /* SPR 17837 FIX START */
                    /* Decrement the counter only if success is received for RSC removal */
                    p_meas_report_info = rrm_get_meas_node_for_meas_id(
                            p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_id,
                            p_g_rrm_ue_ctx->p_ue_context); 
                    if (PNULL == p_meas_report_info)
                    {
                        /* Spr 18488 Changes Start */
                        /* SPR 17871 Fix Start */
                        p_g_rrm_ue_ctx->p_ue_context->report_amount_ue -=p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].report_counter;
                        /* SPR 17871 Fix Stop */
                        /* Spr 18488 Changes End */
                        if(p_cell_context->num_anr_strong_cell_req_sent > RRM_ZERO)
                        { 
                            p_cell_context->num_anr_strong_cell_req_sent--; 
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "After Decrementing num_anr_strong_cell_req_sent = %d",
                                    p_cell_context->num_anr_strong_cell_req_sent);
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Failed to Decrease num_anr_strong_cell_req_sent as it is = %d",
                                    p_cell_context->num_anr_strong_cell_req_sent);
                        }
                    }
                    /* SPR 17837 FIX END */
                }
                /* SPR 16373 FIX END */

                if (p_g_rrm_ue_ctx->p_ue_context->report_amount_ue >= p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].report_counter)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "p_ue_context->report_amount_ue = %u, p_ue_context->p_meas_config[meas_id].report_counter = %u",
                            p_g_rrm_ue_ctx->p_ue_context->report_amount_ue, p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].report_counter);
                    p_g_rrm_ue_ctx->p_ue_context->report_amount_ue -= p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].report_counter;
                }
                if(RRM_FALSE == p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].obj_created_at_ue)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Deleting queued procedure for CGI Req for RAT = %d ObjId = %d MeasId = %d"
                            " as corresponding meas object is being removed",
                            p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].rat_type,
                            p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_obj_id,
                            meas_id + RRM_ONE);
                    /* CSR00069389 Start */
                    /* If any CGI req is present in the procedure queue, delete it */
                    while (RRM_PNULL != p_g_rrm_ue_ctx->p_ue_context->p_proc_queue_first_meas_node)
                    {
                        p_rrm_ue_procedure_record = p_g_rrm_ue_ctx->p_ue_context->p_proc_queue_first_meas_node;
                        p_next_node = (rrm_ue_procedure_record_t *)ylNext(&p_rrm_ue_procedure_record->s_node);
                        if (RRC_RRM_MEAS_CONFIG_REQ == p_rrm_ue_procedure_record->proc_queue.api_id)
                        {
                            p_cgi_node = (rrm_ue_meas_config_cgi_queue_node_t*)p_rrm_ue_procedure_record->proc_queue.p_proc_data;
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Deleting queued procedure for CGI Req for ARFCN = %d, MeasId = %d"
                                    " as corresponding meas object is being removed", p_cgi_node->arfcn,
                                    meas_id + RRM_ONE);

                            ylDelete(&p_g_rrm_ue_ctx->p_ue_context->procedure_queue, &p_rrm_ue_procedure_record->s_node);
                            RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
                            RRM_MEM_FREE(p_rrm_ue_procedure_record);
                        }
                        p_g_rrm_ue_ctx->p_ue_context->p_proc_queue_first_meas_node = p_next_node;
                    }
                    /* CSR00069389 End */
                    rrm_uem_reset_meas_config_struct(&p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id]);
                }
                else
                {
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status = RRM_MEAS_CONFIG_NULL;
                    /* Spr 18488 Changes Start */
                    p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].report_id   = RRM_NULL;
                    /* Spr 18488 Changes End */
                }
                /* SPR 17837 FIX START */
                /* Code Deleted */
                /* SPR 17837 FIX END */

            }
            else
            {
                /* Reverting to the previous value */
                p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].meas_config_status = RRM_MEAS_CONFIG_RESP_SUCCESS;
                p_g_rrm_ue_ctx->p_ue_context->p_meas_config[meas_id].obj_created_at_ue = RRM_TRUE;
            }
        }
        /* SPR 21496 Fix End */ 
        /* SPR_16053_Fix: End */

    }
    meas_id = RRM_ZERO;
    if (RRM_SUCCESS == p_proc_data->response)
    {
        p_g_rrm_ue_ctx->p_ue_context->meas_status = RRM_MEAS_CONFIG_RESP_SUCCESS;
        update_meas_config_status( p_g_rrm_ue_ctx->p_ue_context, 
                &is_ecid_meas_resp,
                &meas_id,
                &ecid_meas_resp_action);  

        /* SPR-18789 START*/
        if((p_g_rrm_ue_ctx->rrm_uem_rach_info_data.is_ue_rach_report_active == RRM_TRUE)
                && (p_g_rrm_ue_ctx->p_ue_context->temp_rach_data.is_rach_report_config_to_remove == RRM_TRUE))
        {
            p_g_rrm_ue_ctx->p_ue_context->temp_rach_data.is_rach_report_config_to_remove = RRM_FALSE;
            p_g_rrm_ue_ctx->p_ue_context->temp_rach_data.meas_id = RRM_NULL;
            p_g_rrm_ue_ctx->p_ue_context->temp_rach_data.report_config_id = RRM_NULL;
        }
        /* SPR-18789 END*/
    }
    else
    {
        /*SPR_17047_START*/
        if(RRM_FALSE == req_for_cgi)
        {
            p_g_rrm_ue_ctx->p_ue_context->meas_gap_sent_status = RRM_SET_INVALID;
        }
        /*SPR_17047_END*/
        /* SPR_16053_Fix: Start */
        if(p_proc_data->cause.value == RADIO_CONNECTION_WITH_UE_LOST)   /* 21 is s1ap_radio_connection_with_ue_lost*/
        {
            p_g_rrm_ue_ctx->p_ue_context->current_procedure.state = RRM_UE_REESTABLISH_PROCEDURE_ONGOING;
        }
        /* SPR_16053_Fix: End */

        p_g_rrm_ue_ctx->p_ue_context->meas_status = RRM_MEAS_CONFIG_RESP_FAILED;
        update_meas_config_status( p_g_rrm_ue_ctx->p_ue_context, 
                &is_ecid_meas_resp,
                &meas_id,
                &ecid_meas_resp_action);  
    }
    if(RRM_TRUE == is_ecid_meas_resp)
    {
        rrm_ue_process_meas_resp_for_ue_pos(p_g_rrm_ue_ctx->p_ue_context,
                meas_id,
                ecid_meas_resp_action);
    }
    /* SPR 16406 21AUG Start */
    /* SPR 16406 8SEP start */
    /* SPR 17784 Start */
    /*Code Moved in update_meas_config_status function*/
    /* SPR 17784 End */  
    /* SPR 16406 21AUG End */
    if(RRM_FALSE == meas_resp_valid)
    {
        /* CSR00069389 Start */
        /*SPR 17061 Start*/
        /*  SPR 15397 Start */		
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Meas Config Resp has been received for HO "
                "for UE index = %d, current procedure state = %u",  p_g_rrm_ue_ctx->p_ue_context->ue_index,  p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state);
        /*  SPR 15397 End */
        /*SPR 17061 End*/
        /* SPR_15771_Fix: Start */
        /* Code Deleted */
        /* SPR_15771_Fix: End */
        /* CSR00069389 End */
    }
    /* End CSR: 00058590 */

    /* CSR00069389 Start */
    /* SPR 15441 start */    
    /* code removed */
    /* SPR 15441 start */    
    /* Update the awaited state and current state */
    /*SPR 15793 +-*/
    /* SPR 15763 START */
    /* SPR 16406 21AUG Start */
    /* Code Removed */
    /* SPR 16406 21AUG End */
    if (RRM_UE_MEAS_CONFIG_REQ_ONGOING == p_g_rrm_ue_ctx->p_ue_context->current_procedure.state)
        p_g_rrm_ue_ctx->p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
    /* SPR 15763 END */

    /* SPR 15860 Start */
    /* SPR 15861 Start */
    /* SPR 15862 Start */

    /* SPR 15843 Start */
    /// We should check here whether DRX is configured and no CGI Report is pending.
    /// This is needed to ensure that DRX is released when A2 is received while ANR CGI Procedure
    /// is going on. ANR objects are removed when A2 is received but CDRX is not released
    ///
    //
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
            "p_g_rrm_ue_ctx->p_ue_context->current_procedure.state = %u, p_g_rrm_ue_ctx->p_ue_context->cdrx_status = %u",
            p_g_rrm_ue_ctx->p_ue_context->current_procedure.state, p_g_rrm_ue_ctx->p_ue_context->cdrx_status);
    /* SPR 16053 start */
    /* Checking if the CGI is configured then flag needs to be set else the flag needs to be reset
     * only if CGI is not configured and UE supports autonomous gap
     * In case of autonomous gap supported UE the flag will be set or reset
     * during the configurtion and reversal of DRX */

    is_cgi_config_pending = rrm_uem_check_is_cgi_config_pending(p_g_rrm_ue_ctx->p_ue_context);
    if (RRM_TRUE == is_cgi_config_pending)
    {
        p_g_rrm_ue_ctx->p_ue_context->is_cgi_process_in_progress = RRM_TRUE;
    }
    else
    {
        if (RRM_UE_CDRX_DISABLED == p_g_rrm_ue_ctx->p_ue_context->cdrx_status)
        {
            p_g_rrm_ue_ctx->p_ue_context->is_cgi_process_in_progress = RRM_FALSE;
        }
    }
    /* SPR 16053 end */

    if((p_g_rrm_ue_ctx->p_ue_context->current_procedure.state == RRM_UE_ERB_NULL) && 
            (RRM_UE_CDRX_APPLIED == p_g_rrm_ue_ctx->p_ue_context->cdrx_status))
    {
        if(RRM_FALSE == is_cgi_config_pending)
        {
            p_g_rrm_ue_ctx->p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_REMOVED;

            /* Remove DRX as CGIs have been reported */
            if (RRM_FAILURE == rrm_build_and_send_ue_reconfig_req(p_g_rrm_ue_ctx->p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send UE reconfig request to remove CDRX, UE index[%d]",
                        p_g_rrm_ue_ctx->p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE reconfig request sent to UE index[%d] to remove CDRX ",
                        p_g_rrm_ue_ctx->p_ue_context->ue_index);
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "CGI Reports are Pending");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Either CDRX is other than Applied or current procedure state is not NULL");
    }

    /* SPR 15843 End */

    /* SPR 15860 End */
    /* SPR 15861 End */
    /* SPR 15862 End */
    /** if queue not empty then dequeue the events */

    /*SPR 18241 START*/
    if ((rrm_get_queue_count(&p_g_rrm_ue_ctx->p_ue_context->procedure_queue))&&
            (RRM_UE_ERB_NULL == p_g_rrm_ue_ctx->p_ue_context->current_procedure.state))
        /*SPR 18241 END*/
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], dequeue queued message",
                p_g_rrm_ue_ctx->p_ue_context->ue_index);
        /** Dequeue the events from event queue and call message handler */
        /* SPR 15849 Start */
        p_rrm_ue_procedure_record = rrm_request_dequeue( p_g_rrm_ue_ctx->p_ue_context);
        /* SPR 15849 End */
        if(RRM_PNULL != p_rrm_ue_procedure_record)
        {
            rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Procedure queue is empty for UE_INDEX[%d]", p_g_rrm_ue_ctx->p_ue_context->ue_index);
    }
    /* CSR00069389 End */


    /** if queue is not empty, then dequeue the ESMLC meas request */
    if (rrm_get_queue_count(&p_g_rrm_ue_ctx->p_ue_context->esmlc_meas_req_queue))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], dequeue queued \
                message", p_g_rrm_ue_ctx->p_ue_context->ue_index);

        /** Dequeue the events from event queue and call message handler */
   /* SPR 20125 Fix Start */
   /* Code Deleted */
   p_rrm_ue_procedure_record = rrm_request_esmlc_dequeue(p_g_rrm_ue_ctx->p_ue_context);
   /* SPR 20125 Fix End */
        /*LTE_RRM_KLOCWORK_WARN_6_JULY_12_START*/
        if(RRM_PNULL != p_rrm_ue_procedure_record)
        { 
            p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data = 
                p_rrm_ue_procedure_record->proc_queue.p_proc_data;
            rrm_ue_handle_dequeued_esmlc_meas_req(p_rrm_ue_procedure_record->proc_queue.api_id, 
                    p_g_rrm_ue_ctx);
            /* SPR 15441 start */
            RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
            RRM_MEM_FREE(p_rrm_ue_procedure_record);
            p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data = RRM_PNULL;
            /* SPR 15441 end */
            /* Coverity 75023 Fix Start */
            /* Coverity 75023 Fix End */
        }
        /*LTE_RRM_KLOCWORK_WARN_6_JULY_12_END*/
    }

    /* SPR 16053 start */
    if (RRM_FALSE == req_for_cgi)
    {
        rrm_update_interfreq_interrat_info(p_g_rrm_ue_ctx->p_ue_context);
    }
    /* SPR 16053 end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_ho_restriction_ind 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_config_resp message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ho_restriction_ind(
        rrm_ue_global_context_t *p_g_rrm_ue_ctx
        )
{
    rrm_ue_proc_ho_restriction_list_t   *p_proc_data    = RRM_PNULL;
    rrm_return_et                       ret_val         = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_proc_data = (rrm_ue_proc_ho_restriction_list_t *)
        p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data;

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
            "HO_RESTRICTION IND for UE index = %d",
            p_g_rrm_ue_ctx->p_ue_context->ue_index);

    /*SPR 21848 Start*/
    rrm_ue_fill_restriction_list_from_proc_data_to_ue_context(&p_g_rrm_ue_ctx->p_ue_context->ho_restriction_list,
            &p_proc_data->ho_restriction_list);
    rrm_release_ho_restriction_list(&p_proc_data->ho_restriction_list);
    /*SPR 21848 End*/
    /* SPR 15441 start */ 
    /* code removed */
    /* SPR 15441 end */ 
    return ret_val;

}

/****************************************************************************
 * Function Name  : rrm_ue_populate_eutran_nbr_list
 * Inputs         : utran_count - No. of EUTRAN elements in the list 
 *                  p_ue_utran_nbr_list - Pointer to EUtran list received from 
 *                  RRC
 * Outputs        : p_ue_meas_results_ind - Pointer to the EUtran list to be sent
 *                  to RMIF
 * Returns        : None
 * Description    : Populates the meas_results_ind message to be sent to RMIF
 ****************************************************************************/
rrm_void_t
rrm_ue_populate_eutran_nbr_list(
        rrm_son_eutran_neighbor_cell_t  *p_ue_eutran_nbr_list,
        rrm_ue_measurment_results_ind_t *p_proc_data,
        rrm_ue_context_t                *p_ue_context
        )
{
    U8          eutran_index = RRM_NULL;
    rrm_son_eutran_neighbor_cell_t  *p_proc_eutran_nbr_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();	
    p_proc_eutran_nbr_list = p_proc_data->eutran_neighbor_list;

    for(eutran_index = RRM_ZERO; eutran_index < p_proc_data->eutran_count; eutran_index++)
    {
        p_ue_eutran_nbr_list[eutran_index].bitmask = 
            p_proc_eutran_nbr_list->bitmask;

        p_ue_eutran_nbr_list[eutran_index].pci =
            p_proc_eutran_nbr_list->pci;

        if(RRM_SON_EUTRAN_NC_CGI_PRESENT &
                p_proc_eutran_nbr_list->bitmask)
        {
            /* SPR 16053 start */
            /* Code deleted */
            /* SPR 16053 end */

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Updated Status:");	

            /* SPR 21496 Fix Start */ 
            rrm_ue_print_meas_config_struct(p_ue_context->
                    p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
            /* SPR 21496 Fix End */ 

            RRM_MEMCPY(
                    &p_ue_eutran_nbr_list[eutran_index].cgi,
                    &p_proc_eutran_nbr_list->cgi,
                    sizeof(rrm_oam_eutran_global_cell_id_t));
        }
        if(RRM_SON_EUTRAN_NC_PLMN_PRESENT &
                p_proc_eutran_nbr_list->bitmask)
        {
            p_ue_eutran_nbr_list[eutran_index].num_plmn_id =
                p_proc_eutran_nbr_list->num_plmn_id;

            RRM_MEMCPY(
                    p_ue_eutran_nbr_list[eutran_index].plmn_id,
                    p_proc_eutran_nbr_list->plmn_id,
                    sizeof(p_proc_eutran_nbr_list->plmn_id));
        }
        if(RRM_SON_EUTRAN_NC_TAC_PRESENT &
                p_proc_eutran_nbr_list->bitmask)
        {
            RRM_MEMCPY(
                    p_ue_eutran_nbr_list[eutran_index].tac,
                    p_proc_eutran_nbr_list->tac,
                    sizeof(U8) * MAX_TAC_SIZE);
        }
        if(RRM_SON_EUTRAN_NC_CSG_PRESENT &
                p_proc_eutran_nbr_list->bitmask)
        {
            RRM_MEMCPY(p_ue_eutran_nbr_list[eutran_index].csg_identity,
                    p_proc_eutran_nbr_list->csg_identity,
                    MAX_CELL_IDENTITY_OCTETS);
        }
        if(RRM_SON_EUTRAN_NC_CSG_MEM_STATUS_PRESENT &
                p_proc_eutran_nbr_list->bitmask)
        {
            p_ue_eutran_nbr_list[eutran_index].csg_membershipStatus=
                p_proc_eutran_nbr_list->csg_membershipStatus;
        }
        p_ue_eutran_nbr_list[eutran_index].rsrp =
            p_proc_eutran_nbr_list->rsrp;

        p_ue_eutran_nbr_list[eutran_index].rsrq =
            p_proc_eutran_nbr_list->rsrq;

        p_proc_eutran_nbr_list++;
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_ue_populate_utran_nbr_list
 * Inputs         : utran_count - No. of UTRAN elements in the list 
 *                  p_ue_utran_nbr_list - Pointer to Utran list received from 
 *                  RRC
 * Outputs        : p_ue_meas_results_ind - Pointer to the Utran list to be sent
 *                  to RMIF
 * Returns        : None
 * Description    : Populates the meas_results_ind message to be sent to RMIF
 ****************************************************************************/
rrm_void_t
rrm_ue_populate_utran_nbr_list(
        rrm_son_utran_neighbor_cell_t  *p_ue_utran_nbr_list,
        rrm_ue_measurment_results_ind_t *p_proc_data,
        rrm_ue_context_t                *p_ue_context
        )
{
    U8          utran_index = RRM_NULL;
    rrm_son_utran_neighbor_cell_t  *p_proc_utran_nbr_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_proc_utran_nbr_list = p_proc_data->utran_neighbor_list;

    for(utran_index = RRM_ZERO; utran_index < p_proc_data->utran_count; utran_index++)
    {
        p_ue_utran_nbr_list[utran_index].bitmask = 
            p_proc_utran_nbr_list->bitmask;

        RRM_MEMCPY(&p_ue_utran_nbr_list[utran_index].pci,
                &p_proc_utran_nbr_list->pci,
                sizeof(rrm_son_utran_physical_cell_id_t));

        if(RRM_SON_UTRAN_NC_CGI_PRESENT &
                p_proc_utran_nbr_list->bitmask)
        {
            /* SPR 16053 start */
            /* Code deleted */
            /* SPR 16053 end */

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Updated Status:");	

            /* SPR 21496 Fix Start */ 
            rrm_ue_print_meas_config_struct(p_ue_context->
                    p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET]);
            /* SPR 21496 Fix End */ 

            RRM_MEMCPY(
                    &p_ue_utran_nbr_list[utran_index].cgi,
                    &p_proc_utran_nbr_list->cgi,
                    sizeof(rrm_son_utran_geran_global_cell_id_t));
        }
        if(RRM_SON_UTRAN_NC_LAC_PRESENT &
                p_proc_utran_nbr_list->bitmask)
        {
            RRM_MEMCPY(
                    &p_ue_utran_nbr_list[utran_index].lac,
                    &p_proc_utran_nbr_list->lac,
                    sizeof(U8) * MAX_LAC_SIZE);
        }
        if(RRM_SON_UTRAN_NC_LAC_PRESENT &
                p_proc_utran_nbr_list->bitmask)
        {
            p_ue_utran_nbr_list[utran_index].rac =
                p_proc_utran_nbr_list->rac;
        }
        if(RRM_SON_UTRAN_NC_PLMN_PRESENT &
                p_proc_utran_nbr_list->bitmask)
        {
            p_ue_utran_nbr_list[utran_index].num_plmn_id =
                p_proc_utran_nbr_list->num_plmn_id;

            RRM_MEMCPY(
                    p_ue_utran_nbr_list[utran_index].plmn_id,
                    p_proc_utran_nbr_list->plmn_id,
                    sizeof(p_proc_utran_nbr_list->plmn_id));
        }
        if(RRM_SON_UTRAN_NC_CSG_PRESENT &
                p_proc_utran_nbr_list->bitmask)
        {
            RRM_MEMCPY(p_ue_utran_nbr_list[utran_index].csg_identity,
                    p_proc_utran_nbr_list->csg_identity,
                    MAX_CELL_IDENTITY_OCTETS);
        }
        if(RRM_SON_UTRAN_NC_CSG_MEM_STATUS_PRESENT &
                p_proc_utran_nbr_list->bitmask)
        {
            p_ue_utran_nbr_list[utran_index].csg_membershipStatus =
                p_proc_utran_nbr_list->csg_membershipStatus;
        }
        p_ue_utran_nbr_list[utran_index].rscp =
            p_proc_utran_nbr_list->rscp;

        p_ue_utran_nbr_list[utran_index].ecno =
            p_proc_utran_nbr_list->ecno;

        p_proc_utran_nbr_list++;
    }
    RRM_UT_TRACE_EXIT();
}

rrm_void_t
rrm_ue_populate_geran_nbr_list(
        rrm_son_geran_neighbor_cell_t  *p_ue_geran_nbr_list,
        rrm_ue_measurment_results_ind_t *p_proc_data
        /*SPR 17777 +-*/
        )
{
    U8          geran_index = RRM_NULL;
    rrm_son_geran_neighbor_cell_t  *p_proc_geran_nbr_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_proc_geran_nbr_list = p_proc_data->geran_neighbor_list;

    for(geran_index = RRM_ZERO; geran_index < p_proc_data->geran_count; geran_index++)
    {
        p_ue_geran_nbr_list[geran_index].bitmask =
            p_proc_geran_nbr_list->bitmask;

        p_ue_geran_nbr_list[geran_index].arfcn =
            p_proc_geran_nbr_list->arfcn;

        p_ue_geran_nbr_list[geran_index].band_ind =
            p_proc_geran_nbr_list->band_ind;

        RRM_MEMCPY(&p_ue_geran_nbr_list[geran_index].pci,
                &p_proc_geran_nbr_list->pci,
                sizeof(rrm_son_geran_physical_cell_id_t));

        if(RRM_SON_GERAN_MR_IND_CGI_INFO_PRESENT &
                p_proc_geran_nbr_list->bitmask)
        {
            /* SPR 16053 start */
            /* Code deleted */
            /* SPR 16053 end */

            RRM_MEMCPY(
                    &p_ue_geran_nbr_list[geran_index].cgi,
                    &p_proc_geran_nbr_list->cgi,
                    sizeof(rrm_son_utran_geran_global_cell_id_t));
        }
        if(RRM_SON_GERAN_MR_IND_RAC_PRESENT &
                p_proc_geran_nbr_list->bitmask)
        {
            p_ue_geran_nbr_list[geran_index].rac = p_proc_geran_nbr_list->rac;
        }
        p_ue_geran_nbr_list[geran_index].rssi = p_proc_geran_nbr_list->rssi;

        p_proc_geran_nbr_list++;
    }
    RRM_UT_TRACE_EXIT();
}

rrm_void_t
rrm_ue_populate_cdma2000_nbr_list(
        rrm_son_cdma_neighbor_cell_t  *p_ue_cdma_nbr_list,
        rrm_ue_measurment_results_ind_t *p_proc_data,
        rrm_ue_context_t                *p_ue_context
        )
{
    U8          cdma_index = RRM_NULL;
    U8          index = RRM_NULL;
    rrm_ue_meas_result_cdma2000_t  *p_proc_cdma_nbr_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_proc_cdma_nbr_list = p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.meas_result_cdma2000;

    for(cdma_index = RRM_ZERO; cdma_index < p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.cdma2000_count; cdma_index++)
    {
        p_ue_cdma_nbr_list[cdma_index].bitmask =
            p_proc_cdma_nbr_list->bitmask;

        p_ue_cdma_nbr_list[cdma_index].pci =
            p_proc_cdma_nbr_list->phy_cell_id;

        /* SPR 21496 Fix Start */ 
        p_ue_cdma_nbr_list[cdma_index].arfcn =  p_ue_context->
            p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].carr_freq;
        p_ue_cdma_nbr_list[cdma_index].band_class = p_ue_context->
            p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].band_class;
        /* SPR 21496 Fix End */ 
        if(RRM_UEM_MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT &
                p_proc_cdma_nbr_list->bitmask)
        {
            p_ue_cdma_nbr_list[cdma_index].bitmask |=
                RRM_SON_CDMA_MEAS_IND_CGI_INFO_PRESENT;
            /* SPR 16053 start */
            /* Code deleted */
            /* SPR 16053 end */

            if(RRM_UEM_CELL_GLOBAL_ID_CDMA2000_1XRTT_PRESENT & 
                    p_proc_cdma_nbr_list->cgi_info.bitmask)
            {

                p_ue_cdma_nbr_list[cdma_index].cgi.bitmask = 
                    RRM_SON_CGI_1X_RTT_PRESENT;

                for(index = RRM_ZERO; index < RRM_SON_CELL_GLOBAL_ID_1X_RTT_SIZE; index++)
                {
                    p_ue_cdma_nbr_list[cdma_index].cgi.cell_global_id_1X_RTT[index] = 
                        p_proc_cdma_nbr_list->cgi_info.cell_global_id_1xrtt[index];
                }

            }
            else if(RRM_UEM_CELL_GLOBAL_ID_CDMA2000_HRPD_PRESENT & 
                    p_proc_cdma_nbr_list->cgi_info.bitmask)
            {

                p_ue_cdma_nbr_list[cdma_index].cgi.bitmask = 
                    RRM_SON_CGI_HRPD_PRESENT;

                for(index= RRM_ZERO;index <RRM_SON_CELL_GLOBAL_ID_HRPD_SIZE ;index++)
                {
                    p_ue_cdma_nbr_list[cdma_index].cgi.cell_global_id_HRPD[index] = 
                        p_proc_cdma_nbr_list->cgi_info.cell_global_id_hrpd[index];
                }
            }
        }

        if(RRM_UEM_MEAS_RESULT_CDMA2000_PILOT_PN_PHASE_PRESENT &
                p_proc_cdma_nbr_list->meas_result.bitmask)
        {
            p_ue_cdma_nbr_list[cdma_index].bitmask |=
                RRM_SON_MEAS_RESULT_CDMA2000_PILOT_PN_PHASE_PRESENT;

            p_ue_cdma_nbr_list[cdma_index].pilot_pn_phase =
                p_proc_cdma_nbr_list->meas_result.pilot_pn_phase;

        }

        p_ue_cdma_nbr_list[cdma_index].pilot_strength =
            p_proc_cdma_nbr_list->meas_result.pilot_strength;

        p_proc_cdma_nbr_list++;
    }
    RRM_UT_TRACE_EXIT();
}

/* BLR Team HO status report to SON Changes Start */
/* SPR 17108 FIX START*/
/****************************************************************************
 * Function Name  : rrm_ue_populate_rrmif_handover_report
 * Inputs                 p_ue_context - Pointer to the UE context for which meas
 *                  results are being populated
 *                  p_target_id  - Pointer to the target cellId
 *                  p_phy_cell_id_info - Pointer to structure which
 *                  contains PCI and frequency.    
 * Outputs        : p_ue_handover_report - Pointer to the Msg data to be sent
 *                  to RMIF
 * Returns        : Success/Failure
 * Description    : Populates the handover_report  message to be sent to RMIF
 ****************************************************************************/
/* SPR 17108 FIX END*/
rrm_void_t
rrm_ue_populate_rrmif_handover_report(
        rrm_ue_context_t              *p_rrm_ue_context,
        rrm_target_id_t               *p_target_id,
        /* SPR 17108 FIX START*/
        phy_cell_id_info_t            *p_phy_cell_id_info 
        /* SPR 17108 FIX END*/
        )
{
    U8                        iterator          = RRM_ZERO;
    rrm_cell_context_t       *p_cell_ctxt = RRM_PNULL;
    U8                        num_mnc_digit= RRM_ZERO;
    U8                        index= RRM_ZERO;
    S16                       intr_freq_index = RRM_NULL;
    U8                        irat_count = RRM_ZERO;
    /*SPR 20523 START*/
    S8                        actual_cm_offset_freq_value = RRM_ZERO;
    /*SPR 20523 END*/
    inter_rat_ncl_t           *p_ncl_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    if( RRM_PNULL != p_rrm_ue_context)
    {
        /*coverity 25402: p_epc_params removed, , rel 1.3.1*/
	/* SPR 19838 : CID 12746 Fix Start */
        /* Code Removed */
	/* SPR 19838 : CID 12746 Fix End */
        p_cell_ctxt  = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
        p_ncl_params = rrm_cellm_get_inter_rat_ncl_info(p_rrm_ue_context->cell_index);
        /*CID 65788:start*/
        if (RRM_PNULL != p_cell_ctxt)
        {
            RRM_MEMCPY(&p_rrm_ue_context->ue_handover_report.src_cgi.cell_identity,
                    p_cell_ctxt->global_cell_id.cell_identity,
                    sizeof(p_rrm_ue_context->ue_handover_report.src_cgi.cell_identity));

            /* Fix for coverity, LTE_RRM_MALL:CID:11178 [Prasant] */
            RRM_MEMCPY(&p_rrm_ue_context->ue_handover_report.src_cgi.primary_plmn_id.mcc,
                    &p_cell_ctxt->global_cell_id.primary_plmn_id.mcc,
                    (sizeof(U8)*MCC_OCTET_SIZE));

            num_mnc_digit = p_cell_ctxt->global_cell_id.primary_plmn_id.num_mnc_digit;

            if (num_mnc_digit > MAX_MNC_OCTET_SIZE) {
                RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name,
                        RRM_ERROR,
                        "Invalid MNC Digit count (%d),"
                        "Should be less than %d, Dropping the remaining digits",
                        num_mnc_digit,MAX_MNC_OCTET_SIZE);
                num_mnc_digit = MAX_MNC_OCTET_SIZE;
            }

            for( iterator =RRM_ZERO;iterator< num_mnc_digit;
                    iterator++)
            {
                p_rrm_ue_context->ue_handover_report.src_cgi.primary_plmn_id.mnc[iterator] =\
                                                                                            p_cell_ctxt->global_cell_id.primary_plmn_id.mnc[iterator];
            }

            p_rrm_ue_context->ue_handover_report.src_cgi.primary_plmn_id.num_mnc_digit = num_mnc_digit;


            if (p_target_id->bitmask & RRM_TARGET_ID_ENB_ID_PRESENT)
            {
                p_rrm_ue_context->ue_handover_report.trgt_cgi.bitmask |= RRM_INTRA_RAT_GLOBAL_CELL_ID_PRESENT;
                for (iterator = RRM_ZERO; iterator < MAX_MCC_DIGITS; iterator++)
                {
                    p_rrm_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id.primary_plmn_id.
                        mcc[iterator] = p_target_id->enb_id.global_enb_id.plmn_identity.mcc[iterator];
                }
                p_rrm_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id.primary_plmn_id.
                    num_mnc_digit = p_target_id->enb_id.global_enb_id.plmn_identity.mnc.count;
                for (iterator = RRM_ZERO; iterator < p_rrm_ue_context->ue_handover_report.trgt_cgi.\
                        intra_rat_global_cell_id.primary_plmn_id.num_mnc_digit; iterator++)
                {
                    p_rrm_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id.primary_plmn_id.
                        mnc[iterator] = p_target_id->enb_id.global_enb_id.plmn_identity.mnc.mnc[iterator];
                }

                RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id.cell_identity,
                        p_target_id->enb_id.global_enb_id.cell_identity,
                        (sizeof(U8)*MAX_CELL_IDENTITY_OCTETS));

                p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.bitmask |= RRM_EUTRAN_STRENGTH_RSRP_PRESENT;
                p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.bitmask |= RRM_EUTRAN_STRENGTH_RSRQ_PRESENT;
                p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.rsrp = p_rrm_ue_context->meas_result_serv_cell.rsrp_result;
                p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.rsrq = p_rrm_ue_context->meas_result_serv_cell.rsrq_result;

                /* SPR 16406 Start */
                for (index=RRM_ZERO;(index < p_rrm_ue_context->ho_params.eutra_known_cell_selection_list.count) && (index <MAX_NEIGH_CELL);index++)
                {
                    /* SPR 15232 start */
                    /* SPR 17108 FIX START*/
                    if((p_rrm_ue_context->ho_params.eutra_known_cell_selection_list.reported_neighbor_cell_info[index].phy_cell_id == p_phy_cell_id_info->phy_cell_id) &&
                            (p_rrm_ue_context->ho_params.eutra_known_cell_selection_list.reported_neighbor_cell_info[index].target_earfcn == p_phy_cell_id_info->carr_earfcn))
                        /* SPR 17108 FIX END*/
                        /* SPR 15232 end */
                    {
                        p_rrm_ue_context->ue_handover_report.trgt_cell_meas_strgth.choice = RRM_EUTRAN_TRGT_CELL_STRENGTH;
                        if(p_rrm_ue_context->trigger_quantity == RRM_RRC_RSRP)
                        {
                            p_rrm_ue_context->ue_handover_report.trgt_cell_meas_strgth.u.eutran_cell_strength.bitmask =RRM_EUTRAN_STRENGTH_RSRP_PRESENT;
                            p_rrm_ue_context->ue_handover_report.trgt_cell_meas_strgth.u.eutran_cell_strength.rsrp =
                                /* SPR 15232 start */
                                p_rrm_ue_context->ho_params.eutra_known_cell_selection_list.reported_neighbor_cell_info[index].rsrx_value;	
                            /* SPR 15232 end */
                        }
                        else
                        {
                            p_rrm_ue_context->ue_handover_report.trgt_cell_meas_strgth.u.eutran_cell_strength.bitmask =RRM_EUTRAN_STRENGTH_RSRQ_PRESENT;
                            p_rrm_ue_context->ue_handover_report.trgt_cell_meas_strgth.u.eutran_cell_strength.rsrq =
                                /* SPR 15232 start */
                                p_rrm_ue_context->ho_params.eutra_known_cell_selection_list.reported_neighbor_cell_info[index].rsrx_value;	
                            /* SPR 15232 end */
                        }
                        break;
                    }
                }
            }
            /* SPR 16406 End */
            else if(p_target_id->bitmask & RRM_TARGET_ID_RNC_ID_PRESENT)
            {
                p_rrm_ue_context->ue_handover_report.trgt_cgi.bitmask |= RRM_INTER_RAT_GLOBAL_CELL_ID_PRESENT;
                p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.bitmask |=
                    RRM_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT;

                p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                    utran_geran_global_cell_id.rat_type = RRM_UTRAN_CELL;

                RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                        utran_geran_global_cell_id.plmn_id.mcc,\
                        p_target_id->rnc_id.lai.plmn_identity.mcc,\
                        (sizeof(U8)*MCC_OCTET_SIZE));

                p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.\
                    utran_geran_global_cell_id.plmn_id.num_mnc_digit = 
                    p_target_id->rnc_id.lai.plmn_identity.mnc.count;

                RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                        utran_geran_global_cell_id.plmn_id.mnc,
                        p_target_id->rnc_id.lai.plmn_identity.mnc.mnc,
                        (p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                         utran_geran_global_cell_id.plmn_id.\
                         num_mnc_digit));

                /* SPR 8628 start */
                for(irat_count = 0; \
                        irat_count < p_ncl_params->num_valid_utran_freq_cell;
                        irat_count++)
                {
                    /* SPR 17108 FIX START*/
                    if((p_phy_cell_id_info->phy_cell_id == p_ncl_params->utran_freq_cells[irat_count].pcpich_scrambling_code) &&
                            (p_ncl_params->utran_freq_cells[irat_count].uarfcndl == p_phy_cell_id_info->carr_earfcn))
                    {
                        RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id. \
                                utran_geran_global_cell_id.cell_identity,
                                p_ncl_params->utran_freq_cells[irat_count].uc_id.cell_id_merge,
                                RRM_MERGED_UTRAN_CELL_IDENTITY_OCTETS);
                        break;
                    }
                    /* SPR 17108 FIX END*/
                }
                /* SPR 8628 end */
            }
            else if(p_target_id->bitmask & RRM_TARGET_ID_CGI_PRESENT)
            {
                /* SPR 17108 FIX START*/
                for(irat_count = 0; \
                        irat_count < p_ncl_params->num_valid_geran_cell;
                        irat_count++)
                {
                    if((p_phy_cell_id_info->phy_cell_id == p_ncl_params->geran_freq_cells[irat_count].pci) &&
                            (p_phy_cell_id_info->carr_earfcn == p_ncl_params->geran_freq_cells[irat_count].bcch_arfcn))
                    {
                        /* SPR 17108 FIX END*/
                        p_rrm_ue_context->ue_handover_report.trgt_cgi.bitmask |= RRM_INTER_RAT_GLOBAL_CELL_ID_PRESENT;
                        p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.bitmask |=
                            RRM_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT;

                        p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                            utran_geran_global_cell_id.rat_type = RRM_GERAN_CELL;
                        RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                                utran_geran_global_cell_id.plmn_id.mcc,\
                                p_target_id->cgi.plmn_identity.mcc,\
                                MCC_OCTET_SIZE);

                        p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.\
                            utran_geran_global_cell_id.plmn_id.num_mnc_digit = 
                            p_target_id->cgi.plmn_identity.mnc.count;

                        RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id.
                                utran_geran_global_cell_id.plmn_id.mnc,
                                p_target_id->cgi.plmn_identity.mnc.mnc,
                                p_target_id->cgi.plmn_identity.mnc.count);
                        /* SPR 17108 FIX START*/
                        RRM_MEMCPY(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id. \
                                utran_geran_global_cell_id.cell_identity,
                                &(p_ncl_params->geran_freq_cells[irat_count].lai.lac), (sizeof(U8) * RRM_OAM_MAX_NUM_LAC_OCTETS));

                        RRM_MEMCPY(&(p_rrm_ue_context->ue_handover_report.trgt_cgi.inter_rat_global_cell_id. \
                                    utran_geran_global_cell_id.cell_identity[RRM_TWO]),
                                &(p_ncl_params->geran_freq_cells[irat_count].cell_id), (sizeof(U8) * RRM_UTRAN_CELL_IDENTITY_OCTETS));

                    }
                }
                /* SPR 17108 FIX END*/

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
                        "Target cell id is not EUTRA or UTRAN or GERAN type");
            }

            /* MLB Changes start */
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.bitmask |= RRM_EUTRAN_STRENGTH_OFFSET_ATT_PRESENT;
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.bitmask |= RRM_OFFSET_ATTR_HYS_PRESENT;
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.hys =
                p_cell_ctxt->ran_info.connected_mode_mobility_params.common_params_for_eutra.hysteresis;
            if (p_cell_ctxt->ran_info.mobility_params.bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT)
            {
                /* Finding the index of inter freq param */
                intr_freq_index = rrmcm_search_earfcn_in_cell_context(p_cell_ctxt, p_rrm_ue_context->carrier_earfcn);
                /* , rel2.0.1, 29791, if added*/
                if(-1 != intr_freq_index)
                {
                    p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.bitmask |= RRM_OFFSET_ATTR_OFN_PRESENT;
                    /*SPR 20523 START*/
                    actual_cm_offset_freq_value = rrm_ue_convert_actual_qoffset_value(RRM_EUTRAN_CELL,p_cell_ctxt->ran_info.mobility_params.idle_mode_mobility_params.
                            idle_mode_mobility_inter_freq_params[intr_freq_index].cm_offset_freq);
                    p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.ofn = actual_cm_offset_freq_value;
                    /*SPR 20523 END*/
                }
            }
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.bitmask |= RRM_OFFSET_ATTR_OFF_PRESENT;
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.off =
                p_cell_ctxt->ran_info.connected_mode_mobility_params.common_params_for_eutra.a3_offset;
            /* Filling Dummy value for ofs and ofc. Its not configured right now from OAM */
            /* Whenever OAM will configure these value then need to change */
            /*SPR 20523 START*/
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.bitmask |= RRM_OFFSET_ATTR_OFC_PRESENT;
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.ofs = RRM_EUTRAN_FREQ_OFFSET_0_DB; /* Default Value TS-36.331 */
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.bitmask |= RRM_OFFSET_ATTR_OCS_PRESENT;
            p_rrm_ue_context->ue_handover_report.srv_cell_meas_strgth.offset_attr.ocs = RRM_EUTRAN_FREQ_OFFSET_0_DB; /* Default Value TS-36.331 */
            /*SPR 20523 END*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
        }
        /*CID 65788:end*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
                "p_ue_context is NULL");
    }
    RRM_UT_TRACE_EXIT();
}
/* BLR Team HO status report to SON Changes End */

/* BLR Team missing PCI reporting to SON start */
/* SPR 16406 Start */
/****************************************************************************
 * Function Name  : rrm_ue_populate_and_send_rrmif_meas_results_ind
 * Inputs         : p_ue_context - Pointer to the UE context for which meas
 *                  results are being populated
 * Outputs        : None
 *
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Populates the meas_results_ind message to be sent to RMIF
 ****************************************************************************/
rrm_void_t
rrm_ue_populate_and_send_rrmif_meas_results_ind(
        rrm_ue_context_t                    *p_ue_context,
        rrm_son_meas_results_ind_t          *p_meas_result
        )
{
    U8      index = RRM_NULL;
    U8      count = RRM_NULL;


    rrmuem_rmif_meas_results_ind_t      *p_ue_meas_results_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_ue_meas_results_ind = (rrmuem_rmif_meas_results_ind_t *)rrm_mem_get(sizeof(rrmuem_rmif_meas_results_ind_t));

    if( RRM_PNULL == p_ue_meas_results_ind)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return ;
    }

    RRM_MEMSET(p_ue_meas_results_ind,RRM_ZERO, sizeof(rrmuem_rmif_meas_results_ind_t));

    p_ue_meas_results_ind->cell_index = p_ue_context->cell_index;
    p_ue_meas_results_ind->ue_index   = p_ue_context->ue_index;

    /* SPR 15698 Start */
    /// Fill meas report event in measurement indication being sent to MIF and MIF in turn send this to SON
    /* SPR 16406 8SEP start */
    /*Cov 93558 +*/
    p_ue_meas_results_ind->meas_report_event = (rrmc_meas_report_event_et)p_ue_context->meas_rep_event;
    /*Cov 93558 -*/
    /* SPR 16406 8SEP end */
    /* SPR 15698 End */

    if(p_meas_result->eutran_meas_list[index].neighbor_cell_list_size > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->eutran_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->eutran_meas_list_size;
                index++)
        {
            /* Populate the earfcn value from the carrier freq stored in UE 
               context corresponding to the meas id of results ind */
            p_ue_meas_results_ind->eutran_meas_list[index].earfcn = \
                                                                    p_meas_result->eutran_meas_list[index].earfcn;

            p_ue_meas_results_ind->eutran_meas_list[index].neighbor_cell_list_size = 
                p_meas_result->eutran_meas_list[index].neighbor_cell_list_size;

            for ( count =RRM_ZERO;(count <=p_meas_result->eutran_meas_list[index].\
                        neighbor_cell_list_size && count < RRM_MAX_CELLS_REPORTED);count ++)
            {
                RRM_MEMCPY(&(p_ue_meas_results_ind->eutran_meas_list[index].neighbor_cell_list[count]),
                        &(p_meas_result->eutran_meas_list[index].neighbor_cell_list[count]),
                        sizeof(rrm_son_eutran_neighbor_cell_t));			       
                /* CSR_97730_fix: start */
                /* CGI & TAC are mandatorily sent in CGI reporting in meas results ind */
                p_ue_meas_results_ind->eutran_meas_list[index].neighbor_cell_list[count].bitmask |= RRM_SON_EUTRAN_NC_CGI_PRESENT;

                p_ue_meas_results_ind->eutran_meas_list[index].neighbor_cell_list[count].bitmask |= RRM_SON_EUTRAN_NC_TAC_PRESENT;
                /* CSR_97730_fix: end */
            }
        }
    }
    else if(p_meas_result->utran_meas[index].neighbor_cell_list_size> RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->utran_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->utran_meas_list_size;
                index++)
        {
            /* Populate the uarfcn value from the carrier freq stored in UE 
               context corresponding to the meas id of results ind */
            p_ue_meas_results_ind->utran_meas[index].uarfcn = 
                p_meas_result->utran_meas[index].uarfcn;

            p_ue_meas_results_ind->utran_meas[index].neighbor_cell_list_size =
                p_meas_result->utran_meas[index].neighbor_cell_list_size;

            for ( count =RRM_ZERO;count <=p_meas_result->utran_meas[index].\
                    neighbor_cell_list_size && count < RRM_MAX_CELLS_REPORTED;count ++)
            {
                RRM_MEMCPY(&(p_ue_meas_results_ind->utran_meas[index].neighbor_cell_list[count]),
                        &(p_meas_result->utran_meas[index].neighbor_cell_list[count]),
                        sizeof(rrm_son_utran_neighbor_cell_t));			       

                /* SPR_14564_fix: start */
                /* for UTRA CGI is only present mandatorily in case CGI for UTRA is configured. For other
                 * fields to be sent SON, bitmasks need to be checked first then packed in API.
                 */
                p_ue_meas_results_ind->utran_meas[index].neighbor_cell_list[count].bitmask |= RRM_SON_UTRAN_NC_CGI_PRESENT; 
                /* SPR_14564_fix: end */
            }
        }
    }
    else if(p_meas_result->geran_meas[index].neighbor_cell_list_size > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->geran_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->geran_meas_list_size;
                index++)
        {
            /* Populate the arfcn value from the carrier freq stored in UE
               context corresponding to the meas id of results ind */

            p_ue_meas_results_ind->geran_meas[index].neighbor_cell_list_size =\
                                                                              p_meas_result->geran_meas[index].neighbor_cell_list_size;

            for ( count =RRM_ZERO;count <=p_meas_result->geran_meas[index].\
                    neighbor_cell_list_size && count < RRM_MAX_CELLS_REPORTED;count ++)
            {
                RRM_MEMCPY(&(p_ue_meas_results_ind->geran_meas[index].neighbor_cell_list[count]),
                        &(p_meas_result->geran_meas[index].neighbor_cell_list[count]),
                        sizeof(rrm_son_geran_neighbor_cell_t));			       

            }
        }
    }
    else if(p_meas_result->cdma_meas[index].neighbor_cell_list_size > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->cdma_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->cdma_meas_list_size;
                index++)
        {
            /* Populate the arfcn value from the carrier freq stored in UE
               context corresponding to the meas id of results ind */

            p_ue_meas_results_ind->cdma_meas[index].neighbor_cell_list_size =\
                                                                             p_meas_result->cdma_meas[index].neighbor_cell_list_size;

            for ( count =RRM_ZERO;count <=p_meas_result->cdma_meas[index].\
                    neighbor_cell_list_size && count < RRM_MAX_CELLS_REPORTED;count ++)
            {
                RRM_MEMCPY(&(p_ue_meas_results_ind->cdma_meas[index].neighbor_cell_list[count]),
                        &(p_meas_result->cdma_meas[index].neighbor_cell_list[count]),
                        sizeof(rrm_son_cdma_neighbor_cell_t));			       

            }
        }
    }



    else {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "No new Neighbours are detected as part of received event!");
    }
    if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                RRMUEM_RMIF_MEAS_RESULTS_IND, sizeof(rrmuem_rmif_meas_results_ind_t),
                (void *)(p_ue_meas_results_ind)))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Sent MEAS RESULTS IND with new PCIs for  UE_INDEX[%d]",
                p_ue_context->ue_index); 
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Failed to send MEAS RESULTS IND with new PCIs for UE_INDEX[%d] ",
                p_ue_context->ue_index);
    }
    RRM_MEM_FREE(p_ue_meas_results_ind);
    RRM_UT_TRACE_EXIT();
}
/* SPR 16406 End */

/* SPR 16406 Start */
/****************************************************************************
 * Function Name  : rrm_get_cgi_meas_node_for_meas_id 
 * Inputs         : meas_id , p_ue_context - Pointer to the UE context for which meas
 *                  results are being populated
 * Outputs        : None
 * Returns        : meas_report_info_node_t* type node 
 * Description    : returns node of report corresponding to input meas_id 
 ****************************************************************************/
    meas_report_info_node_t* 
rrm_get_cgi_meas_node_for_meas_id(U8                        meas_id,
        rrm_ue_context_t*         p_ue_context)
{
    meas_report_info_node_t *p_meas_report_info = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_meas_report_info = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));

    while (p_meas_report_info) 
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "report_measid[%d], measid[%d] is_report_pending[%d]\n",
                p_meas_report_info->meas_id,meas_id,
                p_meas_report_info->is_meas_report_pending);
        if ((p_meas_report_info->meas_id == meas_id) &&
                (p_meas_report_info->is_meas_report_pending == RRM_TRUE)) 
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas ID %d found in the list.", meas_id);
            /* SPR 16406 8SEP start */
            RRM_UT_TRACE_EXIT();
            return p_meas_report_info;
            /* SPR 16406 8SEP end */
        }
        p_meas_report_info = (meas_report_info_node_t*)ylNext(&p_meas_report_info->sNode);
    }
    /* SPR 16406 8SEP start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
            "Meas ID %d not found in the list.", meas_id);
    /* SPR 16406 8SEP end */

    RRM_UT_TRACE_EXIT();
    return p_meas_report_info;
}
/* SPR 16406 End */
/* BLR Team missing PCI reporting to SON end */
/* SPR 17845 Fix Start */
/****************************************************************************
 * Function Name  : rrm_ue_drop_eutra_daho_cell_for_cgi 
 * Inputs         : rrm_son_eutran_meas_results_t *p_eutran_config_list, 
 *                  cell_index 
 * Outputs        : None
 * Returns        : None
 * Description    : drops daho cell for CGI procedure 
 ****************************************************************************/
rrm_void_t
rrm_ue_drop_eutra_daho_cell_for_cgi
(
 rrm_son_eutran_meas_results_t *p_eutran_config_list,
 rrm_cell_index_t cell_index
 )
{
    rrm_daho_cell_config_info_t     *p_daho_cfg = RRM_PNULL;
    rrm_cell_context_t              *p_cell_ctxt = RRM_PNULL;
    rrm_counter_t                   index = RRM_ZERO;
    rrm_counter_t                   index1 = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return;
    }
    /* extract daho configuration */

    p_daho_cfg = rrm_cellm_get_daho_cell_config_info_params(cell_index);

    if(RRM_PNULL == p_daho_cfg)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "daho configuration not found for cell[%u]", cell_index);
        return;
    }
    else
    {
        for(index = RRM_ZERO; index< (p_eutran_config_list->neighbor_cell_list_size); index++)
        {
            if((EUTRA_DAHO_CELL_PRESENT & p_daho_cfg->bitmask) &&
                    (p_eutran_config_list->neighbor_cell_list[index].pci == \
                     p_daho_cfg->eutran_daho_cell_config_info.phy_cell_id) &&
                    (p_eutran_config_list->earfcn == \
                     p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn))  
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "daho cell[%u] found in CGI request %d", 
                        p_eutran_config_list->neighbor_cell_list[index].pci, 
                        index);
                if(index != (p_eutran_config_list->neighbor_cell_list_size - RRM_ONE))
                {
                    /*Coverity 99446 Fix Start*/
                    /* Coverity CID 99446 Fix Start */
                    for(index1 = index; index1< ((p_eutran_config_list->neighbor_cell_list_size - RRM_ONE) && (index1 < RRM_MAX_CELLS_REPORTED)); index1++)
                    /* Coverity CID 99446 Fix End */
                    /*Coverity 99446 Fix End*/
                    {
                        p_eutran_config_list->neighbor_cell_list[index1] = 
                            p_eutran_config_list->neighbor_cell_list[index1 + RRM_ONE];
                    }
                }
                p_eutran_config_list->neighbor_cell_list_size--;
            }
        } 
    }

    RRM_UT_TRACE_EXIT();

}
/* SPR 17845 Fix Stop */
/****************************************************************************
 * Function Name  : rrm_ue_populate_rrmif_meas_results_ind
 * Inputs         : p_proc_data - Pointer to Msg data received form RRC
 *                  p_ue_context - Pointer to the UE context for which meas
 *                  results are being populated
 * Outputs        : p_ue_meas_results_ind - Pointer to the Msg data to be sent
 *                  to RMIF
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Populates the meas_results_ind message to be sent to RMIF
 ****************************************************************************/
rrm_return_et
rrm_ue_populate_rrmif_meas_results_ind(
        rrmuem_rmif_meas_results_ind_t      *p_ue_meas_results_ind,
        rrm_ue_measurment_results_ind_t     *p_proc_data,
        rrm_ue_context_t                    *p_ue_context
        )
{
    U8      index = RRM_NULL;
    rrm_return_et                       ret_val = RRM_SUCCESS;
    /* SPR 16406 Start */
    meas_report_info_node_t       *p_meas_report_info = RRM_PNULL;
    /* SPR 16406 End */

    RRM_UT_TRACE_ENTER();

    p_ue_meas_results_ind->cell_index = p_ue_context->cell_index;
    p_ue_meas_results_ind->ue_index = p_proc_data->ue_index;

    /* SPR 15698 Start */
    /// We needs to send the Event Type to SON to differentiate between whether a 
    /// Strongest cell report received 
    /* SPR 16406 Start */
    p_meas_report_info = rrm_get_cgi_meas_node_for_meas_id(p_proc_data->meas_id,p_ue_context);
    if(RRM_PNULL != p_meas_report_info)
    {
        p_ue_meas_results_ind->meas_report_event = p_meas_report_info->reporting_event;
    }
    /* SPR 17599 FIX START*/
    else
    {
        p_ue_meas_results_ind->meas_report_event = MEAS_REP_EVENT_NONE;
    }
    /* SPR 17599 FIX END*/
    /* SPR 16406 End */


    /* SPR 21496 Fix Start */ 
    if(p_proc_data->eutran_count > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->eutran_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->eutran_meas_list_size;
                index++)
        {
            if(RRM_EUTRAN_CELL == p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type)
            {
                /* Populate the earfcn value from the carrier freq stored in UE 
                   context corresponding to the meas id of results ind */
                p_ue_meas_results_ind->eutran_meas_list[index].earfcn = 
                    p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].carr_freq;

                p_ue_meas_results_ind->eutran_meas_list[index].
                    neighbor_cell_list_size
                    = p_proc_data->eutran_count;

                rrm_ue_populate_eutran_nbr_list(p_ue_meas_results_ind->eutran_meas_list[index].
                        neighbor_cell_list, p_proc_data, p_ue_context);
                /* SPR 17845 Fix Start */
                rrm_ue_drop_eutra_daho_cell_for_cgi(&(p_ue_meas_results_ind->eutran_meas_list[index]),
                        p_ue_meas_results_ind->cell_index);
                /* SPR 17845 Fix Stop */

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Invalid Meas Results: Meas Id = %d allocated to other RAT type = %d",
                        p_proc_data->meas_id, 
                        p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type);
                ret_val = RRM_FAILURE;
                break;
            }
        }
    }
    if(p_proc_data->utran_count > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->utran_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->utran_meas_list_size;
                index++)
        {
            /* TDD Support SON Start */
            if((RRM_UTRAN_CELL == p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type) ||
                    (RRM_UTRAN_TDD_CELL == p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type))
                /* TDD Support SON End */
            {
                /* Populate the uarfcn value from the carrier freq stored in UE 
                   context corresponding to the meas id of results ind */
                p_ue_meas_results_ind->utran_meas[index].uarfcn = 
                    p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].carr_freq;

                p_ue_meas_results_ind->utran_meas[index].neighbor_cell_list_size
                    = p_proc_data->utran_count;

                rrm_ue_populate_utran_nbr_list(p_ue_meas_results_ind->utran_meas[index].neighbor_cell_list,
                        p_proc_data, p_ue_context);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Invalid Meas Results: Meas Id = %d allocated to other RAT type = %d",
                        p_proc_data->meas_id, 
                        p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type);
                ret_val = RRM_FAILURE;
                break;
            }
        }
    }
    if(p_proc_data->geran_count > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->geran_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->geran_meas_list_size;
                index++)
        {
            if(RRM_GERAN_CELL == p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type)
            {
                /* Populate the arfcn value from the carrier freq stored in UE
                   context corresponding to the meas id of results ind */
                p_ue_meas_results_ind->geran_meas[index].bitmask |= 
                    RRM_SON_GERAN_MR_MEAS_OBJ_ID_PRESENT;
                p_ue_meas_results_ind->geran_meas[index].meas_obj_id = 
                    p_proc_data->meas_id;

                p_ue_meas_results_ind->geran_meas[index].neighbor_cell_list_size
                    = p_proc_data->geran_count;

                rrm_ue_populate_geran_nbr_list(p_ue_meas_results_ind->geran_meas[index].neighbor_cell_list,
                        p_proc_data);
                /*SPR 17777 +-*/
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Invalid Meas Results: Meas Id = %d allocated to other RAT type = %d",
                        p_proc_data->meas_id,
                        p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type);
                ret_val = RRM_FAILURE;
                break;
            }

        }
    }
    if(p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.cdma2000_count > RRM_ZERO)
    {
        /* Meas results ind is being sent per earfcn/uarfcn to RMIF */
        p_ue_meas_results_ind->cdma_meas_list_size = RRM_1;

        for(index = RRM_ZERO; index < p_ue_meas_results_ind->cdma_meas_list_size;
                index++)
        {
            if(RRM_CDMA_CELL == p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type)
            {
                /* Populate the arfcn value from the carrier freq stored in UE
                   context corresponding to the meas id of results ind */
                p_ue_meas_results_ind->cdma_meas[index].bitmask |= 
                    RRM_SON_CDMA_MEAS_RESULT_OBJ_ID_PRESENT;
                p_ue_meas_results_ind->cdma_meas[index].meas_obj_id = 
                    p_proc_data->meas_id;

                p_ue_meas_results_ind->cdma_meas[index].neighbor_cell_list_size
                    = p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.cdma2000_count;

                rrm_ue_populate_cdma2000_nbr_list(p_ue_meas_results_ind->cdma_meas[index].neighbor_cell_list,
                        p_proc_data, p_ue_context);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Invalid Meas Results: Meas Id = %d allocated to other RAT type = %d",
                        p_proc_data->meas_id,
                        p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].rat_type);
                ret_val = RRM_FAILURE;
                break;
            }

        }
    }
    /* SPR 21496 Fix End */ 
    if(p_proc_data->utran_count == RRM_ZERO && p_proc_data->eutran_count == RRM_ZERO && p_proc_data->geran_count == RRM_ZERO && \
            p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.cdma2000_count == RRM_ZERO)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "No Neighbours detected!");
    }

    /* UE Positioning start */
    p_ue_meas_results_ind->meas_results_ecid_r9.ue_rxtx_time_diff = 
        p_proc_data->meas_result_ecid_r9.ue_rxtx_time_diff;
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "UE RxTx time diff is [%d]",p_proc_data->meas_result_ecid_r9.ue_rxtx_time_diff);

    for(index = RRM_ZERO; index < ECID_CURRENT_SFN_OCTET_SIZE; index ++)
    {
        p_ue_meas_results_ind->meas_results_ecid_r9.current_sfn_r9[index] = 
            p_proc_data->meas_result_ecid_r9.current_sfn_r9[index];
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Current sfn r9 for index[%d] is [%d]", index, p_proc_data->meas_result_ecid_r9.current_sfn_r9[index]);
    }
    /* UE Positioning end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 * Function Name  : is_meas_id_configured_for_cdma2000_hrpd
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Return true/false on the basis of meas id configured for 
 HRPD.
 ****************************************************************************/
    rrm_bool_et
is_meas_id_configured_for_cdma2000_hrpd(rrm_ue_context_t *p_ue_context)
{
    U8 valid_meas_id = RRM_ZERO;
    /* Coverity_ID : 31009 */
    rrm_bool_et meas_id_configured = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    /* SPR 21496 Fix Start */ 
    for (valid_meas_id = RRM_ZERO;
            valid_meas_id < p_ue_context-> \
            p_meas_obj_cdma2000_info-> \
            count_meas_object_hrpd;
            valid_meas_id++)
    {
        if(RRM_THIRTEEN > p_ue_context->p_meas_obj_cdma2000_info->
                meas_obj_cdma2000_cell_info_hrpd[valid_meas_id].meas_id)
        {
            meas_id_configured = RRM_FALSE;
        }
    }
    if(RRM_ZERO == p_ue_context->p_meas_obj_cdma2000_info->count_meas_object_hrpd)
    {
        meas_id_configured = RRM_FALSE;
    }
    /* SPR 21496 Fix End */ 

    RRM_UT_TRACE_EXIT();
    return meas_id_configured;
}


/****************************************************************************
 * Function Name  : is_meas_id_configured_for_cdma2000_1xrtt
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Return true/false on the basis of meas id configured for 
 1xrtt.
 ****************************************************************************/
    rrm_bool_et
is_meas_id_configured_for_cdma2000_1xrtt(rrm_ue_context_t *p_ue_context)
{
    U8 valid_meas_id = RRM_ZERO;
    /* coverity  : CID 31009*/
    rrm_bool_et meas_id_configured = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    /* SPR 21496 Fix Start */ 
    for (valid_meas_id = RRM_ZERO;
            valid_meas_id < p_ue_context-> \
            p_meas_obj_cdma2000_info-> \
            count_meas_object_1xrtt;
            valid_meas_id++)
    {
        if(RRM_THIRTEEN > p_ue_context->p_meas_obj_cdma2000_info->
                meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id].meas_id)
        {
            meas_id_configured = RRM_FALSE;
        }
    }
    if(RRM_ZERO == p_ue_context->p_meas_obj_cdma2000_info->count_meas_object_1xrtt)
    {
        meas_id_configured = RRM_FALSE;
    }
    /* SPR 21496 Fix End */ 

    RRM_UT_TRACE_EXIT();
    return meas_id_configured;
}


/****************************************************************************
 * Function Name  : match_1xrtt_meas_id
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Return true/false on the basis of meas id of measurement 
 result matched for meas id of 1xrtt.
 ****************************************************************************/
    rrm_bool_et
match_1xrtt_meas_id(rrm_ue_context_t *p_ue_context, U8 meas_id_received)
{
    U8 valid_meas_id = RRM_ZERO;
    /* Coverity_ID : 31010 */
    rrm_bool_et meas_id_matched = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    /* SPR 21496 Fix Start */ 
    if (RRM_PNULL != p_ue_context->p_meas_obj_cdma2000_info)
    {
    for (valid_meas_id = RRM_ZERO;
            valid_meas_id < p_ue_context-> \
          p_meas_obj_cdma2000_info-> \
            count_meas_object_1xrtt;
            valid_meas_id++)
    {
        if(meas_id_received == p_ue_context->p_meas_obj_cdma2000_info->
                meas_obj_cdma2000_cell_info_1xrtt[valid_meas_id].meas_id)
        {
            meas_id_matched = RRM_TRUE;
            p_ue_context->cdma2000_meas_id_received = RRM_TRUE; 
            break;
        }
    }
    }
    /* SPR 21496 Fix End */ 

    RRM_UT_TRACE_EXIT();

    return meas_id_matched;
}


/****************************************************************************
 * Function Name  : is_meas_id_configured_for_cdma2000_1xrtt
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Return true/false on the basis of meas id of measurement
 result matched for meas id of hrpd.
 ****************************************************************************/
    rrm_bool_et
match_hrpd_meas_id(rrm_ue_context_t *p_ue_context, U8 meas_id_received)
{
    U8 valid_meas_id = RRM_ZERO;
    /* coverity : CID 31010*/
    rrm_bool_et meas_id_matched = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    /* SPR 21496 Fix Start */ 
    if (RRM_PNULL != p_ue_context->p_meas_obj_cdma2000_info)
    {
    for (valid_meas_id = RRM_ZERO;
            valid_meas_id < p_ue_context-> \
          p_meas_obj_cdma2000_info-> \
            count_meas_object_hrpd;
            valid_meas_id++)
    {
        if(meas_id_received == p_ue_context->p_meas_obj_cdma2000_info->
                meas_obj_cdma2000_cell_info_hrpd[valid_meas_id].meas_id)
        {
            meas_id_matched = RRM_TRUE;
            p_ue_context->cdma2000_meas_id_received = RRM_TRUE; 
            break;
        }
    }
    }
    /* SPR 21496 Fix End */ 

    RRM_UT_TRACE_EXIT();

    return meas_id_matched;
}

/*SPR_7831_CHANGES_START*/
/****************************************************************************
 * Function Name  : rrm_check_meas_id_validity
 * Inputs         : rrm_ue_context_t *p_ue_context RRM UE Context.
 *                : rrm_ue_measurment_results_ind_t *p_proc_data
 * Outputs        : None
 * Returns        : meas_type
 * Description    : Checks for the validity of meas_id.
 ****************************************************************************/
meas_type_et
rrm_check_meas_id_validity(
        rrm_ue_context_t                  *p_ue_context,
        rrm_ue_measurment_results_ind_t     *p_proc_data
        )
{
    meas_type_et meas_type = MEAS_TYPE_ANR;
    meas_report_info_node_t *p_meas_report_info = RRM_PNULL;
    rrm_bool_et             is_meas_id_found = RRM_FALSE;
    YLNODE *p_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_node = ylFirst(&(p_ue_context->meas_report_list));

    while(p_node)
    {
        p_meas_report_info = (meas_report_info_node_t*) p_node;
        if(p_meas_report_info->meas_id == p_proc_data->meas_id)
        {
            meas_type = p_meas_report_info->meas_type;
            is_meas_id_found = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "meas_id received from UE matches with the "
                    "meas_id in the list at RRM");
            break;
        }
        p_node = ylNext(p_node);
    }

    if(RRM_FALSE == is_meas_id_found)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "meas_id received from UE does not match with any of the "
                "meas_id in the list at RRM");
    }

    RRM_UT_TRACE_EXIT();
    return meas_type;
}
/*SPR_7831_CHANGES_END*/

/* SPR 12973 Start */
rrm_bool_et
rrm_uem_check_req_status_of_meas_objects(
        rrm_ue_context_t                  *p_ue_context
        )
{
    U8          meas_id             = RRM_NULL;
    rrm_bool_et all_meas_results_received = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_ue_context->p_proc_queue_first_meas_node)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CGI results are pending to be received!");
        all_meas_results_received = RRM_FALSE;
    }
    else
    {
        for(meas_id = 0; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
        {
          /* SPR 21496 Fix Start */ 
            /* SPR 16053 start */
            if(RRM_MEAS_CONFIG_RESP_SUCCESS == p_ue_context->p_meas_config[meas_id].meas_config_status)
            {
                /* SPR_16053_Fix: Start */
                if(RRM_ZERO == p_ue_context->p_meas_config[meas_id].report_counter)
                {
                    /* SPR 16053 end */
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "All measurement reports are received for meas ID = %d", meas_id + RRM_ONE);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[%d] measurement reports are not received for meas ID[%d]",
                            p_ue_context->p_meas_config[meas_id].report_counter,
                            meas_id + RRM_ONE);
                    all_meas_results_received = RRM_FALSE;
                    break;
                }
                /* SPR_16053_Fix: End */
                /* SPR 21496 Fix End */ 

            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return all_meas_results_received;
}
/* SPR 12973 End */

/* SPR 15860 Start */
/* SPR 15861 Start */
/* SPR 15862 Start */
/*SPR 17061 Start*/
/* SPR 15397 Start */
rrm_bool_et
rrm_uem_check_req_status_of_anr_meas_objects(
        rrm_ue_context_t                  *p_ue_context
        )
{
    U8          meas_id             = RRM_NULL;
    rrm_bool_et all_anr_meas_results_received   = RRM_TRUE;
    rrm_bool_et is_inter_freq_events_configured = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    for(meas_id = 0; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
    {
        /* SPR_16053_Fix: Start */
        /* SPR 16053 start */
        if(RRM_MEAS_CONFIG_RESP_SUCCESS == p_ue_context->p_meas_config[meas_id].meas_config_status)
        {
            if(RRM_ZERO == p_ue_context->p_meas_config[meas_id].report_counter)
            {
                /* SPR 16053 end */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Strongest Cell Meas result is to be DELETED meas ID = %d and shall"
                        " be marked NULL when Meas config Response received", meas_id + RRM_ONE);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Strongest Cell Meas results of meas ID = %d are pending", meas_id + RRM_ONE);
                all_anr_meas_results_received = RRM_FALSE;
                break;
            }
        }
        /* SPR_16053_Fix: End */        
    }

    /* Check if there any inter frequency event configured or not. RRM should not release the measurement gap
       if any inter-frequency event is configured */
    if(RRM_TRUE == all_anr_meas_results_received)
    {
        is_inter_freq_events_configured = rrm_is_any_interfreq_interrat_meas_configured(p_ue_context);

        if(RRM_TRUE == is_inter_freq_events_configured)
        {
            all_anr_meas_results_received = RRM_FALSE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "No Inter Frequency Event Configured for UE");
        }
    }

    RRM_UT_TRACE_EXIT();
    return all_anr_meas_results_received;
}
/* SPR 15397 End */
/*SPR 17061 End*/
/* SPR 15843 End */
/* SPR 15860 End */
/* SPR 15861 End */
/* SPR 15862 End */

/* SPR_15755_Fix: Start */
/****************************************************************************
 * Function Name  : rrm_get_meas_node_for_meas_id
 * Inputs         : meas_id, p_ue_context
 * Outputs        : None
 * Returns        : Meas node for which the input meas id matches.
 * Description    : Returns the pointer of the node for which the meas id 
 *                  matches with the input meas id.
 ****************************************************************************/
meas_report_info_node_t   *rrm_get_meas_node_for_meas_id(
        U8                        meas_id,
        rrm_ue_context_t*         p_ue_context) 
{
    meas_report_info_node_t *p_meas_report_info = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_meas_report_info = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));

    while (p_meas_report_info) {
        if (p_meas_report_info->meas_id == meas_id) {
            RRM_UT_TRACE_EXIT();
            return p_meas_report_info;
        }
        p_meas_report_info = (meas_report_info_node_t*)ylNext(&p_meas_report_info->sNode);
    }     

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Meas ID %d not found in the list.", meas_id);

    RRM_UT_TRACE_EXIT();
    return p_meas_report_info;
}
/* SPR_15755_Fix: End */

/* SPR 15860 Start */
/* SPR 15861 Start */
/* SPR 15862 Start */

/* SPR 16406 Start */
/* Code removed */
/* SPR 16406 End */

    rrm_bool_et
rrm_ue_is_cgi_report_pending(rrm_ue_context_t*         p_ue_context)
{
    rrm_bool_et is_cgi_report_pending = RRM_FALSE;

    meas_report_info_node_t *p_meas_report_info = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_meas_report_info = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));

    while (p_meas_report_info) 
    {
        if((p_meas_report_info->is_meas_report_pending == RRM_TRUE) &&
                (p_meas_report_info->reporting_event == MEAS_REP_EVENT_FOR_CGI))
        {
            is_cgi_report_pending = RRM_TRUE;
            break;
        }
        p_meas_report_info = (meas_report_info_node_t*)ylNext(&p_meas_report_info->sNode);
    }     

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "is_cgi_report_pending = %u", is_cgi_report_pending);

    RRM_UT_TRACE_EXIT();
    return is_cgi_report_pending;
}
/* SPR 15860 End */
/* SPR 15861 End */
/* SPR 15862 End */

/* SPR 15397 End */
/*SPR 16944 START*/
/****************************************************************************
 * Function Name  : rrm_check_if_qci_supported
 * Inputs         : rrm_cell_context_t,rcvd_qci
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Checks if cqi is supported or not 
 ****************************************************************************/
rrm_return_et
rrm_check_if_qci_supported
(
 rrm_cell_context_t *p_cell_ctx,
 U8                  rcvd_qci
 )
{
    U8                index;
    rrm_return_et     ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();
    for(index = RRM_ZERO; index < p_cell_ctx->epc_info.epc_params.num_valid_qos_profiles; index++)
    {
        if(rcvd_qci == p_cell_ctx->epc_info.epc_params.qos_config_params[index].qci)
        {
            ret_val = RRM_SUCCESS; 
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "QCI [%d] is supported", rcvd_qci);
            RRM_UT_TRACE_EXIT();
            return ret_val; 
        }
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "QCI [%d] is not supported", rcvd_qci);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 16944 END*/

/****************************************************************************
 * Function Name  : rrm_ue_handle_meas_results_ind
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_results_ind message received from RRC.
 ****************************************************************************/
    rrm_return_et
rrm_ue_handle_meas_results_ind (rrm_ue_global_context_t *p_g_rrm_ue_ctx)
{
    rrm_return_et				        ret_val = RRM_SUCCESS;
    rrm_ue_measurment_results_ind_t     *p_proc_data = RRM_NULL;
    /* SPR 18770 Fix Start */
     meas_report_info_node_t *p_meas_report_node = RRM_PNULL;
    /* SPR 18770 Fix End */
    /* SPR 12973 Start */
    rrm_bool_et                         remove_cdrx = RRM_FALSE;
    /* SPR 12973 End */

    /* SPR 15441 start */
    rrm_ue_procedure_record_t       *p_rrm_ue_procedure_record = RRM_PNULL;
    /* SPR 15441 end */
    /* SPR_15755_Fix: Start */
    meas_report_info_node_t       *p_meas_report_info = RRM_PNULL;
    /* SPR_15755_Fix: End */
    /* SPR 15860 Start */
    /* SPR 15861 Start */
    /* SPR 15862 Start */
    rrm_bool_et  is_cgi_report_pending = RRM_FALSE;
    /*SPR 17646 Start*/
    rrm_bool_et  should_process_enqueued_proc = RRM_FALSE;
    rrm_return_et should_process_enqueued_proc_ret_val = RRM_FAILURE;
    /*SPR 17646 End*/
    /* SPR 15860 End */
    /* SPR 15861 End */
    /* SPR 15862 End */
    /* SPR 15539 Start */
    rrmc_meas_report_event_et          meas_rep_event = MEAS_REP_EVENT_NONE;
    /* SPR 15539 End */

    RRM_UT_TRACE_ENTER();
    p_proc_data = (rrm_ue_measurment_results_ind_t *)
        p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Checking meas_id=%d for UE_ID[%d]",p_proc_data->meas_id, p_g_rrm_ue_ctx->p_ue_context->ue_index);
    /* Start HO Code Cleanup */
    /*SPR 12269:start*/
    /* SPR 18770 Fix Start */
    if(MEAS_TYPE_FOR_VICTIM != rrm_check_meas_id_validity(p_g_rrm_ue_ctx->p_ue_context, p_proc_data))
    {
        if((p_proc_data->meas_id >= RRM_MEAS_OBJ_ID_OFFSET) &&
                /*SPR 16655 START*/ 
                (p_proc_data->meas_id <= MAX_MEAS_OBJECT_ID))
                /*SPR 16655 END*/            
        {
          /* SPR 21496 Fix Start */ 
            /*CA HARDENING CHANGES 6.3.0*/
            /*SPR 16764 START*/
            /*SPR 17646 Start*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "ENTRY LEVEL MEAS CONFIG STATUS = %d ",p_g_rrm_ue_ctx->p_ue_context->p_meas_config[0].meas_config_status);
            should_process_enqueued_proc_ret_val = rrm_uem_meas_results_ind(p_g_rrm_ue_ctx);
            if(RRM_SUCCESS == should_process_enqueued_proc_ret_val)
                should_process_enqueued_proc = RRM_TRUE;
            else
                should_process_enqueued_proc = RRM_FALSE;
            /*SPR 17646 End*/
            /*SPR 16764 END*/
        }
    }
    /* SPR 18770 Fix End */
	else
	{
		/*SPR 12269:end*/
		/*CA Stage3: start*/
		/*call function handler pass meas_id and p_ue_context*/
		p_meas_report_node = (meas_report_info_node_t *)ylFirst(&(p_g_rrm_ue_ctx->p_ue_context->meas_report_list));
		while (p_meas_report_node)
		{
			if(p_proc_data->meas_id == p_meas_report_node->meas_id)
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
						"MeasId[%d] is configured for EARFCN =%d, RPT Event[%d], Trigger Quantity[%d]",
						p_meas_report_node->meas_id,p_meas_report_node->carrier_earfcn,
						p_meas_report_node->reporting_event, p_meas_report_node->trigger_quantity);
				p_meas_report_node->register_meas_func_type(p_g_rrm_ue_ctx);
				ret_val = RRM_SUCCESS;
				break;
			}
			p_meas_report_node = (meas_report_info_node_t *)ylNext(&p_meas_report_node->sNode);
		}
		/*CA Stage3: end*/
    }

    /* SPR 15539 Start */
    /* SPR 15860 Start */
    /* SPR 15861 Start */
    /* SPR 15862 Start */
    p_meas_report_info = rrm_get_cgi_meas_node_for_meas_id(p_proc_data->meas_id, p_g_rrm_ue_ctx->p_ue_context);
    if(RRM_PNULL != p_meas_report_info)
    {
        meas_rep_event = p_meas_report_info->reporting_event;
        p_meas_report_info->is_meas_report_pending = RRM_FALSE;
    }

    if ((should_process_enqueued_proc == RRM_TRUE)&&
            (rrm_get_queue_count(&p_g_rrm_ue_ctx->p_ue_context->procedure_queue)))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], dequeue queued message",
                p_g_rrm_ue_ctx->p_ue_context->ue_index);
        /** Dequeue the events from event queue and call message handler */
        /* SPR 15849 Start */
        p_rrm_ue_procedure_record = rrm_request_dequeue( p_g_rrm_ue_ctx->p_ue_context);
        /* SPR 15849 End */
        if(RRM_PNULL != p_rrm_ue_procedure_record)
        {
            rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
            p_rrm_ue_procedure_record = RRM_PNULL;
        }
    }
    /* SPR 15860 End */
    /* SPR 15861 End */
    /* SPR 15862 End */

    /* SPR 15539 End */
    /* SPR 15441 start */
    /* code removed */
    /* SPR 15441 end */

    /* SPR 15539 Start */
    /* SPR 12973 Start */
    /* If CDRX has been configured at the UE for CGI reporting purpose */
    /* SPR 15860 Start */
    /* SPR 15861 Start */
    /* SPR 15862 Start */

    /// We shouldn't delete the DRX if any CGI report is pending
    is_cgi_report_pending = rrm_ue_is_cgi_report_pending(p_g_rrm_ue_ctx->p_ue_context);

    if((RRM_FALSE == is_cgi_report_pending) && (MEAS_REP_EVENT_FOR_CGI == meas_rep_event))
        /* SPR 15539 End */
    {
        /* SPR 15860 End */
        /* SPR 15861 End */
        /* SPR 15862 End */
        /* SPR_15538_Fix: Start */
        /* SPR 16406 8SEP start */
        if((p_proc_data->meas_id >= RRM_MEAS_OBJ_ID_OFFSET) &&
                (p_proc_data->meas_id <= RRM_ANR_MAX_MEAS_OBJ))
        {
            /* SPR 16406 8SEP end */
            if(RRM_UE_CDRX_APPLIED == p_g_rrm_ue_ctx->p_ue_context->cdrx_status)
            {
                /* SPR_15538_Fix: End */
                /* SPR 16406 8SEP start */
                /* Code deleted */        
                /* SPR 16406 8SEP end */
                /* If CDRX has been applied for ANR */
                /* Check if all the PCI reports and CGI reports of all the requested CGIs have been received
                   for this UE, then remove the CDRX configuration applied for eCGI reports and apply DRX */
                remove_cdrx = rrm_uem_check_req_status_of_meas_objects(p_g_rrm_ue_ctx->p_ue_context);
                /* SPR 16406 Start */
                if((RRM_TRUE == remove_cdrx) && (RRM_UE_STATE_HO_ONGOING != p_g_rrm_ue_ctx->p_ue_context->ue_state))
                    /* SPR 16406 End */
                {
                    p_g_rrm_ue_ctx->p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_REMOVED;
                    /* SPR 12480 Start */
                    /* Apply DRX again as CGIs have been reported */
                    /*CA HARDENING CHANGES 6.3.0 */
                    if (RRM_FAILURE == rrm_build_and_send_ue_reconfig_req(p_g_rrm_ue_ctx->p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to send UE reconfig request to remove CDRX, UE index[%d]",
                                p_g_rrm_ue_ctx->p_ue_context->ue_index);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE reconfig request sent to UE index[%d] to remove CDRX ",
                                p_g_rrm_ue_ctx->p_ue_context->ue_index);
                    }
                    /* SPR 12480 End */
                    /*SPR 17111 Start */
                    //p_g_rrm_ue_ctx->p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
                    /*SPR 17111 End*/
                }
                /* SPR_15538_Fix: Start */
            }
            /*SPR 17061 Start*/
            /*SPR 15835:Start*/
            /* SPR 16406 Start */
            else if(( RRM_UE_CDRX_DISABLED == p_g_rrm_ue_ctx->p_ue_context->cdrx_status)
                    && (RRM_UE_STATE_HO_ONGOING != p_g_rrm_ue_ctx->p_ue_context->ue_state) )
                /* SPR 16406 End */
            {
                /*SPR 15835:End*/
                /*SPR 17061 End*/
                /* For Autonomous Gap */
                /* If UE reconfig was sent for CDRX removal then RRM will send the meas config req. to UE for removal 
                   of report config id & meas id for the CGI process. */
                /* SPR 15674 Start */
                /* SPR 16406 8SEP start */
                p_g_rrm_ue_ctx->p_ue_context->meas_rep_event = meas_rep_event;
                /* SPR 16406 8SEP end */
                /* SPR 15674 End */
                ret_val = rrm_build_and_send_meas_config_req(p_g_rrm_ue_ctx->p_ue_context,MEAS_TYPE_HO);
            }
            /* SPR 16406 8SEP start */
        }
        /* SPR 16406 8SEP end */
        /* SPR_15538_Fix: End */
    }
    /* SPR 12973 End */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* UE MEAS CHANGES :ENDS */

/****************************************************************************
 * Function Name  : rrm_ue_handle_e_capability_ind
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_capability_ind message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ue_capability_ind (
        rrm_ue_global_context_t *p_g_rrm_ue_ctx
        )
{
    rrm_return_et 					ret_val = RRM_SUCCESS;
    rrm_ue_procedure_record_t       *p_rrm_ue_procedure_record = RRM_PNULL;

    /* SPR 17850 Fix Start */
    rrm_ue_context_t                *p_ue_context = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    /*LTE_RRM_KLOCWORK_WARN_6_JULY_12_START*/
    do
    {
        p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
        /** Move the state to UE ACTIVE state */
        rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
        p_ue_context->ue_start_time = rrm_get_system_time();
        /** Set the procedure for ERB setup request */
        p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

        ret_val = rrm_ue_setting_capability_params(p_g_rrm_ue_ctx->p_ue_context);


        /** if queue not empty then dequeue the events */
        if (rrm_get_queue_count(&p_ue_context->procedure_queue))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], dequeue queued \
                    message",p_ue_context->ue_index);
            /** Dequeue the events from event queue and call message handler */
            /* SPR 15849 Start */
            p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
            /* SPR 15849 End */
            if(RRM_PNULL == p_rrm_ue_procedure_record)
            {
                ret_val = RRM_FAILURE;
                break;
            } 

            /* CSR00069389 Start */
            rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
            /* CSR00069389 End */
        }
        /* SPR 15441 start */
        /* code removed */
        /* SPR 15441 end */
    }while(RRM_ZERO);
    /* SPR 17850 Fix End */
    /*LTE_RRM_KLOCWORK_WARN_6_JULY_12_END*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 17850 Fix Start */
/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_capability_ind_ho_ongoing
 * Inputs         : rrm_global_context_t *p_rrm_glb_ctxt RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_capability_ind message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ue_capability_ind_ho_ongoing
(
 rrm_ue_global_context_t *p_rrm_glb_ctxt
 )
{
    rrm_return_et 					ret_val = RRM_FAILURE;
    rrm_ue_context_t                *p_ue_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_ue_context = p_rrm_glb_ctxt->p_ue_context;

    if(RRM_PNULL != p_ue_context)
    {
        ret_val = rrm_ue_setting_capability_params(p_rrm_glb_ctxt->p_ue_context);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ue_setting_capability_params
 * Inputs         : rrm_ue_context_t *p_ue_context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Storing the ue_capability_ind message received from RRC 
 *                  in UE Context.
 ****************************************************************************/
rrm_return_et
rrm_ue_setting_capability_params 
(
 rrm_ue_context_t    *p_ue_context
 )
{
    rrm_return_et 					        ret_val = RRM_SUCCESS;
    rrm_bool_et                             dual_rx_mode_supported = RRM_FALSE;
    idle_mode_mobility_params_t             *p_idle_mode = RRM_PNULL;
    U8                                      loop = RRM_ZERO;
    rrm_ue_max_num_rohc_context_session_et  max_rohc_sessions = RRM_UE_CS2;


    RRM_UT_TRACE_ENTER();


    /* SPR 21496 Fix Start */ 
    /* Code Removed */
    /* SPR 21496 Fix End */ 

    rrm_checks_ue_supported_rats(p_ue_context);
    /* Fix for CSR: 00059124 */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "FGI Value %d",
            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.feature_group_indicators);

    p_idle_mode = rrm_cellm_get_idle_mode_params( p_ue_context->cell_index);

    /* CDMA2000 changes start */
    /* coverity : CID 30222*/
    /* SPR 16504 fix start*/
    /*SPR 20459 FIX START*/
    if (p_ue_context->ue_capability_params.bitmask & RRM_UE_CDMA2000_RADIO_CAPABILITY_PRESENT)
    {
	    p_ue_context->cdma2000_capabilities.is_cdma2000_present=RRM_ONE;   

    }
    /*SPR 20459 FIX End*/
    if ((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) && 
            (p_ue_context->ue_capability_params.\
             rrm_eutra_radio_capability_info.\
             bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT) &&
            (p_ue_context->ue_capability_params.\
             rrm_eutra_radio_capability_info.\
             ue_eutra_capability_v920_ies.\
             bitmask & RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT) &&
            (p_ue_context->ue_capability_params.\
             rrm_eutra_radio_capability_info.\
             ue_eutra_capability_v920_ies.inter_rat_parameters_cdma2000_v920.\
             bitmask & RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT))
    {
        p_ue_context->cdma2000_capabilities.\
            is_ecsfb_conc_ho_present = (rrm_bool_et)
            (((p_idle_mode->idle_mode_mobility_irat_cdma_params.\
               presence_bitmask & RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
              (p_idle_mode->idle_mode_mobility_irat_cdma_params.\
               inter_rat_parameters_cdma2000_v920.\
               bitmask & RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG)));
    }

    if ((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
            (p_ue_context->ue_capability_params.\
             rrm_eutra_radio_capability_info.\
             bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT) &&
            (p_ue_context->ue_capability_params.\
             rrm_eutra_radio_capability_info.\
             ue_eutra_capability_v920_ies.\
             bitmask & RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT) &&
            !(p_ue_context->ue_capability_params.\
                rrm_eutra_radio_capability_info.\
                ue_eutra_capability_v920_ies.\
                inter_rat_parameters_cdma2000_v920.\
                bitmask & RRM_UE_IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT))
    {
        p_ue_context->cdma2000_capabilities.\
            is_only_ecsfb_present = (rrm_bool_et)
            ((p_idle_mode->idle_mode_mobility_irat_cdma_params.\
              presence_bitmask & RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG) &&
             (!(p_idle_mode->idle_mode_mobility_irat_cdma_params.\
                inter_rat_parameters_cdma2000_v920.\
                bitmask & RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG)));
    }
    /* SPR 16504 fix stop */

    /* coverity : CID 30223*/
    /* SPR 16504 fix start */
    if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT) &&
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask &
             RRM_UE_IRAT_CDMA2000_PARAMS_V920_PRESENT))
    {
        p_ue_context->cdma2000_capabilities.is_ecsfb_present = (rrm_bool_et)
            (p_idle_mode->idle_mode_mobility_irat_cdma_params.presence_bitmask &
             RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG);
    }
    /* SPR 16504 fix stop */

    dual_rx_mode_supported = rrm_ue_check_dual_rx_support(p_ue_context);

    p_ue_context->cdma2000_capabilities.is_dual_rx_mode_present = dual_rx_mode_supported;

    /* CDMA2000 changes end */

    /* MAX_CID changes Start */
    p_ue_context->map_data_drb_rohc.total_drb_count = RRM_ZERO;
    for (loop = RRM_ZERO; loop < RRM_MAX_NUM_DRB_PER_UE; loop++)
    {
        p_ue_context->map_data_drb_rohc.map_data_rohc[loop].rab_id =  RRM_OUT_OF_RANGE;
    }
    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_OUT_OF_RANGE_FOUR_BYTE;
    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_ZERO;
    p_ue_context->map_data_drb_rohc.count_drbs_cid_allocated = RRM_ZERO;

    if (p_ue_context->ue_capability_params.bitmask &
            RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        max_rohc_sessions = (rrm_ue_max_num_rohc_context_session_et)
            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.pdcp_parameters.max_num_rohc_context_session;
        switch(max_rohc_sessions)
        {
            case RRM_UE_CS2:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_TWO;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_ONE;
                    break;
                }

            case RRM_UE_CS4:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_TWO;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_TWO;
                    break;
                }

            case RRM_UE_CS8:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_TWO;
                    break;
                }

            case RRM_UE_CS12:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_THREE;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_FOUR;
                    break;
                }

            case RRM_UE_CS16:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_FOUR;
                    break;
                }

            case RRM_UE_CS24:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_THREE;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                    break;
                }

            case RRM_UE_CS32:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                    break;
                }

            case RRM_UE_CS48:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_SIX;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                    break;
                }

            case RRM_UE_CS64:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_EIGHT;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                    break;
                }

            case RRM_UE_CS128:
            case RRM_UE_CS256:
            case RRM_UE_CS512:
            case RRM_UE_CS1024:
            case RRM_UE_CS16384:
            case RRM_UE_SPARE2:
            case RRM_UE_SPARE1:
                {
                    p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FIFTEEN;
                    p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                    break;
                }
            default:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FIFTEEN;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;

        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 17850 Fix End */

/****************************************************************************
 * Function Name  : rrm_ue_wait_for_cap_ind_handle_erb_setup_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the erb_setup_req  message received from RRC 
 *                  received in WAIT_FOR_CAPABILITY_IND state
 ****************************************************************************/
rrm_return_et
rrm_ue_wait_for_cap_ind_handle_erb_setup_req (
        rrm_ue_global_context_t *p_g_rrm_ue_ctx
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    rrm_ue_context_t *p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    /** Enqueue the erb_setup_erq if received before capability indication */
    rrm_ue_procedure_queue_t    proc_queue;
    proc_queue.api_id = p_g_rrm_ue_ctx->api_id; 
    proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data; 
    /*BUG 13332:start*/
    proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;
    /*BUG 13332:end*/
    /**Enqueue ERAB setup request */
    /*SPR 18241 START*/
    rrm_ue_mgr_enqueue_req( &proc_queue, p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
    /*SPR 18241 END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*SPR_17893_START*/
/****************************************************************************
 * Function Name  : rrm_set_utran_capability_enq_info 
 * Inputs         : is_req_sent,is_resp_rcvd
 * Outputs        : p_ue_context
 * Returns        : None
 * Description    : Sets the utran capability enquiry flags as per the provided
 *                  values. 
 ****************************************************************************/
rrm_void_t
rrm_set_utran_capability_enq_info(rrm_ue_context_t *p_ue_context,rrm_bool_et is_req_sent, rrm_bool_et is_resp_rcvd)
{
	RRM_UT_TRACE_ENTER();

	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
			"For,UE Index:[%u],Previously:is_utran_cap_enq_req_sent:"
			"[%d],is_utran_cap_enq_resp_recd:[%d][0-RRM_FALSE,1- RRM_TRUE] \n",
			p_ue_context->ue_index,  
			p_ue_context->utran_capability_enq_info.is_utran_cap_enq_req_sent,
			p_ue_context->utran_capability_enq_info.is_utran_cap_enq_resp_recd);

	p_ue_context->utran_capability_enq_info.is_utran_cap_enq_req_sent  = is_req_sent;
	p_ue_context->utran_capability_enq_info.is_utran_cap_enq_resp_recd = is_resp_rcvd;

	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
			"For,UE Index:[%u],Currently:is_utran_cap_enq_req_sent:"
			"[%d],is_utran_cap_enq_resp_recd:[%d][0-RRM_FALSE,1- RRM_TRUE] \n",
			p_ue_context->ue_index,  
			p_ue_context->utran_capability_enq_info.is_utran_cap_enq_req_sent,
			p_ue_context->utran_capability_enq_info.is_utran_cap_enq_resp_recd);

	RRM_UT_TRACE_EXIT();
	return;
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_capability_enquiry_resp_in_ho_ongoing
 * Inputs         : rrm_global_context_t *p_rrm_glb_ctxt RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_capability_enquiry_resp message received 
 from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ue_capability_enquiry_resp_in_ho_ongoing (
        rrm_ue_global_context_t *p_rrm_glb_ctxt
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_ue_context_t                *p_ue_context = RRM_PNULL;
    rrm_ue_capability_enq_res_t *p_rrm_ue_capability_enq_res = RRM_PNULL;
    
    RRM_UT_TRACE_ENTER();
    p_ue_context = p_rrm_glb_ctxt->p_ue_context;
    p_rrm_ue_capability_enq_res = (rrm_ue_capability_enq_res_t *)p_ue_context->current_procedure.p_proc_data;
    if(RRM_TRUE ==  p_rrm_ue_capability_enq_res->is_utran_cap_present)
    {
        p_ue_context->ue_capability_params.bitmask |= RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT; 
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                "For,UE Index:[%u],The Utran Capability Enquiry Succeded  \n",
                p_ue_context->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_ERROR,
                "For,UE Index:[%u],The Utran Capability Enquiry Failed  \n",
                p_ue_context->ue_index);
    }
    rrm_set_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_TRUE);

    p_ue_context->is_ho_reqd_on_recv_utan_cap = RRM_FALSE;

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_capability_enquiry_resp
 * Inputs         : rrm_global_context_t *p_rrm_glb_ctxt RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_capability_enquiry_resp message received 
 from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ue_capability_enquiry_resp (
        rrm_ue_global_context_t *p_rrm_glb_ctxt
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_ue_context_t                *p_ue_context = RRM_PNULL;
    rrm_ue_capability_enq_res_t *p_rrm_ue_capability_enq_res = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_ue_context = p_rrm_glb_ctxt->p_ue_context;
    p_rrm_ue_capability_enq_res = (rrm_ue_capability_enq_res_t *)p_ue_context->current_procedure.p_proc_data;
    if(RRM_TRUE ==  p_rrm_ue_capability_enq_res->is_utran_cap_present)
    {
        p_ue_context->ue_capability_params.bitmask |= RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT; 
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                "For,UE Index:[%u],The Utran Capability Enquiry Succeded",
                p_ue_context->ue_index);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_ERROR,
                "For,UE Index:[%u],The Utran Capability Enquiry Failed",
                p_ue_context->ue_index);
    }
    rrm_set_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_TRUE);

    rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
    if(RRM_FALSE == p_rrm_ue_capability_enq_res->is_utran_cap_present)
    {
        rrm_set_utran_capability_enq_info(p_ue_context,RRM_FALSE,RRM_FALSE);
        p_ue_context->is_ho_reqd_on_recv_utan_cap = RRM_FALSE;

        /*Stop the DAHO Timer*/
        if(p_ue_context->ho_params.blind_timer)
        {
            rrm_ue_stop_timer(p_ue_context->ho_params.blind_timer);
            p_ue_context->ho_params.blind_timer = RRM_PNULL;
        }

        /*Release the UE*/
        if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
                    p_ue_context->ue_index,
                    RADIO_NETWORK_LAYER_TYPE,
                    FAILURE_IN_THE_RADIO_INTERFACE_PROCEDURE,
                    rrm_generate_txn_id(),
                    p_ue_context,
                    p_ue_context->cell_index))
        {
            ret_val = RRM_SUCCESS;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "UE Connection release ind sent for UE index:%d",p_ue_context->ue_index);

            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_uem_log_on_off,
                        p_rrm_uem_facility_name,
                        RRM_ERROR,
                        "UE Connection release_ind sent, \
                        Failed to clean up ue resources");
            }
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to send release connection ind for UE index:%d",
                    p_ue_context->ue_index);
        }
    }
    else
    {
        if((RRM_TRUE == p_ue_context->is_ho_reqd_on_recv_utan_cap))
        {
            p_ue_context->is_ho_reqd_on_recv_utan_cap = RRM_FALSE;

            if(RRM_INVALID_CELL_LIST_TYPE == p_ue_context->rrm_cell_selection_info.current_cell_list)
            {
                p_ue_context->rrm_cell_selection_info.current_cell_list = RRM_EUTRAN_KNOWN_CELL_LIST;
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                        "RRM has started HO procedure after receiving the Utran Capability");
            }    
            if(RRM_SUCCESS == rrm_uem_search_and_select_pci_for_ho(p_ue_context,rrm_generate_txn_id()))
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                        "RRM has started HO procedure after receiving the Utran Capability");
            }
            else if(RRM_INVALID_CELL_LIST_TYPE == p_ue_context->rrm_cell_selection_info.current_cell_list)
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                        "RRM Starts to trigger the DAHO for the Utran Capability");
                  rrm_ho_to_utra_daho(p_ue_context,RRM_ONE); 
            }
        }		
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_check_utran_capability_enq_info 
 * Inputs         : p_ue_context,is_req_sent,is_resp_rcvd
 * Outputs        : None 
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function checks if the utran capability enq flags are same
 *                  as that the provided values or not.
 ****************************************************************************/
rrm_bool_et
rrm_check_utran_capability_enq_info(rrm_ue_context_t *p_ue_context,rrm_bool_et is_req_sent, rrm_bool_et is_resp_rcvd)
{
	rrm_bool_et retval = RRM_FALSE;  
	RRM_UT_TRACE_ENTER();
	if((is_req_sent  ==  p_ue_context->utran_capability_enq_info.is_utran_cap_enq_req_sent) &&
			(is_resp_rcvd == p_ue_context->utran_capability_enq_info.is_utran_cap_enq_resp_recd) )
        {
             retval = RRM_TRUE;
        }
	RRM_UT_TRACE_EXIT();
	return retval;
}

/*SPR_17893_END*/

/****************************************************************************
 * Function Name  : rrm_ue_get_lc_id 
 * Inputs         : rrm_ue_context_t, rrm_ue_erab_setup_item_list_t,
 *                  erb_setup_item_success_list_index
 * Outputs        : None
 * Returns        : void
 * Description    : Assign lc_id 
 ****************************************************************************/
void 
rrm_ue_get_lc_id(
        rrm_ue_context_t                *p_ue_context,
        rrm_ue_erab_setup_item_list_t   *p_setup_item_list,
        U8                              erb_setup_item_success_list_index
        )
{
    U8                      lc_id_list[MAX_LC_ID_INDEX]=RRM_MAX_DEFAULT_LCID_VALUES;         /*{3,4,5,6,7,8,9,10};*/
    U8                      lc_id_index = RRM_NULL;
    U8                      drb_configured_index = RRM_NULL;
    U8                      erb_setup_item_list_index = RRM_NULL;
    rrm_bool_et 			non_configured_lc_id = RRM_TRUE;
    
    RRM_UT_TRACE_ENTER();

    for( lc_id_index = RRM_NULL; lc_id_index < MAX_LC_ID_INDEX; 
            lc_id_index++ )
    {
        non_configured_lc_id = RRM_TRUE;
        for ( drb_configured_index = RRM_NULL;
                drb_configured_index < p_ue_context->drb_configured.
                num_of_list;
                drb_configured_index++ )
        {
            if ( p_ue_context->drb_configured.
                    erab_item[drb_configured_index].lc_id == 
                    lc_id_list[lc_id_index] 
                    /* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
                    || ( 
                        RRM_ZERO != p_ue_context->drb_configured.
                        erab_item[drb_configured_index].new_lc_id
                        &&
                        p_ue_context->drb_configured.
                        erab_item[drb_configured_index].new_lc_id ==
                        lc_id_list[lc_id_index]
                       )
#endif
                    /* OPTION3X Changes End */
               )
            {
                non_configured_lc_id = RRM_FALSE;
                break;
            }
        }
        if ( RRM_TRUE == non_configured_lc_id )
        {
            for( erb_setup_item_list_index = RRM_NULL;
                    erb_setup_item_list_index < 
                    erb_setup_item_success_list_index;
                    erb_setup_item_list_index++ )
            {
                if ( p_setup_item_list->
                        erab_item[erb_setup_item_list_index].lc_id ==
                        lc_id_list[lc_id_index] )
                {
                    non_configured_lc_id = RRM_FALSE;
                    break;
                }
            }
        }
        if (RRM_TRUE == non_configured_lc_id)
        {
            p_setup_item_list->erab_item[erb_setup_item_success_list_index]
                .lc_id = lc_id_list[lc_id_index];

            break;
        }
    }
}

/****************************************************************************
 * Function Name  : rrm_ue_get_drb_id 
 * Inputs         : rrm_ue_context_t, rrm_ue_erab_setup_item_list_t,
 *                  erb_setup_item_success_list_index
 * Outputs        : None
 * Returns        : void
 * Description    : Assign drb_id 
 ****************************************************************************/
void 
rrm_ue_get_drb_id(
        rrm_ue_context_t                *p_ue_context,
        rrm_ue_erab_setup_item_list_t   *p_setup_item_list,
        U8                              erb_setup_item_success_list_index
        )
{
    U8                      drb_id_list[RRM_MAX_DRB_ID_INDEX]=RRM_MAX_DEFAULT_DRB_ID_VALUES;         /*{3 to 10};*/
    U8                      drb_id_index = RRM_NULL;
    U8                      drb_configured_index = RRM_NULL;
    U8                      erb_setup_item_list_index = RRM_NULL;
    rrm_bool_et 			non_configured_drb_id = RRM_TRUE;
    
    RRM_UT_TRACE_ENTER();

    for( drb_id_index = RRM_NULL; drb_id_index < RRM_MAX_DRB_ID_INDEX; 
            drb_id_index++ )
    {
        non_configured_drb_id = RRM_TRUE;
        for ( drb_configured_index = RRM_NULL;
                drb_configured_index < p_ue_context->drb_configured.
                num_of_list;
                drb_configured_index++ )
        {
            if ( p_ue_context->drb_configured.
                    erab_item[drb_configured_index].drb_id == 
                    drb_id_list[drb_id_index]
                    /* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
                    || (
                        RRM_ZERO != p_ue_context->drb_configured.
                        erab_item[drb_configured_index].new_drb_id
                        &&
                        p_ue_context->drb_configured.
                        erab_item[drb_configured_index].new_drb_id ==
                        drb_id_list[drb_id_index]
                       )
#endif
                    /* OPTION3X Changes End */
               )
            {
                non_configured_drb_id = RRM_FALSE;
                break;
            }
        }
        if ( RRM_TRUE == non_configured_drb_id )
        {
            for( erb_setup_item_list_index = RRM_NULL;
                    erb_setup_item_list_index < 
                    erb_setup_item_success_list_index;
                    erb_setup_item_list_index++ )
            {
                if ( p_setup_item_list->
                        erab_item[erb_setup_item_list_index].drb_id ==
                        drb_id_list[drb_id_index] )
                {
                    non_configured_drb_id = RRM_FALSE;
                    break;
                }
            }
        }
        if (RRM_TRUE == non_configured_drb_id)
        {
            p_setup_item_list->erab_item[erb_setup_item_success_list_index]
                .drb_id = drb_id_list[drb_id_index];

            break;
        }
    }
}
/****************************************************************************
 * Function Name  : rrm_ue_get_drb_id_lc_id 
 * Inputs         : rrm_ue_context_t, rrm_ue_erab_setup_item_list_t
 * Outputs        : None
 * Returns        : void
 * Description    : Assign drb_id and lc_id 
 ****************************************************************************/
void
rrm_ue_get_drb_id_lc_id(
        rrm_ue_context_t                                *p_ue_context,
        rrm_ue_erab_setup_item_list_t   *p_setup_item_list,
        /* coverity : CID 19451*/
        /* Coverity_ID : 54432, 54433 */
        rrm_erab_procedure_et             current_procedure
        )
{
    U8                      erb_setup_item_success_list_index = RRM_NULL;
    
    RRM_UT_TRACE_ENTER();
    for( erb_setup_item_success_list_index = RRM_NULL;
            erb_setup_item_success_list_index<p_setup_item_list->num_of_list;
            erb_setup_item_success_list_index++)
    {
        #ifdef ENDC_ENABLED
        /*we do not allocate the lc id for the SN_TERMINATED_SCG_BEARER*/
        if(DRB_TYPE_SN_TERMINATED_SCG !=
                p_setup_item_list->erab_item[erb_setup_item_success_list_index].
                drb_type)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "ERAB_ID[%d] is not SN_TERMINATED_SCG_BEARER, Allocate LC_ID", 
                    p_setup_item_list->erab_item[erb_setup_item_success_list_index].erab_id);

            rrm_ue_get_lc_id(p_ue_context, 
                    p_setup_item_list, 
                    erb_setup_item_success_list_index);
        }
        #endif

        rrm_ue_get_drb_id(p_ue_context,
                p_setup_item_list,
                erb_setup_item_success_list_index);
    }
    RRM_UT_TRACE_EXIT();
}
/*OPTION3X Changes Stop*/

/*SPR 15436 changes start*/
int compare_by_priority(const void *a,const void *b)
{
    int temp = 0;
    rrm_ue_erab_setup_item_t *ia= (rrm_ue_erab_setup_item_t *)a;
    rrm_ue_erab_setup_item_t *ib= (rrm_ue_erab_setup_item_t *)b;
    temp = ia->erab_level_qos_params.alloc_and_reten_prior.priority_level - ib->erab_level_qos_params.alloc_and_reten_prior.priority_level;
    //    return (int) (ia->erab_level_qos_params.alloc_and_reten_prior.priority_level - ib->erab_level_qos_params.alloc_and_reten_prior.priority_level );
    return temp;    
}
/* SPR 16500 Fix Start */
/****************************************************************************
 * Function Name  : rrm_ue_emergency_set_max_ngbr_rab_priority
 * Inputs         : rrm_ue_context_t    *p_rrm_ue_context
 * Outputs        : None
 * Returns        : S8 
 * Description    : Determines the highest priority NGBR RAB and returns the 
 * 		    maximum priority of all the NGBR RABs currently present.
 ****************************************************************************/
static U8
rrm_ue_emergency_set_max_ngbr_rab_priority (
        rrm_ue_context_t    *p_rrm_ue_context
        )
{
    rrm_ue_proc_ho_adm_data_t   *p_rrm_ue_proc_ho_adm_data = RRM_PNULL;
    U8				qci = RRM_NULL;
    U8				index = RRM_NULL;
    U8				max_ngbr_rab_priority = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    if ( RRM_PNULL != p_rrm_ue_context )
    {
        p_rrm_ue_proc_ho_adm_data = (rrm_ue_proc_ho_adm_data_t *) p_rrm_ue_context->
            current_procedure.p_proc_data;		

        for ( index = RRM_NULL ; index < p_rrm_ue_proc_ho_adm_data->erab_setup_list.
                num_of_list; index++ )
        {

            qci = p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                erab_level_qos_params.qci;

            if (qci >= RRM_NGBR_QCI_5) 
            {
                switch(qci)
                {
                    case RRM_NGBR_QCI_5:
                        {
                            p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                                emergency_arp_ngbr_priority = QCI_5;    
                            break;
                        }
                    case RRM_NGBR_QCI_6:
                        {
                            p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                                emergency_arp_ngbr_priority = QCI_6;    
                            break;
                        }
                    case RRM_NGBR_QCI_7:
                        {
                            p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                                emergency_arp_ngbr_priority = QCI_7;    
                            break;
                        }
                    case RRM_NGBR_QCI_8:
                        {
                            p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                                emergency_arp_ngbr_priority = QCI_8;    
                            break;
                        }
                    case RRM_NGBR_QCI_9:
                        {
                            p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                                emergency_arp_ngbr_priority = QCI_9;    
                            break;
                        }
                }

                if ( (max_ngbr_rab_priority) < p_rrm_ue_proc_ho_adm_data->
                        erab_setup_list.erab_item[index].emergency_arp_ngbr_priority )
                {
                    max_ngbr_rab_priority = p_rrm_ue_proc_ho_adm_data->
                        erab_setup_list.erab_item[index].emergency_arp_ngbr_priority;
                }
            } 
        }
    }

    RRM_UT_TRACE_EXIT();
    return max_ngbr_rab_priority;
}
/* SPR 16500 Fix Stop */

/*SPR 15436 changes end*/

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_ho_adm_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_ho_adm_req message received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ue_ho_adm_req (
        rrm_ue_global_context_t *p_g_rrm_ue_ctx
        )
{
    rrm_return_et					ret_val = RRM_SUCCESS;
    rrm_ue_context_t            	*p_ue_context = RRM_PNULL;
    U32								index = RRM_NULL;
    /* SPR-19056 START */
    /* code deleted */
    /* SPR-19056 END */
    rrm_ue_proc_ho_adm_data_t       *p_rrm_ue_proc_ho_adm_data = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t 	*p_erab_setup_item_list = RRM_PNULL;
    rrm_ue_erab_setup_item_list_t 	*p_erab_setup_item_success_list = RRM_PNULL;
    rrm_ue_erab_failed_item_list_t 	*p_erab_setup_item_failed_list = RRM_PNULL;
    U8								trans_id = p_g_rrm_ue_ctx->trans_id;
    /*SPR 18602 START*/
    /*code removed*/
    /*SPR 18602 END*/
    U8                              success_count = RRM_ZERO;
    U8                              failure_count = RRM_ZERO;
    U8                              gbr_success_count = RRM_NULL;
    U8                              ngbr_success_count = RRM_NULL;
    U8                              gbr_configd_count = RRM_NULL;
    U8                              ngbr_configd_count = RRM_NULL;
    /*coverity 25214, initialized rrm_response, , rel1.3.1*/
    rrm_response_t                  rrm_response = {RRM_ZERO};
    /* FGI Feature Start */
    /* FGI Feature Start */
    U32                             num_temp_um_mode = RRM_NULL ;
    U32                             num_temp_am_mode = RRM_NULL ;
    /* warnings removal: 'data_transfer_mode' should be U32 according */ 
    U32                             data_transfer_mode = RRM_NULL; 
    /* FGI Feature End */
    /*csg start*/
    access_mgmt_params_t            *p_access_mgmt_params = RRM_NULL;
    /*csg end*/
    /*SPR 18654 START*/
    U64 out_dl_allocated_ngbr_prbs = RRM_ZERO;
    U64 out_ul_allocated_ngbr_prbs = RRM_ZERO;
    U32 out_dl_required_num_prbs = RRM_ZERO;
    U32 out_ul_required_num_prbs = RRM_ZERO;
    /*SPR 18654 END*/
    /* CSR-00058598 and SPR-837-fix start*/
    rrm_bool_et is_request_for_emergency_erab = RRM_FALSE;
    U8 emergency_erab_arp = RRM_ZERO;
    /* SPR 16500 Fix Start */
    U8	ngbr_rab_for_emergency_present = RRM_FALSE;
    U8 	ngbr_rab_max_priority = RRM_ZERO;
#ifdef ENDC_ENABLED
	rrm_bool_et             is_endc_ue_x2_up = RRM_FALSE;
	rrm_bool_et             is_resource_available = RRM_TRUE;
#endif
    /* SPR 16500 Fix Stop */
    /* CSR-00058598 and SPR-837-fix end */
    /* SPR 15244 Fix Start */
    U8 count = RRM_ZERO;
    general_epc_params_t *p_general_epc_params = RRM_PNULL;
    /* SPR 15244 Fix End */

    /*SPR 18602 START*/
    /* code deleted */
    /*SPR 18602 END*/

    /*SPR 10329:start*/
    U8                              mme_id_index             = RRM_ZERO;
    /*SPR 10329:end*/
    /* SPR 16853: start */
    rrm_bool_et				is_default_bearer = RRM_FALSE;
    rrm_bool_et				first_ngbr_found = RRM_FALSE;
    /* SPR 16853: end */
    /*SPR 17438 Fix Start*/
    rrm_ue_index_t      ue_idx = RRM_ZERO;
    /*SPR 17438 Fix End*/
    /*spr 17437 fix start*/
    rrm_rab_removal_ctxt_t          local_rab_removal_ctxt;
    /*spr 17437 fix stop*/

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_g_rrm_ue_ctx);
    RRM_ASSERT(RRM_PNULL != p_g_rrm_ue_ctx->p_ue_context);
    /** Store the UE context in local pointer to this function */
    p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    /*SPR 22754 Fix Start*/
    /* CID 110728  Fix Start*/
    if (RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "UE Context not found");
        return RRM_FAILURE;
    }
    /* CID 110728  Fix End*/
    /*SPR 22754 Fix End*/
    p_rrm_ue_proc_ho_adm_data = (rrm_ue_proc_ho_adm_data_t *)
        p_ue_context->current_procedure.p_proc_data;

    /* SPS related changes start */
    rrm_cell_context_t       *p_cell_context = RRM_PNULL;
    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /*Coverity 93952 Fix Start*/
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found");
        return RRM_FAILURE;
    }
    /*Coverity 93952 Fix End*/
    /* SPR 15244 Fix Start */
    p_general_epc_params = &(p_cell_context->epc_info.epc_params.general_epc_params);
    /* SPR 15244 Fix End */
    /*SPR 18602 START*/
    p_ue_context->rrm_additional_bitrate_setup_mod = RRM_ZERO;
    p_ue_context->rrm_reduced_bitrate_setup_mod = RRM_ZERO;
    /*SPR 18602 END*/

    p_ue_context->ue_sps_data.is_sps_erab_established = RRM_FALSE;
    p_ue_context->ue_sps_data.sps_erab_highest_arp_priority = RRM_ZERO;
    p_ue_context->ue_sps_data.sps_erab_highest_qci_priority= RRM_ZERO;
    p_ue_context->ue_sps_data.sps_erab_id = RRM_OUT_OF_RANGE;
    /* SPS related changes end */

    /** Store the AMBR value in UE context for RBC */
    p_g_rrm_ue_ctx->p_ue_context->ue_agg_max_bit_rate =
        p_rrm_ue_proc_ho_adm_data->ambr;
    p_erab_setup_item_success_list = (rrm_ue_erab_setup_item_list_t *)
        rrm_mem_get(sizeof(rrm_ue_erab_setup_item_list_t));
    if( RRM_PNULL == p_erab_setup_item_success_list)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }
    p_erab_setup_item_failed_list = (rrm_ue_erab_failed_item_list_t *)
        rrm_mem_get(sizeof(rrm_ue_erab_failed_item_list_t));
    if( RRM_PNULL == p_erab_setup_item_failed_list)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        RRM_MEM_FREE(p_erab_setup_item_success_list);
        return RRM_FAILURE;
    }
    /* SPR-19056 START */
    p_erab_setup_item_list =  &p_rrm_ue_proc_ho_adm_data->erab_setup_list;
    /* SPR-19056 END */
    /*SPR 18602 START*/
    /*code removed*/
    /*SPR 18602 END*/

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "UE_INDEX[%d], performing RBC for total %d bearers ",
            p_ue_context->ue_index,
            p_erab_setup_item_list->num_of_list);
    p_rrm_ue_proc_ho_adm_data = (rrm_ue_proc_ho_adm_data_t *)
        (p_ue_context->current_procedure.p_proc_data);
    /* SPR 18250 Fix Start */
    if(p_ue_context->ue_capability_params.bitmask &
            RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        switch(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.pdcp_parameters.max_num_rohc_context_session)
        {
            case RRM_UE_CS2:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_TWO;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_ONE;
                break;

            case RRM_UE_CS4:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_TWO;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_TWO;
                break;

            case RRM_UE_CS8:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_TWO;
                break;

            case RRM_UE_CS12:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_THREE;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_FOUR;
                break;

            case RRM_UE_CS16:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_FOUR;
                break;

            case RRM_UE_CS24:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_THREE;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;

            case RRM_UE_CS32:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;

            case RRM_UE_CS48:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_SIX;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;

            case RRM_UE_CS64:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_EIGHT;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;

            case RRM_UE_CS128:
            case RRM_UE_CS256:
            case RRM_UE_CS512:
            case RRM_UE_CS1024:
            case RRM_UE_CS16384:
            case RRM_UE_SPARE2:
            case RRM_UE_SPARE1:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FIFTEEN;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;

            default:
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FIFTEEN;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
        }
    }
    /* SPR 18250 Fix End */

    p_erab_setup_item_list =  &p_rrm_ue_proc_ho_adm_data->erab_setup_list;
    p_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul = 
        p_rrm_ue_proc_ho_adm_data->ambr.ue_agg_max_bit_rate_ul;
    p_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl = 
        p_rrm_ue_proc_ho_adm_data->ambr.ue_agg_max_bit_rate_dl;
    /*coverity 11177, rrm_ue_history_t replace with ue_history, , rel 1.3.1*/
    RRM_MEMCPY(&p_ue_context->ue_history,
            &p_rrm_ue_proc_ho_adm_data->ue_history,
            sizeof(ue_history_t));
				/*SPR 20589 FIX START*/
            /*SPR 21848 Start*/
    rrm_ue_fill_restriction_list_from_proc_data_to_ue_context(&p_ue_context->ho_restriction_list,&p_rrm_ue_proc_ho_adm_data->ho_restriction_list);
    rrm_release_ho_restriction_list(&p_rrm_ue_proc_ho_adm_data->ho_restriction_list);
            /*SPR 21848 End*/
				/*SPR 20589 FIX End*/
    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/

    /* SPR 22553 FIXED START*/    
    if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_HO_ADM_REQ_SUB_PROFILE_ID_PRESENT)
    {    
        p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = 
            p_rrm_ue_proc_ho_adm_data->sub_profile_id;
        p_ue_context->rrm_sub_profile_id_info.bitmask |= RRM_UEM_CTX_TRANSE_PID_PRESENT;    
    }
    /* SPR 22553 FIXED END*/    
    /*SPR 18602 START*/
    /*code removed*/
    /*SPR 18602 END*/

    /* SRVCC SUPPORT START */
    p_ue_context->srvcc_config_info.srvcc_ho_op_possible =
        p_rrm_ue_proc_ho_adm_data->srvcc_op_possible;
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "srvcc_op_possible = %d in ho_adm_req",
            p_ue_context->srvcc_config_info.srvcc_ho_op_possible);
    /* SRVCC SUPPORT END */

    /* SPR 15244 Fix Start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"p_general_epc_params->num_valid_plmn is = %d",
            p_general_epc_params->num_valid_plmn);
    if(p_ue_context->ho_restriction_list.serving_plmn_identity.mnc.count != RRM_ZERO)
    {
        for(count = RRM_ZERO; count < p_general_epc_params->num_valid_plmn ; count++)
        {
            /* SPR: 15922 : Start */
            if(RRM_ZERO == RRM_MEMCMP(&(p_ue_context->ho_restriction_list.serving_plmn_identity.mcc),
                        &(p_general_epc_params->plmn_list[count].plmn_id.mcc), MAX_MCC_DIGITS))
                /* SPR: 15922 : End */
            {
                if(p_ue_context->ho_restriction_list.serving_plmn_identity.mnc.count == p_general_epc_params->plmn_list[count].plmn_id.num_mnc_digit)
                {
                    /* SPR: 15922 : Start */
                    /*SPR 17438 Fix Start*/ 
                    if(RRM_ZERO == RRM_MEMCMP(&(p_ue_context->ho_restriction_list.serving_plmn_identity.mnc.mnc),
                                &(p_general_epc_params->plmn_list[count].plmn_id.mnc),
                                MAX_MNC_OCTET_SIZE))
                        /*SPR 17438 Fix End*/ 
                        /* SPR: 15922 : End */
                    {
                        break;
                    }
                }
            }
        }
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"count is = %d & p_general_epc_params->num_valid_plmn is = %d",
                count,p_general_epc_params->num_valid_plmn);

        if (count != p_general_epc_params->num_valid_plmn)
        {
            if(p_general_epc_params->plmn_list[count].bitmask & RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT)
            {
                if (p_general_epc_params->plmn_list[count].cell_reserved_for_operator_use == RRM_OAM_RESERVED_FOR_OPERATOR)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"cell is reserved for operator ");
                    rrm_response.response = RRM_UE_FAILURE;
                    rrm_response.bitmask = RRM_ZERO;
                    rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
                    rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
                    /*SPR 16609 FIX START*/
                    if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                            (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                            (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                    {
                        rrm_response.cause.value = RRM_X2AP_CELL_NOT_AVAILABLE;
                    }
                    else
                    {
                        rrm_response.cause.value = CELL_NOT_AVAILABLE;
                    }
                    /*SPR 16609 FIX END*/
                    ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,p_ue_context, trans_id );
                    /* SPR: 15922 Fix start */
                    RRM_MEM_FREE(p_erab_setup_item_failed_list);
                    RRM_MEM_FREE(p_erab_setup_item_success_list);
                    /*SPR 17438 Fix Start*/
                    ue_idx = p_ue_context->ue_index;
                    if(RRM_FAILURE == rrm_ue_resource_clean_up( p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                "UE_INDEX[%d],Failed to delete ue context for the UE" ,ue_idx);
                        /*SPR 18195 Fix Start*/
                        ret_val = RRM_FAILURE;
                        /*SPR 18195 Fix Stop*/

                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                                "successfully deleted ue context[%d]",ue_idx);
                        p_ue_context = RRM_PNULL;
                        p_g_rrm_ue_ctx->p_ue_context = RRM_PNULL;
                    }
                    RRM_UT_TRACE_EXIT();
                    /*SPR 17438 Fix End*/
                    /* SPR: 15922 Fix End */

                    return ret_val;
                }
            }
        }
    }
    else if(RRM_ONE == p_general_epc_params->num_valid_plmn)
    {
        if(p_general_epc_params->plmn_list[RRM_ZERO].bitmask & RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT)
        {
            if (p_general_epc_params->plmn_list[count].cell_reserved_for_operator_use == RRM_OAM_RESERVED_FOR_OPERATOR)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"cell is reserved for operator");

                rrm_response.response = RRM_UE_FAILURE;
                rrm_response.bitmask = RRM_ZERO;
                rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
                rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
                /*SPR 16609 FIX START*/
                if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                        (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                        (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                {
                    rrm_response.cause.value = RRM_X2AP_CELL_NOT_AVAILABLE;
                }
                else
                {
                    rrm_response.cause.value = CELL_NOT_AVAILABLE;
                }
                /*SPR 16609 FIX END*/
                ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,
                        p_ue_context, trans_id );
                /* SPR: 15922 Fix start */
                RRM_MEM_FREE(p_erab_setup_item_failed_list);
                RRM_MEM_FREE(p_erab_setup_item_success_list);
                /*SPR 17438 Fix Start*/
                ue_idx = p_ue_context->ue_index;
                if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                            "UE_INDEX[%d],Failed to delete ue context for the UE" ,ue_idx);
                    /*SPR 18195 Fix Start*/
                    ret_val = RRM_FAILURE;
                    /*SPR 18195 Fix Stop*/

                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "successfully deleted ue context[%d]",ue_idx);
                    p_ue_context = RRM_PNULL;
                    p_g_rrm_ue_ctx->p_ue_context = RRM_PNULL;
                }
                RRM_UT_TRACE_EXIT();
                /*SPR 17438 Fix End*/
                /* SPR: 15922 Fix End */

                return ret_val;
            }
        }
    }
    else
    {
        /*SPR 22843 Fix Start*/
        if(p_general_epc_params->num_valid_plmn > 1)
        {
            if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT)
            {
                if(p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mnc.count != RRM_ZERO)
                {
                    for(count = RRM_ZERO; count < p_general_epc_params->num_valid_plmn ; count++)
                    {
                        if(RRM_ZERO == RRM_MEMCMP(&(p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mcc),
                                    &(p_general_epc_params->plmn_list[count].plmn_id.mcc), MAX_MCC_DIGITS))
                        {
                            if(p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mnc.count == p_general_epc_params->plmn_list[count].plmn_id.num_mnc_digit)
                            {
                                if(RRM_ZERO == RRM_MEMCMP(&(p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mnc.mnc),
                                            &(p_general_epc_params->plmn_list[count].plmn_id.mnc),
                                            MAX_MNC_OCTET_SIZE)) 
                                {
                                    if(p_general_epc_params->plmn_list[count].bitmask & RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT)
                                    {
                                        if (p_general_epc_params->plmn_list[count].cell_reserved_for_operator_use == RRM_OAM_RESERVED_FOR_OPERATOR)
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"cell is reserved for operator");
        /*SPR 22843 Fix End*/
        rrm_response.response = RRM_UE_FAILURE;
        rrm_response.bitmask = RRM_ZERO;
        rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
        /*SPR 22843 Fix Start*/
                                            rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
                                            if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                                    (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                                    (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
        {
                                                rrm_response.cause.value = RRM_X2AP_CELL_NOT_AVAILABLE;
        }
        else
        {
                                                rrm_response.cause.value = CELL_NOT_AVAILABLE;
        }
        /*SPR 22843 Fix End*/
        ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,
                p_ue_context, trans_id );
        /* SPR: 15922 Fix start */
        RRM_MEM_FREE(p_erab_setup_item_failed_list);
        RRM_MEM_FREE(p_erab_setup_item_success_list);
        /*SPR 22843 Fix Start*/
                                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                                            {
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                                          "Failed to delete ue context" );
                                                ret_val = RRM_FAILURE;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                          "successfully deleted the ue context");
                                                p_ue_context = RRM_PNULL;
                                                p_g_rrm_ue_ctx->p_ue_context = RRM_PNULL;
                                            }
                                            RRM_UT_TRACE_EXIT();

        return ret_val;

                                        }
                                    }
                                }
                            }
                        } 
                    }
                }
            }
        }
        /*SPR 22843 Fix End*/
    }
    /* SPR 15244 Fix End */


    /*csg start*/
    if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT)
    {
        p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
            p_rrm_ue_proc_ho_adm_data->csg_membership_status;
    }
    else
    {
        p_ue_context->rrm_csg_membership.rrm_csg_membership_status = 
            RRM_NOT_MEMBER;
    }
    rrm_adjust_csg_nsg_counter(RRM_INVALID,p_ue_context);
    p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
    /* SPR 15301 Fix start */
    if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_HO_ADM_REQ_MEAS_SUBFRAME_PATTERN_PRESENT)
    {
        p_ue_context->is_csi_pattern_to_release = RRM_TRUE;
    }
    else
    {
        p_ue_context->is_csi_pattern_to_release = RRM_FALSE;
    }
    /* SPR 15301 Fix end */
    if(p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_HYBRID)
    {
        p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
        if(p_access_mgmt_params->max_csg_members != RRM_INDEX_ERR)
        {
            ret_val = rrm_handle_csg_membership_hybrid_for_ho(p_ue_context,p_access_mgmt_params->max_csg_members,
                    p_access_mgmt_params->max_non_csg_members);

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Max csg members is set as minus one");
            ret_val = rrm_handle_max_csg_mem_minus_one_hybrid_for_ho(p_ue_context,p_access_mgmt_params);
        }

        /*no need to check establishment cause during incoming
          HO.As establishment cause does not come in ho_adm_req*/
        if(RRM_FAILURE == ret_val)
        {
            rrm_response.response = RRM_UE_FAILURE;
            /*+Coverity :CID 25214+*/
            rrm_response.bitmask = RRM_ZERO;
            /*-Coverity :CID 25214-*/
            rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
            rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
            /*SPR 16609 FIX START*/
            if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                    (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                    (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
            {
                rrm_response.cause.value = RRM_X2AP_UNSPECIFIED;
            }
            else
            {
                rrm_response.cause.value = HANDOVER_CANCELLED;
            }
            /*SPR 16609 FIX END*/
            ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,
                    p_ue_context, trans_id );
            rrm_decrease_csg_non_csg_counter(p_ue_context);
            /* SPR: 15922 Fix start */
            RRM_MEM_FREE(p_erab_setup_item_failed_list);
            RRM_MEM_FREE(p_erab_setup_item_success_list);
            /*SPR 17438 Fix Start*/
            /*Code Deleted*/ 
            /*SPR 17438 Fix End*/
            /* SPR: 15922 Fix End */
            return ret_val;
        }
    }
    else
    {
        /* CSR 58774 Fix Start */
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], cell is not hybrid, skipping csg validation",
                p_ue_context->ue_index);
        /* CSR 58774 Fix End */
    }
    /*csg end*/

    /* CA: Stage3 HO code start */
    if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_SCELL_CANDIDATE_INFO_PRESENT)
    {
        U8                     counter = RRM_ZERO;
        U16                    scell_pci_list[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
        rrm_cell_index_t  scell_index_list[RRM_MAX_SCELL];
        U8                     ue_category = RRM_ZERO;
        U8                     access_stratum_release = RRM_OUT_OF_RANGE;

        for(counter = RRM_ZERO; counter < RRM_MAX_SCELL; counter++)
        {
            scell_index_list[counter] = RRM_OUT_OF_RANGE;
            scell_pci_list[counter] = RRM_OUT_OF_RANGE;
        }

        p_ue_context->scell_candidate_count = 
            p_rrm_ue_proc_ho_adm_data->scell_candidate_count;
        /*cov fix start 55814*/
        for(counter = RRM_ZERO; 
                ((counter < p_rrm_ue_proc_ho_adm_data->scell_candidate_count) && (counter < RRM_MAX_SCELL));
                counter++)
            /*cov fix end 55814*/
        {
            p_ue_context->candidate_scell_info[counter].pci = 
                p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].pci;

            p_ue_context->candidate_scell_info[counter].carrier_freq =
                p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].carrier_freq;

            if(p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].bitmask & CANDIDATE_SCELL_RSRP_PRESENT)
            {
                p_ue_context->candidate_scell_info[counter].rsrp = 
                    p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].rsrp;
            }

            if(p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].bitmask & CANDIDATE_SCELL_RSRQ_PRESENT)
            {
                p_ue_context->candidate_scell_info[counter].rsrq = 
                    p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].rsrq;
            }
            scell_pci_list[counter] = p_rrm_ue_proc_ho_adm_data->candidate_scell_info[counter].pci;
        }

        rrm_get_release_and_category_of_ue(p_ue_context,
                &ue_category,
                &access_stratum_release);

        if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_CA_CONFIG_INFO_PRESENT)
        {
            /* This Cell should be CA eligible for Carrier Aggregation*/
            if(RRM_TRUE == p_cell_context->operator_info.ca_config.is_ca_eligible)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "IS_CA_ELIGIBLE: %d", p_cell_context->operator_info.ca_config.is_ca_eligible);
		/*SPR22034 Changes Start*/
                /* The release of the UE should be equal or greater than rel10 for CA */
                if(RRM_REL10 <= access_stratum_release)
		/*SPR22034 Changes End*/
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "ACCESS_STRATUM_RELEASE: %d", access_stratum_release);

                    /* The UE category should be one of 4,5 or 6,7,8 */
                    if(ue_category >= RRM_FOUR && ue_category <= RRM_EIGHT)
                    {
                        rrm_fetch_scell_candidate_cell_index_from_cellm(scell_pci_list, 
                                scell_index_list,
                                p_cell_context);

                        rrm_check_and_update_ue_scell_list(p_ue_context,
                                p_cell_context,
                                scell_index_list);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "UE_CATEGORY: %d", ue_category);
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "ACCESS_STRATUM_RELEASE: %d, so no need to check CA pre-requisites",
                            access_stratum_release);
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "CA_ELIGIBLE is OFF [%d] for cell_index[%d]",
                        p_cell_context->operator_info.ca_config.is_ca_eligible,
                        p_ue_context->cell_index);
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "CA info is absent for cell_index[%d]",
                    p_ue_context->cell_index);
        }
    }
    /* CA: Stage3 HO code end */
    /*SPR 10329:fix start*/
    if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT)
    {
        p_ue_context->is_gu_grp_info_present = RRM_TRUE;
        RRM_MEMCPY(&p_ue_context->gu_group_id.plmn_id.mcc,
                &p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mcc,
                RRM_THREE);
        RRM_MEMCPY(&p_ue_context->gu_group_id.plmn_id.num_mnc_digit,
                &p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mnc.count,
                RRM_ONE);
        RRM_MEMCPY(&p_ue_context->gu_group_id.plmn_id.mnc,
                &p_rrm_ue_proc_ho_adm_data->gummei_info.plmn_identity.mnc.mnc,
                RRM_THREE);
        for(mme_id_index = RRM_ZERO; mme_id_index < RRM_MAX_MME_GRP_BYTES; mme_id_index ++)
        {
            p_ue_context->gu_group_id.mme_group_id[mme_id_index]= p_rrm_ue_proc_ho_adm_data->gummei_info.mme_group_id[mme_id_index];
        }
    }
    else
    {
        p_ue_context->is_gu_grp_info_present = RRM_FALSE;
    }
    /*SPR 10329:fix end*/

    /* SPR_21459 Fix - Start */
    if(p_rrm_ue_proc_ho_adm_data->bitmask & RRM_HO_ADM_REQ_MME_ID_PRESENT)
    {
        p_ue_context->mme_id = p_rrm_ue_proc_ho_adm_data->mme_id;
    }
    /* SPR_21459 Fix - End */

    /* SPS related changes start */
    RRM_MEMCPY(&p_ue_context->ue_sps_data.sps_config, 
            &p_rrm_ue_proc_ho_adm_data->sps_config, 
            sizeof(rrm_sps_config_t));

    RRM_MEMCPY(&p_ue_context->ue_sps_data.drx_config, 
            &p_rrm_ue_proc_ho_adm_data->drx_config, 
            sizeof(rrm_drx_config_t));

    if(p_ue_context->ue_capability_params.
            rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.bitmask &
            RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Checking for sps provision of UE_INDEX [%d]",
                p_ue_context->ue_index);

        /* CSR-82437[SPR-12178]-fix start */
        rrm_checks_ue_supported_rats(p_ue_context);
        /* CSR-82437[SPR-12178]-fix end */

        /* SPR_13793_start */
        if(RRM_REL8 == p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
        {
            if ((RRM_FALSE != p_cell_context->sps_on) &&
                    /*Start:Bug 762*/
                    (rrm_is_set_fgi_bit(p_ue_context,RRM_THREE)) && 
                    (rrm_is_set_fgi_bit(p_ue_context,RRM_SEVEN)))
                /*End:Bug 762*/
            {
                if (RRM_FALSE == p_ue_context->ue_sps_data.is_sps_erab_established)
                {
                    rrm_find_sps_erab_highest_priority (p_erab_setup_item_list,
                            p_ue_context, p_cell_context);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                            "Error:UE already has a SPS RAB established in case of HO");
                }
            } 

        }
        else
        {
            /* SPR_13793_end */
            if ((RRM_FALSE != p_cell_context->sps_on) &&
                    /*Start:Bug 762*/
                    (rrm_is_set_fgi_bit(p_ue_context,RRM_TWENTY_NINE)) && 
                    (rrm_is_set_fgi_bit(p_ue_context,RRM_SEVEN)))
                /*End:Bug 762*/
            {
                if (RRM_FALSE == p_ue_context->ue_sps_data.is_sps_erab_established)
                {
                    rrm_find_sps_erab_highest_priority (p_erab_setup_item_list,
                            p_ue_context, p_cell_context);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                            "Error:UE already has a SPS RAB established in case of HO");
                }
            } 
            /* SPR_13793_start */
        }
        /* SPR_13793_end */
    }
    /* SPS related changes end */
    /* CSR 00055769  : inter-freq HO code changes start*/
    /* SPR 21496 Fix Start */ 
    p_ue_context->p_meas_config_of_ho_adm = (rrm_meas_config_t*)rrm_mem_get(sizeof(rrm_meas_config_t));
    rrm_map_source_meas_config((p_ue_context->p_meas_config_of_ho_adm),
            &(p_rrm_ue_proc_ho_adm_data->meas_config));
    /* SPR 21496 Fix End */ 
    /* CSR 00055769  : inter-freq HO code changes end*/
    /* CSR-00058598 and SPR-837-fix start*/
    if ((RRM_SUCCESS == rrm_check_ue_arp_val_for_emergency_ho_admin(p_ue_context))    &&
            (RRM_OAM_ACCESS_MODE_CLOSE == p_access_mgmt_params->access_mode)   &&
            (RRM_NOT_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status))
    {
        is_request_for_emergency_erab = RRM_TRUE;
        emergency_erab_arp = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_ue_context->cell_index]->epc_info.epc_params.emergency_erab_arp;
        /* SPR 16500 Fix Start */
        for ( count = RRM_NULL ; count < p_erab_setup_item_list->num_of_list;
                count++ )
        {
            if ( (((U8)(p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_ue_context->cell_index]->
                                epc_info.epc_params.emergency_erab_arp)) == 
                        (p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                         erab_level_qos_params.alloc_and_reten_prior.priority_level)) && 
                    (p_rrm_ue_proc_ho_adm_data->erab_setup_list.erab_item[index].
                     erab_level_qos_params.qci >= RRM_NGBR_QCI_5))
            {
                ngbr_rab_for_emergency_present = RRM_TRUE;
                break;	
            }
        }

        if ( ngbr_rab_for_emergency_present == RRM_FALSE )
        {
            ngbr_rab_max_priority = rrm_ue_emergency_set_max_ngbr_rab_priority(p_ue_context);    
        }
        /* SPR 16500 Fix Stop */
    }
    /*SPR 15436 26Mar changes start*/
    rrm_quick_sort(p_erab_setup_item_list->erab_item,p_erab_setup_item_list->num_of_list, sizeof(rrm_ue_erab_setup_item_t),
            compare_by_priority);
    /*SPR 15436 26Mar changes end*/

    /*spr 17437 fix start */
    ylInit(&local_rab_removal_ctxt.rabs_to_rem_list);
    ylInit(&local_rab_removal_ctxt.rab_rem_container.ue_to_remove_list);
    ylInit(&local_rab_removal_ctxt.rab_rem_container.ue_rab_list);
    /*spr 17437 fix stop */

    /* Coverity_ID_Fix_55814 */
    for(index = RRM_NULL; ((index<p_erab_setup_item_list->num_of_list) &&
                (index < RRM_MAX_NUM_DRB_PER_UE));index++)
    {

        if ((RRM_TRUE == is_request_for_emergency_erab)   &&
                (emergency_erab_arp != p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level))
        {
            /* SPR 16500 Fix Start */
            /* According to specification 23.203 section 6.17, priority of the NGBR RABS
             * based on Packet Delay Budget & Packet Error Loss Rate is interpreted as :
             * QCI ( 6,8,9,7,5 ) where QCI 6 will be of highest priority and 5 will be of 
             * lowest . Selecting the first NGBR RAB of highest priority in case of request
             * for emergency ERAB irrespective of the fact that whether the OAM configured ARP
             * and the priority_level for this highest priority RAB matches or not */
            if ( (ngbr_rab_for_emergency_present == RRM_FALSE ) &&
                    ( ngbr_rab_max_priority == p_erab_setup_item_list->erab_item[index].
                      emergency_arp_ngbr_priority ))    
            {
                ret_val = RRM_SUCCESS;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                        "Selecting high priority NGBR RAB for emergency ."
                        "OAM config ARP %d, emergency_erab_arp = %d , erab_id = %d",
                        emergency_erab_arp, p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.alloc_and_reten_prior.priority_level, 
                        p_erab_setup_item_list->erab_item[index].erab_id );

            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                        "OAM config ARP %d, emergency_erab_arp = %d",
                        emergency_erab_arp, p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.alloc_and_reten_prior.priority_level);
            }
            /* SPR 16500 Fix Stop */
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }
        /*spr 17437 fix start*/
        rrm_reset_rab_removal_ctxt(&local_rab_removal_ctxt);
        /*spr 17437 fix stop*/

        if(RRM_SUCCESS == ret_val)
        {
            /*SPR 18602 START*/
            /*code removed*/
            /*SPR 18602 END*/

            /* SPR 16853: start */
            if ((RRM_FALSE == first_ngbr_found) && (p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci >= RRM_NGBR_QCI_5 &&
                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci <= RRM_NGBR_QCI_9))
            {
                /* SPR_17377_Warning_fix + */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[ERB setup] Default bearer setup request with RABId[%u], QCI[%u], ARP[%u]",
                        p_erab_setup_item_list->erab_item[index].erab_id,
                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level);
                /* SPR_17377_Warning_fix - */
                first_ngbr_found = RRM_TRUE;
                is_default_bearer = RRM_TRUE;
            }
            else
            {
                is_default_bearer = RRM_FALSE;
            }
            /* SPR 16853: end */
            /*SPR 16944 START*/
            if (RRM_SUCCESS == rrm_check_if_qci_supported(p_cell_context,
                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci))
            {
                /*SPR 16944 END*/

                /** Perform RBC */
                ret_val = rrm_ue_rbc_erab_setup(
                        p_ue_context,
                        /* SPR 19968 Start */
                        &p_erab_setup_item_list->erab_item[index],
                        p_rrm_ue_proc_ho_adm_data->ambr,
                        /* SPR 19968 END */
                        gbr_configd_count,
                        ngbr_configd_count,
                        gbr_success_count,
                        ngbr_success_count,
                        /*SPR 18602 START*/
                        /*code deleted*/
                        /*SPR 18602 END*/
                        /* FGI Feature Start */
                        &num_temp_um_mode,
                        &num_temp_am_mode,
                        &data_transfer_mode, /* FGI Feature End */
                        &out_dl_allocated_ngbr_prbs,
                        &out_ul_allocated_ngbr_prbs,
                        &out_dl_required_num_prbs,
                        &out_ul_required_num_prbs,
                        /* SPR 16853: start */
                        is_default_bearer,
                        /*spr 17437 fix start*/
                        &local_rab_removal_ctxt
#ifdef ENDC_ENABLED 
						,is_endc_ue_x2_up
						,&is_resource_available
#endif
						);
                /*spr 17437 fix stop*/

				/* SPR 16853: end */
				/* CSR-00058598 and SPR-837-fix end */

				if(ret_val == RRM_SUCCESS)
				{
                    /*+ SPR 18090 */
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                            RRM_DETAILED,"UE_INDEX[%d],RBC "
                            "successful for erab id %d , lc_id %d, drb_id %d", 
                            p_ue_context->ue_index,
                            p_erab_setup_item_list->erab_item[index].erab_id,
                            p_erab_setup_item_list->erab_item[index].lc_id,
                            p_erab_setup_item_list->erab_item[index].drb_id);
                    /*spr 17437 fix start*/
                    rrm_fill_rab_removal_info_in_ue_ctxt(
                            p_ue_context,
                            &local_rab_removal_ctxt);
                    /*spr 17437 fix stop*/

                    /*- SPR 18090 */
					p_erab_setup_item_success_list->erab_item[success_count].
						erab_id =
						p_erab_setup_item_list->erab_item[index].erab_id;
					p_erab_setup_item_success_list->erab_item[success_count].
						drb_id =
						p_erab_setup_item_list->erab_item[index].drb_id;
                    /*+ SPR 18090 */
                    p_erab_setup_item_success_list->erab_item[success_count].lc_id =
                        p_erab_setup_item_list->erab_item[index].lc_id;
                    /*- SPR 18090 */

					p_erab_setup_item_success_list->erab_item[success_count].
						erab_level_qos_params.bitmask =
						p_erab_setup_item_list->erab_item[success_count].
						erab_level_qos_params.bitmask;

					p_erab_setup_item_success_list->erab_item[success_count].
						erab_level_qos_params.qci =
						p_erab_setup_item_list->erab_item[index].
						erab_level_qos_params.qci;

					p_erab_setup_item_success_list->erab_item[success_count].
						erab_level_qos_params.gbr_qos_info.
						erab_max_bit_rate_dl =
						p_erab_setup_item_list->erab_item[index].
						erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl;

					p_erab_setup_item_success_list->erab_item[success_count].
						erab_level_qos_params.gbr_qos_info.
						erab_max_bit_rate_ul =
						p_erab_setup_item_list->erab_item[index].
						erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul;

					p_erab_setup_item_success_list->erab_item[success_count].
						erab_level_qos_params.gbr_qos_info.
						erab_guar_bit_rate_dl =
						p_erab_setup_item_list->erab_item[index].
						erab_level_qos_params.gbr_qos_info.
						erab_guar_bit_rate_dl;

					p_erab_setup_item_success_list->erab_item[success_count].
						erab_level_qos_params.gbr_qos_info.
						erab_guar_bit_rate_ul =
						p_erab_setup_item_list->erab_item[index].
						erab_level_qos_params.gbr_qos_info.
						erab_guar_bit_rate_ul;
					/*SPR 5589 Fix START*/
					p_erab_setup_item_success_list->erab_item[success_count].dl_fwding =
						p_erab_setup_item_list->erab_item[index].dl_fwding;
					/*SPR 5589 Fix END*/
                   /*SPR_18138_Fix_Start*/
                    p_erab_setup_item_success_list->erab_item[success_count].data_fwding_not_possible = p_erab_setup_item_list->erab_item[index].data_fwding_not_possible;
                    /*SPR_18138_Fix_End*/

					if(p_erab_setup_item_list->erab_item[index].
							erab_level_qos_params.qci >= RRM_GBR_QCI_1 &&
							p_erab_setup_item_list->erab_item[index].
							erab_level_qos_params.qci <= RRM_GBR_QCI_4)
					{
						gbr_success_count++;
					}
					else if(p_erab_setup_item_list->erab_item[index].
							erab_level_qos_params.qci >= RRM_NGBR_QCI_5 &&
							p_erab_setup_item_list->erab_item[index].
							erab_level_qos_params.qci <= RRM_NGBR_QCI_9)
					{
						ngbr_success_count++;
					}

					/* SPR 5476 Fix start */

					p_erab_setup_item_success_list->erab_item[success_count].
						data_transfer_mode = data_transfer_mode;

					/* SPR 5476 Fix stop  */

					success_count++;
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,
							RRM_DETAILED,"UE_INDEX[%d],RBC "
							"failed for erab id %d ",
							p_ue_context->ue_index,
							p_erab_setup_item_list->erab_item[index].erab_id);
					p_erab_setup_item_failed_list->
						erab_to_be_release_item[failure_count].erab_id =
						p_erab_setup_item_list->erab_item[index].erab_id;
					/* SPR 8533: code changes start */
					p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
						cause.type = RADIO_NETWORK_LAYER_TYPE; /*radioNetworkLayer*/
					/* SPR 16609 FIX START */
					/*SPR 16944 START*/
					/*code deleted*/
					/*SPR 16944 END*/
					/*SPR 16944 START*/
					if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
							(HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
							(HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
					{
						p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].cause.value = RRM_X2AP_NO_RADIO_RESRCS_AVLAL_IN_TRGET_CELL; /*Radio resources not available*/				
					}
					else
					{
						p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].cause.value = RADIO_RESOURCES_NOT_AVAILABLE; /*Radio resources not available*/
					}
					/*SPR 16944 END*/
					/* SPR 16609 FIX END */
					failure_count++;
				}
				/*SPR 16944 START*/
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
						RRM_DETAILED,"QCI [%d] is not configured hence cannot admit ERAB[%d] for UE [%u] ",
						p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
						p_erab_setup_item_list->erab_item[index].erab_id,
						p_ue_context->ue_index);
				p_erab_setup_item_failed_list->
					erab_to_be_release_item[failure_count].erab_id =
					p_erab_setup_item_list->erab_item[index].erab_id;
				/* SPR 8533: code changes start */
				p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
					cause.type = RADIO_NETWORK_LAYER_TYPE; /*radioNetworkLayer*/
				/* SPR 8533: code changes end */

				if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
						(HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
						(HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
				{
					p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].cause.value = RRM_X2AP_NOT_SUPPORTED_QCI_VALUE;	
				}
				else
				{			
					p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].cause.value = NOT_SUPPORTED_QCI_VALUE; /*Not supported QCI Value*/
				}
				failure_count++;
			}
			/*SPR 16944 END*/
		}
        /*spr 17437 fix start*/
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                    RRM_ERROR,"Cannot admit non Emergency QCI [%u],ERAB[%u] for UE [%u] Cell with is Closed,UE is Non Member",
                    p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
                    p_erab_setup_item_list->erab_item[index].erab_id,
                    p_ue_context->ue_index);
            p_erab_setup_item_failed_list->
                erab_to_be_release_item[failure_count].erab_id =
                p_erab_setup_item_list->erab_item[index].erab_id;
            p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                cause.type = RADIO_NETWORK_LAYER_TYPE;
            p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].cause.value = UNSPECIFIED;
            failure_count++;
        }
        /*spr 17437 fix stop*/

	}   
    /*spr 17437 fix start*/
    rrm_process_rab_removal_info_in_ue_ctxt(p_ue_context);
    /*spr 17437 fix stop*/

	/*Store allocated prbs for non-gbr bearers(required prb for ue-ambr)*/
	/* Start changes for SPR 490 */
	if((RRM_ZERO != out_dl_required_num_prbs)||(RRM_ZERO != out_ul_required_num_prbs))
	{
		rrm_cellm_set_dl_allocated_ngbr_prb(p_ue_context->cell_index, out_dl_allocated_ngbr_prbs
				+ out_dl_required_num_prbs);
		rrm_cellm_set_ul_allocated_ngbr_prb(p_ue_context->cell_index, out_ul_allocated_ngbr_prbs
				+ out_ul_required_num_prbs);
		/*Bug_776_changes_start*/
		rrm_cellm_increment_dl_allocated_ngbr_prb_per_ue(
				p_ue_context, out_dl_required_num_prbs);
		rrm_cellm_increment_ul_allocated_ngbr_prb_per_ue(
				p_ue_context, out_ul_required_num_prbs);
		/*Bug_776_changes_end*/
	}
	/* End changes for SPR 490 */
	/*end store*/
	p_erab_setup_item_success_list->num_of_list = success_count;
	p_erab_setup_item_failed_list->num_of_list = failure_count;
    /*+- SPR 18090 code removed */
    p_ue_context->current_procedure.p_erb_success_list =
		(void *)p_erab_setup_item_success_list;
	p_ue_context->current_procedure.p_erb_failed_list =
		(void *)p_erab_setup_item_failed_list;
	p_ue_context->ue_state = RRM_UE_STATE_HO_ONGOING;
	RRM_MEMSET(&rrm_response,RRM_ZERO,sizeof(rrm_response_t));
	/** Fill and send ERAB setup response */
	if(((ngbr_success_count !=RRM_ZERO)&&(success_count == \
					p_erab_setup_item_list->num_of_list))&& (failure_count == RRM_ZERO ))
	{

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, \
				RRM_DETAILED,"UE_INDEX[%d],Sending "
				"HO_ADM_RESP with response SUCCESS",
				p_ue_context->ue_index);
		rrm_response.response = RRM_UE_SUCCESS;
		ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,
				p_ue_context, trans_id );
	}
	else if((success_count == RRM_ZERO) &&
			(failure_count == p_erab_setup_item_list->num_of_list))
	{
		/*SPR 17370 START*/
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, \
				RRM_ERROR,"UE_INDEX[%d], Sending "
				"HO_ADM_RESP with response FAILURE because all RABs admission failed",
				p_ue_context->ue_index);
		rrm_response.response = RRM_UE_FAILURE;
		/*CODE DELETED*/
		if(p_erab_setup_item_failed_list != RRM_PNULL)
		{
			if(p_erab_setup_item_failed_list->num_of_list > RRM_ZERO)
			{
				if(RRM_SUCCESS == rrm_check_for_common_cause_in_failed_list(p_erab_setup_item_failed_list))
				{
					rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
					rrm_response.cause.type   = p_erab_setup_item_failed_list->erab_to_be_release_item[RRM_ZERO].cause.type;
					rrm_response.cause.value  = p_erab_setup_item_failed_list->erab_to_be_release_item[RRM_ZERO].cause.value;
				}
				else
				{
					rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
					rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
					if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
							(HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
							(HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
					{
						rrm_response.cause.value = RRM_X2AP_UNSPECIFIED;
					}
					else
					{
						rrm_response.cause.value = UNSPECIFIED;
					}
				}

			}
		}
		else
		{
			rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
			rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
			if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
					(HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
					(HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
			{
				rrm_response.cause.value = RRM_X2AP_UNSPECIFIED;
			}
			else
			{
				rrm_response.cause.value = UNSPECIFIED;
			}

			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"p_erab_setup_item_failed_list is NULL");
		}
		/*SPR 17370 END*/
		/*SPR 16609 FIX END*/
		/* Raise Event RRM_EVENT_LOCAL_HO_IN_PREP_ATTEMPT START*/
		/* CSR-00058598 and SPR-837-fix start*/
        if (RRM_TRUE == is_request_for_emergency_erab)
        {
            rrm_raise_event_ho_in_prep_failure(p_ue_context, HANDOVER_TARGET_NOT_ALLOWED);
        }
        else
        {
            rrm_raise_event_ho_in_prep_failure(p_ue_context, RRM_EVENT_CANNOT_HANDLE_BEARER_COMBINATION);
        }
        /* CSR-00058598 and SPR-837-fix end */
        /* Raise Event RRM_EVENT_LOCAL_HO_IN_PREP_ATTEMPT END*/
        /* SPR 20742 start */
        rrm_decrease_csg_non_csg_counter(p_ue_context);
        /* SPR 20742 end */

        ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,
                p_ue_context, trans_id );
    }
    else if(((ngbr_success_count!= RRM_ZERO)&&(success_count != RRM_ZERO)) &&
            (failure_count  != RRM_ZERO ))
    {
        /* SPR 20742 start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, \
                RRM_WARNING,"UE_INDEX[%d],Sending "
                "HO_ADM_RESP with response PARTIAL_SUCCESS",
                p_ue_context->ue_index);
        /* SPR 20742 end */
        rrm_response.response = RRM_UE_PARTIAL_SUCCESS;
        rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
        /* SPR 8533: code changes start */
        rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
        /* SPR 8533: code changes start */
        /*SPR 16609 FIX START*/
        if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
        {
            rrm_response.cause.value = RRM_X2AP_PARTIAL_HANDOVER;
        }
        else
        {
            rrm_response.cause.value = PARTIAL_HANDOVER;
        }
        /*SPR 16609 FIX END*/
        ret_val = rrm_build_and_send_ho_adm_resp (
                rrm_response, p_ue_context, trans_id );
    }
	else if(ngbr_success_count == RRM_ZERO)
	{
		/*SPR 17370 START*/
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,\
				RRM_ERROR,"UE_INDEX[%d],Sending "
				"HO_ADM_RESP with response FAILURE because no NGBR RAB can be admitted for the UE",
				p_ue_context->ue_index);
		/*SPR 17370 END*/
		rrm_response.response = RRM_UE_FAILURE;
		rrm_response.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
		rrm_response.cause.type = RADIO_NETWORK_LAYER_TYPE;
		/*SPR 16609 FIX START*/
		if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
				(HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
				(HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
		{
			rrm_response.cause.value = RRM_X2AP_UNSPECIFIED;
		}
		else
		{
			/*SPR 17370 START*/
			rrm_response.cause.value = UNSPECIFIED;
			/*SPR 17370 END*/
		}
		/*SPR 16609 FIX END*/
		rrm_decrease_csg_non_csg_counter(p_ue_context);
		ret_val = rrm_build_and_send_ho_adm_resp( rrm_response,
				p_ue_context, trans_id );
	}
	else /**succes and failure list both are
	       zero i.e number of requested erb is zero*/
	{

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Number of requested rab is zero");
		ret_val = RRM_FAILURE;
	}
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	/* SPR 15462 Fix Code Deleted */
    /*spr 17437 fix start*/
    RRM_MEMSET(&p_ue_context->erab_to_be_released_item_list,RRM_ZERO,sizeof(rrm_ue_erab_to_be_released_item_list_t));
    rrm_reset_rab_removal_container(&p_ue_context->adm_ctrl_rec.rab_removal_container);
    /* SPR 21496 Fix Start */ 
    if (RRM_PNULL != p_ue_context->p_meas_config_of_ho_adm)
    {
      RRM_MEM_FREE(p_ue_context->p_meas_config_of_ho_adm);
    }
    /* SPR 21496 Fix End */ 
    /*spr 17437 fix stop*/


	RRM_UT_TRACE_EXIT();
	return ret_val;

}

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_ho_adm_cnf 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_ho_adm_cnf message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_ho_adm_cnf (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et				ret_val = RRM_SUCCESS;
	rrm_ue_context_t                    *p_ue_context = RRM_PNULL;
	/*SPR 22745 Fix Start*/
	/*CID 121562 */
	rrm_ue_proc_ho_adm_cnf_data_t       *p_rrm_proc_ho_cnf_data = RRM_PNULL;
	/*SPR 22745 Fix End*/
	rrm_ue_erab_setup_item_list_t       *p_rrm_ue_erab_success_list = RRM_PNULL;
	/*Start: SPR 8892*/
	/*One line deleted*/
	/*End: SPR 8892*/
	U8                                   cnf_index = RRM_NULL;
	U8                                   success_index = RRM_NULL;
	/* SPS related changes start */
	rrm_bool_et                          fail_sps_erab_found = RRM_FALSE;
	U8                                    fail_erab_index = RRM_ZERO;
	/* SPS related changes end */
	/*SPR_18491_START*/
	rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
	/* SPR_18491_END*/

	/*SPR 15994 Fix start*/
	rrm_ue_index_t                        ue_index  = RRM_ZERO;
	/*SPR 15994 Fix stop*/

	/* SPR_15886_Fix: Start */
	rrm_bool_et                     is_ecid_meas_resp     = RRM_FALSE;
	U8                              meas_id         = RRM_NULL;
	rrm_meas_ecid_resp_et          ecid_meas_resp_action = RRM_ECID_MEAS_CONTINUE;
	/* SPR_15886_Fix: End */
	/* SPR 21367 Fix Start */
	U64                         ul_total_gbr_ue = RRM_ZERO;
	U64                         dl_total_gbr_ue = RRM_ZERO;
	/* SPR 21367 Fix End */
    #ifdef ENDC_ENABLED
    U8                          drb_list_count = RRM_ZERO;
    #endif

	RRM_UT_TRACE_ENTER();
	/*SPR 22754 Fix Start*/
	RRM_ASSERT(RRM_PNULL != p_g_rrm_ue_ctx);
	RRM_ASSERT(RRM_PNULL != p_g_rrm_ue_ctx->p_ue_context);
	/** Store the UE context local to the function */
	/*CID 81641 / CID 110728 */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	if (RRM_PNULL == p_ue_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"UE Context not found");
		ret_val = RRM_FAILURE; 
		return ret_val;
	}
	/*SPR 22754 Fix End*/
	/** Srore ERAB success list */
	p_rrm_ue_erab_success_list =
		(rrm_ue_erab_setup_item_list_t *)p_ue_context->current_procedure.
		p_erb_success_list;
	/*SPR 22754 Fix Start*/
	/*CID 81641*/
	if(p_ue_context->current_procedure.p_proc_data != RRM_PNULL)
	{
		p_rrm_proc_ho_cnf_data =
			(rrm_ue_proc_ho_adm_cnf_data_t *)p_ue_context->current_procedure.
			p_proc_data;
	}
	/*SPR 22754 Fix End*/

    /*SPR 22553 FIXED START */    
    if(p_ue_context->rrm_sub_profile_id_info.bitmask & RRM_UEM_CTX_TRANSE_PID_PRESENT)
    {    
        p_ue_context->rrm_sub_profile_id_info.sub_profile_id = p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id;
        p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = RRM_ZERO;
        p_ue_context->rrm_sub_profile_id_info.bitmask &= ~RRM_UEM_CTX_TRANSE_PID_PRESENT;   

    }
    /*SPR 22553 FIXED END */    
	/*SPR 15994 Fix start*/
	ue_index = p_ue_context->ue_index;
	/*SPR 15994 Fix stop*/
	/*SPR 18241 START*/
	p_ue_context->ue_state = RRM_UE_STATE_ACTIVE;
	/*SPR 18241 END*/

	/*Start:SPR 8696*/
	/** Change procedure state to RRM_UE_ERB_NULL */
	p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
	/*End:SPR 8696*/
	/* Start fix for SPR 14987 */
	rrm_cell_context_t *p_cell_context = RRM_NULL;
	/* End fix for SPR 14987 */

	/*SPR 22754 Fix Start*/
	/* CID 121562 */
	if(p_rrm_proc_ho_cnf_data != RRM_PNULL)
	{
		/*SPR 22754 Fix End*/
		if(p_rrm_proc_ho_cnf_data->response == RRM_FAILURE)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], Received \
					RRC_RRM_HO_ADMISSION_CNF response FAILURE",
					p_ue_context->ue_index);
			/** Delete UE Contex */
			/*SPR 22151 Fix Start*/
			if((p_ue_context != RRM_PNULL) &&(p_rrm_ue_erab_success_list != RRM_PNULL))
			{
				rrm_ue_clean_rab_resrc_at_ho_adm_cnf_complete_failure(p_ue_context,p_rrm_ue_erab_success_list);
			}
			/*SPR 22151 Fix End*/
			/* BUG_12217_CHANGES_START */
			ret_val = rrm_ue_delete_context(p_ue_context->cell_index,
					p_ue_context->ue_index);
			if(RRM_FAILURE == ret_val)
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
						"Failed to delete ue context");
			}
			else
			{
				/*SPR 15994 Fix start*/
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d] successfully \
						deleted ue context for the UE" ,ue_index);
				/*SPR 15994 Fix stop*/
			}
			/* BUG_12217_CHANGES_END */

			ret_val = RRM_FAILURE;
		}
		else
		{
			/* raise event for LOCAL_UE_HO_DETECTED */

			rrm_raise_event_ho_ue_detected();/*SPR 17777 +-*/

			/* raise event for LOCAL_UE_HO_DETECTED */

			for(cnf_index = RRM_NULL;
					cnf_index < p_rrm_proc_ho_cnf_data->erab_item_list.count;
					cnf_index++)
			{
				/* COVERITY : RESOURCE LEAK : CID : 55325 fix start */
				for(success_index = RRM_NULL;
						(( success_index < p_rrm_ue_erab_success_list->num_of_list) &&
						 ( success_index < RRM_MAX_NUM_DRB_PER_UE ));
						success_index++)
					/* COVERITY : RESOURCE LEAK : CID : 55325 fix end */        
				{
					/*Start: SPR 8892*/
					if(p_rrm_proc_ho_cnf_data->erab_item_list.erab_id[cnf_index]
							/*End: SPR 8892*/
							== p_rrm_ue_erab_success_list->erab_item[success_index].
							erab_id)
					{
						RRM_MEMCPY(&p_ue_context->drb_configured.
								erab_item[p_ue_context->drb_configured.num_of_list],
								&p_rrm_ue_erab_success_list->erab_item[success_index] ,
								sizeof(rrm_ue_erab_setup_item_t));
						p_ue_context->drb_configured.num_of_list++;
                        #ifdef ENDC_ENABLED
                        for( drb_list_count = 0 ; drb_list_count < p_ue_context->drb_configured.num_of_list ; drb_list_count++)
                        {
                            p_ue_context->drb_configured.erab_item[drb_list_count].new_lc_id =  0xFF;
                        }
                        #endif

						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Erab is \
								setup for erab id %d",p_ue_context->ue_index,
								p_rrm_ue_erab_success_list->erab_item[success_index].
								erab_id);
					}
				}
			}

			/* CA: SCell Selection start */
			if(RRM_ZERO == p_ue_context->scell_candidate_count)
			{
				if(RRM_SUCCESS != rrm_check_for_ca_need_thru_erab_setup_or_ho_cnf(p_ue_context))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"[HO_ADM_CNF block] indicates that OAM-configured threshold is not exceeded");

				}
			}
			/* CA: SCell Selection end */

			/* SPS related changes start */
			/* Reset the SPS ERAB info for UE and Decrement active SPS_count  */
			if(p_rrm_proc_ho_cnf_data->sps_error == RRM_TRUE)
			{
				for (fail_erab_index = RRM_NULL;
						fail_erab_index < p_rrm_proc_ho_cnf_data->erab_failed_item_list.count;
						fail_erab_index++)
				{
					if(p_rrm_proc_ho_cnf_data->erab_failed_item_list.erab_id[fail_erab_index] == 
							p_ue_context->ue_sps_data.sps_erab_id) 
					{
						if(p_ue_context->ue_sps_data.is_sps_erab_established == RRM_TRUE)
						{
							rrm_ue_reset_sps_info(p_ue_context);
							rrm_cellm_decrement_num_sps_active_ue(p_ue_context->cell_index,p_ue_context->ue_sps_data.pucch_an_list_resource_index);
						}
						fail_sps_erab_found= RRM_TRUE;
						break;
					}
				}
				if(fail_sps_erab_found == RRM_FALSE )
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
							"UE_INDEX[%d], ERAB_ID[%d]: Not found sps ERAB in fail list (HO_ADM_CNF)", 
							p_ue_context->ue_index,p_ue_context->ue_sps_data.sps_erab_id);
				}
			}
			/* SPS related changes end */
			/*SPR 18241 START*/
			/*code moved*/
			/*SPR 18241 END*/
			/*SPR 22151 Fix Start*/
			/*SPR 19819 START*/
			if((p_ue_context != RRM_PNULL) && (p_rrm_proc_ho_cnf_data != RRM_PNULL)&&(p_rrm_ue_erab_success_list != RRM_PNULL))
			{
				rrm_ue_clean_rab_resrc_at_ho_adm_cnf_failure(p_ue_context,p_rrm_proc_ho_cnf_data,p_rrm_ue_erab_success_list);
			}
			/*SPR 19819 END*/
			/*SPR 22151 Fix End*/



			p_ue_context->ue_start_time = rrm_get_system_time();
			/* HO Oscillation Start */

			/* SPR_15886_Fix: Start */
			/* As A1, A2 & A3 may be configured with the Erab Setup only so RRM shall mark the Meas nodes for A1, A2 & A3
			 * as success when Erab Setup Cnf received. */
			meas_id = RRM_ZERO;
			p_ue_context->meas_status = RRM_MEAS_CONFIG_RESP_SUCCESS;
			update_meas_config_status( p_ue_context,
					&is_ecid_meas_resp,
					&meas_id,
					&ecid_meas_resp_action);
			/* SPR_15886_Fix: End */

			/* Start fix for SPR 14987 */
			p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
			if(p_cell_context == RRM_PNULL)
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Cell Context is NULL,\
						cannot proceed for Periodic ANR procedure at UE attach ");
				ret_val = RRM_FAILURE;
			}
			else 
			{
				if ((RRM_TRUE == p_cell_context->apply_anr_on_ue_attach_in_all_cycles) ||
						(RRM_TRUE == p_cell_context->is_anr_first_cycle))
				{
					if ((p_cell_context->p_son_info != RRM_PNULL) && 
							(p_cell_context->p_son_info->p_anr_info != RRM_PNULL) &&
							(p_cell_context->num_anr_strong_cell_req_sent < p_cell_context->ue_meas_cnt))
					{
						if ( (RRM_TRUE == rrm_is_ue_supporting_autonomous_gap(p_ue_context)) ||
								(RRM_TRUE == is_ue_supported_fgi_for_cdrx(p_ue_context)) )
						{
							rrm_send_meas_config_request_for_anr(p_cell_context, p_ue_context);
						}
						else
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"CDRX/Autonomous gaps not supported by UE rquired for ANR");
						}
					}
					else
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], ANR is disabled" 
								" or MAX UE limit reached for ANR configuration %d",p_ue_context->ue_index,
								p_cell_context->num_anr_strong_cell_req_sent);
					}
				}
			}
			/* End fix for SPR 14987 */
			/* SPR 21367 Fix Start */
			rrm_ue_calculate_total_bit_rate(p_ue_context,&ul_total_gbr_ue,
					&dl_total_gbr_ue);
			if (RRM_PNULL != p_cell_context)
			{
				(p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate)+= ul_total_gbr_ue;
				(p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate)+= dl_total_gbr_ue;

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,"Total admitted bitrate UL[%lu] DL[%lu] after this RAB procedure", 
						p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate, p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate);
			}
			/* SPR 21367 Fix End */

			rrm_detect_ho_oscillation(p_ue_context);
			/* HO Oscillation End */
			/* BUG_12217_CHANGES_START */
			/*Coverity 86998 Changes Start*/
			/*RRM_MEM_FREE(p_rrm_proc_ho_cnf_data);*/
			/*Coverity 86998 Changes End*/
			/* BUG_12217_CHANGES_END */

			/*spr 17437 fix start*/
			if(RRM_PNULL != p_ue_context->current_procedure.p_erb_success_list)
			{
				RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_success_list);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING," erb_success_list is empty ");
			}

			if(RRM_PNULL != p_ue_context->current_procedure.p_erb_failed_list)
			{
				RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_failed_list);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"erb_failed_list is empty");
			}
			/*spr 17437 fix stop*/

			/*SPR_18491_START*/
			if ( (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL) && (rrm_get_queue_count(&p_ue_context->procedure_queue)))
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"UE_INDEX[%d], dequeue queued message",
						p_ue_context->ue_index);
				/** Dequeue the events from event queue and call message handler */
				/* SPR 15849 Start */
				p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
				/* SPR 15849 End */
				if(RRM_PNULL != p_rrm_ue_procedure_record)
				{   
					/* CSR00069389 Start */
					rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
					/* CSR00069389 End */
				}
				else
				{

					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
							"UE_INDEX[%d], p_rrm_ue_procedure_record is NULL, queue count = %u",
							p_ue_context->ue_index,rrm_get_queue_count(&p_ue_context->procedure_queue));

				}    
			}
			/*SPR_18491_END*/
		}
		/*SPR 22754 Fix Start*/
	}
	/*SPR 22754 Fix End*/
	/* BUG_12217_CHANGES_START */
	/* Code Deleted */
	/* BUG_12217_CHANGES_END */
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* HO Oscillation Start */
/****************************************************************************
 * Function Name  : rrm_detect_ho_oscillation
 * Inputs         : p_ue_context
 * Outputs        : NONE
 * Returns        : VOID
 * Description    : Detects HO Oscillation
 ****************************************************************************/
	rrm_void_t rrm_detect_ho_oscillation
(
 rrm_ue_context_t                 *p_ue_context
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t  *p_cell_context             = RRM_PNULL;
	U8                  max_cells_to_be_searched    = RRM_ZERO;
	U8                  time_stay_threshold         = RRM_ZERO;
	U8                  index                       = RRM_ZERO;
	last_visited_cell_list_t *p_last_visited_cell_list = RRM_PNULL;
	cell_global_id_eutra_t *p_global_cell_id    = RRM_PNULL;
	U8                  osc_loop_count              = RRM_ZERO;
	U8                  min_osc_loop                = RRM_ZERO;

	p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	p_last_visited_cell_list = &p_ue_context->ue_history.last_visited_cell_list;
	/*CID 65786 :start*/
	if (RRM_PNULL != p_cell_context)
	{
		max_cells_to_be_searched = p_cell_context->operator_info.ho_oscillation_cfg.max_last_visited_cells_searched;
		time_stay_threshold = p_cell_context->operator_info.ho_oscillation_cfg.time_of_stay_threshold;
		min_osc_loop = p_cell_context->operator_info.ho_oscillation_cfg.min_num_of_oscillation_loop;

		max_cells_to_be_searched = (max_cells_to_be_searched < p_last_visited_cell_list->count)?\
					   max_cells_to_be_searched:p_last_visited_cell_list->count;

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"ue_history_cell_list_count = %d, cfg_max_cells_to_be_searched = %d,\
				time_of_stay_threshold = %d, min_num_of_oscillation_loop = %d",
				p_last_visited_cell_list->count, max_cells_to_be_searched, 
				time_stay_threshold, min_osc_loop);

		while( index < max_cells_to_be_searched )
		{
			if( p_last_visited_cell_list->last_visited_cell_info[index].bitmask & LAST_VISITED_CELL_INFO_E_UTRAN_CELL_INFORMATION_PRESENT )
			{
				p_global_cell_id = &p_last_visited_cell_list->last_visited_cell_info[index].
					last_visited_e_utran_cell_information.global_cell_id;
				if( p_last_visited_cell_list->last_visited_cell_info[index].last_visited_e_utran_cell_information.time_ue_stayed_in_cell > time_stay_threshold )
				{
					break;
				}
			}
			else if( p_last_visited_cell_list->last_visited_cell_info[index].bitmask & LAST_VISITED_CELL_INFO_UTRAN_CELL_INFORMATION_PRESENT )
			{
				p_global_cell_id = (cell_global_id_eutra_t *)&p_last_visited_cell_list->last_visited_cell_info[index].
					last_visited_utran_cell_information.utran_cell_id;
				if( p_last_visited_cell_list->last_visited_cell_info[index].last_visited_utran_cell_information.time_ue_stayed_in_cell > time_stay_threshold )
				{
					break;
				}
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"Neither EUTRAN nor UTRAN cell present in ue_history");
				break;
			}
			if(RRM_SUCCESS == rrm_compare_global_cell_id(p_global_cell_id,&p_cell_context->global_cell_id))
			{
				osc_loop_count++;
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"HO OScillation Loop Detected %d times",osc_loop_count);
			}
			if(osc_loop_count == min_osc_loop)
			{
				p_ue_context->ho_params.osc_loop_detected = RRM_TRUE;
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
						"HO OScillation Loop detected min_osc_loop times, Oscillation prevention required");
				p_ue_context->ho_params.osc_loop_count = index + RRM_ONE;
				break;
			}
			index++;
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
	}

	/*CID 65786 :end*/
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 ** Function Name  : rrm_compare_global_cell_id
 ** Inputs         :
 **                : cell_global_id_eutra_t *p_global_cell_id 
 **                : rrm_cell_context_t  *p_rrm_global_cell_id
 ** Outputs        :
 ** Returns        : SUCCESS/FAILURE
 ** Description    : This function compares the global cell id of RRM and RRC
 **                  
 *****************************************************************************/
rrm_return_et rrm_compare_global_cell_id(
		cell_global_id_eutra_t *p_global_cell_id,
		rrm_global_cell_id_t *p_rrm_global_cell_id)	
{
	rrm_return_et ret_val = RRM_SUCCESS;
	U8 index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	RRM_ASSERT(RRM_PNULL != p_global_cell_id);
	RRM_ASSERT(RRM_PNULL != p_rrm_global_cell_id);

	/* Comparing MCC Id */
	for (index = RRM_ZERO; index< MAX_MCC_DIGITS; index++)
	{
		if (p_global_cell_id->plmn_identity.mcc[index] !=
				p_rrm_global_cell_id->primary_plmn_id.mcc[index])
		{
			RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRC MCC[%d]  RRM MCC[%d] "
					"at INDEX[%d]",
					p_global_cell_id->plmn_identity.mcc[index],
					p_rrm_global_cell_id->primary_plmn_id.mcc[index],
					index);
			ret_val = RRM_FAILURE;
			break;
		}
	}

	if (ret_val != RRM_FAILURE)
	{
		/**Comparing MNC Id **/
		if (p_global_cell_id->plmn_identity.mnc.count ==
				p_rrm_global_cell_id->primary_plmn_id.num_mnc_digit)
		{
			RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "No of MNC matches");
			for (index=RRM_ZERO; index< p_global_cell_id->plmn_identity.mnc.count ; index++)
			{
				if (p_global_cell_id->plmn_identity.mnc.mnc[index] !=
						p_rrm_global_cell_id->primary_plmn_id.mnc[index])
				{
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRC MNC[%d] "
							"RRM MNC[%d]  at INDEX [%d]",
							p_global_cell_id->plmn_identity.mnc.mnc[index],
							p_rrm_global_cell_id->primary_plmn_id.mnc[index], index);
					ret_val = RRM_FAILURE;
					break;
				}
			}/*for loop ends*/
		}
		else
		{
			RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRC num_mnc_digit[%d] "
					"RRM num_mnc_digit[%d]",
					p_global_cell_id->plmn_identity.mnc.count,
					p_rrm_global_cell_id->primary_plmn_id.num_mnc_digit);
			ret_val = RRM_FAILURE;
		}
	}


	if (ret_val != RRM_FAILURE)
	{
		/* Comparing Cell Identity */
		RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Comparing Cell Ident");
		for (index= RRM_ZERO; index < MAX_CELL_IDENTITY_OCTETS; index++)
		{
			if (p_global_cell_id->cell_identity[index] != p_rrm_global_cell_id->cell_identity[index])
			{
				RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRC CELL_ID[%d] "
						"RRM CELL_ID[%d] at INDEX[%d]",
						p_global_cell_id->cell_identity[index],
						p_rrm_global_cell_id->cell_identity[index], index);
				ret_val = RRM_FAILURE;
				break;
			}
		}/*for loop ends*/
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* HO Oscillation End */

/*MC, MR & HO  START */
/****************************************************************************
 * Function Name  : rrm_ue_is_erabs_admitted_by_tgt_enb
 * Inputs         : p_ho_cmd_req
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS if erabs admitted by target eNB otherwise RRM_FAILURE
 * Description    : Verifies whether the erabs are admitted by target eNB or not
 ****************************************************************************/
rrm_return_et
	rrm_ue_is_erabs_admitted_by_tgt_enb 
(
 rrm_ue_context_t                 *p_ue_context,
 rrm_ue_proc_ho_command_request_t* p_ho_cmd_req
 )
{
	rrm_return_et ret_val = RRM_SUCCESS;
	U8  count = RRM_ZERO;
	U8  count1 = RRM_ZERO;
	if (p_ho_cmd_req->bitmask & 
			RRC_RRM_UE_HO_CMD_REQ_ERAB_TO_RELEASE_LIST_PRESENT)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
				"Receive HO CMD REQ with ERAB RELEASE LIST for the UE_INDEX[%d]",\
				p_ho_cmd_req->ue_index);
		for(count =RRM_ZERO;count < p_ho_cmd_req->erab_sub_to_fwd_list.erab_count;count++)
		{
			for(count1 = RRM_ZERO;count1< p_ue_context->drb_configured.num_of_list;count1++)
			{
				if(p_ho_cmd_req->erab_sub_to_fwd_list.drb_sub_to_fwd[count].erab_id == \
						p_ue_context->drb_configured.erab_item[count1].erab_id)
				{
					if(p_ue_context->drb_configured.erab_item[count1].erab_level_qos_params.qci > RRM_GBR_QCI_4)
					{
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
								"Received HO CMD REQ with non GBR bearer created at \
								tgt enb for the UE_INDEX[%d]",\
								p_ho_cmd_req->ue_index);
						ret_val = RRM_PARTIAL_SUCCESS;
					}
					else
					{
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
								"Received HO CMD REQ without non GBR bearer created at \
								tgt enb for the UE_INDEX[%d]",\
								p_ho_cmd_req->ue_index);
						ret_val = RRM_FAILURE;
					}
				}
			}
		}   
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
				"Received HO CMD REQ with non GBR bearer created at \
				tgt enb and not having any release bearer list for the UE_INDEX[%d]",\
				p_ho_cmd_req->ue_index);
		ret_val = RRM_SUCCESS;
	}
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_ho_cmd_req 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_ho_cmd_req message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_ho_cmd_req (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{

	rrm_return_et ret_val = RRM_SUCCESS;
	/* LTE_RRM_MALL, CID 11230 */
	rrm_response_t                     rrm_response = {RRM_ZERO};    
	rrm_ue_context_t                  *p_ue_context = RRM_PNULL;
	rrm_ue_proc_ho_command_request_t  *p_rrm_proc_ho_cmd_req = RRM_NULL;
	/* SPR 15674 Start */
	/* SPR 16406 8SEP start */
	/* SPR 16406 18sep Start  */
	phy_cell_id_info_t  phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
	/* SPR 16406 18sep End */
	/* SPR 16406 8SEP end */
	/* SPR 15674 End */
	U8                                 transaction_id = p_g_rrm_ue_ctx->trans_id;

	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	/* BLR Team HO status report to SON Changes Start */


	p_rrm_proc_ho_cmd_req =
		(rrm_ue_proc_ho_command_request_t *)p_ue_context->current_procedure.
		p_proc_data;
	rrm_response.response  = ret_val;

	/*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_INFO-START
	  When an outgoing handover request is to be sent*/
	rrm_raise_event_ho_out_prep_info(p_ue_context,
			p_rrm_proc_ho_cmd_req);
	/*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_INFO-END*/

	ret_val = rrm_build_and_send_ho_cmd_resp (rrm_response,
			p_rrm_proc_ho_cmd_req,transaction_id,p_ue_context); 

	/* MRO HO attempt to SON Changes Start */
	/* SPR 15674 Start */
	phy_cell_id_info.phy_cell_id = p_ue_context->ho_params.target_phys_cell_id;
	phy_cell_id_info.carr_earfcn = p_ue_context->ho_params.target_earfcn;
	/* MRO HO attempt to SON Changes Start */
	/* Start :SPR 9309 */
	if ((p_ue_context->ho_type == HANDOVER_TYPE_INTRA_LTE_X2) ||
			((p_ue_context->target_cell_type == EUTRA_CELL) &&
			 ((RRM_SUCCESS == is_x2_link_up_for_phy_cell(phy_cell_id_info, p_ue_context->cell_index)) ||
			  (is_x2_link_exist(phy_cell_id_info)))))
		/* SPR 15674 End */
	{
		rrm_ue_ho_attempt_ind(p_ue_context);
	}
	/* End :SPR 9309 */
	/* MRO HO attempt to SON Changes end */

	/* Freq-priority changes start */
	/* Stop the blind timer if it is still running */
	if(p_ue_context->ho_params.blind_timer)
	{
      /* SPR-17852 START */
            /* CSR-58333-fix start*/
            rrm_ue_stop_timer(p_ue_context->ho_params.blind_timer);
            /* CSR-58333-fix end*/
            p_ue_context->ho_params.blind_timer = RRM_PNULL;
        /* SPR-17852 END */
	}

	/* Freq-priority changes end */
	/*SPR-539 Fix Starts*/
	//rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
	/*SPR-539 Fix Ends*/

	/* Force Lock / Grace lock changes Start*/
	p_ue_context->ue_ho_current_state =  RRM_HO_STATE_WAIT_FOR_REL;
	/* CSR 00058108 : code changes start */
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
			"Changed the UE HO state to RRM_HO_STATE_WAIT_FOR_REL\n");
	/* CSR 00058108 : code changes end */
	/* Force Lock / Grace lock changes End*/

	return ret_val;
}

/* SPR-12923-fix start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_ho_attempt_ind_for_rlf
 *
 *   DESCRIPTION:
 *       Send the HO attempt msg to MIF msg handler in the case of TOO_LATE.
 *
 *   RETURNS:
 *       RRM_SUCCESS if attempt ind sent to MIF successfully 
 *       RRM_FAILURE otherwise
 ******************************************************************************/
	rrm_return_et
rrm_ue_ho_attempt_ind_for_rlf(
		rrm_ue_context_t       *p_ue_context,
		rrm_global_cell_id_t   *p_trgt_cgi)
{
	rrmuem_rmif_ho_attempt_ind_t    rrmuem_rmif_ho_attempt_ind;
	rrm_return_et                   ret_val = RRM_SUCCESS;
	rrm_cell_context_t             *p_cell_context = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	RRM_MEMSET(&rrmuem_rmif_ho_attempt_ind, RRM_ZERO, sizeof(rrmuem_rmif_ho_attempt_ind_t));


	/*CID 66691:start*/
	if((RRM_PNULL != p_ue_context) && (RRM_PNULL != p_trgt_cgi))
	{
		p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
		if (RRM_PNULL != p_cell_context)
		{
			p_ue_context->is_ho_failed = RRM_FALSE;

			if ((RRM_TRUE == rrm_cellm_get_ho_attemt_ind_attr_status(p_ue_context->cell_index)))
			{   

				RRM_MEMCPY(&(rrmuem_rmif_ho_attempt_ind.src_cgi),
						&(p_cell_context->global_cell_id),
						sizeof(rrm_oam_eutran_global_cell_id_t));

				RRM_MEMCPY(&(rrmuem_rmif_ho_attempt_ind.trgt_cgi),
						p_trgt_cgi,
						sizeof(rrm_global_cell_id_t));

				rrmuem_rmif_ho_attempt_ind.attempt_count = RRM_ONE;
				/* SPR 22184/SES-478 Fix Start */
				/* Code Removed */
				/* SPR 22184/SES-478 Fix End */

				if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
							RRMUEM_RMIF_HO_ATTEMPT_IND, sizeof(rrmuem_rmif_ho_attempt_ind_t),
							(void *)(&rrmuem_rmif_ho_attempt_ind)))
				{

					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"rrm_ue_ho_attempt_ind_for_rlf(): Sent Handover attempt indication for UE_INDEX[%d]",
							p_ue_context->ue_index);
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"rrm_ue_ho_attempt_ind_for_rlf(): Failed to send Handover attempt indication for UE_INDEX[%d]",
							p_ue_context->ue_index);
					ret_val= RRM_FAILURE;
				}
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "p_cell_context is null");
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		/*CID 66691:end*/
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"rrm_ue_ho_attempt_ind_for_rlf(): p_ue_context is NULL or target CGI is null");
		ret_val= RRM_FAILURE;
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* SPR-12923-fix end */

/*  MRO code changes start */
/****************************************************************************
 * Function Name  : rrm_ue_handle_rlf_ind 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the RLF_IND received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_rlf_ind (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et				ret_val = RRM_SUCCESS;
	rrm_ue_context_t    *p_ue_context = RRM_PNULL;
	rrm_ue_proc_rlf_ind_t  *p_rrm_ue_rlf_data = RRM_PNULL;
	rrm_global_cell_id_t    rlf_re_est_cell_ecgi;
	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	p_rrm_ue_rlf_data = (rrm_ue_proc_rlf_ind_t *)p_ue_context->current_procedure.p_proc_data;

	/*Raising Event RRM_PE_EVENT_X2_RLF_INDICATION -START*/
	rrm_raise_event_x2_rlf_indication();
	/*Raising Event RRM_PE_EVENT_X2_RLF_INDICATION -END*/


	if(RRM_SUCCESS != rrm_x2ap_ecgi_to_eutran_global_cell_id(
				p_rrm_ue_rlf_data->re_est_cell_ecgi,&rlf_re_est_cell_ecgi))
	{
		RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name,
				RRM_WARNING, "rrm_ue_handle_rlf_ind Global cell id is not correct");
		return RRM_FAILURE; 
	}

	/* BLR Team HO status report to SON Changes Start */
	if( RRM_FALSE == p_ue_context->ho_params.ho_ue_attempt_ind_sent )
	{
		/*Raising event RRM_PE_EVENT_TOO_LATE_HO -START*/
		rrm_raise_event_too_late_ho(p_ue_context);
		/*Raising event RRM_PE_EVENT_TOO_LATE_HO -END*/

		/* SPR-12923-fix start */
		rrm_ue_ho_attempt_ind_for_rlf (p_ue_context,&rlf_re_est_cell_ecgi);

		rrm_ue_ho_failure_report(p_ue_context, RRMUEM_RMIF_HO_TOO_LATE,p_rrm_ue_rlf_data); 

		/* Code Deleted */
		/* SPR-12923-fix end */

	}
	/* CSR-82583[SPR-12644]-fix start */
	/* SPR-13375-fix start */
        /* SPR 21496 Fix Start */ 
	else if (RRM_SUCCESS  == compare_global_cell_id((rrm_oam_eutran_global_cell_id_t *)&(p_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id),
				(rrm_oam_eutran_global_cell_id_t *)&(rlf_re_est_cell_ecgi)))
		/* SPR-13375-fix end */
		/* CSR-82583[SPR-12644]-fix end */
          /* SPR 21496 Fix End */ 
	{
		/* too late for HO */

		/*Raising event RRM_PE_EVENT_TOO_LATE_HO -START*/
		rrm_raise_event_too_late_ho(p_ue_context);
		/*Raising event RRM_PE_EVENT_TOO_LATE_HO -END*/

		rrm_ue_ho_failure_report(p_ue_context, RRMUEM_RMIF_HO_TOO_LATE,p_rrm_ue_rlf_data); 
	}
	else
	{
		/*Raising event RRM_PE_EVENT_HO_WRONG_CELL -START*/
		rrm_raise_event_ho_wrong_cell(p_ue_context);
		/*Raising event RRM_PE_EVENT_HO_WRONG_CELL -END*/

		/*Raising event RRM_PE_EVENT_HO_WRONG_CELL_REEST -START*/
		rrm_raise_event_ho_wrong_cell_reest(p_ue_context);
		/*Raising event RRM_PE_EVENT_HO_WRONG_CELL_REEST -END*/

		rrm_ue_ho_failure_report(p_ue_context, RRMUEM_RMIF_HO_TO_WRONG_CELL,p_rrm_ue_rlf_data);

	}

	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*  MRO code changes end */
/*SPR-604 Fix Starts*/


/*INTRA_CELL_HO changes start*/
/****************************************************************************
 * Function Name  : rrm_ue_intra_enb_ho_ind_event
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_results_ind message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_intra_enb_ho_ind_event (rrm_ue_global_context_t *p_g_rrm_ue_ctx)
{
	rrm_return_et              ret_val = RRM_SUCCESS;
	rrm_ue_context_t          *p_ue_ctxt = RRM_PNULL;
	rrm_cell_context_t        *p_cell_context = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_ue_ctxt = p_g_rrm_ue_ctx->p_ue_context;

	p_cell_context = rrm_cellm_get_cell_context(p_ue_ctxt->cell_index);
	if (RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Cell Context not found");
		return RRM_FAILURE;
	}
 /*SPR 18241 START*/
    if(p_ue_ctxt->current_procedure.state != RRM_UE_ERB_NULL) 
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "UE_INDEX[%d] has already ongoing procedure [%d], enqueue message",
                p_ue_ctxt->ue_index, p_ue_ctxt->current_procedure.state);
        rrm_ue_procedure_queue_t    proc_queue;
        proc_queue.api_id = p_g_rrm_ue_ctx->api_id;
        proc_queue.p_proc_data =  p_g_rrm_ue_ctx->p_ue_context->current_procedure.p_proc_data;
        proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;

        rrm_ue_mgr_enqueue_req(&proc_queue, p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
        /* SPR 15797 Start */
        RRM_UT_TRACE_EXIT();
        return ret_val;
        /* SPR 15797 End */
    }
    /*SPR 18241 END*/

	if (RRM_UE_STATE_ACTIVE == p_ue_ctxt->ue_state)
	{
		if (RRM_SUCCESS == (ret_val = rrm_build_and_send_intra_cell_ho_required(
						p_ue_ctxt,
						p_g_rrm_ue_ctx->trans_id)))
		{
			p_ue_ctxt->ho_params.target_phys_cell_id = p_cell_context->ran_info.\
								   rf_params.rf_configurations.phy_cell_id;
			/* SPR 15674 Start */
			p_ue_ctxt->ho_params.target_earfcn = p_cell_context->ran_info.\
							     rf_params.rf_configurations.dl_earfcn;
			/* SPR 15674 End */
			p_ue_ctxt->ue_ho_current_state = RRM_HO_STATE_HO_TRIGGERED;
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
					"UE_INDEX[%d],HO required sent successfully for intra-cell HO",
					p_ue_ctxt->ue_index);
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
					"UE_INDEX[%d],Failed to send HO required for intra-cell HO",
					p_ue_ctxt->ue_index);
			ret_val = RRM_FAILURE;
		}
        /*SPR 18241 START*/
        /*code deleted*/    
        /*SPR 18241 END*/
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*SPR-604 Fix Ends*/

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_ho_failue 
 _params
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_ho_failure message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_ho_failure (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et	ret_val = RRM_SUCCESS;
	rrm_ue_context_t    *p_ue_context = RRM_PNULL;
	rrm_bool_et          ho_report_to_son_status = RRM_FALSE;
    /*SPR 18241 START*/
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
    /*SPR 18241 END*/
    
	/*coverity 24987: init with INVALID_PHYSICAL_CELL_ID: , rel 1.3*/
	/* SPR 15674 Start */
	/* SPR 16406 8SEP start */
	/* SPR 16406 18sep Start  */
	phy_cell_id_info_t  phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
	/* SPR 16406 18sep End */
	/* SPR 16406 8SEP end */
	/* SPR 15674 End */
	U16              transaction_id = rrm_generate_txn_id();
	U8               ho_retry_count = RRM_NULL;
	rrm_ho_config_params_t  *p_ho_config_params = RRM_PNULL;

	/* SPR 12705 start */
	rrm_cell_context_t *p_cell_ctxt = RRM_PNULL;
	/* SPR 12705 end */
	/* SPR 15986 Fix Start */
	rrm_ue_proc_ho_failure_t  *p_rrm_ue_proc_ho_failure = RRM_PNULL;
	/* SPR 15986 Fix End */
	/* SPR:15970 Fix Start - 6/4/15 */
	U8              is_ho_trigger_for_daho = RRM_FALSE;
	/* SPR:15970 Fix End - 6/4/15 */
	/* SPR 16406 24Sep Start */
	/* Code removed */
	/* SPR 16406 24Sep End */
	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	/* Review_comment_for_SPR_7996_nd_8345_start */
	rrm_decrement_num_of_enb_init_ho_csg_and_non_csg_usr(p_ue_context);
	/* Review_comment_for_SPR_7996_nd_8345_end */
	/* SPR 12705 start */
	p_cell_ctxt = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	if (RRM_PNULL != p_cell_ctxt)
	{
		rrm_update_kpi_ho_fail_stats(p_ue_context,p_cell_ctxt);
	}
	/* SPR 12705 end */

	/* BLR Team HO status report to SON Changes Start */
	/* MLB Changes start */
	ho_report_to_son_status = rrm_cellm_get_ho_report_status(p_ue_context->cell_index);
	/* Accessing horetry count from cellM */
	p_ho_config_params =(rrm_ho_config_params_t *)rrm_cellm_get_ho_config_params(p_ue_context->cell_index);
	ho_retry_count = p_ho_config_params->ho_retry_params.ho_retry_count;
	/* SPR 15232 start */
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Configured ho_retry_count [%d], Retry done [%d]",ho_retry_count,
			p_ue_context->ho_params.ho_retry_count);
	/* SPR 15232 end */
	/*SPR 17327 START */
	p_rrm_ue_proc_ho_failure = (rrm_ue_proc_ho_failure_t *)
		(p_ue_context->current_procedure.p_proc_data);

	if((RRM_PNULL != p_rrm_ue_proc_ho_failure) &&
			(RADIO_NETWORK_LAYER_TYPE == p_rrm_ue_proc_ho_failure->rrm_cause.type) &&
			(INTERACTION_WITH_OTHER_PROCEDURE == p_rrm_ue_proc_ho_failure->rrm_cause.value))
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				"HO_Failure Received with Cause as INTERACTION_WITH_OTHER_PROCEDURE and "
				"type as RADIO_NETWORK_LAYER_TYPE .No need to determine/send HO-REPORT to SON.");
	}
	else if (ho_report_to_son_status == RRM_TRUE) 
		/*SPR 17327 END */

		/* SPR-12570-fix start */
	{
		p_ue_context->ue_handover_report.result = RRM_FAILURE;
		p_ue_context->ue_handover_report.rrm_dst_son_mod_ho_rep = RRM_ZERO;
		p_ue_context->ue_handover_report.rrm_dst_son_mod_ho_rep |= RRMUEM_RMIF_DST_SON_MOD_ANR_HOR;
		if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
					RRMUEM_RMIF_HO_REPORT, sizeof(rrmuem_rmif_ho_report_t),
					(void *)(&p_ue_context->ue_handover_report)))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"HO_Failure Sent Handover report for UE_INDEX[%d]",
					p_ue_context->ue_index);
			/* SPR 22184/SES-478 Fix Start */
			/* Code Removed */
			/* SPR 22184/SES-478 Fix End */

		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"HO_Failure Failed to send Handover Report for UE_INDEX[%d]",
					p_ue_context->ue_index);
		}
	}
	else
	{
		p_ue_context->handover_on_daho_cell_skip_ho_status_report = RRM_FALSE;
	}
	/* SPR-12570-fix end */
	/* MLB Changes end */

	/* BLR Team HO status report to SON Changes End */

	if( p_ue_context->ue_ho_current_state == RRM_HO_STATE_HO_TRIGGERED)
	{     
		/*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_FAILED-START
		  When the outgoing handover preparation fails*/
		rrm_raise_event_ho_out_prep_failed(p_ue_context);
		/*Raising event RRM_EVENT_LOCAL_HO_OUT_PREP_FAILED-END*/
	}
    /*SPR 18241 START*/
    /*code deleted*/
    /*SPR 18241 END*/

	/*SPR 16581 START*/
	/* SPR 16406 8SEP start */
	/*SPR_17893_START*/
	p_ue_context->ue_ho_current_state =  RRM_HO_STATE_NULL;
	p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

	/*If the Utran Capability was asked from UE and failure was received then,
	 *release this UE.*/
	if((RRM_TRUE == rrm_check_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_TRUE)) &&
			(RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT !=  
			 (p_ue_context->ue_capability_params.bitmask & RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT)))
	{
		rrm_set_utran_capability_enq_info(p_ue_context,RRM_FALSE,RRM_FALSE);		
		rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
        p_ue_context->is_ho_reqd_on_recv_utan_cap = RRM_FALSE;
        

		if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
					p_ue_context->ue_index,
					RADIO_NETWORK_LAYER_TYPE,
					FAILURE_IN_THE_RADIO_INTERFACE_PROCEDURE,
					p_g_rrm_ue_ctx->trans_id,
					p_ue_context,
					p_ue_context->cell_index))
		{
			ret_val = RRM_SUCCESS;
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"UE Connection release ind sent for UE index:%d",p_ue_context->ue_index);

			if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
			{
				ret_val = RRM_FAILURE;
				RRM_TRACE(g_uem_log_on_off,
						p_rrm_uem_facility_name,
						RRM_ERROR,
						"UE Connection release_ind sent, \
						Failed to clean up ue resources");
			}
		}
		else
		{
			ret_val = RRM_FAILURE;
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"Failed to send release connection ind for UE index:%d",
					p_ue_context->ue_index);
		}
	}
	else
	{
   /*SPR_17893_END*/
   /*SPR_17893_START*/
    /*If UE is being asked for utran capability*/
    if(RRM_TRUE == rrm_check_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_FALSE))
    {
        rrm_ue_set_state(p_ue_context,RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES);
    }
    else
    {
        /*SPR_17893_END*/
	rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
    /*SPR_17893_START*/
    }
    /*SPR_17893_END*/
	/* Force Lock / Grace lock changes Start*/
    /*SPR_17893_START*/
    /*Code Deleted*/
    /*SPR_17893_END*/
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Changed the UE HO state to RRM_HO_STATE_NULL as"
			" HO_FAILURE received and trying to find the next best suitable PCI\n");
	/* SPR 16406 8SEP end */
	/*SPR 16581 END*/
    
/*SPR 17327 START */
    if ( (PNULL != p_rrm_ue_proc_ho_failure) &&
            (RADIO_NETWORK_LAYER_TYPE == p_rrm_ue_proc_ho_failure->rrm_cause.type))
   
     {
      if(INTERACTION_WITH_OTHER_PROCEDURE == p_rrm_ue_proc_ho_failure->rrm_cause.value)
      {
	      rrm_search_and_remove_phy(p_ue_context,
			      p_ue_context->ho_params.target_phys_cell_id,
			      p_ue_context->ho_params.target_earfcn);
              /*SPR 17527 START*/
              if(RRM_TRUE != rrm_ue_is_cgi_report_pending(p_ue_context))
	      {
                  if (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status)
                  {
		      rrm_remove_previous_pending_measurement(p_ue_context);
	      }
	      else
	      {
		      rrm_uem_send_cdrx_removal(p_ue_context);
	      }
              }
              /*SPR 17527 END*/
	      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
			      "UE HO state changed to RRM_HO_STATE_NULL as HO_FAILURE received due to Interaction with other proc\n");

	      RRM_UT_TRACE_EXIT();
	      return RRM_SUCCESS;

      }
      else if((RADIO_CONNECTION_WITH_UE_LOST == p_rrm_ue_proc_ho_failure->rrm_cause.value) &&
              (!( (p_ue_context->ho_type == HANDOVER_TYPE_INTRA_LTE_X2) ||
                  (p_ue_context->ho_type == HANDOVER_TYPE_INTRA_CELL)   ||
                  (p_ue_context->ho_type == HANDOVER_TYPE_INTER_CELL)
                ))
	    )
    /*SPR 17327 END */
        /*SPR 16581 END*/
       {
        /* SPR 16406 Start */
        /* SPR 16406 8SEP start */
        p_ue_context->ho_params.geran_known_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.geran_confused_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.geran_unknown_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.utra_known_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.utra_unknown_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.utra_confused_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.eutra_known_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.eutra_unknown_cell_selection_list.count = RRM_ZERO;
        p_ue_context->ho_params.eutra_confused_cell_selection_list.count = RRM_ZERO;
        /* SPR 16406 8SEP end */
        /* SPR 16406 End */
        /* SPR 16406 18sep Start */
        rrm_reset_cell_selection_and_cgi_pending_list(p_ue_context);
        /* SPR 16406 18sep End */

        /* SPR 16406 8SEP start */
        /* Code removed */
        /* SPR 16406 8SEP end */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "HO_FAILURE received due to re-establishment\n");
        /* Force Lock / Grace lock changes End*/
        RRM_UT_TRACE_EXIT();
        return RRM_SUCCESS;
       }
    /*SPR 17327 START */
    }
    /*SPR 17327 END */


	if((p_ue_context->cdma2000_capabilities.is_cdma2000_present) && ((RRM_TRUE == 
					p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.ho_required_sent_status) ||
				(RRM_TRUE == p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_required_sent_status)))
	{
		if((RRM_TRUE == p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
					ho_required_sent_status) && (RRM_TRUE == p_ue_context->
						cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_required_sent_status))
		{
			if((RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == p_ue_context->cdma2000_ho_cmd_resp.
						cdma2000_1xrtt_params.ho_req_identifier) && (RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == 
							p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_req_identifier))
			{
				rrm_ue_stop_ho_timers(p_ue_context);

				/* Trigger HO to 1XRTT DAHO */
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"UE_INDEX[%d] Sending HO REQUIRED to HRPD & 1XRTT DAHO Cell" ,
						p_ue_context->ue_index);
				/* CSR 55938: code changes start */
				/* CSR 55938: code changes end */

				ret_val = rrm_build_and_send_daho_cdma2000_ho_required (
						p_ue_context,
						transaction_id);
				if (RRM_SUCCESS == ret_val) 
				{
					p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
						ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL;
					p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.
						ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL;
					RRM_TRACE(g_cellm_log_on_off,
							p_rrm_cellm_facility_name,
							RRM_DETAILED,
							"HO triggered for UE: [%d]",
							p_ue_context->ue_index);
				}
			}
			else if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
			{
				/* Bug 16121 Fix Start */
				if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
							p_ue_context->ue_index,
							RADIO_NETWORK_LAYER_TYPE,
							INTER_RAT_REDIRECTION,
							p_g_rrm_ue_ctx->trans_id,
							p_ue_context,
							/* SPR_10729_fix */ 
							p_ue_context->cell_index))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
					if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_rrm_uem_facility_name,
								RRM_DETAILED,
								"ue_connection_release_ind sent, \
								Failed to clean up ue resources");
						ret_val = RRM_FAILURE;
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							"Failed to send release connection ind for UE index:%d",
							p_ue_context->ue_index);
					ret_val = RRM_FAILURE;
				}
				/* Bug 16121 Fix End */

			}
		}
		else if((RRM_TRUE == p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
					ho_required_sent_status) && (RRM_FALSE == p_ue_context->
						cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_required_sent_status))
		{
			/* RWR */
			rrm_ue_stop_ho_timers(p_ue_context);

			/* Check if it was previously from DAHO/MAHO */
			if(RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == p_ue_context->cdma2000_ho_cmd_resp.
					cdma2000_1xrtt_params.ho_req_identifier)
			{
				/* Trigger HO to 1XRTT DAHO */
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"UE_INDEX[%d] Sending HO REQUIRED to 1XRTT DAHO Cell" ,
						p_ue_context->ue_index);

				/* CSR 55938: code changes start */
				/* CSR 55938: code changes end */

				ret_val = rrm_build_and_send_1xrtt_daho_ho_required (
						p_ue_context,
						transaction_id);
				if (RRM_SUCCESS == ret_val) 
				{
					p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
						ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL;
					RRM_TRACE(g_cellm_log_on_off,
							p_rrm_cellm_facility_name,
							RRM_DETAILED,
							"HO triggered for UE: [%d]",
							p_ue_context->ue_index);
				}
			}
			else if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
			{
				/* Bug 16121 Fix Start */
				if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
							p_ue_context->ue_index,
							RADIO_NETWORK_LAYER_TYPE,
							INTER_RAT_REDIRECTION,
							p_g_rrm_ue_ctx->trans_id,
							p_ue_context,
							/* SPR_10729_fix */
							p_ue_context->cell_index))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
					if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_rrm_uem_facility_name,
								RRM_DETAILED,
								"ue_connection_release_ind sent, \
								Failed to clean up ue resources");
						ret_val = RRM_FAILURE;
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							"Failed to send release connection ind for UE index:%d",
							p_ue_context->ue_index);
					ret_val = RRM_FAILURE;
				}
				/* Bug 16121 Fix End */

			}
		}
		else if((RRM_FALSE == p_ue_context->cdma2000_ho_cmd_resp.cdma2000_1xrtt_params.
					ho_required_sent_status) && (RRM_TRUE == p_ue_context->
						cdma2000_ho_cmd_resp.cdma2000_hrpd_params.ho_required_sent_status))
		{
			/* RWR */
			rrm_ue_stop_ho_timers(p_ue_context);

			/* Check if it was previously from DAHO/MAHO */
			if(RRM_HO_REQUIRED_SENT_FOR_MAHO_CELL == p_ue_context->cdma2000_ho_cmd_resp.
					cdma2000_hrpd_params.ho_req_identifier)
			{
				/* Trigger HO to HRPD DAHO */
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"UE_INDEX[%d] Sending HO REQUIRED to 1XRTT DAHO Cell" ,
						p_ue_context->ue_index);

				/* CSR 55938: code changes start */
				/* CSR 55938: code changes end */

				ret_val = rrm_build_and_send_hrpd_daho_ho_required (
						p_ue_context,
						transaction_id);
				if (RRM_SUCCESS == ret_val) 
				{
					p_ue_context->cdma2000_ho_cmd_resp.cdma2000_hrpd_params.
						ho_req_identifier = RRM_HO_REQUIRED_SENT_FOR_DAHO_CELL;

					RRM_TRACE(g_cellm_log_on_off,
							p_rrm_cellm_facility_name,
							RRM_DETAILED,
							"HO triggered for UE: [%d]", 
							p_ue_context->ue_index);
				}
			}
			else if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
			{
				/* Bug 16121 Fix Start */
				if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
							p_ue_context->ue_index,
							RADIO_NETWORK_LAYER_TYPE,
							INTER_RAT_REDIRECTION,
							p_g_rrm_ue_ctx->trans_id,
							p_ue_context,
							/* SPR_10729_fix */
							p_ue_context->cell_index))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
					if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_rrm_uem_facility_name,
								RRM_DETAILED,
								"ue_connection_release_ind sent, \
								Failed to clean up ue resources");
						ret_val = RRM_FAILURE;
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							"Failed to send release connection ind for UE index:%d",
							p_ue_context->ue_index);
					ret_val = RRM_FAILURE;
				}
				/* Bug 16121 Fix End */

			}
			/* SPR 16406 8SEP start */
			/* Code removed */
			/* SPR 16406 8SEP end */
		}
		/* Start :SPR 8868 */
		if (RRM_FAILURE == ret_val) 
		{
			if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
			{
				/* Bug 16121 Fix Start */
				if(RRM_SUCCESS ==  rrm_build_and_send_ue_connection_release_ind(
							p_ue_context->ue_index,
							RADIO_NETWORK_LAYER_TYPE,
							CS_FALLBACK_TRIGGERED,
							p_g_rrm_ue_ctx->trans_id,
							p_ue_context,
							/* SPR_10729_fix */
							p_ue_context->cell_index))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
					if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_rrm_uem_facility_name,
								RRM_DETAILED,
								"ue_connection_release_ind sent, \
								Failed to clean up ue resources");
						ret_val = RRM_FAILURE;
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							"Failed to send release connection ind for UE index:%d",
							p_ue_context->ue_index);
					ret_val = RRM_FAILURE;
				}
				/* Bug 16121 Fix End */

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"Release with redirection on CDMA 1xrtt after HO failure received in case of CSFB\n");
			}
			else
			{
				RRM_TRACE(g_cellm_log_on_off,
						p_rrm_cellm_facility_name,
						RRM_DETAILED,
						"HO Required failed on CDMA for UE: [%d]",
						p_ue_context->ue_index);
				/* SPR 16406 8SEP start */
				/* Code removed */
				/* SPR 16406 8SEP end */
			}
		}
		/* End :SPR 8868 */
	}
	else
	{
		/* SPR 15674 Start */
		/* SPR 16406 8SEP start */
		/* Code deleted */
		/* SPR 16406 8SEP end */
		/* LTE RRM shall do an HO on DAHO Cell after trying only once
		 *        on a cell reported by measurements for an emergency call. */
		/* SPR 16406 Start */
		if( ( p_ue_context->ho_params.eutra_known_cell_selection_list.bitmask & RRM_UE_BLIND_CELL_HO_TRIGGERED ) ||
				( p_ue_context->ho_params.utra_known_cell_selection_list.bitmask & RRM_UE_BLIND_CELL_HO_TRIGGERED ) ||
				( p_ue_context->ho_params.geran_known_cell_selection_list.bitmask & RRM_UE_BLIND_CELL_HO_TRIGGERED) )
			/* SPR 16406 End */
		{
			phy_cell_id_info.phy_cell_id = INVALID_PHYSICAL_CELL_ID;
		}
		else
		{
			/*SPR-604 Fix Starts*/
			if(HANDOVER_TYPE_INTRA_CELL != p_ue_context->ho_type)
				/*SPR-604 Fix Ends*/
			{
				/* LTE RRM shall do an HO on DAHO Cell after trying only once 
				   on a cell reported by measurements for an emergency call. */
				/* SPR 17564 Fix Start */
				if (RRM_TRUE == rrm_is_ue_special_previledge (p_ue_context))
					/* SPR 17564 Fix End */
				{
					/* SPR 16406 Start */
                    /* Spr 18748 Start */
                    if(RRM_TRUE == rrm_check_if_sec_meas_configured(p_ue_context))
                    /* Spr 18748 End */

					{
						phy_cell_id_info = rrm_get_valid_daho_cell_id(p_ue_context);
						/* SPR:15970 Fix Start - 6/4/15 */
						is_ho_trigger_for_daho = RRM_TRUE;
						/* SPR:15970 Fix End - 6/4/15 */

					}
					/* SPR 16406 8SEP start */
					if(phy_cell_id_info.phy_cell_id == INVALID_PHYSICAL_CELL_ID)
					{
						/* SPR 16406 8SEP end */
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"Changed the UE HO state to RRM_HO_STATE_NULL as"
								" HO_FAILURE received and trying to find the next best suitable PCI\n");
						/*SPR 16581 END*/

						p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

						/* SPR 16406 8SEP start */
						/* Code deleted */
						/* SPR 16406 8SEP end */

						/* SPR 16406 8SEP start */
						/* Code deleted */
						/* SPR 16406 8SEP end */
						/* SPR 16406 24Sep Start */
						rrm_search_and_remove_phy(p_ue_context,
								p_ue_context->ho_params.target_phys_cell_id,
								p_ue_context->ho_params.target_earfcn);
						/* SPR 16406 24Sep End */
						/* SPR 16406 3Aug Start */
						if(RRM_SUCCESS == rrm_uem_search_and_select_pci_for_ho(p_ue_context, transaction_id))
						{
							RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_WARNING,
									"RRM has started HO procedure after HO failure ");
							RRM_UT_TRACE_EXIT();
							return RRM_SUCCESS;
						}
						/* SPR 16406 End */

					}
				}
				else
				{
					/* SPR 16406 8SEP start */
                    /* Spr 18748 Start */
                    if((RRM_TRUE == rrm_check_if_sec_meas_configured(p_ue_context)) &&
							(p_ue_context->ho_params.ho_retry_count > ho_retry_count))
                    /* Spr 18748 End */
					{
						phy_cell_id_info = rrm_get_valid_daho_cell_id(p_ue_context);
						/* SPR:15970 Fix Start - 6/4/15 */
						is_ho_trigger_for_daho = RRM_TRUE;
						/* SPR:15970 Fix End - 6/4/15 */
					}
					else
					{
						/* SPR 16406 8SEP end */
						/* SPR 16406 8SEP start */
						/* Code deleted */
						/* SPR 16406 8SEP end */

						/* SPR 16406 24Sep Start */
						rrm_search_and_remove_phy(p_ue_context,
								p_ue_context->ho_params.target_phys_cell_id,
								p_ue_context->ho_params.target_earfcn);
						/* SPR 16406 24Sep End */
						/* SPR 16406 8SEP start */
						/* Code deleted */
						/* SPR 16406 8SEP end */
						/* SPR 16406 3Aug Start */
						if(RRM_SUCCESS == rrm_uem_search_and_select_pci_for_ho(p_ue_context, transaction_id))
						{
							RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_WARNING,
									"RRM has started HO procedure after HO failure ");
							RRM_UT_TRACE_EXIT();
							return RRM_SUCCESS;
						}
						/* SPR 16406 3Aug End */
                        /* Spr 18748 Start */
                        if((RRM_TRUE == rrm_check_if_sec_meas_configured(p_ue_context)) &&
								(RRM_INVALID_CELL_LIST_TYPE == p_ue_context->rrm_cell_selection_info.current_cell_list))
                            /* Spr 18748 End */
						{
							phy_cell_id_info = rrm_get_valid_daho_cell_id(p_ue_context);
							/* SPR:15970 Fix Start - 6/4/15 */
							is_ho_trigger_for_daho = RRM_TRUE;
							/* SPR:15970 Fix End - 6/4/15 */
						}
						/* SPR 16406 End */

					}
				}
			}


			/* Inter RAT changes end */
			/* SPR 16406 Start */
			if(phy_cell_id_info.phy_cell_id !=INVALID_PHYSICAL_CELL_ID )
				/* SPR 16406 End */
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                        "UE_INDEX[%d] Sending HO REQUIRED to TGT eNb" ,
                        p_ue_context->ue_index);

                /* CSR 55938: code changes start */
                /* CSR 55938: code changes end */

                ret_val = rrm_build_and_send_ho_required (phy_cell_id_info,
                        p_ue_context,
                        transaction_id);    
                if (RRM_SUCCESS == ret_val) {
                    /* SPR 16406 8SEP start */
                    /* Code removed */
                    /* SPR 16406 8SEP end */
                    /* SPR:15970 Fix Start - 6/4/15 */
                    if (is_ho_trigger_for_daho == RRM_FALSE)
                        p_ue_context->ho_params.last_ho_trigger_event = 
                            p_ue_context->ho_params.last_reported_meas_event;
                    /* SPR:15970 Fix End - 6/4/15 */
                    RRM_TRACE(g_cellm_log_on_off,
                            p_rrm_cellm_facility_name,
                            RRM_DETAILED,
                            "HO triggered towards PCI[%d], Earfcn[%d]"
                            "for UE: [%d]", phy_cell_id_info.phy_cell_id,
                            phy_cell_id_info.carr_earfcn,
                            p_ue_context->ue_index);
                }
                else 
                {
                    /* SPR 8481 start */
                    if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
                    {
                        /*Coverity 83423 Fix Start*/
                        if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                                    p_ue_context->ue_index,
                                    RADIO_NETWORK_LAYER_TYPE,
                                    CS_FALLBACK_TRIGGERED,
                                    p_g_rrm_ue_ctx->trans_id,
                                    p_ue_context,p_ue_context->cell_index))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "Release with redirection after HO failure received in case of CSFB\n");
                            /* SPR 20742 start */
                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                            {
                                RRM_TRACE(g_uem_log_on_off,
                                        p_rrm_uem_facility_name,
                                        RRM_ERROR,
                                        "Failed to clean up ue resources");
                                ret_val = RRM_FAILURE;
                            }
                            /* SPR 20742 end */
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    "Failed to send release connection ind for UE index:%d",
                                    p_ue_context->ue_index);
                            ret_val = RRM_FAILURE;
                        }
                        /*Coverity 83423 Fix End*/
                    }
                    /* SPR 8481 end */
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off,
                                p_rrm_cellm_facility_name,
                                RRM_DETAILED,
                                "HO Required failed towards PCI[%d], Earfcn[%d]"
                                "for UE: [%d]", phy_cell_id_info.phy_cell_id,
                                phy_cell_id_info.carr_earfcn,
                                p_ue_context->ue_index);
                        /* SPR 16406 8SEP start */
                        /* SPR 16406 8SEP start */
                        /* Code removed */
                        /* SPR 16406 8SEP end */
                        /* SPR 16406 8SEP start */

                        /* SPR 16406 24Sep Start */
                        rrm_search_and_remove_phy(p_ue_context,
                                p_ue_context->ho_params.target_phys_cell_id,
                                p_ue_context->ho_params.target_earfcn);
                        /* SPR 16406 24Sep End */


                        if(RRM_SUCCESS == rrm_uem_search_and_select_pci_for_ho(p_ue_context, transaction_id))
                        {
                            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_WARNING,
                                    "RRM has started HO procedure after HO failure ");
                            RRM_UT_TRACE_EXIT();
                            return RRM_SUCCESS;
                        }
                        /*SPR 17527 START*/
                        else
                        {
                            if(RRM_TRUE != rrm_ue_is_cgi_report_pending(p_ue_context))
                            {
                                /* SPR 16406 8SEP start */
                                if (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status)
                                {
                                    rrm_remove_previous_pending_measurement(p_ue_context);
                    }
                    else
                    {
                        /* SPR 16406 3Aug Start */
                        rrm_uem_send_cdrx_removal(p_ue_context);
                        /* SPR 16406 3Aug End */
                    }
                    /* SPR 16406 8SEP end */
                }
            }
            /*SPR 17527 END*/  

            /* SPR 16406 8SEP end */

            /* SPR 15674 End */
                    }
                }
            }
            else
            {   
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                        "UE_INDEX[%d] No other best cell is available for HO trigger " ,
                        p_ue_context->ue_index);
				/* SPR 8481 start */
                /* SPR 13445 Fix Start */
                /* SPR 14426 Fix Start */
                if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)  
                    /* SPR 14426 Fix End */
                {
                    /*SPR_17893_START*/
                    if(RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES == p_ue_context->ue_state)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                                "UE_INDEX[%d], UE state is WAIT_FOR_CAP_ENQ_RES, "
                                "RRM_UE_CSFB_RECD is set.Not sending Connection Release Ind" ,
                                p_ue_context->ue_index);
                        ret_val = RRM_SUCCESS;
                    }
                    else
                    {    
                        /*SPR_17893_END*/
                        /* Bug 16121 Fix Start */
                        if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                                    p_ue_context->ue_index,
                                    RADIO_NETWORK_LAYER_TYPE,
                                    CS_FALLBACK_TRIGGERED,
                                    p_g_rrm_ue_ctx->trans_id,
                                    p_ue_context,
                                    /* SPR_10729_fix */
                                    p_ue_context->cell_index))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                            {
                                RRM_TRACE(g_uem_log_on_off,
                                        p_g_rrm_uem_facility_name,
                                        RRM_DETAILED,
                                        "ue_connection_release_ind sent, \
                                        Failed to clean up ue resources");
                                ret_val = RRM_FAILURE;

                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    "Failed to send release connection ind for UE index:%d",
                                    p_ue_context->ue_index);
                            ret_val = RRM_FAILURE;
                        }
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Release with redirection after DAHO HO failure received in case of CSFB\n");
                        /*SPR_17893_START*/
                    }
                    /*SPR_17893_END*/
                    /* Bug 16121 Fix End */
                }
                /* SPR 13445 Fix End */
                /* SPR 8481 end */
                /*SPR 20123 Fix Start*/
                else if (RRM_TRUE == p_ue_context->ue_block_params.rrm_ue_meas_config_req_sent)
                {
                    /* SPR-20656 START */
                    if (RRM_FALSE == rrm_is_ue_special_previledge(p_ue_context))
                        /* SPR-20656 END */
                    {
                        if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                                    p_ue_context->ue_index,
                                    RADIO_NETWORK_LAYER_TYPE,
                                    CELL_NOT_AVAILABLE,
                                    p_g_rrm_ue_ctx->trans_id,
                                    p_ue_context,
                                    /* SPR_10729_fix */
                                    p_ue_context->cell_index))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                            {
                                RRM_TRACE(g_uem_log_on_off,
                                        p_g_rrm_uem_facility_name,
                                        RRM_DETAILED,
                                        "ue_connection_release_ind sent, \
                                        Failed to clean up ue resources");
                                ret_val = RRM_FAILURE;

                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    "Failed to send release connection ind for UE index:%d",
                                    p_ue_context->ue_index);
                            ret_val = RRM_FAILURE;
                        }
                        /* SPR-20656 START */
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "Skipping UE[%u] for release as establishment cause is[%u]",
                                p_ue_context->ue_index,
                                p_ue_context->establishment_cause);
                    }
                    /* SPR-20656 END */

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Release with redirection after DAHO HO failure received in case of ES Cell switch off\n");
                }
                /*SPR 20123 Fix End*/
                else
                {
                    /* SPR 16406 8SEP start */
                    /* Code removed */
                    /* SPR 16406 8SEP end */
                    /* SPR 16406 8SEP start */
                    /* SPR 16406 8SEP end */
                    /*SPR 17527 START*/
                    if(RRM_TRUE != rrm_ue_is_cgi_report_pending(p_ue_context))
                    {
                        /* SPR 16406 8SEP start */
                        if (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status)
                        {
                            rrm_remove_previous_pending_measurement(p_ue_context);
                        }
                        else
                        {
                            /* SPR 16406 3Aug Start */
                            rrm_uem_send_cdrx_removal(p_ue_context);
                            /* SPR 16406 3Aug End */
                        }
                        /* SPR 16406 8SEP end */
                    }
                    /*SPR 17527 END*/  

                }
            }
        }
    }
    /*SPR 18241 START*/
    if ( (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL) && 
            (rrm_get_queue_count(&p_ue_context->procedure_queue)))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], dequeue queued message",
                p_ue_context->ue_index);
        /** Dequeue the events from event queue and call message handler */
        /* SPR 15849 Start */
        p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
        /* SPR 15849 End */
        if(RRM_PNULL != p_rrm_ue_procedure_record)
        {
            /* CSR00069389 Start */
            rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
            /* CSR00069389 End */
        }
    }
    /*SPR 18241 END*/

    /* SPR 15441 start */
    /* code removed */
    /* SPR 15441 end */
    /*SPR_17893_START*/
    } 
    /*SPR_17893_END*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 16406 3Aug Start */
/****************************************************************************
 * Function Name  : rrm_uem_send_cdrx_removal 
 * Inputs         : p_ue_context
 * Outputs        : NONE
 * Returns        : NONE 
 * Description    : This function sends CDRX removal request to UE if applicable.
 ****************************************************************************/
rrm_void_t
	rrm_uem_send_cdrx_removal
(
 rrm_ue_context_t *p_ue_context
 )
{
     /* Coverity Fix 88583 Start */
    rrm_ue_cdrx_status_et    cdrx_save = p_ue_context->cdrx_status;
    /* Coverity Fix 88583 End */
    
	RRM_UT_TRACE_ENTER();

	if (RRM_UE_CDRX_APPLIED == p_ue_context->cdrx_status)
	{
		/* need to send CDRX removal request here */
		p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_REMOVED;
		if (RRM_FAILURE == rrm_build_and_send_ue_reconfig_req(p_ue_context))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"Failed to send UE reconfig request to remove CDRX, UE index[%d]",
					p_ue_context->ue_index);
            p_ue_context->cdrx_status = cdrx_save;        
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"UE reconfig request sent to UE index[%d] to remove CDRX ",
					p_ue_context->ue_index);
		}
	}

	RRM_UT_TRACE_EXIT();
}

/* SPR 16406 3Aug End */

/* SPR 16406 Start */
/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_ho_cancel_resp 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the ue_ho_cancel_resp message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_ho_cancel_resp (
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	/* SPR 15232 start */
	rrm_return_et				ret_val = RRM_SUCCESS;
	/*MC, MR & HO  START */
	rrm_ue_context_t                    *p_ue_context = RRM_PNULL;
    /* SPR-17852 START */
    /* removed p_cell_ctxt */ 
    /* SPR-17852 END */
  /*SPR 18241 START*/
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
    /*SPR 18241 END*/

	/* SPR 16406 24Sep Start */
	/* Code removed */
	/* SPR 16406 24Sep End */ 
	RRM_UT_TRACE_ENTER();
	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	p_ue_context->ue_ho_current_state =  RRM_HO_STATE_NULL;
    /*SPR_17893_START*/
    if((RRM_TRUE == rrm_check_utran_capability_enq_info(p_ue_context,RRM_TRUE,RRM_FALSE)) &&
            (RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT !=  
             (p_ue_context->ue_capability_params.bitmask & RRM_UE_UTRA_RADIO_CAPABILITY_PRESENT)))
    {    
        rrm_ue_set_state(p_ue_context,RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES);
    } 
    else
    {
        /*SPR_17893_END*/
	rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
        /*SPR_17893_START*/
    }
    /*SPR_17893_END*/

	p_ue_context->ho_params.ho_retry_count = RRM_ZERO;
	/* SPR 16406 8SEP start */
	p_ue_context->ho_params.last_ho_trigger_event = MEAS_REP_EVENT_NONE;
    /* Spr 18511, 18488 Changes Start */
    if((p_ue_context->current_procedure.state != RRM_UE_MEAS_CONFIG_REQ_ONGOING) &&
        (p_ue_context->current_procedure.state != RRM_UE_RECONFIG_ONGOING))
    {
        p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
    }
    /* Spr 18511, 18488 Changes End */
	/* SPR 16406 8SEP end */


	/* SPR:15970 Fix Start */
	/* Code Removed */
	/* SPR:15970 Fix End */
	if(p_ue_context->ho_params.eutra_known_cell_selection_list.count)
	{
        /* SPR-17852 START */
        if((p_ue_context->ho_params.blind_timer)) {
        /* SPR-17852 END */
            rrm_ue_stop_timer (p_ue_context->ho_params.blind_timer);
            p_ue_context->ho_params.blind_timer = RRM_PNULL;
        }
	}
	/* SPR 16406 24Sep Start */
	rrm_search_and_remove_phy(p_ue_context,
			p_ue_context->ho_params.target_phys_cell_id,
			p_ue_context->ho_params.target_earfcn);
	/* SPR 16406 24Sep End */

	/* SPR:15970 Fix End - 6/4/15 */
	/* SPR 16406 3Aug Start */
	if(RRM_FAILURE == rrm_uem_search_and_select_pci_for_ho(p_ue_context,rrm_generate_txn_id()))
	{
        /*SPR 17527 START*/
        if(RRM_TRUE != rrm_ue_is_cgi_report_pending(p_ue_context))
        {
        /* SPR 16406 8SEP start */
        if (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status)
        {
            rrm_remove_previous_pending_measurement(p_ue_context);
        }
        else
        {
        rrm_uem_send_cdrx_removal(p_ue_context);
    } 
        /* SPR 16406 8SEP end */
        }
        /*SPR 17527 END*/ 
	}
	/* SPR 16406 3Aug End */
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
    /*SPR 18241 START*/
    if ( (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL) && (rrm_get_queue_count(&p_ue_context->procedure_queue)))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], dequeue queued message",
                p_ue_context->ue_index);
        /** Dequeue the events from event queue and call message handler */
        /* SPR 15849 Start */
        p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
        /* SPR 15849 End */
        if(RRM_PNULL != p_rrm_ue_procedure_record)
        {
            /* CSR00069389 Start */
            rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
            /* CSR00069389 End */
        }
    }
    /*SPR 18241 END*/


	RRM_UT_TRACE_EXIT();
	/*MC, MR & HO END */
	return ret_val;
}
/* SPR 16406 End */
/* SPR 15232 end */

/****************************************************************************
 * Function Name  : rrm_ue_map_modify_drb_id_lc_id
 * Inputs         : rrm_ue_context_t, rrm_ue_erab_setup_item_list_t
 * Outputs        : None
 * Returns        : void
 * Description    : Map the LCID and LC ID
 ****************************************************************************/
	void
rrm_ue_map_modify_drb_id_lc_id(
		rrm_ue_context_t                *p_ue_context,
		rrm_ue_erab_setup_item_list_t   *p_setup_item_list
		)
{
	U8      drb_configured_index = RRM_NULL;
	U8      success_list_index = RRM_NULL;
	RRM_UT_TRACE_ENTER();
	for ( success_list_index = RRM_NULL; 
			success_list_index < p_setup_item_list->num_of_list; 
			success_list_index++)
	{
		for ( drb_configured_index = RRM_NULL; 
				drb_configured_index< p_ue_context->drb_configured.num_of_list;                 drb_configured_index++)
		{
			if (p_setup_item_list->erab_item[success_list_index].erab_id ==
					p_ue_context->drb_configured.
					erab_item[drb_configured_index].erab_id)
			{
				p_setup_item_list->erab_item[success_list_index].drb_id =
					p_ue_context->drb_configured.
					erab_item[drb_configured_index].drb_id;
				p_setup_item_list->erab_item[success_list_index].lc_id =
					p_ue_context->drb_configured.
					erab_item[drb_configured_index].lc_id;
				break;
			}
		}
	}
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_find_gbr_ngbr_drb_configd
 * Inputs         : rrm_ue_context_t
 * Outputs        : number of configured gbr and ngbr bearers 
 * Returns        : void
 * Description    : outputs number of configured gbr and ngbr bearers 
 ****************************************************************************/
	 void
rrm_find_gbr_ngbr_drb_configd(
		rrm_ue_context_t *p_ue_context,
		U8 *p_gbr_count,
		U8 *p_ngbr_count
		)
{

	U32 index = RRM_NULL;
	U8  qci;
	/* SPR 19968 Start */
	*p_gbr_count = RRM_NULL;
        *p_ngbr_count = RRM_NULL;
	/* SPR 19968 End */
	for(index = RRM_NULL ; 
			index < p_ue_context->drb_configured.num_of_list;
			index++)
	{
		qci = p_ue_context->drb_configured.erab_item[index].
			erab_level_qos_params.qci;
		if(qci >= RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
		{
			(*p_gbr_count)++;
		}
		else if(qci >= RRM_NGBR_QCI_5 && qci <=RRM_NGBR_QCI_9)
		{
			(*p_ngbr_count)++;
		}
	}
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
			"Total gbr_count: %d, ngbr_count: %d",
			*p_gbr_count, *p_ngbr_count);
}

/* CA: SCell Selection start */
/****************************************************************************
 * Function Name  : rrm_check_for_ca_need_thru_erab_setup_or_ho_cnf
 * Inputs         : p_ue_context
 * Outputs        : SUCCESS or FAILURE
 * Description    : This function returns SUCCESS if the total guaranteed 
 *                  bitrate of already established GBR bearers exceeds the 
 *                  OAM-configured threshold for CA.
 ****************************************************************************/
	rrm_return_et
rrm_check_for_ca_need_thru_erab_setup_or_ho_cnf(
		rrm_ue_context_t                 *p_ue_context
		)
{
	rrm_return_et         ret_val = RRM_FAILURE;
	U64                   ul_total_gbr_ue         = RRM_ZERO;
	U64                   dl_total_gbr_ue         = RRM_ZERO;
	rrm_cell_context_t   *p_cell_context = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	/* Coverity_fix_start_62536 */
	if(RRM_PNULL != p_ue_context)
	{
		/* Coverity_fix_end_62536 */
		p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index); 
		if(RRM_PNULL != p_cell_context)
		{
			/* Calculate the guar bit rate for GBR bearers on this UE */
			rrm_ue_calculate_total_bit_rate(p_ue_context, 
					&ul_total_gbr_ue, 
					&dl_total_gbr_ue);

			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"ul_total_gbr_ue: %llu, dl_total_gbr_ue: %llu",
					ul_total_gbr_ue, dl_total_gbr_ue);

			if(dl_total_gbr_ue > p_cell_context->operator_info.ca_config.ca_applicable_bitrate_dl)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"dl_total_gbr_ue: %llu, ca_applicable_bitrate_dl: %llu", dl_total_gbr_ue,
						p_cell_context->operator_info.ca_config.ca_applicable_bitrate_dl);

				if (RRM_SUCCESS != rrm_check_for_ca_preconditions(p_ue_context, p_cell_context))
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
							"Cannot enabled CA for the UE [%u]", p_ue_context->ue_index);
				}
				else
				{
					ret_val = RRM_SUCCESS;
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"CA enabled for the UE [%u]", p_ue_context->ue_index);
				}
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"ue_context or cell_context is NULL");
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/******************************************************************************
 * Function Name  : rrm_compare_ue_csg_with_cell_csg_status
 * Inputs         : p_ue_context
 *                : p_scell_ctxt
 *                : p_cell_access_mgmt_params
 * Outputs        : TRUE or FALSE
 * Description    : Returns TRUE if the csg membership status of the UE is 
 *                  compatible with that of the scell-eligible cell, else FALSE.
 ******************************************************************************/
	rrm_bool_et
rrm_compare_ue_csg_with_cell_csg_status(
		rrm_ue_context_t           *p_ue_context,
		rrm_cell_context_t         *p_scell_ctxt,
		access_mgmt_params_t       *p_cell_access_mgmt_params
		)
{
	U8      index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	if(RRM_PNULL != p_ue_context &&
			RRM_PNULL != p_scell_ctxt)
	{
		/* 
		 ** The CSG status of the 'SCell-eligible' cell should be compatible
		 ** with the CSG status of the UE.
		 ** 1- If the UE CSG membership is 'MEMBER', and SCell's CSG status 
		 **    is CLOSED, then SCell's CSG ID needs to be matched with that
		 **    of the PCell if PCell's CSG status is also CLOSED.
		 ** 2- If the UE CSG membership is 'MEMBER', and SCell's CSG status
		 **    is OPEN or HYBRID, then no need to match SCell's CSG ID with
		 **    that of the PCell.
		 ** 3- If the UE CSG membership is 'NON-MEMBER', then the SCell can 
		 **    be OPEN or HYBRID.
		 */

		if(RRM_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"UE CSG status is %d", p_ue_context->rrm_csg_membership.rrm_csg_membership_status);

			if(RRM_OAM_ACCESS_MODE_CLOSE == p_scell_ctxt->access_mgmt_params.access_mode)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"SCell CSG status is %d", p_scell_ctxt->access_mgmt_params.access_mode);

				if(RRM_OAM_ACCESS_MODE_CLOSE == p_cell_access_mgmt_params->access_mode)
				{
					for(index = RRM_ZERO; index < NUM_CSG_OCTETS; index++)
					{
						if(p_scell_ctxt->access_mgmt_params.csg_id[index] ==
								p_cell_access_mgmt_params->csg_id[index])
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
									"CSG ID of PCell and SCell match at index %d", index);
						}
						else
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
									"CSG ID of PCell and SCell do not match at index %d", index);

							break;
						}
					}
					if(index == NUM_CSG_OCTETS)
					{
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
								"CSG status of UE and SCell are compatible and CSG ID of SCell \
								matches with that of the PCell!");

						return RRM_TRUE;
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"CSG status of PCell is not CLOSED, so no need to match CSG ID of SCell");

					return RRM_TRUE;
				}
			}
			else if(RRM_OAM_ACCESS_MODE_HYBRID == p_scell_ctxt->access_mgmt_params.access_mode ||
					RRM_OAM_ACCESS_MODE_OPEN == p_scell_ctxt->access_mgmt_params.access_mode)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"SCell CSG status is %d", p_scell_ctxt->access_mgmt_params.access_mode);

				return RRM_TRUE;
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"Not a valid SCell CSG status!");
			}
		}
		else if(RRM_NOT_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"UE CSG status is %d", p_ue_context->rrm_csg_membership.rrm_csg_membership_status);

			if(RRM_OAM_ACCESS_MODE_HYBRID == p_scell_ctxt->access_mgmt_params.access_mode ||
					RRM_OAM_ACCESS_MODE_OPEN == p_scell_ctxt->access_mgmt_params.access_mode)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"SCell CSG status is %d", p_scell_ctxt->access_mgmt_params.access_mode);

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"CSG status of UE and SCell are compatible!");

				return RRM_TRUE;
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"Not a valid SCell CSG status in this case since UE is NON_MEMBER!");
			}
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Either ue_context is NULL or Cell context is NULL");
	}

	RRM_UT_TRACE_EXIT();
	return RRM_FALSE;
}


/* SPR 13383 changes start */

/******************************************************************************
 * Function Name  : rrm_function_check_band_combination_set_support
 * Inputs         : p_ue_context
 *                : index
 *                : bandwidthcombination_set
 * Outputs        : -Ve or +Ve
 * Description    : function check the band combination set value for given 
 combination index in which all other condition is satisfied
 like bandwidth combination & class except combination set
 ******************************************************************************/
	S8
rrm_function_check_band_combination_set_support( rrm_ue_context_t    *p_ue_context , 
		U8                   index , 
		U32                  bandwidthcombination_set )
{

	rrm_rf_parameters_v1060_ies_t    *p_rf_parameters_v1060_ies_t = RRM_NULL;
	U8                                i = RRM_ZERO;
	S8                                combination_set_supported= RRM_ONE;
	U8                                data = RRM_ZERO;
	U32                               combinationset_bitmask = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	if( p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
			ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask & RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT )
	{
		if( p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
				ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
				ue_eutra_capability_v1060.bitmask & RRM_UE_EUTRA_CAPABILITY_V1060_RF_PARAMETERS_PRESENT )
		{    
			p_rf_parameters_v1060_ies_t =  
				( rrm_rf_parameters_v1060_ies_t  *) 
				&(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
						ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
						ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060 );

			if( index >= p_rf_parameters_v1060_ies_t->supported_band_combination_ext_r10.count ||
					index >= MAX_BAND_COMB_R10  )
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"Combination index is not passed correct %d",index);
				/*error condition */
			}
            /* SPR 21496 Fix Start */ 
			else if( p_rf_parameters_v1060_ies_t->supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10[index].bitmask &
					RRM_SUPPORTED_BAND_WIDTH_COMB_SET_R10 )
			{
				for( i = RRM_ZERO; i < p_rf_parameters_v1060_ies_t->supported_band_combination_ext_r10.
						p_band_combination_parameters_ext_r10[index].supported_band_width_combination_set_r10.count &&
						i < MAX_BAND_WIDTH_COMB_R10; i++ )
				{
					data = p_rf_parameters_v1060_ies_t->supported_band_combination_ext_r10.
						p_band_combination_parameters_ext_r10[index].supported_band_width_combination_set_r10.data[i];
					combinationset_bitmask |= data << ( RRM_THIRTY_TWO - (( i + RRM_ONE)*RRM_EIGHT) );


				}
                /* SPR 21496 Fix End */ 

				if( !(combinationset_bitmask & bandwidthcombination_set) ) 
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"Combination set is found at index %d",i );
					combination_set_supported = RRM_MINUS_ONE;
				}
			}
		}
	}
	RRM_UT_TRACE_EXIT();

	return combination_set_supported; 

}



/******************************************************************************
 * Function Name  : rrm_function_match_band_combination_in_ue_capability
 * Inputs         : p_ue_context 
 *                : carrier_1_band
 *                : carrier_2_band
 *                : band_comb_set
 * Outputs        : S8
 * Description    : Checks the compatibilty of the UE with the Scell-eligible
 *                  cells received in the scell_list.
 ******************************************************************************/
S8
rrm_function_match_band_combination_in_ue_capability( 
		rrm_ue_context_t   *p_ue_context,
		U8                  carrier_1_band , 
		U8                  carrier_2_band ,
		U8                  carrier_1_bw_class,
		U8                  carrier_2_bw_class, 
		U32                 band_comb_set,
		rrm_bool_et         contigious_bandwidth )
{

    U8                                        i, j, k = RRM_ZERO;
    U8                                        supported_band = RRM_ZERO;
    S8                                        combination_found = RRM_MINUS_ONE;
    U8                                        inter_band = RRM_ZERO;
    U8                                        bandwidth_class_bitmask = RRM_ZERO;
    rrm_ca_band_width_class_r10_et            bandwidth_class = rrm_bw_a ;
    /* LAA Rel13 Code + */
    rrm_supported_band_combination_r10_ies_t *p_band_comb_r10_ies = RRM_NULL;
    /* LAA Rel13 Code - */
    rrm_bool_et                               look_bw_class = RRM_FALSE;
    U32                                       band_comb_bitmask = RRM_ZERO;
    U8                                        intra_non_conti = RRM_ZERO;

    RRM_UT_TRACE_ENTER();


    if( carrier_2_band != carrier_1_band )
        inter_band = RRM_ONE;

    /* SPR 12008 end */
    if( p_ue_context->ue_capability_params.bitmask & 
            RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        if(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask & 
                RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)
        {
            if(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask &
                    RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT)
            {
                if(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.bitmask & RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT)
                {
                    /* LAA Rel13 Code + */

                    /*If Ue capability is Rel 13 then checks the compatibilty of the Rel 13 UE 
                     * with the Scell-eligible cells received in the scell_list else checks the
                     * compatibilty of the Rel 10 UE with the Scell-eligible cells received in 
                     * the scell_list
                     */
                        /* LAA Rel13 Code - */

                        if(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask &
                                RRM_UE_EUTRA_CAPABILITY_V1020_RF_PARAMETERS_PRESENT)
                        {
                            p_band_comb_r10_ies = (rrm_supported_band_combination_r10_ies_t *) 
                                &(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                        ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10);

                            for(i = RRM_ZERO; (i < p_band_comb_r10_ies->count) && (i < MAX_BAND_COMB_R10); i++)
                            {
                                combination_found = RRM_MINUS_ONE;
                                band_comb_bitmask = RRM_ZERO;   
                            /*SPR 21878 Start*/
                            intra_non_conti = RRM_ZERO;
                            /*SPR 21878 End*/

                                /* SPR 21496 Fix Start */ 
                                for(j = RRM_ZERO;
                                        (j < p_band_comb_r10_ies->p_band_combination_parameters_r10[i].count) && (j < MAX_SIM_BANDS_R10);
                                        j++)
                                {
                                    look_bw_class = RRM_FALSE;
                                    bandwidth_class_bitmask = RRM_ZERO;
                                    supported_band = p_band_comb_r10_ies->p_band_combination_parameters_r10[i].p_band_parameters_info[j].band_eutra_r10;
                                    /* SPR 21496 Fix End */ 


                                    /* if scell band is non zero its mean this is inter band combination match */
                                    if( inter_band)
                                    {
                                        if( supported_band == carrier_1_band) 
                                        {
                                            if( !(band_comb_bitmask & RRM_CARRIER_COMPONENT_1_BITMASK) )
                                            {
                                                band_comb_bitmask |= RRM_CARRIER_COMPONENT_1_BITMASK; 

                                                look_bw_class = RRM_TRUE;   
                                                combination_found = RRM_ONE;
                                            }
                                            else
                                            {
                                                combination_found = RRM_MINUS_ONE;
                                                break;
                                            }
                                        }
                                        else if( supported_band == carrier_2_band )
                                        {
                                            if( !(band_comb_bitmask & RRM_CARRIER_COMPONENT_2_BITMASK) )
                                            {
                                                band_comb_bitmask |= RRM_CARRIER_COMPONENT_2_BITMASK; 

                                                look_bw_class = RRM_TRUE;    
                                                combination_found = RRM_ONE;
                                            }
                                            else
                                            {
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            break;
                                        }

                                    }
                                    else
                                    {
                                        if( supported_band == carrier_1_band )
                                        {
                                            if( RRM_TRUE == contigious_bandwidth )
                                            {
						/*SPR 21892 Start*/
                                                    band_comb_bitmask |= RRM_CARRIER_COMPONENT_1_BITMASK; 
						/*SPR 21892 End*/
                                            }
                                            else
                                            {
                                                band_comb_bitmask = band_comb_bitmask << RRM_ONE;
                                                band_comb_bitmask |= RRM_CARRIER_COMPONENT_1_BITMASK; 
                                            }

                                            combination_found = RRM_ONE;
                                            look_bw_class = RRM_TRUE;    
                                        }
                                        else
                                        {
                                            combination_found = RRM_MINUS_ONE;
                                            break;
                                        }
                                    }

                                    /*first check : do we have any band is matched with ue_capability
                                      if band is mached then we should check for bandwidth class else
                                      we should not check for bandwidth class*/

                                    if( RRM_TRUE == look_bw_class )
                                    {
                                        /* SPR 21496 Fix Start */ 
                                        if( p_band_comb_r10_ies->p_band_combination_parameters_r10[i].
                                                p_band_parameters_info[j].bitmask & RRM_BAND_PARAMETERS_DL_R10_IES_PRESENT )
                                        {
                                            /* look for bandwidth class value*/
                                            for( k = RRM_ZERO; \
                                                    ( k < p_band_comb_r10_ies->p_band_combination_parameters_r10[i]. \
                                                      p_band_parameters_info[j].band_parameters_dl_r10.count ) \
                                                    && ( k < MAX_BANDWIDTH_CLASS_R10 ); k++ )
                                            {


                                                bandwidth_class =  
                                                    p_band_comb_r10_ies->p_band_combination_parameters_r10[i].p_band_parameters_info[j].
                                                    band_parameters_dl_r10.ca_mimo_parameters_dl_r10[k].ca_band_width_class_dl_r10;

                                                bandwidth_class_bitmask = bandwidth_class_bitmask |                
                                                    rrm_get_bitmask_corresponding_class(bandwidth_class);

                                            }
                                            /* SPR 21496 Fix End */ 

                                            /* if interband combination match is going on */
                                            if( inter_band )
                                            {
                                                /* sccording to spec: 36.101 v 11.990 ,Table 5.6A.1-2 
                                                   supported now only classs A bandwidth, Thats why bitmask
                                                   is checked for RRM_BANDWIDTH_CLASS_A for any combination in interband. if
                                                   bandwidth class does not have class A bit set. its means UE
                                                   did not support the combination */
                                                if( supported_band == carrier_1_band )
                                                {
                                                    if( !(bandwidth_class_bitmask & carrier_1_bw_class ) )
                                                    {
                                                        combination_found = RRM_MINUS_ONE;
                                                    }
                                                }
                                                else if( supported_band == carrier_2_band )
                                                {
                                                    if( !(bandwidth_class_bitmask & carrier_2_bw_class ))
                                                    {
                                                        combination_found = RRM_MINUS_ONE;
                                                    }
                                                }

                                            }
                                            else /* intra conti */
                                            {
                                                /* sccording to spec: 36.101 v 11.990 ,Table 5.6A.1-2 
                                                   supported now only classs C bandwidth, Thats why bitmask
                                                   is checked for RRM_BANDWIDTH_CLASS_C for any combination in intraband. if
                                                   bandwidth class does not have class C bit set. its means UE
                                                   did not support the combination */
                                                if( RRM_TRUE == contigious_bandwidth )
                                                {
                                                    if( !(bandwidth_class_bitmask & carrier_1_bw_class ) )
                                                        combination_found = RRM_MINUS_ONE ;
                                                }
                                                else 
                                                {
                                                    if(  (bandwidth_class_bitmask & carrier_1_bw_class ) &&
                                                            (bandwidth_class_bitmask & carrier_2_bw_class ) )
                                                    {
                                                        intra_non_conti = intra_non_conti >> RRM_ONE;
                                                        intra_non_conti |=  RRM_FOUR;
                                                    }
                                                    else if( bandwidth_class_bitmask & carrier_1_bw_class )
                                                    {
                                                        intra_non_conti |=  RRM_ONE;
                                                    }
                                                    else if( bandwidth_class_bitmask & carrier_2_bw_class)
                                                    {
                                                        intra_non_conti |=  RRM_TWO;
                                                    }
                                                    else
                                                    {
                                                        combination_found = RRM_MINUS_ONE;
                                                    }
                                                }    
                                            }
                                        }
                                        else
                                        {   
                                            combination_found = RRM_MINUS_ONE;
                                            break;
                                        }
                                    }
                                }
                                if( RRM_MINUS_ONE != combination_found)
                                {
                                    if( (inter_band) )
                                    {
                                        if( ( band_comb_bitmask & RRM_CARRIER_COMPONENT_1_BITMASK ) &&
                                                ( band_comb_bitmask & RRM_CARRIER_COMPONENT_2_BITMASK ) )
                                        {
                                            /*first check for bandwidth combination set */
                                            combination_found = rrm_function_check_band_combination_set_support( p_ue_context,
                                                    i,
                                                    band_comb_set);

                                            /* combination is found after fulfilling the band combinaion,band-
                                               width class , band combination set */
                                            if( combination_found != RRM_MINUS_ONE )   
                                                break;
                                        }
                                        else
                                        {
                                            combination_found = RRM_MINUS_ONE;
                                        }

                                    }
                                    else /* if intra band contigious*/  
                                    {
                                        if( RRM_TRUE == contigious_bandwidth )
                                        {
                                            combination_found = rrm_function_check_band_combination_set_support( p_ue_context,
                                                    i,
                                                    band_comb_set);
                                        }
                                        else
                                        {
                                            if( (intra_non_conti == RRM_THREE) ||
                                                    (intra_non_conti == RRM_FIVE)  ||
                                                    (intra_non_conti == RRM_SIX ) )
                                            {
                                                combination_found = rrm_function_check_band_combination_set_support( p_ue_context,
                                                        i,
                                                        band_comb_set);
                                            }
                                            else
                                            {
                                                combination_found = RRM_MINUS_ONE;
                                            }
                                        }
                                        /*if band combination set is found for intra band contigious combination 
                                          then break the most outer loop */                                                                                                         
                                        if( combination_found != RRM_MINUS_ONE )break; 
                                    }
                                }
                            }
                        }
                    /* LAA Rel13 Code - */
                }
            }
        }
    }

    RRM_UT_TRACE_EXIT();

    return combination_found; 
}

/* SPR 13383 changes end */

/*  LAA Rel13 Code +- */
/******************************************************************************
 * Function Name  : rrm_check_ue_compatibilty_with_scell
 * Inputs         : p_ue_context
 *                : p_cell_context
 *                : scell_list
 *                : scell_index_list
 * Outputs        : NONE
 * Description    : Checks the compatibilty of the UE with the Scell-eligible
 *                  cells received in the scell_list.
 ******************************************************************************/
	rrm_void_t
rrm_check_ue_compatibilty_with_scell(
		rrm_ue_context_t         *p_ue_context,
		rrm_cell_context_t       *p_cell_context,
		rrm_cell_index_t         *scell_list,        /* SCell candidates received from CellM */
		rrm_cell_index_t         *scell_index_list   /* Final SCell list of SCells compatible with UE */
		)
{
	U8                     index = RRM_ZERO;
	rrm_cell_context_t    *p_scell_ctxt = RRM_PNULL;
	U8                     scell_index = RRM_ZERO;
	U8                     scell_count = RRM_ZERO;
	rrm_bool_et            scell_index_exist = RRM_FALSE;
	/* SPR 13383 changes start */
	U8                     carrier_1_band = RRM_ZERO;
	U8                     carrier_2_band = RRM_ZERO;
	S8                     found = RRM_MINUS_ONE;
	U8                     carrier_1_bw_class = RRM_ZERO;
	U8                     carrier_2_bw_class = RRM_ZERO;
	U32                    bandwidth_combination_set = RRM_ZERO;
	rrm_bool_et            contigious_bandwidth = RRM_TRUE;
	/* SPR 13383 changes end  */

	RRM_UT_TRACE_ENTER();

	if(RRM_PNULL == p_ue_context ||
			RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Either of the p_ue_context or p_cell_context is NULL");

		return;
	}

	for(index = RRM_ZERO; index < RRM_MAX_SCELL; index++)
	{
		if(RRM_OUT_OF_RANGE != scell_list[index])
		{
			p_scell_ctxt = rrm_cellm_get_cell_context(scell_list[index]);
			/* Coverity:65789 Start*/
			if((RRM_PNULL == p_scell_ctxt) ||
					(CELL_STATE_ACTIVE != p_scell_ctxt->cell_state))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"Either SCell is NULL or Scell's state is not active");

				continue;
			}
			/* Coverity:65789 End*/
			for(scell_count = RRM_ZERO; scell_count < p_ue_context->ue_scell_add_params.count; scell_count++)
			{
				if ((p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_cell_index ==  p_scell_ctxt->cell_index)
                        )
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"Cell index[%d] is already added as scell",p_scell_ctxt->cell_index);
					scell_index_exist = RRM_TRUE;
				}
			}

			if(RRM_TRUE == scell_index_exist)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"Either SCell's state is[%d] not active scell is already added[%d] or cell context is NULL",
						p_scell_ctxt->cell_state,scell_index_exist);
				scell_index_exist = RRM_FALSE;
				continue;
			}

			/* SPR 13383 changes start */
			carrier_1_band = (U8)p_cell_context->ran_info.rf_params.rf_configurations.frequency_band_indicator;
			carrier_2_band = (U8)p_scell_ctxt->ran_info.rf_params.rf_configurations.frequency_band_indicator;

			if(  carrier_1_band == carrier_2_band )
			{
				contigious_bandwidth = rrm_is_band_intra_contigious (p_cell_context , p_scell_ctxt );
				/*serach the entry in Intra band Table */
				if( RRM_TRUE == contigious_bandwidth )
				{
					found =rrm_find_entry_of_carrier_component_in_ca_intra_band_cont_table( carrier_1_band ,
							p_cell_context->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							p_scell_ctxt->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							&carrier_1_bw_class,
							&bandwidth_combination_set
							);
				}
				else
				{
					found = rrm_find_intra_band_non_contigious_entry( carrier_1_band,
							p_cell_context->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							p_scell_ctxt->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							&carrier_1_bw_class,
							&carrier_2_bw_class,
							&bandwidth_combination_set );
				}
			}
			else
			{

				/* Inter band */
				if( carrier_1_band < carrier_2_band )
				{
					/*search the entry in inter band table. combination entry is searched
					  in ascending order in Table, so lowest band value first should be searched
					  in table then next band value should be searched in table */
					found = rrm_find_entry_of_carrier_component_in_ca_inter_band_table( carrier_1_band,
							carrier_2_band,
							p_cell_context->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							p_scell_ctxt->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							&carrier_1_bw_class,
							&carrier_2_bw_class,
							&bandwidth_combination_set ); 
				}                                                                    
				else
				{
					/*search the entry in inter band table. combination entry is searched
					  in ascending order in Table, so lowest band value first should be searched
					  in table then next band value should be searched in table */
					found = rrm_find_entry_of_carrier_component_in_ca_inter_band_table( carrier_2_band,
							carrier_1_band,
							p_scell_ctxt->ran_info.rf_params.
							rf_configurations.dl_bandwidth,
							p_cell_context->ran_info.rf_params.
							rf_configurations.dl_bandwidth, 
							&carrier_2_bw_class,
							&carrier_1_bw_class,
							&bandwidth_combination_set ); 
				}                                                                
			}

			/* if combination entry is not found in table then iterate for next scell */
			if( RRM_MINUS_ONE == found )                                                                    
				continue;

			/* function matches for band combination in ue capability. if combination is 
			   not supported then it returns the -1. This fucntion have four arguments
			   . fourth argument should be passed in case for intra band combination match */
			found = rrm_function_match_band_combination_in_ue_capability( p_ue_context, 
					carrier_1_band,
					carrier_2_band,
					carrier_1_bw_class,
					carrier_2_bw_class,
					bandwidth_combination_set, contigious_bandwidth);

			if( RRM_MINUS_ONE == found )                                                                    
				continue;

			if(RRM_TRUE == 
					rrm_compare_ue_csg_with_cell_csg_status( p_ue_context, 
						p_scell_ctxt, 
						&p_cell_context->access_mgmt_params))
				/* SPR 13383 changes end */
			{
				/* CSG status of the UE is compatible with that of the SCell, so Scell 
				 ** added in the final SCell list */
				scell_index_list[scell_index] = scell_list[index];
				scell_index++;
			}
			else
			{
				/* SPR 12008 start */
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"SCell at index %d in scell list did not comply with the CSG "
						"membership status of the UE, so it is not added in the final "
						"SCell list", index);
				/* SPR 12008 end */
			}

		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"scell_list is having invalid value[%d], out of range at index[%d]",
					scell_list[index], index);
		}
	}

	RRM_UT_TRACE_EXIT();
}

/***********************************************************************
 * Function Name  : rrm_count_scells_in_final_list
 * Inputs         : final_scell_list
 * Outputs        : U8
 * Description    : Counts the total number of SCells in the final list
 ***********************************************************************/
	U8
rrm_count_scells_in_final_list(
		rrm_cell_index_t    *final_scell_list
		)
{
	U8    index = RRM_ZERO;
	U8    count = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	for(index = RRM_ZERO; index < RRM_MAX_SCELL; index++)
	{
		if(RRM_OUT_OF_RANGE != final_scell_list[index])
		{
			count++;
		}
		else
		{
			break;
		}
	}

	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
			"Count of SCells: %d", count);

	RRM_UT_TRACE_EXIT();
	return count;
}

/******************************************************************************
 * Function Name  : rrm_store_final_scell_list_in_ue_context
 * Inputs         : p_ue_context
 *                : final_scell_list
 *                : count
 * Outputs        : NONE
 * Description    : Stores the final scell list and its count in the ue_context.
 ******************************************************************************/
	rrm_void_t
rrm_store_final_scell_list_in_ue_context(
		rrm_ue_context_t         *p_ue_context,
		rrm_cell_index_t         *final_scell_list,
		U8                        count
		)
{
	U8    index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	if(RRM_PNULL != p_ue_context)
	{
		/* Storing the scell count */
		p_ue_context->ca_data.count = count;
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Count stored in ue_context is %d", count);

		/* Storing the array of SCell index in ue_context */
		for(index = RRM_ZERO; index < count; index++)
		{
			p_ue_context->ca_data.final_scell_list[index] = final_scell_list[index];

			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"final_scell_list[%d]: %d", index, 
					final_scell_list[index]);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"p_ue_context is NULL");
	}

	RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 * Function Name  : rrm_check_and_update_ue_scell_list 
 * Inputs         : p_ue_context, p_cell_context,ret_list
 * Outputs        : NONE
 * Description    : Chechk UE compatibilty with Scell.Update UE Scell list.Add
 *                : Scell to UE
 ******************************************************************************/
	rrm_return_et
rrm_check_and_update_ue_scell_list(rrm_ue_context_t *p_ue_context,
		rrm_cell_context_t *p_cell_context,
		rrm_cell_index_t  *p_ret_list)
{
	rrm_cell_index_t   final_scell_list[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
	U8                 count = RRM_ZERO;
	rrm_return_et      ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();
	for(count = RRM_ZERO; count < RRM_MAX_SCELL; count++)
	{
		final_scell_list[count] = RRM_OUT_OF_RANGE;
	}
	count = RRM_ZERO;
	/* Checking the compatibilty of the UE with the Scell-eligible cells 
	   and forming the final Scell list*/
	rrm_check_ue_compatibilty_with_scell(p_ue_context, 
			p_cell_context, 
			p_ret_list,
			final_scell_list);

	/* Counting the number of cells in the final scell list */
	count = rrm_count_scells_in_final_list(final_scell_list);

	/* Storing final scell list and list count in ue_context */
	/* SPR 19838 : CID 10436 Fix Start */
	if(RRM_ZERO != count)
	{ 
		rrm_store_final_scell_list_in_ue_context(p_ue_context, 
				final_scell_list, 
				count);
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"No Scell is found in UE context");
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	}
	/* SPR 19838 : CID 10436 Fix End */
	if (RRM_UE_STATE_IDLE != p_ue_context->ue_state)
	{
		/* Adding the selected SCell */
		ret_val  = rrm_add_scell_to_ue(p_ue_context,
				p_ue_context->ca_data.count,
				p_ue_context->ca_data.final_scell_list);
		if(RRM_SUCCESS == ret_val)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"SCell successfully added for the ue_index %d", 
					p_ue_context->ue_index);
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"Failed to add SCell for the ue_index %d", 
					p_ue_context->ue_index);
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/******************************************************************************
 * Function Name  : rrm_enable_ca_for_the_ue
 * Inputs         : p_ue_context
 *                : p_cell_context
 * Outputs        : NONE
 * Description    : Enables CA for the UE if all the preconditions are satisfied.
 ******************************************************************************/
	rrm_return_et
rrm_enable_ca_for_the_ue(
		rrm_ue_context_t         *p_ue_context,
		rrm_cell_context_t       *p_cell_context
		)
{
	rrm_cell_index_t   ret_list[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
	U8                 index = RRM_ZERO;
	rrm_return_et      ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();

	/* Initializing the arrays */
	for(index = RRM_ZERO; index < RRM_MAX_SCELL; index++)
	{
		ret_list[index] = RRM_OUT_OF_RANGE;
	}

	if(RRM_PNULL != p_ue_context &&
			RRM_PNULL != p_cell_context)
	{
		/* Checking if the SCell Addition method is Database-Assisted 
		   or Measurement-Assisted */

		if((RRM_IS_MASA_INFO_PRESENT & p_cell_context->operator_info.ca_config.bitmask) &&
				(RRM_FALSE == p_cell_context->operator_info.ca_config.is_masa))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"SCell Selection method is Database-Assisted");

			/* Fetching the 'SCell-eligible' cells' sorted array from CellM */ 
			rrm_fetch_scell_eligible_cells_from_cellm(p_cell_context->cell_index,
					ret_list);

			ret_val = rrm_check_and_update_ue_scell_list(p_ue_context,p_cell_context,ret_list);
		}
		else if((RRM_IS_MASA_INFO_PRESENT & p_cell_context->operator_info.ca_config.bitmask) &&
				(RRM_TRUE == p_cell_context->operator_info.ca_config.is_masa))
		{
			/*Configure inter frequency measurment A4 for the UE*/
			if(RRM_TRUE != p_ue_context->ca_data.a4_recv_for_ca)
			{
				ret_val= rrm_verify_ue_for_inter_freq_meas(p_ue_context, RRM_TRUE);
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"SCell Selection method is Measurement-Assisted A4 measurement configuration");
			}
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"Either of the p_ue_context or p_cell_context is NULL");
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/**************************************************************************
 * Function Name  : rrm_check_if_ue_is_ca_capable
 * Inputs         : p_ue_context
 *                : p_cell_context
 * Outputs        : TRUE or FALSE
 * Description    : Checks the eligibility criteria of the UE to be put in 
 *                  CA mode.
 **************************************************************************/
	rrm_bool_et
rrm_check_if_ue_is_ca_capable(
		rrm_ue_context_t                 *p_ue_context, 
		rrm_cell_context_t               *p_cell_context
		)
{
	RRM_UT_TRACE_ENTER();

	if(RRM_PNULL == p_ue_context ||
			RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Either of the p_ue_context or p_cell_context is NULL");

		RRM_UT_TRACE_EXIT();
		return RRM_FALSE;
	}

	/* Checking the eligibility of UE - start */

	/* The frequency band of the Serving Cell should be 10MHz or 20MHz */
	if((RRM_OAM_BW_N_50 == p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth) ||
			(RRM_OAM_BW_N_100 == p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth))
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"FREQ_BAND: %d", p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth);

		/* Bitrate threshold should be exceeded by num_of_report times */ 
		if(p_cell_context->operator_info.ca_config.num_of_report <= 
				p_ue_context->ca_data.num_of_times_threshold_exceeded)
		{
			RRM_UT_TRACE_EXIT();
			return RRM_TRUE;
		}
	}
	/* Checking the eligibility of UE - end */

	RRM_UT_TRACE_EXIT();
	return RRM_FALSE;
}

/****************************************************************************
 * Function Name  : rrm_get_release_and_category_of_ue
 * Inputs         : p_ue_context
 *                : ue_category
 *                : access_stratum_release
 * Outputs        : Release and Category of the UE
 * Returns        : None
 * Description    : This function fills the ue_category and release of the UE
 ****************************************************************************/
	rrm_void_t
rrm_get_release_and_category_of_ue(
		rrm_ue_context_t    *p_ue_context,
		U8                  *ue_category,
		U8                  *access_stratum_release
		)
{
	RRM_UT_TRACE_ENTER();

	/* Storing Rel10 UE Category, if the Rel10 IE has come */
	if(p_ue_context->ue_capability_params.bitmask & 
			RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
	{
		*access_stratum_release =
			p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release;

		*ue_category = rrm_get_ue_category(p_ue_context); 
	}
	RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_check_for_ca_preconditions
 * Inputs         : p_ue_context
 *                : p_cell_context
 * Outputs        : None
 * Returns        : None
 * Description    : Checks for the preconditions of CA for the UE.
 ****************************************************************************/
	rrm_return_et
rrm_check_for_ca_preconditions(
		rrm_ue_context_t                *p_ue_context,
		rrm_cell_context_t              *p_cell_context
		)
{
	U8   ue_category = RRM_ZERO;    
	U8   access_stratum_release = RRM_OUT_OF_RANGE;
	U8                          scell_deactive_count= RRM_ZERO; 
	RrmMacUeReconfigReq         *p_mac_ue_reconfig_req = {RRM_ZERO};
	rrm_scell_active_deactive_t scell_active_deactive_list = {RRM_ZERO};
	rrm_ue_procedure_queue_t    proc_queue = {RRM_ZERO};
/*SPR 21479 Fix start*/
    rrm_ue_global_context_t   *p_ue_glb_ctxt = rrm_uem_get_ctxt(RRM_UEM_MODULE_ID);
/*SPR 21479 Fix end*/

	RRM_UT_TRACE_ENTER();

	rrm_get_release_and_category_of_ue(p_ue_context,
			&ue_category,
			&access_stratum_release);

	if(p_cell_context->operator_info.bitmask & RRMCM_RMIF_CA_CONFIG_INFO_PRESENT)
	{
		/* This Cell should be CA eligible for Carrier Aggregation*/
		if(RRM_TRUE == p_cell_context->operator_info.ca_config.is_ca_eligible)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"IS_CA_ELIGIBLE: %d", p_cell_context->operator_info.ca_config.is_ca_eligible);

			/*SPR22034 Changes Start*/
			/* The release of the UE should be equal or greater than rel10 for CA */
			if(RRM_REL10 <= access_stratum_release)
			/*SPR22034 Changes End*/
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"ACCESS_STRATUM_RELEASE: %d", access_stratum_release);

				/* The UE category should be one of 4,5 or 6,7,8 */
				if(ue_category >= RRM_FOUR && ue_category <= RRM_EIGHT)
                {
                        rrm_check_active_scell(&(p_ue_context->ue_scell_add_params),
                                &scell_active_deactive_list);
                        /*If anyone of the scell is in deactivated state. Activate the scell*/
                        if (RRM_ZERO != scell_active_deactive_list.scell_deactive_count)
                        {
                            if (RRM_ZERO == p_ue_context->ue_scell_add_params.scell_bkp_count)
                            {
                                rrm_ue_scell_state_backp(p_ue_context);
                                /*activate the deactivated cell*/
                                p_mac_ue_reconfig_req = (RrmMacUeReconfigReq *)rrm_mem_get(sizeof(RrmMacUeReconfigReq));
                                /* SPR 19838 : CID 10268 Fix Start */
                                if(RRM_PNULL != p_mac_ue_reconfig_req)
                                {	
                                    /* SPR 19838 : CID 10268 Fix End */
                                    RRM_MEMSET(p_mac_ue_reconfig_req ,RRM_ZERO, sizeof(RrmMacUeReconfigReq));
                                    p_mac_ue_reconfig_req->bitmask |= UE_CA_CONFIG_INFO_LIST_RECONFIG_BIT;
                                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE = RRM_ONE;
                                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
                                        ueScellSchedulingInfo[RRM_ZERO].ueIndex =  p_ue_context->ue_index;

                                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
                                        ueScellSchedulingInfo[RRM_ZERO].isMACCESendToUE = RRM_ONE;
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                                            "isMACCESendToUE[%d] numOfScellsSchedulingAllowed[%d]",
                                            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].isMACCESendToUE,
                                            scell_active_deactive_list.scell_deactive_count);
                                    for (scell_deactive_count = RRM_ZERO;scell_deactive_count<
                                            scell_active_deactive_list.scell_deactive_count;scell_deactive_count++)
                                    {
                                        p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
                                            ueScellSchedulingInfo[RRM_ZERO].schedulingActivateScell[scell_deactive_count]= 
                                            p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[
                                            scell_active_deactive_list.scell_deactive_index[scell_deactive_count]].scell_index;
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_BRIEF,
                                                "Scell Index[%d] is activated",
                                                p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].
                                                schedulingActivateScell[scell_deactive_count]);
                                        p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
                                            ueScellSchedulingInfo[RRM_ZERO].numOfScellsSchedulingAllowed++; 
                                        p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[
                                            scell_active_deactive_list.scell_deactive_index[scell_deactive_count]].scell_state = SCELL_ACTIVE;


                                    }
                                    if(MAC_UE_RECONF_NOT_ONGOING ==  rrm_get_mac_ue_reconfig_mutex 
                                            (p_ue_context->cell_index))
                                    {
                                        if( RRM_SUCCESS == rrm_send_mac_ue_reconfig_req(p_mac_ue_reconfig_req,
                                                    RRM_MODULE_ID,
                                                    RRM_ONE,
                                                    p_ue_context->cell_index))
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                                                    "Successfully sent RRM_MAC_UE_RECONFIG_REQ to  L2 for scell Activation");
                                            rrm_set_mac_ue_reconfig_mutex(p_ue_context->cell_index,
                                                    W_FOR_MAC_UE_RECONF_CNF_FOR_CA);
                                            RRM_MEM_FREE(p_mac_ue_reconfig_req);
                                        }
                                        /* SPR 19838 : CID 11346 Fix Start */
                                        else
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_ERROR,
                                                    "Failed to send RRM_MAC_UE_RECONFIG_REQ to L2 for scell Activation");
                                            RRM_MEM_FREE(p_mac_ue_reconfig_req);
                                        }
                                        /* SPR 19838 : CID 11346 Fix End */ 
                                    }
                                    else
                                    {
                                        proc_queue.api_id = RRM_MAC_UE_RECONFIG_REQ; 
                                        proc_queue.p_proc_data = (rrm_void_t *)p_mac_ue_reconfig_req; 
                                        rrm_ue_glb_enqueue_req(&proc_queue, p_ue_glb_ctxt); 
                                    }
                                    /* SPR 19838 : CID 10268 Fix Start */
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                            "Memory Allocation Failed for p_mac_ue_reconfig_req");
                                    RRM_UT_TRACE_EXIT();
                                    return RRM_FAILURE;
                                }
                                /* SPR 19838 : CID 10268 Fix End */
                            }
                            RRM_UT_TRACE_EXIT();
                            return RRM_SUCCESS;
                        }
                        else
                        {
                            rrm_enable_ca_for_the_ue(p_ue_context, p_cell_context);
                            RRM_UT_TRACE_EXIT();
                            return RRM_SUCCESS;
                        }
                }
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"UE_CATEGORY: %d", ue_category);
				}
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"ACCESS_STRATUM_RELEASE: %d, so no need to check CA pre-requisites",
						access_stratum_release);
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"CA_ELIGIBLE is OFF [%d] for cell_index[%d]",
					p_cell_context->operator_info.ca_config.is_ca_eligible,
					p_ue_context->cell_index);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"CA info is absent for cell_index[%d]",
				p_ue_context->cell_index);
	}
	RRM_UT_TRACE_EXIT();
	return RRM_FAILURE;
}
/* CA: SCell Selection end */

/****************************************************************************
 * Function Name  : rrm_handle_erb_setup_modify_procedure 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : handles erb_setup/erb_modify procedure .
 ****************************************************************************/
rrm_return_et
rrm_handle_erb_setup_modify_procedure( 
		rrm_ue_global_context_t *p_g_rrm_ue_ctx,
		rrm_ue_erab_setup_item_list_t   *p_erab_setup_item_success_list,
		rrm_ue_erab_failed_item_list_t  *p_erab_setup_item_failed_list,
		rrm_erab_procedure_et            rrm_erab_procedure
		)
{
	rrm_return_et		    ret_val = RRM_SUCCESS;
	rrm_ue_context_t                *p_ue_context = RRM_PNULL;
	U32				    index = RRM_NULL;
	rrm_ue_proc_erab_setup_data_t   *p_rrm_ue_proc_erab_setup_data = RRM_PNULL;
	rrm_ue_erab_setup_item_list_t   *p_erab_setup_item_list = RRM_PNULL;
	U8				    trans_id = p_g_rrm_ue_ctx->trans_id;
	U8                              success_count = RRM_ZERO;
	U8                              failure_count = RRM_ZERO;
    /*SPR 18241 START*/
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;
    /*SPR 18241 END*/

	U8                              gbr_configd_count = RRM_NULL;
	U8                              ngbr_configd_count = RRM_NULL;
	U8                              gbr_success_count = RRM_NULL;
	U8                              ngbr_success_count = RRM_NULL;
    /*SPR 18602 START*/
    /*code deleted*/
    /*SPR 18602 END*/
	/* FGI Feature Start */ 
	U32                             num_temp_um_mode = RRM_ZERO;
	U32                             num_temp_am_mode = RRM_ZERO;
	/* warnings removal: 'data_transfer_mode' shoould be of type U32 
	   according to prototype declaration of rrm_ue_rbc_erab_setup(),
	   10/05/2012 */
	U32	        		            data_transfer_mode = RRM_ZERO;
	/* FGI Feature End*/
	/* Fix for Coverity, CID:11190, [Prasant] */
   /*spr 17437 fix start*/
    /*Code Deleted */
	/*spr 19968 fix stop*/
	U8 new_qci = RRM_ZERO;
	U8 old_qci = RRM_ZERO;
	U8 erab_index = RRM_ZERO;

	U8 ngbr_bearer_count = RRM_ZERO;
    /*SPR 18654 START*/
    U64  out_dl_allocated_ngbr_prbs = RRM_ZERO;;
    U64 out_ul_allocated_ngbr_prbs = RRM_ZERO;;
    U32 out_dl_required_num_prbs = RRM_ZERO;;
    U32 out_ul_required_num_prbs = RRM_ZERO;;
    /*SPR 18654 END*/
	/* SPR 16853: start */
	rrm_bool_et				is_default_bearer = RRM_FALSE;
	rrm_bool_et				first_ngbr_found = RRM_FALSE;
	/* SPR 16853: end */
#ifdef ENDC_ENABLED
	rrm_bool_et             is_endc_ue_x2_up = RRM_FALSE;
	rrm_bool_et             is_resource_available = RRM_TRUE;
    U8                      data_transfer_mode_cnfgd = RRM_ZERO;
#endif
    /*spr 17437 fix start*/
    rrm_rab_removal_ctxt_t          local_rab_removal_ctxt;
    /*spr 17437 fix stop*/
    /* SPR 15834 Fix Start */
    rrm_ue_cause_t erb_setup_modify_fail_cause;
    erb_setup_modify_fail_cause.type  =  RADIO_NETWORK_LAYER_TYPE;
    /*SPR 22036 Fix Start*/
    erb_setup_modify_fail_cause.value =  RADIO_RESOURCES_NOT_AVAILABLE;
    /*SPR 22036 Fix Stop*/
    /* SPR 15834 Fix End */


	RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	/* SPS related changes start */
	rrm_cell_context_t       *p_cell_context = RRM_PNULL;
	p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	/* SPS related changes end */
	/*CID 65799:start*/
	if (RRM_PNULL == p_cell_context )
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	}
	/*CID 65799:end*/

	p_rrm_ue_proc_erab_setup_data = (rrm_ue_proc_erab_setup_data_t *)
		(p_ue_context->current_procedure.p_proc_data);
	p_erab_setup_item_list =  &p_rrm_ue_proc_erab_setup_data->erab_setup_list;
    /*SPR 18602 START*/
    p_ue_context->rrm_additional_bitrate_setup_mod = RRM_ZERO;
    p_ue_context->rrm_reduced_bitrate_setup_mod = RRM_ZERO;
    /*SPR 18602 END*/

    /*spr 17437 fix start */
    ylInit(&local_rab_removal_ctxt.rabs_to_rem_list);
    ylInit(&local_rab_removal_ctxt.rab_rem_container.ue_to_remove_list);
    ylInit(&local_rab_removal_ctxt.rab_rem_container.ue_rab_list);
    /*spr 17437 fix stop */

	switch ( rrm_erab_procedure )
	{
		case ERAB_SETUP:
			/* SPR 19968 +- */
            /*SPR 18602 START*/
            /*code deleted*/
            /*SPR 18602 END*/

			/** procedure change to ERAB setup ongoing */
			/*SPR 19968 +-*/

			/* SPS related changes start */


			if(p_ue_context->ue_capability_params.
					rrm_eutra_radio_capability_info.
					eutra_radio_capability_info_def.bitmask &
					RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"Checking for sps provision of UE_INDEX [%d]",
						p_ue_context->ue_index);

				/* SPR_13793_start */
				if(RRM_REL8 == p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
						eutra_radio_capability_info_def.access_stratum_release)
				{

					if ((RRM_FALSE != p_cell_context->sps_on) &&
							(rrm_is_set_fgi_bit(p_ue_context,RRM_THREE)) && 
							(rrm_is_set_fgi_bit(p_ue_context,RRM_SEVEN)))
					{
						if (RRM_FALSE == p_ue_context->ue_sps_data.is_sps_erab_established)
						{
							rrm_find_sps_erab_highest_priority (p_erab_setup_item_list, 
									p_ue_context, p_cell_context);
						}
					}
				}
				else
				{
					if ((RRM_FALSE != p_cell_context->sps_on) &&
							(rrm_is_set_fgi_bit(p_ue_context,RRM_TWENTY_NINE)) && 
							(rrm_is_set_fgi_bit(p_ue_context,RRM_SEVEN)))
					{
						if (RRM_FALSE == p_ue_context->ue_sps_data.is_sps_erab_established)
						{
							rrm_find_sps_erab_highest_priority (p_erab_setup_item_list, 
									p_ue_context, p_cell_context);
						}
					}
					/* SPR_13793_start */
				}
				/* SPR_13793_end */
			}
			/* SPS related changes end */

			/*SPR 15436 changes start*/

			rrm_quick_sort(p_erab_setup_item_list->erab_item,p_erab_setup_item_list->num_of_list, sizeof(rrm_ue_erab_setup_item_t),
					compare_by_priority);
			/*SPR 15436 changes end*/                                    

			for(index = RRM_NULL; index<p_erab_setup_item_list->num_of_list; 
					index++)
			{
				/*SPR 19968 Start*/
				rrm_find_gbr_ngbr_drb_configd(p_ue_context,&gbr_configd_count,
						&ngbr_configd_count);
				/*code deleted*/

            /*SPR 18602 START*/
            /*code deleted*/
            /*SPR 18602 END*/


				/*SPR 19968 End*/
            /*spr 17437 fix start*/
            rrm_reset_rab_removal_ctxt(&local_rab_removal_ctxt);
            /*spr 17437 fix stop*/

				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
						"[ERB setup] Bearer setup request with RABId[%u], QCI[%u], ARP[%u]",
						p_erab_setup_item_list->erab_item[index].erab_id,
						p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
						p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level);

				if(p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci >= RRM_NGBR_QCI_5 &&
						p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci <= RRM_NGBR_QCI_9)
				{
					ngbr_bearer_count++;
					/* SPR 16853: start */
					if((RRM_FALSE == first_ngbr_found) && (p_ue_context->drb_configured.num_of_list == RRM_ZERO))
					{
						/* SPR_17377_Warning_fix + */
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"[ERB setup] Default bearer setup request with RABId[%u], QCI[%u], ARP[%u]",
								p_erab_setup_item_list->erab_item[index].erab_id,
								p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
								p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level);
						/* SPR_17377_Warning_fix - */
						first_ngbr_found = RRM_TRUE;
						is_default_bearer = RRM_TRUE;
					}
					else
					{
						is_default_bearer = RRM_FALSE;
					}
					/* SPR 16853: end */
				}
				/*SPR 16944 START*/
				if (RRM_SUCCESS == rrm_check_if_qci_supported(p_cell_context,
							p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci))
                {
                    /*SPR 16944 END*/

#ifdef ENDC_ENABLED
                    /*NR_DC Code Change Start*/ 
                    if( RRM_TRUE == 
                        rrm_check_trigger_to_configure_nr_database(p_ue_context,\
                            TRIGGER_TYPE_QCI,p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci))
                    {
                        if( RRM_TRUE == 
                                check_ue_freq_ind_supported_by_default_sgnb(
/* NR_BAND_FIX_START */
                                    p_ue_context->nr_band_bitmap_fdd,
/* NR_BAND_FIX_END */
                                    p_ue_context->ue_index))
                        {
                            /* NR_REP_CONFIG_FIX_START */
                            if( RRM_SUCCESS == 
                                    rrm_check_is_configured_peer_gnb_pci_valid(\
                                        p_ue_context->cell_index))
                            {
                                is_endc_ue_x2_up = RRM_TRUE;
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "[ERB setup] Initiate SgNB Addition for QCI[%d] and ERAB ID[%d]",
                                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
                                        p_erab_setup_item_list->erab_item[index].erab_id);
                                p_erab_setup_item_success_list->erab_item[success_count].bitmask |=
                                    RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG;
                                /*update the drb_type*/
                                p_erab_setup_item_success_list->erab_item[success_count].drb_type =
                                    DRB_TYPE_SN_TERMINATED_SCG;
                                //TB_FIX
                                //rrm_get_endc_drb_type_on_qci(  p_erab_setup_item_list->erab_item[index].
                                //erab_level_qos_params.qci,p_ue_context->cell_index);

                                /* This is to indicate that send Sgnb params in Erb setup response itself */
                                p_ue_context->is_sgnb_param_reqd = RRM_TRUE;
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "[ERB setup] Can'tInitiate SgNB Addition for QCI[%d] and ERAB ID[%d]\n"
                                        "None of the peer gnb pCI is present in x2 link up indication\n",
                                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
                                        p_erab_setup_item_list->erab_item[index].erab_id);
                            }
                            /* NR_REP_CONFIG_FIX_END */
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "[ERB setup] Can'tInitiate SgNB Addition for QCI[%d] and ERAB ID[%d]\n"
                                    "Freq band indicator doesn't match with default sgnb\n",
                                    p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
                                    p_erab_setup_item_list->erab_item[index].erab_id);
                        }
                    }
                    /*NR_DC Code Change Stop*/ 

                    /*Reserve the resources, only when the drb_type is not SN_TERMINATED_SCG*/
                    if(DRB_TYPE_SN_TERMINATED_SCG != 
                            p_erab_setup_item_success_list->erab_item[success_count].drb_type)
                    {
#endif
                        /** Perform RBC */
                        ret_val = rrm_ue_rbc_erab_setup(
                                p_ue_context, 
                                /* SPR 19968 Start */
                                &p_erab_setup_item_list->erab_item[index],
                                p_rrm_ue_proc_erab_setup_data->ambr,
                                /* SPR 19968 End */
                                gbr_configd_count,ngbr_configd_count,
                                gbr_success_count,ngbr_success_count,
                                /*SPR 18602 START*/
                                /*code deleted*/
                                /*SPR 18602 END*/
                                /* FGI Feature Start */
                                &num_temp_um_mode,
                                &num_temp_am_mode,
                                &data_transfer_mode, /* FGI Feature End */
                                &out_dl_allocated_ngbr_prbs,
                                &out_ul_allocated_ngbr_prbs,
                                &out_dl_required_num_prbs,
                                &out_ul_required_num_prbs,	
                                /* SPR 16853: start */
                                is_default_bearer,
                                /*spr 17437 fix start*/
                                &local_rab_removal_ctxt
#ifdef ENDC_ENABLED 
								,is_endc_ue_x2_up
						        ,&is_resource_available

#endif
								);
                        /*spr 17437 fix stop*/
#ifdef ENDC_ENABLED
                    }
#endif
                    /* SPR 16853: end */
#ifdef ENDC_ENABLED
                    if ((ret_val == RRM_SUCCESS) || ((ret_val == RRM_FAILURE) && !is_resource_available && is_endc_ue_x2_up))
#else
                    if (ret_val == RRM_SUCCESS )
#endif
                    {
#ifdef ENDC_ENABLED
                    	if ((ret_val == RRM_FAILURE) && !is_resource_available && is_endc_ue_x2_up)
                    	{
                            /* NR_REP_CONFIG_FIX_START */
                            if( RRM_SUCCESS == 
                                    rrm_check_is_configured_peer_gnb_pci_valid(\
                                        p_ue_context->cell_index))
                            {
                        	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                	"Resources not availbale for UE_INDEX[%d], RBC unsuccessful for eRAB Id %d, QCI [%d] creating SGNB bearer",
                                	p_ue_context->ue_index,
                                	p_erab_setup_item_list->erab_item[index].erab_id,
                                	p_erab_setup_item_list->erab_item[index].
                                	erab_level_qos_params.qci);
                      		p_erab_setup_item_success_list->erab_item[success_count].bitmask |=
                          		RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG;
                      		/*update the drb_type*/
                      		p_erab_setup_item_success_list->erab_item[success_count].drb_type =
                            // rrm_get_endc_drb_type_on_qci(  p_erab_setup_item_list->erab_item[index].
                            // erab_level_qos_params.qci,p_ue_context->cell_index);
                          		DRB_TYPE_SN_TERMINATED_SCG;

                      		p_ue_context->is_sgnb_param_reqd = RRM_TRUE;
                      		is_resource_available = RRM_TRUE;
                    	}
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "[ERB setup] Can'tInitiate SgNB Addition for QCI[%d] and ERAB ID[%d]",
                                        "None of the peer gnb pCI is present in x2 link up indication\n",
                                        p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci,
                                        p_erab_setup_item_list->erab_item[index].erab_id);
                            }
/* NR_REP_CONFIG_FIX_END */
                 }
#endif
                        /*SPR 19819 30JUN START*/
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "UE_INDEX[%d], RBC successful for eRAB Id %d, QCI [%d]",
                                p_ue_context->ue_index,
                                p_erab_setup_item_list->erab_item[index].erab_id,
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.qci);
                        /*SPR 19819 30JUN END*/

                        /*spr 17437 fix start*/
                        rrm_fill_rab_removal_info_in_ue_ctxt(
                                p_ue_context,
                                &local_rab_removal_ctxt);
                        /*spr 17437 fix stop*/

                        /*SPR 16504 Fix Start */
                        p_erab_setup_item_success_list->erab_item[success_count].erab_id = RRM_ZERO;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.bitmask = RRM_ZERO;
                        /*SPR 16504 Fix Stop */

                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_id = 
                            p_erab_setup_item_list->erab_item[index].erab_id;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.bitmask =
                            p_erab_setup_item_list->erab_item[success_count].
                            erab_level_qos_params.bitmask;

                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.qci = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.qci;

#ifdef ENDC_ENABLED
                    	if(DRB_TYPE_SN_TERMINATED_SCG != 
                            	p_erab_setup_item_success_list->erab_item[success_count].drb_type)
                    	{
#endif
                        	/* FGI Feature Start */ 
                        	p_erab_setup_item_success_list->
                            	erab_item[success_count].data_transfer_mode= 
                            	data_transfer_mode;
                        	/* FGI Feature End */
#ifdef ENDC_ENABLED
                    	}
                        else
                        {
                            data_transfer_mode_cnfgd = rrm_get_data_transfer_mode_configd(
                                    p_erab_setup_item_success_list->erab_item[success_count].
                                    erab_level_qos_params.qci,
                                    p_ue_context->cell_index);

                            if ( UM_MODE == data_transfer_mode_cnfgd )
                            {
                                p_erab_setup_item_success_list->erab_item[success_count].
                                    data_transfer_mode = UM_MODE;
                            }
                            else if ( AM_MODE == data_transfer_mode_cnfgd )
                            {
                                p_erab_setup_item_success_list->erab_item[success_count].
                                    data_transfer_mode = AM_MODE;
                            }
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "data_transfer_mode_cnfgd [%d] for DRB_TYPE_SN_TERMINATED_SCG ",
                                    data_transfer_mode_cnfgd);
                        }
#endif
                        /*SPR 15436 changes start*/
                        if (p_erab_setup_item_list->erab_item[index].
                                /*SPR 15436 changes end*/
                                erab_level_qos_params.bitmask & ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT)
                        {
                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl = 
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl;

                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul = 
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul;

                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl = 
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;

                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul = 
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;
                        }
                        else
                        {
                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl = RRM_ZERO;
                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul = RRM_ZERO;
                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl = RRM_ZERO;
                            p_erab_setup_item_success_list->erab_item[success_count].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul = RRM_ZERO;
                        }
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "MBR:- DL[%llu] UL[%llu]  GBR:- DL[%llu] UL[%llu] ",
                                p_erab_setup_item_list->erab_item[index].   
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl,
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul,
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl,
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul);
                        /*SPR 16504 Fix Start */
                        p_erab_setup_item_success_list->erab_item[success_count].\
                            erab_level_qos_params.alloc_and_reten_prior.priority_level = RRM_ZERO;

                        p_erab_setup_item_success_list->erab_item[success_count].\
                            erab_level_qos_params.alloc_and_reten_prior.preemption_capability = RRM_ZERO;

                        p_erab_setup_item_success_list->erab_item[success_count].\
                            erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability = RRM_ZERO;

                        /*SPR 16504 Fix Stop */

                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.alloc_and_reten_prior.
                            priority_level = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.alloc_and_reten_prior.
                            priority_level;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.alloc_and_reten_prior.
                            preemption_capability = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.alloc_and_reten_prior.
                            preemption_capability;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.alloc_and_reten_prior.
                            preemption_vulnerability = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.alloc_and_reten_prior.
                            preemption_vulnerability;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            drb_id = 
                            p_erab_setup_item_list->erab_item[index].
                            drb_id;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            lc_id = 
                            p_erab_setup_item_list->erab_item[index].
                            lc_id;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            dl_fwding = 
                            p_erab_setup_item_list->erab_item[index].
                            dl_fwding;
                        /*SPR_18138_Fix_Start*/
                        p_erab_setup_item_success_list->erab_item[success_count].data_fwding_not_possible = p_erab_setup_item_list->erab_item[index].data_fwding_not_possible;
                        /*SPR_18138_Fix_End*/

                        /*SPR 15436 changes start*/
                        if (p_erab_setup_item_list->erab_item[index].bitmask &
                                /*SPR 15436 changes end*/
                                RRM_UEM_ERAB_TO_BE_SETUP_LIPA_RAB_IND_PRESENT_FLAG)
                        {
                            p_erab_setup_item_success_list->erab_item[success_count].
                                lipa_rab_ind = 
                                p_erab_setup_item_list->erab_item[index].lipa_rab_ind;

                            p_erab_setup_item_success_list->erab_item[success_count].
                                bitmask |= 
                                RRM_UEM_ERAB_TO_BE_SETUP_LIPA_RAB_IND_PRESENT_FLAG;
                        }  

                        if(p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.qci >= RRM_GBR_QCI_1 &&
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.qci <= RRM_GBR_QCI_4)
                        {
                            gbr_success_count++;
                        }
                        else if(p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.qci >= RRM_NGBR_QCI_5 &&
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.qci <= RRM_NGBR_QCI_9)
                        {
                            ngbr_success_count++; 
                        }

                        success_count++;
                    }
                    else
                    {
                        /*SPR 19819 30JUN START*/
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "UE_INDEX[%d], RBC failed for eRAB Id %d, QCI [%d]",
                                p_ue_context->ue_index,
                                p_erab_setup_item_list->erab_item[index].erab_id,
                                p_erab_setup_item_list->erab_item[index].
                                erab_level_qos_params.qci);
                        /*SPR 19819 30JUN END*/

                        p_erab_setup_item_failed_list->
                            erab_to_be_release_item[failure_count].erab_id = 
                            p_erab_setup_item_list->erab_item[index].erab_id;
                        p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                            cause.type = RADIO_NETWORK_LAYER_TYPE; /*radioNetworkLayer*/
                        /*SPR 16944 START*/
                        /*code deleted*/
                        /*SPR 16944 END*/
                        /*SPR 16944 START*/
                        p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                            cause.value = RADIO_RESOURCES_NOT_AVAILABLE;
                        /*SPR 16944 END*/

                        failure_count++;
                    }
                    /*SPR 16944 START*/
                }
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,"UE_INDEX[%d], RBC \
							failed for erab id %d ",
							p_ue_context->ue_index,
							p_erab_setup_item_list->erab_item[index].erab_id);
					p_erab_setup_item_failed_list->
						erab_to_be_release_item[failure_count].erab_id = 
						p_erab_setup_item_list->erab_item[index].erab_id;
					p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
						cause.type = RADIO_NETWORK_LAYER_TYPE; /*radioNetworkLayer*/

					p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].cause.value = NOT_SUPPORTED_QCI_VALUE; 
					failure_count++;
				}
				/*SPR 16944 END*/
			}
            /*spr 17437 fix start*/
            rrm_process_rab_removal_info_in_ue_ctxt(p_ue_context);
            /*spr 17437 fix stop*/
			/* SPS related changes start */
			p_ue_context->ue_sps_data.sps_erab_highest_arp_priority = RRM_ZERO;
			p_ue_context->ue_sps_data.sps_erab_highest_qci_priority = RRM_ZERO;
			/* SPS related changes end */
			/*Store allocated prbs for non-gbr bearers(required prb for ue-ambr)*/
			/* Start changes for SPR 490 */
			if((ngbr_bearer_count > RRM_ZERO) && 
					((RRM_ZERO != out_dl_required_num_prbs)||(RRM_ZERO != out_ul_required_num_prbs)))
			{
				rrm_cellm_set_dl_allocated_ngbr_prb(p_ue_context->cell_index, out_dl_allocated_ngbr_prbs
						+ out_dl_required_num_prbs);
				rrm_cellm_set_ul_allocated_ngbr_prb(p_ue_context->cell_index, out_ul_allocated_ngbr_prbs
						+ out_ul_required_num_prbs);
				/*Bug_776_changes_start*/
				rrm_cellm_increment_dl_allocated_ngbr_prb_per_ue(
						p_ue_context, out_dl_required_num_prbs);
				rrm_cellm_increment_ul_allocated_ngbr_prb_per_ue(
						p_ue_context, out_ul_required_num_prbs);
				/*Bug_776_changes_end*/
			}
			/* End changes for SPR 490 */
			/*end store*/

			p_erab_setup_item_success_list->num_of_list = success_count;		 
			p_erab_setup_item_failed_list->num_of_list = failure_count;
			rrm_ue_get_drb_id_lc_id(p_ue_context,
					p_erab_setup_item_success_list, ERAB_SETUP); /* Coverity: CID 19424 */
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"erb_success_list(%d), erb_failed_list(%d)",
					p_erab_setup_item_success_list->num_of_list, p_erab_setup_item_failed_list->num_of_list);
			p_ue_context->current_procedure.p_erb_success_list = 
				(void *)p_erab_setup_item_success_list;
			p_ue_context->current_procedure.p_erb_failed_list = 
				(void *)p_erab_setup_item_failed_list;
			/** Fill and send ERAB setup response */
			if((success_count == p_erab_setup_item_list->num_of_list)  
					&& (failure_count == RRM_ZERO ))
			{

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"UE_INDEX[%d], Sending ERB_SETUP_RESP with response SUCCESS",
						p_ue_context->ue_index);
				ret_val = rrm_build_and_send_erb_setup_resp ( RRM_UE_SUCCESS , 
						p_ue_context, trans_id);
				/*MAX_CID Changes Starts */
				if (RRM_FAILURE == ret_val)
				{
					p_ue_context->map_data_drb_rohc.count_drbs_cid_allocated--;
					p_ue_context->map_data_drb_rohc.total_drb_count--;
				}
				/*MAX_CID Changes Ends */

			}
			else if((success_count == RRM_ZERO) && 
					(failure_count == p_erab_setup_item_list->num_of_list))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"UE_INDEX[%d], Sending ERB_SETUP_RESP with response FAILURE",
						p_ue_context->ue_index);
				/* SPR 12686: Start */
				p_cell_context->kpi_stat.kpi.num_of_erb_setup_fail += 
					p_erab_setup_item_failed_list->num_of_list;
				/* SPR 12686: End */
				ret_val = rrm_build_and_send_erb_setup_resp ( RRM_UE_FAILURE , 
						p_ue_context, trans_id);
                /*SPR 18241 START*/
		/*SPR 20007 : CID 77082 Start*/
        /* Code Deleted */
		/*SPR 20007 : CID 77082 End*/
                p_ue_context->current_procedure.p_erb_success_list = RRM_PNULL;
                p_ue_context->current_procedure.p_erb_failed_list = RRM_PNULL;
                p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

                if ( (ret_val == RRM_SUCCESS) && (rrm_get_queue_count(&p_ue_context->procedure_queue)))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UE_INDEX[%d], dequeue queued message",
                            p_ue_context->ue_index);
                    /** Dequeue the events from event queue and call message handler */
                    /* SPR 15849 Start */
                    p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                    /* SPR 15849 End */
                    if(RRM_PNULL != p_rrm_ue_procedure_record)
                    {
                        /* CSR00069389 Start */
                        rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
                        /* CSR00069389 End */
                    }
                }


                /*SPR 18241 END*/

			}
			else if((success_count != RRM_ZERO) && (failure_count  != RRM_ZERO ))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"UE_INDEX[%d], Sending ERB_SETUP_RESP with response PARTIAL_SUCCESS",
						p_ue_context->ue_index); 
				/* SPR 12686: Start */
				p_cell_context->kpi_stat.kpi.num_of_erb_setup_fail += 
					p_erab_setup_item_failed_list->num_of_list;
				/* SPR 12686: End */
				ret_val = rrm_build_and_send_erb_setup_resp ( 
						RRM_UE_PARTIAL_SUCCESS , p_ue_context, trans_id);
			}
			else /**succes and failure list both are
			       zero i.e number of requested erb is zero*/
			{

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Number of requested rab is zero");
				ret_val = RRM_FAILURE;
			}
			/* SPR 15441 start */
			/* code removed */
			/* SPR 15441 end */
            /*SPR 18241 START*/
            /*code deleted*/
            /*SPR 18241 END*/
            /*spr 17437 fix start*/
            RRM_MEMSET(&p_ue_context->erab_to_be_released_item_list,RRM_ZERO,sizeof(rrm_ue_erab_to_be_released_item_list_t));
            rrm_reset_rab_removal_container(&p_ue_context->adm_ctrl_rec.rab_removal_container);
            /*spr 17437 fix stop*/          
			/* SPR 15462 Fix Code Deleted */
			break;
		case ERAB_MODIFY:
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"UE_INDEX[%d], performing RBC for total %d bearers ",p_ue_context->ue_index,
					p_erab_setup_item_list->num_of_list);


        /*spr 17437 fix start*/
            rrm_quick_sort(p_erab_setup_item_list->erab_item,p_erab_setup_item_list->num_of_list, sizeof(rrm_ue_erab_setup_item_t),
                    compare_by_priority);
        /*spr 17437 fix stop*/

			for(index = RRM_NULL; index<p_erab_setup_item_list->num_of_list; 
					index++)
            {
                /*spr 17437 fix start*/
                rrm_reset_rab_removal_ctxt(&local_rab_removal_ctxt);
                ret_val =  RRM_FAILURE;
                erb_setup_modify_fail_cause.type  =  RADIO_NETWORK_LAYER_TYPE;
                /*SPR 22036 Fix Start*/
                erb_setup_modify_fail_cause.value =  RADIO_RESOURCES_NOT_AVAILABLE;
                /*SPR 22036 Fix Stop*/

                for(erab_index = RRM_ZERO;erab_index<p_ue_context->drb_configured.num_of_list;erab_index++)
                {
                    if(p_erab_setup_item_list->erab_item[index].erab_id ==
                            p_ue_context->drb_configured.erab_item[erab_index].erab_id)
                    {
                        ret_val = RRM_SUCCESS;
                        break;
                    }
                }
                /*spr 17437 fix stop*/
                if((new_qci >= RRM_GBR_QCI_1 && new_qci <= RRM_GBR_QCI_4) && (old_qci >= RRM_NGBR_QCI_5 && old_qci <= RRM_NGBR_QCI_9))
                {
                    ret_val = rrm_ue_check_config_gbr_drbs(p_ue_context,
                            gbr_configd_count,gbr_success_count);
                }
                if((old_qci >= RRM_GBR_QCI_1 && old_qci <= RRM_GBR_QCI_4) && (new_qci >= RRM_NGBR_QCI_5 && new_qci <= RRM_NGBR_QCI_9))
                {
                    ret_val = rrm_ue_check_config_ngbr_drbs(p_ue_context,
                            ngbr_configd_count,ngbr_success_count); 
                }
                if(ret_val == RRM_SUCCESS)
                {
                    /*Perform RBC */
                    ret_val = rrm_ue_rbc_erab_modify(p_ue_context,  
                            p_erab_setup_item_list->erab_item[index],
                            p_rrm_ue_proc_erab_setup_data->ambr,
                            &out_dl_allocated_ngbr_prbs,
                            &out_ul_allocated_ngbr_prbs,
                            &out_dl_required_num_prbs,
                            &out_ul_required_num_prbs, 
                            /* SPR 15834 Fix Start */
                            &erb_setup_modify_fail_cause,
                            /*spr 17437 fix start*/
                            &local_rab_removal_ctxt);
                    /*spr 17437 fix stop*/

                    /* SPR 15834 Fix End */
                }
                /*spr 17437 fix start*/
                else
                {
                    erb_setup_modify_fail_cause.type  =  RADIO_NETWORK_LAYER_TYPE;
                    erb_setup_modify_fail_cause.value =  UNKNOWN_ERAB_ID;
                }
                /*spr 17437 fix stop*/


                if(ret_val == RRM_SUCCESS)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE_INDEX[%d], RBC successful for erab id %d ",
                            p_ue_context->ue_index,
                            p_erab_setup_item_list->erab_item[index].erab_id);
                    /*spr 17437 fix start*/
                    rrm_fill_rab_removal_info_in_ue_ctxt(
                            p_ue_context,
                            &local_rab_removal_ctxt);
                    /*spr 17437 fix stop*/

                    p_erab_setup_item_success_list->erab_item[success_count].
                        erab_id = 
                        p_erab_setup_item_list->erab_item[index].erab_id;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        erab_level_qos_params.bitmask =
                        p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.bitmask;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        erab_level_qos_params.qci = 
                        p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.qci;

                    if (p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.bitmask & ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT)
                    {
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_max_bit_rate_dl = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_max_bit_rate_ul = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.gbr_qos_info.
                            erab_max_bit_rate_ul;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_guar_bit_rate_dl = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.gbr_qos_info.
                            erab_guar_bit_rate_dl;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_guar_bit_rate_ul = 
                            p_erab_setup_item_list->erab_item[index].
                            erab_level_qos_params.gbr_qos_info.
                            erab_guar_bit_rate_ul;
                    }
                    else
                    {
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_max_bit_rate_dl = RRM_ZERO;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_max_bit_rate_ul = RRM_ZERO;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_guar_bit_rate_dl = RRM_ZERO;
                        p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.
                            erab_guar_bit_rate_ul = RRM_ZERO;
                    }
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Modify: MBR:- DL[%llu] UL[%llu]  GBR:- DL[%llu] UL[%llu] ",
                            p_erab_setup_item_success_list->erab_item[success_count].   
                            erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl,
                            p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul,
                            p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl,
                            p_erab_setup_item_success_list->erab_item[success_count].
                            erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul);

                    p_erab_setup_item_success_list->erab_item[success_count].
                        erab_level_qos_params.alloc_and_reten_prior.
                        priority_level = 
                        p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.alloc_and_reten_prior.
                        priority_level;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        erab_level_qos_params.alloc_and_reten_prior.
                        preemption_capability = 
                        p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.alloc_and_reten_prior.
                        preemption_capability;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        erab_level_qos_params.alloc_and_reten_prior.
                        preemption_vulnerability = 
                        p_erab_setup_item_list->erab_item[index].
                        erab_level_qos_params.alloc_and_reten_prior.
                        preemption_vulnerability;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        drb_id = 
                        p_erab_setup_item_list->erab_item[index].
                        drb_id;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        lc_id = 
                        p_erab_setup_item_list->erab_item[index].
                        lc_id;
                    p_erab_setup_item_success_list->erab_item[success_count].
                        dl_fwding = 
                        p_erab_setup_item_list->erab_item[index].
                        dl_fwding;
                    success_count++;
                    /*spr 17437 fix start*/
                    /*Code Deleted*/
                    /*spr 17437 fix stop*/

                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE_INDEX[%d], RBC failed for erab id %d ",
                            p_ue_context->ue_index,
                            p_erab_setup_item_list->erab_item[index].erab_id);

                    p_erab_setup_item_failed_list->
                        erab_to_be_release_item[failure_count].erab_id = 
                        p_erab_setup_item_list->erab_item[index].erab_id;
                    /* SPR 15834 Fix Start */
                    p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                        cause.type = erb_setup_modify_fail_cause.type;
                    p_erab_setup_item_failed_list->erab_to_be_release_item[failure_count].
                        cause.value = erb_setup_modify_fail_cause.value;
                    /* Reset the  erb_setup_modify_fail_cause variable */
                    /* SPR 15834 Fix End */
                    failure_count++;
                }
            }
            /*spr 17437 fix start*/
            rrm_process_rab_removal_info_in_ue_ctxt(p_ue_context);
            /*spr 17437 fix stop*/
            /*SPR 22036 Fix Start*/
            for(index = RRM_ZERO; ((index < p_ue_context->erab_to_be_released_item_list.num_of_list) && 
                        (index <RRM_UE_MAX_ERB_COUNT)); index++)
            {
                for(erab_index = RRM_ZERO; (erab_index < p_ue_context->drb_configured.num_of_list) &&
                        ( erab_index < RRM_MAX_NUM_DRB_PER_UE ); erab_index++)
                {
                    if(p_ue_context->erab_to_be_released_item_list.erab_to_be_release_item[index].erab_id == 
                            p_ue_context->drb_configured.erab_item[erab_index].erab_id)
                    {
                        if (erab_index == (p_ue_context->drb_configured.num_of_list - RRM_ONE))
                        {
                            RRM_MEMSET(&p_ue_context->drb_configured.erab_item[erab_index],
                                    RRM_ZERO,
                                    sizeof(rrm_ue_erab_setup_item_t));
                        }
                        else
                        {
                            if (erab_index < (p_ue_context->drb_configured.num_of_list - RRM_ONE))
                            {
                                RRM_MEMCPY(&p_ue_context->drb_configured.erab_item[erab_index],
                                        &p_ue_context->drb_configured.erab_item[p_ue_context->
                                        drb_configured.num_of_list - RRM_ONE], 
                                        sizeof(rrm_ue_erab_setup_item_t));
                                RRM_MEMSET(&p_ue_context->drb_configured.
                                        erab_item[p_ue_context->drb_configured.num_of_list - RRM_ONE],
                                        RRM_NULL ,sizeof(rrm_ue_erab_setup_item_t));
                            }
                        }
                        p_ue_context->drb_configured.num_of_list--;
                    }
                } 
            }
            /*SPR 22036 Fix Stop*/
			/*Store allocated prbs for non-gbr bearers(required prb for ue-ambr)*/
			/* Start changes for SPR 490 */
			if((RRM_ZERO != out_dl_required_num_prbs)||(RRM_ZERO != out_ul_required_num_prbs))
			{
				rrm_cellm_set_dl_allocated_ngbr_prb(p_ue_context->cell_index, out_dl_allocated_ngbr_prbs
						+ out_dl_required_num_prbs);
				rrm_cellm_set_ul_allocated_ngbr_prb(p_ue_context->cell_index, out_ul_allocated_ngbr_prbs
						+ out_ul_required_num_prbs);
				/*Bug_776_changes_start*/
				rrm_cellm_increment_dl_allocated_ngbr_prb_per_ue(
						p_ue_context, out_dl_required_num_prbs);
				rrm_cellm_increment_ul_allocated_ngbr_prb_per_ue(
						p_ue_context, out_ul_required_num_prbs);
				/*Bug_776_changes_end*/
			}
			/* End changes for SPR 490 */
			/*end store*/

			p_erab_setup_item_success_list->num_of_list = success_count;
			p_erab_setup_item_failed_list->num_of_list = failure_count;
			rrm_ue_map_modify_drb_id_lc_id(p_ue_context,
					p_erab_setup_item_success_list);
			p_ue_context->current_procedure.p_erb_success_list 
				= (void *)p_erab_setup_item_success_list;
			p_ue_context->current_procedure.p_erb_failed_list 
				= (void *)p_erab_setup_item_failed_list;
			p_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =  
				p_rrm_ue_proc_erab_setup_data->ambr.ue_agg_max_bit_rate_ul; 
			p_ue_context->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =  
				p_rrm_ue_proc_erab_setup_data->ambr.ue_agg_max_bit_rate_dl;
			/** Fill and send ERAB modify response */
			if((success_count == p_erab_setup_item_list->num_of_list))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						"UE_INDEX[%d], Sending ERB_MODIFY_RESP with response SUCCESS",
						p_ue_context->ue_index);
				ret_val = rrm_build_and_send_erb_modify_resp( 
						RRM_UE_SUCCESS , p_ue_context, trans_id);
			}
			else if(success_count == RRM_ZERO) 
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"UE_INDEX[%d], Sending ERB_MODIFY_RESP with response FAILURE",
						p_ue_context->ue_index); 
				ret_val = rrm_build_and_send_erb_modify_resp( 
						RRM_UE_FAILURE , p_ue_context, trans_id);
                /*SPR 18241 START*/
                p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
		/*SPR 20007 : CID 77082 Start*/
        /* Code Deleted */
		/*SPR 20007 : CID 77082 End*/
                p_ue_context->current_procedure.p_erb_success_list = RRM_PNULL;
                p_ue_context->current_procedure.p_erb_failed_list = RRM_PNULL;
                if ( (ret_val == RRM_SUCCESS) && (rrm_get_queue_count(&p_ue_context->procedure_queue)))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UE_INDEX[%d], dequeue queued message",
                            p_ue_context->ue_index);
                    /** Dequeue the events from event queue and call message handler */
                    /* SPR 15849 Start */
                    p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                    /* SPR 15849 End */
                    if(RRM_PNULL != p_rrm_ue_procedure_record)
                    {
                        /* CSR00069389 Start */
                        rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
                        /* CSR00069389 End */
                    }
                }
                /*SPR 18241 END*/

			}
			else if((success_count != RRM_ZERO) && (failure_count  != RRM_ZERO) )
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
						"UE_INDEX[%d], Sending ERB_MODIFY_RESP with response PARTIAL_FAILURE",
						p_ue_context->ue_index);
				ret_val = rrm_build_and_send_erb_modify_resp
					( RRM_UE_PARTIAL_SUCCESS , p_ue_context, trans_id);
			}
			else /**succes and failure list both are zero i.e number of 
			       requested erb is zero*/
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"UE_INDEX[%d], Number of requested rab is zero",p_ue_context->ue_index);
				ret_val = RRM_FAILURE;
			}
			/* SPR 15441 start */
			/* code removed */
			/* SPR 15441 end */
            /*SPR 18241 START*/
            /*CODE DELETED*/
            /*SPR 18241 END*/
            /*spr 17437 fix start*/
        RRM_MEMSET(&p_ue_context->erab_to_be_released_item_list,RRM_ZERO,sizeof(rrm_ue_erab_to_be_released_item_list_t));
        rrm_reset_rab_removal_container(&p_ue_context->adm_ctrl_rec.rab_removal_container);
        /*spr 17437 fix stop*/

			/** procedure change to ERAB modify ongoing */
			/* SPR 15462 Fix Code Deleted */
			break;
		default:
			rrm_ue_handle_log_and_ignore_event(p_g_rrm_ue_ctx);
			ret_val = RRM_FAILURE;
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* SPS related changes start */
/****************************************************************************
 * Function Name  : rrm_find_sps_erab_highest_priority
 * Inputs         : p_erab_setup_item_list
 *                : p_ue_context
 *                : p_cell_context
 * Outputs        : None
 * Description    : Finds the 'highest priority' for the RAB to be given SPS config
 ****************************************************************************/
	rrm_void_t
rrm_find_sps_erab_highest_priority (
		rrm_ue_erab_setup_item_list_t  *p_erab_setup_item_list,
		rrm_ue_context_t               *p_ue_context,
		rrm_cell_context_t             *p_cell_context
		)
{
	U8     index = RRM_ZERO;
	U8     qci_val = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	RRM_ASSERT(RRM_PNULL != p_ue_context);
	RRM_ASSERT(RRM_PNULL != p_cell_context);

	for (index = RRM_ZERO; index < p_erab_setup_item_list->num_of_list; index++)
	{
		qci_val = p_erab_setup_item_list->erab_item[index].erab_level_qos_params.qci;

		if ((p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].bitmask & RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT) &&  
				(p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].sps_config_enabled == RRM_TRUE))
			/* QCI is SPS enabled or not */      
		{/* SPR 18418 Fix Start */
            if ((RRM_ZERO == p_ue_context->ue_sps_data.sps_erab_highest_arp_priority) || 
                    ((p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level) < 
                     (p_ue_context->ue_sps_data.sps_erab_highest_arp_priority) )) /* SPR 18418 Fix Stop */

			{
				p_ue_context->ue_sps_data.sps_erab_highest_arp_priority = 
					p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level;

				p_ue_context->ue_sps_data.sps_erab_highest_qci_priority = 
					p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].priority;
			}

			else if ( (p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level) == 
					(p_ue_context->ue_sps_data.sps_erab_highest_arp_priority) )
			{
				 	/* SPR 18418 Fix Start */	
                if ((RRM_ZERO == p_ue_context->ue_sps_data.sps_erab_highest_qci_priority ) || 
		    ((p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].priority) <
                        (p_ue_context->ue_sps_data.sps_erab_highest_qci_priority) )) /* SPR 18418 Fix Stop */
				{
					p_ue_context->ue_sps_data.sps_erab_highest_qci_priority = 
						p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].priority;
				}
				else if( (p_cell_context->epc_info.epc_params.qos_config_params[(qci_val-RRM_ONE)].priority) ==
						(p_ue_context->ue_sps_data.sps_erab_highest_qci_priority) )
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"The SPS RAB[%d] has equal QCI priority",
							p_erab_setup_item_list->erab_item[index].erab_id);
				}
				else
				{   
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"The SPS RAB[%d] has lower QCI priority than the highest priority RAB",
							p_erab_setup_item_list->erab_item[index].erab_id);
				}
			}

			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"The SPS RAB[%d] has lower arp priority than the highest priority RAB",
						p_erab_setup_item_list->erab_item[index].erab_id);
			}
		}
	}

	RRM_UT_TRACE_EXIT();
}
/*SPR 18241 14JAN START*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_context_mod_in_ho_ongoing_state
 * Inputs         : rrm_ue_global_context_t *p_rrm_glb_ctxt
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the UE_CONTEXT_MOD_REQ from L3 in ho_ongoing_state
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_ue_context_mod_in_ho_ongoing_state(
        rrm_ue_global_context_t *p_rrm_glb_ctxt
        ) 
{
    rrm_return_et                     ret_val = RRM_SUCCESS;
    rrm_ue_context_t                 *p_ue_context = RRM_PNULL;
    U8                                trans_id = p_rrm_glb_ctxt->trans_id;

    RRM_UT_TRACE_ENTER();
    p_ue_context = p_rrm_glb_ctxt->p_ue_context;

    if(RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Context Pointer is NULL for RRC_RRM_UE_CONTEXT_MOD_REQ");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    else
    {
        /*SPR_18491_START*/
        if (p_ue_context->current_procedure.state == RRM_UE_SRC_HO_ONGOING)
        {    
        /*SPR_18491_END*/
            if(RRM_FAILURE == rrm_build_and_send_context_mod_resp(RRM_UE_FAILURE,
                        p_ue_context,
                        trans_id))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Failure Received during sending Context_mod_resp");
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        "Sending failure for UE context modification of UE [%d] as it is received in HO_ONGOING_STATE",
                        p_ue_context->ue_index);
            }
        /*SPR_18491_START*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "UE_INDEX[%d], Current procedure is TARGET_HO_ONGOING so, enqueue UE_CONETXT_MOD for the UE" ,
                    p_ue_context->ue_index);
            rrm_ue_queue_ue_ctxt_msg(p_rrm_glb_ctxt);
        }    
        /*SPR_18491_END*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 18241 14JAN END*/

/*SPR 18241 START*/
/****************************************************************************
 * Function Name  : rrm_ue_queue_ue_ctxt_msg
 * Inputs         : rrm_ue_global_context_t *p_rrm_glb_ctxt
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the UE_CONTEXT_MOD_REQ from L3
 ****************************************************************************/
rrm_return_et
rrm_ue_queue_ue_ctxt_msg(
                rrm_ue_global_context_t *p_rrm_glb_ctxt
                        )
{
    rrm_return_et                     ret_val = RRM_SUCCESS;
    rrm_ue_context_t                  *p_ue_context = RRM_PNULL;
    rrm_ue_procedure_queue_t           proc_queue;
    U8                                trans_id = p_rrm_glb_ctxt->trans_id;
    rrm_ue_context_mod_req_t          *p_ue_context_mod_req = RRM_PNULL; 
    RRM_UT_TRACE_ENTER();
    
    p_ue_context = p_rrm_glb_ctxt->p_ue_context;

    if(RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Context Pointer is NULL for RRC_RRM_UE_CONTEXT_MOD_REQ");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    else
    {
        p_ue_context_mod_req = (rrm_ue_context_mod_req_t *) p_ue_context->current_procedure.p_proc_data;

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "UE_INDEX[%d], Current procedure is not ERB NULL, enqueue message for the UE" ,
                p_ue_context->ue_index);
        if(p_ue_context_mod_req != RRM_PNULL)
        { 
            proc_queue.api_id = p_rrm_glb_ctxt->api_id;
            proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data;
            proc_queue.trans_id = trans_id;
            if(p_ue_context_mod_req->csf_indicator == RRM_CSFB_HIGH_PRIORITY)    
            {    
                /* As it is a high priority signalling wanted it to be processed immediately */
                rrm_ue_mgr_enqueue_req(&proc_queue,p_rrm_glb_ctxt->p_ue_context, RRM_TRUE);
            }
            else
            {
                rrm_ue_mgr_enqueue_req(&proc_queue,p_rrm_glb_ctxt->p_ue_context, RRM_FALSE);
            }    
        }
    }
     RRM_UT_TRACE_EXIT();
     return ret_val;
}
/*SPR 18241 END*/

/* SPS related changes end */
/****************************************************************************
 * Function Name  : rrm_ue_handle_context_mod_req
 * Inputs         : rrm_ue_global_context_t *p_g_rrm_ue_ctx
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the UE_CONTEXT_MOD_REQ from L3
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_context_mod_req(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		) 
{
	rrm_return_et                     ret_val = RRM_SUCCESS;
	rrm_ue_context_t                 *p_ue_context = RRM_PNULL;
	U8                                trans_id = p_g_rrm_ue_ctx->trans_id;
	rrm_ue_context_mod_req_t         *p_ue_context_mod_req = RRM_PNULL;
	/*csg start*/
	rrm_csg_membership_status_et      old_membership_status;
	/*csg end*/

	RRM_UT_TRACE_ENTER();
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	if(RRM_PNULL == p_ue_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Context Pointer is NULL for RRC_RRM_UE_CONTEXT_MOD_REQ");
		return RRM_FAILURE;
	}
	else
	{
        /*SPR 18241 START*/
        if (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL)
        {
            /*SPR 18241 END*/

		/*SPR-604 Fix Starts*/
        /* SPR 22553 FIXED START*/
		RRM_MEMCPY(&(p_ue_context->ue_context_mod_old_params),
				&(p_ue_context->ue_context_mod_req),
				sizeof(rrm_ue_ctxt_mod_info_t));
        /* SPR 22553 FIXED START*/

		/*SPR-604 Fix Ends*/

		p_ue_context_mod_req = (rrm_ue_context_mod_req_t *)p_ue_context->current_procedure.p_proc_data;

		if(p_ue_context_mod_req->bitmask & RRM_UEM_CTX_SPID_PRESENT)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"SPID present in context_mod_req");
			/* InterRAT changes start */
            /*SPR 22553 FIXED START */
            /*Code Remove */
			p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = p_ue_context_mod_req->spid;
            p_ue_context->rrm_sub_profile_id_info.bitmask |= RRM_UEM_CTX_TRANSE_PID_PRESENT;
			/* InterRAT changes end */
            /*SPR 22553 FIXED END */
		}
		if(p_ue_context_mod_req->bitmask & RRM_UEM_CTX_CSF_INDICATOR_PRESENT)
		{
			p_ue_context->ue_context_mod_req.csf_indicator = p_ue_context_mod_req->csf_indicator;
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"CSF_Indicator present in context_mod_req");
			p_ue_context->ue_context_mod_req.bitmask |= RRM_UEM_CTX_CSF_INDICATOR_PRESENT;
			/* InterRAT changes start */
			p_ue_context->ho_params.bitmask |= RRM_UE_CSFB_RECD;
			/* InterRAT changes end */
		}
		if(p_ue_context_mod_req->bitmask & RRM_UEM_CTX_REGISTERED_LAI_PRESENT)
		{
			RRM_MEMCPY(&(p_ue_context->ue_context_mod_req.registered_lai), 
					&(p_ue_context_mod_req->registered_lai), sizeof(rrm_uem_registered_lai_t));
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Registered_lai present in context_mod_req");
			p_ue_context->ue_context_mod_req.bitmask |= RRM_UEM_CTX_REGISTERED_LAI_PRESENT;    
		}

		if(RRM_FAILURE == rrm_build_and_send_context_mod_resp(RRM_UE_SUCCESS,
					p_ue_context,
					trans_id))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Failure Received during sending Context_mod_resp");
			ret_val = RRM_FAILURE;
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Successfully sent Context_mod_resp");
			p_ue_context->current_procedure.state =
				RRM_UE_CONTEXT_MOD_ONGOING;
			ret_val = RRM_SUCCESS;
		}

		/*csg start*/
		/*SPR-604 Fix Starts*/
		old_membership_status = p_ue_context->rrm_csg_membership.rrm_csg_membership_status;
		p_ue_context->ue_context_mod_old_params.csg_membership_status = old_membership_status;
		/*SPR-604 Fix Ends*/
		/* SPR 10079 Fix Start */
		if(p_ue_context_mod_req->bitmask & RRM_UEM_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT)
		{
			old_membership_status = p_ue_context->rrm_csg_membership.rrm_csg_membership_status;
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Updating CSG Membership status from %d to %d", old_membership_status,
					p_ue_context_mod_req->csg_membership_status);
			/* SPR 11719 Fix Start */
			p_ue_context->ue_context_mod_req.bitmask |= RRM_UEM_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT;
			/* SPR 11719 Fix End */
			p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
				p_ue_context_mod_req->csg_membership_status;
			rrm_adjust_csg_nsg_counter(old_membership_status,p_ue_context);

			if((RRM_MEMBER == old_membership_status) && 
					(RRM_NOT_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status))
			{
				if(RRM_SUCCESS == rrm_check_scell_csg_status_when_ue_mem_to_non_mem(p_ue_context))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"SCell released due to CSG incompatibility with UE");
				}
			}
		}
		/* SPR 10079 Fix Start */
		/*SPR-604 Fix Starts*/
		/*SPR-604 Fix Ends*/
		/*csg end*/
        /*SPR 18241 START*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "UE_INDEX[%d], Current procedure is not ERB NULL, enqueue message for the UE" ,
                    p_ue_context->ue_index);
            rrm_ue_queue_ue_ctxt_msg(p_g_rrm_ue_ctx);
        }
        /*SPR 18241 END*/

	}
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/*SPR-604 Fix Starts*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_context_mod_cnf
 * Inputs         : rrm_ue_global_context_t *p_g_rrm_ue_ctx
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the UE_CONTEXT_MOD_CNF from L3
 ****************************************************************************/
rrm_return_et
	rrm_ue_handle_context_mod_cnf
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
    rrm_return_et                ret_val               = RRM_SUCCESS;
    rrm_ue_context_t            *p_ue_context          = RRM_PNULL;
    rrm_ue_contxt_mod_cnf_t     *p_ue_contxt_mod_cnf   = RRM_PNULL;
    rrm_bool_et                  is_ue_released        = RRM_FALSE;
    rrm_csg_membership_status_et old_membership_status = RRM_INVALID;
    U8                           trans_id              = p_g_rrm_ue_ctx->trans_id;
    /* SPR 17916 Fix Start */
    rrm_ue_procedure_record_t       *p_rrm_ue_procedure_record = RRM_PNULL;
    /* SPR 17916 Fix Stop */

    /*SPR 18241 14JAN START*/
    rrm_ue_procedure_record_t       *p_temp = RRM_PNULL;
    /*SPR 18241 14JAN END*/
    RRM_UT_TRACE_ENTER();

    p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

    if(RRM_PNULL != p_ue_context)
    {
        /*cov fix start 63860*/
        /*cov fix end 63860*/
        /* SPR_12361_fix_start */
        p_ue_contxt_mod_cnf = (rrm_ue_contxt_mod_cnf_t *)p_ue_context->
            current_procedure.p_proc_data;
        /* SPR_12361_fix_end */


        if(p_ue_context->current_procedure.state == RRM_UE_CONTEXT_MOD_ONGOING)
        {
            /*SPR 18241 START*/
            p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
            /*SPR 18241 END*/

            if ((RRM_PNULL != p_ue_contxt_mod_cnf) &&
                    (RRM_SUCCESS == p_ue_contxt_mod_cnf->response))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Index[%d], Success response received for UE_CONTEXT_MOD_CNF",
                        p_ue_context->ue_index);
                
                /* SPR 22553 FIXED START */
                if(p_ue_context->rrm_sub_profile_id_info.bitmask & RRM_UEM_CTX_TRANSE_PID_PRESENT)
                {
                    p_ue_context->rrm_sub_profile_id_info.sub_profile_id = p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id;
                    p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = RRM_ZERO;
                    p_ue_context->rrm_sub_profile_id_info.bitmask &= ~RRM_UEM_CTX_TRANSE_PID_PRESENT;
                }
                /* SPR 22553 FIXED END */

                if(p_ue_context->ue_context_mod_req.bitmask & \
                        RRM_UEM_CTX_CSF_INDICATOR_PRESENT)
                {
                    ret_val = rrm_ue_handle_cs_fallback(p_g_rrm_ue_ctx,&is_ue_released);
                    /* SPR 22491 Fix Start */
                    if(RRM_TRUE == is_ue_released)
                    {
                        return ret_val;
                    }
                    /* SPR 22491 Fix End */
                }
                else if (p_ue_context->ue_context_mod_req.bitmask & RRM_UEM_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT)
                {
                    /* CSR_00084771_fix: Start */
                    /* SPR 16406 8SEP start */
                    p_ue_context->meas_rep_event = MEAS_REP_EVENT_A2;
                    /* SPR 16406 8SEP end */
                    /* CSR_00084771_fix: End */ 
                    /* SPR 15232 start */
                    p_ue_context->ho_params.a2_event_received = RRM_TRUE;
                    /* SPR 15232 end */
                    ret_val = rrm_handle_csg_membership(p_ue_context);

                    /*if csg validation fails check UE establishment cause*/
                    if((ret_val == RRM_FAILURE))
                    {
                        /*keep UE if estalishment cause is high priority*/
                        /* SPR 17564 Fix Start */
                        if (RRM_TRUE == rrm_is_ue_special_previledge (p_ue_context))
                            /* SPR 17564 Fix End */
                        {
                            ret_val = RRM_SUCCESS;
                            /* SPR 17564 Fix Start */
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Not releasing UE as UE is either emergeyncy or high priority");
                            /* SPR 17564 Fix End */
                        }
                    }
                    /*CA HARDENING CHANGES*/
                    /* SPR 13445 Fix Start */
                    p_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
                    /* SPR 13445 Fix End */ 

                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "Could not handover the ue, releasing the ue");

                        if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                                    p_ue_context->ue_index,
                                    RADIO_NETWORK_LAYER_TYPE,
                                    S1AP_INVALID_CSG_ID,
                                    trans_id,
                                    RRM_PNULL,
                                    /* SPR_10729_fix */
                                    p_ue_context->cell_index))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "ue connection release ind sent for UE index:%d",p_ue_context->ue_index);
                            ret_val = RRM_SUCCESS;
                            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                            {
                                RRM_TRACE(g_uem_log_on_off,
                                        p_g_rrm_uem_facility_name,
                                        RRM_DETAILED,
                                        "ue_connection_release_ind sent, \
                                        Failed to clean up ue resources");
                                ret_val = RRM_FAILURE;

                            }
                            /* SPR 22491 Fix Start */
                            return ret_val;
                            /* SPR 22491 Fix End */
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    "Failed to send release connection ind for UE index:%d",
                                    p_ue_context->ue_index);
                            ret_val = RRM_FAILURE;
                        }
                    }
                }

                /*SPR_12095_fix*/
                /* SPR 22491 Fix +- */
            }
            /* Roll-back the parameters upon failure */
            else
            {
                old_membership_status = p_ue_context->rrm_csg_membership.rrm_csg_membership_status;

                p_ue_context->rrm_csg_membership.rrm_csg_membership_status =
                    p_ue_context->ue_context_mod_old_params.csg_membership_status;

                /* SPR 22553 FIXED START*/
                RRM_MEMCPY(&p_ue_context->ue_context_mod_req, &p_ue_context->ue_context_mod_old_params,
						sizeof(rrm_ue_ctxt_mod_info_t));

                p_ue_context->rrm_sub_profile_id_info.trans_sub_profile_id = RRM_ZERO;
                p_ue_context->rrm_sub_profile_id_info.bitmask &= ~RRM_UEM_CTX_TRANSE_PID_PRESENT;

                /* SPR 22553 FIXED END*/
                if (RRM_UEM_CTX_CSF_INDICATOR_PRESENT & p_ue_context->ue_context_mod_req.bitmask)
                {
                    p_ue_context->ho_params.bitmask |= RRM_UE_CSFB_RECD;
                }
                else
                {
                    p_ue_context->ho_params.bitmask &= ~RRM_UE_CSFB_RECD;
                }
                rrm_adjust_csg_nsg_counter(old_membership_status,p_ue_context);
            }
            /* SPR 17916 Fix Start */
            /** Set the procedure for ERB setup request */
            /*SPR 18241 START*/
            /*code moved*/
            /*SPR 18241 END*/

        }
        else
        {
            /*SPR 18241 14JAN START*/
            p_ue_contxt_mod_cnf = (rrm_ue_contxt_mod_cnf_t *)p_ue_context->\
                                  current_procedure.p_proc_data;
            if ((RRM_PNULL != p_ue_contxt_mod_cnf) &&
                    (RRM_FAILURE == p_ue_contxt_mod_cnf->response))
            {
                p_rrm_ue_procedure_record =(rrm_ue_procedure_record_t *) ylFirst(&p_ue_context->procedure_queue); 
                while (RRM_PNULL != p_rrm_ue_procedure_record)
                {
                    p_temp =(rrm_ue_procedure_record_t *) ylNext(&p_rrm_ue_procedure_record->s_node);
                    if (RRC_RRM_UE_CONTEXT_MOD_REQ == p_rrm_ue_procedure_record->proc_queue.api_id)
                    {
                        ylDelete(&p_ue_context->procedure_queue, &p_rrm_ue_procedure_record->s_node);
                        RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
                        RRM_MEM_FREE(p_rrm_ue_procedure_record);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "UE[%d] Dropping RRM_UE_CONTEXT_MOD_REQ as another procedure started on lower layer",
                                p_ue_context->ue_index);
                    }
                    p_rrm_ue_procedure_record = p_temp;
                }               
            }
            /*SPR 18241 14JAN END*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "UE[%d] is not in RRM_UE_CONTEXT_MOD_ONGOING", p_ue_context->ue_index);
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL for UE_CONTEXT_MOD_CNF");
        ret_val = RRM_FAILURE;
    }
    /* SPR 17916 Fix Start */
    /*CID 97196 Start*/
    /** if queue not empty then dequeue the events */
    /* SPR 22491 Fix Start */
    /* p_ue_context is set inside p_g_rrm_ue_ctx. In case ue resource cleanup is happened, */
    /* p_g_rrm_ue_ctx->p_ue_context is set to NULL */
    if(p_g_rrm_ue_ctx->p_ue_context!=RRM_PNULL)
        /* SPR 22491 Fix End */
    {
        if (rrm_get_queue_count(&p_ue_context->procedure_queue))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], dequeue queued \
                    message",p_ue_context->ue_index);
            /** Dequeue the events from event queue and call message handler */
            p_rrm_ue_procedure_record = rrm_request_dequeue(p_ue_context);
            if(RRM_PNULL == p_rrm_ue_procedure_record)
            {
                ret_val = RRM_FAILURE;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            } 

            rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
        }
        /*CID 97196 End*/
        /*SPR 18241 START*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL for UE_CONTEXT_MOD_CNF");
        ret_val = RRM_FAILURE;
    }
    /*SPR 18241 END*/

    /* SPR 15441 start */
    /* code removed */
    /* SPR 15441 end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR-604 Fix Ends*/

/****************************************************************************
 * Function Name  : rrm_ue_log_and_ignore_event 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the Unexpected Events coming from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_log_and_ignore_event(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	RRM_UT_TRACE_ENTER();
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Recieved failure for the following state [%d] and \
			event [%d]",
			p_g_rrm_ue_ctx->p_ue_context->ue_state, 
			p_g_rrm_ue_ctx->p_ue_context->ue_event);
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 start */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_ue_print_drb_configured
 * Inputs         : rrm_ue_context_t UE context.
 * Outputs        : None
 * Returns        : None
 * Description    : Prints the QOS parameters.
 ****************************************************************************/
	void
rrm_ue_print_drb_configured(
		rrm_ue_context_t *p_ue_context
		)
{
	U8 	erab_index = RRM_NULL;   

	RRM_UT_TRACE_ENTER();

	if( RRM_PNULL != p_ue_context)
	{
		for( erab_index = RRM_ZERO; erab_index < p_ue_context->drb_configured.
				num_of_list; erab_index++)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Erab \
					ID at %d index is %d", erab_index, p_ue_context->
					drb_configured.erab_item[erab_index].erab_id);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Drb \
					ID at %d index is %d", erab_index, p_ue_context->
					drb_configured.erab_item[erab_index].drb_id);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"LC \
					ID at %d index is %d", erab_index, p_ue_context->
					drb_configured.erab_item[erab_index].lc_id);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"DL \
					forwarding at %d index is %d", erab_index, p_ue_context->
					drb_configured.erab_item[erab_index].dl_fwding);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"QCI \
					at %d index is %d", erab_index, p_ue_context->
					drb_configured.erab_item[erab_index].erab_level_qos_params.qci);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Priority at \
					%d index is %d", erab_index, p_ue_context->drb_configured.
					erab_item[erab_index].erab_level_qos_params.
					alloc_and_reten_prior.priority_level);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Capability \
					at %d index is %d", erab_index, p_ue_context->drb_configured.erab_item[erab_index].
					erab_level_qos_params.alloc_and_reten_prior.preemption_capability);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Vulnerability \
					at %d index is %d", erab_index, p_ue_context->drb_configured.erab_item[erab_index].
					erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"DL \
					MBR at %d index is %llu", erab_index, p_ue_context->drb_configured.erab_item[erab_index].
					erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_dl);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"UL \
					MBR at %d index is %llu", erab_index, p_ue_context->drb_configured.erab_item[erab_index].
					erab_level_qos_params.gbr_qos_info.erab_max_bit_rate_ul);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"DL \
					GBR at %d index is %llu", erab_index, p_ue_context->drb_configured.erab_item[erab_index].
					erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl);
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"UL \
					GBR at %d index is %llu", erab_index, p_ue_context->drb_configured.erab_item[erab_index].
					erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul);
		}
	}

	RRM_UT_TRACE_EXIT();
}
/* SPR 14302 start */
/****************************************************************************
 * Function Name  : rrm_uem_handle_ue_reconfig_failure_resp 
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Handles ue reconfig failure responce scenarion for victim  
 ****************************************************************************/
rrm_return_et
	rrm_uem_handle_ue_reconfig_failure_resp
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{

	RRM_UT_TRACE_ENTER();

	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_cell_context_t *p_cell_context = RRM_PNULL;
	victim_ue_node_t *p_victim_node = RRM_PNULL;
	victim_ue_node_t *p_temp_victim_node = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
	YLIST victim_ue_list;

	cell_index = p_g_rrm_ue_ctx->p_ue_context->cell_index;
	p_cell_context = rrm_cellm_get_cell_context(cell_index); 
	if(RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
				RRM_WARNING," invalid cell context[NULL] found ");
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	}

	victim_ue_list = p_g_rrm_ue_ctx->victim_ue_info.
		rrm_victim_ue_on_cell[cell_index].victim_ue_list;
	p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);       
	p_temp_victim_node = p_victim_node;

	while(p_temp_victim_node)
	{
		/* SPR 14659 start */
		/* SPR 14610 start */
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(p_temp_victim_node->victim_ue_node_data.ue_index,
				cell_index); 
		/* SPR 14610 end */

        if(p_ue_context)
		{
			/* SPR_14046_START */
        /*SPR 22464 Fix Start*/
			if((RRM_TRUE == rrm_is_set_fgi_bit(p_g_rrm_ue_ctx->p_ue_context, RRM_HUNDRED_FIFTEEN)) && 
                    (RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
					 eutra_radio_capability_info_def.access_stratum_release ) &&
					(p_g_rrm_ue_ctx->p_ue_context->ue_index == p_temp_victim_node->victim_ue_node_data.ue_index))
        /*SPR 22464 Fix Stop*/
				/* SPR_14046_END */
			{
				p_temp_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node); 
				ylDelete(&victim_ue_list, (YLNODE *)p_victim_node);
				RRM_MEM_FREE(p_victim_node);
                p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;      
                /* SPR 20652 Fix End */
				p_victim_node = p_temp_victim_node;
			}
			else
			{
				p_temp_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node);
				p_victim_node = p_temp_victim_node;
			}
		} 
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                    "[UE:%d] context not found", p_temp_victim_node->victim_ue_node_data.ue_index);
        }
		/* SPR 14659 end */
	}

	if(RRM_TRUE == p_g_rrm_ue_ctx->p_ue_context->rrm_eicic_meas_event_ongoing)
	{
		if(RRM_SUCCESS == rrm_uem_send_remove_meas_config_for_victim(p_g_rrm_ue_ctx->p_ue_context))
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
					"Successfully sent remove meas id request for victim ue[%d]",
					p_g_rrm_ue_ctx->p_ue_context->ue_index);
		}
		p_g_rrm_ue_ctx->p_ue_context->rrm_eicic_meas_event_ongoing = RRM_FALSE;
	}

	/* SPR 14659 start */
	p_g_rrm_ue_ctx->victim_ue_info.
		rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
	/* SPR 14659 end */
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;	
}

/* SPR 14302 end*/
/****************************************************************************
 * Function Name  : rrm_uem_handle_ue_reconfig_success_resp 
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Handles ue reconfig success responce scenarion for victim  
 ****************************************************************************/
rrm_return_et
	rrm_uem_handle_ue_reconfig_success_resp
(
 rrm_ue_context_t *p_ue_context
 )
{

	if(RRM_TRUE == p_ue_context->rrm_eicic_meas_event_ongoing)
	{
		if(RRM_SUCCESS == rrm_uem_send_remove_meas_config_for_victim(p_ue_context))
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
					"Successfully sent remove meas id request for victim ue[%d]",
					p_ue_context->ue_index);
		}
		p_ue_context->rrm_eicic_meas_event_ongoing = RRM_FALSE;
	}

	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;	
}
/****************************************************************************
 * Function Name  : rrm_uem_send_remove_meas_config_for_victim 
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : remove meas triggerred for victim ue  
 ****************************************************************************/
rrm_return_et
	rrm_uem_send_remove_meas_config_for_victim
(
 rrm_ue_context_t *p_ue_context
 )
{

	RRM_UT_TRACE_ENTER();

	rrm_return_et ret_val = RRM_FAILURE;
	U16 transaction_id = rrm_generate_txn_id();

	rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRM_PNULL;
	p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t *) rrm_mem_get (sizeof(rrc_rrm_meas_config_req_t));
	if(RRM_PNULL != p_rrc_rrm_meas_config_req)
	{


		p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;

		p_rrc_rrm_meas_config_req->meas_config.bitmask = RRM_ZERO;
		p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;


		p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count = RRM_ONE; 
		p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[RRM_ZERO] = 
			p_ue_context->rrm_ue_eicic_info.meas_report_id; 

		if(p_rrc_rrm_meas_config_req->meas_config.bitmask)
		{
			ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
					RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);

			if(ret_val == RRM_FAILURE)
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
						"Failed to send MEAS CONFIG REQUEST for UE_INDEX[%d]",
						p_ue_context->ue_index);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"Successfully sent MEAS CONFIG REQUEST for UE_INDEX[%d]",
						p_ue_context->ue_index);
				p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;/*RRM_MEAS Changes */
				p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING;
			}


		}
	}

	/* cov 69667 fix */
	RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
	RRM_UT_TRACE_EXIT();
	return ret_val;	
}


/* BUG_11907_FIX_START */
/****************************************************************************
 * Function Name  : rrm_check_ue_reconfig_count_for_cell_del 
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : None
 * Description    : Calculates UE Reconfig count for scell delete scenario.
 ****************************************************************************/
rrm_return_et
rrm_check_ue_reconfig_count_for_cell_del(
		/*SPR 13316:start*/
		rrm_ue_global_context_t     *p_g_rrm_ue_ctx
		/*SPR 13316:end*/
		)
{
	rrm_ue_context_t            *p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	YLIST                   *p_scell_user_list = RRM_PNULL;
	rrm_return_et           ret_val = RRM_SUCCESS;
	RRM_UT_TRACE_ENTER();

	if( p_ue_context != RRM_PNULL)
	{

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Pcell: %d Scell: %d UE_Index: %d",
				p_ue_context->cell_index,
				p_ue_context->ue_scell_add_params.scell_cell_index,
				p_ue_context->ue_index);

		p_scell_user_list = rrm_get_scell_list_of_cell( p_ue_context->cell_index ,
				p_ue_context->ue_scell_add_params.scell_cell_index );
		/*Cov_fix_start_65035*/
		if(RRM_PNULL != p_scell_user_list)
		{
			if (!(ylCount(p_scell_user_list)))
			{
				rrm_send_cell_info_change_ind_resp(p_ue_context->cell_index,
						p_ue_context->ue_scell_add_params.scell_cell_index,
						/*SPR 13316:start*/
						RRM_SUCCESS, p_g_rrm_ue_ctx->trans_id ); 
				/*SPR 13316:end*/
			}
		}
		else
		{
			ret_val = RRM_FAILURE;
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"Scell list received is NULL !!");
		}
		/*Cov_fix_end_65035*/
	}
	else
	{
		ret_val = RRM_FAILURE;
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"UE context received NULL!!");
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* BUG_11907_FIX_END */


/*LTE_RRM_TM_SWITCH_START*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_reconfig_resp_event
 * Inputs         : rrm_ue_global_context_t global context.
 * Outputs        : None
 * Returns        : None
 * Description    : fsm method 
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_reconfig_resp_event(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et		 ret_val = RRM_SUCCESS;
	rrm_ue_context_t            *p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	rrm_ue_reconfig_response_t  *p_proc_data = RRM_PNULL;
	U16                          current_procedure =
		p_ue_context->current_procedure.state;
	rrm_ue_procedure_record_t    *p_rrm_ue_procedure_record = RRM_PNULL;
	/*CA HARDENING CHANGES 6.3.0 */
	rrm_bool_et  is_cgi_config_pending = RRM_FALSE;
	/*SPR 15663 start*/
	U8 sr_row_num = RRM_ZERO;   
	U16 sr_col_num = RRM_ZERO;
	/*SPR 15663 end*/
	/*Location update fix in UE RECONFIG*/
	rrm_return_et        ret_val_loc_update = RRM_SUCCESS;
	rrm_location_update_action_et  ue_location_update_action = INVALID_REASON;
	rrm_ue_index_t                 ue_index_list[MAX_NUM_OF_UE]  = {RRM_ZERO};
	U32                            ue_update_count                = RRM_ZERO;
	rrm_cell_index_t               cell_index = RRM_OUT_OF_RANGE;               /*!< Cell index for UE context      */
	rrm_bool_et                  trigger_mac_loc_update_req_aftr_ue_reconfig = RRM_FALSE;
	rrm_cell_context_t   *p_cell_ctx = RRM_PNULL;
	/*Location update fix in UE RECONFIG*/
	/* Fix for CSR 58972 start*/
	U16                                      transaction_id = RRM_ZERO;
	/* Fix for CSR 58972 end*/

    /*SPR 21464 Changes Start*/
    /*code removed*/
    /*SPR 21464 Changes End*/

	/* SPR 8315 FIX START*/
	mac_ue_reconfig_sequence_node_t *p_curr_mac_ue_reconf_seq_data_node = RRM_PNULL;
	/* BUG_11907_FIX_START */
	rrm_bool_et          scell_deletion_flag = RRM_TRUE;
	/* BUG_11907_FIX_END */
	/* BUG_12745_FIX_START */
	rrc_rrm_ue_connection_release_ind_t *p_ue_connection_release_ind = RRM_PNULL;
	/* BUG_12745_FIX_END */
	p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	RRM_UT_TRACE_ENTER();
    /*SPR 20137 Start*/
    if (RRM_TRUE == p_ue_context->ue_sync_status_ind)
    {
        p_ue_context->ue_sync_status_ind = RRM_FALSE;
    }
    /*SPR 20137 Stop*/

	/*CID 65887:start*/
	if (RRM_PNULL != p_cell_ctx)
	{
        /*SPR 21464 Changes Stairt*/
        /*Code for memory allocation of p_curr_mac_ue_reconf_seq_data_node has
         * been moved from here, to the place where are are pushing the node*/
        /*SPR 21464 Changes End*/
		
		/* SPR 8315 FIX END*/
		/* SPR 15698 Start */
		/* set the UE's sub state to RRM_UE_ERB_NULL*/
		/* SPR 15763 START */
        /*SPR_21462_FIX_START*/
		if((RRM_UE_RECONFIG_ONGOING == p_ue_context->current_procedure.state) ||
            (RRM_UE_SCELL_PROCEDURE_ONGOING == p_ue_context->current_procedure.state)) 
		{
			p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
		}
        /*SPR_21462_FIX_END*/
		/* SPR 15763 END */
		/* SPR 15698 End */
		p_proc_data = (rrm_ue_reconfig_response_t *)
			p_ue_context->current_procedure.p_proc_data;

		switch( current_procedure ) 
		{
			case RRM_UE_RECONFIG_ONGOING:
				{
					if( RRM_ZERO == p_proc_data->response )
					{
#ifdef LTE_EMBMS_SUPPORTED
                        if(RRM_TRUE == p_ue_context->ue_mbms_data.mbms_reconfig_triggered)
                        {
                          /*
                          ** In case of Failure , trigger UE reconfigure Request
                          ** and Turn DRX and CQI off For this UE
                          */
                          if(RRM_ONE  == p_ue_context->ue_mbms_data.mbms_reconfig_count )
                          {
                              rrm_uem_mbms_reconfig_cqi_drx_off_req(p_ue_context);
                          }
                          else
                          {
                              RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                                        "Second attempt for UE reconfiguration failed.Kepp UE"
                                          "with released CQI and DRX ");
                              p_ue_context->ue_mbms_data.mbms_reconfig_triggered = RRM_FALSE;
                              p_ue_context->ue_mbms_data.mbms_reconfig_count = RRM_ZERO;
                              p_ue_context->ue_mbms_data.reconfig_bitmask = RRM_ZERO;
                          }
                        }
                        else
                        {
#endif

						/* SPR_16053_Fix: Start */
						/* For UE Reconfig Resp, Fail causes are mapped as per rrc_erab_error_codes_t */
						if((p_proc_data->fail_cause == RRC_REESTABLISHMENT_TRIGGERED) ||
								(p_proc_data->fail_cause == RRC_RADIO_LINK_FAILURE_TRIGGERED))
						{
							p_ue_context->current_procedure.state = RRM_UE_REESTABLISH_PROCEDURE_ONGOING;
						}
						/* SPR_16053_Fix: End */

						if( RRM_UE_RECONFIG_PHY_ANTENNA_CONFIG_ROLLBACK_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask) )
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,reset the TM mode for UE[%d]" \
									,p_ue_context->ue_index);

							rrm_rollback_ue_antenna_info( p_ue_context );

							/* rrm_ue_handle_reconfig_resp_for_tm_switch_event( p_ue_context );*/
						}
						if( RRM_UE_RECONFIG_PHY_ANTENNA_INFO_V920_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask) )
						{

							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,reset the TM mode for UE[%d]" \
									,p_ue_context->ue_index);

							rrm_rollback_ue_antenna_info_v920( p_ue_context ); 

						}
						if( RRM_UE_RECONFIG_PHY_ANTENNA_INFO_R10_ROLLBACK_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask) )
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,reset the TM mode for UE[%d]" \
									,p_ue_context->ue_index);

							rrm_rollback_ue_antenna_info_r10( p_ue_context );
						}
						if( RRM_UE_RECONFIG_PHY_CQI_REPORTING_ROLLBACK_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask))
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,reset the CQI info for UE[%d]" \
									,p_ue_context->ue_index);

							rrm_rollback_ue_cqi_information( p_ue_context );
						}
						if( RRM_UE_RECONFIG_PHY_CQI_REPORTING_R10_ROLLBACK_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask))
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,reset the CQI info for UE[%d]" \
									,p_ue_context->ue_index);

							rrm_rollback_ue_cqi_information_r10( p_ue_context );
						}

						/* SRS_FREQ_HOPPING_START */
						/* SPR_8391_CHANGES_START*/
						if( RRM_UE_RECONFIG_PHY_SOUNDING_RS_UL_CONFIG_ROLLBACK_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask))
						{
							if(RRM_TRUE == rrm_cellm_get_srs_status(p_ue_context->cell_index))
							{
								if((p_ue_context->srs_params.srs_anchor) != (p_ue_context->srs_params_last_used.srs_anchor))
								{
									rrm_ue_handle_reconfig_resp_for_srs_hopping_status_changed_event( p_ue_context );
								}
							}
						}
						/* SPR_8391_CHANGES_END*/
						/* SRS_FREQ_HOPPING_END */
						/*DYNAMIC ICIC START*/
						/*
						 ** If UE reconfigure is failed , rollback the Dynamic ICIC data maintained in
						 ** UE's context.
						 */
						if(p_ue_context->dynamic_icic_info.ue_reconfig_rollback_flag == RRM_TRUE)
						{
							rrm_rollback_ue_dynamic_icic_data( p_ue_context );
						}
						/*DYNAMIC ICIC END*/
						if((RRM_UE_RECONFIG_PHY_TPC_PDCCH_CONFIG_PUSCH_ROLLBACK_PRESENT &
									(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask)) ||
								( RRM_UE_RECONFIG_PHY_TPC_PDCCH_CONFIG_PUCCH_ROLLBACK_PRESENT &
								  (p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask)))
						{
							rrm_handle_ue_reconfig_resp_fail(p_ue_context);
						}

						/* SPR 10450 Fix Start */
						if( RRM_UE_RECONFIG_PHY_DRX_CONFIG_ROLLBACK_PRESENT &&
								p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask )
						{
							/* SPR 16053 start */
							/* Code deleted */
							/* SPR 16053 end */

							rrm_handle_ue_reconfig_response_for_drx( p_ue_context,
									p_proc_data->response);
						}
						/* SPR 10450 Fix End */

						/* SPR_16061_Fix: Start */
						if (RRM_UE_CDRX_TO_BE_APPLIED == p_ue_context->cdrx_status)
						{
							p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
							/* SPR 16053 start */
							/* SPR 16406 8SEP start */
							/* Code removed */
							/* SPR 16406 8SEP end */
							/* SPR 21 Aug End */
							p_ue_context->is_cgi_process_in_progress = RRM_FALSE;
							/* SPR 16053 end */

						}
						/* SPR_16061_Fix: End */

						if(RRM_TRUE == p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing)
							/* SPR14165end */
						{
							/* SPR 14471 start */
							if(RRM_UE_RECONFIG_FOR_VICTIM == p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag)
								/* SPR 14471 end */
							{
								rrm_uem_handle_ue_reconfig_failure_resp(p_g_rrm_ue_ctx);
							}
							else
							{
								RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
										"Received RRC UE RECONFIG CNF failure for eICIC for making UE non victim ...");
							}
							/* SPR14165start */
							p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing= RRM_FALSE;
                                                        /* SPR 21496 Fix Start */ 
							/* SPR14165end */
							/* SPR 14286 start */
							p_ue_context->p_ue_mac_report->eicic_report_count = RRM_ZERO;
							/* SPR 14286 end */
                                                        /* SPR 21496 Fix End */ 
						}
						/* SPR 14302 end*/
#ifdef LTE_EMBMS_SUPPORTED
                    }
#endif

						/* bug_13913_start */
						/* bug_13913_start */
					}
					else
					{
#ifdef LTE_EMBMS_SUPPORTED
                        if(RRM_TRUE == p_ue_context->ue_mbms_data.mbms_reconfig_triggered) 
                        {
                            rrm_uem_handle_mbms_reconfig_resp(p_ue_context);
                            p_ue_context->ue_mbms_data.mbms_reconfig_triggered = RRM_FALSE;
                            p_ue_context->ue_mbms_data.mbms_reconfig_count = RRM_ZERO;
                            p_ue_context->ue_mbms_data.reconfig_bitmask = RRM_ZERO;
                        }
                        else
                        {
#endif

                                          /* SPR 21496 Fix Start */ 
						p_ue_context->p_ue_mac_report->report_count = RRM_ZERO;
                                                /* SPR 21496 Fix End */ 

						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
								"UE[%d] Reconfig Response is Success" ,p_ue_context->ue_index);
						/*DYNAMIC ICIC START*/
						/*
						 ** If UE reconfigure is successful ,update the Dynamic ICIC data maintained in
						 ** UE's context.
						 */
						/* bug_13913_start */
						/* SPR14165start */
						if(RRM_TRUE == p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing)
							/* SPR14165end */
						{
							/* SPR 14471 start */
							if(RRM_UE_RECONFIG_FOR_VICTIM == p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag)
							{
								rrm_uem_handle_ue_reconfig_success_resp(p_ue_context);
								/* SPR 14285 start */
								p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_VICTIM_STATE;  
							}
							else
							{
								RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
										"Received RRC UE RECONFIG CNF success for eICIC for making UE non victim ...");

							}
							/* SPR 14286 start */
                                                        /* SPR 21496 Fix Start */ 
							p_ue_context->p_ue_mac_report->eicic_report_count = RRM_ZERO;
                                                        /* SPR 21496 Fix End */ 
							/* SPR 14286 end */
							/* SPR 14471 end */
							/* SPR 14285 end */
							/* SPR14165start */
							p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing= RRM_FALSE;
							/* SPR14165end */
							/*SPR 15663 start*/
							if(p_ue_context->temp_sr_config.sr_params_bitmask & RRM_UE_RECONFIG_SR_PARAMS_PRESENT)
							{
								rrm_ue_rac_release_sr_res_index(p_ue_context);
								/*SPR 15713 Fix Start*/
								/*SPR 15713 Fix End*/
								p_ue_context->sr_params.sr_pucch_res_index = p_ue_context->temp_sr_config.sr_pucch_res_index;
								p_ue_context->sr_params.sr_configuration_index = p_ue_context->temp_sr_config.sr_configuration_index;
								sr_row_num = p_ue_context->temp_sr_config.sr_res_row;
								sr_col_num = p_ue_context->temp_sr_config.sr_res_col;
								p_ue_context->sr_params.sr_res_row = sr_row_num;
								p_ue_context->sr_params.sr_res_col = sr_col_num;

								rrm_cell_mark_sr_index_busy(p_ue_context->cell_index,sr_row_num,sr_col_num,RRM_FALSE);

								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
										"sr_res_index(%d), sr_config_index(%d), sr_row_num(%d), sr_col_num(%d)",
										p_ue_context->sr_params.sr_pucch_res_index,p_ue_context->temp_sr_config.sr_configuration_index,\
										sr_row_num, sr_col_num);
							}    
							p_ue_context->temp_sr_config.sr_params_bitmask = RRM_ZERO;
							RRM_MEMSET(&(p_ue_context->temp_sr_config),RRM_ZERO,sizeof(rrm_ue_temp_sr_config_data_t));
							/*SPR 15663 end*/
						}
						/* bug_13913_start */

						if(p_ue_context->dynamic_icic_info.ue_reconfig_rollback_flag == RRM_TRUE)
						{
							/*Location update fix in UE RECONFIG*/
							/*SPR 7892 FIX START*/
							rrm_commit_ue_dynamic_icic_data( p_ue_context);

							if(RRM_TRUE == p_ue_context->dynamic_icic_info.location_update_req_for_ue_reconfig)
							{
								trigger_mac_loc_update_req_aftr_ue_reconfig = RRM_TRUE;
								if( RRM_UE_POSITION_AT_CELL_CENTER == 
										p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)
								{
									ue_location_update_action = UE_LOCATION_UPDATE_CE_TO_CC ;
								}
								else
								{
									ue_location_update_action = UE_LOCATION_UPDATE_CC_TO_CE ;
								}
							}
							/* SPR 8315 FIX START*/
							else
							{
								RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
										"Loc Update is not required for UE[%d] ,after sending UE reconfig "
										"to RRC", p_ue_context->ue_index);
							}
							/* SPR 8315 FIX END*/
							/*SPR 7892 FIX END*/
							/*Location update fix in UE RECONFIG*/
						}
						/*DYNAMIC ICIC END*/
						/* SRS_FREQ_HOPPING_START */
						/* SPR_8391_CHANGES_START*/
						if( RRM_UE_RECONFIG_PHY_SOUNDING_RS_UL_CONFIG_ROLLBACK_PRESENT &
								(p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask))
						{
							if(RRM_TRUE == rrm_cellm_get_srs_status(p_ue_context->cell_index))
							{
								if((p_ue_context->srs_params.srs_anchor) != (p_ue_context->srs_params_last_used.srs_anchor))
								{
									rrm_ue_handle_reconfig_resp_for_srs_hopping_status_changed_event( p_ue_context );
								}
							}
						}
						/* SPR_8391_CHANGES_END*/
						/* SRS_FREQ_HOPPING_END */

						/* Fix for CSR: 00059124 */
						/* SPR 12973 Start */
						if (RRM_UE_CDRX_TO_BE_APPLIED == p_ue_context->cdrx_status)
						{
							/* Free DRX resources */
							if(NO_DRX_PROFILE != p_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index)
							{
								rrm_ue_rac_clear_drx_res( p_ue_context->cell_index,
										p_ue_context->applied_drx_config.
										curr_applied_drx_config.applied_drx_profile_index,
										p_ue_context->applied_drx_config.
										curr_applied_drx_config.applied_drx_offset_val
										);
							}


							/* Fix for CSR 58972 start*/
							p_ue_context->cdrx_status = RRM_UE_CDRX_APPLIED;

							/* SPR-13322-fix start */
							if (INVALID_PHYSICAL_CELL_ID == p_ue_context->pci_for_which_cgi_required)
							{
								/* SPR 16787: start */
								RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
										"CDRX Applied for CGI reporting for ANR ");
								/* SPR 16787: end */
							}
							else
							{
								/* SPR_14564_fix: start */
								RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
										"RAT type for which CGI required %d ", p_ue_context->rrm_cgi_triggered_for_rat_type);
								/* SPR_14564_fix: end */
								/*15026_start*/
								if ((p_ue_context->is_cgi_process_in_progress == RRM_TRUE) && 
										(RRM_SUCCESS == rrm_build_and_send_meas_config_req_for_cgi(
																	   p_ue_context,
																	   /*SPR 17777 +-*/
																	   /* SPR_14564_fix: start */
																	   p_ue_context->rrm_cgi_triggered_for_rat_type)))
									/* SPR_14564_fix: end */
									/*15026_end*/   
								{
									RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,
											RRM_DETAILED,
											"Meas config sent to RRC");
									/* SPR 16787: start */
									/* Code removed */
									/* SPR 16787: end */
								}
								else
								{
									/* SPR 16787: start */
									/*Coverity 94764 Fix Start*/
									if (p_ue_context->is_cgi_process_in_progress == RRM_TRUE)
										/*Coverity 94764 Fix End*/
									{
										if (RRM_CGI_REP_CAUSE_MAX != p_ue_context->cgi_reporting_triggered_for_meas_event)
										{
											RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
													RRM_ERROR,
													"Resetting the flag to RRM_CGI_REP_CAUSE_MAX as CGI cannot be initiated");
											p_ue_context->cgi_reporting_triggered_for_meas_event = RRM_CGI_REP_CAUSE_MAX;

											/* Remove DRX as CGIs have been reported */
											p_g_rrm_ue_ctx->p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_REMOVED;

											if (RRM_FAILURE == (ret_val = rrm_build_and_send_ue_reconfig_req(p_g_rrm_ue_ctx->p_ue_context)))
											{
												RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
														"Failed to send UE reconfig request to remove CDRX, UE index[%d]",
														p_g_rrm_ue_ctx->p_ue_context->ue_index);
											}
											else
											{
												RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
														"UE reconfig request sent to UE index[%d] to remove CDRX ",
														p_g_rrm_ue_ctx->p_ue_context->ue_index);
											}
										}
									}
									/* SPR 16787: end */
									/* SPR 16787: start */
									else
									{
										/* SPR 16787: end */
										RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,
												RRM_DETAILED,
												"Meas config request not sent to RRC");

										transaction_id = rrm_generate_txn_id();
										/* SPR 15674 Start */
										/* SPR 16406 8SEP start */
										/* SPR 16406 18sep Start  */
										phy_cell_id_info_t phy_cell_id_info = 
										{RRM_ZERO, p_ue_context->pci_for_which_cgi_required, 
											p_ue_context->cgi_trigerred_for_earfcn, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
										/* SPR 16406 18sep End */
										/* SPR 16406 8SEP end */
										if (RRM_SUCCESS ==  rrm_build_and_send_ho_required(
													phy_cell_id_info,
													p_ue_context,
													transaction_id))
										{
											/* SPR 16406 8SEP start */
											/* Code removed */
											/* SPR 16406 8SEP end */
											/* SPR 15674 End */

											RRM_TRACE(g_cellm_log_on_off,
													p_rrm_cellm_facility_name, 
													RRM_DETAILED, 
													"Build & send HO Required UE:SUCCESS");
										}
										else
										{
											RRM_TRACE(g_cellm_log_on_off,
													p_rrm_cellm_facility_name, 
													RRM_WARNING, 
													"Build & send HO Required UE:FAILED");
										}

										/*SPR 15509 +-*/
										/* SPR-13322-fix end */
										/* SPR 12973 Delete */
										/* SPR 16787: start */
									}
									/* SPR 16787: end */
								}
							}
							/* Fix for CSR 58972 end*/
						}
						/* SPR 12973 End */
						/* SPR 12480 Start */
						/* reset the CDRX configuration status */
						else if (RRM_UE_CDRX_TO_BE_REMOVED == p_ue_context->cdrx_status)
						{
							/* SPR 16042 Start */   
							/* SPR 15860 Start */
							/* SPR 15861 Start */
							/* SPR 15862 Start */
							/* SPR 15843 Start */
							/// We don't need to send the meas config removal request explicitly if corresponding 
							/// object has already been deleted
							is_cgi_config_pending = rrm_uem_check_is_cgi_config_pending(p_g_rrm_ue_ctx->p_ue_context);
							if(RRM_TRUE == is_cgi_config_pending)
							{
								/// Check if NO CGI request pending with the same reconfig_id in procedure_queue
								is_cgi_config_pending = rrm_uem_check_cgi_report_pending_in_proc_queue(p_g_rrm_ue_ctx->p_ue_context);
								if(RRM_FALSE == is_cgi_config_pending)
								{

									/* SPR_15538_Fix: Start */
									/* If UE reconfig was sent for CDRX removal then RRM will send the meas config req. to UE for removal 
									   of report config id & meas id for the CGI process. */
									/* SPR 16406 8SEP start */
									p_ue_context->meas_rep_event = MEAS_REP_EVENT_FOR_CGI;
									ret_val = rrm_build_and_send_meas_config_req(p_ue_context,MEAS_TYPE_HO);
									p_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
									/* SPR 16406 8SEP end */
								}
								else
								{
									RRM_TRACE(g_cellm_log_on_off,
											p_rrm_cellm_facility_name,
											RRM_DETAILED,
											"CGI Reports Pending with same configuration");
								}
							}
							/* SPR 15843 End */
							/* SPR 15860 End */
							/* SPR 15861 End */
							/* SPR 15862 End */
							/* SPR_15538_Fix: End */

							/* SPR 15509 start */
							p_ue_context->is_cgi_process_in_progress = RRM_FALSE;
							/* SPR 15509 end */
							p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
							/* SPR 16042 End */
						}
						/* SPR 12480 End */
						/* Fix for CSR: 00059124 */
						else if( RRM_UE_RECONFIG_PHY_DRX_CONFIG_ROLLBACK_PRESENT &&
								p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask )
							/* SPR 10450 Fix Start */
						{
							rrm_handle_ue_reconfig_response_for_drx( p_ue_context,
									p_proc_data->response);
						}
						/* SPR 10450 Fix End */
#ifdef LTE_EMBMS_SUPPORTED
                   }
#endif

					}
					break;
				}
			case RRM_UE_SCELL_PROCEDURE_ONGOING:
				{
					if( RRM_ZERO == p_proc_data->response )
					{
						/* SPR_16053_Fix: Start */
						/* For UE Reconfig Resp, Fail causes are mapped as per rrc_erab_error_codes_t */
						if((p_proc_data->fail_cause == RRC_REESTABLISHMENT_TRIGGERED) ||
								(p_proc_data->fail_cause == RRC_RADIO_LINK_FAILURE_TRIGGERED))
						{
							p_ue_context->current_procedure.state = RRM_UE_REESTABLISH_PROCEDURE_ONGOING;
						}
						/* SPR_16053_Fix: End */

						/* CA Changes : Start */
						if(RRM_SCELL_INDEX_BACKUP_PRESENT & p_ue_context->ue_scell_add_params.bitmask )
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,rollback the scell info for UE[%d] as SCell addition failed" \
									,p_ue_context->ue_index);

							rrm_rollback_ue_scell_info_add_fail(p_ue_context);
                            /*SPR_21462_FIX_START*/
                            p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
                            /*SPR_21462_FIX_END*/
						}
						if(RRM_SCELL_RADIO_RESOURCE_CONFIG_COMMON_PARAM_CHANGE & p_ue_context->ue_scell_add_params.bitmask)
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, \
									"Failure Response for UE Reconfig,rollback the scell info for UE[%d] as SCell deletion failed" \
									,p_ue_context->ue_index);

							/* Delete UE context from the list of UE contexts which were served by the Scell.
							   As in the case of Radio Resource Config commom param change UE was already added to the list 
							   at the time of Scell addition, and now if UE reconfig for deletion failed then we need to 
							   remove UE context from the list. */  
							rrm_scell_del_success(p_ue_context);
							/* reset the params set in case of RADIO_RESOURCE_CONFIG_COMMON_PARAM_CHANGE */
						}
						if(RRM_SCELL_DELETE_SCENARIO & p_ue_context->ue_scell_add_params.bitmask)
						{
							/* BUG_12745_FIX_START */
							scell_deletion_flag = RRM_FALSE;
							/* BUG_12745_FIX_END */
						}
						/* CA Changes : End */
					}
					else
					{
						/*CA STAGE 2*/
						if((p_ue_context->is_num_of_ca_ue_incremented) == RRM_ZERO)
						{
							(p_cell_ctx->kpi_stat.kpi.num_of_ca_ue)++;
							(p_ue_context->is_num_of_ca_ue_incremented)++;
						}
						/*CA STAGE 2*/
						if(RRM_SCELL_INDEX_BACKUP_PRESENT & p_ue_context->ue_scell_add_params.bitmask )
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Success Response for UE Reconfig,add scell info for UE[%d] to Scell UE list in Cell Context" \
									,p_ue_context->ue_index);

							rrm_scell_add_success(p_ue_context);
						}
						if(RRM_SCELL_DELETE_SCENARIO & p_ue_context->ue_scell_add_params.bitmask)
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
									"Success Response for UE Reconfig,delete scell info of UE[%d] from Scell UE list in Cell Context" \
									,p_ue_context->ue_index);

							/* Note: Do not decrement Scell count in this function, it is being decremented in rrm_rrc_ue_intf.c file
							   at the time of sending Scell delete to RRC in function rrm_remove_scell_data_from_ue_context */

							/* BUG_11907_FIX_START */
							scell_deletion_flag = RRM_TRUE;
							/* BUG_11907_FIX_END */
						}
						/* CA Changes : End */
						/*CA Stage3 start*/
						if((p_cell_ctx->operator_info.ca_config.bitmask & RRM_IS_MASA_INFO_PRESENT) && 
								(RRM_TRUE == p_cell_ctx->operator_info.ca_config.is_masa) &&
								!(RRM_SCELL_DELETE_SCENARIO & p_ue_context->ue_scell_add_params.bitmask))
						{
							rrm_scell_check_add_meas_config_req(p_ue_context);
						}
						/*CA Stage3 end*/
					}
				}
				break;
			default :
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING, \
							"UE index[%d] Fsm could not process the UE Reconfig Response due to invalid sub \
							state[%d]" ,p_ue_context->ue_index,current_procedure);
				}

		}


		/* SPR 15763 START */
		/* Code removed*/
		/* SPR 15763 END */

		/* SPR 15698 Start */
		/* SPR 15763 START */
		/* Code Deleted */
		/* SPR 15763 END */
		/* SPR 15698 End */

		/* SPR 15763 START */
		/* Code removed*/
		/* SPR 15763 END */

		/* SPR 15698 Start */
		/* Code Removed */
		/* SPR 15698 End */

		/*reset the bitmask when reconfig response related action is done*/ 
		p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = RRM_ZERO;


		/* SPR 15698 Start */
		/// Shouldn't process procedure queue if meas_config_req sent to remove the meas id

		if ((p_ue_context->current_procedure.state == RRM_UE_ERB_NULL) && 
				(rrm_get_queue_count(&p_ue_context->procedure_queue)))
		{
			/** if queue not empty then dequeue the events */
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"UE_INDEX[%d], dequeue queued message",
					p_ue_context->ue_index);
			/** Dequeue the events from event queue and call message handler */
			/* SPR 15849 Start */
			p_rrm_ue_procedure_record = rrm_request_dequeue(p_ue_context);
			/* SPR 15849 End */
			if(RRM_PNULL != p_rrm_ue_procedure_record)
			{
				/* CSR00069389 Start */
				rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
				/* CSR00069389 End */
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "p_ue_context->current_procedure.state = %u", p_ue_context->current_procedure.state);
		}

		/* SPR 15698 End */
		/*Location update fix in UE RECONFIG*/
		if(RRM_TRUE == trigger_mac_loc_update_req_aftr_ue_reconfig )
		{
			/*SPR 7892 FIX START*/
			if( MAC_UE_RECONF_NOT_ONGOING  == rrm_get_mac_ue_reconfig_mutex( p_ue_context->cell_index))
				/*SPR 7892 FIX END*/
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
						"Trigger MAC LOC UPDATE request...for ICIC");
				cell_index = p_ue_context->cell_index;
				ue_index_list[0] = p_ue_context->ue_index;
				ue_update_count = 1;

				ret_val_loc_update = build_and_send_l2_ue_reconfig_req(cell_index,ue_index_list, ue_update_count, ue_location_update_action);
				if(RRM_SUCCESS == ret_val_loc_update)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
							"Successfully send UE reconfig req to MAC for location update after"
							"P_A is reconfigured");
					/* +- Coverity 65887 */
					p_cell_ctx->dynamic_icic_data.mac_loc_update_triggrd_aftr_ue_reconfig = RRM_TRUE;
					/*SPR 7892 FIX START*/
					rrm_set_mac_ue_reconfig_mutex(cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_ICIC);
					/*SPR 7892 FIX END*/
                    
                    /*SPR 21464 Changes Start*/
                    p_curr_mac_ue_reconf_seq_data_node = (mac_ue_reconfig_sequence_node_t *)rrm_mem_get(sizeof(mac_ue_reconfig_sequence_node_t));
                    if (p_curr_mac_ue_reconf_seq_data_node == RRM_PNULL)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                "Memory allocation to p_curr_mac_ue_reconf_seq_data_node failed" );
                        RRM_UT_TRACE_EXIT();
                        return RRM_FAILURE;
                    }
                    /*SPR 21464 Changes End*/
					
					/* SPR 8315 FIX START*/
					p_curr_mac_ue_reconf_seq_data_node->mac_ue_reconf_seq_node_data.p_ue_context = p_ue_context;

					ylPushTail(&(p_g_rrm_ue_ctx->mac_ue_reconfig_sequence_list),
							(YLNODE *)p_curr_mac_ue_reconf_seq_data_node);
                    
                    /*SPR 21464 Changes Start*/
                    /*code removed*/
                    /*SPR 21464 Changes End*/

					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
							"UE context for UE [%d] is pushed at tail of List",
							p_ue_context->ue_index);
					RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
							"MAC UE RECONFIG SEQ UE LIST is having [%d] UEs",p_g_rrm_ue_ctx->mac_ue_reconfig_sequence_list.count);
					/* SPR 8315 FIX END*/

				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
							"UNABLE to  send UE reconfig req to MAC for location update after"
							"P_A is reconfigured");
					/* SPR 8351 FIX2 START */
					rrm_rollback_ue_dynamic_icic_data( p_ue_context );
					/* SPR 8351 FIX2 END */
				}
			}
			/*SPR 7892 FIX START*/
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
						"MAC UE reconfig is already ongoing for this cell index[%d]",p_ue_context->cell_index);

				rrm_rollback_ue_dynamic_icic_data( p_ue_context );
			}
			/*SPR 7892 FIX END*/
		}
		/* SPR 8315 FIX START*/
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
					"Loc Update is not required for UE[%d] ,after sending UE reconfig "
					"to RRC", p_ue_context->ue_index);
            /*SPR 21464 Changes Start*/
			/* code removed*/ 
            /*SPR 21464 Changes End*/
		}/*Location update fix in UE RECONFIG*/
		/* SPR 8315 FIX END*/

		/* BUG_12745_FIX_START */
		/* BUG_11907_FIX_START */

		if(RRM_SCELL_DELETE_SCENARIO & p_ue_context->ue_scell_add_params.bitmask)
		{
			rrm_scell_del_success(p_ue_context);
			/*SPR 13316:start*/
			rrm_check_ue_reconfig_count_for_cell_del(p_g_rrm_ue_ctx);
			/*SPR 13316:end*/
			p_ue_context->ue_scell_add_params.scell_cell_index = RRM_OUT_OF_RANGE;
			/* Scell count value decrement removed */
			p_ue_context->ue_scell_add_params.bitmask = RRM_ZERO;

			if(scell_deletion_flag == RRM_FALSE)
			{
				p_ue_connection_release_ind = (rrc_rrm_ue_connection_release_ind_t*)rrm_mem_get(sizeof(rrc_rrm_ue_connection_release_ind_t));
				/*CID 65798:start*/
				if (RRM_PNULL == p_ue_connection_release_ind)
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_ue_connection_release_ind is null");
					RRM_UT_TRACE_EXIT();
					return RRM_FAILURE;
				}
				/*CID 65798:end*/
				RRM_MEMSET(p_ue_connection_release_ind, RRM_OUT_OF_RANGE, sizeof(rrc_rrm_ue_connection_release_ind_t));

				p_ue_connection_release_ind->bitmask = RRM_ZERO;
				p_ue_connection_release_ind->ue_index = p_ue_context->ue_index;
				p_ue_connection_release_ind->release_cause.type = RADIO_NETWORK_LAYER_TYPE; 
				p_ue_connection_release_ind->release_cause.value = RELEASE_DUE_TO_EUTRAN_GENERATED_REASON;
				transaction_id = rrm_generate_txn_id();
				ret_val = rrm_il_send_rrc_rrm_ue_connection_release_ind(
						p_ue_connection_release_ind,
						RRM_MODULE_ID,
						RRC_MODULE_ID,
						transaction_id,p_ue_context->cell_index);

				if (RRM_SUCCESS == ret_val)
				{
					if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
					{
						RRM_TRACE(g_uem_log_on_off,
								p_g_rrm_uem_facility_name,
								RRM_DETAILED,
								"ue_connection_release_ind sent, \
								Failed to clean up ue resources");
						ret_val = RRM_FAILURE;
					}
					else
					{
						RRM_TRACE(g_uem_log_on_off,
								p_g_rrm_uem_facility_name,
								RRM_DETAILED,
								"successfully cleaned up resources for the ue %d",
								p_ue_context->ue_index);
					}
				}
				RRM_MEM_FREE(p_ue_connection_release_ind);
			}
		}

		/* BUG_12745_FIX_END */
		/* BUG_11907_FIX_END */
		/* SPR 15441 start */
		/* code removed */
		/* SPR 15441 end */

	}
    /* SPR 19754 fix start */
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	}
    /* SPR 19754 fix end */

	/*SPR 15994 Fix start*/
	
	/*SPR 21464 Chnages Start*/
	/*code removed*/
	/*SPR 21464 Chnages End*/

    /* SPR 19754 fix start */
	/* Code Removed */
    /* SPR 19754 fix end */
	/*CID 65887:end*/

	RRM_UT_TRACE_EXIT();
    	/* Coveriy 107427 Fix Start */
	/*SPR 21464 Chnages Start*/
	/*code removed*/
	/*SPR 21464 Chnages End*/
   	/* Coveriy 107427 Fix Start */
	return ret_val;
}

/* Start changes for LA feature */
/******************************************************************************
 *   FUNCTION NAME: rrm_determine_ue_speed_category
 *   DESCRIPTION:
 *       This function determines the UE speed category on the basis of SINR/PL
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
	rrm_return_et
rrm_determine_ue_speed_category(
		rrm_ue_context_t *p_ue_context)
{
	U16         report_index = RRM_ZERO;
	U32         decision_factor = RRM_ZERO;
	U32         decision_factor_next = RRM_ZERO;
	U32         delta_value = RRM_ZERO;
	U32         delta_value_total = RRM_ZERO;
	U32         avg_total_delta_value = RRM_ZERO;
	U8          positive_delta_count = RRM_ZERO;
	U8          negative_delta_count = RRM_ZERO;
	U8          total_count = RRM_ZERO;
	/* Coverity_ID : 54435 */
	rrm_return_et         ret_val = RRM_FAILURE; /* Coverity: CID 41584 Rel2.1.3 */

	rrm_ue_speed_category_data_t *p_speed_category_data = RRM_NULL;
	rrm_cell_context_t *p_cell_ctxt = RRM_NULL;
	RRM_UT_TRACE_ENTER();

	p_cell_ctxt = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	p_speed_category_data = &(p_cell_ctxt->ran_info.antenna_info.ue_speed_catagory_data);
        /* SPR 21496 Fix Start */ 
	if( p_ue_context->p_ue_mac_report->report_index >= RRM_MAX_REPORT_STAT_UE )
	{
		for( (report_index = RRM_ZERO);
				(report_index < (RRM_MAX_REPORT_STAT_UE-1));
				(report_index++)
		   )
		{
			decision_factor = p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW0;
			decision_factor_next = p_ue_context->p_ue_mac_report->ue_stats[report_index+1].downlinkSINRValueCW0;

			if( decision_factor > decision_factor_next )
			{
				delta_value = decision_factor - decision_factor_next;
				negative_delta_count++ ;
			}
			else
			{
				delta_value = decision_factor_next - decision_factor;
				positive_delta_count++ ;
			}

			delta_value_total = delta_value_total + delta_value;

		}

		total_count = ((RRM_MAX_REPORT_STAT_UE-RRM_ONE)*RRM_DELTA_SINR_COUNT_PERCENT)/RRM_PERCENTAGE;
		if( (positive_delta_count >= total_count) || (negative_delta_count >= total_count) )
		{
			avg_total_delta_value = (delta_value_total)/(RRM_MAX_REPORT_STAT_UE-1);
			if (avg_total_delta_value < p_speed_category_data->ue_speed_category1_deltaSINR_thresold)
			{
				if ( p_ue_context->ue_speed_algo_param.ue_speed_catagory == RRM_UE_SPEED_CATEGORY_2 )
				{
					p_ue_context->ue_speed_algo_param.ue_speed_catagory = RRM_UE_SPEED_CATEGORY_1;
					p_ue_context->ue_speed_algo_param.ue_speed_catagory_change_flag = RRM_TRUE;
				}
			}
			else if (avg_total_delta_value > p_speed_category_data->ue_speed_category1_deltaSINR_thresold)
			{
				if ( p_ue_context->ue_speed_algo_param.ue_speed_catagory == RRM_UE_SPEED_CATEGORY_1 )
				{
					p_ue_context->ue_speed_algo_param.ue_speed_catagory = RRM_UE_SPEED_CATEGORY_2;
					p_ue_context->ue_speed_algo_param.ue_speed_catagory_change_flag = RRM_TRUE;
				}
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
						"Shall not come here, for future use");
			}
		}
		else
		{
			/* can't determine the UE mobility as reprots are highly varied*/
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,     \
					"cannot calculate UE mobility category as reports are highly varied, \
					total no. of delta Count[%d], calculated +ve delta count[%d], calculated -ve delta count[%d]",\
					total_count, positive_delta_count, negative_delta_count);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
				"Not enough MAC UE reports for mobility calculation, # fresh reports(%d), total # reports [%d]",
				p_ue_context->p_ue_mac_report->report_count,
				p_ue_context->p_ue_mac_report->report_index);
	}
        /* SPR 21496 Fix End */ 
	if ( p_ue_context->ue_speed_algo_param.ue_speed_catagory_change_flag == RRM_TRUE )
	{
		ret_val = RRM_SUCCESS;
	}
	else
	{
		ret_val = RRM_FAILURE;
	}

	RRM_UT_TRACE_EXIT();

	return ret_val;    /* Coverity: CID 41584 Rel2.1.3 */
}
/* End changes for LA feature */
/* CA_Stage_3_Scell_TM_change: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_determine_ue_speed_category_for_scell
 *   Inputs         : p_ue_context
 *   Outputs        : None
 *   DESCRIPTION:
 *       This function determines the UE speed category on the basis of SINR/PL
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
	rrm_return_et
rrm_determine_ue_speed_category_for_scell(
		rrm_ue_context_t *p_ue_context)
{
	U8          report_index = RRM_ZERO;
	U8          count = RRM_ZERO;
	U32         decision_factor = RRM_ZERO;
	U32         decision_factor_next = RRM_ZERO;
	U32         delta_value = RRM_ZERO;
	U32         delta_value_total = RRM_ZERO;
	U32         avg_total_delta_value = RRM_ZERO;
	U8          positive_delta_count = RRM_ZERO;
	U8          negative_delta_count = RRM_ZERO;
	U8          total_count = RRM_ZERO;
	U8          index = RRM_ZERO;
	rrm_return_et         ret_val = RRM_FAILURE;

	rrm_ue_speed_category_data_t *p_speed_category_data = RRM_NULL;
	rrm_cell_context_t *p_scell_cell_ctxt = RRM_NULL;
	RRM_UT_TRACE_ENTER();

	if(p_ue_context->p_ue_mac_report->report_index >= RRM_MAX_REPORT_STAT_UE)
	{
		/* Check if Scell Count is valid then get scell_cell_index & get scell's cell context in p_scell_ctxt &
		   retreive the ue_speed_category_data from the p_scell_ctxt */
		if(p_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL)
		{
			for(count = RRM_ZERO; 
					count < p_ue_context->ue_scell_add_params.count; 
					count++)
			{
				p_scell_cell_ctxt = rrm_cellm_get_cell_context(p_ue_context->ue_scell_add_params.
						rrm_scell_info_for_ue[count].scell_cell_index);
				p_speed_category_data = &(p_scell_cell_ctxt->ran_info.antenna_info.ue_speed_catagory_data);

				if(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].
						scell_periodic_stats.scell_report_count >= RRM_MAX_REPORT_STAT_UE)
				{
					for( report_index = RRM_ZERO;
							report_index < (RRM_MAX_REPORT_STAT_UE-RRM_ONE);
							report_index++)
					{
						if(rrm_check_scell_index_report_received(p_ue_context,
									p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index, 
									report_index) == RRM_TRUE)
						{
							/*Check if the value is not received on second index for a scell */
							index = p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_index;
							decision_factor = p_ue_context->p_ue_mac_report->ue_stats[report_index].
								scellReport[index].downlinkSINRValueCW0;
							decision_factor_next = p_ue_context->p_ue_mac_report->ue_stats[report_index+RRM_ONE].
								scellReport[index].downlinkSINRValueCW0;

							if( decision_factor > decision_factor_next )
							{
								delta_value = decision_factor - decision_factor_next;
								negative_delta_count++ ;
							}
							else
							{
								delta_value = decision_factor_next - decision_factor;
								positive_delta_count++ ;
							}

							delta_value_total += delta_value;
						}
					}
				}
			}
			total_count = ((RRM_MAX_REPORT_STAT_UE-RRM_ONE)*RRM_DELTA_SINR_COUNT_PERCENT)/RRM_PERCENTAGE;
			if( (positive_delta_count >= total_count) || (negative_delta_count >= total_count) )
			{
				avg_total_delta_value = (delta_value_total)/(RRM_MAX_REPORT_STAT_UE);
				if ((avg_total_delta_value < p_speed_category_data->ue_speed_category1_deltaSINR_thresold) &&
						( p_ue_context->ue_speed_algo_param.ue_speed_catagory == RRM_UE_SPEED_CATEGORY_2 ))
				{
					p_ue_context->ue_speed_algo_param.ue_speed_catagory = RRM_UE_SPEED_CATEGORY_1;
					p_ue_context->ue_speed_algo_param.ue_speed_catagory_change_flag = RRM_TRUE;
				}
				else if ((avg_total_delta_value > p_speed_category_data->ue_speed_category1_deltaSINR_thresold) &&
						( p_ue_context->ue_speed_algo_param.ue_speed_catagory == RRM_UE_SPEED_CATEGORY_1 ))
				{
					p_ue_context->ue_speed_algo_param.ue_speed_catagory = RRM_UE_SPEED_CATEGORY_2;
					p_ue_context->ue_speed_algo_param.ue_speed_catagory_change_flag = RRM_TRUE;
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
							"Shall not come here, for future use");
				}
			}
			else
			{
				/* can't determine the UE mobility as reprots are highly varied*/
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,     \
						"cannot calculate UE mobility category as reports are highly varied, \
						total no. of delta Count[%d], calculated +ve delta count[%d], calculated -ve delta count[%d]",\
						total_count, positive_delta_count, negative_delta_count);
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"Invalid Scell Count[%d] for UE Idx[%d]",
					p_ue_context->ue_scell_add_params.count,
					p_ue_context->ue_index);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				"Not enough MAC UE reports for mobility calculation, # fresh reports(%d), total # reports [%d]",
				p_ue_context->p_ue_mac_report->report_count,
				p_ue_context->p_ue_mac_report->report_index);
	}

	if ( p_ue_context->ue_speed_algo_param.ue_speed_catagory_change_flag == RRM_TRUE )
	{
		ret_val = RRM_SUCCESS;
	}
	else
	{
		ret_val = RRM_FAILURE;
	}

	RRM_UT_TRACE_EXIT();

	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_check_if_ue_speed_cat_chng_required_for_scell
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : fsm method
 ****************************************************************************/
	rrm_return_et
rrm_check_if_ue_speed_cat_chng_required_for_scell( rrm_ue_context_t *p_ue_context )
{
	U8 count = RRM_ZERO;
	rrm_cell_index_t cell_index;
	rrm_return_et ret_val = RRM_FAILURE;

	RRM_UT_TRACE_ENTER();
	if( p_ue_context != RRM_NULL)
	{
		if(p_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL)
		{
			for(count = RRM_ZERO; count < p_ue_context->ue_scell_add_params.count; count++)
			{
				cell_index = p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index;
				if(p_ue_context->ue_speed_algo_param.ue_speed_param_scell[cell_index]
						.ue_speed_calculation_count >= RRM_MAX_REPORT_STAT_UE)
				{
					if(rrm_determine_ue_speed_category_for_scell(p_ue_context) == RRM_SUCCESS)
					{
						p_ue_context->ue_speed_algo_param.ue_speed_param_scell[cell_index]
							.ue_speed_calculation_count = RRM_ZERO;
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"UE Speed category for UE Index [%d] changed wrt scell cell index [%d]",
								p_ue_context->ue_index, cell_index);

						ret_val = RRM_SUCCESS;
					}
					else
					{
						/* For case if UE Speed category not changed then 'ue_speed_calculation_count' for the scell 
						   will be reset to zero and wait for next 20 Reports from MAC to again check for speed 
						   category change */
						p_ue_context->ue_speed_algo_param.ue_speed_param_scell[cell_index]
							.ue_speed_calculation_count = RRM_ZERO;
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"UE Speed category for UE Index [%d] not changed wrt scell cell index [%d]",
								p_ue_context->ue_index, cell_index);
					}
				}
				else
				{
					/* Increase the count of 'ue_speed_calculation_count' if total count of reports are less than 20 */
					(p_ue_context->ue_speed_algo_param.ue_speed_param_scell[cell_index].ue_speed_calculation_count)++;

					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"Not enough reports present for UE speed calculation. Total no of fresh report present are[%d]",
							p_ue_context->ue_speed_algo_param.ue_speed_param_scell[cell_index].ue_speed_calculation_count);
				}
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"Added Scells for the given UE context are [%d].",
					p_ue_context->ue_scell_add_params.count);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"Null Pointer exception for UE context!!!");
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* CA_Stage_3_Scell_TM_change: End */

/****************************************************************************
 * Function Name  : rrm_ue_handle_mac_periodic_report_event
 * Inputs         : p_g_rrm_ue_ctx
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : fsm method
 ****************************************************************************/
rrm_return_et
	rrm_ue_handle_mac_periodic_report_event
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
    /*++ SPR 20078 code removed --*/
    rrm_return_et               ret_val = RRM_SUCCESS;
	/*SPR 7892 FIX START*/
    rrm_location_update_action_et  ue_location_update_action = INVALID_REASON;
    rrm_ue_index_t                 ue_index_list[MAX_NUM_OF_UE]  = {RRM_ZERO};
    U32                            ue_update_count                = RRM_ZERO;
    rrm_cell_index_t               cell_index = 0xFF;               /*!< Cell index for UE context      */
    rrm_return_et        ret_val_loc_update = RRM_SUCCESS;
    rrm_cell_context_t   *p_cell_ctx = RRM_PNULL;
	/*SPR 7892 FIX END*/
	/* SPR 8315 FIX START*/
    mac_ue_reconfig_sequence_node_t *p_curr_mac_ue_reconf_seq_data_node = RRM_PNULL;
    /*COV 68868 Fix Start*/
    /*Code Moved*/
    /*COV 68868 Fix Stop*/
	/* SPR 8315 FIX END*/
    /*++ SPR 20078 code removed --*/
    rrm_ue_context_t		*p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    U16   			current_procedure = 
        p_ue_context->current_procedure.state;

	/* coverity  : CID 41553 */ 
    rrm_return_et               speed_changed = RRM_FAILURE ;

    RRM_UT_TRACE_ENTER();
	/* Start changes for LA feature */

    /* This function determine UE speed category based on SINR/PL */
    if ( p_ue_context->ue_speed_algo_param.ue_speed_calculation_count >= RRM_MAX_REPORT_STAT_UE)
    {
        speed_changed = rrm_determine_ue_speed_category(p_ue_context);
        if (speed_changed == RRM_SUCCESS)
        {
            p_ue_context->ue_speed_algo_param.ue_speed_calculation_count = RRM_ZERO;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "RRM will send mac ue reconfig request as UE speed category is changed for UE  [%d]", p_ue_context->ue_index);
        }
    }
    else
    {
        /* increase the count if the 'ue_speed_calculation_count' for Pcell is less than 20 */
        (p_ue_context->ue_speed_algo_param.ue_speed_calculation_count)++;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Not enough reports present for UE speed calculation. Total no of fresh report present are[%d]",
                p_ue_context->ue_speed_algo_param.ue_speed_calculation_count);
    }
    /* End changes for LA feature */
    /* CA_Stage_3_Scell_TM_change: Start */
    /* Check if UE Speed category is changed wrt to any scell */
    if(rrm_check_if_ue_speed_cat_chng_required_for_scell(p_ue_context) == RRM_SUCCESS)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE speed category changed for UE Index [%d] wrt to scell cell index",
                p_ue_context->ue_index);
    } 
    /* CA_Stage_3_Scell_TM_change: End */

    if((RRM_UE_ERB_NULL == current_procedure) && (RRM_ZERO != p_ue_context->drb_configured.num_of_list))
    {
        /*++ SPR 20078 code removed --*/
        /*TM mode switch decision */
        ret_val = rrm_build_and_send_ue_reconfig_req( p_ue_context );

        if( RRM_SUCCESS == ret_val )
        {
            /*set the UE sub state*/
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                    "UE Reconfig Successfully Sent for UE_INDEX[%d]",
                    p_ue_context->ue_index);
            /* SPR 21165 Fix Start */
            /* Code Deleted */
            /* SPR 21165 Fix End */
        }
        else if( RRM_TRUE == p_ue_context->dynamic_icic_info.location_update_req_for_ue_reconfig)
        {
            /*SPR 7892 FIX START*/
            if( MAC_UE_RECONF_NOT_ONGOING  == rrm_get_mac_ue_reconfig_mutex( p_ue_context->cell_index))
                /*SPR 7892 FIX END*/
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Trigger MAC LOC UPDATE request...for ICIC");
                cell_index = p_ue_context->cell_index;
                ue_index_list[0] = p_ue_context->ue_index;
                ue_update_count = 1;
                if( RRM_UE_POSITION_AT_CELL_CENTER == 
                        p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)
                {
                    ue_location_update_action = UE_LOCATION_UPDATE_CE_TO_CC ;
                }
                else
                {
                    ue_location_update_action = UE_LOCATION_UPDATE_CC_TO_CE ;
                }

                ret_val_loc_update = 
                    build_and_send_l2_ue_reconfig_req(cell_index,ue_index_list, ue_update_count, ue_location_update_action);
                /*COV 68868 Fix Start*/
                p_curr_mac_ue_reconf_seq_data_node = 
                    (mac_ue_reconfig_sequence_node_t *)rrm_mem_get(sizeof(mac_ue_reconfig_sequence_node_t));
                if (p_curr_mac_ue_reconf_seq_data_node  == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Memory allocation to p_curr_mac_ue_reconf_seq_data_node failed" );
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                /*COV 68868 Fix Stop*/

                if(RRM_SUCCESS == ret_val_loc_update)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Successfully send UE reconfig req to MAC for location update ");
                    p_cell_ctx = rrm_cellm_get_cell_context(cell_index);
                    /*COV 67342 Fix Start*/
                    if (RRM_PNULL == p_cell_ctx)
                    {
                        if( RRM_NULL != p_curr_mac_ue_reconf_seq_data_node )
                        {
                            RRM_MEM_FREE( p_curr_mac_ue_reconf_seq_data_node );
                        }   
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                "Cell context is Null " );
                        RRM_UT_TRACE_EXIT();
                        return RRM_FAILURE;
                    }
                    p_cell_ctx->dynamic_icic_data.mac_loc_update_triggrd_aftr_ue_reconfig = RRM_TRUE;
                    /*COV 67342 Fix Stop*/

                    /*SPR 7892 FIX START*/
                    rrm_set_mac_ue_reconfig_mutex(cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_ICIC);
                    /*SPR 7892 FIX END*/
                    /* SPR 8315 FIX START*/

                    p_curr_mac_ue_reconf_seq_data_node->mac_ue_reconf_seq_node_data.p_ue_context = p_ue_context;

                    ylPushTail(&(p_g_rrm_ue_ctx->mac_ue_reconfig_sequence_list),
                            (YLNODE *)p_curr_mac_ue_reconf_seq_data_node);
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE context for UE [%d] is pushed at tail of List",
                            p_ue_context->ue_index);
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                            "MAC UE RECONFIG SEQ UE LIST is having [%d] UEs",p_g_rrm_ue_ctx->mac_ue_reconfig_sequence_list.count);
                    /* SPR 8315 FIX END*/
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "UNABLE to  send UE reconfig req to MAC for location update ");
                    /* SPR 8488 FIX START */
                    rrm_rollback_ue_dynamic_icic_data( p_ue_context );
                    /* SPR 8488 FIX END */

                    /* COVERITY : RESOURCE LEAK : CID : 63244 fix start*/
                    if( RRM_NULL != p_curr_mac_ue_reconf_seq_data_node )
                    {
                        RRM_MEM_FREE( p_curr_mac_ue_reconf_seq_data_node );
                    }
                    /* COVERITY : RESOURCE LEAK : CID : 63244 fix end*/
                }
            }
			/*SPR 7892 FIX START*/
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
                        "MAC UE reconfig is already ongoing for this cell index[%d]",p_ue_context->cell_index);
                rrm_rollback_ue_dynamic_icic_data( p_ue_context );
				/* COVERITY : RESOURCE LEAK : CID : 63244 fix start*/
                /*COV 68868 Fix Start*/
                /*Code removed*/
                /*COV 68868 Fix Stop*/
				/* COVERITY : RESOURCE LEAK : CID : 63244 fix end*/
            }
			/*SPR 7892 FIX END*/
        }
		    /* SPR 21165 Fix Start */
		    /* Code Deleted */
		    /* SPR 21165 Fix End */
        /*++ SPR 20078 code removed --*/
    }
    else
    {
		/* SPR 12193 Fix Start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                "UE Fsm could not process the UE's[%d] Transmission mode due to Invalid" 
                "Sub State[%d]",p_ue_context->ue_index,current_procedure);
		/* SPR 12193 Fix end */

        /*++ SPR 20078 code removed --*/
		/* COVERITY : RESOURCE LEAK : CID : 63244 fix start*/
        /*COV 68868 Fix Start*/
        /*Code removed*/
        /*COV 68868 Fix Stop*/
		/* COVERITY : RESOURCE LEAK : CID : 63244 fix end*/
        /*++ SPR 20078 code removed --*/
    }

    RRM_UT_TRACE_EXIT();
		 /* SPR 21165 Fix Start */
		 /* Code Deleted */
		 /* SPR 21165 Fix End */

    /* This should always be success as this return ststement specifies if event is successfully handled or not.
     * In this case it is done successfully.. so always returning SUCCESS
     */ 
    return RRM_SUCCESS;
}

/*csg start*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_proximity_ind
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the proximity_ind message received from RRC.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_proximity_ind_event(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	rrm_proximity_ind_t *p_rrm_proximity_ind = RRM_NULL;
	rrm_ue_context_t    *p_ue_context = RRM_NULL;
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	RRM_UT_TRACE_ENTER();
	if (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL)
	{
		/* COMP_WARN_1_FEB:compilation warning removal */
		p_rrm_proximity_ind = (rrm_proximity_ind_t *)
			p_ue_context->current_procedure.p_proc_data;

		if(p_rrm_proximity_ind->proximity_ind_type == RRM_ENTERING)
		{
			if((p_rrm_proximity_ind->carrier_Freq.bitmask & RRM_UE_PROXIMITY_ARFCN_VALUE_EUTRA_PRESENT) ||
					(p_rrm_proximity_ind->carrier_Freq.bitmask & RRM_UE_PROXIMITY_ARFCN_VALUE_UTRA_PRESENT))
			{
				/* Start fix for SPR 8391 */
				p_ue_context->proximity_ind = RRM_TRUE;
				/* End fix for SPR 8391 */
				ret_val = rrm_build_and_send_meas_config_req(
						p_ue_context,MEAS_TYPE_HO);
			}
		}
		else if(p_rrm_proximity_ind->proximity_ind_type == RRM_LEAVING)
		{
			/*release measurement*/
			/* Start fix for SPR 8391 */
			p_ue_context->proximity_ind = RRM_TRUE;
			/* End fix for SPR 8391 */
			ret_val = rrm_build_and_send_meas_config_req_release(
					p_ue_context);
		}


		/* dealloacate the proc data memory */
		/* Start fix for SPR 8391 */
		p_ue_context->proximity_ind = RRM_FALSE;
		/* SPR 15441 start */
		/* code removed */
		/* SPR 15441 end */
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], Current procedure \
				is not ERB NULL, enqueue message for the UE" ,
				p_ue_context->ue_index);
		rrm_ue_procedure_queue_t    proc_queue;
		proc_queue.api_id = p_g_rrm_ue_ctx->api_id;
		proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data;
		/*BUG 13332:start*/
		proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;
		/*BUG 13332:end*/
		/**Enqueue ERAB setup request */
        /*SPR 18241 START*/
		rrm_ue_mgr_enqueue_req( &proc_queue, p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*csg end*/

/****************************************************************************
 * Function Name  : rrm_ue_handle_reconfig_resp_for_tm_switch_event
 * Inputs         : rrm_ue_context_t ue context.
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : fsm method
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_reconfig_resp_for_tm_switch_event(rrm_ue_context_t *p_ue_context)
{

	rrm_ue_reconfig_response_t  *p_proc_data = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_proc_data = (rrm_ue_reconfig_response_t *)
		p_ue_context->current_procedure.p_proc_data;

	/*Failure condition*/
	if( RRM_ZERO == p_proc_data->response )
	{

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
				"Failure Response for UE Reconfig,reset the TM mode for UE[%d]" \
				,p_ue_context->ue_index);

		/*reset the UE's antenna info*/
		rrm_rollback_ue_cqi_information( p_ue_context );
		rrm_rollback_ue_antenna_info( p_ue_context );

	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
				"UE[%d] Reconfig Response is Success" ,p_ue_context->ue_index);
	}

	/*set the ue's state RRM_UE_ERB_NULL*/
	p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}

/*LTE_RRM_TM_SWITCH_END*/
/****************************************************************************
 * Function Name  : reset_scell_add_bkp
 * Inputs         : rrm_ue_context_t ue context.
 * Outputs        : None
 * Returns        : None
 * Description    : resets the scell backup fields after committing.
 ****************************************************************************/
	rrm_void_t
reset_scell_add_bkp(rrm_ue_context_t *p_ue_context)
{
	RRM_UT_TRACE_ENTER();
	p_ue_context->ue_scell_add_params.bitmask = RRM_ZERO;
	p_ue_context->ue_scell_add_params.scell_bkp_count = RRM_ZERO;
	RRM_MEMSET(p_ue_context->ue_scell_add_params.scell_cell_index_add_bkp, RRM_OUT_OF_RANGE, RRM_MAX_SCELL);

	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_scell_add_success
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : adds UE ctx to the corresponding Scell list in Cell ctx.
 ****************************************************************************/
/* CA changes : Start */
	rrm_return_et
rrm_scell_add_success(rrm_ue_context_t *p_ue_context)
{
	U8 count = RRM_ZERO;
	/* CA_Stage_3_Scell_TM_change: Start */
	U8               scell_arr_idx = RRM_ZERO;
	rrm_return_et    ret_val = RRM_SUCCESS;
	/* CA_Stage_3_Scell_TM_change: End */
	U8 scell_index = RRM_ZERO;
	rrm_cell_context_t *p_cell_ctx;

	RRM_UT_TRACE_ENTER();
	if(p_ue_context != RRM_PNULL)
	{ 
		p_cell_ctx = rrm_cellm_get_cell_context(p_ue_context->cell_index);
		/*CID 65800:start*/
		if (RRM_PNULL == p_cell_ctx )
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctx is null");
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		/*CID 65800:end*/

		while(p_ue_context->ue_scell_add_params.scell_cell_index_add_bkp[count] != RRM_OUT_OF_RANGE)
		{ 
			scell_index = p_ue_context->ue_scell_add_params.scell_cell_index_add_bkp[count];
			//Add UE Context to the list of UEs using the given Scell_index as Scell.
			p_cell_ctx->scell_info[scell_index].scell_index = scell_index;
			rrm_add_ue_in_scell_list_of_cell( p_ue_context->cell_index,
					scell_index,
					p_ue_context );
			/* CA_Stage_3_Scell_TM_change: Start */
			/* For Pcell UE Mac Periodic reports report index & report count are initialised at UE admission.
			   For Scell the report index & report count are initialised here when Scell Add is successful at UE
			   and UE Reconfig response is successful.
			   After successful addition of Scell, MAC is expected to send the Scell Reports for Scell.*/
			if(((rrm_is_scell_valid_for_ue(p_ue_context, scell_index, &scell_arr_idx)) != RRM_FAILURE ))
			{
				p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].scell_periodic_stats.scell_report_index = RRM_ZERO;
				p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].scell_periodic_stats.scell_report_count = RRM_ZERO;
				p_ue_context->ue_speed_algo_param.ue_speed_param_scell[scell_index].ue_speed_calculation_count = RRM_ONE;
			}
			count++;
			/* CA_Stage_3_Scell_TM_change: End */
		}
		reset_scell_add_bkp(p_ue_context);

		p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
	}
	else /* else of RRM_PNULL != p_ue_context */
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"NULL POINTER EXCEPTION for ue context!!");
		ret_val = RRM_FAILURE;
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/********************************************************************************
 * Function Name  : rrm_scell_del_success
 * Inputs         : rrm_ue_context_t ue context.
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : Deletes UE ctx from the corresponding Scell list in Cell ctx.
 ********************************************************************************/
	rrm_return_et
rrm_scell_del_success(rrm_ue_context_t *p_ue_context)
{
	RRM_UT_TRACE_ENTER();
	//Delete UE Context from the list of UEs using the given Scell_index as Scell. 
	rrm_delete_ue_in_scell_list_of_cell( p_ue_context->cell_index,
			p_ue_context->ue_scell_add_params.scell_cell_index,
			p_ue_context);
	p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}
/* CA changes : End */

/*SPR 8019 FIX START2*/

/* SRS_FREQ_HOPPING_START */
/****************************************************************************
 * Function Name  : rrm_ue_handle_reconfig_resp_for_srs_hopping_status_changed_event
 * Inputs         : rrm_ue_context_t ue context.
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : fsm method
 ****************************************************************************/
rrm_return_et
	rrm_ue_handle_reconfig_resp_for_srs_hopping_status_changed_event
(
 rrm_ue_context_t *p_ue_context
 )
{

	rrm_ue_reconfig_response_t  *p_proc_data = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_proc_data = (rrm_ue_reconfig_response_t *)
		p_ue_context->current_procedure.p_proc_data;

	/*Failure condition*/
	if( RRM_ZERO == p_proc_data->response )
	{

		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
				"Failure Response for UE Reconfig,restore the previous SRS configuration for UE[%d]" \
				,p_ue_context->ue_index);

		rrm_rollback_ue_srs_configuration( p_ue_context );

	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
				"UE[%d] Reconfig Response is Success" ,p_ue_context->ue_index);
		RRM_MEMCPY(&(p_ue_context->srs_params_last_used),&(p_ue_context->srs_params),
				sizeof(rrm_ue_srs_params_t));

	}

	/*set the ue's state RRM_UE_ERB_NULL*/
	p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;

	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rollback_ue_srs_configuration
 *   Inputs         : p_ue_context
 *   Outputs        : None
 *   DESCRIPTION:
 *       This function rollbacks the srs configuration.
 *   RETURNS: None
 ******************************************************************************/
rrm_void_t
	rrm_rollback_ue_srs_configuration
(
 rrm_ue_context_t *p_ue_context
 )
{
	RRM_UT_TRACE_ENTER();

	rrm_bool_t ret_val = RRM_FAILURE;
	U16 srs_res_anchor_val = RRM_ZERO;
	/*
	 ** Free the SRS anchor of the SRS configuration used for the
	 ** UE reconfig.
	 */

	srs_res_anchor_val = p_ue_context->srs_params.srs_anchor;

	ret_val = rrm_cellm_mark_srs_index_free(p_ue_context->cell_index,srs_res_anchor_val);

	if(RRM_SUCCESS == ret_val)
	{
		srs_res_anchor_val = p_ue_context->srs_params_last_used.srs_anchor;

		ret_val = rrm_cellm_mark_srs_index_busy(p_ue_context->cell_index,srs_res_anchor_val);
		if(RRM_SUCCESS == ret_val )
		{
			RRM_MEMCPY(&(p_ue_context->srs_params),&(p_ue_context->srs_params_last_used),
					sizeof(rrm_ue_srs_params_t));
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,\
					"UNABLE to MARK the last used SRS Configuration as BUSY for Unsuccesful UE reconfig :");
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,\
				"UNABLE to free SRS Configuration for Unsuccesful UE reconfig :");
	} 
	RRM_UT_TRACE_EXIT();
}
/* SRS_FREQ_HOPPING_END */
/*SPR 8019 FIX END2*/

/* UE Positioing code start */
/****************************************************************************
 * Function Name  : rrm_ue_handle_meas_results_ind_for_ue_positioing
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas results ind message for UE Positioing.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_meas_results_ind_for_ue_positioing(
		rrm_ue_measurment_results_ind_t    *p_ue_meas_results,
		rrm_ue_context_t                   *p_ue_context,
		U8                                  ecid_meas_req_index
		)
{
	rrm_return_et                            ret_val= RRM_SUCCESS;
	s1ap_rrm_lppa_ecid_meas_report_t         *p_lppa_ecid_meas_report = RRM_PNULL;
	U16                                      transaction_id = RRM_ZERO;
	U32                                      index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();
	if((RRM_PNULL != p_ue_meas_results ) && 
			(RRM_PNULL != p_ue_context ) && 
			(RRM_FIFTEEN > ecid_meas_req_index ))
	{
		p_lppa_ecid_meas_report = (s1ap_rrm_lppa_ecid_meas_report_t *)
			rrm_mem_get(sizeof(s1ap_rrm_lppa_ecid_meas_report_t));
		if (RRM_PNULL == p_lppa_ecid_meas_report)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
			return RRM_FAILURE;
		}
                /* SPR 21496 Fix Start */ 
		RRM_MEMSET (p_lppa_ecid_meas_report, RRM_ZERO,sizeof(s1ap_rrm_lppa_ecid_meas_report_t));
		p_lppa_ecid_meas_report->ue_index        = p_ue_context->ue_index;
		p_lppa_ecid_meas_report->routing_id      = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].routing_id;
		p_lppa_ecid_meas_report->lppa_trans_id   = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].lppa_trans_id;
		p_lppa_ecid_meas_report->e_smlc_ue_meas_id  = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].e_smlc_ue_meas_id;
		p_lppa_ecid_meas_report->enb_ue_meas_id  = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].enb_ue_meas_id;
                /* SPR 21496 Fix End */ 

		rrm_fill_eutran_access_point(p_ue_context->cell_index,
				&(p_lppa_ecid_meas_report->e_cid_meas_result));
		ret_val = rrm_fill_serv_cell_ecid_info(p_ue_context->cell_index,&(p_lppa_ecid_meas_report->e_cid_meas_result));
		if(RRM_SUCCESS ==ret_val)
		{
                  /* SPR 21496 Fix Start */ 
			for(index =  RRM_ZERO ; (index < p_ue_context->p_ue_positioing_data[ecid_meas_req_index].num_meas_quantifier) && (ret_val == RRM_SUCCESS) ;index++) 
			{
				switch (p_ue_context->p_ue_positioing_data[ecid_meas_req_index].meas_quantifier[index])
				{
					case RRM_LPPA_CELL_ID:
						/* Already filled, nothing needs to be done */
						break;
					case RRM_LPPA_ANGLEOFARRIVAL:
						p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].value_angle_of_arrival = 
							p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_mac_data.AoA[0];
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].bitmask |= 
							LPPA_MEAS_RESULT_VALUE_ANGLE_OF_ARRIVAL_PRESENT;
						break;
					case RRM_LPPA_TIMINGADVANCETYPE1:
						p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].value_timing_adv_type_1 = 
							(p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_mac_data.enb_rxtx_diff_type1) + 
							(p_ue_meas_results->meas_result_ecid_r9.ue_rxtx_time_diff);
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].bitmask |= 
							LPPA_MEAS_RESULT_VALUE_TIMING_ADV_TYPE_1_PRESENT;
						break;
					case RRM_LPPA_TIMINGADVANCETYPE2:
						p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].value_timing_adv_type_2 = 
							p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_mac_data.enb_rxtx_diff_type2;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].bitmask |= 
							LPPA_MEAS_RESULT_VALUE_TIMING_ADV_TYPE_2_PRESENT;
						break;
					case RRM_LPPA_RSRP:
						p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |=LPPA_MEASUREMENT_RESULT_PRESENT;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
						ret_val = rrm_fill_lppa_rsrp_meas_result(p_ue_context->cell_index,
								&(p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index]),
								p_ue_meas_results
								);
						break;
					case RRM_LPPA_RSRQ:
						p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |=LPPA_MEASUREMENT_RESULT_PRESENT;
						p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
						ret_val = rrm_fill_lppa_rsrq_meas_result(p_ue_context->cell_index,
								&(p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index]),
								p_ue_meas_results
								);
						break;
					default:
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
								"Not of any valid meas quaitifier");
						break;
				}
			}
                        /* SPR 21496 Fix End */ 
		}
		if(RRM_SUCCESS == ret_val )
		{
			transaction_id= rrm_generate_txn_id();
			if(RRM_SUCCESS == rrm_il_send_s1ap_rrm_lppa_ecid_meas_report(p_lppa_ecid_meas_report,
						RRM_MODULE_ID,
						RRC_MODULE_ID,
						transaction_id,p_ue_context->cell_index))
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,\
						"ECID meas report send for UE_INDEX[%d]",
						p_ue_context->ue_index);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
						"Failed to send ECID meas report UE_INDEX[%d]",
						p_ue_context->ue_index);
			}
		}
		RRM_MEM_FREE( p_lppa_ecid_meas_report );
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
				"either p_ue_meas_results or p_ue_context is NULL or ecid_meas_req_index >= 15[%d]",
				ecid_meas_req_index );
	}


	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_lppa_ecid_meas_init_req
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the rrm_ue_handle_lppa_ecid_meas_init_req for UE Positioing.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_lppa_ecid_meas_init_req(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	RRM_UT_TRACE_ENTER();   
	rrm_return_et                   ret_val = RRM_SUCCESS;
	rrm_bool_et                     ecid_meas_exist = RRM_TRUE;
	rrm_ue_context_t                *p_ue_context = RRM_NULL;
	/* Coverity_ID : 41554 */
	rrm_ue_timer_buf_t              timer_buff;
	rrm_ue_lppa_ecid_meas_init_req_t   *p_rrm_lppa_ecid_meas_init_req = RRM_NULL;
	U8                              index=RRM_ZERO;
	U8                              ecid_meas_index = RRM_ZERO;
	U32                             timer_duration = RRM_ZERO; 
	U8                              num_meas_quan = RRM_ZERO;
	rrm_bool_et                     ecid_meas_supported = RRM_FALSE;
	rrm_cause_t                     cause = {RRM_ZERO};
	lppa_criticality_diagno_t       cri_diag = {RRM_ZERO};
	rrm_lppa_meas_peridicity_et     report_interval= RRM_LPPA_MS120;
	U8                              ue_esmlc_req_index = RRM_MAX_ESMLC_MEAS_ID;
	S32                             ue_started_meas_time_in_ms = RRM_ZERO;
	U32                             drx_sf_in_msec =RRM_ZERO;

	U8 report_config_trigger_qty_bitmask = RRM_ZERO;
        /* SPR 21496 Fix Start */ 
        U16                             tbl_size = RRM_ZERO; 
        /* SPR 21496 Fix End */ 

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	/*1.Fetch data from parsed ecid_meas_init_req, stored within ue context
	  2.Populate structure within ue context for ue pos
	  3.send meas config req
	  4.Start timer*/

	if (RRM_PNULL != p_ue_context)
	{
		/* Bug 8018 fix start */
		/* SPR 10164 Fix Start */
		if(p_ue_context->ue_capability_params.bitmask & 
				RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
			/* SPR 10164 Fix End */
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d] has capability params present" , 
					p_ue_context->ue_index);

			/* Checking whether UE release is greater than or equal to 9 */
			if(RRM_REL9 <= 
					p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d] has access_stratum_release equal to %d" , 
						p_ue_context->ue_index, 
						p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release);

				/* Bug 8018 fix end */        
				/* If meas config request has already been sent for a UE for any reason,
				 * then enqueue the ESMLC request which will be dequeued later on once 
				 * meas config response comes */
				if(RRM_MEAS_CONFIG_REQ_SENT == p_ue_context->meas_status)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "meas config req has already been sent \
							for the UE_INDEX[%d], so enqueue the message" , p_ue_context->ue_index);

					/* SPR 15441 start */
					rrm_ue_procedure_queue_t    proc_queue;
					proc_queue.api_id = p_g_rrm_ue_ctx->api_id;
					proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data;
					/* SPR 15441 end */
					/*BUG 13332:start*/
					proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;
					/*BUG 13332:end*/

					/* Enqueue the ESMLC request */
					rrm_ue_mgr_enqueue_esmlc_meas_req(&proc_queue, p_g_rrm_ue_ctx->p_ue_context);
				} /* if part of enqueuing the esmlc request */
				else
				{
					p_rrm_lppa_ecid_meas_init_req =(rrm_ue_lppa_ecid_meas_init_req_t*)
						p_ue_context->current_procedure.p_proc_data;

                                        /* SPR 21496 Fix Start */ 
                                        if (RRM_PNULL == p_ue_context->p_ue_positioing_data)
                                        {
                                          tbl_size = sizeof(rrm_ue_positioing_data) * RRM_MAX_ESMLC_MEAS_ID;
                                          p_ue_context->p_ue_positioing_data = (rrm_ue_positioing_data*)rrm_mem_get(tbl_size);
                                          if (RRM_PNULL == p_ue_context->p_ue_positioing_data)
                                          {
                                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                                "Failed to allocate memory for ECID measurements");
                                            RRM_UT_TRACE_EXIT();
                                            return RRM_FAILURE;
                                          }
                                          RRM_MEMSET(p_ue_context->p_ue_positioing_data, RRM_ZERO, tbl_size);
                                        }
                                        /* SPR 21496 Fix End */ 
					ecid_meas_exist = rrm_ue_is_ecid_meas_already_exist(p_ue_context,p_rrm_lppa_ecid_meas_init_req->e_smlc_meas_id,&ue_esmlc_req_index);
					if(ecid_meas_exist == RRM_FALSE)
					{
						if(RRM_TRUE == rrm_ue_is_valid_ecid_meas_request(p_ue_context,p_rrm_lppa_ecid_meas_init_req))
						{
							for(ecid_meas_index =RRM_ZERO;ecid_meas_index < RRM_MAX_ESMLC_MEAS_ID;ecid_meas_index++)
							{
                                                          /* SPR 21496 Fix Start */ 
								if(p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_req_received == RRM_FALSE)
								{
									cause.type = RRM_ECID_RADIO_NW_LAYER_CAUSE;
									cause.value  = RRM_RNL_REQUESTED_ITEM_TEMPORARILLY_NOT_AVAILABLE;
									/*populate ue pos structure in ue_context*/
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_req_received = RRM_TRUE;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].mme_id =
										p_rrm_lppa_ecid_meas_init_req->mme_id;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].routing_id =
										p_rrm_lppa_ecid_meas_init_req->routing_id;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].lppa_trans_id =
										p_rrm_lppa_ecid_meas_init_req->lppa_trans_id;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id =
										p_rrm_lppa_ecid_meas_init_req->e_smlc_meas_id;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].enb_ue_meas_id = ecid_meas_index + RRM_ONE;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].report_type =
										p_rrm_lppa_ecid_meas_init_req->report_char;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].report_interval =
										p_rrm_lppa_ecid_meas_init_req->meas_periodicity;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier = RRM_ZERO;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_pos_timer =  RRM_PNULL;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_send_for_rem =  RRM_FALSE;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req =  RRM_NULL;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_report_sent =  RRM_FALSE;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].timer_expire_count =  RRM_ZERO;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_id_allocate =  RRM_FALSE;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_config_sent_time.sec = RRM_ZERO;
									p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_config_sent_time.msec = RRM_ZERO;

									for(index=RRM_ZERO;
											index<p_rrm_lppa_ecid_meas_init_req->num_meas_quantifier;
											index ++)
									{
										switch(p_rrm_lppa_ecid_meas_init_req->meas_quantifier[index].meas_quantity_item)
										{
											case RRM_LPPA_CELL_ID:
												p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_quantifier[num_meas_quan++] =
													RRM_LPPA_CELL_ID;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier++;
												ecid_meas_supported = RRM_TRUE;
												break;
											case RRM_LPPA_ANGLEOFARRIVAL:
												p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_quantifier[num_meas_quan++]=
													RRM_LPPA_ANGLEOFARRIVAL;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier++;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_MAC_MEAS_REQD;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req |=  RRM_ECID_MAC_AOA_REQD;
												ecid_meas_supported = RRM_TRUE;
												break;
											case RRM_LPPA_TIMINGADVANCETYPE1:
												p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_quantifier[num_meas_quan++]=
													RRM_LPPA_TIMINGADVANCETYPE1;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier++;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_UE_MEAS_REQD;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_MAC_MEAS_REQD;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req |=  RRM_ECID_MAC_TA1_REQD;
												ecid_meas_supported = RRM_TRUE;

												/* If UE RxTx difference is requested, then bitmask corresponding to it will be set */
												report_config_trigger_qty_bitmask |= RRM_UE_POS_TRIGGER_QTY_UE_RXTX_DIFF;
												break;
											case RRM_LPPA_TIMINGADVANCETYPE2:
												p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_quantifier[num_meas_quan++]=
													RRM_LPPA_TIMINGADVANCETYPE2;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier++;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_MAC_MEAS_REQD;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req |=  RRM_ECID_MAC_TA2_REQD;
												ecid_meas_supported = RRM_TRUE;
												break;
											case RRM_LPPA_RSRP:
												p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_quantifier[num_meas_quan++]=
													RRM_LPPA_RSRP;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier++;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_UE_MEAS_REQD;
												ecid_meas_supported = RRM_TRUE;

												/* If RSRP is requested, then bitmask for RSRP will be set */
												report_config_trigger_qty_bitmask |= RRM_UE_POS_TRIGGER_QTY_RSRP;
												break;
											case RRM_LPPA_RSRQ:
												p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_quantifier[num_meas_quan++]=
													RRM_LPPA_RSRQ;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].num_meas_quantifier++;
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_UE_MEAS_REQD;
												ecid_meas_supported = RRM_TRUE;

												/* If RSRQ is requested, then bitmask for RSRQ will be set */
												report_config_trigger_qty_bitmask |= RRM_UE_POS_TRIGGER_QTY_RSRQ;
												break;
											default:
												RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
														"Not of any valid meas quaitifier at index[%d] for ue_index [%d] ",
														index,
														p_ue_context->ue_index);
												break;
										}
									}
									if(RRM_TRUE == ecid_meas_supported)
									{
										if(RRM_LPPA_ONDEMAND == p_rrm_lppa_ecid_meas_init_req->report_char)
										{
											report_interval = RRM_LPPA_MS120;
										}
										else
										{
											report_interval = p_rrm_lppa_ecid_meas_init_req->meas_periodicity; 
										}

										if(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status &  RRM_ECID_MAC_MEAS_REQD &&
												!(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status &  RRM_ECID_UE_MEAS_REQD))
										{
											/* Coverity_ID : 55182 */
											timer_duration = rrm_get_meas_priodicity_in_ms(RRM_LPPA_MS2048);
										}
										else
										{
											/* Coverity_ID : 55182 */
											timer_duration = rrm_get_meas_priodicity_in_ms(RRM_LPPA_MS5120);
										}
										if(p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req &  RRM_ECID_MAC_TA1_REQD)
										{
											/* SPR 10450 Fix Start */
											drx_sf_in_msec = rrm_get_drx_cycle_period(p_ue_context->cell_index,
													p_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index);
											/* SPR 10450 Fix End */
											if(timer_duration < drx_sf_in_msec)
											{
												timer_duration =  drx_sf_in_msec + 100;
											}
										}
										if(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD)
										{
											/*configure measurement for ue pos*/
											ret_val = rrm_build_and_send_meas_config_req_for_ue_positioning(p_ue_context,
													ecid_meas_index,
													report_interval,
													p_ue_context->p_ue_positioing_data[ecid_meas_index].report_type,
													report_config_trigger_qty_bitmask,
													RRM_FALSE/*request is for ue_postioning*/); 


											if(RRM_FAILURE == ret_val)
											{
												RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
														"UE meas config request failured for the meas quantifier at index[%d] for ue_index[%d]",
														index,
														p_ue_context->ue_index);
											}
											else
											{ 
												p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_config_sent_time = rrm_get_system_time();
												p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
												/* SPR 15797 Start */
												p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING; 
												/* SPR 15797 End */
											}
										}
										if ((RRM_FAILURE != ret_val)  &&
												(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status &  RRM_ECID_MAC_MEAS_REQD))
										{
											/* Send rrm_mac_ecid_meas_report_req to MAC */
											RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
													"Sending rrm_mac_ecid_meas_report_req for meas quantifier at index[%d] for ue_index[%d]",
													index,
													p_ue_context->ue_index);

											if(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD)
											{
												RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
														"Will send MAC E_CID request on receiving of meas_config_resp for esmlc_id =%d for [UE:%d]",
														p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id,
														p_ue_context->ue_index);
											}
											else
											{
												ret_val =  rrm_build_and_send_mac_ecid_meas_report_req(p_ue_context,ue_started_meas_time_in_ms);
												if (RRM_FAILURE == ret_val)
												{
													RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
															"MAC EC_CID request failured for the meas quantifier at index[%d] for ue_index[%d]",
															index,
															p_ue_context->ue_index);
												}
											}
										}
									}
									else
									{
										ret_val = RRM_FAILURE;
										cause.type = RRM_ECID_RADIO_NW_LAYER_CAUSE;
										cause.value  = RRM_RNL_REQUESTED_ITEM_NOT_SUPPORTED;
									}
									if(RRM_SUCCESS == ret_val)
									{
										if((RRM_LPPA_ONDEMAND == p_rrm_lppa_ecid_meas_init_req->report_char)&&
												(!(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD))&&
												(!(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)))
										{
											rrm_build_and_send_ecid_meas_response( p_ue_context,ecid_meas_index);
											rrm_clean_ue_ecid_meas_related_info(p_ue_context,ecid_meas_index);
										}
										else
										{
											if(!(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD))
											{
												rrm_build_and_send_ecid_meas_response( p_ue_context,ecid_meas_index);
											}
											RRM_MEMSET (&timer_buff,0,sizeof(rrm_ue_timer_buf_t));
											timer_buff.timer_type = rrm_get_ecid_meas_timer_type(ecid_meas_index);
											timer_buff.ue_index = p_ue_context->ue_index;
											timer_buff.cell_index = p_ue_context->cell_index;
											/* CSR-58333-fix start*/
											p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_pos_timer =
												rrm_ue_start_timer(
														timer_duration,
														&timer_buff,
														sizeof(rrm_ue_timer_buf_t),
														RRM_FALSE);
											/* CSR-58333-fix end*/
										}
									}
									else
									{
										rrm_build_and_send_ecid_meas_failure(p_ue_context->ue_index, 
												p_ue_context->cell_index,
												p_rrm_lppa_ecid_meas_init_req->mme_id,
												p_rrm_lppa_ecid_meas_init_req->routing_id,
												p_rrm_lppa_ecid_meas_init_req->lppa_trans_id,
												p_rrm_lppa_ecid_meas_init_req->e_smlc_meas_id,cause);
										rrm_ue_delete_meas_id_info_for_ecid_meas(p_ue_context, ecid_meas_index);
										rrm_clean_ue_ecid_meas_related_info(p_ue_context,ecid_meas_index);
									}
									break;
								}
                                                                /* SPR 21496 Fix End */ 
							}
						}
						else
						{
							cause.type = RRM_ECID_RADIO_NW_LAYER_CAUSE;
							cause.value  = RRM_RNL_REQUESTED_ITEM_NOT_SUPPORTED;
							rrm_build_and_send_ecid_meas_failure(p_ue_context->ue_index, 
									p_ue_context->cell_index,
									p_rrm_lppa_ecid_meas_init_req->mme_id,
									p_rrm_lppa_ecid_meas_init_req->routing_id,
									p_rrm_lppa_ecid_meas_init_req->lppa_trans_id,
									p_rrm_lppa_ecid_meas_init_req->e_smlc_meas_id,cause);
						}
					}
					else
					{
						cause.type   = RRM_ECID_RADIO_NW_LAYER_CAUSE;
						cause.value  = RRM_RNL_UNSPECIFIED;
						rrm_build_and_send_ecid_meas_error_req(p_ue_context->ue_index, 
								p_ue_context->cell_index,
								p_rrm_lppa_ecid_meas_init_req->mme_id,
								p_rrm_lppa_ecid_meas_init_req->routing_id,
								p_rrm_lppa_ecid_meas_init_req->lppa_trans_id,
								cause,cri_diag);
					}

					/* SPR 15441 start */
					/* code removed */
					/* SPR 15441 end */
				} /* else part of enqueuing the esmlc request */
				/* Bug 8018 fix start */
			} /* if part ends for checking access stratum value */
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d] has access stratum release=%d , \
						so sending failure ind" , p_ue_context->ue_index, 
						p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release);

				/* Bug 8242: Fix start */
				p_rrm_lppa_ecid_meas_init_req =(rrm_ue_lppa_ecid_meas_init_req_t*)
					p_ue_context->current_procedure.p_proc_data;
				/* Bug 8242: Fix end */

				ret_val = RRM_FAILURE;
				cause.type = RRM_ECID_RADIO_NW_LAYER_CAUSE;
				cause.value  = RRM_RNL_REQUESTED_ITEM_NOT_SUPPORTED;

				if(RRM_PNULL != p_rrm_lppa_ecid_meas_init_req) /* Coverity: CID 54284 */
				{
					rrm_build_and_send_ecid_meas_failure(p_ue_context->ue_index, 
							p_ue_context->cell_index,
							p_rrm_lppa_ecid_meas_init_req->mme_id,
							p_rrm_lppa_ecid_meas_init_req->routing_id,
							p_rrm_lppa_ecid_meas_init_req->lppa_trans_id,
							p_rrm_lppa_ecid_meas_init_req->e_smlc_meas_id,cause);

					/* SPR 15441 start */
					/* code removed */
					/* SPR 15441 end */
				}
			} /* else part ends for checking access stratum value */ 
		} /* if part ends for checking capability params */
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d] has capability params absent so \
					not checking access stratum release for UE" , p_ue_context->ue_index);
		} /* else part ends for checking capability params */
		/* Bug 8018 fix end */
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"p_ue_context is NULL");
	}
	RRM_UT_TRACE_EXIT();   
	return ret_val; 
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_inter_freq_meas_ind
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the RRC_RRM_INTER_FREQ_MEAS_IND
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_inter_freq_meas_ind(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_ue_context_t                               *p_ue_context = RRM_PNULL;
	rrc_rrm_meas_config_req_t                      *p_rrc_rrm_meas_config_req = RRM_PNULL;
	rrm_ue_inter_freq_meas_ind_t                   *p_rrm_ue_inter_freq_meas_ind = RRM_PNULL;
	U16                                            trans_id = rrm_generate_txn_id();
	rrm_bool_et                                    send_rrc_meas_gap_config_req = RRM_FALSE;
	/* SPR 14326 Fix Start */
	rrm_bool_et                                    send_measgap = RRM_FALSE;
	rrm_cell_context_t                             *p_cell_context = RRM_PNULL;
	/* SPR 14326 Fix End */
	/* SPR: 15922 Fix start */
	rrm_return_et                                  ret_val = RRM_SUCCESS;
	/* SPR: 15922 Fix end */

	RRM_UT_TRACE_ENTER();


	/** Store the UE context local to the function */
	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	/* SPR 14326 Fix Start */
	p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	/* SPR 14326 Fix End */
	/* Coverity 71369 Fix Start */
	if(RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"rrm_cellm_get_cell_context returns NULL for CELL_INDEX = %d",p_ue_context->cell_index);
		return RRM_FAILURE;
	}
	/* Coverity 71369 Fix End */
	p_rrm_ue_inter_freq_meas_ind = (rrm_ue_inter_freq_meas_ind_t *)p_ue_context->current_procedure.p_proc_data;
	if(RRM_PNULL == p_rrm_ue_inter_freq_meas_ind)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"p_ue_context->current_procedure.p_proc_data is null");
		return RRM_FAILURE;
	}

	p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t *) rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
	if(RRM_PNULL == p_rrc_rrm_meas_config_req )
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Failed to allocate memory for p_rrc_rrm_meas_config_req ");
		/* SPR 15441 start */
		/* code removed */
		/* SPR 15441 end */
		return RRM_FAILURE;
	}
	/* SPR 14326 Fix Start */
	send_measgap = rrm_check_send_meas_gap_is_enabled(p_cell_context->ran_info.rf_params
			.rf_configurations.dl_earfcn ,
			p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].carrier_freq,
			p_ue_context,
			INTER_FREQ_BAND_LIST,
			EUTRA_FREQ,
			RRM_PNULL
			);
	if( RRM_TRUE == send_measgap)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				"Add MEAS GAP for Inter Freq Meas Ind as per UE Capability");
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
				"No need to add MEAS GAP for Inter Freq Meas Ind as per UE Capability");
	}

	if((p_rrm_ue_inter_freq_meas_ind->bitmask & RRM_UE_INTER_FREQ_RSTD_INFO_LIST_PRESENT ||  
				p_rrm_ue_inter_freq_meas_ind->bitmask & RRM_UE_INTER_FREQ_RSTD_START) 
			&& (RRM_TRUE == send_measgap))
		/* SPR 14326 Fix End */
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Add meas_gap =%d for carrier_freq =%d for UE_INDEX=%d",
				p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].meas_prs_offset,
				p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].carrier_freq,
				p_rrm_ue_inter_freq_meas_ind->ue_index);
		p_rrc_rrm_meas_config_req->ue_index = p_rrm_ue_inter_freq_meas_ind->ue_index;
		p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;
		p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask |= MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT;
		p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type = RRM_ONE;
		p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.bitmask |= MEAS_GAP_CONFIG_GP0_PRESENT;
		p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.gp0 = 
			p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].meas_prs_offset;
		send_rrc_meas_gap_config_req = RRM_TRUE;
		p_ue_context->meas_gap_config.meas_gap_added |=MEAS_GAP_ADDED_FOR_PRS;
		p_ue_context->meas_gap_config.meas_gap_type = RRM_MEAS_GAP_TYPE_0;
		p_ue_context->meas_gap_config.meas_gap_offset = p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].meas_prs_offset;

		/*SPR_17047_START*/
		p_ue_context->meas_gap_sent_status = RRM_SET;
		/*SPR_17047_END*/

		/*SPR 17061 Start*/
		/* SPR 15397 Start */
		/* SPR 16053 start */
		/* Code removed */
		/* SPR 16053 end */
		/* SPR 15397 End */
		/*SPR 17061 End*/
	}
	else if(p_rrm_ue_inter_freq_meas_ind->bitmask & RRM_UE_INTER_FREQ_RSTD_INFO_LIST_PRESENT ||  
			p_rrm_ue_inter_freq_meas_ind->bitmask & RRM_UE_INTER_FREQ_RSTD_STOP)
	{
		if((p_ue_context->meas_gap_config.meas_gap_added & MEAS_GAP_ADDED_FOR_NON_PRS) == RRM_FALSE)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Remove meas_gap =%d for carrier_freq =%d for UE_INDEX=%d",
					p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].meas_prs_offset,
					p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].carrier_freq,
					p_rrm_ue_inter_freq_meas_ind->ue_index);
			p_rrc_rrm_meas_config_req->ue_index = p_rrm_ue_inter_freq_meas_ind->ue_index;
			p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;
			p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask |= MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT;
			p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type = RRM_ZERO;
			p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.bitmask |= MEAS_GAP_CONFIG_GP0_PRESENT;
			p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.gp0 = 
				p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].meas_prs_offset;
			send_rrc_meas_gap_config_req = RRM_TRUE;
			p_ue_context->meas_gap_config.meas_gap_type = RRM_ZERO;
			/*SPR_17047_START*/
			p_ue_context->meas_gap_sent_status = RRM_UNSET;
			/*SPR_17047_END*/

			/*SPR 17061 Start*/
			/* SPR 15397 Start */
			/* SPR 16053 start */
			/* Code removed */
			/* SPR 16053 end */
			/* SPR 15397 End */
			/*SPR 17061 End*/
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"Not remove(meas_gap_added=%d) meas_gap =%d for carrier_freq =%d for UE_INDEX=%d",
					p_ue_context->meas_gap_config.meas_gap_added,
					p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].meas_prs_offset,
					p_rrm_ue_inter_freq_meas_ind->rstd_interfreq_list[RRM_ZERO].carrier_freq,
					p_rrm_ue_inter_freq_meas_ind->ue_index);
		}
		p_ue_context->meas_gap_config.meas_gap_added = p_ue_context->meas_gap_config.meas_gap_added & ~(MEAS_GAP_ADDED_FOR_PRS);
	}
	else
	{
		send_rrc_meas_gap_config_req = RRM_FALSE;

	}
	if(RRM_TRUE == send_rrc_meas_gap_config_req )
	{
		if (RRM_FAILURE == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
					RRM_MODULE_ID,
					RRC_MODULE_ID,
					trans_id, p_g_rrm_ue_ctx->p_ue_context->cell_index))
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"Failed to send rrm_rrc_meas_config_req");
			/* COVERITY : RESOURCE LEAK : CID : 54363 fix start */
			RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
			/* COVERITY : RESOURCE LEAK : CID : 54363 fix end*/
			RRM_MEM_FREE(p_rrm_ue_inter_freq_meas_ind);
			/* SPR: 15922 Fix Start */
			ret_val =  RRM_FAILURE;
			/* SPR: 15922 Fix End */

		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"Send rrm_rrc_meas_config_req sucessfully");

		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"No need to send rrm_rrc_meas_config_req sucessfully");
	}
	RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	RRM_UT_TRACE_EXIT();
	/* SPR: 15922 Fix Start */
	return ret_val;
	/* SPR: 15922 Fix End */
}



/****************************************************************************
 * Function Name  : rrm_ue_handle_lipa_ho_required
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the rrm_ue_handle_lipa_ho_required for non_lipa rab 
 *                  indication.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_lipa_ho_required(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et                           ret_val = RRM_SUCCESS;
	RRM_UT_TRACE_ENTER();
	ret_val = rrm_build_and_send_lipa_ho_required(p_g_rrm_ue_ctx->p_ue_context);  

	if(RRM_FAILURE == ret_val)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"Failure received for rrm_ue_handle_lipa_ho_required");
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"rrm_ue_handle_lipa_ho_required is successful");
	} 
	RRM_UT_TRACE_EXIT();  
	return ret_val; 
}


/****************************************************************************
 * Function Name  : rrm_ue_handle_local_error_ind
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the rrm_ue_handle_local_error_ind for local error 
 *                  indication.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_local_error_ind(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et                           ret_val = RRM_SUCCESS;
	rrm_ue_context_t                       *p_ue_context = RRM_PNULL;
	rrm_ue_proc_local_error_ind_t          *p_local_error_ind = RRM_PNULL;
	rrm_ue_erb_t                            ue_erb = {0};

	/*SPR 17513 START*/ 
	U8                                      ngbr_count = RRM_ZERO;
	U8                                      configured_ngbr_count = RRM_ZERO;
	/*SPR 17513 END*/ 
	U8                                       erab_index = RRM_ZERO;
	U8                                       lipa_rab_index = RRM_ZERO;
	rrm_bool_et                              lipa_sipto_erab_release = RRM_FALSE;
	U8                                       err_ind_erb_id = RRM_ZERO;
	U32                                       cause = UNSPECIFIED;
	U8                                        type = RRM_ZERO;
	rrc_rrm_erb_release_ind_t                rrc_rrm_erb_release_ind;
	/* SPR 16331 Fix start */
    /*SPR 22151 Fix Start*/
    /*SPR 18654 START*/
    rrm_prb_t                                dl_prbs_to_release = RRM_ZERO;
    rrm_prb_t                                ul_prbs_to_release = RRM_ZERO;
    /*SPR 18654 START*/
    /*SPR 22151 Fix End*/
	U8                                      qci = RRM_ZERO;
	U64                                     dl_bitrate = RRM_ZERO;
	U64                                     ul_bitrate = RRM_ZERO;
	/* SPR 16331 Fix end */

	RRM_UT_TRACE_ENTER();

	RRM_MEMSET(&rrc_rrm_erb_release_ind, RRM_ZERO,
			sizeof(rrc_rrm_erb_release_ind_t));

	if(p_g_rrm_ue_ctx != RRM_PNULL)
	{
		/* Coverity: CID 42147 */
		p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
		if(RRM_PNULL != p_ue_context )
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					" local error ind is received for UE_INDEX[%d]",p_ue_context->ue_index);

            /*SPR 22151 Fix Start*/
            /*SPR 18654 fix code deleted*/
            /*SPR 22151 Fix End*/

			rrc_rrm_erb_release_ind.ue_index = p_ue_context->ue_index;

			ue_erb.p_rrm_ue_context = p_ue_context;

			p_local_error_ind =(rrm_ue_proc_local_error_ind_t*)
				p_ue_context->current_procedure.p_proc_data;
			if(RRM_PNULL != p_local_error_ind)
			{
				/*SPR 17513 START*/ 
				for (erab_index = RRM_ZERO;
						(erab_index < p_ue_context->drb_configured.num_of_list) &&
						( erab_index < RRM_MAX_NUM_DRB_PER_UE ) ;erab_index++)
				{
					qci = p_ue_context->drb_configured.erab_item[erab_index].erab_level_qos_params.qci;
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							" qci for index[%d]is [%d] ",erab_index,qci);
					if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								" rab is GBR");
					}
					else
					{
						configured_ngbr_count++;
					}
				}
				for(err_ind_erb_id = RRM_ZERO; 
						err_ind_erb_id < p_local_error_ind->erab_id_list.count;
						err_ind_erb_id++)
				{
					for (erab_index = RRM_ZERO;
							(erab_index < p_ue_context->drb_configured.num_of_list) && 
							( erab_index < RRM_MAX_NUM_DRB_PER_UE ) ;erab_index++)
					{

						if(p_ue_context->drb_configured.erab_item[erab_index].erab_id ==
								p_local_error_ind->erab_id_list.erab_id[err_ind_erb_id])
						{
							qci = p_ue_context->drb_configured.erab_item[erab_index].erab_level_qos_params.qci;
							if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
										" rab is GBR");
							}
							else
							{
								ngbr_count++;
							}
							break;
						}
					}
				}

				/*SPR 17513 END*/ 
				switch(p_local_error_ind->cause)
				{
					case RRM_OAM_INITIATED_LGW_DEL:
						cause = CAUSE_MISC_OAM_INTERVENTION;
						type = RRM_S1AP_CAUSE_MISC;
						break;
					case RRM_GTP_ERROR_IND:
					case RRM_GTP_PATH_FAIL:
						cause = UNSPECIFIED_TRANSPORT_RESOURCE;
						type = RRM_T_S1AP_CAUSE_TRANSPORT;
						break;
					default:
						cause = UNSPECIFIED;
						type = RADIO_NETWORK_LAYER_TYPE; 
						break;
				}
				/*SPR 17513 START*/ 
				if(configured_ngbr_count == ngbr_count)
					/*SPR 17513 END*/ 

				{
					/*CID 47684*/
					for(erab_index = RRM_ZERO;
							(erab_index < p_ue_context->drb_configured.num_of_list) &&
							( erab_index < RRM_MAX_NUM_DRB_PER_UE ) ;erab_index++)
					{
						/* Deleting the ue erb info from the priority list*/
						ue_erb.erab_id = p_ue_context->drb_configured.erab_item[erab_index].erab_id;
						/* SPR 15388 Changes Starts */
						rrc_rrm_erb_release_ind.erab_to_be_released_item_list.\
							erab_to_be_release_item[lipa_rab_index].erab_id =
							p_ue_context->drb_configured.erab_item[erab_index].erab_id;

						rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
							erab_to_be_release_item[lipa_rab_index].cause.type = type;

						rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
							erab_to_be_release_item[lipa_rab_index].cause.value = cause;

						lipa_rab_index++;
                        /* CID 97174 +- */
						/* SPR 15388 Changes Ends */

						if(RRM_FAILURE == rrm_ue_delete_erb_entity_per_rab_index(&ue_erb, erab_index))
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
									"UE_INDEX[%d]: Failure received while deletion from erab priority  \
									list", p_ue_context->ue_index);
						}

						/* SPR 16331 Fix start */
						qci = p_ue_context->drb_configured.erab_item[erab_index].erab_level_qos_params.qci;
						if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
						{
							/*GBR LIMIT START */
							dl_bitrate = p_ue_context->drb_configured.erab_item[erab_index].
								erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;
							ul_bitrate = p_ue_context->drb_configured.erab_item[erab_index].
								erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;

							rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, dl_bitrate);
							rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, ul_bitrate);
							/*GBR LIMIT END */
                            /*SPR 22151 Fix Start*/
                            /*SPR 18654 Fix code deleted*/
                            dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,dl_bitrate); 
                            ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,ul_bitrate); 
                            /*SPR 22151 Fix End*/

							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"UE_ID[%d]:erb_id[%d] Deallocating dl_gbr_prbs(%d)",
									p_ue_context->ue_index,
									p_ue_context->drb_configured.erab_item[erab_index].erab_id,
									dl_prbs_to_release);

							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"UE_ID[%d]:erb_id[%d] Deallocating ul_gbr_prbs(%d)",
									p_ue_context->ue_index,
									p_ue_context->drb_configured.erab_item[erab_index].erab_id,
									ul_prbs_to_release);
							rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
							rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
						}
						/* SPR 16331 fix end */
					}
					RRM_MEMSET(&(p_ue_context->drb_configured),
							RRM_ZERO,
							sizeof(rrm_ue_erab_setup_item_list_t));

					if(RRM_FAILURE == rrm_build_and_send_ue_connection_release_ind(
								p_ue_context->ue_index,
								type,
								cause,
								RRM_ZERO,
								RRM_PNULL,
								/* SPR_10729_fix */
								p_ue_context->cell_index))
					{
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
								"unable to send Ue Release Req");
						ret_val = RRM_FAILURE;
					}
					/* SPR 15388 Changes Start */
					else
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
								"send release connection ind send for UE index:%d",
								p_ue_context->ue_index);
						ret_val = RRM_SUCCESS;
						if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
						{
							RRM_TRACE(g_uem_log_on_off,
									p_g_rrm_uem_facility_name,
									RRM_DETAILED,
									"ue_connection_release_ind sent, \
									Failed to clean up ue resources");

							ret_val = RRM_FAILURE;

						}
						RRM_UT_TRACE_EXIT();
						return ret_val;
					}
					/* SPR 15388  Changes Ends */
				}
				else
				{
					for(err_ind_erb_id = RRM_ZERO; 
							err_ind_erb_id < p_local_error_ind->erab_id_list.count;
							err_ind_erb_id++)
					{
						/* CID 54977 */
						for (erab_index = RRM_ZERO;
								(erab_index < p_ue_context->drb_configured.num_of_list) && 
								( erab_index < RRM_MAX_NUM_DRB_PER_UE ) ;erab_index++)
						{
							{
								/*SPR 17513 START*/ 
								/*code deleted*/
								/*SPR 17513 END*/
								if(p_ue_context->drb_configured.erab_item[erab_index].erab_id ==
										p_local_error_ind->erab_id_list.erab_id[err_ind_erb_id])
								{
									rrc_rrm_erb_release_ind.erab_to_be_released_item_list.\
										erab_to_be_release_item[lipa_rab_index].erab_id =
										p_ue_context->drb_configured.erab_item[erab_index].erab_id;

									rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
										erab_to_be_release_item[lipa_rab_index].cause.type = type;

									rrc_rrm_erb_release_ind.erab_to_be_released_item_list.
										erab_to_be_release_item[lipa_rab_index].cause.value = cause;

									/* Deleting the ue erb info from the priority list*/
									ue_erb.erab_id = p_ue_context->drb_configured.erab_item[erab_index].erab_id;

									if(RRM_FAILURE == rrm_ue_delete_erb_entity_per_rab_index(&ue_erb, erab_index))
									{
										RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
												"UE_INDEX[%d]: Failure received while deletion from erab priority  \
												list", p_ue_context->ue_index);
									}

									/* SPR 16331 fix start */
									qci = p_ue_context->drb_configured.erab_item[erab_index].erab_level_qos_params.qci;
									if(qci>=RRM_GBR_QCI_1 && qci <=RRM_GBR_QCI_4)
									{
										/*GBR LIMIT START */
										dl_bitrate = p_ue_context->drb_configured.erab_item[erab_index].
											erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;
										ul_bitrate = p_ue_context->drb_configured.erab_item[erab_index].
											erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;

										rrm_cellm_set_used_dl_bitrate_during_erb_release(p_ue_context->cell_index, dl_bitrate);
										rrm_cellm_set_used_ul_bitrate_during_erb_release(p_ue_context->cell_index, ul_bitrate);
                                        /*GBR LIMIT END */
                                        /*SPR 22151 Fix Start*/
                                        /*SPR 18654 Fix code deleted*/
                                        dl_prbs_to_release = rrm_convert_bitrate_to_prb_dl(p_ue_context->cell_index,dl_bitrate); 
                                        ul_prbs_to_release = rrm_convert_bitrate_to_prb_ul(p_ue_context->cell_index,ul_bitrate); 
                                        /*SPR 22151 Fix End*/

										RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
												"UE_ID[%d]:erb_id[%d] Deallocating dl_gbr_prbs(%d)",
												p_ue_context->ue_index,
												p_ue_context->drb_configured.erab_item[erab_index].erab_id,
												dl_prbs_to_release);

										RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
												"UE_ID[%d]:erb_id[%d] Deallocating ul_gbr_prbs(%d)",
												p_ue_context->ue_index,
												p_ue_context->drb_configured.erab_item[erab_index].erab_id,
												ul_prbs_to_release);

										rrm_cellm_reset_dl_allocated_gbr_prb(p_ue_context->cell_index,dl_prbs_to_release);
										rrm_cellm_reset_ul_allocated_gbr_prb(p_ue_context->cell_index,ul_prbs_to_release);
									}
									/* SPR 16331 fix end */

									if (erab_index ==  (p_ue_context->drb_configured.num_of_list - 1))
									{
										RRM_MEMSET(&p_ue_context->drb_configured.erab_item[erab_index],
												RRM_ZERO,
												sizeof(rrm_ue_erab_setup_item_t));
									}
									else
									{ 
										if(erab_index < (p_ue_context->drb_configured.num_of_list - 1))
										{
											RRM_MEMCPY(&p_ue_context->drb_configured.erab_item[erab_index],
													&p_ue_context->drb_configured.erab_item[p_ue_context->
													drb_configured.num_of_list - 1],
													sizeof(rrm_ue_erab_setup_item_t));
											RRM_MEMSET(&p_ue_context->drb_configured.
													erab_item[p_ue_context->drb_configured.num_of_list - 1],
													RRM_NULL ,sizeof(rrm_ue_erab_setup_item_t));
										}   
									}
									lipa_rab_index++;
									lipa_sipto_erab_release = RRM_TRUE;
									p_ue_context->drb_configured.num_of_list--;
									break;
								}
								/*SPR 17513 START*/ 
								/*Braces deleted*/
								/*SPR 17513 END*/
							}
						}
						/* SPR 17564 Fix Start */
						/* Updating the UE Priority*/
						if ((lipa_rab_index > RRM_ZERO) && 
								(RRM_FALSE == rrm_is_ue_special_previledge (p_ue_context)))
						{
							if (RRM_FAILURE == rrm_ue_update_ue_priority_list(p_ue_context))                
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
										"UE_INDEX[%d]: Failure received while updating the  \
										ue_priority", p_ue_context->ue_index);
							}
						}
						/* SPR 17564 Fix End */
					}


					/* SPR 17564 Fix Start */
					/* Code Removed */
					/* SPR 17564 Fix End */

					if(RRM_TRUE == lipa_sipto_erab_release)
					{
						rrc_rrm_erb_release_ind.erab_to_be_released_item_list.count = lipa_rab_index;
						if(RRM_FAILURE == rrm_build_and_send_lipa_erb_release_ind(
									&rrc_rrm_erb_release_ind, p_ue_context->cell_index))
						{
							RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
									"unable to send Bearer Release Ind");
							ret_val = RRM_FAILURE;
						}
					}
					/* SPR 15441 start */
					/* code removed */
					/* SPR 15441 end */
				}
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"p_local_error_ind is NULL");
				ret_val = RRM_FAILURE;
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"p_ue_context is NULL");
			ret_val = RRM_FAILURE;
		}
	}

	RRM_UT_TRACE_EXIT();   
	return ret_val; 
}


/****************************************************************************
 * Function Name  : rrm_ue_handle_lppa_error_ind
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the rrm_ue_handle_lppa_ecid_meas_termination_cmd for UE Positioing.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_lppa_error_ind(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et                           ret_val = RRM_FAILURE;
	rrm_ue_context_t                       *p_ue_context = RRM_PNULL;
	/* SPR 15441 start */
	/* code removed */
	/* SPR 15441 end */
	RRM_UT_TRACE_ENTER();


	if(p_g_rrm_ue_ctx != RRM_PNULL)
	{
		p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
		if(RRM_PNULL != p_ue_context )
		{
			/* SPR 15441 start */
			/* code removed */
			/* SPR 15441 end */
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					" ECID error is received for UE_INDEX[%d]",p_ue_context->ue_index);
			/* SPR 15441 start */
			/* code removed */
			/* SPR 15441 end */
			ret_val= RRM_SUCCESS;
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"p_ue_context is NULL");
		}
	}
	RRM_UT_TRACE_EXIT();   
	return ret_val; 

}
/****************************************************************************
 * Function Name  : rrm_ue_handle_lppa_ecid_meas_termination_cmd
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the rrm_ue_handle_lppa_ecid_meas_termination_cmd for UE Positioing.
 ****************************************************************************/
	rrm_return_et
rrm_ue_handle_lppa_ecid_meas_termination_cmd(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et                           ret_val = RRM_SUCCESS;
	rrm_ue_context_t                       *p_ue_context = RRM_PNULL;
	rrm_ue_lppa_ecid_meas_termination_cmd_t   *p_rrm_ecid_meas_term_ind = RRM_PNULL;
	rrm_cause_t                             cause = {RRM_ZERO};
	lppa_criticality_diagno_t               cri_diag = {RRM_ZERO};
	U8                                      ue_esmlc_req_index = RRM_MAX_ESMLC_MEAS_ID;


	if(RRM_PNULL != p_g_rrm_ue_ctx )
	{
		p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
		if(RRM_PNULL != p_ue_context )
		{
			p_rrm_ecid_meas_term_ind =(rrm_ue_lppa_ecid_meas_termination_cmd_t*)
				p_ue_context->current_procedure.
				p_proc_data;
			if(RRM_PNULL != p_rrm_ecid_meas_term_ind )
			{
				if( RRM_TRUE == rrm_ue_is_ecid_meas_already_exist (p_ue_context,p_rrm_ecid_meas_term_ind->e_smlc_ue_meas_id,&ue_esmlc_req_index))
				{
                                  /* SPR 21496 Fix Start */ 
					if( p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].ue_pos_timer &&
							p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].ue_meas_send_for_rem == RRM_FALSE)
					{
						/* Stop UE positioing timer for waiting for UE meas_config_req */
						RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name,
								RRM_DETAILED, "UE POsitioing timer"); 
						/* CSR-58333-fix start*/
						rrm_ue_stop_timer( p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].ue_pos_timer);
						/* CSR-58333-fix end*/
						p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].ue_pos_timer = RRM_PNULL;
					}
					if( (p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD))
					{
						if(RRM_LPPA_PERIODIC ==  p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].report_type)
						{
							rrm_ue_meas_config_remove_for_ecid(p_ue_context,
									ue_esmlc_req_index,
									RRM_FALSE);
							p_ue_context->p_ue_positioing_data[ue_esmlc_req_index].ue_meas_send_for_rem=RRM_TRUE;
							rrm_clean_ue_ecid_meas_related_info(p_ue_context,ue_esmlc_req_index);
						}
						else
						{
							rrm_ue_delete_meas_id_info_for_ecid_meas(p_ue_context, ue_esmlc_req_index);
							rrm_clean_ue_ecid_meas_related_info(p_ue_context,ue_esmlc_req_index);
						}
					}
					else
					{
						rrm_clean_ue_ecid_meas_related_info(p_ue_context,ue_esmlc_req_index);
					}
                                        /* SPR 21496 Fix End */ 
				}
				else
				{
					cause.type  = RRM_ECID_PROTOCOL_CAUSE;
					cause.value = RRM_PC_MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE;
					rrm_build_and_send_ecid_meas_error_req(p_ue_context->ue_index,
							p_ue_context->cell_index,
							p_rrm_ecid_meas_term_ind->mme_id,
							p_rrm_ecid_meas_term_ind->routing_id,
							p_rrm_ecid_meas_term_ind->lppa_trans_id,
							cause , cri_diag);

				}
				/* SPR 15441 start */
				/* code removed */
				/* SPR 15441 end */
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"p_ue_context is NULL");
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_get_ecid_meas_timer_type
 * Inputs         : U8 ecid_meas_index.
 * Outputs        : None
 * Returns        : rrm_ue_timer_type_et
 * Description    : Return timer_type coresspoding to ecid_meas_index .
 ****************************************************************************/
	rrm_ue_timer_type_et
rrm_get_ecid_meas_timer_type(
		U8                   esmlc_meas_id 
		)
{
	rrm_ue_timer_type_et    ecid_meas_timer_type = RRM_UE_MAX_TIMER_ID;
	RRM_UT_TRACE_ENTER();

	switch(esmlc_meas_id)
	{
		case RRM_ZERO:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_1;
			break;
		case RRM_ONE:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_2;
			break;
		case RRM_TWO:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_3;
			break;
		case RRM_THREE:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_4;
			break;
		case RRM_FOUR:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_5;
			break;
		case RRM_FIVE:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_6;
			break;
		case RRM_SIX:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_7;
			break;
		case RRM_SEVEN:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_8;
			break;
		case RRM_EIGHT:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_9;
			break;
		case RRM_NINE:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_10;
			break;
		case RRM_TEN:
			ecid_meas_timer_type =RRM_UE_ECID_MEAS_TIMER_11; 
			break;
		case RRM_ELEVEN:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_12;
			break;
		case RRM_TWELVE:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_13; 
			break;
		case RRM_THIRTEEN:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_14;
			break;
		case RRM_FOURTEEN:
			ecid_meas_timer_type = RRM_UE_ECID_MEAS_TIMER_15; 
			break;
		default:
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"not of any valid esmlc_meas_id %d",
					esmlc_meas_id);
	}
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
			"ESMLC meas id is %d and thus ECID meas timer type is %d",
			esmlc_meas_id, ecid_meas_timer_type);

	RRM_UT_TRACE_EXIT();
	return ecid_meas_timer_type;
}
/* Coverity_ID : 55182 start */
/****************************************************************************
 * Function Name  : rrm_get_meas_priodicity_in_ms
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : U32
 * Description    : Return the time interval in MS .
 ****************************************************************************/
	U32
rrm_get_meas_priodicity_in_ms(
		rrm_lppa_meas_peridicity_et          report_interval
		)
{
	U32  timer_duration =RRM_ZERO;
	U32  buffer_time = RRM_MEAS_REPORT_PERIODICITY_BUFFER;
	RRM_UT_TRACE_ENTER();

	switch(report_interval)
	{
		case RRM_LPPA_MS120:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_120 + buffer_time;
			break;
		case RRM_LPPA_MS240:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_240 + buffer_time;
			break;
		case RRM_LPPA_MS480:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_480 + buffer_time;
			break;
		case RRM_LPPA_MS640:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_640 + buffer_time;
			break;
		case RRM_LPPA_MS1024:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_1024 + buffer_time;
			break;
		case RRM_LPPA_MS2048:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_2048 + buffer_time;
			break;
		case RRM_LPPA_MS5120:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_5120 + buffer_time;
			break;
		case RRM_LPPA_MS10240:
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_10240 + buffer_time;
			break;
		case RRM_LPPA_MSMIN1:
			/*convert minute to mili-second*/
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_MIN_1 + buffer_time;
			break;
		case RRM_LPPA_MSMIN6:
			/*convert minute to mili-second*/
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_MIN_6 + buffer_time;
			break;
		case RRM_LPPA_MSMIN12:
			/*convert minute to mili-second*/
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_MIN_12 + buffer_time;
			break;
		case RRM_LPPA_MSMIN30:
			/*convert minute to mili-second*/
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_MIN_30 + buffer_time;
			break;
		case RRM_LPPA_MSMIN60:
			/*convert minute to mili-second*/
			timer_duration = RRM_MEAS_REPORT_PERIODICITY_MIN_60 + buffer_time;
			break;
		default:
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
					"Not of any valid periodicity %d",
					report_interval);

	}
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
			"Report Interval is %d and thus timer duration is %d",
			report_interval, timer_duration);

	RRM_UT_TRACE_EXIT();
	return timer_duration;
}
/* Coverity_ID : 55182 end */
/****************************************************************************
 * Function Name  : rrm_ue_is_ecid_meas_already_exist
 * Inputs         : p_ue_context ,esmlc_meas_id, p_ue_esmlc_req_index
 * Outputs        : None
 * Returns        : RRM_TRUE if E-SMLC request is already registered else RRM_FALSE. 
 * Description    : Determine is E-SMLC meas request is already registered with the received esmlc_meas_id.
 ****************************************************************************/
	rrm_bool_et
rrm_ue_is_ecid_meas_already_exist(
		rrm_ue_context_t               *p_ue_context,
		U32                             esmlc_meas_id,
		U8                             *p_ue_esmlc_req_index
		)
{
	rrm_bool_et   ret_val = RRM_FALSE;
	U8            index   = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
	if(p_ue_context != RRM_PNULL &&
			p_ue_esmlc_req_index != RRM_PNULL)
	{
		for(index=RRM_ZERO; index < RRM_MAX_ESMLC_MEAS_ID; index++)
		{
                  /* SPR 21496 Fix Start */ 
			if((p_ue_context->p_ue_positioing_data[index].e_smlc_ue_meas_id     == esmlc_meas_id) &&      
					(p_ue_context->p_ue_positioing_data[index].ecid_meas_req_received == RRM_TRUE))
                          /* SPR 21496 Fix End */ 
			{
				ret_val= RRM_TRUE;
				*p_ue_esmlc_req_index = index;
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
						"requested esmlc meas[%d] is already registered at index[%d] for UE[%d]",
						esmlc_meas_id,index, p_ue_context->ue_index);
				break;
			}

		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
				"p_ue_context or p_ue_esmlc_req_index is NULL");
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ue_process_meas_resp_for_ue_pos
 * Inputs         : p_rrm_ue_context, meas_id, ecid_meas_resp_action
 * Outputs        : None
 * Returns        : None
 * Description    : Process the meas response for meas request triggered for ECID meas
 ****************************************************************************/
	rrm_void_t
rrm_ue_process_meas_resp_for_ue_pos(
		rrm_ue_context_t         *p_rrm_ue_context,
		U8                        meas_id,
		rrm_meas_ecid_resp_et     ecid_meas_resp_action)
{
	U8            index                           = RRM_ZERO;
	U8            ecid_meas_index                 = RRM_ZERO;
	rrm_bool_et   meas_resp_mapped_with_ecid_meas = RRM_FALSE;
	rrm_cause_t   cause = {RRM_ZERO};
	S32           time_diff_in_meas_config_req_and_resp = RRM_ZERO;
	RRM_TIME_T    current_time ={RRM_ZERO};
	/*SPR_8004:fix_start*/
	U8 index_for_meas_id = RRM_ZERO;
	/*SPR_8004:fix_end */

	RRM_UT_TRACE_ENTER();
	if(RRM_PNULL != p_rrm_ue_context)
	{
		for(index = RRM_ZERO; index < RRM_MAX_ESMLC_MEAS_ID ;index ++)
		{
                  /* SPR 21496 Fix Start */ 
			/*SPR_8004:fix_start */
			if(p_rrm_ue_context->p_ue_positioing_data[index].ecid_meas_req_received == RRM_TRUE)
                          /* SPR 21496 Fix End */ 
			{
				for(index_for_meas_id = RRM_ZERO; index_for_meas_id <MAX_ALLOCATED_ID_FOR_ECID  ;index_for_meas_id ++)
				{
                                  /* SPR 21496 Fix Start */ 
					if((p_rrm_ue_context->p_ue_positioing_data[index].meas_id_and_meas_obj_id[index_for_meas_id].\
								meas_id == meas_id))
                                          /* SPR 21496 Fix End */ 
					{
						meas_resp_mapped_with_ecid_meas = RRM_TRUE;
						break;
					}
				}
				ecid_meas_index =index;
			}
			/*SPR_8004:fix_changes_end */
		}
		if(RRM_TRUE == meas_resp_mapped_with_ecid_meas)
		{
			if((RRM_ECID_MEAS_DELETE        == ecid_meas_resp_action ) ||
					(RRM_ECID_MEAS_DELETE_FAILED == ecid_meas_resp_action ) ||
					(RRM_ECID_MEAS_FAILED == ecid_meas_resp_action))
			{
                          /* SPR 21496 Fix Start */ 
				if(p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD)
				{
					rrm_ue_delete_meas_id_info_for_ecid_meas(p_rrm_ue_context, ecid_meas_index);
				}
				/*  In case of meas req failed, send the ecid_failure */
				if (RRM_ECID_MEAS_FAILED == ecid_meas_resp_action)
				{
					cause.type = RRM_ECID_RADIO_NW_LAYER_CAUSE;
					cause.value  = RRM_RNL_REQUESTED_ITEM_TEMPORARILLY_NOT_AVAILABLE;
					rrm_build_and_send_ecid_meas_failure(p_rrm_ue_context->ue_index, 
							p_rrm_ue_context->cell_index,
							p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].mme_id,
							p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].routing_id,
							p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].lppa_trans_id,
							p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id,cause);
					/* If meas req failed, then stop the ecid meas timer for this */ 
					if( p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_pos_timer &&
							p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_send_for_rem == RRM_FALSE)
					{
						/* Stop UE positioing timer for waiting for UE meas_config_req */
						RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE POsitioing timer");
						/* CSR-58333-fix start*/
						rrm_ue_stop_timer( p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_pos_timer);
						/* CSR-58333-fix end*/
						p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_pos_timer = RRM_PNULL;
					}
				}
				rrm_clean_ue_ecid_meas_related_info(p_rrm_ue_context, ecid_meas_index);
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Reset the ESMLC_MEAS_REQ[%d] info for U_INDEX[%d]",
						ecid_meas_index,p_rrm_ue_context->ue_index);
			}
			else
			{
				rrm_build_and_send_ecid_meas_response(p_rrm_ue_context,ecid_meas_index);
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"ECID meas response sent for UE_INDEX[%d]",
						p_rrm_ue_context->ue_index);
				if(p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)
				{
					current_time = rrm_get_system_time();
					time_diff_in_meas_config_req_and_resp = rrm_time_diff(&current_time,
							&(p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].ue_meas_config_sent_time));
					if(time_diff_in_meas_config_req_and_resp < RRM_ZERO)
					{
						time_diff_in_meas_config_req_and_resp = RRM_ZERO;
					}

					if(RRM_FAILURE ==  rrm_build_and_send_mac_ecid_meas_report_req(p_rrm_ue_context,
								time_diff_in_meas_config_req_and_resp))
					{
						RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
								"MAC EC_CID request failured for esmlc_meas_id =%d for ue_index[%d]",
								p_rrm_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id,
								p_rrm_ue_context->ue_index);
					}
				}
			}
                        /* SPR 21496 Fix End */ 
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Meas response is not mapped with \
					ECID meas req for UE_INDEX[%d]", p_rrm_ue_context->ue_index);
		}
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"UE context is NULL");
	}

	RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_ue_store_ue_meas_results_in_ue_context
 * Inputs         : p_ue_meas_results
 : p_ue_context
 : ecid_meas_req_index
 * Outputs        : None
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function stores the UE meas results in the UE context
 *                  so that they can be collectively sent with MAC results 
 *                  in ECID_MEAS_REPORT later on.
 ****************************************************************************/
	rrm_return_et
rrm_ue_store_ue_meas_results_in_ue_context(
		rrm_ue_measurment_results_ind_t  *p_ue_meas_results,
		rrm_ue_context_t                 *p_ue_context,
		U8                                ecid_meas_req_index
		)
{
	rrm_return_et         ret_val = RRM_SUCCESS;
	U8                    index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

        /* SPR 21496 Fix Start */ 
	/* Initialising the UE meas params in UE context to zero - start */
	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_serv_cell.rsrp_result = RRM_ZERO;
	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_serv_cell.rsrq_result = RRM_ZERO;

	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_count = RRM_ZERO;

	for(index = RRM_ZERO; index < p_ue_meas_results->eutran_count; index++)
	{
		p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].pci = RRM_ZERO;
		p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].rsrp = RRM_ZERO;
		p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].rsrq = RRM_ZERO;
	}

	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_ecid_r9.ue_rxtx_time_diff = RRM_ZERO;
	for(index=RRM_ZERO; index<ECID_CURRENT_SFN_OCTET_SIZE; index++)
	{
		p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_ecid_r9.current_sfn_r9[index] = RRM_ZERO;
	}
	/* Initialising the UE meas params in UE context to zero - end */

	/* Populating the UE context params with latest values */
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
			"Filling serving cell info from meas results ind in UE context for UE_INDEX[%d]",
			p_ue_context->ue_index);

	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_serv_cell.rsrp_result = 
		p_ue_meas_results->meas_result_serv_cell.rsrp_result;
	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_serv_cell.rsrq_result = 
		p_ue_meas_results->meas_result_serv_cell.rsrq_result;

	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
			"Filling neighbour cell info from meas results ind in UE context for UE_INDEX[%d]",
			p_ue_context->ue_index);

	if(p_ue_meas_results->eutran_count)
	{
		p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_count = 
			p_ue_meas_results->eutran_count;

		for(index = RRM_ZERO; index<p_ue_meas_results->eutran_count; index++)
		{
			p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].pci = 
				p_ue_meas_results->eutran_neighbor_list[index].pci;

			p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].rsrp = 
				p_ue_meas_results->eutran_neighbor_list[index].rsrp;

			p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].rsrq = 
				p_ue_meas_results->eutran_neighbor_list[index].rsrq;
		}
	}

	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
			"Filling meas_result_ecid_r9 info from meas results ind in UE context for UE_INDEX[%d]",
			p_ue_context->ue_index);

	p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_ecid_r9.ue_rxtx_time_diff = 
		p_ue_meas_results->meas_result_ecid_r9.ue_rxtx_time_diff;

	for(index=RRM_ZERO; index<ECID_CURRENT_SFN_OCTET_SIZE; index++)
	{
		p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_ecid_r9.current_sfn_r9[index] = 
			p_ue_meas_results->meas_result_ecid_r9.current_sfn_r9[index];
	}

        /* SPR 21496 Fix End */ 
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/********************************************************************************
 * Function Name  : rrm_build_and_send_mac_ecid_meas_report_req
 * Inputs         : p_ue_context, ue_started_meas_time_in_ms
 * Outputs        : none
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function builds and sends the ecid meas report req to MAC
 *********************************************************************************/
	rrm_return_et
rrm_build_and_send_mac_ecid_meas_report_req(
		rrm_ue_context_t            *p_ue_context,
		S32                         ue_started_meas_time_in_ms 
		)
{
	rrm_return_et                   ret_val = RRM_SUCCESS;
	RrmMacEcidMeasConfigReq  rrm_mac_ecid_meas_report_req = {RRM_ZERO};  
	U16                             transaction_id = RRM_ZERO;
	U8                              index= RRM_ZERO;
	U8                              esmlc_meas_id = RRM_ZERO;
	rrm_bool_et                     aoa_required=RRM_FALSE;
	rrm_bool_et                     ta1_required=RRM_FALSE;
	rrm_bool_et                     ta2_required=RRM_FALSE;
	rrm_cell_context_t              *p_cell_context=RRM_PNULL;
	U32                              drx_cycle_period_in_ms = RRM_ZERO;
	U32                              enb_rx_tx_measure_time_in_ms = RRM_ZERO; 

	RRM_UT_TRACE_ENTER();

	if((p_ue_context != RRM_PNULL))
	{
		for (index= RRM_ZERO;index< RRM_MAX_ESMLC_MEAS_ID;index++)
		{
                  /* SPR 21496 Fix Start */ 
			if((p_ue_context->p_ue_positioing_data[index].ecid_meas_req_received == RRM_TRUE) &&
					(p_ue_context->p_ue_positioing_data[index].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD ))
			{
				esmlc_meas_id = p_ue_context->p_ue_positioing_data[index].e_smlc_ue_meas_id;
				if(p_ue_context->p_ue_positioing_data[index].ta1_ta2_aoa_req & RRM_ECID_MAC_TA1_REQD)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
							"TA1 is required for index =%d for UE_INDEX[%d]", 
							index,
							p_ue_context->ue_index);
					ta1_required = RRM_TRUE;
				}
				if(p_ue_context->p_ue_positioing_data[index].ta1_ta2_aoa_req & RRM_ECID_MAC_TA2_REQD)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
							"TA2 is required for index =%d for UE_INDEX[%d]", 
							index,
							p_ue_context->ue_index);
					ta2_required = RRM_TRUE;
				}
				if(p_ue_context->p_ue_positioing_data[index].ta1_ta2_aoa_req & RRM_ECID_MAC_AOA_REQD)
				{
					RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
							"AOA is required for index =%d for UE_INDEX[%d]", 
							index,
							p_ue_context->ue_index);
					aoa_required = RRM_TRUE;
				}
			}
                        /* SPR 21496 Fix End */ 
		}
		if(ta1_required == RRM_TRUE || ta2_required == RRM_TRUE || aoa_required == RRM_TRUE)
		{
			rrm_mac_ecid_meas_report_req.ueIndex = p_ue_context->ue_index;

			rrm_mac_ecid_meas_report_req.eCidMeasId = esmlc_meas_id;

			if(aoa_required)
			{

				rrm_mac_ecid_meas_report_req.AoARequested = RRM_ONE;

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"Angle of Arrival is requested in rrm_mac_ecid_meas_report_req for UE_INDEX[%d]", 
						p_ue_context->ue_index);
			}

			if(ta1_required)
			{
				rrm_mac_ecid_meas_report_req.type1_eNBRxTxRequested = RRM_ONE;                    
				p_cell_context = rrm_cellm_get_cell_context( p_ue_context->cell_index);
				if(p_cell_context == RRM_PNULL)
				{
					return RRM_FAILURE;
				}

				/* SPR 10450 Fix Start */
				drx_cycle_period_in_ms = rrm_get_drx_cycle_period(p_ue_context->cell_index,p_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index);
				/* SPR 10450 Fix End */

				/* 
				 ** Set the target SFN for enb rx-tx (drx_cycle_period_in_ms - (time taken in receiving in meas_config_resp + no of SFN before when UE will measure)
				 ** time taken in receiving in meas_config_resp = (time when meas_config_req received  - time when meas_config_resp sent)/2
				 */
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"To set targetSFNForeNBRxTx ,drx_cycle_period_in_ms=%d  ue_started_meas_time_in_ms =%d, mac_ecid_meas_start_sfn =%d for UE_INDEX[%d]",
						drx_cycle_period_in_ms,
						(U32)ue_started_meas_time_in_ms,
						p_cell_context->mac_ecid_meas_start_sfn,
						p_ue_context->ue_index);
				if( (((U32)ue_started_meas_time_in_ms/RRM_TWO) + (p_cell_context->mac_ecid_meas_start_sfn * RRM_TEN))< drx_cycle_period_in_ms)
				{
					enb_rx_tx_measure_time_in_ms = 
						(U16) (drx_cycle_period_in_ms - (((U32)ue_started_meas_time_in_ms/RRM_TWO) + (p_cell_context->mac_ecid_meas_start_sfn * RRM_TEN)));
					if( enb_rx_tx_measure_time_in_ms == RRM_ZERO)
					{
						enb_rx_tx_measure_time_in_ms = (p_cell_context->mac_ecid_meas_start_sfn * RRM_TEN);
					}
				}
				else
				{
					enb_rx_tx_measure_time_in_ms = (p_cell_context->mac_ecid_meas_start_sfn * RRM_TEN);
				}
				rrm_mac_ecid_meas_report_req.targetSFNForeNBRxTx = enb_rx_tx_measure_time_in_ms/RRM_TEN;

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"Type1 eNodeB RxTx Difference is requested at targetSFNForeNBRxTx=%d in rrm_mac_ecid_meas_report_req for UE_INDEX[%d]", 
						rrm_mac_ecid_meas_report_req.targetSFNForeNBRxTx,
						p_ue_context->ue_index);
			}
			if(ta2_required)
			{
				rrm_mac_ecid_meas_report_req.type2_eNBRxTxRequested = RRM_ONE;

				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
						"Type2 eNodeB RxTx Difference is requested in rrm_mac_ecid_meas_report_req for UE_INDEX[%d]", 
						p_ue_context->ue_index);
			}
			transaction_id = rrm_generate_txn_id();

			ret_val = rrm_send_mac_ecid_meas_report_req(&rrm_mac_ecid_meas_report_req, RRM_MODULE_ID, transaction_id, p_ue_context->cell_index);

			if(RRM_FAILURE == ret_val)
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
						"Failed to Send to RRM_MAC_ECID_MEAS_REPORT_REQ to L2");
			}
			else
			{
				p_ue_context->is_mac_req_initiated = RRM_TRUE;
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
						" Sent RRM_MAC_ECID_MEAS_REPORT_REQ to L2");
			}
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/********************************************************************************
 * Function Name  : rrm_send_mac_ecid_meas_report_req
 * Inputs         : rrm_mac_ecid_meas_report_req_t  *p_rrm_mac_ecid_meas_report_req
 *                : U16 src_module_id
 *                : U16 transaction_id
 *                : U8  cell_index
 * Outputs        : None
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : Sends RRM_MAC_ECID_MEAS_REPORT_REQ to MAC
 ********************************************************************************/
	rrm_return_et 
rrm_send_mac_ecid_meas_report_req(
		RrmMacEcidMeasConfigReq  *p_rrm_mac_ecid_meas_report_req, /* Pointer to API specific information. */
		U16                              src_module_id,                  /* Source module identifier */
		U16                              transaction_id,                 /* Interface transaction identifier */
		U8                               cell_index                      /* cell_index */
		)
{
	U16 msg_length     = RRM_ZERO;
	U16 msg_api_length = RRM_ZERO;
	U8 *p_mac_msg = RRM_PNULL;
	U8 *p_msg = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	msg_length = sizeof(RrmMacEcidMeasConfigReq);
	msg_api_length = msg_length + RRM_API_HEADER_SIZE + RRM_INTERFACE_API_HEADER_SIZE;

	/* Allocate buffer */
	p_msg = rrm_msg_mem_get(msg_api_length);

	if (p_msg == RRM_PNULL)
	{
		/* Not enough memory */
		return RRM_FAILURE;
	}
	p_mac_msg = p_msg;
	RRM_MEMSET(p_mac_msg, RRM_ZERO, msg_api_length);

	/* Fill CSPL header */
	rrm_construct_api_header(p_mac_msg, RRM_VERSION_ID, src_module_id,
			MAC_MODULE_ID, RRM_MAC_E_CID_MEAS_CONFIG_REQ, msg_api_length);

	p_mac_msg = p_mac_msg + RRM_API_HEADER_SIZE;

	/* Fill interface header */
	/*
	 ** Multiple cell support, Passing a valid cell_index if multiple cell support
	 ** is enabled, otherwise passing 0 in cell_index.
	 */
	/*SPR 20856 Start*/
	rrm_construct_interface_api_header(p_mac_msg, transaction_id, src_module_id,
			MAC_MODULE_ID, RRM_MAC_E_CID_MEAS_CONFIG_REQ, msg_length, cell_index);
	/*SPR 20856 End*/
	p_mac_msg = p_mac_msg + RRM_INTERFACE_API_HEADER_SIZE;

	RRM_MEMCPY(p_mac_msg, p_rrm_mac_ecid_meas_report_req, sizeof(RrmMacEcidMeasConfigReq));

	/* Send message to MAC */
	rrm_send_message(p_msg, MAC_MODULE_ID);
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}
/* UE Positioning code end */

/*DYNAMIC ICIC START*/
/****************************************************************************
 * Function Name  : rrm_rollback_ue_dynamic_icic_data 
 * Inputs         : rrm_ue_context_t ue context.
 * Outputs        : None
 * Returns        : None
 * Description    : This function rollbacks the Dynamic ICIC data with the values 
 *                  of the last successful UE reconfig/attach.
 ****************************************************************************/
rrm_void_t
rrm_rollback_ue_dynamic_icic_data
( 
 rrm_ue_context_t *p_rrm_ue_context
 )
{
	RRM_UT_TRACE_ENTER();
	p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data =
		p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_past_data;

	p_rrm_ue_context->dynamic_icic_info.ue_reconfig_rollback_flag = RRM_FALSE;
	/* SPR 8488 FIX START */
	p_rrm_ue_context->dynamic_icic_info.location_update_req_for_ue_reconfig = RRM_FALSE;
	/* SPR 8488 FIX END */

	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_commit_ue_dynamic_icic_data 
 * Inputs         : rrm_ue_context_t ue context.
 * Outputs        : None
 * Returns        : None
 * Description    : This function updates the Dynamic ICIC data and commit 
 *                  the same in the past data also.
 ****************************************************************************/
rrm_void_t
rrm_commit_ue_dynamic_icic_data
( 
 rrm_ue_context_t *p_rrm_ue_context
 )
{
	RRM_UT_TRACE_ENTER();

	/* 
	 ** Update the UE's P_A related info
	 */
	/*SPR 7892 FIX START*/
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
			"SUCCESS is received UE reconf resp from L3 after P_A is reconfigured, Commit the new P_A");
	p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_past_data.p_a_configured =
		p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured;

	p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_past_data.last_p_a_updated_type=
		p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_p_a_updated_type;

	/*SPR 7892 FIX END*/
	/* 
	 ** Update the timestamp for the successful UE reconfiguration.
	 */
	p_rrm_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_time_ue_reconfigured = rrm_get_system_time(); 

	/* 
	 ** Commit the dynamic ICIC data of successful ue reconfiguration
	 ** in the both the "past" data and "present" data for the UE.
	 */
	/* 
	 ** Reset the rollback flag for the next ue reconfig.
	 */
	p_rrm_ue_context->dynamic_icic_info.ue_reconfig_rollback_flag = RRM_FALSE;

	RRM_UT_TRACE_EXIT();
}

/*DYNAMIC ICIC END*/
/*SPR-695 Fix Starts*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_low_priority_ue_rel_event 
 * Inputs         : rrm_ue_global_context_t p_g_rrm_ue_ctx
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE 
 * Description    : This function handles low priority ue release event  
 ****************************************************************************/
rrm_return_et rrm_ue_handle_low_priority_ue_rel_event
(       
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )       
{
	rrm_return_et               ret_val         = RRM_SUCCESS;
	rrm_ue_index_t              ue_index        = RRM_ZERO;
	rrm_ue_context_t            *p_ue_context   = p_g_rrm_ue_ctx->p_ue_context;
	U16                         trans_id        = p_g_rrm_ue_ctx->trans_id;

	RRM_UT_TRACE_ENTER();

	ue_index = p_ue_context->ue_index;

	if (RRM_NO_ACTN_ON_UE == p_ue_context->action_triggered)
	{
		ret_val= rrm_build_and_send_ue_connection_release_ind(
				ue_index,
				RADIO_NETWORK_LAYER_TYPE,
				REDUCE_LOAD_IN_SERVING_CELL,
				trans_id,
				/*SPR-11368 Fix Starts*/
				RRM_PNULL,
				/*SPR-11368 Fix End*/
				/* SPR_10729_fix */
				p_ue_context->cell_index);
		p_ue_context->action_triggered = RRM_REL_ACTN_ON_UE;
	}
	else
	{
		ret_val = RRM_FAILURE;
	}

	if (ret_val == RRM_FAILURE)
	{
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
				"Error in sending UE release indication for ue index:%d" , ue_index);
	}
	else
	{
		if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
		{
			RRM_TRACE(g_uem_log_on_off,
					p_g_rrm_uem_facility_name,
					RRM_DETAILED,
					"ue_connection_release_ind sent, \
					Failed to clean up ue resources");
			ret_val = RRM_FAILURE;
		}
	}
	return ret_val;
}
/*SPR-695 Fix Ends*/
/* SPR 12512 Fix Start */

/* SPR_16053_Fix: Start */
/****************************************************************************
 * Function Name  : rrm_uem_check_cgi_reports_pending
 * Inputs         : p_rrm_ue_ctx
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Check if any CGI report is pending on the UE or not
 ****************************************************************************/
	rrm_bool_et
rrm_uem_check_cgi_reports_pending(rrm_ue_context_t* p_rrm_ue_ctx)
{
	rrm_bool_et              is_cgi_report_pending = RRM_FALSE;
	YLNODE*                  p_node                = RRM_PNULL;
	meas_report_info_node_t* p_meas_report_node    = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	p_node = ylFirst(&(p_rrm_ue_ctx->meas_report_list));

	while (p_node)
	{
		p_meas_report_node = (meas_report_info_node_t*)p_node;
		p_node = ylNext(p_node);

		if(p_meas_report_node->reporting_event == MEAS_REP_EVENT_FOR_CGI)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"CGI Report is Pending for meas id = %u",
					p_meas_report_node->meas_id);
			is_cgi_report_pending = RRM_TRUE;
			break;
		}
	}

	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING, "is_cgi_report_pendin = %u", is_cgi_report_pending);

	RRM_UT_TRACE_EXIT();
	return is_cgi_report_pending;
}

/****************************************************************************
 * Function Name  : rrm_check_if_node_is_meas_config
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Function to check if the first pending request is for CGI or not.
 *                  It returns TRUE if a nod is found else return FALSE
 ****************************************************************************/
	rrm_bool_et
rrm_check_if_node_is_meas_config(
		rrm_ue_context_t *p_ue_context
		)
{
	rrm_ue_procedure_record_t *p_rrm_ue_procedure_record = RRM_PNULL;

	YLNODE *first_node = ylFirst(&(p_ue_context->procedure_queue));

	RRM_UT_TRACE_ENTER();
	p_rrm_ue_procedure_record = (rrm_ue_procedure_record_t*)YMEMBEROF
		(rrm_ue_procedure_record_t, s_node, first_node);

	if(RRM_PNULL != p_rrm_ue_procedure_record)
	{
		if (p_rrm_ue_procedure_record->proc_queue.api_id == RRC_RRM_MEAS_CONFIG_REQ)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					"First Node in the Procedural Queue is Measurement Config");
			RRM_UT_TRACE_EXIT();
			return RRM_TRUE;

		}
	}
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
			"First Node in the Procedural Queue is not Measurement Config");
	RRM_UT_TRACE_EXIT();
	return RRM_FALSE;
}

/****************************************************************************
 * Function Name  : rrm_check_is_next_queued_api_meas_config
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function checks if next pending request is for the CGI
 *                  or not. If it is for the CGI then function returns TRUE
 *                  else it returns FALSE
 ****************************************************************************/
	rrm_bool_et
rrm_check_is_next_queued_api_meas_config(
		rrm_ue_context_t                   *p_ue_context)
{
	rrm_bool_et              ret_val = RRM_FALSE;
	RRM_UT_TRACE_ENTER();
	if (rrm_get_queue_count(&p_ue_context->procedure_queue))
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				"UE Index[%d], Procedural queue is not empty.",
				p_ue_context->ue_index);
		if(RRM_TRUE == rrm_check_if_node_is_meas_config(p_ue_context))
		{
			ret_val = RRM_TRUE;
		}
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_check_is_meas_config_in_status_to_be_delete
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Check if there is any strongest cell measurement pending on
 *                  the UE or not. If measurement is pending then function returns FALSE else it
 *                  returns TRUE
 ****************************************************************************/
	rrm_bool_et
rrm_check_is_meas_config_in_status_to_be_delete(
		rrm_ue_context_t                   *p_ue_context
		)
{
	rrm_bool_et     ret_val = RRM_FALSE;
	U8              count   = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
	/* SPR 16053 start */
	for( count = RRM_ZERO; count < RRM_ANR_MAX_MEAS_OBJ; count++ )
	{
		if((p_ue_context->p_meas_config[count].meas_config_status == RRM_MEAS_CONFIG_RESP_SUCCESS) &&
				(p_ue_context->p_meas_config[count].report_counter != RRM_ZERO))
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"All reports from meas_id [%d] has not been received", (count+1));
			ret_val = RRM_TRUE;
			break;
		}
	}
	/* SPR 16053 end */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* SPR_16053_Fix: End */

/****************************************************************************
 *  * Function Name  : rrm_ue_handle_ue_sync_status_ind_event
 *   * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 *    * Outputs        : None
 *     * Returns        : RRM_SUCCESS/RRM_FAILURE
 *      * Description    : Handles the rrm_ue_handle_ue_sync_status_ind_event .
 *       ****************************************************************************/
	rrm_return_et
rrm_ue_handle_ue_sync_status_ind_event(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et                           ret_val = RRM_FAILURE;
	rrm_ue_context_t                       *p_ue_context = RRM_PNULL;
	rrm_ue_sync_staus_ind_data_t           *p_ue_sync_status= RRM_PNULL;
	RRM_UT_TRACE_ENTER();


	if(p_g_rrm_ue_ctx != RRM_PNULL)
	{
		p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
		if(RRM_PNULL != p_ue_context )
		{
			p_ue_sync_status  =(rrm_ue_sync_staus_ind_data_t *)
				p_ue_context->current_procedure.
				p_proc_data;
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					" UE SYNC STATUS is received for UE_INDEX[%d]",p_ue_context->ue_index);
			if(p_ue_sync_status->ue_sync_status == RRM_UE_OUT_OF_SYNC_INITIAL ||
					p_ue_sync_status->ue_sync_status == RRM_UE_OUT_OF_SYNC_MAX_RETRIES)
			{
				/* UE is out of sync */
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						" Will reconfig UE with SR/CQI/SRS config when IN_SYNC will be received for UE_INDEX[%d]",p_ue_context->ue_index);
			}
            /*SPR 20137 Start*/
            /* Condition to check whether already reconfig UE with
             *              * SR/CQI/SRS config ongoing on reception of IN_SYNC */
            else if (RRM_TRUE != p_ue_context->ue_sync_status_ind)
                /*SPR 20137 Stop*/
			{
				/* SPR 16187 fix start */
				if ((p_ue_context->current_procedure.state == RRM_UE_MEAS_CONFIG_REQ_ONGOING) ||
						(p_ue_context->current_procedure.state == RRM_UE_ERB_NULL))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"Reconfig UE with SR/CQI/SRS config when IN_SYNC will be received for UE_INDEX[%d], current_procedure.state = %u",
							p_ue_context->ue_index,
							p_ue_context->current_procedure.state);
					/* SPR 16187 fix end */

					/* UE is in in-sync  so reconfig the UE for SR, CQI and SRS  */
					rrm_build_and_send_ue_reconfig_req_on_ue_insync(p_ue_context);
                    p_ue_sync_status = RRM_PNULL;
                    /*SPR 20137 Start*/
                    p_ue_context->ue_sync_status_ind = RRM_TRUE;
                    /*SPR 20137 Stop*/
					/* SPR 15441 start */
					/* code removed */
					/* SPR 15441 end */
				}
				else
				{
					/* SPR 16187 fix start */
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
							"UE_INDEX[%d], Current procedure[%u] is not ERB NULL, enqueue message for the UE",
							p_ue_context->ue_index, p_ue_context->current_procedure.state);
					/* SPR 16187 fix end */
					rrm_ue_procedure_queue_t    proc_queue;
					proc_queue.api_id = p_g_rrm_ue_ctx->api_id;
					proc_queue.p_proc_data = p_ue_context->current_procedure.p_proc_data;
					/*BUG 13332:start*/ 
					proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;
					/*BUG 13332:end*/ 
					/**Enqueue
					 * ERAB
					 * setup
					 * request
					 **/
                    /*SPR 18241 START*/
					rrm_ue_mgr_enqueue_req( &proc_queue, p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
                    /*SPR 18241 END*/
                    /*SPR 20137 Start*/
                    p_ue_context->ue_sync_status_ind = RRM_TRUE;
                    /*SPR 20137 Stop*/
				}
			}
            /*SPR 20137 Start*/
            else if(RRM_TRUE == p_ue_context->ue_sync_status_ind)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Dropping the message,as UE SYNC STATUS is already ongoing for UE_INDEX[%d]",p_ue_context->ue_index);
            }
            /*SPR 20137 Stop*/
			ret_val= RRM_SUCCESS;
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"p_ue_context is NULL");
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;

}
/* SPR 12512 Fix End */


/*CA stage3 start*/
/****************************************************************************
 * Function Name  : rrm_uem_masa_meas_config_ind 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_results_ind message received from RRC for MASA procedure
 ****************************************************************************/


	rrm_return_et 
rrm_uem_masa_meas_config_ind(rrm_ue_global_context_t *p_g_rrm_ue_ctx)
{
	rrm_ue_measurment_results_ind_t     *p_proc_data = RRM_NULL;
	rrm_ue_context_t *p_ue_context = RRM_PNULL;
	rrmc_meas_report_event_et          meas_rep_event;
	U8                           index = RRM_ZERO;
	U8                           meas_id_count = RRM_ZERO;
	RrmMacUeReconfigReq          *p_mac_ue_reconfig_req = RRM_PNULL;
	rrm_cell_context_t           *p_cell_ctx = RRM_PNULL;
	rrm_return_et                ret_val = RRM_SUCCESS;
	lte_ncl_t                    *p_lte_ncl = RRM_PNULL; 
	U8                           eutran_count = RRM_ZERO;
	U8                           scell_index = RRM_ZERO;
	rrm_cell_index_t   scell_list[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
	rrm_cell_index_t       scell_cap_list[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
	rrm_ue_procedure_queue_t    proc_queue = {RRM_ZERO};
	rrm_bool_et                scell_deactivated_flag = RRM_FALSE;
	U8                         cell_index_of_scell = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	p_proc_data = (rrm_ue_measurment_results_ind_t *)
		p_ue_context->current_procedure.p_proc_data;

	for(index = RRM_ZERO; index < RRM_MAX_SCELL; index++)
	{
		scell_list[index] = RRM_OUT_OF_RANGE;
		scell_cap_list[index] = RRM_OUT_OF_RANGE; 
	}
	index = RRM_ZERO;
	if(RRM_UE_STATE_HO_ONGOING == p_ue_context->ue_state)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_WARNING,
				"HO is ongoing for UE[%d] drop measurement indication", p_ue_context->ue_index);
		return RRM_FAILURE;
	}
	meas_rep_event = rrm_ue_get_configured_meas_event (
			p_proc_data->meas_id,
			p_ue_context);
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_BRIEF, 
			"get configured Meas report event[%d], Meas_id [%d] and trigger_quantity [%d]",
			meas_rep_event,p_proc_data->meas_id,p_ue_context->trigger_quantity);
	switch(meas_rep_event)
	{

		case MEAS_REP_EVENT_A1:
			{
				/*Verify A2 is recieved for Scell on basis of meas_id. if yes deactivate the Scell*/
				for (index = RRM_ZERO; index < p_ue_context->ue_scell_add_params.count; index++)
				{
					for (meas_id_count = RRM_ZERO;
							meas_id_count < sizeof(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].meas_id)/
							sizeof(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].meas_id[RRM_ZERO]);
							meas_id_count++)
					{
						if (p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].
								meas_id[meas_id_count] == p_proc_data->meas_id) 
						{
							/*Set the deactivation flag:SCELL_DEACTIVE*/
							if(SCELL_DEACTIVE_FOR_MEASUREMENT == 
									p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state)
							{
								p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state =
									SCELL_DEACTIVE;
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
										"Successfully set deactive cause as SCELL_DEACTIVE for scell_index[%d] ue_id[%d]",
										p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index,
										p_ue_context->ue_index);
							}
						}
					}
				}
			}
			break;
		case MEAS_REP_EVENT_A2:
			{
				/*keep the backup of scell state*/
				rrm_ue_scell_state_backp(p_g_rrm_ue_ctx->p_ue_context);
				/*Verify A2 is recieved for Scell on basis of meas_id. if yes deactivate the Scell*/
				p_mac_ue_reconfig_req = (RrmMacUeReconfigReq *)rrm_mem_get(sizeof(RrmMacUeReconfigReq));
				/*cov fix start 63897*/
				if (RRM_PNULL != p_mac_ue_reconfig_req)
				{
					/*cov fix start 63938*/
					p_mac_ue_reconfig_req->bitmask = RRM_ZERO;
					/*cov fix end 63938*/


					for (index = RRM_ZERO; index < p_g_rrm_ue_ctx->p_ue_context->ue_scell_add_params.count; index++)
					{
						for (meas_id_count = RRM_ZERO; 
								meas_id_count < sizeof(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].meas_id)/
								sizeof(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].meas_id[RRM_ZERO]);
								meas_id_count++)
						{
							if (p_g_rrm_ue_ctx->p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].
									meas_id[meas_id_count]== p_proc_data->meas_id) 
							{
								/*Send deactivation request to MAC. if already not sent*/
								p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].
									schedulingDeactivateScell[scell_index]= 
									p_g_rrm_ue_ctx->p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_index;
								scell_index++;
								/*Set the scell state as deactive*/
								p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE = RRM_ONE;
								p_g_rrm_ue_ctx->p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state= 
									SCELL_DEACTIVE_FOR_MEASUREMENT;
							}
						}
					}
					if (RRM_ZERO != p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE)
					{
						p_mac_ue_reconfig_req->bitmask |= UE_CA_CONFIG_INFO_LIST_RECONFIG_BIT; 
						/*SPR 13355:start*/
						p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].isMACCESendToUE = RRM_ONE;
						/*SPR 13355:end*/

						p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].ueIndex = 
							p_g_rrm_ue_ctx->p_ue_context->ue_index;
						p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].
							numOfScellsSchedulingNotAllowed = scell_index;
					}

					/*Check if already reconfig is on going or not. 
					  If yes queue this and send once response is received from MAC*/
					if(MAC_UE_RECONF_NOT_ONGOING ==  rrm_get_mac_ue_reconfig_mutex 
							(p_g_rrm_ue_ctx->p_ue_context->cell_index))
					{
						if( RRM_SUCCESS == rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req,
									RRM_MODULE_ID,
									RRM_ZERO,
									p_g_rrm_ue_ctx->p_ue_context->cell_index))
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
									"Successfully sent RRM_MAC_UE_RECONFIG_REQ to L2 for scell");
							rrm_set_mac_ue_reconfig_mutex( p_g_rrm_ue_ctx->p_ue_context->cell_index,
									W_FOR_MAC_UE_RECONF_CNF_FOR_CA);
							/*cov_fix_63934_start*/
							RRM_MEM_FREE(p_mac_ue_reconfig_req);
							/*cov_fix_63934_end*/
						}
					}
					else
					{
						proc_queue.api_id = RRM_MAC_UE_RECONFIG_REQ; 
						proc_queue.p_proc_data = (rrm_void_t *)(p_mac_ue_reconfig_req); 
						rrm_ue_glb_enqueue_req(&proc_queue, p_g_rrm_ue_ctx); 
						/*p_mac_ue_reconfig_req will be freed after dequeue*/
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
							"Unable to allocate memory for p_mac_ue_reconfig_req ");
				}
				/*cov fix end 63897*/

			}
			break;
		case MEAS_REP_EVENT_A4:
			{
				if (RRM_ZERO == p_g_rrm_ue_ctx->p_ue_context->ue_scell_add_params.scell_bkp_count)
				{
					p_cell_ctx = rrm_cellm_get_cell_context(p_g_rrm_ue_ctx->p_ue_context->cell_index);
					p_lte_ncl = rrm_cellm_get_lte_ncl_info(p_g_rrm_ue_ctx->p_ue_context->cell_index);
					/*cov fix start 63896*/
					if ((RRM_PNULL != p_cell_ctx) && (RRM_PNULL != p_lte_ncl))
					{
						/*cov fix start 63911*/
						for(eutran_count = RRM_ZERO;
								((eutran_count< p_proc_data->eutran_count) && ( eutran_count < RRM_MAX_CELLS_REPORTED));
								eutran_count++)
							/*cov fix end 63911*/
						{
							for (index= RRM_ZERO;index< p_lte_ncl->num_valid_inter_freq_cell;index++)
							{
								if (p_proc_data->eutran_neighbor_list[eutran_count].pci == 
										p_lte_ncl->inter_freq_cells[index].phy_cell_id)
								{
									scell_deactivated_flag = RRM_FALSE;
									/*find cell_index on basis of ecgi*/
									/* Bug_13158_fix: Start */ /* wrong index was passed for inter_freq_cells */
									rrm_validate_ncl_cell_for_scell_selection(&(p_lte_ncl->inter_freq_cells[index]),
											p_cell_ctx->cell_index, &scell_deactivated_flag, &cell_index_of_scell);
									/* Bug_13158_fix: End */

									if (RRM_FALSE == scell_deactivated_flag)
									{
										rrm_update_scell_list_and_scell_cap_list(&scell_index, scell_list, scell_cap_list, 
												&(p_lte_ncl->inter_freq_cells[index]), &cell_index_of_scell);
										/* scell_index incremented for the next index to be used */
										scell_index++;
									}
									break;
								}
							}
						}
						if(scell_index > RRM_ONE)
						{
							RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
									"Number of elements in scell list[%d] is greater than 1, so sorting required", 
									scell_index);

							rrm_sort_scell_list_by_cell_capacity(scell_list, 
									scell_cap_list, 
									scell_index);
						}
						ret_val = rrm_check_and_update_ue_scell_list(p_ue_context,p_cell_ctx,scell_list);
					}
					else 
					{
						RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
								"Unable to assign memory for p_cell_ctx or p_lte_ncl");

					}
					/*cov fix end 63896*/
				}
			}
			break;
		case MEAS_REP_EVENT_A3:
		case MEAS_REP_EVENT_A5:
		case MEAS_REP_EVENT_NONE:
		case MEAS_REP_EVENT_B1:
		case MEAS_REP_EVENT_B2:
			/*CA HAREDENING 6.3.0 CHANGES*/
		case MEAS_REP_EVENT_STRONGEST_CELL_FOR_SON:
			/*SPR 15509 start*/
		case MEAS_REP_EVENT_FOR_CGI:
			/*SPR 15509 End*/
		case MEAS_REP_MAX_EVENT:
			/* SPR 13445 Fix Start */
		case MEAS_REP_EVENT_FORCEFUL_A2:
			/* SPR 13445 Fix End */
			/* SPR 14247 start */
		case MEAS_REP_EVENT_PERIODICAL:
			/* SPR 14247 end  */
		/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
        case MEAS_REP_EVENT_B1_NR:
		case MEAS_REP_EVENT_B2_NR:
#endif
/* ENDC_MEAS_CHANGES_END */
			break;
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* SPR 14873 start */
/****************************************************************************
 * Function Name  : rrm_uem_map_eutra_report_amount 
 * Inputs         : rrm_common_params_for_eutra_t *p_common_params_for_eutra
 * Outputs        : max_eicic_ind_report
 * Returns        : U8
 * Description    : It maps the report amount
 ****************************************************************************/
U8
	rrm_uem_map_eutra_report_amount
(
 rrm_common_params_for_eutra_t *p_common_params_for_eutra
 ) 
{
	U8  max_eicic_ind_report = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	switch(p_common_params_for_eutra->report_amount)
	{

		case RRMC_REPORT_AMOUNT_1 :
			max_eicic_ind_report = RRM_ONE;
			break;

		case RRMC_REPORT_AMOUNT_2 :
			max_eicic_ind_report = RRM_TWO;
			break;

		case RRMC_REPORT_AMOUNT_4 :
			max_eicic_ind_report = RRM_FOUR;
			break;

		case RRMC_REPORT_AMOUNT_8 :
			max_eicic_ind_report = RRM_EIGHT;
			break;

		case RRMC_REPORT_AMOUNT_16 :
			max_eicic_ind_report = RRM_SIXTEEN;
			break;

		case RRMC_REPORT_AMOUNT_32 :
			max_eicic_ind_report = RRM_THIRTY_TWO;
			break;

		case RRMC_REPORT_AMOUNT_64 :
			max_eicic_ind_report = RRM_SIXTY_FOUR;
			break;

		case RRMC_REPORT_AMOUNT_INFINITY :
			max_eicic_ind_report = RRM_ZERO;
			break;

		default : 
			max_eicic_ind_report = RRM_ZERO;

	}
	RRM_UT_TRACE_EXIT();
	return max_eicic_ind_report;
}
/* SPR 14873 end */
/* eICIC_PHASE_1_2_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_uem_eicic_meas_config_ind 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_results_ind message received from RRC 
 *                  eICIC procedure
 ****************************************************************************/
	rrm_return_et
rrm_uem_eicic_meas_config_ind(rrm_ue_global_context_t *p_g_rrm_ue_ctx)
{
	rrm_ue_measurment_results_ind_t     *p_proc_data = RRM_NULL;
	rrm_ue_context_t *p_ue_context = RRM_PNULL;
	/* SPR14165start */
	/* SPR14165end */
	U8                           index = RRM_ZERO;
	U8                           eutran_count = RRM_ZERO;
	U8                           num_cell_count = RRM_ZERO;
	/* bug_13886_start */
	/* SPR 14247 start */
	rrm_common_params_for_eutra_t *p_common_params_for_eutra = RRM_PNULL;
	p_common_params_for_eutra = rrm_cellm_get_connected_mode_common_params(p_g_rrm_ue_ctx->p_ue_context->cell_index);
	/* SPR 14873 start */
	U8                           max_eicic_ind_report = RRM_ZERO;
	max_eicic_ind_report = rrm_uem_map_eutra_report_amount(p_common_params_for_eutra);
	/* SPR 14873 end*/
	/* SPR 14247 end */
	rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
	/* bug_13886_end */
	rrm_bool_et                  flag_found = RRM_FALSE;
	RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	p_proc_data = (rrm_ue_measurment_results_ind_t *)
		p_ue_context->current_procedure.p_proc_data;

	/* SPR14165start */
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_BRIEF,
			"get configured Meas_id [%d] and trigger_quantity [%d]",
			p_proc_data->meas_id,p_ue_context->trigger_quantity);

	/* bug_13886_start */
	p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
	/* cov 69661 fix */
	if (RRM_PNULL == p_cell_ctxt)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
				"Cell Context not found");
		return RRM_FAILURE;
	}
	/* SPR 14302 start */ 
	if (RRM_TRUE == p_ue_context->rrm_eicic_meas_event_ongoing)
		/* SPR 14302 end */ 
	{
		p_ue_context->eicic_meas_result.num_meas_ind_rcvd++;
		num_cell_count = p_ue_context->eicic_meas_result.num_cell_reported;

		if (p_ue_context->eicic_meas_result.num_meas_ind_rcvd < max_eicic_ind_report)
		{
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
					" MEAS REPORT received at RRM : %d ", 
					p_ue_context->eicic_meas_result.num_meas_ind_rcvd);
			for(eutran_count = RRM_ZERO;
					((eutran_count< p_proc_data->eutran_count) && (eutran_count < RRM_THREE));
					eutran_count++)
			{
				for(index = RRM_ZERO;index < num_cell_count; index++) 
				{ 
					/* Checking if already rcvd in older meas report */
					if (p_proc_data->eutran_neighbor_list[eutran_count].pci ==
							p_ue_context->eicic_meas_result.eutran_cell[index].eutran_ncl.pci)
					{
						p_ue_context->eicic_meas_result.eutran_cell[index].
							occurence_count++;
						flag_found = RRM_TRUE; 
						break;
					}
					/* bug_13886_start */
					else
					{
						/* Not Found in older report */
						flag_found = RRM_FALSE;
					} 
					/* bug_13886_end */
				}
				if(flag_found != RRM_TRUE)
				{
					/* Updating the meas structure in p_ue_context */  
					RRM_MEMCPY((void *)&p_ue_context->eicic_meas_result.eutran_cell[num_cell_count].eutran_ncl, 
							(void *)&p_proc_data->eutran_neighbor_list[eutran_count],sizeof(rrm_son_eutran_neighbor_cell_t));
					p_ue_context->eicic_meas_result.eutran_cell[num_cell_count].
						occurence_count++;
					/* bug_13886_start */
					p_ue_context->eicic_meas_result.num_cell_reported++;
					num_cell_count ++;
					/* bug_13886_end */
					flag_found = RRM_FALSE;
				}
			}
			/* Cov 69267 Fix */ 
		}
		else if(p_ue_context->eicic_meas_result.num_meas_ind_rcvd ==  max_eicic_ind_report)
		{
			/* SPR 14247 start */
			p_ue_context->eicic_meas_result.num_meas_ind_rcvd = RRM_ZERO;
			/* SPR 14247 end */
			rrm_uem_sort_eicic_meas_array(&p_ue_context->eicic_meas_result);

			/* bug_13886_start */
			UInt8 aggressor_add_count = RRM_ZERO;

			/*Addind Strongest Cell Found in Previous Meas Report */
			for(eutran_count = RRM_ZERO;
					((eutran_count< p_ue_context->eicic_meas_result.num_cell_reported) && (eutran_count < RRM_TWO));
					eutran_count++)
			{
				/*SPR 16216 start*/
				if(p_ue_context->eicic_meas_result.eutran_cell[eutran_count].occurence_count >= RRM_ONE)
					/*SPR 16216 end*/
				{
                    /*SPR 20687 Changes Start */
					rrm_uem_update_aggressor_node_list(
							&p_ue_context->eicic_meas_result.eutran_cell[eutran_count].eutran_ncl,
							p_g_rrm_ue_ctx,eutran_count);
                    /*SPR 20687 changes Stop*/
					aggressor_add_count++;
				}

			}

			/* Adding The strongest Cell from last measurment report */
			/* cov 69671 fix */
			for(eutran_count = RRM_ZERO;((eutran_count< p_proc_data->eutran_count) 
						&& (eutran_count < RRM_MAX_CELLS_REPORTED)); 
					eutran_count++)
			{
				if(((p_proc_data->eutran_neighbor_list[eutran_count].pci !=
								p_ue_context->eicic_meas_result.eutran_cell[RRM_ZERO].eutran_ncl.pci)&&
							(p_proc_data->eutran_neighbor_list[eutran_count].pci !=
							 p_ue_context->eicic_meas_result.eutran_cell[RRM_ONE].eutran_ncl.pci))||
						(aggressor_add_count == RRM_ZERO))
				{
                    /*SPR 20687 changes Start*/
					rrm_uem_update_aggressor_node_list(
							&p_proc_data->eutran_neighbor_list[eutran_count],
							p_g_rrm_ue_ctx,RRM_TWO);
                    /*SPR 20687 changes Stop*/

					/* Add Only Three Aggressor From Meas Report Received */ 
					/* SPR 14302 start */
					if(++aggressor_add_count == RRM_THREE)
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
								" expected aggressors have been found successfully " );
						break;  
					}
					/* SPR 14302 end */
				}
			}
			/* bug_13886_end */

			/* SPR14165start */
			/* SPR 14302 start */ 
			/* Calling the function to remove Meas Reporting from UE */
			if(RRM_TRUE == p_ue_context->rrm_eicic_meas_event_ongoing)
			{
				/* SPR 14570 start */
				/*15034_start*/
				if(RRM_SUCCESS == rrm_uem_send_remove_meas_config_for_victim(p_ue_context))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
							"Successfully sent remove meas id request for victim ue[%d]",
							p_ue_context->ue_index);
				}    
				/*15034_end*/
				/* SPR 14570 end */ 
			}
			p_ue_context->rrm_eicic_meas_event_ongoing = RRM_FALSE;
			/* SPR 14302 end*/ 
		}
	}
	else 
	{

		/* SPR14165end */
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_ERROR,
				"Invalid Meas report For Victim Meas_id [%d]",
				p_proc_data->meas_id);

		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE; 

	}
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS; 
}
/****************************************************************************
 * Function Name  : rrm_uem_update_aggressor_node_list 
 * Inputs         : eutran_neighbor,p_cell_ctx.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Add the aggressor node received from RRC in link list for
 eICIC procedure 
 ****************************************************************************/
rrm_return_et
/*SPR 20687 changes Start*/
	rrm_uem_update_aggressor_node_list
(rrm_son_eutran_neighbor_cell_t * eutran_neighbor, 
 rrm_ue_global_context_t *p_ue_glbl_ctxt,
 U8                       count)
    /*SPR 20687 changes Stop*/
{
	rrm_cell_index_t cell_index = RRM_ZERO;
	lte_ncl_t                    *p_lte_ncl = RRM_PNULL;
	U8                           index = RRM_ZERO;
    /*SPR 20687 changes Start*/
    /* Code Removed */
    /*SPR 20687 changes Stop*/
	rrm_invoke_ind_status_et     invoke_ind_sent = RRM_EICIC_INVOKE_NOT_SENT ;
	rrm_ue_context_t *p_ue_context = RRM_PNULL;

	p_ue_context = p_ue_glbl_ctxt->p_ue_context;

	YLIST aggressor_node_list;
	aggressor_node_t *p_new_aggressor_node = RRM_PNULL; 

	RRM_UT_TRACE_ENTER();
	ylInit(&aggressor_node_list);

	cell_index = p_ue_glbl_ctxt->p_ue_context->cell_index;
	p_lte_ncl = rrm_cellm_get_lte_ncl_info(cell_index);
	if(RRM_PNULL == p_lte_ncl)
	{

		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
				"p_lte_ncl not found " );
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;    
	}
	aggressor_node_list = p_ue_glbl_ctxt->aggressor_node_info.
		rrm_aggressor_on_cell[cell_index].aggressor_node_list;

	for (index= RRM_ZERO;index< p_lte_ncl->num_valid_intra_freq_cell;index++)
	{
		/* Checking if already invoke sent */
		if (eutran_neighbor->pci ==
				p_lte_ncl->intra_freq_cells[index].phy_cell_id)
		{
			invoke_ind_sent = p_lte_ncl->intra_freq_cells[index].rrm_intra_ncl_eicic_data.invoke_ind_status;
			break;
		} 
	}
	if(RRM_EICIC_INVOKE_NOT_SENT == invoke_ind_sent)
	{
		if (RRM_ZERO != ylCount(&aggressor_node_list))
		{
			p_new_aggressor_node = (aggressor_node_t*) ylFind(&aggressor_node_list,
					(void *)&eutran_neighbor->pci, rrm_uem_find_aggressor_node_list_key,
					rrm_uem_aggressor_node_data_compare);

			if(p_new_aggressor_node) 
			{
				/* Incrementing the Occurence Count For The aggressor Node */
				p_new_aggressor_node->aggressor_node_data.occurence_count++;

			}
			else /* Node not found in aggressor list */
			{
				p_new_aggressor_node = (aggressor_node_t *)rrm_mem_get(sizeof(aggressor_node_t));
				if (p_new_aggressor_node == RRM_PNULL)
				{
					RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
							"Memory allocation to p_new_aggressor_node failed" );
					RRM_UT_TRACE_EXIT();
					return RRM_FAILURE;
				}

				RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
						" Adding aggressor into the list : PCI[%d] ", eutran_neighbor->pci );
				RRM_MEMSET(p_new_aggressor_node,RRM_ZERO, sizeof(aggressor_node_t));
				p_new_aggressor_node->aggressor_node_data.pci = eutran_neighbor->pci;
				p_new_aggressor_node->aggressor_node_data.occurence_count++;  

				ylPushTail(&(aggressor_node_list),&(p_new_aggressor_node->node));

			}                                 
		}
		else
		{   
			/* Creating Aggressor List For The First Time As List is Empty */
			p_new_aggressor_node = (aggressor_node_t *)rrm_mem_get(sizeof(aggressor_node_t));
			if (p_new_aggressor_node == RRM_PNULL)
			{
				RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
						"Memory allocation to p_new_aggressor_node failed" );
				RRM_UT_TRACE_EXIT();
				return RRM_FAILURE;
			}
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
					" Adding aggressor into the list : PCI[%d] ", eutran_neighbor->pci );
			RRM_MEMSET(p_new_aggressor_node,RRM_ZERO, sizeof(aggressor_node_data_t));
			p_new_aggressor_node->aggressor_node_data.pci = eutran_neighbor->pci;
			p_new_aggressor_node->aggressor_node_data.occurence_count++;  

			ylPushHead(&aggressor_node_list, &(p_new_aggressor_node->node)); 
		}
		/* Filling Valid aggressor info added into linked list*/
        /*SPR 20687 changes Start*/
        p_ue_context->eicic_meas_result.valid_aggressor_list[count]= eutran_neighbor->pci;
        /*SPR 20687 changes Stop*/
		p_ue_context->eicic_meas_result.valid_aggressor_count++;
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
				" valid aggressor count in list [%d] ", 
				p_ue_context->eicic_meas_result.valid_aggressor_count);
		/* bug_13914_start */
		p_ue_glbl_ctxt->aggressor_node_info.
			rrm_aggressor_on_cell[cell_index].aggressor_node_list = aggressor_node_list ;
		/* bug_13914_end */  
		/* SPR 15230 fix start */
		//code is removed
		/*15070_end*/
		/* SPR 15230 fix end */

	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
				"Invoke for aggressor is already sent so ignoring neighbour" );
	} 
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS; 
}

/*****************************************************************************
 * Function Name  : rrm_uem_sort_eicic_meas_array 
 * Inputs         : eicic_meas_result 
 * Outputs        : None 
 * Returns        :
 * Description    : sort the meas array stored in p_ue_context
 *                  
 ****************************************************************************/
	void rrm_uem_sort_eicic_meas_array
(rrm_ue_eicic_meas_ind_t * p_eicic_meas_result)
{
	UInt8 index, index_1, flag = RRM_TRUE;    
	eicic_meas_data_t      eutran_cell;     
	UInt8 length = p_eicic_meas_result->num_cell_reported;

	RRM_UT_TRACE_ENTER();
	for(index = RRM_ONE; (index <= length) && flag; index++)
	{
		flag = RRM_FALSE;
		for (index_1= RRM_ZERO; index_1 < (length -1); index_1++)
		{
			if (p_eicic_meas_result->eutran_cell[index_1+RRM_ONE].occurence_count >
					p_eicic_meas_result->eutran_cell[index_1].occurence_count)      
			{ 
				/* bug_13886_start */
				RRM_MEMCPY(&eutran_cell,
						&p_eicic_meas_result->eutran_cell[index_1],
						sizeof(eicic_meas_data_t));             
				/* bug_13886_start */
				RRM_MEMCPY(&p_eicic_meas_result->eutran_cell[index_1],
						&p_eicic_meas_result->eutran_cell[index_1+RRM_ONE],
						sizeof(eicic_meas_data_t));
				RRM_MEMCPY(&p_eicic_meas_result->eutran_cell[index_1+RRM_ONE], 
						&eutran_cell,sizeof(eicic_meas_data_t));

				flag = RRM_TRUE;              
			}
		}
	}
	RRM_UT_TRACE_EXIT();
	return;   
}



/* eICIC_PHASE_1_2_CHANGES_END */

/****************************************************************************
 * Function Name  : rrm_uem_meas_config_ind 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the meas_results_ind message received from RRC for HO procedure
 ****************************************************************************/
/*CA HARDENING CHANGES 6.3.0 CHANGES */
rrm_return_et 
/*SPR 16764 START*/
rrm_uem_meas_results_ind(rrm_ue_global_context_t *p_g_rrm_ue_ctx)
	/*SPR 16764 END*/
{
	/* SPR 15797 Start */
	/*CID:88453 Fix Start*/
	static rrmuem_rmif_meas_results_ind_t      ue_meas_results_ind = {RRM_ZERO};
	/*CID:88453 Fix End*/
	/* SPR 15797 End */
	rrm_ue_measurment_results_ind_t     *p_proc_data = RRM_NULL;
	rrm_cell_context_t                  *p_cell_context = RRM_PNULL;
	U8  valid_pci = RRM_ZERO;
	U8  index_cdma_cell = RRM_ZERO;
	U8  ecid_meas_index = RRM_ZERO;
	rrm_bool_et   ue_meas_for_ecid_meas = RRM_FALSE;
	/* RACH_OPTIMIZATION_CHANGES_START */
	U8  rach_index  = RRM_ZERO;
	S32 ue_started_meas_time_in_ms = RRM_ZERO;
	/* RACH_OPTIMIZATION_CHANGES_END */
	/*SPR_7831_CHANGES_START*/
	meas_type_et                   meas_type = MEAS_TYPE_ANR;
	/*SPR_7831_CHANGES_END*/
	rrm_ue_context_t *p_ue_context = RRM_PNULL;
	rrm_return_et    ret_val = RRM_SUCCESS;
	/*SPR_8004:fix_start */
	U8 index = RRM_ZERO;
	/*SPR_8004:fix_end */
	/* CSR00069389 Start */
	//rrm_ue_procedure_record_t      *p_rrm_ue_procedure_record = RRM_PNULL;
	/* CSR00069389 End */
	/*SPR 17646 Start*/
	rrm_bool_et should_process_enqueued_proc = RRM_FALSE;
	/*SPR 17647 End*/
	/* SPR 16099 fix start */
	rrm_ue_meas_config_cgi_queue_node_t *p_report_cgi_req_info = RRM_PNULL;
	rrm_ue_procedure_record_t           *p_ue_record_to_be_del = RRM_PNULL;
	meas_report_info_node_t       *p_meas_report_info = RRM_PNULL;
	rrm_ue_procedure_record_t      *p_rrm_ue_procedure_record = RRM_PNULL;
	/* SPR 16099 fix end */
	/* SPR 16406 8SEP start */
	rrm_bool_et                         cgi_report              = RRM_FALSE;
	/* SPR 16406 8SEP end */
	/* SPR-18789 START*/
	rrc_rrm_meas_config_req_t   *p_rrc_rrm_meas_config_req    = RRM_PNULL;
	U16                         trans_id                      = rrm_generate_txn_id();
	/* SPR-18789 END*/
    /*SPR 21541 Fix Start*/ 
    rrm_ue_procedure_queue_t    proc_queue;
	rrm_return_et	ret_val1 = RRM_SUCCESS;
    /*SPR 21541 Fix Stop*/

	RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	/* coverity_64544_fix: Start */                
	if(p_ue_context->current_procedure.p_proc_data != RRM_PNULL)
	{
		p_proc_data = (rrm_ue_measurment_results_ind_t *)
			p_ue_context->current_procedure.p_proc_data;
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
				"p_ue_context->current_procedure.p_proc_data is NULL!");
		return RRM_FAILURE;
	}
	/* coverity_64544_fix: End */                
	/* SPR 15797 +- */

	/* SPR 16099 fix update start */
	if(((RRM_1 == p_proc_data->eutran_count) &&
				(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->eutran_neighbor_list[RRM_ZERO].bitmask))
			|| ((RRM_1 == p_proc_data->utran_count) &&
				(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->utran_neighbor_list[RRM_ZERO].bitmask))
			|| ((RRM_1 == p_proc_data->geran_count) &&
				(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->geran_neighbor_list[RRM_ZERO].bitmask))
			|| ((RRM_1 == p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.cdma2000_count) &&
				(RRM_UEM_MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT &
				 p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.meas_result_cdma2000[RRM_ZERO].bitmask)))
	{
		/* Check if the non-empty CGI report is receivied from the UE. Traverse the procedure queue
		 * of the UE and discard the nodes of meas config that are there for the CGI reporting of the
		 * same PCI and EARFCN */
		p_meas_report_info = rrm_get_cgi_meas_node_for_meas_id(p_proc_data->meas_id,
				p_g_rrm_ue_ctx->p_ue_context);
		if (RRM_PNULL != p_meas_report_info)
		{
			/* SPR 16406 8SEP start */
			cgi_report = RRM_TRUE;
			/* SPR 16406 8SEP end */
			p_rrm_ue_procedure_record = (rrm_ue_procedure_record_t *)ylFirst(&(p_g_rrm_ue_ctx->p_ue_context->procedure_queue));

			while (RRM_PNULL != p_rrm_ue_procedure_record)
			{
				if (p_rrm_ue_procedure_record->proc_queue.api_id == RRC_RRM_MEAS_CONFIG_REQ)
				{
					p_report_cgi_req_info = (rrm_ue_meas_config_cgi_queue_node_t *)(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
					if (RRM_PNULL != p_report_cgi_req_info)
					{
						if((RRM_EUTRAN_CELL == p_report_cgi_req_info->rat_type) &&
								(p_report_cgi_req_info->arfcn == p_meas_report_info->carrier_earfcn) &&
								(p_report_cgi_req_info->cgi == p_proc_data->eutran_neighbor_list[RRM_ZERO].pci ))
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"CGI Meas Config existing for the reported PCI is discarded as CGI has been received.");

							/* Deallocating memory allocated to proc_data */
							RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
							p_report_cgi_req_info = RRM_PNULL;

							p_ue_record_to_be_del = p_rrm_ue_procedure_record;
							p_rrm_ue_procedure_record = (rrm_ue_procedure_record_t *)ylNext((YLNODE*)p_rrm_ue_procedure_record);

							/* Aligning the pointer pointing to CGI node list */
							if (p_ue_record_to_be_del == p_g_rrm_ue_ctx->p_ue_context->p_proc_queue_first_meas_node)
							{
								p_g_rrm_ue_ctx->p_ue_context->p_proc_queue_first_meas_node = p_rrm_ue_procedure_record;
							}

							/* Deallocating memory allocated to node in procedural queue */
							ylDelete(&(p_g_rrm_ue_ctx->p_ue_context->procedure_queue),(YLNODE*)p_ue_record_to_be_del);
							RRM_MEM_FREE(p_ue_record_to_be_del);

							continue;
						}
					}
				}
				p_rrm_ue_procedure_record = (rrm_ue_procedure_record_t *)ylNext((YLNODE*)p_rrm_ue_procedure_record);
			}
		}
	}
	/* SPR 16099 fix update end */

	/* Start HO Code Cleanup */
	if((p_proc_data->meas_id >= RRM_MEAS_OBJ_ID_OFFSET) && 
			(p_proc_data->meas_id <= RRM_ANR_MAX_MEAS_OBJ))
	{
		p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
		/*CID 65797:start*/
		if (RRM_PNULL == p_cell_context)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
			/*CID 66688:start*/
			/* SPR 15797 +- */
			/*CID 66688:end*/
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		/*CID 65797:end*/

		if(CELL_ALREADY_REGISTERD_FOR_ANR & p_cell_context->cell_already_register_anr)
		{
			/* End HO Code Cleanup */
			/* SPR 16053 start */
			if(RRM_MEAS_CONFIG_RESP_SUCCESS ==
					p_ue_context->
					p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET].
					meas_config_status)
				/* SPR 16053 end */
			{   

				/* SPR 15797 +- */
				rrm_ue_print_meas_config_struct(p_ue_context->
						p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET]);

				/* Store the results of serving cell of the UE in ue context */
				p_ue_context->meas_result_serv_cell.rsrp_result =
					p_proc_data->meas_result_serv_cell.rsrp_result;

				p_ue_context->meas_result_serv_cell.rsrq_result =
					p_proc_data->meas_result_serv_cell.rsrq_result;

				/* Populate RRMUEM_RMIF_MEAS_RESULTS_IND msg to be sent to RMIF */
				/* SPR 16406 8SEP start */
				/*SPR_17893_START*/
				if (((RRM_UE_STATE_ACTIVE == p_g_rrm_ue_ctx->p_ue_context->ue_state) ||
							(RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES == p_g_rrm_ue_ctx->p_ue_context->ue_state))|| (RRM_TRUE == cgi_report))
				{
					/*SPR_17893_END*/

					/* SPR 15797 Start */
					ret_val = rrm_ue_populate_rrmif_meas_results_ind(&ue_meas_results_ind,
							/* SPR 15797 End */
							p_proc_data,
							p_ue_context);
					if(RRM_SUCCESS == ret_val)
					{
						/* SPR 15797 Start */
						if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
									RRMUEM_RMIF_MEAS_RESULTS_IND, sizeof(rrmuem_rmif_meas_results_ind_t),
									(void *)(&ue_meas_results_ind)))
							/* SPR 15797 End */
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"Sent MEAS RESULTS IND for UE_INDEX[%d] MeasId: %d",
									p_ue_context->ue_index, 
									p_proc_data->meas_id);
							ret_val = RRM_SUCCESS;
						}
						else
						{
							/* SPR 16406 8SEP start */
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
									"Failed to send MEAS RESULTS IND for UE_INDEX[%d] "
									"MeasId: %d", p_ue_context->ue_index,
									p_proc_data->meas_id);
							ret_val = RRM_FAILURE;
							/* SPR 16406 8SEP end */
						}
					}
					/* SPR 16406 8SEP start */
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
							"Dropping ANR measurement report measId[%u] for UE_INDEX[%d] as UE is not in active state, UE state is [%u]",
							p_proc_data->meas_id, p_g_rrm_ue_ctx->p_ue_context->ue_index, p_g_rrm_ue_ctx->p_ue_context->ue_state);
				}
				/* SPR 16406 8SEP end */
				/* CSR00069389 Start */
				/* SPR 15314 Changes Start*/
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"\nBefore Decrementing Function handle_meas_result_ind  meas id = %d,report counter = %d,"
						"report amount ue =%d",p_proc_data->meas_id ,
						p_g_rrm_ue_ctx->p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET ].report_counter, 
						p_g_rrm_ue_ctx->p_ue_context->report_amount_ue);

				/* SPR 15854 Fix Start */
				if(RRM_ZERO != p_g_rrm_ue_ctx->p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET ].report_counter)
				{
					p_g_rrm_ue_ctx->p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET ].report_counter--;
				}
				/* Changes Done so that the value does not corrupt in case report amount for UE was 1 */
				if(RRM_ZERO != p_g_rrm_ue_ctx->p_ue_context->report_amount_ue)
				{
					p_g_rrm_ue_ctx->p_ue_context->report_amount_ue--;
				}
				/* SPR 15854 Fix End */


				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"\nAfter Decrementing Function handle_meas_result_ind  meas id = %d, report counter = %d,"
						"report amount ue =%d",p_proc_data->meas_id ,
						p_g_rrm_ue_ctx->p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET ].report_counter, 
						p_g_rrm_ue_ctx->p_ue_context->report_amount_ue);

				/* SPR 16406 8SEP start */
				if((p_g_rrm_ue_ctx->p_ue_context->p_meas_config[p_proc_data->meas_id - RRM_MEAS_OBJ_ID_OFFSET ].report_counter == RRM_ZERO) &&
						(RRM_UE_MEAS_CONFIG_REQ_ONGOING != p_g_rrm_ue_ctx->p_ue_context->current_procedure.state) &&
						/*SPR_17893_START*/
						((RRM_UE_STATE_ACTIVE ==  p_g_rrm_ue_ctx->p_ue_context->ue_state)||
						 (RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES ==  p_g_rrm_ue_ctx->p_ue_context->ue_state)))
					/*SPR_17893_END*/

					/* SPR 16406 8SEP end */
				{
					/*SPR 16053 +-*/
					/*SPR 17676 +-*/
					/* SPR 15724:Start */
					rrm_release_anr_meas_configuration( p_g_rrm_ue_ctx->p_ue_context,
							p_proc_data->meas_id);
					/* SPR 15724:End */
				}
				/* SPR 15314 CHANGES END*/
				/* CSR00069389 End */
			}
			else 
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
						"(1) Meas Config Request has not been sent OR \n"
						"(2) Failure resp has been received for Meas Config Req for Strongest cell"
						" reporting OR \n (3) No resp has been received for CGI reporting Req, for "
						"UE_INDEX[%d], Meas Id %d. So Meas Results Ind mesage discarded!", 
						p_ue_context->ue_index, p_proc_data->meas_id);
				ret_val = RRM_FAILURE;
			}
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"SON Deregistered. So Meas Results Ind mesage discarded!");
			ret_val = RRM_FAILURE;

		}
		/* CSR00069389 Start */
		/*SPR 17061 Start*/
		/*SPR 15835:Start*/
		/* SPR 15397 Start */
		if(p_g_rrm_ue_ctx->p_ue_context->report_amount_ue == RRM_ZERO )
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
					"UE STATE SET TO NULL");

			p_g_rrm_ue_ctx->p_ue_context->procedure_awaited_state = RRM_UE_ERB_NULL;

			/* SPR 15854 Fix Start */
			if(((RRM_1 == p_proc_data->eutran_count) &&
						(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->eutran_neighbor_list[RRM_ZERO].bitmask))
					|| ((RRM_1 == p_proc_data->utran_count) &&
						/* SPR 16406 8SEP start */
						(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->utran_neighbor_list[RRM_ZERO].bitmask))
					/* SPR 16406 8SEP end */
					|| ((RRM_1 == p_proc_data->geran_count) &&
						(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->geran_neighbor_list[RRM_ZERO].bitmask))
					|| ((RRM_1 == p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.cdma2000_count) &&
						(RRM_UEM_MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT &
						 p_proc_data->cdma2000_meas_results.meas_result_list_cdma2000.meas_result_cdma2000[RRM_ZERO].bitmask)))
			{
				/* SPR 15854 Fix End */
				p_g_rrm_ue_ctx->p_ue_context->stored_meas_id_for_cgi = p_proc_data->meas_id;
				/* SPR 16053 start */
				/* Code deleted */
				/* SPR 16053 end */

			}
			/* SPR 15854 Fix Start */
			if((RRM_1 == p_proc_data->utran_count) &&
					(RRM_SON_EUTRAN_NC_CGI_PRESENT & p_proc_data->utran_neighbor_list[RRM_ZERO].bitmask))
			{
				p_g_rrm_ue_ctx->p_ue_context->stored_meas_id_for_cgi = p_proc_data->meas_id;
				/* SPR 16053 start */
				/* Code deleted */
				/* SPR 16053 end */

			}
			/* SPR 15854 Fix End */

			/** if queue not empty then dequeue the events */
			/* SPR 15860 Start */
			/* SPR 15861 Start */
			/* SPR 15862 Start */

			/* Code Removed */

			should_process_enqueued_proc = RRM_TRUE;

			/* SPR 15860 End */
			/* SPR 15861 End */
			/* SPR 15862 End */
			/* SPR 15397 End */
		}
		/*SPR 17061 End*/
		/* CSR00069389 End */
	}
	else
	{
		/* MC,MR & HO START  */ 

		if((p_proc_data->meas_id >= HO_MEAS_START_ID) && 
				(p_proc_data->meas_id <= MAX_MEAS_OBJECT_ID))
		{

			/* Bug 213 Start */ 
			//rrm_ue_context_t* p_ue_context = (rrm_ue_context_t*)p_ue_context;
			/*SPR_7831_CHANGES_START*/
			meas_type = rrm_check_meas_id_validity(p_ue_context, p_proc_data);

			switch(meas_type)
			{
				case MEAS_TYPE_ECID:
					{
						/*SPR_7831_CHANGES_END*/

						/* UE positioning code changes start */

						/* search is this meas result for any ue meas request that  was requested for ECID meas request */
						for(ecid_meas_index= RRM_ZERO; ecid_meas_index < RRM_MAX_ESMLC_MEAS_ID ; ecid_meas_index++)
						{
							/*SPR_8004:fix_start */
                                                  /* SPR 21496 Fix Start */ 
							if((p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_req_received))
                                                          /* SPR 21496 Fix End */ 
							{
								for(index = RRM_ZERO; index < MAX_ALLOCATED_ID_FOR_ECID ;index ++)
								{

                                                                  /* SPR 21496 Fix Start */ 
									if(p_ue_context->p_ue_positioing_data[ecid_meas_index].meas_id_and_meas_obj_id[index].meas_id \
											== p_proc_data->meas_id)
                                                                          /* SPR 21496 Fix End */ 
									{
										ue_meas_for_ecid_meas = RRM_TRUE;
										break;

									}
								}

								/*SPR_8004:fix_end */
								break;
							}
						}

						if(ue_meas_for_ecid_meas == RRM_TRUE)
						{
							/* To indicate in UE context that UE meas results ind has arrived */
                                                  /* SPR 21496 Fix Start */ 
							p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status |= RRM_ECID_UE_MEAS_RECVD;

							/*  store the UE  meas results in UE context and combined result 
							 ** will be sent later on at timer expiry */

							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"Storing the  UE meas results ind for esmlc_meas_id[%u] in the UE context for [UE:%u]",
									p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id,
									p_ue_context->ue_index);

							if(RRM_FAILURE == rrm_ue_store_ue_meas_results_in_ue_context(p_proc_data, p_ue_context, ecid_meas_index))
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
										"Failure to store UE meas results ind for esmlc_meas_id[%u] in the UE context for [UE:%u]",
										p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id,
										p_ue_context->ue_index);
							}
							if(p_ue_context->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD &&
									p_ue_context->is_mac_req_initiated == RRM_FALSE)
							{
								ret_val =  rrm_build_and_send_mac_ecid_meas_report_req(p_ue_context, 
										ue_started_meas_time_in_ms);
								if (RRM_FAILURE == ret_val)
								{
									RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
											"MAC EC_CID request failured for esmlc_meas_id =%u for [UE:%u]",
											p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id,
											p_ue_context->ue_index);
								}
							}
                                                        /* SPR 21496 Fix End */ 

							/* UE positioing code changes end */
						}
					}
					break;
					/* RACH_OPTIMIZATION_CHANGES_START */
				case MEAS_TYPE_RACH:
					{
						if((p_g_rrm_ue_ctx->rrm_uem_rach_info_data.is_ue_rach_report_active == RRM_TRUE)
								&& (p_ue_context->temp_rach_data.meas_id == p_proc_data->meas_id) && 
								(p_ue_context->temp_rach_data.is_ue_report_requested == RRM_TRUE))
						{
							/*As data has been stored so setting flag to FALSE*/
							p_ue_context->temp_rach_data.is_ue_report_requested = RRM_FALSE;
							/* SPR-18789 START*/
							p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*) rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
							if (RRM_PNULL != p_rrc_rrm_meas_config_req)
							{
								RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL, sizeof(rrc_rrm_meas_config_req_t));

								p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;

								if (RRM_ZERO != p_ue_context->meas_gap_config.meas_gap_config_type)
								{
									p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;
									p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask |= RRM_ZERO;
									p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type = RRM_ZERO;
									p_ue_context->meas_gap_sent_status = RRM_UNSET;
								}
								p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;
								p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count = RRM_ONE;
								p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[RRM_ZERO] =
									p_ue_context->temp_rach_data.report_config_id;


								if (RRM_FAILURE == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
											RRM_MODULE_ID,
											RRC_MODULE_ID,
											trans_id,
                                                                                      p_ue_context->cell_index))

								{
									RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
											"Failed to send rrm_rrc_meas_config_req");
								}
								else
								{
									RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
											RRM_BRIEF,
											"Send rrm_rrc_meas_config_req sucessfully");
									p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING;
								}

								RRM_MEM_FREE (p_rrc_rrm_meas_config_req);
							}
							else
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
										"Memory allocation failed for p_rrc_rrm_meas_config_req UE[%u]",
										p_ue_context->ue_index);
							}
							/* SPR-18789 END */

							/*As UE reported enough number of strongest cells than required, so considering the info*/
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
									"Storing the meas result ind results for RACH report");
							if(p_proc_data->eutran_count >= p_g_rrm_ue_ctx->rrm_uem_rach_info_data.
									strong_cell_info_count)
							{
								for(rach_index = RRM_ZERO; rach_index < p_g_rrm_ue_ctx->
										rrm_uem_rach_info_data.strong_cell_info_count; rach_index++)
								{
									p_ue_context->temp_rach_data.strong_cell_info[rach_index].pci = 
										p_proc_data->eutran_neighbor_list[rach_index].pci;
									p_ue_context->temp_rach_data.strong_cell_info[rach_index].rsrp = 
										p_proc_data->eutran_neighbor_list[rach_index].rsrp;
								}
								/*As number of preambles sent are more than 1, so strongest cell information is to be provided*/
								/*BUG_965_CHANGES_START*/
								/*As number of strongest cell is more than or equal to as requested from SON, so storing 
								  that much count as received as last argument*/
								store_rach_info_in_global_list(p_g_rrm_ue_ctx, p_ue_context, RRM_TRUE, 
										p_g_rrm_ue_ctx->rrm_uem_rach_info_data.strong_cell_info_count);
								/*BUG_965_CHANGES_END*/
							}
							else if(RRM_ZERO != p_proc_data->eutran_count)
							{
								for(rach_index = RRM_ZERO; rach_index < p_proc_data->eutran_count;
										rach_index++)
								{
									p_ue_context->temp_rach_data.strong_cell_info[rach_index].pci =
										p_proc_data->eutran_neighbor_list[rach_index].pci;
									p_ue_context->temp_rach_data.strong_cell_info[rach_index].rsrp =
										p_proc_data->eutran_neighbor_list[rach_index].rsrp;
								}
								/*As number of preambles sent are more than 1, so strongest cell information is to be provided*/
								/*BUG_965_CHANGES_START*/
								/*As number of strongest cell is less than as requested from SON, so storing 
								  that much count as received as last argument*/
								store_rach_info_in_global_list(p_g_rrm_ue_ctx, p_ue_context, RRM_TRUE, p_proc_data->eutran_count);
								/*BUG_965_CHANGES_END*/
							}
							else
							{
								/*UE reported less number of strongest cell info than what was required*/
								/*BUG_965_CHANGES_START*/
								/*As no strongest cell information is to be sent so count (last argument)
								  should be sent as ZERO*/
								store_rach_info_in_global_list(p_g_rrm_ue_ctx, p_ue_context, RRM_FALSE, RRM_ZERO);
								/*BUG_965_CHANGES_END*/
							}

						}
					}
					break;
					/*SPR 17192 Changes Start*/ 
				case MEAS_TYPE_ANR:
					/*SPR 17192 Changes End*/
                /*SPR 21541 Fix Start*/
                if((RRM_UE_MEAS_CONFIG_REQ_ONGOING == p_ue_context->current_procedure.state) || 
                        (RRM_UE_RECONFIG_ONGOING == p_ue_context->current_procedure.state))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Current procedure is \
                            MEAS_CONFIG_REQ || UE_RECONFIG_ONGOING, enqueue message",
                            p_ue_context->ue_index);
                    proc_queue.api_id = p_g_rrm_ue_ctx->api_id;
                    proc_queue.p_proc_data =
                        (rrm_ue_measurment_results_ind_t *)rrm_mem_get
                        (sizeof(rrm_ue_measurment_results_ind_t));

                    proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;

                    if(RRM_PNULL == proc_queue.p_proc_data)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                "Mem allocation failed");
                        ret_val1 = RRM_FAILURE;
                        RRM_UT_TRACE_EXIT();
                        return ret_val1;
                    }
                    else
                    {
                        RRM_MEMCPY(proc_queue.p_proc_data,  p_ue_context->current_procedure.p_proc_data,
                                sizeof(rrm_ue_measurment_results_ind_t));
                        /**Enqueue Meas Results reported for HO */
                        rrm_ue_mgr_enqueue_req( &proc_queue, p_ue_context,RRM_FALSE);
                        RRM_MEM_FREE(proc_queue.p_proc_data);
                        ret_val1 = RRM_FAILURE;
                        RRM_UT_TRACE_EXIT();
                        return ret_val1;
                    }
                }
                else
                {

					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
							"meas_id received from UE does not match with any of the "
							"meas_id in the list at RRM");
                }
                /*SPR 21541 Fix Stop*/
					/* RACH_OPTIMIZATION_CHANGES_END */
				case MEAS_TYPE_HO: 
					{
						/* CSR00069389 Start */
						/* SPR 16406 Start */
						if((RRM_UE_MEAS_CONFIG_REQ_ONGOING == p_ue_context->current_procedure.state) || 
								(RRM_UE_RECONFIG_ONGOING == p_ue_context->current_procedure.state))
							/* SPR 16406 End */
						{
							RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d],Current procedure is \
									MEAS_CONFIG_REQ, enqueue message",
									p_ue_context->ue_index);
							rrm_ue_procedure_queue_t    proc_queue;
							proc_queue.api_id = p_g_rrm_ue_ctx->api_id;
							proc_queue.p_proc_data =
								(rrm_ue_measurment_results_ind_t *)rrm_mem_get
								(sizeof(rrm_ue_measurment_results_ind_t));
							/*BUG 13332:start*/
							proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;
							/*BUG 13332:end*/

							if(RRM_PNULL == proc_queue.p_proc_data)
							{
								RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
										"Mem allocation failed");
								ret_val = RRM_FAILURE;
								/* SPR 15797 Start */
								RRM_UT_TRACE_EXIT();
								return ret_val;
								/* SPR 15797 End */

							}
							else
							{
								RRM_MEMCPY(proc_queue.p_proc_data,  p_ue_context->current_procedure.p_proc_data,
										sizeof(rrm_ue_measurment_results_ind_t));
								/**Enqueue Meas Results reported for HO */
								/*SPR 18241 START*/
								rrm_ue_mgr_enqueue_req( &proc_queue, p_ue_context,RRM_FALSE);
								/*SPR 18241 END*/
								/* SPR 15441 start */
								RRM_MEM_FREE(proc_queue.p_proc_data);
								/* SPR 15441 end */
								/* SPR 15797 Start */
								RRM_UT_TRACE_EXIT();
								/*SPR 17646 start*/
								/*Coverity 94892 Fix Start */
								ret_val1 = RRM_FAILURE;
								/*Coverity 94892 Fix End */
								/*SPR 17646 End*/
								return ret_val1;
								/* SPR 15797 End */
							}
						}
						else
						{
							/* CSR00069389 End */

							/*coverity 25401: p_idle_mode removed, aditya, rel1.3.1*/
							/* SPR 19838 : CID 12723 Fix Start */
							/* Code Removed */
							/* SPR 19838 : CID 12723 Fix End */

							if(RRM_FALSE == match_hrpd_meas_id(p_g_rrm_ue_ctx->p_ue_context, p_proc_data->meas_id))
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
										"match_hrpd_meas_id returned FALSE");  /* Coverity: CID 30734 Rel 2.1.3 */
							}
							if (RRM_FALSE == match_1xrtt_meas_id(p_g_rrm_ue_ctx->p_ue_context, p_proc_data->meas_id))
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
										"match_1xrtt_meas_id returned FALSE, i.e. meas id of measurement result does not match with meas id of 1xrtt");
							}

							if( (RRM_TRUE == p_ue_context->cdma2000_meas_id_received) &&
									(p_ue_context->cdma2000_capabilities.is_cdma2000_present) )
							{
								if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
								{
									if((p_ue_context->ho_params.csfb_blind_timer) &&
											(qvTimerRunning(p_ue_context->ho_params.csfb_blind_timer)))
									{
										if(((RRM_ZERO == p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].cdma2000_cell_type) && 
													(RRM_ZERO == p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].cdma2000_cell_type)) &&
												(RRM_TRUE == is_meas_id_configured_for_cdma2000_hrpd(p_g_rrm_ue_ctx->p_ue_context) &&
												 (RRM_TRUE == is_meas_id_configured_for_cdma2000_1xrtt(p_g_rrm_ue_ctx->p_ue_context))))
										{
											/* For first Report */
											/* CDMA2000 changes*/
											if(RRM_TRUE == match_hrpd_meas_id(p_g_rrm_ue_ctx->p_ue_context, p_proc_data->meas_id))
											{
												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].cdma2000_cell_type = 
													RRM_TRUE;
												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].meas_id = 
													p_proc_data->meas_id;

												index_cdma_cell = RRM_ONE;
											}
											else if(RRM_TRUE == match_1xrtt_meas_id(p_g_rrm_ue_ctx->p_ue_context, p_proc_data->meas_id))
											{
												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].cdma2000_cell_type = 
													RRM_TRUE;

												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].meas_id =
													p_proc_data->meas_id;

												index_cdma_cell = RRM_ZERO;
											}

											p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].pci_count = 
												p_proc_data->cdma2000_meas_results.
												meas_result_list_cdma2000.cdma2000_count;
											/*cov fix start 63937*/
											for(valid_pci = RRM_ZERO;
													((valid_pci <  p_proc_data->cdma2000_meas_results.
													  meas_result_list_cdma2000.cdma2000_count) && ( valid_pci < RRM_MAX_CELLS_REPORTED));
													/*p_g_rrm_ue_ctx->p_ue_context->meas_results_info.pci_count*/
													valid_pci++)
												/*cov fix end 63937*/
											{
												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].
													pci[valid_pci] = p_proc_data->cdma2000_meas_results.
													meas_result_list_cdma2000.meas_result_cdma2000[valid_pci].phy_cell_id;

												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].
													pilot_strength[valid_pci] = p_proc_data->cdma2000_meas_results.
													meas_result_list_cdma2000.meas_result_cdma2000[valid_pci].meas_result.
													pilot_strength;
											}
											/* CDMA2000 changes*/
										}
										else if((RRM_FALSE == is_meas_id_configured_for_cdma2000_hrpd(p_g_rrm_ue_ctx->p_ue_context)) &&
												(RRM_TRUE == is_meas_id_configured_for_cdma2000_1xrtt(p_g_rrm_ue_ctx->p_ue_context)) &&
												RRM_TRUE == match_1xrtt_meas_id(p_g_rrm_ue_ctx->p_ue_context, p_proc_data->meas_id))
										{ 
											/* This is the case only 1xRTT eCSFB */
											RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
													RRM_DETAILED, "CSFB Blind Timer");
                                    /* SPR-17852 START */
                                    if(p_ue_context->ho_params.csfb_blind_timer) 
                                    {
                                    /* CSR-58333-fix start*/
                                    rrm_ue_stop_timer(p_ue_context->ho_params.csfb_blind_timer);
                                    /* CSR-58333-fix end*/
                                    p_ue_context->ho_params.csfb_blind_timer = RRM_PNULL;
                                    } 
                                    /* SPR-17852 END */
											ret_val1 = rrm_ue_handle_meas_results_ind_for_ho(p_g_rrm_ue_ctx);
										}
										else
										{
											/* For Second Report */
											if((RRM_ZERO != p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].
														cdma2000_cell_type) || (RRM_ZERO != p_g_rrm_ue_ctx->p_ue_context->
															meas_results_info[RRM_ONE].cdma2000_cell_type))
											{
												if(RRM_TRUE == match_hrpd_meas_id(p_g_rrm_ue_ctx->p_ue_context, 
															p_proc_data->meas_id))
												{
													p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].cdma2000_cell_type = 
														RRM_TRUE;
													p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].meas_id = 
														p_proc_data->meas_id;

													index_cdma_cell = RRM_ONE;
												}
												else if(RRM_TRUE == match_1xrtt_meas_id(p_g_rrm_ue_ctx->p_ue_context, 
															p_proc_data->meas_id))
												{
													p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].cdma2000_cell_type = 
														RRM_TRUE;
													p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].meas_id =
														p_proc_data->meas_id;

													index_cdma_cell = RRM_ZERO;
												}

												p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].pci_count = 
													p_proc_data->cdma2000_meas_results.
													meas_result_list_cdma2000.cdma2000_count;
												/*cov fix start 63937*/    
												for(valid_pci = RRM_ZERO;
														((valid_pci <  p_proc_data->cdma2000_meas_results.
														  meas_result_list_cdma2000.cdma2000_count) && ( valid_pci < RRM_MAX_CELLS_REPORTED));
														/*p_g_rrm_ue_ctx->p_ue_context->meas_results_info.pci_count*/
														valid_pci++)
													/*cov fix end 63937*/
												{
													p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].
														pci[valid_pci] = p_proc_data->cdma2000_meas_results.
														meas_result_list_cdma2000.meas_result_cdma2000[valid_pci].phy_cell_id;

													p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].
														pilot_strength[valid_pci] = p_proc_data->cdma2000_meas_results.
														meas_result_list_cdma2000.meas_result_cdma2000[valid_pci].meas_result.
														pilot_strength;
												}

											}

											// Stop the csfb timer
											RRM_TRACE (g_uem_log_on_off, p_rrm_uem_facility_name,
													RRM_DETAILED, "CSFB Blind Timer");
                                    /* SPR-17852 START */
                                    if(p_ue_context->ho_params.csfb_blind_timer)
                                    {
                                    /* CSR-58333-fix start*/
                                    rrm_ue_stop_timer(p_ue_context->ho_params.csfb_blind_timer);
                                    /* CSR-58333-fix end*/
                                    p_ue_context->ho_params.csfb_blind_timer = RRM_PNULL;
                                    }
                                    /* SPR-17852 END */

											ret_val1 = rrm_ue_handle_meas_results_ind_for_ho(p_g_rrm_ue_ctx);
										}
									}
								}
								else
								{
									if(RRM_TRUE == match_hrpd_meas_id(p_g_rrm_ue_ctx->p_ue_context, 
												p_proc_data->meas_id))
									{
										p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].cdma2000_cell_type = 
											RRM_TRUE;
										p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ONE].meas_id = 
											p_proc_data->meas_id;

										index_cdma_cell = RRM_ONE;
									}
									else if(RRM_TRUE == match_1xrtt_meas_id(p_g_rrm_ue_ctx->p_ue_context, p_proc_data->meas_id))
									{
										p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].cdma2000_cell_type = 
											RRM_TRUE;
										p_g_rrm_ue_ctx->p_ue_context->meas_results_info[RRM_ZERO].meas_id =
											p_proc_data->meas_id;

										index_cdma_cell = RRM_ZERO;
									}

									p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].pci_count = 
										p_proc_data->cdma2000_meas_results.
										meas_result_list_cdma2000.cdma2000_count;
									/*cov fix start 63937*/
									for(valid_pci = RRM_ZERO;
											((valid_pci <  p_proc_data->cdma2000_meas_results.
											  meas_result_list_cdma2000.cdma2000_count) && ( valid_pci < RRM_MAX_CELLS_REPORTED));
											/*p_g_rrm_ue_ctx->p_ue_context->meas_results_info.pci_count*/
											valid_pci++)
										/*cov fix end 63937*/
									{
										p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].
											pci[valid_pci] = p_proc_data->cdma2000_meas_results.
											meas_result_list_cdma2000.meas_result_cdma2000[valid_pci].phy_cell_id;

										p_g_rrm_ue_ctx->p_ue_context->meas_results_info[index_cdma_cell].
											pilot_strength[valid_pci] = p_proc_data->cdma2000_meas_results.
											meas_result_list_cdma2000.meas_result_cdma2000[valid_pci].meas_result.
											pilot_strength;
									}
									/*CP Fix for B1, B2 configuration Start */
									ret_val1 = rrm_ue_handle_meas_results_ind_for_ho(p_g_rrm_ue_ctx);
									/*CP Fix for B1, B2 configuration Stop */
								}
								/* SPR 15441 start */
								/* code removed */
								/* SPR 15441 end */
								/*SPR 15797 +-*/
								RRM_UT_TRACE_EXIT();
								return ret_val1;
							}

							if (p_ue_context->ue_ho_current_state == RRM_HO_STATE_WAIT_FOR_REL)
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
										"Measuremnt Report (meas_id=%u) received while waiting "
										"for Release after HO, Ignoring the report for UE(%u)",
										p_proc_data->meas_id,
										p_g_rrm_ue_ctx->p_ue_context->ue_index);
								ret_val = RRM_FAILURE;
							}
							else 
							{
								/* Bug 213 End */
								ret_val = rrm_ue_handle_meas_results_ind_for_ho(p_g_rrm_ue_ctx);
								/* Coverity Fix 94908 Start */
								if(RRM_FAILURE == ret_val)
								{
									RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
											"Failure returned by function rrm_ue_handle_meas_results_ind_for_ho");
								}
								/* Coverity Fix 94908 End */
							} 
							/*SPR 17646 Start*/

							should_process_enqueued_proc = RRM_TRUE;
							/*SPR 17646 End*/
						}
						/* CSR00069389 Start */
					}
					/* CSR00069389 End */
					/*SPR_7831_CHANGES_START*/
					break;
					/*SPR 17192 +-*/
                 /* SPR 18431 Fix Start */
                case MEAS_TYPE_CA:
                {
                    ret_val = rrm_uem_masa_meas_config_ind(p_g_rrm_ue_ctx);
                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Failure returned by function rrm_uem_masa_meas_config_ind");
                    }
                    break;
                }
                    /* SPR 18431 Fix End */


/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
                case MEAS_TYPE_EUTRA_NR:
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Case MEAS_TYPE_EUTRA_NR hit \n");
                    ret_val = rrm_ue_handle_meas_results_ind_for_nr(p_g_rrm_ue_ctx);
                    if (RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                  "Failure while handling NR measurement report");
                    }
                    
                    break;
                }
#endif
/* ENDC_MEAS_CHANGES_END */
				default:
					break;
			}
			/*SPR_7831_CHANGES_END*/
			/* SPR 15860 Start */
			/* SPR 15861 Start */
			/* SPR 15862 Start */
			/*SPR 17646 +-*/ 
			/* SPR 15860 End */
			/* SPR 15861 End */
			/* SPR 15862 End */
		}
	}
	/*SPR 15797 +-*/
	/*SPR 17646 Start*/
	/* Coverity_fix_94899_start */
	if(RRM_TRUE == should_process_enqueued_proc)
		ret_val = RRM_SUCCESS;
	else
		ret_val = RRM_FAILURE;
	/* Coverity_fix_94899_end */
	/*SPR 17646 End*/
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_reestab_config_cnf_in_ho
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RRC_RRM_UE_REESTAB_CONFIG_CNF message in HO ongoing.
 ****************************************************************************/
rrm_return_et
	rrm_ue_handle_ue_reestab_config_cnf_in_ho
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
	rrm_ue_context_t *p_ue_context = RRM_PNULL;
	rrm_return_et     ret_val      = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
	p_ue_context->is_ho_failed = RRM_TRUE;

	/* CA Stage 3 Start */
/* CA_Stage3_Change: Start */
	if(RRM_TRUE == rrm_was_any_scell_activated_for_ue(p_ue_context, RRM_TRUE))
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				"Scell was activated before reestablihment, so need to reactivate the scell");

		rrm_mac_ue_reconfig_scell_reactivation_on_ho_out_failure(p_ue_context, RRM_TRUE);
	}
	else
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
				"No Scell was activated before reestablishment, so no need to reactivate any scell");
	}
	/* CA Stage 3 End */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* SPR 16053 start */
/****************************************************************************
 * Function Name  : rrm_ue_handle_ue_reestab_config_cnf
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RRC_RRM_UE_REESTAB_CONFIG_CNF message in HO ongoing.
 ****************************************************************************/
rrm_return_et
    rrm_ue_handle_ue_reestab_config_cnf
(
 rrm_ue_global_context_t *p_g_rrm_ue_ctx
 )
{
    rrm_ue_context_t                   *p_ue_context = RRM_PNULL;
    rrm_return_et                       ret_val      = RRM_SUCCESS;
    /* Coverity Fix 88194 Start */
    rrc_rrm_meas_config_req_t          *p_rrc_rrm_meas_config_req; 
    /* Coverity Fix 88194 End */
    rrm_ue_procedure_record_t          *p_rrm_ue_procedure_record = RRM_PNULL;
    U8                                 *p_proc_data = RRM_PNULL;
    U8                                  meas_id_count = RRM_ZERO;
    U8                                  count = RRM_ZERO;
    /*SPR 18241 START*/
    rrm_bool_et                         rrm_not_handling_reestablishment = RRM_FALSE;
    /*SPR 18241 END*/

    U16                                 transaction_id = RRM_ZERO;
    U8                                  report_id = RRM_ZERO;
    rrm_bool_et                         report_configured = RRM_FALSE;
    /*SPR_17893_START*/
    meas_report_info_node_t* p_meas_report_node = RRM_PNULL;
    rrm_bool_et              set_state_to_active  = RRM_FALSE;
    /*SPR_17893_END*/
    RRM_UT_TRACE_ENTER();

    /* Coverity Fix 88194 Start */ 
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t *)rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    if (p_rrc_rrm_meas_config_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_rrm_meas_config_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_rrc_rrm_meas_config_req,
            RRM_ZERO, sizeof(rrc_rrm_meas_config_req_t));
    /* Coverity Fix 88194 End */

    /*Coverity 94779 Fix Start*/
    if(p_g_rrm_ue_ctx != RRM_PNULL)
    {
        p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
        /* CA Stage 3 Start */
        /* CA_Stage3_Change: Start */
        if(RRM_TRUE == rrm_was_any_scell_activated_for_ue(p_ue_context, RRM_FALSE))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Scell was activated before reestablihment, so need to reactivate the scell");

            rrm_mac_ue_reconfig_scell_reactivation_on_ho_out_failure(p_ue_context, RRM_FALSE);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "No Scell was activated before reestablishment, so no need to reactivate any scell");
        }
        /* CA Stage 3 End */
        /*Coverity 94779 Fix End*/
        p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
        if(RRM_PNULL != p_ue_context )
        {
            /*SPR 18241 START*/
            p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
            /*SPR 18241 END*/

            /*SPR_17893_START*/
            if((RRM_SUCCESS == *((U8 *)p_ue_context->current_procedure.p_proc_data)) && 
                    (RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES == p_ue_context->ue_state))
            {
                if(p_ue_context->ho_params.bitmask & RRM_UE_CSFB_RECD)
                {
                    set_state_to_active = RRM_TRUE; 
                }    
                else
                {    
                    p_meas_report_node = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));
                    while (p_meas_report_node)
                    {
                        if ((RRM_MEAS_CONFIG_RESP_SUCCESS == p_meas_report_node->meas_status) &&
                                ((MEAS_REP_EVENT_B2 ==  p_meas_report_node->reporting_event)||
                                 (MEAS_REP_EVENT_B1  ==  p_meas_report_node->reporting_event)) &&
                                (RRM_IRAT_PRIORITY_UTRAN == p_meas_report_node->rat_type))
                        {
                            set_state_to_active  = RRM_TRUE;
                            break;
                        }
                        p_meas_report_node = (meas_report_info_node_t*)ylNext(&p_meas_report_node->sNode);
                    }
                }  

                if(RRM_FALSE == set_state_to_active)
                {
                    rrm_ue_set_state(p_ue_context,RRM_UE_STATE_ACTIVE);
                    rrm_set_utran_capability_enq_info(p_ue_context,RRM_FALSE,RRM_FALSE);
                    p_ue_context->is_ho_reqd_on_recv_utan_cap  = RRM_FALSE;
                }
                else
                {
                    /*Currenlty Assuming that no failure shall happen*/
                    rrm_populate_and_send_utran_cap_enq_req(p_ue_context);
                }
            }
            /*SPR_17893_END*/

            /*SPR 18241 START*/
            if (rrm_get_queue_count(&p_ue_context->procedure_queue))
            {

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], dequeue queued \
                        message",p_ue_context->ue_index);
                /** Dequeue the events from event queue and call message handler */
                /* SPR 15849 Start */
                p_rrm_ue_procedure_record = rrm_request_dequeue(p_ue_context);
                /* SPR 15849 End */
                /*LTE_RRM_KLOCWORK_WARN_6_JULY_12_START*/
                if(RRM_PNULL != p_rrm_ue_procedure_record)
                { 
                    if(p_rrm_ue_procedure_record->proc_queue.api_id == RRC_RRM_UE_CONTEXT_MOD_REQ)
                    {
                        rrm_ue_handle_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx,p_g_rrm_ue_ctx->p_ue_context->cell_index);
                        rrm_not_handling_reestablishment = RRM_TRUE;
                    }
                    else
                    {
                        rrm_ue_mgr_enqueue_back_req(&p_rrm_ue_procedure_record->proc_queue, p_g_rrm_ue_ctx->p_ue_context);
                    }    

                }
                /*LTE_RRM_KLOCWORK_WARN_6_JULY_12_END*/
            }
            /*SPR 18241 END*/

            p_proc_data = (U8 *)p_ue_context->current_procedure.p_proc_data;

            /*SPR 18241 14JAN START*/
            if((*p_proc_data == RRM_SUCCESS)&&(rrm_not_handling_reestablishment == RRM_FALSE))
                /*SPR 18241 14JAN END*/
            {
                /* Mark the UE's current procedure's state */
                /*SPR 18241 START*/
                /*code moved*/
                /*SPR 18241 END*/
                /* Check if CDRX is in Disabled state then check if any meas node exists for CGI */
                if(p_ue_context->cdrx_status == RRM_UE_CDRX_DISABLED)
                {
                    if(p_ue_context->is_cgi_process_in_progress == RRM_FALSE)
                    {
                        /* Spr 18488 Changes Start */
                        RRM_MEMSET(p_rrc_rrm_meas_config_req,RRM_ZERO, sizeof(rrc_rrm_meas_config_req_t));
                        /* Spr 18488 Changes End */

                        /* It is the case of strongest cell */
                        /* Coverity Fix 88194 Start */
                        p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;
                        /* Coverity Fix 88194 End */
                        /* Recalculating the total number of reports pending on the UE */
                        p_ue_context->report_amount_ue = RRM_ZERO;
                        for( count = RRM_ZERO; count < RRM_ANR_MAX_MEAS_OBJ; count++ )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Report Counter = [%d] & Status = [%d] for meas_id [%d]",
                                    p_ue_context->p_meas_config[count].report_counter,
                                    p_ue_context->p_meas_config[count].meas_config_status,
                                    count + RRM_ONE);
                            if (p_ue_context->p_meas_config[count].meas_config_status == RRM_MEAS_CONFIG_RESP_SUCCESS)
                            {
                                report_configured = RRM_TRUE;
                                if(RRM_ZERO != p_ue_context->p_meas_config[count].report_counter)
                                {
                                    /* All reports of strongest cell is yet to be received */
                                    p_ue_context->p_meas_config[count].report_counter = RRM_MAX_STRONGEST_CELL_RPT;
                                    p_ue_context->report_amount_ue += p_ue_context->p_meas_config[count].report_counter;
                                }
                                else
                                {
                                    /* Reports corresponding to this measurement is received and it is no longer required */
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                            "Removing measId [%d] after reestablishment as strongest cells reports are already received",
                                            count + RRM_ONE);
                                    /* Coverity Fix 88194 Start */
                                    p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.meas_id[meas_id_count] =
                                        p_ue_context->p_meas_config[count].meas_id;
                                    /* Coverity Fix 88194 End */
                                    meas_id_count++;
                                    report_id = p_ue_context->p_meas_config[count].report_id;
                                    p_ue_context->p_meas_config[count].meas_config_status = RRM_MEAS_CONFIG_TO_DELETE;
                                }
                            }
                            /* SPR 21496 Fix End */ 
                        }
                        if (RRM_TRUE == report_configured)
                        {
                            if (RRM_ZERO == p_ue_context->report_amount_ue)
                            {
                                /* All reports of strongest cell corresponding to all Ids are received delete the report instead of measId */
                                /* Coverity Fix 88194 Start */
                                p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[RRM_ZERO] = report_id;
                                p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count = RRM_ONE;
                                p_rrc_rrm_meas_config_req->meas_config.bitmask = UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;
                                /* Coverity Fix 88194 End */
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "Removing report config = %d", report_id);
                                /* Remove measurement gap if it is configured */
                                if (RRM_ZERO != p_ue_context->meas_gap_config.meas_gap_config_type)
                                {
                                    p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;
                                    p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask = RRM_ZERO;
                                    p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type = RRM_ZERO;
                                    /*SPR_17047_START*/
                                    p_ue_context->meas_gap_sent_status = RRM_UNSET;
                                    /*SPR_17047_END*/

                                }
                            }
                            else
                            {
                                /* Removed the particular Id only */
                                /* Coverity Fix 88194 Start */
                                p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.count = meas_id_count;
                                p_rrc_rrm_meas_config_req->meas_config.bitmask = UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT;
                            }

                            if((p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.count) ||
                                    (p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count))
                            {
                                ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                                        RRM_MODULE_ID, RRC_MODULE_ID,transaction_id, p_ue_context->cell_index);
                                /* Coverity Fix 88194 End */

                                if(ret_val == RRM_FAILURE)
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                            "Failed to send MEAS CONFIG REQUEST for UE_INDEX[%d]",
                                            p_ue_context->ue_index);
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                            "Successfully sent MEAS CONFIG REQUEST for UE_INDEX[%d]",
                                            p_ue_context->ue_index);
                                    p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;/*RRM_MEAS Changes */
                                    p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING;
                                }
                                /* Coverity Fix 88194 Start */
                                if(RRM_PNULL != p_rrc_rrm_meas_config_req)
                                {
                                    RRM_MEM_FREE (p_rrc_rrm_meas_config_req);
                                }
                                /* Coverity Fix 88194 End */
                                RRM_UT_TRACE_EXIT();
                                return ret_val;
                            }
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "CGI status is [%u] for UE_INDEX[%d]",
                                p_ue_context->is_cgi_process_in_progress,
                                p_ue_context->ue_index);
                    }
                    /* Checking if CGI is pending on the UE so that it can be deleted */
                    if(RRM_TRUE == rrm_uem_check_cgi_reports_pending(p_ue_context))
                    {
                        /* SPR 16406 8SEP start */
                        p_ue_context->meas_rep_event = MEAS_REP_EVENT_FOR_CGI;
                        ret_val = rrm_build_and_send_meas_config_req(p_ue_context,MEAS_TYPE_HO);
                        /* Coverity Fix 87062 Start */
                        if(RRM_FAILURE == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Failure returned by the function rrm_build_and_send_meas_config_req");
                        }
                        /* Coverity Fix 87062 End */
                        p_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
                        /* SPR 16406 8SEP end */
                    }
                    else if(((RRM_UE_ERB_NULL == p_ue_context->procedure_awaited_state)) &&
                            (RRM_FALSE == rrm_check_is_meas_config_in_status_to_be_delete(p_ue_context)) &&
                            (RRM_TRUE == rrm_check_is_next_queued_api_meas_config(p_ue_context)))
                    {
                        /* Configure the next CGI on the UE as no strongest cell is pending on the UE */
                        /** if queue not empty then dequeue the events */
                        if (rrm_get_queue_count(&p_ue_context->procedure_queue))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE_INDEX[%d], dequeue queued message",
                                    p_ue_context->ue_index);
                            /** Dequeue the events from event queue and call message handler */
                            p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                            if(RRM_PNULL != p_rrm_ue_procedure_record)
                            {
                                rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
                            }
                        }
                    }
                }
                /* Check if CDRX is in Applied state then Check from the procedural queue if the next
                 * message to be dequeued is Meas Config for CGI else get CDRX removed. CDRX will again be
                 * applied when CGI request will be dequeued. */
                if(p_ue_context->cdrx_status == RRM_UE_CDRX_APPLIED)
                {
                    if(RRM_TRUE == rrm_check_is_next_queued_api_meas_config(p_ue_context))
                    {
                        /** if queue not empty then dequeue the events */
                        if (rrm_get_queue_count(&p_ue_context->procedure_queue))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE_INDEX[%d], dequeue queued message",
                                    p_ue_context->ue_index);
                            /** Dequeue the events from event queue and call message handler */
                            p_rrm_ue_procedure_record =rrm_request_dequeue(p_ue_context);
                            if(RRM_PNULL != p_rrm_ue_procedure_record)
                            {
                                rrm_ue_process_dequeued_msg(p_rrm_ue_procedure_record, p_g_rrm_ue_ctx);
                            }
                        }
                    }
                    else
                    {
                        /* Check if all the PCI reports and CGI reports of all the requested CGIs have been received
                           for this UE, then remove the CDRX configuration applied for eCGI reports and apply DRX */
                        if(RRM_TRUE != rrm_ue_is_cgi_report_pending(p_ue_context))
                        {
                            p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_REMOVED;
                        }
                    }
                }
                /* Check if CDRX is in To be removed state as all CGI is complete
                 * then send UE reconfig req. for CDRX removal */
                if(p_ue_context->cdrx_status == RRM_UE_CDRX_TO_BE_REMOVED)
                {
                    if (RRM_FAILURE == rrm_build_and_send_ue_reconfig_req(p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to send UE reconfig request to remove CDRX, UE index[%d]",
                                p_ue_context->ue_index);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE reconfig request sent to UE index[%d] to remove CDRX ",
                                p_ue_context->ue_index);
                    }
                }
                /* Check if CDRX is in applied state then do nothing */

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        " Failure response received in Re-estab Ind!!!");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    " UE Context is NULL!!!");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                " Global UE Context is NULL!!!");
    }
    /* Coverity Fix 97069 Start */
    if (RRM_PNULL != p_rrc_rrm_meas_config_req)
    {
        RRM_MEM_FREE (p_rrc_rrm_meas_config_req);
    }
    /* Coverity Fix 97069 End */

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* SPR 16053 end */

/* SPR 9216:MRO enhancement end */
/*SPR 11535:start*/
/****************************************************************************
 * Function Name  : rrm_ue_handle_rrc_ho_ongoing_ue_inactivity 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RRC_RRM_UE_INACTIVE  message in HO ongoing state.
 ****************************************************************************/
rrm_return_et rrm_ue_handle_rrc_ho_ongoing_ue_inactivity(
        rrm_ue_global_context_t *p_g_rrm_ue_ctx
        )
{
    rrm_return_et                ret_val = RRM_SUCCESS;
    rrm_ue_context_t	       	 *p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    rrm_ue_procedure_queue_t     proc_queue = {RRM_ZERO};
    rrm_ue_inactive_t            *p_ue_inactive = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /*queue the mesaage*/
    p_ue_inactive = (rrm_ue_inactive_t *)rrm_mem_get(sizeof(rrm_ue_inactive_t));
    /*Coverity 65139:start*/
    if(RRM_PNULL != p_ue_inactive)
    {
        /*Coverity 65139:end*/
        p_ue_inactive->ue_index = p_ue_context->ue_index; 
        p_ue_inactive->cell_index = p_ue_context->cell_index; 
        proc_queue.api_id = p_g_rrm_ue_ctx->api_id; 
        /*p_proc_data is null copy ue_index and cell index in proc_data*/
        proc_queue.p_proc_data = (void *)p_ue_inactive; 
        /*BUG 13332:start*/ 
        proc_queue.trans_id = p_g_rrm_ue_ctx->trans_id;
        /*BUG 13332:end*/ 
        /**Enqueue ERAB setup request */
        /*SPR 18241 START*/
        ret_val = rrm_ue_mgr_enqueue_req( &proc_queue, p_g_rrm_ue_ctx->p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
        /*p_ue_inactive will be freed after dequeue*/
        /*Coverity 94016 Fix Start*/
        RRM_MEM_FREE(proc_queue.p_proc_data);
        proc_queue.p_proc_data = PNULL;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "\n UE inactivity recevied in HO_ONGOING state to RRC ");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_rrc_ue_inactivity 
 * Inputs         : rrm_global_context_t *p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RRC_RRM_UE_INACTIVE  message in UE_STATE_ACTIVE.
 ****************************************************************************/
rrm_return_et rrm_ue_handle_rrc_ue_inactivity(
		rrm_ue_global_context_t *p_g_rrm_ue_ctx
		)
{
	rrm_return_et                ret_val = RRM_SUCCESS;
	rrm_ue_context_t	       	 *p_ue_context = p_g_rrm_ue_ctx->p_ue_context;

	RRM_UT_TRACE_ENTER();

	if (RRM_PNULL != p_ue_context)
	{
		/*send connection release*/
		ret_val = rrm_build_and_send_ue_connection_release_ind
			(p_ue_context->ue_index,
			 RADIO_NETWORK_LAYER_TYPE,
			 USER_INACTIVITY,
			 RRM_ZERO,
			 RRM_PNULL,
			 /* SPR_10729_fix */
			 p_ue_context->cell_index);

		if (RRM_FAILURE == ret_val)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"\nError in sending the ue_connection_release_ind to RRC ");
		}
		else
		{
			ret_val = rrm_ue_resource_clean_up(p_ue_context);
			if(RRM_FAILURE == ret_val)  
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
						RRM_DETAILED,"ue_connection_release_ind sent, \
						Failed to clean up ue resources");
			}
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*SPR 11535:end*/
/* SPR 10450 Fix Start */
rrm_void_t
	rrm_handle_ue_reconfig_response_for_drx
(
 rrm_ue_context_t *p_ue_context,
 U8                response 
 )
{
	RRM_UT_TRACE_ENTER();

	if( RRM_ZERO == response)
	{
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
				"FAILURE: UE reconfig failed for DRX Configuration."
				"Rollback to the last applied drx configuration");
		/* SPR 12480 Start */
		/* reset the CDRX configuration status */
		if (RRM_UE_CDRX_TO_BE_APPLIED == p_ue_context->cdrx_status)
		{
			p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
		}
		else if (RRM_UE_CDRX_TO_BE_REMOVED == p_ue_context->cdrx_status)
		{
			p_ue_context->cdrx_status = RRM_UE_CDRX_APPLIED;
		}

		/*spr_12699_fix_start*/
		else if(NO_DRX_PROFILE !=  p_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index)
			/* SPR 12480 End */
		{

			rrm_ue_rac_clear_drx_res( p_ue_context->cell_index,
					p_ue_context->applied_drx_config.
					curr_applied_drx_config.applied_drx_profile_index,
					p_ue_context->applied_drx_config.
					curr_applied_drx_config.applied_drx_offset_val
					);
			RRM_MEMCPY(&(p_ue_context->applied_drx_config.curr_applied_drx_config),
					&(p_ue_context->ue_phy_config_information.ue_backup_applied_drx_config),
					sizeof(rrm_ue_applied_drx_config_t));    
			rrm_ue_rac_apply_drx_res ( p_ue_context->cell_index,
					p_ue_context->applied_drx_config.
					curr_applied_drx_config.applied_drx_profile_index,
					p_ue_context->applied_drx_config.
					curr_applied_drx_config.applied_drx_offset_val
					);
		}
		/*spr_12699_fix_end*/
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
				"SUCCESS: UE reconfig is successful for DRX Configuration."
				"Commit the newly applied drx configuration");
		p_ue_context->applied_drx_config.num_of_released_erab = RRM_ZERO;
		RRM_MEMSET(p_ue_context->applied_drx_config.released_erab_info,
				RRM_ZERO, RRM_MAX_NUM_DRB_PER_UE);

		RRM_MEMCPY(&(p_ue_context->ue_phy_config_information.ue_backup_applied_drx_config),
				&(p_ue_context->applied_drx_config.curr_applied_drx_config),
				sizeof(rrm_ue_applied_drx_config_t));    
	}

	RRM_UT_TRACE_EXIT(); 
}
/* SPR 10450 Fix End */

/* SPR 15232 start */
/* SPR 16406 Start */
/****************************************************************************
 * Function Name  : rrm_search_and_remove_phy 
 * Inputs         : ue context, phys_cell_id
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function rollbacks the Dynamic ICIC data with the values 
 *                  of the last successful UE reconfig/attach.
 ****************************************************************************/
/* SPR 16406 24Sep start */
rrm_return_et 
rrm_search_and_remove_phy(
		rrm_ue_context_t *p_ue_context,
		/* SPR 15674 Start */
		U16 phy_cell_id,
		U16 earfcn
		/* SPR 15674 End */
		)
{
	U16     i           = RRM_ZERO;
	U16     j           = RRM_ZERO;
	rrm_bool_et found = RRM_FALSE;

	cell_selection_priority_list_t*     p_known_cell_selection = RRM_PNULL;
	cell_selection_priority_list_t*     p_unknown_cell_selection = RRM_PNULL;
	cell_selection_priority_list_t*     p_confused_cell_selection = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	switch (p_ue_context->target_cell_type)
	{
		case GERAN_CELL:
			p_known_cell_selection = &p_ue_context->ho_params.geran_known_cell_selection_list;
			p_unknown_cell_selection = &p_ue_context->ho_params.geran_unknown_cell_selection_list;
			p_confused_cell_selection = &p_ue_context->ho_params.geran_confused_cell_selection_list;
			break;

		case UTRA_CELL:
			p_known_cell_selection = &p_ue_context->ho_params.utra_known_cell_selection_list;
			p_unknown_cell_selection = &p_ue_context->ho_params.utra_unknown_cell_selection_list;
			p_confused_cell_selection = &p_ue_context->ho_params.utra_confused_cell_selection_list;
			break;

		case EUTRA_CELL:
			p_known_cell_selection = &p_ue_context->ho_params.eutra_known_cell_selection_list;
			p_unknown_cell_selection = &p_ue_context->ho_params.eutra_unknown_cell_selection_list;
			p_confused_cell_selection = &p_ue_context->ho_params.eutra_confused_cell_selection_list;
			break;

		default:
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
					"Removal of PhyId from the list is not supported for this RAT[%u]",
					p_ue_context->target_cell_type);

			RRM_UT_TRACE_EXIT(); 
			return RRM_FAILURE;
	}

	if (RRM_PNULL != p_known_cell_selection)
	{
		for (i = RRM_ZERO; i < p_known_cell_selection->count; i++) 
		{
			/* SPR 15674 Start */
			if ((p_known_cell_selection->reported_neighbor_cell_info[i].phy_cell_id == phy_cell_id)&&
					(p_known_cell_selection->reported_neighbor_cell_info[i].target_earfcn == earfcn))
				/* SPR 15674 End */
			{
				/* SPR 16406 24Sep Start */
                /* Coverity Fix 93897 Start */ 
				if (RRM_ONE == p_known_cell_selection->reported_neighbor_cell_info[i].reported_count)
				{
					/* SPR 16406 24Sep End */
					for (j = i; j <  p_known_cell_selection->count - RRM_ONE; j++)
					{
						p_known_cell_selection->reported_neighbor_cell_info[j] = p_known_cell_selection->reported_neighbor_cell_info[j + RRM_ONE];
					}
					if(RRM_ZERO != p_known_cell_selection->count)
					{
						p_known_cell_selection->count--;
					}
					/* SPR 16406 24Sep Start */
                    /* Coverity Fix 93897 End */
					if (RRM_ZERO != p_known_cell_selection->next_target_cell_idx)
					{
						/* Cell at this index has shifted to previous index because of deletion */
						p_known_cell_selection->next_target_cell_idx = p_known_cell_selection->next_target_cell_idx - RRM_ONE;
					}
					/* SPR 16406 24Sep End */
					/* SPR 16406 24Sep Start */
				}
                /* SPR 17660 Fix Start */
                else if (RRM_ONE < p_known_cell_selection->reported_neighbor_cell_info[i].reported_count)
                {
                    p_known_cell_selection->reported_neighbor_cell_info[i].reported_count--;
                }
                /* SPR 17660 Fix End */
				/* SPR 16406 24Sep End */
				found = RRM_TRUE;
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"PhyId [%u] found", phy_cell_id);
				break;
			}
		}
	}

	if ((found == RRM_FALSE) && (RRM_PNULL != p_unknown_cell_selection))
	{
		for (i = RRM_ZERO; i < p_unknown_cell_selection->count; i++) 
		{
			/* SPR 15674 Start */
			if ((p_unknown_cell_selection->reported_neighbor_cell_info[i].phy_cell_id == phy_cell_id)&&
					(p_unknown_cell_selection->reported_neighbor_cell_info[i].target_earfcn == earfcn))
				/* SPR 15674 End */
			{
				/* SPR 16406 24Sep Start */
				if (RRM_ONE == p_unknown_cell_selection->reported_neighbor_cell_info[i].reported_count)
				{
					/* SPR 16406 24Sep End */
                    /* Coverity Fix 93897 Start */
					for (j = i; j <  p_unknown_cell_selection->count - RRM_ONE; j++)
					{
						p_unknown_cell_selection->reported_neighbor_cell_info[j] = p_unknown_cell_selection->reported_neighbor_cell_info[j + RRM_ONE];
					}
					if(RRM_ZERO != p_unknown_cell_selection->count)
					{
						p_unknown_cell_selection->count--;
					}
					/* SPR 16406 24Sep Start */
                    /* Coverity Fix 93897 End */
					if (RRM_ZERO != p_unknown_cell_selection->next_target_cell_idx)
					{
						/* Cell at this index has shifted to previous index because of deletion */
						p_unknown_cell_selection->next_target_cell_idx = p_unknown_cell_selection->next_target_cell_idx - RRM_ONE;
					}
					/* SPR 16406 24Sep End */
					/* SPR 16406 24Sep Start */ 
				}
                /* SPR 17660 Fix Start */
                else if (RRM_ONE < p_unknown_cell_selection->reported_neighbor_cell_info[i].reported_count)
                {
                    p_unknown_cell_selection->reported_neighbor_cell_info[i].reported_count--;
                }
                /* SPR 17660 Fix End */
				/* SPR 16406 24Sep End */
				found = RRM_TRUE;
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"PhyId [%u] found", phy_cell_id);
				break;
			}
		}
	}

	if ((found == RRM_FALSE) && (RRM_PNULL != p_confused_cell_selection))
	{
		for (i = RRM_ZERO; i < p_confused_cell_selection->count; i++) 
		{
			/* SPR 15674 Start */
			if ((p_confused_cell_selection->reported_neighbor_cell_info[i].phy_cell_id == phy_cell_id)&&
					(p_confused_cell_selection->reported_neighbor_cell_info[i].target_earfcn == earfcn))
				/* SPR 15674 End */
			{
				/* SPR 16406 24Sep Start */
				if (RRM_ONE == p_confused_cell_selection->reported_neighbor_cell_info[i].reported_count)
				{
					/* SPR 16406 24Sep End */
					for (j = i; j <  p_confused_cell_selection->count - RRM_ONE; j++)
					{
						p_confused_cell_selection->reported_neighbor_cell_info[j] = p_confused_cell_selection->reported_neighbor_cell_info[j + RRM_ONE];
					}
					if(RRM_ZERO != p_confused_cell_selection->count)
					{
						p_confused_cell_selection->count--;
					}
					/* SPR 16406 24Sep Start */
					if (RRM_ZERO != p_confused_cell_selection->next_target_cell_idx)
					{
						/* Cell at this index has shifted to previous index because of deletion */
						p_confused_cell_selection->next_target_cell_idx = p_confused_cell_selection->next_target_cell_idx - RRM_ONE;
					}
					/* SPR 16406 24Sep End */
					/* SPR 16406 24Sep Start */
				}
                /* SPR 17660 Fix Start */
                else if (RRM_ONE < p_confused_cell_selection->reported_neighbor_cell_info[i].reported_count)
                {
                    p_confused_cell_selection->reported_neighbor_cell_info[i].reported_count--;
                }
                /* SPR 17660 Fix End */
				/* SPR 16406 24Sep End */
				found = RRM_TRUE;
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"PhyId [%u] found", phy_cell_id);
				break;
			}
		}
	}

	if (RRM_FALSE == found)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"PhyId [%u] not found", phy_cell_id);
		RRM_UT_TRACE_EXIT(); 
		return RRM_SUCCESS;
	}
	RRM_UT_TRACE_EXIT(); 
	return RRM_SUCCESS;
}
/* SPR 16406 End */
/* SPR 15232 end */
/*SPR 17061 start*/
/* SPR 15397 Start */
/****************************************************************************
 * Function Name  : rrm_release_anr_meas_configuration
 * Inputs         : ue context
 * Outputs        : None
 * Returns        : None
 * Description    : This function release the ANR object configuration and Measurement
 *                  Gap configuration for the concerned UE.
 ****************************************************************************/
rrm_void_t
rrm_release_anr_meas_configuration
(
 rrm_ue_context_t *p_ue_context,
 /*SPR 15724:Start*/
 U8 meas_id
 /*SPR 15724:End*/
 )
{
	rrm_bool_et                 should_remove_anr_meas_config = RRM_FALSE;
	rrc_rrm_meas_config_req_t   *p_rrc_rrm_meas_config_req    = RRM_PNULL;
	U16                         trans_id                      = rrm_generate_txn_id();
	/* SPR_15755_Fix: Start */
	meas_report_info_node_t *p_meas_report_info = RRM_PNULL;
	/* SPR_15755_Fix: End */
	/* SPR 16053 start */
	U8                          id                            = RRM_ZERO;
	/* SPR 16053 end */

	RRM_UT_TRACE_ENTER();

	/* SPR: 15922 : Start */ 
	if(RRM_PNULL == p_ue_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"Ue context Pointer is NULL");
		RRM_UT_TRACE_EXIT();
		return;
	}
	/* SPR: 15922 : End */ 
    /* Coverity Fix 86443 Start */ 

	/* SPR 15797 Start */
	rrm_cell_context_t *p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
	if(RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
				"Cell Context Not found");
		RRM_UT_TRACE_EXIT();
		return;
	}
	/* SPR 15797 End */

	/* SPR: 15922 : Start */ 
	/* SPR: 15922 : End */ 

	/// Check whether all ANR measurements reports received. RRM should release the measurement object
	/// configuration and Meas Gap configuration if thats the case.
	///
	/// **Note**:: This code is written by assuming that ANR and HO measurement configuration is disjoint in RRM code which means
	/// that either, ANR meas gap or HO Meas gap configuration is activated
	should_remove_anr_meas_config = rrm_uem_check_req_status_of_anr_meas_objects(p_ue_context);
	/*SPR 15724:Start*/
	if(RRM_TRUE == should_remove_anr_meas_config) 
		/*SPR 15724 :End*/
	{
		/// All ANR pending reports received for the concerned UE
		/// Perform the following actions
		/// - Delete ANR Meas Object configuration
		/// - Release Measurement Gap if configured

		/* SPR_15755_Fix: Start */
		p_meas_report_info = rrm_get_meas_node_for_meas_id(meas_id, p_ue_context); 
		if( RRM_PNULL == p_meas_report_info )
		{
			/* SPR_15755_Fix: End */
			p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*) rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));
			if (RRM_PNULL != p_rrc_rrm_meas_config_req)
			{
				RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL, sizeof(rrc_rrm_meas_config_req_t));

				p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;

				/// This is obvious that Measurement Gap configuration is always present for ANR measurements.
				/// Release Measurement Gap associated with the ANR measurements
				/*SPR 15724:Start*/
				if (RRM_ZERO != p_ue_context->meas_gap_config.meas_gap_config_type)
				{
					p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;
					p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask |= RRM_ZERO;
					p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type = RRM_ZERO;
					/*SPR_17047_START*/
					p_ue_context->meas_gap_sent_status = RRM_UNSET;
					/*SPR_17047_END*/

					/* SPR 16053 start */
					/* Code removed */
					/* SPR 16053 end */
				}
				p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;
				p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count = RRM_ONE;
                                /* SPR 21496 Fix Start */ 
				p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.report_config_id[RRM_ZERO] = 
					p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_id; 
				/* SPR 16053 start */
				for(id = RRM_ZERO; id < RRM_ANR_MAX_MEAS_OBJ; id++)
				{
					if (p_ue_context->p_meas_config[meas_id - RRM_MEAS_OBJ_ID_OFFSET].report_id == p_ue_context->p_meas_config[id].report_id)
					{
						p_ue_context->p_meas_config[id].meas_config_status = RRM_MEAS_CONFIG_TO_DELETE;
					}
				}
                                /* SPR 21496 Fix End */ 
				/* SPR 16053 end */

				/*Code is removed as RRC will remove meas_id on basis of report_config_id remove list*/ 
				/*SPR 15724:End*/
				if (RRM_FAILURE == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
							RRM_MODULE_ID,
							RRC_MODULE_ID,
							/*CA HARDENING CHANGES 6.3.0 ADDING CELL INDEX*/
							trans_id,p_cell_context->cell_index))
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							"Failed to send rrm_rrc_meas_config_req");
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
							RRM_BRIEF,
							"Send rrm_rrc_meas_config_req sucessfully");
					/*SPR 16658 START*/                                
					/* SPR 15797 Start */
                                        /* SPR 21496 Fix Start */ 
					if(p_ue_context->p_meas_config[RRM_ZERO].carr_freq == p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
					{
						p_ue_context->p_meas_config[RRM_ZERO].report_id = RRM_NULL; 
					}
                                        /* SPR 21496 Fix End */ 
					/* SPR 15797 End */
					/*SPR 16658 END*/
					p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING;
				}

				RRM_MEM_FREE (p_rrc_rrm_meas_config_req);
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
						"Memory allocation failed for p_rrc_rrm_meas_config_req UE[%u]",
						p_ue_context->ue_index);
			}

			/* SPR_15755_Fix: Start */
		}
		/* SPR_15755_Fix:  End */
	}
	else
	{
		/// ANR Reports are pending
		/// Nothing To Do
		/* SPR 15843 Start */
		if(RRM_ZERO == p_ue_context->meas_gap_config.meas_gap_config_type)
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
					"Meas Gap is not configured for UE [%u]", p_ue_context->ue_index);
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
					"ANR Reports are pending for UE [%u]", p_ue_context->ue_index);
		}
		/* SPR 15843 End */
	}

	/* SPR: 15922 : Start */ 
    /* Coverity Fix 86443 End */
	/* SPR: 15922 : Start */ 

	RRM_UT_TRACE_EXIT();
}
/* SPR 15397 End */
/*SPR 17061 End*/
/* SPR 16042 start */
	rrm_bool_et
rrm_uem_check_cgi_report_pending_in_proc_queue(rrm_ue_context_t *p_ue_context)
{
	rrm_bool_et                          ret_val                               = RRM_FALSE;
	rrm_ue_procedure_record_t           *p_rrm_ue_procedure_record             = RRM_NULL;
	rrm_ue_meas_config_cgi_queue_node_t *p_rrm_ue_meas_config_cgi_queue_node_t = RRM_NULL;
	rrm_ue_meas_config_t                *p_meas_config_info                    = RRM_NULL;
	U8                                   proc_queue_code_count                 = rrm_get_queue_count(&p_ue_context->procedure_queue);
	YLNODE                              *p_meas_rpt_node                       = RRM_NULL;
	meas_report_info_node_t             *p_meas_report_info                    = RRM_NULL;

	RRM_UT_TRACE_ENTER();

	while(proc_queue_code_count)
	{
		/* SPR 15849 Start */
		p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
		/* SPR 15849 End */

		if(RRM_NULL != p_rrm_ue_procedure_record)
		{

			if(p_rrm_ue_procedure_record->proc_queue.api_id == RRC_RRM_MEAS_CONFIG_REQ)
			{
				p_rrm_ue_meas_config_cgi_queue_node_t = (rrm_ue_meas_config_cgi_queue_node_t*)p_rrm_ue_procedure_record->proc_queue.p_proc_data;
				if(p_rrm_ue_meas_config_cgi_queue_node_t != RRM_NULL)
				{
                                  /* SPR 21496 Fix Start */ 
					p_meas_config_info = rrm_find_obj_in_ue_meas_config(p_rrm_ue_meas_config_cgi_queue_node_t->rat_type,
							p_rrm_ue_meas_config_cgi_queue_node_t->arfcn,
							p_rrm_ue_meas_config_cgi_queue_node_t->band_ind,
							p_rrm_ue_meas_config_cgi_queue_node_t->band_class,
							p_ue_context->p_meas_config);
                                        /* SPR 21496 Fix End */ 
					if(p_meas_config_info != RRM_NULL)
					{
						p_meas_rpt_node = ylFirst(&(p_ue_context->meas_report_list));

						while (p_meas_rpt_node)
						{
							p_meas_report_info = (meas_report_info_node_t*) p_meas_rpt_node;
							if((p_meas_report_info->reporting_event  == MEAS_REP_EVENT_FOR_CGI) &&
									(p_meas_report_info->report_config_id == p_meas_config_info->report_id))
							{
								/// A CGI request is pending in procedure_queue. Can't initiate the deletion of
								/// CGI configuration
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
										"A CGI report is pending with same report_config_id");

								ret_val = RRM_TRUE;
								break;
							}
							else
							{
								RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
										"p_meas_report_info->reporting_event = %u, p_meas_report_info->report_config_id = %u p_meas_config_info->report_id = %u",
										p_meas_report_info->reporting_event,
										p_meas_report_info->report_config_id,
										p_meas_config_info->report_id);
							}

							p_meas_rpt_node= ylNext(p_meas_rpt_node);
						}
					}
					else
					{
						RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
								" p_meas_config_info == RRM_NULL");
					}
				}
				else
				{
					RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
							" p_rrm_ue_meas_config_cgi_queue_node_t == RRM_NULL");
				}
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
						"p_rrm_ue_procedure_record->proc_queue.api_id = %u",p_rrm_ue_procedure_record->proc_queue.api_id);
			}
			/*Coverity 87530 Fix start*/
            /*SPR 18241 START*/
			rrm_ue_mgr_enqueue_req(&p_rrm_ue_procedure_record->proc_queue, p_ue_context,RRM_FALSE);
            /*SPR 18241 END*/

			if(RRM_PNULL != p_rrm_ue_procedure_record->proc_queue.p_proc_data)
			{
				RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
			}

			RRM_MEM_FREE(p_rrm_ue_procedure_record);
		}
		else
		{
			RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
					"p_rrm_ue_procedure_record == NULL ");
		}


		/*Coverity 87530 Fix End*/
		if(RRM_TRUE == ret_val)
		{
			break;
		}
		proc_queue_code_count--;
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* SPR 16042 End */
/* SPR 16373 FIX START */
/****************************************************************************
 * Function Name  : rrm_check_and_dec_num_anr_strong_cell_req_count
 * Inputs         : p_rrm_ue_ctx
 * Outputs        : None
 * Returns        : None
 * Description    : This function decrement the num_anr_strong_cell_req_sent
 *                  for the concerned UE.
 ****************************************************************************/
void
	rrm_check_and_dec_num_anr_strong_cell_req_count
(
 rrm_ue_context_t              *p_ue_context
 )
{
	rrm_counter_t count                = RRM_ZERO;
	rrm_cell_context_t *p_cell_context = rrm_cellm_get_cell_context
		(p_ue_context->cell_index);

	RRM_UT_TRACE_ENTER();

	if(RRM_PNULL == p_cell_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
				"cell context not found");
		RRM_UT_TRACE_EXIT();
		return;
	}

	for( count = RRM_ZERO; count < RRM_ANR_MAX_MEAS_OBJ; count++ )
	{
        /* SPR 17837 FIX START */
          /* SPR 21496 Fix Start */ 
        if((p_ue_context->p_meas_config[count].meas_config_status == RRM_MEAS_CONFIG_TO_DELETE)||
           (p_ue_context->p_meas_config[count].meas_config_status == RRM_MEAS_CONFIG_RESP_SUCCESS)||
           (p_ue_context->p_meas_config[count].meas_config_status == RRM_MEAS_CONFIG_REQ_SENT)||
            (p_ue_context->p_meas_config[count].report_counter > RRM_ZERO))
          /* SPR 21496 Fix End */ 
        /* SPR 17837 FIX END */
        {
			if(p_cell_context->num_anr_strong_cell_req_sent > RRM_ZERO)
			{
				p_cell_context->num_anr_strong_cell_req_sent--;
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"After Decrementing num_anr_strong_cell_req_sent = %d",
						p_cell_context->num_anr_strong_cell_req_sent);
                /* SPR 17837 FIX START */
                break;
                /* SPR 17837 FIX END */
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
						"Failed to Decrease num_anr_strong_cell_req_sent as it is = %d",
						p_cell_context->num_anr_strong_cell_req_sent);
			}

		}
	}
	RRM_UT_TRACE_EXIT();
}
/* SPR 16373 FIX END */


#ifdef LTE_EMBMS_SUPPORTED
/****************************************************************************
 * Function Name  : rrm_uem_handle_mbms_reconfig_resp 
 * Inputs         : p_ue_ctxt
 * Outputs        : None
 * Returns        : None
 * Description    : Handles ue reconfig resp for MBMS
 ****************************************************************************/

rrm_void_t
rrm_uem_handle_mbms_reconfig_resp
(
    rrm_ue_context_t  *p_ue_ctxt
)
{
    RRM_UT_TRACE_ENTER();
    if(p_ue_ctxt->ue_mbms_data.reconfig_bitmask &
           RRM_UE_MBMS_RECONFIG_DRX_ROLLBACK_PRESENT )
    {
        rrm_handle_ue_reconfig_response_for_drx( p_ue_ctxt,
                                                 RRM_ONE);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "DRX configuration is successfully reconfigured for eMBMS "); 
    }
    if((p_ue_ctxt->ue_mbms_data.reconfig_bitmask &
        RRM_UE_MBMS_RECONFIG_REL10_VICTIM_CQI_ROLLBACK_PRESENT) ||
        (p_ue_ctxt->ue_mbms_data.reconfig_bitmask &
         RRM_UE_MBMS_RECONFIG_REL10_NON_VICTIM_CQI_ROLLBACK_PRESENT))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CQI configuration is successfully reconfigured for eMBMS "); 
    }
    if(p_ue_ctxt->ue_mbms_data.reconfig_bitmask &
           RRM_UE_MBMS_RECONFIG_SR_ROLLBACK_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "SR configuration is successfully reconfigured for eMBMS "); 
        rrm_ue_rac_release_sr_res_index(p_ue_ctxt);
        p_ue_ctxt->sr_params.sr_pucch_res_index = p_ue_ctxt->temp_sr_config.sr_pucch_res_index;
        p_ue_ctxt->sr_params.sr_configuration_index = p_ue_ctxt->temp_sr_config.sr_configuration_index;
        p_ue_ctxt->sr_params.sr_res_row = p_ue_ctxt->temp_sr_config.sr_res_row;
        p_ue_ctxt->sr_params.sr_res_col = p_ue_ctxt->temp_sr_config.sr_res_col;

        rrm_cell_mark_sr_index_busy( p_ue_ctxt->cell_index,
                                     p_ue_ctxt->sr_params.sr_res_row,
                                     p_ue_ctxt->sr_params.sr_res_col,
                                     RRM_FALSE
                                    );

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "sr_res_index(%d), sr_config_index(%d), sr_row_num(%d), sr_col_num(%d)",
                p_ue_ctxt->sr_params.sr_pucch_res_index,p_ue_ctxt->temp_sr_config.sr_configuration_index,\
                p_ue_ctxt->temp_sr_config.sr_res_row, p_ue_ctxt->temp_sr_config.sr_res_col);
        RRM_MEMSET(&(p_ue_ctxt->temp_sr_config),RRM_ZERO,sizeof(rrm_ue_temp_sr_config_data_t));
    }
    if(p_ue_ctxt->ue_mbms_data.reconfig_bitmask &
           RRM_UE_MBMS_RECONFIG_DRX_REL_ROLLBACK_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "DRX configuration is successfully removed for eMBMS ");
        p_ue_ctxt->applied_drx_config.curr_applied_drx_config.
            applied_drx_profile_index = NO_DRX_PROFILE;
        p_ue_ctxt->ue_mbms_data.is_drx_disabled = RRM_ONE;

    }
    if(p_ue_ctxt->ue_mbms_data.reconfig_bitmask &
           RRM_UE_MBMS_RECONFIG_CQI_REL_ROLLBACK_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "CQI configuration is successfully removed for eMBMS "); 
        p_ue_ctxt->ue_mbms_data.is_cqi_disabled = RRM_ONE;
    }

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_uem_mbms_reconfig_cqi_drx_off_req 
 * Inputs         : p_ue_ctxt.
 * Outputs        : None
 * Returns        : None
 * Description    : reconfig cqi_drx offset for MBMS 
 ****************************************************************************/

rrm_void_t
rrm_uem_mbms_reconfig_cqi_drx_off_req
(
    rrm_ue_context_t  *p_ue_ctxt
)
{
    rrc_rrm_ue_reconfig_req_t	  rrc_rrm_ue_reconfig_req = {RRM_ZERO};
    rrc_rrm_ue_service_profile_t
        *p_ue_service_profile         = RRM_PNULL;
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_config_ded = RRM_PNULL;
    rrmc_mac_config_t             *p_rrmc_mac_config  = RRM_NULL;
    admission_control_info_t      *p_admission_control_info = RRM_NULL;
    rrc_mac_main_config_ue_service_profile_t    
        *p_ue_profile_mac_main_config = RRM_NULL;
    U8                             dl_bandwidth              = RRM_ZERO;
    U8                             num_of_layer = RRM_ZERO;
    rrc_phy_physical_config_dedicated_ue_service_profile_t
        *p_ue_profile_physical_config_dedicated = RRM_PNULL;
    rrm_return_et                  ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();
    p_admission_control_info = rrm_cellm_get_admission_control_info(
            p_ue_ctxt->cell_index);
    if(RRM_PNULL == p_admission_control_info)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_admission_control_info return NULL");
        RRM_UT_TRACE_EXIT();
        return ;
    }
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(
            p_ue_ctxt->cell_index);
    if(RRM_PNULL == p_rrmc_mac_config)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_rrmc_mac_config return NULL");
        RRM_UT_TRACE_EXIT();
        return ;
    }
    p_ue_service_profile = rrm_cellm_get_ue_service_profile(
            p_ue_ctxt->cell_index);
    if(RRM_PNULL == p_ue_service_profile)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ue_service_profile return NULL");
        RRM_UT_TRACE_EXIT();
        return ;
    }

    p_ue_profile_mac_main_config =  
        &(p_ue_service_profile->radio_res_config.mac_config.mac_main_config);
    if(RRM_PNULL == p_ue_profile_mac_main_config)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ue_profile_mac_main_config return NULL");
        RRM_UT_TRACE_EXIT();
        return ;
    }

    p_ue_profile_physical_config_dedicated = &(p_ue_service_profile->radio_res_config.physical_config_dedicated);
    p_rrc_phy_config_ded = &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated);
    rrc_rrm_ue_reconfig_req.bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.ue_index = p_ue_ctxt->ue_index;

    rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask 
        |= RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;

    /* Turn DRX Off */
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.bitmask 
        |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT; 

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.bitmask 
        |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT; 

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        mac_config.mac_main_config.drx_config.bitmask = RRM_ZERO;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        mac_config.mac_main_config.drx_config.drx_config_type = RRC_DRX_CONFIG_TYPE_REL;
    
    p_ue_ctxt->ue_mbms_data.is_drx_disabled = RRM_ONE;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.ue_priority = MAC_UE_PRIORITY;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.dl_num_harq_process 
        = p_rrmc_mac_config->dl_num_harq_process;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.ul_i_mcs = 
        p_admission_control_info->snr_map.
        snr_dep_params.uplink_snr_dep_params.ul_mcs;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.dl_i_mcs = 
        p_admission_control_info->snr_map.
        snr_dep_params.downlink_snr_dep_params.dl_mcs;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.dl_num_harq_process 
        = p_rrmc_mac_config->dl_num_harq_process ;

    if(p_ue_profile_mac_main_config->ul_sch_config.bitmask &
            RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT)
    {
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
            mac_main_config_extensions.max_ul_harq_tx
            = p_ue_profile_mac_main_config->ul_sch_config.max_ul_harq_tx;
    }

    if(rrm_cellm_get_rrmc_band_width(p_ue_ctxt->cell_index,&dl_bandwidth) == RRM_SUCCESS)
    {
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
            mac_main_config_extensions.dl_max_rb = dl_bandwidth;
    }

    if ( RRM_SUCCESS == rrm_select_num_of_layer_for_ue( p_ue_ctxt,
                &num_of_layer) )
    {
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            mac_config.mac_main_config_extensions.num_of_layer
            = num_of_layer;
    }

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        mac_config.mac_main_config_extensions.
        code_book_index = CODE_BOOK_INDEX;


    /* Turn CQI OFF */
    p_ue_service_profile = rrm_cellm_get_ue_service_profile(
            p_ue_ctxt->cell_index);
    if(RRM_PNULL == p_ue_service_profile)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ue_service_profile return NULL");
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /* Perform CQI reconfiguration for Rel 10 VICTIM UE */
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask 
        |= RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT ;


    p_rrc_phy_config_ded->bitmask = RRM_ZERO; 
    p_rrc_phy_config_ded->bitmask |= RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;
    p_rrc_phy_config_ded->cqi_report_config_r10.bitmask = RRM_ZERO;
    p_rrc_phy_config_ded->cqi_report_config_r10.bitmask |= 
        RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_PERIODIC_R10_PRESENT;
    p_rrc_phy_config_ded->cqi_report_config_r10.nomPDSCH_rs_epre_offset = 
        p_ue_service_profile->radio_res_config.
        physical_config_dedicated.cqi_reporting.
        nom_pdsch_rs_epre_offset ;
    if( RRM_UE_MBMS_RECONFIG_REL10_VICTIM_CQI_ROLLBACK_PRESENT &
            p_ue_ctxt->ue_mbms_data.reconfig_bitmask )
    {
        p_rrc_phy_config_ded->cqi_report_config_r10.bitmask |= 
            RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAME_PATTERN_CONFIG_R10_PRESENT;
        p_rrc_phy_config_ded->cqi_report_config_r10.cqi_report_periodic_r10.
            request_type = RRM_ZERO;
        p_rrc_phy_config_ded->cqi_report_config_r10.csi_subframePattern_r10.
            request_type = RRM_ZERO;
    p_ue_ctxt->ue_mbms_data.is_cqi_disabled = RRM_ONE;
    }
    else if ( RRM_UE_MBMS_RECONFIG_REL10_NON_VICTIM_CQI_ROLLBACK_PRESENT &
            p_ue_ctxt->ue_mbms_data.reconfig_bitmask )
    {
        p_rrc_phy_config_ded->cqi_report_config_r10.cqi_report_periodic_r10.
            request_type = RRM_ZERO;
    p_ue_ctxt->ue_mbms_data.is_cqi_disabled = RRM_ONE;
    }
    else if (RRM_UE_MBMS_RECONFIG_REL9_CQI_ROLLBACK_PRESENT &
            p_ue_ctxt->ue_mbms_data.reconfig_bitmask )
    {
        p_rrc_phy_config_ded->bitmask |=
            RRC_PHY_CQI_REPORTING_PRESENT;
        p_rrc_phy_config_ded->cqi_reporting.bitmask = RRM_ZERO;
        p_rrc_phy_config_ded->cqi_reporting.nom_pdsch_rs_epre_offset =
            p_ue_profile_physical_config_dedicated->cqi_reporting.nom_pdsch_rs_epre_offset;
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE_INDEX[%d], CQI reporting is disabled",
                p_ue_ctxt->ue_index);
        p_ue_ctxt->ue_mbms_data.is_cqi_disabled = RRM_ONE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Nothing to do, As CQI is nor reconfigured ");
    }

    p_ue_ctxt->ue_mbms_data.reconfig_bitmask = RRM_ZERO;
    p_ue_ctxt->ue_mbms_data.reconfig_bitmask |= RRM_UE_MBMS_RECONFIG_CQI_REL_ROLLBACK_PRESENT;
    p_ue_ctxt->ue_mbms_data.reconfig_bitmask |= RRM_UE_MBMS_RECONFIG_DRX_REL_ROLLBACK_PRESENT; 

    /* Send request */
    if(RRM_UE_ERB_NULL == p_ue_ctxt->current_procedure.state)
    {

        ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                RRM_ZERO,
                p_ue_ctxt->cell_index);

        if(RRM_SUCCESS == ret_val)
        {
            p_ue_ctxt->current_procedure.state = RRM_UE_RECONFIG_ONGOING;
            p_ue_ctxt->ue_mbms_data.mbms_reconfig_triggered = RRM_TRUE;
            p_ue_ctxt->ue_mbms_data.mbms_reconfig_count     = RRM_TWO;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Unable to send UE reconfig request to RRC.");
        }
    }
    else
    {
        /*enqueue ue_reconfig*/
        rrm_ue_procedure_queue_t    proc_queue;
        RRM_MEMSET(&proc_queue, RRM_ZERO, sizeof(rrm_ue_procedure_queue_t));
        proc_queue.api_id = RRC_RRM_UE_RECONFIG_REQ;
        proc_queue.p_proc_data =
            (rrc_rrm_ue_reconfig_req_t *)rrm_mem_get
            (sizeof(rrc_rrm_ue_reconfig_req_t));

        if(RRM_PNULL == proc_queue.p_proc_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "rrm_build_and_send_ue_reconfig_req: Mem allocation failed");
            return ;
        }

        RRM_MEMCPY((rrc_rrm_ue_reconfig_req_t*)proc_queue.
                p_proc_data,&rrc_rrm_ue_reconfig_req,
                sizeof(rrc_rrm_ue_reconfig_req_t));
        /**Enqueue ue reconfig request */
        rrm_ue_mgr_enqueue_req( &proc_queue,p_ue_ctxt, RRM_FALSE);

        /* CID 97692:start */
        RRM_MEM_FREE(proc_queue.p_proc_data);
        /* CID 97692:end */
    }

    RRM_UT_TRACE_EXIT();
}
#endif

/*spr 17437 fix start*/
/****************************************************************************
 * Function name  : rrm_fill_rab_removal_info_in_ue_ctxt
 * Inputs         : p_rab_removal_ctxt 
 * Outputs        : p_ue_context
 * Returns        : none
 * Description    : This function fills the rab removal informtion in Uecontext,
 *                  from the local rab removal context 
 ****************************************************************************/
rrm_void_t
rrm_fill_rab_removal_info_in_ue_ctxt
(
  rrm_ue_context_t                *p_ue_context,
  rrm_rab_removal_ctxt_t          *p_rab_removal_ctxt
)
{
    U32 idx                         = RRM_ZERO;
    YLNODE *pNode,*pNode1                   = RRM_PNULL;
    rrm_ue_rab_remove_record_t *p_local_rab_remove_node  = RRM_PNULL;
    rrm_ue_rab_remove_record_t *p_ue_ctxt_rab_rem_node   = RRM_PNULL;
    rrm_rab_remove_node_t         *p_rab_rem_node           = RRM_PNULL;
    rrm_bool_et is_node_to_be_removed               = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "In Rab Removal Ctxt, Count of Rabs to Remove:[%u],"
             "erab_to_be_released_item_list.num_of_list:[%u]",
             ylCount(&p_rab_removal_ctxt->rabs_to_rem_list),
            p_ue_context->erab_to_be_released_item_list.num_of_list);

        /*Collect all the self rabs into the erab_to_be_released_item_list, that are being preempted. */
    while(RRM_PNULL != (pNode = ylPopHead(&p_rab_removal_ctxt->rabs_to_rem_list)))
    {
        p_rab_rem_node = YMEMBEROF(rrm_rab_remove_node_t,pNode,pNode);

        if(RRM_UE_MAX_ERB_COUNT >  p_ue_context->erab_to_be_released_item_list.num_of_list)
        {
               p_ue_context->erab_to_be_released_item_list.erab_to_be_release_item
            [p_ue_context->erab_to_be_released_item_list.num_of_list].erab_id =
                    p_rab_rem_node->erab_id;
               p_ue_context->erab_to_be_released_item_list.erab_to_be_release_item
            [p_ue_context->erab_to_be_released_item_list.
            num_of_list].cause.type = RADIO_NETWORK_LAYER_TYPE;
               p_ue_context->erab_to_be_released_item_list.erab_to_be_release_item
            [p_ue_context->erab_to_be_released_item_list.
            num_of_list].cause.value = RADIO_RESOURCES_NOT_AVAILABLE;
           p_ue_context->erab_to_be_released_item_list.num_of_list++;
        }
        RRM_MEM_FREE(p_rab_rem_node);
        pNode = RRM_PNULL;
    }

    pNode = RRM_PNULL;
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "p_rab_removal_ctxt->rab_rem_container.ue_to_remove_list:[%u],"
             "p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list[%u]",
             ylCount(&p_rab_removal_ctxt->rab_rem_container.ue_to_remove_list),
            ylCount(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list));
        /*Collect all the UEs that are to be released*/
    while(RRM_PNULL != (pNode = ylPopHead(&p_rab_removal_ctxt->rab_rem_container.ue_to_remove_list)))
    {
        ylPushTail(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list,pNode);
        pNode = RRM_PNULL;
    }

    pNode = RRM_PNULL;
        /*Collect all of the RABs of other UEs that are to be removed.
          Eg,Let Rab1 of a UE1 is already being released from prev iteration, there shall be a ue_rab_info for UE1 containg,
           Rab1. If Rab3 and Rab4 of UE1 are selected to be preempted for the current rab admission/modification,
           then Rab3 and Rab4 will be added into the ue_rab_info node.Otherwise insert a new node for UE1for Rab3,Rab4*/
    while(RRM_PNULL != (pNode = ylPopHead(&p_rab_removal_ctxt->rab_rem_container.ue_rab_list)))
    {
        is_node_to_be_removed   = RRM_FALSE;
        pNode1                  = RRM_PNULL;
        p_local_rab_remove_node = RRM_PNULL;

        p_local_rab_remove_node = YMEMBEROF(rrm_ue_rab_remove_record_t,pNode,pNode);

        pNode1 = ylFirst(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list);
        while(RRM_PNULL != pNode1)
        {
            p_ue_ctxt_rab_rem_node = YMEMBEROF(rrm_ue_rab_remove_record_t,pNode,pNode1);
            if(p_local_rab_remove_node->ue_rab_info.ue_idx == p_ue_ctxt_rab_rem_node->ue_rab_info.ue_idx)
            {
               for(idx = RRM_ZERO;idx< p_local_rab_remove_node->ue_rab_info.erabs_to_be_released_count ;idx++)
               {
                if(RRM_MAX_NUM_DRB_PER_UE > p_ue_ctxt_rab_rem_node->ue_rab_info.erabs_to_be_released_count)
                {
                       p_ue_ctxt_rab_rem_node->ue_rab_info.erabs_to_be_released[p_ue_ctxt_rab_rem_node->
                    ue_rab_info.erabs_to_be_released_count] =
                        p_local_rab_remove_node->ue_rab_info.erabs_to_be_released[idx];

                   p_ue_ctxt_rab_rem_node->ue_rab_info.erabs_to_be_released_count++;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to Insert RabId[%u]of UEId[%u] in Rab Removal Container",
                    p_local_rab_remove_node->ue_rab_info.erabs_to_be_released[idx],
                    p_local_rab_remove_node->ue_rab_info.ue_idx);
                }
               }
               is_node_to_be_removed = RRM_TRUE;
               break;
            }
          pNode1 = ylNext(pNode1);
        }

        if(RRM_TRUE == is_node_to_be_removed)
        {
            RRM_MEM_FREE(p_local_rab_remove_node);
        }
        else
        {
            ylPushTail(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list,pNode);
        }
        pNode = RRM_PNULL;
    }
    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : rrm_reset_rab_removal_container
 * Inputs         : None 
 * Outputs        : p_rab_remove_ctnr
 * Returns        : None
 * Description    : This function shall reset the rab removal container 
 ****************************************************************************/
rrm_void_t
rrm_reset_rab_removal_container
(
  rrm_rab_removal_container_t  *p_rab_remove_ctnr
)
{
    rrm_ue_remove_node_t         *p_ue_remove_node  = RRM_PNULL;
    rrm_ue_rab_remove_record_t   *p_other_ue_rabs_node  = RRM_PNULL;
    YLNODE                           *pNode         = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    while(RRM_PNULL != (pNode = ylPopHead(&p_rab_remove_ctnr->ue_to_remove_list)))
    {
            p_ue_remove_node = YMEMBEROF(rrm_ue_remove_node_t,pNode,pNode);
        RRM_MEM_FREE(p_ue_remove_node);
        pNode = RRM_PNULL;
    }

    while(RRM_PNULL != (pNode = ylPopHead(&p_rab_remove_ctnr->ue_rab_list)))
    {
        p_other_ue_rabs_node = YMEMBEROF(rrm_ue_rab_remove_record_t,pNode,pNode);
        RRM_MEM_FREE(p_other_ue_rabs_node);
        pNode = RRM_PNULL;
    }

    RRM_MEMSET(p_rab_remove_ctnr,RRM_ZERO,sizeof(rrm_rab_removal_container_t));
        ylInit(&p_rab_remove_ctnr->ue_to_remove_list);
        ylInit(&p_rab_remove_ctnr->ue_rab_list);
    RRM_UT_TRACE_EXIT();
    return;
}
/****************************************************************************
 * Function Name  : rrm_reset_rab_removal_ctxt
 * Inputs         : None 
 * Outputs        : p_rab_remove_ctxt
 * Returns        : None
 * Description    : This function shall reset the rab removal context 
 ****************************************************************************/
rrm_void_t
    rrm_reset_rab_removal_ctxt
(
 rrm_rab_removal_ctxt_t              *p_rab_remove_ctxt
 )
{
    rrm_rab_remove_node_t        *p_rab_remove_node     = RRM_PNULL;
    YLNODE                           *pNode         = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    while(RRM_PNULL != (pNode = ylPopHead(&p_rab_remove_ctxt->rabs_to_rem_list)))
    {
        p_rab_remove_node = YMEMBEROF(rrm_rab_remove_node_t,pNode,pNode);
        RRM_MEM_FREE(p_rab_remove_node);
        pNode = RRM_PNULL;
    }

    rrm_reset_rab_removal_container(&p_rab_remove_ctxt->rab_rem_container);
    RRM_MEMSET(p_rab_remove_ctxt,RRM_ZERO,sizeof(rrm_rab_removal_ctxt_t));
    RRM_UT_TRACE_EXIT();
    return;
}
/****************************************************************************
 * Function Name  : rrm_process_rab_removal_info_in_ue_ctxt 
 * Inputs         : p_ue_context 
 * Outputs        : 
 * Returns        : None
 * Description    : 
 ****************************************************************************/
rrm_void_t
rrm_process_rab_removal_info_in_ue_ctxt
(
   rrm_ue_context_t                *p_ue_context
)
{
    YLNODE                      *pNode,*pNode1          = RRM_PNULL;
    rrm_ue_rab_remove_record_t       *p_ue_rab_info         = RRM_PNULL;
    rrm_ue_remove_node_t                *p_ue_info          = RRM_PNULL;
    rrm_bool_et                         remove_context      = RRM_FALSE;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t            *p_ue_ctxt           = RRM_PNULL;
    /* SPR 20652 Fix End */
    U32                 match_count,idx,idx1        = RRM_ZERO;
    rrm_ue_erb_t  ue_erb;

    RRM_MEMSET(&ue_erb,RRM_ZERO,sizeof(ue_erb));
    /*Check if UE, for which RABs are to be released, is being released itself or not*/
    pNode = ylFirst(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list);
    while(RRM_PNULL != pNode)
    {
        remove_context = RRM_FALSE;
        pNode1         = RRM_PNULL;
        p_ue_rab_info  = RRM_PNULL;

        p_ue_rab_info = YMEMBEROF(rrm_ue_rab_remove_record_t,pNode,pNode);
        pNode1 = ylFirst(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list);
        while(RRM_PNULL != pNode1)
        {
            p_ue_info  =  YMEMBEROF(rrm_ue_remove_node_t,pNode,pNode1);
            if(p_ue_rab_info->ue_rab_info.ue_idx == p_ue_info->ue_idx)
            {
                remove_context = RRM_TRUE;
                break;
            }
            pNode1 = ylNext(pNode1);
        }
        if(RRM_TRUE == remove_context)
        {
            ylDelete(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list,pNode);
            RRM_MEM_FREE(p_ue_rab_info);
            pNode = RRM_PNULL;
            pNode = ylFirst(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list);
        }
        else
        {
            pNode = ylNext(pNode);
        }
    }
    /*Check if all the RABs of the UE as being selected to be taken down*/
    pNode = RRM_PNULL;
    pNode = ylFirst(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list);
    while(RRM_PNULL != pNode)
    {
        /* Coverity 96508 Fix Start */
        //remove_context = RRM_FALSE;
        /* Coverity 96508 Fix Start */

        /* Coverity 96506 Fix Start */
        //pNode1         = RRM_PNULL;
        /* Coverity 96506 Fix Start */

        p_ue_rab_info  = RRM_PNULL;

        p_ue_rab_info = YMEMBEROF(rrm_ue_rab_remove_record_t,pNode,pNode);
        /* SPR 20652 Fix Start */
        p_ue_ctxt      = rrm_ue_find_context(p_ue_rab_info->ue_rab_info.ue_idx,p_ue_context->cell_index);
        if(RRM_PNULL != p_ue_ctxt)
        {
            match_count = RRM_ZERO;
            for(idx = RRM_ZERO; idx< p_ue_ctxt->drb_configured.num_of_list ;idx++)
            {
                for(idx1 = RRM_ZERO;idx1<p_ue_rab_info->ue_rab_info.erabs_to_be_released_count;idx1++)
                {
                    if(p_ue_rab_info->ue_rab_info.erabs_to_be_released[idx1] ==
                            p_ue_ctxt->drb_configured.erab_item[idx].erab_id)
                    {
                        match_count++;
                        break;
                    }
                }
            }

            if(match_count == p_ue_ctxt->drb_configured.num_of_list)
                /* SPR 20652 Fix End */
            {
                p_ue_info = rrm_mem_get(sizeof(rrm_ue_remove_node_t));

                if(RRM_PNULL != p_ue_info)
                {
                    RRM_MEMSET(p_ue_info,RRM_ZERO,sizeof(rrm_ue_remove_node_t));
                    p_ue_info->ue_idx = p_ue_rab_info->ue_rab_info.ue_idx;
                    ylPushTail(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list,
                            &p_ue_info->pNode);

                    ylDelete(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list,pNode);
                    RRM_MEM_FREE(p_ue_rab_info);
                    pNode = RRM_PNULL;
                    pNode = ylFirst(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list);
                    continue;
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Invalid Case of UEId[%u] not being configured in Context List",
                p_ue_rab_info->ue_rab_info.ue_idx);
        }
        pNode = ylNext(pNode);
    }

    /*Process for the Rabs to be released */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "erab_to_be_released_item_list.num_of_list:[%u]",
             p_ue_context->erab_to_be_released_item_list.num_of_list);
    /* SPR 23129/SES-476 Fix +- */
    
    /*Send ERAB Release Indication*/
    while(RRM_PNULL != (pNode = ylPopHead(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_rab_list)))
    {
        p_ue_rab_info = YMEMBEROF(rrm_ue_rab_remove_record_t,pNode,pNode);
        /* SPR 20652 Fix Start */
        p_ue_ctxt      = rrm_ue_find_context(p_ue_rab_info->ue_rab_info.ue_idx,p_ue_context->cell_index);
        if(RRM_PNULL != p_ue_ctxt)
        {
            if(RRM_SUCCESS  == rrm_build_and_send_erb_release_ind(
                        p_ue_ctxt,
                        p_ue_rab_info->ue_rab_info.ue_idx,
                        p_ue_rab_info->ue_rab_info.erabs_to_be_released,
                        p_ue_rab_info->ue_rab_info.erabs_to_be_released_count,
                        RADIO_NETWORK_LAYER_TYPE,
                        REDUCE_LOAD_IN_SERVING_CELL,
                        RRM_ONE))
            {
                for(idx= RRM_ZERO; idx < p_ue_rab_info->ue_rab_info.erabs_to_be_released_count ;idx++)
                {
                    ue_erb.p_rrm_ue_context = p_ue_ctxt;
                    ue_erb.erab_id = p_ue_rab_info->ue_rab_info.erabs_to_be_released[idx];
                    if(RRM_FAILURE == rrm_ue_delete_erb_entity(&ue_erb))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "UE_INDEX[%d]: Failure received while deletion from erab priority  \
                                list", ue_erb.p_rrm_ue_context->ue_index);
                    }

                    if(p_ue_context->establishment_cause != RRM_UE_ESTAB_CAUSE_EMERGENCY &&
                            p_ue_context->establishment_cause != RRM_UE_ESTAB_CAUSE_HIGHPRIORITY_ACCESS)
                    {

                        if (RRM_FAILURE == rrm_ue_update_ue_priority_list(p_ue_ctxt))
                            /* SPR 20652 Fix End */
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "UE_INDEX[%d]: Failure received while updating the  \
                                    ue_priority", ue_erb.p_rrm_ue_context->ue_index);
                        }
                    }
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Invalid Case of UEId[%u] not being configured in Context List",
                p_ue_rab_info->ue_rab_info.ue_idx);
        }
        RRM_MEM_FREE(p_ue_rab_info);
        pNode = RRM_PNULL;
    }

    /*Send UE Release Ind*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
             "p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list[%u]",
            ylCount(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list));
    while(RRM_PNULL != (pNode = ylPopHead(&p_ue_context->adm_ctrl_rec.rab_removal_container.ue_to_remove_list)))
    {
        p_ue_info  =  YMEMBEROF(rrm_ue_remove_node_t,pNode,pNode);
        /* SPR 20652 Fix Start */
        p_ue_ctxt = rrm_ue_find_context(p_ue_info->ue_idx,
                p_ue_context->cell_index);

        if(RRM_PNULL != p_ue_ctxt) 
        {
            p_ue_ctxt->adm_ctrl_rec.is_ue_already_selected = RRM_FALSE;
            if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                        p_ue_info->ue_idx,
                        RADIO_NETWORK_LAYER_TYPE,
                        REDUCE_LOAD_IN_SERVING_CELL,
                        RRM_ZERO,
                        RRM_PNULL,
                        p_ue_context->cell_index))
            {
                if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_ctxt))
                    /* SPR 20652 Fix End */
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_rrm_uem_facility_name,
                            RRM_ERROR,
                            "ue_connection_release_ind sent, \
                            Failed to clean up ue resources");
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Invalid Case of UEId[%u] not being configured in Context List",
                p_ue_info->ue_idx);
        }
        RRM_MEM_FREE(p_ue_info);
                pNode = RRM_PNULL;
    }
}
/*spr 17437 fix stop*/




/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED

/****************************************************************************
 * Function Name  : rrm_check_is_endc_measurement_assisted 
 * Inputs         : cell_index : cell index to get the configured parameter
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks if ENDC is meas assisted or database assisted
 ****************************************************************************/
rrm_bool_et
rrm_check_is_endc_measurement_assisted
(
  rrm_cell_index_t cell_index
)
{
    rrm_cell_context_t*     p_cell_context  = RRM_PNULL;
    /* coverity_<280094>_fix_start */
    rrm_bool_et           meas_assisted = RRM_FALSE;
    /* coverity_<280094>_fix_end */
    RRM_UT_TRACE_ENTER();

    /* Fetch cell context stored in the UE context */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FALSE;
    }

    if(RRM_TRUE == 
            p_cell_context->operator_info.endc_info.is_ma_sgnb_addition)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Meas Assisted SgNB addition is configured");
       /* coverity_<280100>_fix_start */
       /*coverity_<280380>_fix_start */
        meas_assisted = RRM_TRUE;
       /*coverity_<280380>_fix_end */
        /* coverity_<280100>_fix_end */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Database Assisted SgNB addition is configured");
    }
    RRM_UT_TRACE_EXIT();
    return meas_assisted;
}

/****************************************************************************
 * Function Name  : rrm_check_endc_status_on_ue 
 * Inputs         : p_ue_context : UE context
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks if ENDC is enabled/initiated on UE or not.
 ****************************************************************************/
rrm_bool_et
rrm_check_endc_status_on_ue
(
  rrm_ue_context_t           *p_ue_context
)
{
    rrm_bool_et     endc_enabled = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "UE ENDC status is [%d]",p_ue_context->rrm_endc_nr_data.endc_enable_status);
    if((RRM_ENDC_ENABLE_INITIATED == 
                p_ue_context->rrm_endc_nr_data.endc_enable_status) ||
            (RRM_ENDC_ENABLE_SUCCESSFUL ==
             p_ue_context->rrm_endc_nr_data.endc_enable_status))
    {
        endc_enabled = RRM_TRUE;

    }
    RRM_UT_TRACE_EXIT(); 
    return endc_enabled;
}

/****************************************************************************
 * Function Name  : rrm_check_trigger_to_configure_nr_database 
 * Inputs         : p_ue_context : UE context
 *                  trigger_type : type of trigger to check 
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks if UE is eligible for databse assisted sgnb addition
 ****************************************************************************/
rrm_bool_t
rrm_check_trigger_to_configure_nr_database
(
  rrm_ue_context_t           *p_ue_context,
  rrm_nr_meas_trigger_type_et trigger_type,
  U8 qci
)
{
    rrm_bool_t        configure_nr_db = RRM_FALSE;
    //rrm_ue_proc_erab_setup_data_t   
    //    *p_rrm_ue_proc_erab_setup_data = RRM_PNULL;
    //rrm_ue_erab_setup_item_list_t  
    //    *p_erab_setup_item_list = RRM_PNULL;
    //U16                 succ_erab_idx = RRM_ZERO;
    U8 drb_index               = RRM_ZERO;
    rrm_ue_erab_setup_item_t 
        *p_erab_item = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    if (RRM_TRUE == rrm_check_is_endc_x2ap_link_established())
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "ENDC X2AP Setup is UP");
        if(RRM_FALSE == rrm_check_is_endc_measurement_assisted(p_ue_context->cell_index))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Database Assisted ENDC is configured");
/* NR_BAND_FIX_START */
//            if( RRM_TRUE == rrm_check_is_ue_support_endc(p_ue_context) &&
//                    RRM_TRUE == rrm_check_frequancy_band(p_ue_context))
            if( RRM_TRUE == p_ue_context->rrm_endc_nr_data.mrdc_capability_valid )
/* NR_BAND_FIX_END */
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "UE supports ENDC");
                if(RRM_FALSE == rrm_check_endc_status_on_ue(p_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "ENDC is NOT activated on UE");
                    if(RRM_NR_MEAS_REQ_INITIATED != p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_stats.nr_meas_req_status)
                    {
                        switch ( trigger_type )
                        {
                            case TRIGGER_TYPE_QCI:
                            {
                                // p_rrm_ue_proc_erab_setup_data = (rrm_ue_proc_erab_setup_data_t *)
                                //     (p_ue_context->current_procedure.p_proc_data);

                                // p_erab_setup_item_list = &(p_rrm_ue_proc_erab_setup_data->erab_setup_list);
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                         "For SgNB addition, Check Trigger type - QCI \n");
                                //                                    for(succ_erab_idx = RRM_ZERO;
                                //                                           succ_erab_idx < p_erab_setup_item_list->num_of_list;
                                //                                          succ_erab_idx++)
                                //                                 {
                                    if ( RRM_TRUE ==
                                        //rrm_is_endc_supported_on_qci( p_erab_setup_item_list->erab_item[succ_erab_idx].
                                        //    erab_level_qos_params.qci, p_ue_context->cell_index))
                                    rrm_is_endc_supported_on_qci( qci, p_ue_context->cell_index))
                                    {
                                        configure_nr_db = RRM_TRUE;
                                }
                                //                               }
                                        break;
                            }
                            case TRIGGER_TYPE_ERAB_THROUGHPUT:
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                         "For SgNB addition, Check Trigger type - ERAB_THROUGHPUT \n");
                                for ( drb_index = 0;
                                        (drb_index < p_ue_context->drb_configured.num_of_list);
                                        drb_index++)
                                {
                                    p_erab_item = (rrm_ue_erab_setup_item_t *)
                                        &(p_ue_context->drb_configured.erab_item[drb_index]);

                                    if (PNULL != p_erab_item)
                                    {
                                        /* Check the selection criterias for erab and if either satisfies,
                                           proceed further with this rab */
                                        if (RRM_TRUE == rrm_is_qci_throughput_exceeds_threshold(
                                                    &(p_ue_context->rrm_endc_nr_data.\
                                                        rrm_ue_final_reports.rrm_ue_throughput_reports),p_ue_context->cell_index,
                                                    p_erab_item->erab_level_qos_params.qci,p_erab_item->lc_id))
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                    "[DC Bearer Change] QCI [%d]'s of ERAB id [%d]throughput " \
                                                    "exceeds the defined threshold",
                                                    p_erab_item->erab_level_qos_params.qci,p_erab_item->erab_id);
                                            configure_nr_db = RRM_TRUE;
                                            break;
                                        }
                                    }
                                }
                                break;
                            }
                            case TRIGGER_TYPE_CHANNEL_QUALITY:
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                         "For SgNB addition, Check Trigger type - CHANNEL_QUALITY \n");
                                if(RRM_TRUE ==
                                        rrm_is_ue_channel_quality_is_worse_than_threshold(
                                            &(p_ue_context->rrm_endc_nr_data.\
                                                rrm_ue_final_reports.rrm_ue_channel_quality_reports) ,
                                            p_ue_context->cell_index))
                                {
                                    configure_nr_db = RRM_TRUE;
                                }
                                break;
                            }
                            default:
                            {

                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                        "Invalid Trigger type [%d] is given for SgNB adition.Don't configure \n",trigger_type);
                                break;
                            }

                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Measurements already initiated on UE[%d]\n",p_ue_context->ue_index);
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "ENDC is already activated on UE [%d] \n",p_ue_context->ue_index);

                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "UE[%d] doesn't support ENDC",p_ue_context->ue_index);

            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Measurement Assisted ENDC is configured");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "ENDC X2AP Setup is not established");
    }

    if( RRM_TRUE == configure_nr_db)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Trigger SgNB addition criteria is satisfie for trigger type \n",trigger_type);
    }

    RRM_UT_TRACE_EXIT();

    return configure_nr_db;
}
/****************************************************************************
 * Function Name  : rrm_check_trigger_to_configure_nr_meas 
 * Inputs         : p_ue_context : UE context
 *                  trigger_type : type of trigger to check measurements
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks if UE is eleigible for measurements as per 
 *                  the trigger type.
 ****************************************************************************/
rrm_bool_t
rrm_check_trigger_to_configure_nr_meas
(
  rrm_ue_context_t           *p_ue_context,
  rrm_nr_meas_trigger_type_et trigger_type
)
{
    rrm_bool_t              configure_nr_meas = RRM_FALSE;
    rrm_ue_erab_setup_item_list_t   *p_successful_erbs = RRM_PNULL;
    U16                     succ_erab_idx = RRM_ZERO;
    U8 drb_index               = RRM_ZERO;
    rrm_ue_erab_setup_item_t  *p_erab_item = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    if (RRM_TRUE == rrm_check_is_endc_x2ap_link_established())
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "ENDC X2AP Setup is UP");
        if(RRM_TRUE == rrm_check_is_endc_measurement_assisted(p_ue_context->cell_index))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Mesurement Assisted ENDC is configured");
/* NR_BAND_FIX_START */
//            if( RRM_TRUE == rrm_check_is_ue_support_endc(p_ue_context) &&
//                    RRM_TRUE == rrm_check_frequancy_band(p_ue_context))
            if( RRM_TRUE == p_ue_context->rrm_endc_nr_data.mrdc_capability_valid )
/* NR_BAND_FIX_END */
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "UE supports ENDC");
                if(RRM_FALSE == rrm_check_endc_status_on_ue(p_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "ENDC is NOT activated on UE");
                    if(RRM_NR_MEAS_REQ_INITIATED != p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_stats.nr_meas_req_status)
                    {
                        switch ( trigger_type )
                        {
                            case TRIGGER_TYPE_QCI:
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                                          RRM_BRIEF,\
                                         "For measurements, Check Trigger type - QCI \n");
                                p_successful_erbs = (rrm_ue_erab_setup_item_list_t *)
                                    (p_ue_context->current_procedure.p_erb_success_list);
                                for(succ_erab_idx = RRM_ZERO;
                                        succ_erab_idx < p_successful_erbs->num_of_list;
                                        succ_erab_idx++)
                                {
                                    if ( RRM_TRUE ==
                                            rrm_is_endc_supported_on_qci( 
                                                p_successful_erbs->erab_item[succ_erab_idx].
                                                erab_level_qos_params.qci, 
                                                p_ue_context->cell_index))
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                                                RRM_BRIEF,\
                                                "ENDC is enabled for rab with QCI [%d] \n", 
                                                 p_successful_erbs->\
                                                 erab_item[succ_erab_idx].\
                                                 erab_level_qos_params.qci);
                                        configure_nr_meas = RRM_TRUE;
                                        break;
                                    }
                                }
                                break;
                            }
                            case TRIGGER_TYPE_ERAB_THROUGHPUT:
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                         "For measurements, Check Trigger type - ERAB_THROUGHPUT \n");
                                for ( drb_index = 0;
                                        (drb_index < p_ue_context->drb_configured.num_of_list);
                                        drb_index++)
                                {
                                    p_erab_item = (rrm_ue_erab_setup_item_t *)
                                        &(p_ue_context->drb_configured.erab_item[drb_index]);

                                    if (PNULL != p_erab_item)
                                    {
                                        /* Check the selection criterias for erab and if either satisfies,
                                           proceed further with this rab */
                                        if (RRM_TRUE == rrm_is_qci_throughput_exceeds_threshold(
                                                    &(p_ue_context->rrm_endc_nr_data.\
                                                        rrm_ue_final_reports.rrm_ue_throughput_reports),p_ue_context->cell_index,
                                                    p_erab_item->erab_level_qos_params.qci,p_erab_item->lc_id))
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                    "[DC Bearer Change] QCI [%d]'s of ERAB id [%d]throughput " \
                                                    "exceeds the defined threshold",
                                                    p_erab_item->erab_level_qos_params.qci,p_erab_item->erab_id);
                                            configure_nr_meas = RRM_TRUE;
                                            break;
                                        }
                                    }
                                }
                                break;
                            }
                            case TRIGGER_TYPE_CHANNEL_QUALITY:
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                         "For measurements, Check Trigger type - CHANNEL_QUALITY \n");
                                if(RRM_TRUE ==
                                       rrm_is_ue_channel_quality_is_worse_than_threshold(
                                          &(p_ue_context->rrm_endc_nr_data.\
                                            rrm_ue_final_reports.rrm_ue_channel_quality_reports) ,
                                            p_ue_context->cell_index))
                                {
                                        configure_nr_meas = RRM_TRUE;
                                }

                                break;
                            }
                            default:
                            {

                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                        "Invalid Trigger type [%d] is given for measurements.Don't configure \n",trigger_type);
                                break;
                            }

                        }
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Measurements already initiated on UE[%d]\n",p_ue_context->ue_index);
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "ENDC is already activated on UE [%d] \n",p_ue_context->ue_index);

                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "UE[%d] doesn't support ENDC",p_ue_context->ue_index);

            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "Database Assisted ENDC is configured");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "ENDC X2AP Setup is not established");
    }
    RRM_UT_TRACE_EXIT();
    return configure_nr_meas;
}
/****************************************************************************
 * Function Name  : rrm_get_endc_drb_type_on_qci
 * Inputs         : QCI: qci value whose DRB type is to be checked.
 *                  Cell Index: Cell On which UE is camped.
 * Outputs        : None
 * Returns        : DRB type
 * Description    : Return the drb type for the specififed QCI
 ****************************************************************************/
rrm_drb_type_et
rrm_get_endc_drb_type_on_qci
(
  U8 qci ,
  rrm_cell_index_t cell_index
)
{
    rrm_cell_context_t*     p_cell_context  = RRM_PNULL;
    rrm_drb_type_et         drb_type        = DRB_TYPE_INVALID;
    U8                      qci_count       = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Fetch cell context stored in the UE context */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        /* coverity_<280098>_fix_start */
        return DRB_TYPE_INVALID;
        /* coverity_<280098>_fix_end */
    }

    for(qci_count = RRM_ZERO; qci_count < RRM_MAX_QCI; qci_count++ )
    {
        if( qci == p_cell_context->epc_info.epc_params.
                qos_config_params[qci_count].qci
          )
        {
            drb_type = p_cell_context->epc_info.epc_params. \
                       qos_config_params[qci_count].sgnb_bearer_type;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "qci[%d],drb_type[%d]",p_cell_context->epc_info.epc_params.qos_config_params[qci_count].qci,drb_type);
            break;
        }
    }

  RRM_UT_TRACE_EXIT();
  return drb_type;
}





/****************************************************************************
 * Function Name  : rrm_is_ue_channel_quality_is_worse_than_threshold 
 * Inputs         : p_ue_channel_quality_reports : UE channel quality
                     reports stored in ue context
 *                  Cell Index: Cell On which UE is camped.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks if UE's channel quality is worse than threshold or not
 ****************************************************************************/
rrm_bool_t
rrm_is_ue_channel_quality_is_worse_than_threshold
(
  rrm_ue_channel_quality_reports_t *p_ue_channel_quality_reports,
  rrm_cell_index_t cell_index
)
{
    /* NR_BAND_FIX_START */
    rrm_cell_context_t*     p_cell_context      = RRM_PNULL;
    rrm_bool_t              channel_quality_worse = RRM_FALSE;
    U32                     sinr_dl               = RRM_ZERO;
    U32                     bler_dl               = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /* Fetch cell context stored in the UE context */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FALSE;
    }

    sinr_dl = (p_ue_channel_quality_reports->sinr_dl_cw0 > p_ue_channel_quality_reports->sinr_dl_cw1) ? \
              p_ue_channel_quality_reports->sinr_dl_cw0 : p_ue_channel_quality_reports->sinr_dl_cw1;

    bler_dl = (p_ue_channel_quality_reports->bler_dl_cw0 > p_ue_channel_quality_reports->bler_dl_cw1) ? \
              p_ue_channel_quality_reports->bler_dl_cw0 : p_ue_channel_quality_reports->bler_dl_cw1;

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "UE's sinr_ul[%d] sinr_dl[%d] bler_ul[%d] bler_dl[%d] \n",
             p_ue_channel_quality_reports->sinr_ul,sinr_dl,
             p_ue_channel_quality_reports->bler_ul,bler_dl);

    if ( sinr_dl < p_cell_context->operator_info.endc_info.endc_sinr_thershold_dl)
     {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE's DL sinr [%d] is lesser than threshold[%d] \n",
                p_ue_channel_quality_reports->sinr_dl_cw0,
                p_cell_context->operator_info.endc_info.endc_sinr_thershold_dl);
        channel_quality_worse = RRM_TRUE;
    }
     else if ( p_ue_channel_quality_reports->sinr_ul <
                p_cell_context->operator_info.endc_info.endc_sinr_thershold_ul)
     {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                 "UE's UL sinr [%d] is lesser than threshold[%d] \n",
                  p_ue_channel_quality_reports->sinr_ul,
                  p_cell_context->operator_info.endc_info.endc_sinr_thershold_ul);
         channel_quality_worse = RRM_TRUE;
     }
    //TB_FIX
    else if ( (p_ue_channel_quality_reports->bler_ul != 0xFF ) &&
              (p_ue_channel_quality_reports->bler_ul >
                p_cell_context->operator_info.endc_info.endc_bler_thershold_ul))
     {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                 "UE's UL bler [%d] is greater than threshold[%d] \n",
                  p_ue_channel_quality_reports->bler_ul,
                  p_cell_context->operator_info.endc_info.endc_bler_thershold_ul);
         channel_quality_worse = RRM_TRUE;
     }
    else if ( (bler_dl != 0xFF ) &&
              (bler_dl > p_cell_context->operator_info.endc_info.endc_bler_thershold_dl))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE's DL bler [%d] is greater than [%d] \n",
                p_ue_channel_quality_reports->bler_dl_cw0,
                p_cell_context->operator_info.endc_info.endc_bler_thershold_dl);
        channel_quality_worse = RRM_TRUE;
    }
     else
     {
         RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                 "None of the channel Quality parameters are dgrading"
                "UL bler[%d], DL bler cw0[%d], DL bler cw1[%d],"
                "UL sinr[%d], DL sinr cw0[%d] DL sinr cw1[%d]\n",
                  p_ue_channel_quality_reports->bler_ul,
                p_ue_channel_quality_reports->bler_dl_cw0,
                p_ue_channel_quality_reports->bler_dl_cw1,
                  p_ue_channel_quality_reports->sinr_ul,
                p_ue_channel_quality_reports->sinr_dl_cw0,
                p_ue_channel_quality_reports->sinr_dl_cw1);
     }

    RRM_UT_TRACE_EXIT();
    return channel_quality_worse;
    /* NR_BAND_FIX_END */
}

/****************************************************************************
 * Function Name  : rrm_is_qci_throughput_exceeds_threshold
 * Inputs         : p_ue_throughput_reports : throughput reports stored in
 *                                            ue context
 *                  Cell Index: Cell On which UE is camped.
 *                  qci : QCI of the bearer whose throughput is checked
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks whether bearer throughput of specified QCI exceeds
 *                  the threshold limits or not.
 ****************************************************************************/
rrm_bool_t
rrm_is_qci_throughput_exceeds_threshold
(
  rrm_ue_throughput_reports_t *p_ue_throughput_reports,
  rrm_cell_index_t  cell_index,
  U8                qci ,
  U8                lc_id
)
{
    rrm_cell_context_t*     p_cell_context      = RRM_PNULL;
    rrm_bool_t              thruoghput_exceeded = RRM_FALSE;
    U8                      qci_count           = RRM_ZERO;
    U64                     qci_ul_bitrate      = RRM_ZERO;
    U64                     qci_dl_bitrate      = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Fetch cell context stored in the UE context */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_cell_context is null");
        RRM_UT_TRACE_EXIT();
        return RRM_FALSE;
    }


    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
              "p_ue_throughput_reports->count[%d]\n",
               p_ue_throughput_reports->count);

    for(qci_count = RRM_ZERO; qci_count < p_ue_throughput_reports->count; qci_count++ )
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "qci[%d] lcid[%d] th.QCI[%d] th.LCID [%d]\n",qci,lc_id,p_ue_throughput_reports->rrm_ue_qci_reports[qci_count].qci,
                p_ue_throughput_reports->rrm_ue_qci_reports[qci_count].lc_id);
        if( (qci == p_ue_throughput_reports->rrm_ue_qci_reports[qci_count].qci) &&
            (lc_id == p_ue_throughput_reports->rrm_ue_qci_reports[qci_count].lc_id))
        {
            qci_dl_bitrate = p_ue_throughput_reports->rrm_ue_qci_reports[qci_count].\
                             dl_bitrate;
            qci_ul_bitrate = p_ue_throughput_reports->rrm_ue_qci_reports[qci_count].\
                             ul_bitrate;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "qci_dl_bitrate[%u] qci_ul_bitrate[%u]\n",qci_dl_bitrate,qci_ul_bitrate);
            break;
        }
    }

    if( qci_dl_bitrate > p_cell_context->operator_info.endc_info.bearer_throughput_threshold_dl)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "QCI[%d] DL throughput[%llu] is greater than threshold[%d] \n",
                   qci,qci_dl_bitrate,
                    p_cell_context->operator_info.endc_info.bearer_throughput_threshold_dl);
        thruoghput_exceeded = RRM_TRUE;
    }
    else if ( qci_ul_bitrate > p_cell_context->operator_info.endc_info.bearer_throughput_threshold_ul)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "QCI[%d] UL throughput[%llu] is greater than threshold[%d] \n",
                   qci,qci_ul_bitrate,
                    p_cell_context->operator_info.endc_info.bearer_throughput_threshold_ul);
        thruoghput_exceeded = RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "For QCI[%d] , None of DL throughput[%llu] or UL throughput[%llu]"
                  "exceeds the threshold value",qci,qci_dl_bitrate,qci_ul_bitrate);
    }
    
    RRM_UT_TRACE_EXIT();
    return thruoghput_exceeded;
}

/****************************************************************************
 * Function Name  : rrm_is_endc_supported_on_qci
 * Inputs         : QCI: qci value whose ENDC support is to be checked.
 *                  Cell Index: Cell On which UE is camped.
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Find if operator has enabled ENDC for particular QCI or not.
 ****************************************************************************/
rrm_bool_t
rrm_is_endc_supported_on_qci
(
  U8 qci ,
  rrm_cell_index_t cell_index
)
{
    rrm_cell_context_t*     p_cell_context  = RRM_PNULL;
    rrm_bool_t              endc_supported  = RRM_FALSE;
    U8                      qci_count       = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Fetch cell context stored in the UE context */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "p_cell_context is null");

        RRM_UT_TRACE_EXIT();
        return RRM_FALSE;
    }

    for(qci_count = RRM_ZERO; qci_count < RRM_MAX_QCI; qci_count++ )
    {
        if( (qci == p_cell_context->epc_info.epc_params.
                    qos_config_params[qci_count].qci) &&
                (RRM_TRUE == p_cell_context->epc_info.epc_params.
                 qos_config_params[qci_count].sgnb_bearer_required)
          )
        {
            endc_supported    = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "ENDC is supported by operator for QCI [%d]",qci);
            break;
        }
    }

  if(RRM_FALSE == endc_supported)
  {
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
              "ENDC is NOT supported by operator for QCI [%d]",qci);
  }

  RRM_UT_TRACE_EXIT();
  return endc_supported;
}

/* NR_REP_CONFIG_FIX_START */
rrm_return_et
rrm_check_is_configured_peer_gnb_pci_valid
(
    rrm_cell_index_t  cell_index
)
{
    rrm_cell_context_t           *p_cell_ctxt      = RRM_PNULL;
    rrm_return_et                 ret_val          = RRM_FAILURE;
    rrm_cellm_peer_gnb_pci_list_t *p_configured_neigh_list = RRM_PNULL;
    U8                            pci_count   = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);

    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return ret_val;
    }

    p_configured_neigh_list = 
            &(p_cell_ctxt->operator_info.endc_info.peer_gnb_pci_list);

    for(pci_count = RRM_ZERO ; 
           pci_count < p_configured_neigh_list->count ; pci_count++)
    {
        if( RRM_TRUE == 
                p_configured_neigh_list->peer_gnb_pci[pci_count].is_valid)
        {
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "At least one PCI is valid for candidate cell info list");
            ret_val = RRM_SUCCESS;
            break;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* NR_REP_CONFIG_FIX_END */

rrm_void_t
rrm_build_list_of_selected_erabs
(
    rrm_ue_context_t *p_ue_context,
    endc_eligible_erab_list_t *p_erb_change_list,
    U8               *p_erb_change_list_count
)
{
    U8 drb_index               = RRM_ZERO;
    U8 erb_change_list_count   = RRM_ZERO;
    rrm_ue_erab_setup_item_t 
        *p_erab_item = RRM_NULL;
    rrm_bool_et 
        ue_channel_quality_worse = RRM_FALSE;

    RRM_UT_TRACE_ENTER();


    for ( drb_index = 0;
            (drb_index < p_ue_context->drb_configured.num_of_list);
            drb_index++)
    {
        p_erab_item = (rrm_ue_erab_setup_item_t *)
            &(p_ue_context->drb_configured.erab_item[drb_index]);

        if (PNULL != p_erab_item)
        {

            /* Check the selection criterias for erab and if either satisfies,
               proceed further with this rab */
            if( RRM_FALSE == ue_channel_quality_worse)
            {
                if ( RRM_TRUE == rrm_is_endc_supported_on_qci( p_erab_item->
                            erab_level_qos_params.qci, p_ue_context->cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[DC Bearer Change] QCI [%d] for ERAB_ID[%d] is ENDC capable",
                            p_erab_item->erab_level_qos_params.qci,p_erab_item->erab_id);

                }
                else if (RRM_TRUE == rrm_is_qci_throughput_exceeds_threshold(
                            &(p_ue_context->rrm_endc_nr_data.\
                                rrm_ue_final_reports.rrm_ue_throughput_reports),p_ue_context->cell_index,
                            p_erab_item->erab_level_qos_params.qci,p_erab_item->lc_id))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[DC Bearer Change] QCI [%d]'s of ERAB id [%d]throughput " \
                            "exceeds the defined threshold",
                            p_erab_item->erab_level_qos_params.qci,p_erab_item->erab_id);
                }
                else if (RRM_TRUE == 
                        rrm_is_ue_channel_quality_is_worse_than_threshold(
                            &(p_ue_context->rrm_endc_nr_data.\
                                rrm_ue_final_reports.rrm_ue_channel_quality_reports) ,
                            p_ue_context->cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[DC Bearer Change] UE's [%d] channel quality is " \
                            "worse than the defined threshold",
                            p_ue_context->ue_index);
                    ue_channel_quality_worse = RRM_TRUE;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[DC Bearer Change] QCI [%d] ERAB id [%d] dosnt meet " \
                            "any criteria for movement",
                            p_erab_item->erab_level_qos_params.qci,p_erab_item->erab_id);
                    continue;
                }
            }


            /* Initiate RRM_RRC_DRB_CHANGE_REQ with current erab item */
            if ( RRM_SUCCESS == rrm_ue_get_new_lc_id_for_bearer_change(
                        p_ue_context, p_erab_item) &&
                    (RRM_SUCCESS ==
                     rrm_ue_get_new_drb_id_for_bearer_change(p_ue_context, p_erab_item)))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "[DC Bearer Change] Initiate DC Bearchange for ERAB ID[%d]",
                        p_erab_item->erab_id);

                p_erab_item->bitmask |=
                    RRM_UEM_ERAB_TO_BE_SETUP_DRB_TYPE_PRESENT_FLAG;
                /*update the drb_type*/
                p_erab_item->drb_type = DRB_TYPE_SN_TERMINATED_SPLIT;
        //            rrm_get_endc_drb_type_on_qci( p_erab_item->
          //                  erab_level_qos_params.qci,p_ue_context->cell_index);
                p_erb_change_list[erb_change_list_count].drb_index = drb_index;
                p_erb_change_list[erb_change_list_count].drb_type = p_erab_item->drb_type;
erb_change_list_count++;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "[DC Bearer Change] Unable to allocate new LC ID for ERAB_ID[%d]",
                        p_erab_item->erab_id);
                break;
            }
        }
    }
   *p_erb_change_list_count = erb_change_list_count;
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_get_best_cell_index_frm_nr_result
 * Inputs         : p_meas_nr_res    Meas results of NR neighbor
 *                  max_nr_count     max num of neighbors
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Get the best cell out of all the neigvors in result
 ****************************************************************************/
U8
rrm_get_best_cell_index_frm_nr_result
(
  rrm_nr_meas_results_t *p_meas_nr_res,
  U8 max_nr_count    
)
{
    U8 best_cell_indx = RRM_ZERO;
    U8  nr_count = RRM_ZERO; 
    RRM_UT_TRACE_ENTER();
    
    for(nr_count = RRM_ONE; nr_count < max_nr_count ; ++nr_count)
    {
       rrm_nr_meas_results_t 
                       *current = &p_meas_nr_res[nr_count];
       rrm_nr_meas_results_t 
                       *currentMax = &p_meas_nr_res[best_cell_indx];

        if(current->meas_result_nr_r15.rsrp_result_nr_r15 >
             currentMax->meas_result_nr_r15.rsrp_result_nr_r15)
        {
            best_cell_indx = nr_count;
        }
        else if(currentMax->meas_result_nr_r15.rsrp_result_nr_r15 >
                   current->meas_result_nr_r15.rsrp_result_nr_r15)
        {
            /* no change in best_cell_indx */
        }
        else if(current->meas_result_nr_r15.rsrq_result_nr_r15 >
                   currentMax->meas_result_nr_r15.rsrq_result_nr_r15)
        {
            best_cell_indx = nr_count;
        }
        else if(currentMax->meas_result_nr_r15.rsrq_result_nr_r15 > 
                    current->meas_result_nr_r15.rsrq_result_nr_r15)
        {
            /* no change in best_cell_indx */
        }
        else if(current->meas_result_nr_r15.rs_sinr_result_r15 > 
                      currentMax->meas_result_nr_r15.rs_sinr_result_r15)
        {
            best_cell_indx = nr_count;
        }
        else if(currentMax->meas_result_nr_r15.rs_sinr_result_r15 >
                  current->meas_result_nr_r15.rs_sinr_result_r15)
        {
            /* no change in best_cell_indx */
        }
        else
        {
            /* no change in best_cell_indx */
        }
    }
    RRM_UT_TRACE_EXIT();
    return best_cell_indx;
} 
/* NR_BAND_FIX_START */
/****************************************************************************
 * Function Name  : rrm_nr_report_quantity_rsrp
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE
 * Description    : Checks if RSRP is part of configured report quantity
 ****************************************************************************/
rrm_bool_et
rrm_nr_report_quantity_rsrp
(
    rrm_cell_index_t  cell_index
)
{
    rrm_irat_params_t       *p_rrm_irat_params   = RRM_PNULL;
    rrm_cell_context_t        *p_cell_ctxt   = RRM_PNULL;
    rrm_bool_et              ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return ret_val;
    }
    /* Fetch pointer to irat param from the ran_info stored in cell context */
    p_rrm_irat_params = &(p_cell_ctxt->ran_info.connected_mode_mobility_params.irat);

    switch(p_rrm_irat_params->report_quantity_nr)
    {
        case (U8)RRM_RRC_NR_RSRP:
        case (U8)RRM_RRC_NR_RSRP_RSRQ:
        case (U8)RRM_RRC_NR_RSRP_SINR:
        case (U8)RRM_RRC_NR_ALL:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Report Quantity configured [%d] is with RSRP \n",
                    p_rrm_irat_params->report_quantity_nr);
            ret_val = RRM_TRUE;
            break;
        }
        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Report Quantity configured [%d] is without RSRP \n",
                    p_rrm_irat_params->report_quantity_nr);
            ret_val = RRM_FALSE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_nr_report_quantity_sinr
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE
 * Description    : Checks if SINR is part of configured report quantity
 ****************************************************************************/
rrm_bool_et
rrm_nr_report_quantity_sinr
(
    rrm_cell_index_t  cell_index
)
{
    rrm_irat_params_t       *p_rrm_irat_params   = RRM_PNULL;
    rrm_cell_context_t        *p_cell_ctxt   = RRM_PNULL;
    rrm_bool_et              ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    /* Fetch pointer to irat param from the ran_info stored in cell context */
    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return ret_val;
    }
    p_rrm_irat_params = &(p_cell_ctxt->ran_info.connected_mode_mobility_params.irat);

    switch(p_rrm_irat_params->report_quantity_nr)
    {
        case (U8)RRM_RRC_NR_SINR:
        case (U8)RRM_RRC_NR_RSRP_SINR:
        case (U8)RRM_RRC_NR_RSRQ_SINR:
        case (U8)RRM_RRC_NR_ALL:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Report Quantity configured [%d] is with SINR \n",
                    p_rrm_irat_params->report_quantity_nr);
            ret_val = RRM_TRUE;
            break;
        }
        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Report Quantity configured [%d] is without SINR \n",
                    p_rrm_irat_params->report_quantity_nr);
            ret_val = RRM_FALSE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
 
/****************************************************************************
 * Function Name  : rrm_nr_report_quantity_rsrq
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE
 * Description    : Checks if RSRQ is part of configured report quantity
 ****************************************************************************/
rrm_bool_et
rrm_nr_report_quantity_rsrq
(
    rrm_cell_index_t  cell_index
)
{
    rrm_irat_params_t       *p_rrm_irat_params   = RRM_PNULL;
    rrm_cell_context_t        *p_cell_ctxt   = RRM_PNULL;
    rrm_bool_et              ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    /* Fetch pointer to irat param from the ran_info stored in cell context */
    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return ret_val;
    }
    p_rrm_irat_params = &(p_cell_ctxt->ran_info.connected_mode_mobility_params.irat);

    switch(p_rrm_irat_params->report_quantity_nr)
    {
        case (U8)RRM_RRC_NR_RSRQ:
        case (U8)RRM_RRC_NR_RSRP_RSRQ:
        case (U8)RRM_RRC_NR_RSRQ_SINR:
        case (U8)RRM_RRC_NR_ALL:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Report Quantity configured [%d] is with RSRQ \n",
                    p_rrm_irat_params->report_quantity_nr);
            ret_val = RRM_TRUE;
            break;
        }
        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Report Quantity configured [%d] is without RSRQ \n",
                    p_rrm_irat_params->report_quantity_nr);
            ret_val = RRM_FALSE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_bool_et
rrm_check_meas_id_configured_for_sgnb
(
  U8   meas_id,
  rrm_x2_gb_gnb_id_t *p_global_gnb_id,
  rrm_ue_context_t* p_ue_context 
)
{
   rrm_endc_nr_meas_data_t           *p_endc_meas_data = RRM_PNULL;
   rrm_endc_nr_sgnb_meas_info_t *p_endc_meas_cell_data = RRM_PNULL;
   rrm_endc_nr_sgnb_meas_data_t *p_endc_meas_sgnb_data = RRM_PNULL;
   rrm_bool_et                    ret_val = RRM_FALSE;
   U8                             sgnb_count = RRM_ZERO;
   U8                             meas_count = RRM_ZERO;
   RRM_UT_TRACE_ENTER();

   p_endc_meas_data = &(p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_data[RRM_ZERO]);

   for( sgnb_count = RRM_ZERO; sgnb_count < p_endc_meas_data->sgnb_count; sgnb_count++)
   {
       p_endc_meas_sgnb_data = &(p_endc_meas_data->rrm_endc_nr_sgnb_meas_data[sgnb_count]);
       if(RRM_ZERO == 
               RRM_MEMCMP(&(p_endc_meas_sgnb_data->global_gnb_id),p_global_gnb_id,sizeof(rrm_x2_gb_gnb_id_t)))
       {
           RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "SGNB matched with UE context \n");
           for(meas_count = RRM_ZERO ; meas_count < p_endc_meas_sgnb_data->meas_count ; meas_count++)
           {
               p_endc_meas_cell_data = &(p_endc_meas_sgnb_data->rrm_endc_nr_sgnb_meas_info[meas_count]);
               if( meas_id == p_endc_meas_cell_data->meas_id )
               {
                   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                           "Meas Id matched with Cell \n");
                   ret_val = RRM_TRUE;
                   break;
               }
           }
       }
   }

   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/* NR_BAND_FIX_END */
/****************************************************************************
 * Function Name  : rrm_ue_handle_meas_event_b1_nr
 * Inputs         : p_ue_context     UE Context
 *                  meas_id          Measurement Id reported in meas result 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the measurement report received for event B1 NR.
 ****************************************************************************/
rrm_return_et 
rrm_ue_handle_meas_event_b1_nr
(
    rrm_ue_context_t* p_ue_context, 
    rrm_meas_result_nr_neighbour_list_r15_t *p_meas_result_nr,
    U8  meas_id
)
{
    rrm_cell_context_t*     p_cell_context   = RRM_PNULL;
    phy_scell_id_nr_r15_t   best_cell_pci    = RRM_ZERO;
    phy_scell_id_nr_r15_t   cell_pci    = RRM_ZERO;
    YLNODE                 *p_node           = RRM_PNULL;
    rrm_x2ap_enb_node_t    *p_x2ap_enb_node  = RRM_PNULL;
    rrm_x2_gb_gnb_id_t      selected_gnb_id ; 
    endc_eligible_erab_list_t erb_change_list[RRM_MAX_NUM_DRB_PER_UE] ;
    U8                      erb_change_list_count = RRM_ZERO;
    U8                      drb_index = RRM_ZERO;
    U8                      cell_count = RRM_ZERO;
    U8                      meas_count = RRM_ZERO;
    U8                      nr_count = RRM_ZERO;
    rrm_bool_et             selected_gnb_found = RRM_FALSE;
    rrm_bool_et             pci_found = RRM_FALSE;
    U8                      best_cell_indx = RRM_ZERO;
    rrm_nr_meas_results_list_t rrm_nr_meas_results_list;
                    rrm_nr_cell_info_t *p_nr_cell_info = RRM_PNULL;
    rrm_x2ap_srvd_nr_cell_info_t *p_nr_srvd_cell_info = RRM_PNULL;
    meas_result_nr_r15_t               *p_nr_meas_res = RRM_PNULL;
    rrm_nr_meas_results_t *p_rrm_nr_meas = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(&rrm_nr_meas_results_list, RRM_ZERO, sizeof(rrm_nr_meas_results_list_t));

    RRM_MEMSET(erb_change_list,RRM_NULL,sizeof(endc_eligible_erab_list_t)*RRM_MAX_NUM_DRB_PER_UE);
    RRM_MEMSET(&(selected_gnb_id),RRM_ZERO,sizeof(rrm_x2_gb_gnb_id_t));
    /* Fetch cell context stored in the UE context */

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_cell_context is null");

        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /* Prepare a list of valid cells i.e. the cells that are present in x2 link up ind */
    if( RRM_TRUE == rrm_check_is_endc_x2ap_link_established())
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "X2 link is up");
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Meas results NR count [%d]",p_meas_result_nr->count);
        for(nr_count = RRM_ZERO ; (nr_count < p_meas_result_nr->count)
                                  && (nr_count < RRM_MAX_CELLS_REPORTED); nr_count++)
        {
            p_nr_meas_res = 
                &(p_meas_result_nr->meas_result_neighbour_nr_cell_r15[nr_count].\
                        meas_result_nr_r15);
            cell_pci = p_meas_result_nr->meas_result_neighbour_nr_cell_r15[nr_count].pci_r15;
            p_node = ylFirst(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));
            pci_found = RRM_FALSE;
            while(p_node && (RRM_FALSE == pci_found ))
            {
                p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;

                if(p_x2ap_enb_node->link_up_data.bitmask &
                        RRM_NR_CELL_INFO_PRESENT)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Meas results : RRM_NR_CELL_INFO_PRESENT \n");
                    p_nr_cell_info = &(p_x2ap_enb_node->link_up_data.nr_cell_info);
                    /* check meas id is present in ue context SgNB */
                    if( RRM_FALSE == rrm_check_meas_id_configured_for_sgnb(meas_id,&(p_nr_cell_info->global_gnb_id),p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Meas ID [%d] not matche for SgNB [%d][%d][%d][%d]. Move to next \n",
                                meas_id,p_nr_cell_info->global_gnb_id.gNB_id[0],
                                p_nr_cell_info->global_gnb_id.gNB_id[1],
                                p_nr_cell_info->global_gnb_id.gNB_id[2],
                                p_nr_cell_info->global_gnb_id.gNB_id[3])
                        p_node = ylNext(p_node);
                        continue;
                    }
                    RRM_MEMCPY(&selected_gnb_id,&(p_nr_cell_info->global_gnb_id),sizeof(rrm_x2_gb_gnb_id_t));
                    for( cell_count = RRM_ZERO; cell_count < p_nr_cell_info->num_served_nr_cell;
                            cell_count++ )
                    {
                        p_nr_srvd_cell_info = 
                            &(p_nr_cell_info->cell_info[cell_count].served_cell_info);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Meas results: Resulted cell_pci [%d] NR pci [%d]\n",
                                cell_pci,p_nr_srvd_cell_info->nr_pci);
                        if( cell_pci == p_nr_srvd_cell_info->nr_pci )
                        {
                            p_rrm_nr_meas = 
                                &(rrm_nr_meas_results_list.\
                                        rrm_nr_meas_results[meas_count]);

                            RRM_MEMCPY(&(p_rrm_nr_meas->selected_gnb_id),&(p_nr_cell_info->global_gnb_id),sizeof(rrm_x2_gb_gnb_id_t));
                            RRM_MEMCPY(&(p_rrm_nr_meas->pci_r15),&(p_nr_srvd_cell_info->nr_pci), sizeof(phy_scell_id_nr_r15_t));
                            /* NR_BAND_FIX_START */
                            if((p_nr_meas_res->bitmask  & MEAS_RESULT_NR_RSRP_PRESENT) &&
                                    (RRM_TRUE == rrm_nr_report_quantity_rsrp(p_ue_context->cell_index)))
                            {
                                p_rrm_nr_meas->meas_result_nr_r15.bitmask |= MEAS_RESULT_NR_RSRP_PRESENT;
                                p_rrm_nr_meas->meas_result_nr_r15.rsrp_result_nr_r15 = p_nr_meas_res->rsrp_result_nr_r15;
                            }
                            if((p_nr_meas_res->bitmask  & MEAS_RESULT_NR_RSRQ_PRESENT) &&
                                    (RRM_TRUE == rrm_nr_report_quantity_rsrq(p_ue_context->cell_index)))
                            {
                                p_rrm_nr_meas->meas_result_nr_r15.bitmask |= MEAS_RESULT_NR_RSRQ_PRESENT;
                                p_rrm_nr_meas->meas_result_nr_r15.rsrq_result_nr_r15 = p_nr_meas_res->rsrq_result_nr_r15;
                            }
                            if((p_nr_meas_res->bitmask  & MEAS_RESULT_NR_RS_SINR_PRESENT)  &&
                                    (RRM_TRUE == rrm_nr_report_quantity_sinr(p_ue_context->cell_index)))
                            {
                                p_rrm_nr_meas->meas_result_nr_r15.bitmask |= MEAS_RESULT_NR_RSRQ_PRESENT;
                                p_rrm_nr_meas->meas_result_nr_r15.rs_sinr_result_r15 = p_nr_meas_res->rs_sinr_result_r15;
                            }
                            /* NR_BAND_FIX_END */
                            meas_count++;
                            pci_found = RRM_TRUE;
                            break;
                        }
                    }
                }
                p_node = ylNext(p_node);
            }
        }

        rrm_nr_meas_results_list.count = meas_count;

        if(rrm_nr_meas_results_list.count > RRM_ZERO)
        {
            best_cell_indx  = 
                rrm_get_best_cell_index_frm_nr_result(
                        rrm_nr_meas_results_list.rrm_nr_meas_results,
                        rrm_nr_meas_results_list.count);

            best_cell_pci = rrm_nr_meas_results_list.rrm_nr_meas_results[best_cell_indx]. \
                            pci_r15;                         
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas results : best_cell_indx [%d] best_cell_pci [%d]",best_cell_indx,best_cell_pci);

            RRM_MEMCPY(&selected_gnb_id,&(rrm_nr_meas_results_list.rrm_nr_meas_results[best_cell_indx].selected_gnb_id),sizeof(rrm_x2_gb_gnb_id_t));
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas results: selected_gnb [%d][%d][%d][%d]",selected_gnb_id.gNB_id[0],
                    selected_gnb_id.gNB_id[1],
                    selected_gnb_id.gNB_id[2],
                    selected_gnb_id.gNB_id[3]);
            selected_gnb_found = RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "None of the cells coming Meas results matched with selected_gnb [%d][%d][%d][%d] \n"
                    "Discard the results!!!\n",
                     selected_gnb_id.gNB_id[0],
                    selected_gnb_id.gNB_id[1],
                    selected_gnb_id.gNB_id[2],
                    selected_gnb_id.gNB_id[3]);

        }
        if( RRM_TRUE == selected_gnb_found)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas results: selected_gnb_found is true \n");
            rrm_build_list_of_selected_erabs(p_ue_context,erb_change_list,&erb_change_list_count);
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas results: erb_change_list_count [%d]\n",erb_change_list_count);
            if (erb_change_list_count > RRM_ZERO ) 
            {
                if(RRM_FAILURE == 
                        rrm_build_and_send_dc_bearer_change_req(p_ue_context,\
                            erb_change_list,erb_change_list_count,\
                            p_meas_result_nr,&selected_gnb_id))
                {
                    for(drb_index=0;drb_index<erb_change_list_count;drb_index++)
                    {
                        p_ue_context->drb_configured.\
                            erab_item[erb_change_list[drb_index].drb_index].\
                            new_lc_id = RRM_ZERO;
                        p_ue_context->drb_configured.\
                            erab_item[erb_change_list[drb_index].drb_index].\
                            new_drb_id = RRM_ZERO;
                    }
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "X2 link is not up");

    }

    p_ue_context->rrm_endc_nr_data.\
        rrm_endc_nr_meas_stats.nr_meas_req_counter++;
    p_ue_context->rrm_endc_nr_data.\
        rrm_endc_nr_meas_stats.nr_meas_req_status = RRM_NR_MEAS_REQ_COMPLETED; 

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrm_ue_handle_meas_results_ind_for_nr
 * Inputs         : rrm_ue_global_context_t* p_g_rrm_ue_ctx RRM Global Context.
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the NR specific measurement report received from RRC.
 ****************************************************************************/
rrm_return_et
rrm_ue_handle_meas_results_ind_for_nr
(
    rrm_ue_global_context_t* p_g_rrm_ue_ctx
)
{
    rrm_ue_measurment_results_ind_t*  p_meas_results      = RRM_NULL;
    rrm_ue_context_t*                 p_ue_context        = RRM_PNULL;
    rrmc_meas_report_event_et         meas_rep_event      = MEAS_REP_EVENT_NONE;
    rrm_return_et                     ret_val             = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

	p_ue_context = p_g_rrm_ue_ctx->p_ue_context;
    p_meas_results = (rrm_ue_measurment_results_ind_t *)
                              p_ue_context->current_procedure.p_proc_data;

    /* If UE is undergoing handover, no need to process ENDC measurement results */
    if(RRM_UE_STATE_HO_ONGOING == p_ue_context->ue_state)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                  "HO is ongoing for UE[%d], droping measurement indication", 
                  p_ue_context->ue_index);

        return RRM_FAILURE;
    }

    /* Fetch meas event for which measurement report is received */
    meas_rep_event = rrm_ue_get_configured_meas_event(p_meas_results->meas_id,
                                                      p_ue_context);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Here case is MEAS_TYPE_EUTRA_NR hit meas_rep_event[%d]\n",meas_rep_event);

    switch(meas_rep_event)
    {
        case MEAS_REP_EVENT_B1_NR:
        {
            if ( RRM_NR_MEAS_REQ_INITIATED == p_ue_context->rrm_endc_nr_data.
                rrm_endc_nr_meas_stats.nr_meas_req_status )
            {
                ret_val = rrm_ue_handle_meas_event_b1_nr(p_ue_context, 
                        &(p_meas_results-> \
                            rrm_meas_result_nr_neighbour_list_r15),p_meas_results->meas_id);
            }
            break;
        }

        case MEAS_REP_EVENT_B2_NR:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_ue_facility_name, RRM_WARNING,
                      "MEAS_REP_EVENT_B2_NR is not supported in this release \n"); 
            break;
        }

        default:
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_ue_facility_name, RRM_WARNING,
                      "Meas result received for invalid NR event: %d", 
                      meas_rep_event);
            break;
        }
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
#endif
/* ENDC_MEAS_CHANGES_END */
