/* vim: ts=4:et:ai:ci:sw=4
*/
/******************************************************************************
  *
  * ARICENT -
  *
  * Copyright (C) 2012 Aricent Inc . All Rights Reserved.
  *
  ******************************************************************************
  *
  * $$Id: rrm_cell_fsm.c $
  *
  *******************************************************************************
  *
  * File Description: This file contains contains the finite machine automata 
  *      implementation for Cell RRM
  *
  *
  *******************************************************************************
  *Revision Details
  *----------------------
  *   DATE            AUTHOR      REFERENCE       REASON
  *   Feb 2012                    Initial
  *   27 Nov 2012     gur21481                    BUG:178
  *   29 Jan 2013     gur27278                    Added code for SPS feature
  *   15 Jul 2013     gur11056                    SPR 490: Min Bit Rate per QCI
  *   29 Apr 2014     gur35095      SPR 10779     RRM not doing handover on Intra freq on Inter cell
  *   02 May 2014     gur25767      SPR 10538     Queueing implemented for Meas Config CGI
  *   27 May 2014     gur29831      SPR 11293     NRT FIX
  *   28 May 2014     gur27356      SPR 11383     Cell Unavailability KPI compliance.
  *   28 May 2014     gur26515      SPR-10749     Updated for Fromat2/2a/2b Multiplexing.
  *   03 June 2014    gur13083      SPR 11492     Null check is missing before
  *                                               memory release
  *   06 June 2014    gur29990      SPR 11317     OLPC Redesigned 
  *   06 June 2014    gur26515      SPR 10730     Added code changes for SPR 10730
  *   10 June 2014    gur29831      SPR 11728     Added code changes for SPR 11728 
  *   12 June 2014    gur21481      SPR 11797     check for null pointer is added
  *   13 June 2014    gur27356      SPR 10489     Support additional causes in RWR.
  *   25 June 2014    gur29831      SPR 12100     Added code changes for SPR 12100  
  *   28 June 2014    gur21481      SPR 12251     added code for deletion because of reconfig
  *   18 Jun 2014     gur25767    SPR 11861       SIB 4 multiple PCI broadcast issue fix
  *   20 June 2014   gur34951      SPR 10329      Enhancement of GU GROUP ID
  *   26 Jun,2014     gur29990    11848           Cell Stop Handling done.
  *   30 Jun,2014     gur30784    12233           Fix for enqueing the reconfig API
  *   1st July 2014   gur21481    SPR 12315       nrt_reconfig param was freed.
  *   02 July,2014   gur25767     SPR 10498       Inter-freq Daho Support
  *   08 July,2014   gur29831     SPR 12440       CA to Non-Ca issue 
  *   08 July,2014    gur35095    SPR 12416       Broadcast cell delete req to all eNb cells
  *                                               because of reconfiguration
  *   02 JuL,2014     gur265150    10450           Implemented DRX Staggering.
  *   02 July,2014  gur25767       SPR 10498       Inter-freq Daho Support
  *   14 Jul,2014     gur27356    SPR-12550       Delete the timer id "x2ap_icic_info_rpt_tmr.
  *   15 Jul,2014     gur27356    SPR-12599       RRM not triggering DAHO HO towards GERAN cell.
  *   24 Jul,2014     gur32417    SPR 12689       PCI conflict with serving issue changes 
  *   06 Aug,2014     gur13083    SPR 13014       RRM was releasing memory of
  *                                               another procedure in case message is queued up
  *   20 Aug,2014     gur27356    SPR 13182       RRM is sending rrc_rrm_cell_reconfigure_req to RRC,
  *                                               in case of PCI confusion.
  *   27 Aug,2014     gur13083    SPR 13377       RRM is sending cell delete
  *                                               indication to SON in case of reconfiguration also
  ******************************************************************************/

/****************************************************************************
 * Includes
 ****************************************************************************/
#include "rrm_stats.h"
#include "rrm_cell_fsm.h"
#include "rrm_cell_context.h"
#include "rrm_cell_mgr.h"
#include "rrm_cell_rrmim_intf.h"
#include "rrm_types.h"
#include "rrm_utils.h"
#include "l3_api_composer.h"
#include "l3_api_compose_parse_utils.h"
#include "rrm_rrc_cell_intf.h"
#include "rrm_ue_context.h"
#include "rrm_ue_mgr.h"
#include "rrm_api_types.h"
#include "rrm_oam_composer.h"
#include "rrm_son_composer.h"
#include "rrm_events.h"
#include "rrm_cell_rrmim_intf.h"


#ifdef LTE_EMBMS_SUPPORTED
#include "rrm_rrc_cell_embms.h"
#include "rrm_cell_embms.h"

/****************************************************************************
 * Exported Variables/Functions
 ****************************************************************************/

 extern
rrm_void_t
rrm_cal_inter_intra_neigh_config
(
 rrm_cell_embms_data_t       *p_embms_data,
 rrm_embms_mcch_mtch_list    *p_mcch_mtch_list,
 idle_mode_mobility_params_t *p_idle_mobility_params,
 lte_ncl_t                   *p_ncl_params
 );

extern
rrm_return_et
rrm_detect_mbms_collision_with_si
(
 rrm_cell_context_t                  *p_cell_ctx,
 rrm_embms_sf_info_t                  embms_rf_sf_list[],
 U8                                  *p_si_offset
 );



#endif


#define RRM_CELL_M_FSM_NAME " RRM Cell Manager FSM"


#define CELL_M_FSM_GET_CURRENT_STATE(p_cell_ctx) \
        (p_cell_ctx->cell_state)

#define CELL_STATE_CHNAGE_IND(p_cell_ctx,new_state)\
        if((new_state == CELL_STATE_ACTIVE)||(new_state == CELL_STATE_INACTIVE)||\
           (new_state == CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP)||\
           (new_state == CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_STOP_RESP)||\
           (new_state == CELL_STATE_DELETE_IN_PROGRESS))\
          { cell_state_change_ind(p_cell_ctx,new_state);}\

    
/* Variable storing the CellM name for logging */
S8 *p_g_rrm_cellm_facility_name = (S8 *)"RRM_CELLM";
/* Global variable storing the status (Enabled/Disabled) of UEM logging */
/* SPR 21412 Cell Reconfig Fix Start */
/* SPR 21412 Cell Reconfig Fix End */
rrm_bool_et g_cellm_log_on_off = RRM_TRUE;
const S8 * CELL_FSM_STATE[]=
{

   (const S8 *)"CELL_STATE_IDLE",                                 /*!< CELL_EVENTS event 0 */
   (const S8 *)"CELL_STATE_W_FOR_CONFIG_RESP",                    /*!< CELL_EVENTS event 1 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_START",                     /*!< CELL_EVENTS event 2 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_START_RESP",                /*!< CELL_EVENTS event 3 */
   (const S8 *)"CELL_STATE_ACTIVE",                               /*!< CELL_EVENTS event 4 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP",/*!< CELL_EVENTS event 5 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_RESP",             /*!< CELL_EVENTS event 6 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_RECONFIG_RESP",    /*!< CELL_EVENTS event 7 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_START_RESP",      /*!< CELL_EVENTS event 8 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_DEL",                               /*!< CELL_EVENTS event 9 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_STOP_RESP",                        /*!< CELL_EVENTS event 11 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_STOP_RESP",      /*!< CELL_EVENTS event 12 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_UPDATE_RESP",    /*!< CELL_EVENTS event 13 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_START_RESP",     /*!< CELL_EVENTS event 14 */
   (const S8 *)"CELL_STATE_OUT_OF_SERVICE",                              /*!< CELL_EVENTS event 15 */
   (const S8 *)"CELL_STATE_DELETE_IN_PROGRESS",                           /*!< CELL_EVENTS event 16 */
   (const S8 *)"CELL_STATE_UEM_DEL",                                      /*!< CELL_EVENTS event 17 */
   (const S8 *)"CELL_STATE_INACTIVE",                                     /*!< CELL_EVENTS event 18 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_DEL_RECONFIG_FAILED",              /*!< CELL_EVENTS event 19 */
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_NRT",            /*!< CELL_EVENTS event 20 */
   (const S8 *)"CELL_STATE_PWS_ONGOING",                                 /*!< CELL_EVENTS event 21 *//*ETWS CMAS FEAT*/
   (const S8 *)"CELL_STATE_MLB_W_FOR_CELL_RECONFIG_RESP",                 /*!< Wait For Cell reconfig resp for MLB */ 
   /* DYNAMIC ICIC CHANGES START */
   (const S8 *)"CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2",           /*!< Wait For resp from UEM/L2 */ 
   /* DYNAMIC ICIC CHANGES END */
   (const S8 *)"CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP",
   (const S8 *)"CELL_STATE_ALREADY_BLOCKED",
     /* CA_Stage3_Change: Start */
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_STOP",
   /* CA_Stage3_Change: Start */
   (const S8 *)"CELL_STATE_W_FOR_CELL_INFO_CHANGE_RESP",      /*!< Wait For resp from all cell of eNb for cell delete req */
   /* CA_Stage3_Change: End */
   /* BUG_11648_FIX_START */
   (const S8 *)"CELL_STATE_W_FOR_CELL_STOP_BROADCAST_RESP",  /*!< Wait For resp from all cell of eNb for cell stop */
   /* BUG_11648_FIX_END */
#ifdef LTE_EMBMS_SUPPORTED
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_MBMS",  /*!< Wait For resp from all cells for mbms */
#endif
   /*spr 21625 fix start*/
   (const S8 *)"CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK",
   /*spr 21625 fix end*/
};

const S8 * CELL_STATE[]=
{

   (const S8 *)"RRMCM_RMIF_CONFIG_REQ_EVENT",
   (const S8 *)"RRC_RRM_CELL_SETUP_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_CELL_START_REQ_EVENT",
   (const S8 *)"RRC_RRM_CELL_START_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_RECONFIG_REQ_EVENT",
   (const S8 *)"RRC_RRM_CELL_RECONFIG_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_CELL_STOP_REQ_EVENT",
   (const S8 *)"RRC_RRM_CELL_STOP_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_UPDATE_REQ_EVENT",
   (const S8 *)"RRC_RRM_CELL_UPDATE_RESP_EVENT", 
   (const S8 *)"RRMCM_RMIF_CELL_DELETE_REQ_EVENT",
   (const S8 *)"RRC_RRM_CELL_DELETE_RESP_EVENT",
   (const S8 *)"RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_STOP_ADMISSION_REQ_EVENT",
   (const S8 *)"RRMCM_RMIF_START_ADMISSION_REQ_EVENT",
   (const S8 *)"RRMCM_RMIF_CELL_SON_REGISTER_REQ_EVENT",
   (const S8 *)"RRMCM_RMIF_CELL_SON_DEREGISTER_REQ_EVENT",
   (const S8 *)"RRMCM_RMIF_SON_CELL_SET_ATTR_REQ_EVENT",
   (const S8 *)"CELL_PERIODIC_TIMER_EXPIRY",
   (const S8 *)"RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT",
   (const S8 *)"RRMCM_RMIF_MEAS_CONFIG_REQ_EVENT",
   (const S8 *)"RRMCM_RMIF_UPDATED_NRT_INFO_EVENT",
   (const S8 *)"RRC_RRM_PWS_REQ_EVENT",                /*ETWS CMAS FEAT START*/
   (const S8 *)"RRC_RRM_PWS_CNF_EVENT",
   (const S8 *)"RRC_RRM_KILL_REQ_EVENT",
   (const S8 *)"RRC_RRM_KILL_CNF_EVENT",
   (const S8 *)"RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT",
   (const S8 *)"RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT",   /*ETWS CMAS FEAT END*/
   (const S8 *)"RRM_PERIODIC_RESRC_UPDATE_EVENT",  
   (const S8 *)"RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT",  
   (const S8 *)"RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT",  
   (const S8 *)"RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT",
   (const S8 *)"RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT",
   (const S8 *)"RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_TTT_UPDATE_IND_EVENT",
   (const S8 *)"RRC_RRM_RIM_INFO_EVENT",
   /* DYNAMIC ICIC CHANGES START */
   (const S8 *)"RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT",
   (const S8 *)"RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT",
   (const S8 *)"RRM_UEM_OR_L2_RESPONSE_EVENT",
   (const S8 *)"RRM_CELL_RECONFIG_FOR_ICIC_EVENT",  
   /* DYNAMIC ICIC CHANGES END */
   (const S8 *)"RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT",
   /* bug_13882_start */  
   (const S8 *)"RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT",
   (const S8 *)"RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT",
   /* bug_13882_end */  
   /* SON ES MLB Started */
   (const S8 *)"RRM_ES_PERIODIC_RESRC_UPDATE_EVENT",
   (const S8 *)"RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT",
   /* SON ES MLB end */
   /*RACH_OPTIMIZATION_CHANGES_START*/
   (const S8 *)"RRMCM_RMIF_RACH_INFO_IND_EVENT",
   /*RACH_OPTIMIZATION_CHANGES_END*/
   /* CA_Stage3_Change: Start */
   (const S8 *)"RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT",
   /* CA_Stage3_Change: End */
   /* BUG_11648_FIX_START */
   (const S8 *)"RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT",
  /* BUG_11648_FIX_END */
   /* eICIC_PHASE_1_2_CHANGES_START */
   /* bug_13882_start */  
   (const S8 *)"CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT",
   (const S8 *)"CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT",
   (const S8 *)"CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT",
   (const S8 *)"RRM_UEM_GET_AGGRESSOR_RESP_EVENT",
   (const S8 *)"RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT",
   /* bug_13882_end */  
   /* eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
   (const S8 *)"RRMCM_M2AP_SF_INFO_REQ_EVENT",
#endif
   (const S8 *)"RRMCM_CELL_MAX_EVENTS"
};
/****************************************************************************
 * two dimensional functional pointer for FSM
 ****************************************************************************/

typedef rrm_return_et (*rrm_cellm_func_ptr)( rrm_cell_context_t *);
rrm_cellm_func_ptr rrm_cellm_fsm_tbl[CELL_MAX_STATES][RRMCM_CELL_MAX_EVENTS];

static const void * rrmcm_eutran_meas_context_key(const YLNODE *p_ylnode);
static const void * rrmcm_utran_meas_context_key(const YLNODE *p_ylnode);

/****************************************************************************
 * Function Name  : rrm_cpy_cdma2000_freq_cells
 * Inputs         : inter_rat_ncl_t
 *                : rrmcm_meas_config_sib_info_for_reconfig_t
 * Outputs        : None
 * Returns        : Void
 * Description    : Copy cdma2000 values from
 *                  rrmcm_meas_config_sib_info_for_reconfig_t to inter_rat_ncl_t
 *                  structure 
 ****************************************************************************/
rrm_void_t rrm_cpy_cdma2000_freq_cells(
        inter_rat_ncl_t *p_irat_ncl,
        rrmcm_meas_config_sib_info_for_reconfig_t *p_meas_config_sib_info_for_reconfig
        )
{
    U32 i = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if (p_meas_config_sib_info_for_reconfig->cdma_params.num_valid_cdma2000_freq_cells > RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS)
    {
        p_irat_ncl->num_valid_cdma2000_freq_cells = RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS;
    }
    else
    {
        p_irat_ncl->num_valid_cdma2000_freq_cells =
            p_meas_config_sib_info_for_reconfig->cdma_params.num_valid_cdma2000_freq_cells; 
    }

    for (i = RRM_ZERO; i < p_irat_ncl->num_valid_cdma2000_freq_cells; i++)
    {
        p_irat_ncl->cdma2000_freq_cells[i] =
            p_meas_config_sib_info_for_reconfig->cdma_params.cdma2000_freq_cells[i];
    }

    RRM_UT_TRACE_EXIT();
    return;
}




/*function to remove coverity warning, rel2.0.1, */

rrm_oam_measurement_bandwidth_et rrm_map_oam_bandwidth_value
(
    rrm_allowed_meas_bandwidth_et meas_bandwidth
)
{
    rrm_oam_measurement_bandwidth_et oam_meas_band = RRM_OAM_BW_MEAS_N_6; 
    switch(meas_bandwidth)
    {
	case RRM_ALWD_BW_MBW_6:
	    oam_meas_band = RRM_OAM_BW_MEAS_N_6;
	    break;

	case RRM_ALWD_BW_MBW_15:
	     oam_meas_band = RRM_OAM_BW_MEAS_N_15;
	    break;

	case RRM_ALWD_BW_MBW_25:
	     oam_meas_band = RRM_OAM_BW_MEAS_N_25;
	    break;

	case RRM_ALWD_BW_MBW_50:
	     oam_meas_band = RRM_OAM_BW_MEAS_N_50;
	    break;

	case RRM_ALWD_BW_MBW_75:
	     oam_meas_band = RRM_OAM_BW_MEAS_N_75;
	    break;

	case RRM_ALWD_BW_MBW_100:
	     oam_meas_band = RRM_OAM_BW_MEAS_N_100;
	    break;

	default:
	    oam_meas_band = RRM_OAM_BW_MEAS_N_6;
    }	
    return oam_meas_band;
}

/*function to remove coverity warning, rel2.0.1, */

rrm_son_geran_band_indicator_et rrm_map_son_band_ind_val(rrmcm_rmif_geran_band_indicator_et band_ind)
{
    rrm_son_geran_band_indicator_et son_band_ind = RRM_SON_GERAN_DCS_1800;
    switch(band_ind)
    {
	case RRM_GERAN_DCS_1800:
	    son_band_ind = RRM_SON_GERAN_DCS_1800;
	    break;
	
	case RRM_GERAN_PCS_1900:
	    son_band_ind = RRM_SON_GERAN_PCS_1900;
	    break;

	default:
	    son_band_ind = RRM_SON_GERAN_DCS_1800;
    }
  return son_band_ind;
}
/*EICIC_TDD_CHANGES_START*/
/****************************************************************************
 * Function Name  : rrm_copy_tdd_bits
 * Inputs         : U8  abs_size,
 *                  U8 *p_abs_pattern
 * Outputs        : None
 * Returns        : Void
 * Description    : this function copies abs_pattern as per the tdd config.
 ****************************************************************************/
rrm_void_t rrm_copy_tdd_bits
(
 U8  abs_size,
 U8 *p_abs_pattern
 )    
{
#ifdef TDD_MODE_FLAG
    U8 abs_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    switch(abs_size)
    {
        case RRM_MAX_ABS_PATTERN_BYTE_TDD_0 :
            for(abs_index = RRM_ZERO;abs_index < RRM_MAX_ABS_PATTERN_BYTE_TDD_0;abs_index++)
            {
                if(abs_index < ( RRM_MAX_ABS_PATTERN_BYTE_TDD_0 - RRM_ONE))
                {    
                    p_abs_pattern[abs_index] = p_abs_pattern[abs_index] & 0xFF;
                }
                if(abs_index ==( RRM_MAX_ABS_PATTERN_BYTE_TDD_0 - RRM_ONE))
                {
                    p_abs_pattern[abs_index] = p_abs_pattern[abs_index] & 0xFC;
                }
                /*coverity fix 83002 start*/
                /*delete code*/
                /*coverity fix 83002 start*/

            }
            break;

        case RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 :
            for(abs_index = RRM_ZERO;abs_index < RRM_MAX_ABS_PATTERN_BYTE_TDD_0;abs_index++)
            {
                if(abs_index < ( RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 - RRM_ONE))
                {    
                    p_abs_pattern[abs_index] = p_abs_pattern[abs_index] & 0xFF;
                }
                if(abs_index ==( RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 - RRM_ONE))
                {
                    p_abs_pattern[abs_index] = p_abs_pattern[abs_index] & 0xF0;
                }
                if(abs_index > ( RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 - RRM_ONE))
                {    
                    p_abs_pattern[abs_index] = RRM_ZERO;
                }
            }
            break;

        case RRM_MAX_ABS_PATTERN_BYTE_TDD_6 :
            for(abs_index = RRM_ZERO;abs_index < RRM_MAX_ABS_PATTERN_BYTE_TDD_0;abs_index++)
            {
                if(abs_index < ( RRM_MAX_ABS_PATTERN_BYTE_TDD_6 - RRM_ONE))
                {    
                    p_abs_pattern[abs_index] = p_abs_pattern[abs_index] & 0xFF;
                }
                if(abs_index ==( RRM_MAX_ABS_PATTERN_BYTE_TDD_6 - RRM_ONE))
                {
                    p_abs_pattern[abs_index] = p_abs_pattern[abs_index] & 0xF0;
                }
                if(abs_index > ( RRM_MAX_ABS_PATTERN_BYTE_TDD_6 - RRM_ONE))
                {    
                    p_abs_pattern[abs_index] = RRM_ZERO;
                }
            }
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Invalid abs size[%u] for tdd",abs_index);
                
    }
    RRM_UT_TRACE_EXIT();
#else
    /*SPR 17777 +-*/
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILEDALL,
                    "Unused variable abs_size=%u p_abs_pattern=%p",abs_size,p_abs_pattern);
    /*SPR 17777 +-*/
#endif    
}
/*EICIC_TDD_CHANGES_END*/

/*EICIC_TDD_CHANGES_START*/
/****************************************************************************
 * Function Name  : rrm_copy_tdd_bits_from_src_abs_to_dest
 * Inputs         : U8  abs_size,
 *                  U8 *p_src_abs_pattern,
 *                  U8 *p_dest_abs_pattern
 * Outputs        : None
 * Returns        : Void
 * Description    : this function copies abs_pattern as per the tdd config.
 ****************************************************************************/
rrm_void_t rrm_copy_tdd_bits_from_src_abs_to_dest
(
   U8  abs_size,
   U8 *p_src_abs_pattern,
   U8 *p_dest_abs_pattern
)    
{
    U8 abs_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /*CID:83013 start*/
    /*delete*/
    /*CID:83013 end*/
#ifdef TDD_MODE_FLAG
    if( RRM_MAX_ABS_PATTERN_BYTE_TDD_0 == abs_size )
    {
        for(abs_index = RRM_ZERO;abs_index < RRM_MAX_ABS_PATTERN_BYTE_TDD_0;abs_index++)
        {
            if(abs_index ==( RRM_MAX_ABS_PATTERN_BYTE_TDD_0 - RRM_ONE))
            {
                p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index] & 0xFC;
            }
            else
            {
                p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index];
            }    
        }    
    }    
    else if( RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 == abs_size )
    {
        for(abs_index = RRM_ZERO;abs_index < RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5;abs_index++)
        {
            if(abs_index ==( RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 - RRM_ONE))
            {
                p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index] & 0xF0;
            }
            else
            {
                p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index] ;
            }    
        }
    }
    else if( RRM_MAX_ABS_PATTERN_BYTE_TDD_6 == abs_size)
    {
        for(abs_index = RRM_ZERO;abs_index < RRM_MAX_ABS_PATTERN_BYTE_TDD_6;abs_index++)
        {
            if(abs_index ==(RRM_MAX_ABS_PATTERN_BYTE_TDD_6 - RRM_ONE))
            {
                p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index] & 0xF0;
            }
            else
            {
                p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index];
            }    
        }    
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Invalid abs size[%u] for tdd", abs_size);
    }
#else
    for(abs_index = RRM_ZERO;abs_index < RRM_MAX_PATTERN_BYTE;abs_index++)
    {
        p_dest_abs_pattern[abs_index] = p_src_abs_pattern[abs_index];
    }
    /*SPR 17777 +-*/
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILEDALL,
                    "Unused variable abs_size=%u ",abs_size);
    /*SPR 17777 +-*/
#endif    
    RRM_UT_TRACE_EXIT();
}
/*EICIC_TDD_CHANGES_END*/
/****************************************************************************
 * Function Name  : rrm_get_first_list_node
 * Inputs         : p_list - Pointer to the YLIST object.
 * Outputs        : None.
 * Returns        : The first node in the list.
 * Variables      : None.
 * Description    : Returns the first node in the list. Note that the
 *                  node is not removed from the list.
 ****************************************************************************/
YLNODE *
rrm_get_first_list_node
(
    const YLIST *p_list
)
{
    YLNODE *p_node = RRM_PNULL;
    if (p_list != RRM_PNULL)
    {
        p_node = ylFirst(p_list);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
            "rrm_get_first_list_node: Input pointer received is NULL");
    }
    return p_node;
}

/****************************************************************************
 * Function Name  : rrm_get_next_list_node
 * Inputs         : p_node - Pointer to the YLNODE object.
 * Outputs        : None.
 * Returns        : The next node in the list.
 * Variables      : None.
 * Description    : Returns the node next in the list. Note that the
 *                  node is not removed from the list.
 ****************************************************************************/
YLNODE *
rrm_get_next_list_node
(
    const YLNODE *p_node
)
{
    YLNODE *p_next_node = RRM_PNULL;
    if (RRM_PNULL != p_node)
    {
        p_next_node = ylNext(p_node);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
            "get_next_list_node: Input pointer received is NULL");
    }
    return p_next_node;
}

/****************************************************************************
 * Function Name  : rrm_list_delete_node
 * Inputs         : p_list - Pointer to the LIST object.
 *                  p_node - Pointer to the LIST NODE object.
 * Outputs        : None.
 * Returns        : None.
 * Variables      : None.
 * Description    : Deletes an element in the list.
 ****************************************************************************/
rrm_void_t
rrm_list_delete_node
(
    YLIST        *p_list,
    YLNODE       *p_node
)
{
    if ((p_list != RRM_PNULL) && (p_node != RRM_PNULL))
    {
        ylDelete(p_list, p_node);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
            "list_delete_node: Input pointer received is NULL");
    }
}

/*SPR 22445 Fix Start*/
/****************************************************************************
 * Function Name  : rrmcm_decide_dequeue_message 
 * Inputs         : U8      event : event for FSM
 *                : rrm_cell_context_t  *cell_context : pointer to cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : In this function we decide that we have to dequeue the 
 *                  message or not.
 ****************************************************************************/
void rrmcm_process_queued_msg(   	
    rrm_cell_states_et  old_cell_state,
    rrm_cell_context_t  *p_cell_context)
{
    RRM_UT_TRACE_ENTER();
    if ((old_cell_state != p_cell_context->cell_state) ||
            ((old_cell_state == CELL_STATE_ACTIVE)&&(p_cell_context->cell_state == CELL_STATE_ACTIVE)))
    {
        rrmcm_dequeue_message(p_cell_context);
    }
    RRM_UT_TRACE_EXIT();
}
/*SPR 22445 Fix Stop*/

/****************************************************************************
 * Function Name  : cellm_fsm_process_event
 * Inputs         : U8      event : event for FSM
 *                : rrm_cell_context_t  *cell_context : pointer to cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Entry process for CELLM FSM
 ****************************************************************************/
rrm_return_et
cellm_fsm_process_event(   	
    U8 event /*Incoming event*/,
    rrm_cell_context_t  *cell_context/*event occured for the cell context*/)
{
    rrm_cell_states_et current_cell_state = CELL_MAX_STATES ;
    rrm_return_et  ret_val = RRM_FAILURE;
    U8             response = RRM_NULL;
    RRM_UT_TRACE_ENTER();
    
    /*Get the cell state from cell context*/
    current_cell_state = cell_context->cell_state;
    if ((current_cell_state < CELL_MAX_STATES) 
        && (event < RRMCM_CELL_MAX_EVENTS))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "### CellFSM: Processing State %s Event: %s ###",
                CELL_FSM_STATE[current_cell_state], CELL_STATE[event]);

        if(RRM_SUCCESS == (response = rrm_cellm_fsm_tbl[current_cell_state][event](cell_context)))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "### CellFSM: State change: %s -> %s Event: %s ###",
                    CELL_FSM_STATE[current_cell_state],
                    CELL_FSM_STATE[cell_context->cell_state], CELL_STATE[event]);

            ret_val = RRM_SUCCESS;
        }
        else if(response == RRM_CELL_INVALID_STATE_FOR_PWS)
        {
            ret_val = RRM_CELL_INVALID_STATE_FOR_PWS; 

        }
        else
        {
            /* CSR 58774 Fix Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "#### CellFSM: FSM failed State change: %s -> %s  Event: %s ####",
                    CELL_FSM_STATE[current_cell_state],
                    CELL_FSM_STATE[cell_context->cell_state], CELL_STATE[event]);

            /* CSR 58774 Fix End*/
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "#### CellFSM: Cell: %u Invalid State: %d  Event: %d ####",
                   cell_context->cell_index, current_cell_state, event);
                   
           ret_val = RRM_FAILURE;
    }
    /*SPR 22445 Fix Start*/
    rrmcm_process_queued_msg(current_cell_state,cell_context);
    /*SPR 22445 Fix Stop*/
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 14131 start*/
/****************************************************************************
 * Function Name  : rrm_send_enable_disable_ind_to_son
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles enable_disable_ind to son in FSM
 ****************************************************************************/
rrm_return_et 
rrm_send_enable_disable_ind_to_son
(
    rrm_cell_context_t *p_cell_ctx
)
{
    /*SPR 14131 start*/
     rrm_son_eicic_enable_disable_ind_t rrm_son_eicic_enable_disable_ind = { RRM_ZERO};
    /*SPR 14131 end*/
    rrm_return_et ret_val = RRM_SUCCESS;
    
    RRM_UT_TRACE_ENTER();
    
    RRM_MEMCPY( &(rrm_son_eicic_enable_disable_ind.cell_id),
            &(p_cell_ctx->global_cell_id),
            sizeof(rrm_oam_eutran_global_cell_id_t));

    switch(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type)
    {
        case RRM_OAM_ACT_AS_AGGRESSOR:
            rrm_son_eicic_enable_disable_ind.eicic_provisioned_type = RRM_SON_ACT_AS_AGGRESSOR;
            break;

        case RRM_OAM_ACT_AS_VICTIM:
            rrm_son_eicic_enable_disable_ind.eicic_provisioned_type = RRM_SON_ACT_AS_VICTIM;
            break;

        case RRM_OAM_ACT_AS_AGGRESSOR_AND_VICTIM:
            rrm_son_eicic_enable_disable_ind.eicic_provisioned_type = RRM_SON_ACT_AS_AGGRESSOR_AND_VICTIM;
            break;

        case RRM_OAM_EICIC_DEACTIVATED:
            rrm_son_eicic_enable_disable_ind.eicic_provisioned_type = RRM_SON_EICIC_DEACTIVATED;
            break;

        default:
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "Invalid EICIC provision type[%d] is recieved, Taking default value as DEACTIVATED",
                    p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type);
            rrm_son_eicic_enable_disable_ind.eicic_provisioned_type = RRM_SON_EICIC_DEACTIVATED;
    }

    rrm_son_send_rrm_son_eicic_enable_disable_ind( &rrm_son_eicic_enable_disable_ind,
            RRM_MODULE_ID,
            RRM_SON_MLB_MODULE_ID,
            RRM_ZERO,
            p_cell_ctx->cell_index);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 14131 end*/

/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  :rrm_send_cell_state_ind_to_mif
 * Inputs         : U8      event : event for FSM
 *                : rrm_cell_context_t  *cell_context : pointer to cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Entry process for CELLM FSM
 ******************************************************************************/
rrm_void_t
rrm_send_cell_state_ind_to_mif(rrmcm_rmif_cell_state_change_ind_t   *p_ind ,
                               U8                                    cell_state)
{
    RRM_UT_TRACE_EXIT();
           switch (cell_state)
          {
              case CELL_STATE_ACTIVE:
                   p_ind->cell_state = RRM_MIF_CELLM_CELL_OPERATIONAL;
                   p_ind->cell_state_change_cause = RRM_MIF_CELLM_CELL_START;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                     RRM_BRIEF,"cell state :%d",p_ind->cell_state);
                   break;
             case CELL_STATE_INACTIVE:
             case CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP:
             case CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_STOP_RESP:
                  p_ind->cell_state = RRM_MIF_CELLM_CELL_UNOPERATIONAL_DUE_TO_SWITCHOFF;
                  p_ind->cell_state_change_cause = RRM_MIF_CELLM_CELL_STOP;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                     RRM_BRIEF,"cell state :%d",p_ind->cell_state);
                  break;
             case CELL_STATE_DELETE_IN_PROGRESS:
                  p_ind->cell_state = RRM_MIF_CELLM_CELL_UNOPERATIONAL_DUE_TO_CELL_DELETE;
                  p_ind->cell_state_change_cause = RRM_MIF_CELLM_CELL_DELETE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                     RRM_BRIEF,"cell state :%d",p_ind->cell_state);
                  break;
            default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "wrong cell state received: %s [%d]",CELL_FSM_STATE[cell_state],cell_state);
          }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  :send_cell_state_ind_to_mif 
 * Inputs         : U8      event : event for FSM
 *                : rrm_cell_context_t  *cell_context : pointer to cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Entry process for CELLM FSM
 ******************************************************************************/
rrm_return_et
send_cell_state_ind_to_mif
(
  rrm_cell_context_t *p_cell_ctx,
  rrm_mif_cellm_message_resp_e resp,
  U8 cell_state
)
{
    rrmcm_rmif_cell_state_change_ind_t *p_ind = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_EXIT();
    
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "cell state chnage indication for cell index:%d",p_cell_ctx->cell_index);
    p_ind = rrm_mem_get(sizeof(rrmcm_rmif_cell_state_change_ind_t));
    /*coverity id :16288, added NULL check for return of rrm_mem_get */
    if(p_ind != RRM_PNULL)
    {
        p_ind->cellindex = p_cell_ctx->cell_index; 
        /*Klockwork_fix_start*/
        rrm_send_cell_state_ind_to_mif(p_ind ,cell_state);
        /*Klockwork_fix_end*/
    }
    else
    {
	  RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
	                        "Memory allocation to p_ind failed");
      RRM_UT_TRACE_EXIT();
	  return RRM_FAILURE;
    }
    if(RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
			    resp,
			    sizeof(rrmcm_rmif_cell_state_change_ind_t),
			    (void *)p_ind)) 
    {  
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Send State Change Indi for cell index%d",p_cell_ctx->cell_index);
	    ret_val = RRM_SUCCESS;
    }
    else
    {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "failure in sending state change ind for cell_index %d",
			    p_cell_ctx->cell_index);
	    ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_ind);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : cell_state_change_ind 
 * Inputs         : U8      event : event for FSM
 *                : rrm_cell_context_t  *cell_context : pointer to cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Entry process for CELLM FSM
 ******************************************************************************/
rrm_return_et
cell_state_change_ind
(
 rrm_cell_context_t *p_rrm_cell_ctx,
 U8 cell_state
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    cell_son_attr_info_list_t  *p_attribute_info = RRM_PNULL;  
    RRM_UT_TRACE_ENTER();

    if (p_rrm_cell_ctx->p_son_info != RRM_PNULL)
    {
        if (p_rrm_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)
        {
            p_attribute_info = p_rrm_cell_ctx->p_son_info->p_anr_info;
            if(p_attribute_info->p_cell_state!= RRM_PNULL)
            {
                if(p_attribute_info->p_cell_state->flag_trgr_cell_state == RRM_TRUE)
                {
                   /* send cell state change ind to SON */
                   ret_val = send_cell_state_ind_to_mif(p_rrm_cell_ctx,
                                RRMCM_RMIF_CELL_STATE_CHANGE_FOR_ANR_IND,
                                cell_state);
                   if(ret_val == RRM_FAILURE)
                   {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_ERROR,"failed to send cell state change ind");
                   }
                }
            }
        }
        if (p_rrm_cell_ctx->p_son_info->p_es_info != RRM_PNULL)
        {
            p_attribute_info = p_rrm_cell_ctx->p_son_info->p_es_info;
            if(p_attribute_info->p_cell_state!= RRM_PNULL)
            {
                if(p_attribute_info->p_cell_state->flag_trgr_cell_state == RRM_TRUE)
                {
                   /* send threshold ind to SON */
                   ret_val = send_cell_state_ind_to_mif(p_rrm_cell_ctx,
                                RRMCM_RMIF_CELL_STATE_CHANGE_FOR_ES_IND,
                                cell_state);
                   if(ret_val == RRM_FAILURE)
                   {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                               "failed to send cell state change ind");
                   }
                }
            }
        }
        if (p_rrm_cell_ctx->p_son_info->p_mlb_info != RRM_PNULL)
        {
            p_attribute_info = p_rrm_cell_ctx->p_son_info->p_mlb_info;
            if(p_attribute_info->p_cell_state!= RRM_PNULL)
            {
                if(p_attribute_info->p_cell_state->flag_trgr_cell_state == RRM_TRUE)
                {
                   /* send threshold ind to SON */
                   ret_val = send_cell_state_ind_to_mif(p_rrm_cell_ctx,
                                RRMCM_RMIF_CELL_STATE_CHANGE_FOR_MLB_IND,
                                cell_state);
                   if(ret_val == RRM_FAILURE)
                   {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                               "failed to send CELL_STATE_CHANGE_FOR_MLB");
                   }
                }
            }
        }
        if ((p_rrm_cell_ctx->p_son_info != RRM_PNULL) &&
            (p_rrm_cell_ctx->p_son_info->p_mro_info != RRM_PNULL))
        {
            p_attribute_info = p_rrm_cell_ctx->p_son_info->p_mro_info;
            if(p_attribute_info->p_cell_state!= RRM_PNULL)
            {
                if(p_attribute_info->p_cell_state->flag_trgr_cell_state == RRM_TRUE)
                {
                   /* send threshold ind to SON */
                   ret_val = send_cell_state_ind_to_mif(p_rrm_cell_ctx,
                                RRMCM_RMIF_CELL_STATE_CHANGE_FOR_MRO_IND,
                                cell_state);
                   if(ret_val == RRM_FAILURE)
                   {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                               "failed to send CELL_STATE_CHANGE_FOR_MRO");
                   }
                }
            }
        }
        /*SPR 15993 Fix Start*/
        /* RACH_OPTIMIZATION_CHANGES_START */
        if (RRM_ZERO != p_rrm_cell_ctx->cell_rach_info.rach_l2_periodic_timer)
        {
        /*SPR 15993 Fix End*/
        ret_val = send_cell_state_ind_to_mif(p_rrm_cell_ctx,
                RRMCM_RMIF_CELL_STATE_CHANGE_FOR_RACH_OPTI,
                cell_state);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to send CELL_STATE_CHANGE_FOR_RACH_OPTIMIZATION");
        }
        /* RACH_OPTIMIZATION_CHANGES_END */
        /*SPR 15993 Fix Start*/
        }
        /*SPR 15993 Fix End*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val; 
}
/****************************************************************************
 * Function Name  : rrm_send_internal_msg
 * Inputs         : U16     dst_module_id: Destination module identifier 
 *                : U16     api_id  : API Id 
 *		  : U16  msg_size : Size of message (payload) 	
 *		  : void *p_msg  : Message specific info (payload) 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Initialises the cell context cell_resource and other parameters
 ****************************************************************************/
rrm_return_et
rrm_send_internal_msg(
    U16     dst_module_id,
    U16     api_id,
    U16     msg_size,
    void    *p_msg)
{
  U8 *p_api          = RRM_PNULL;
  rrm_return_et	ret_val = RRM_FAILURE;
  U16 msg_api_length = (U16)(msg_size + RRM_API_HEADER_SIZE);

  RRM_UT_TRACE_ENTER();

  /* Allocate buffer */
  p_api = rrm_msg_mem_get(msg_api_length);
  if (RRM_PNULL == p_api)
  {
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	"failed in mem allocation");
    ret_val = RRM_FAILURE; 
  }
  else
  {    
    RRM_MEMSET(p_api, RRM_ZERO, msg_api_length);
    rrm_construct_cspl_header(
	p_api, 
	RRM_VERSION_ID,RRM_CM_MODULE_ID,
	dst_module_id, 
	api_id, 
	RRM_API_PRIORITY,
	msg_api_length);
    /** Send message to required destination*/

    RRM_MEMCPY(p_api + RRM_API_HEADER_SIZE, p_msg, msg_size);
    /*SPR 20172 Fix Start*/
    rrm_send_message(p_api, dst_module_id);
    /*SPR 20172 Fix End*/
    /* SPR 21251 +- */
    ret_val = RRM_SUCCESS;
  }
  RRM_UT_TRACE_EXIT();

  return ret_val;
}
/****************************************************************************
* Function Name  : fail_cause_lower_range
* Inputs         : U8 fail_cause
* Outputs        : None
* Returns        : U16 new_fail_cause
* Description    : mapping of fail cause
****************************************************************************/
/*klock_works_changes_start*/
rrm_error_et
fail_cause_lower_range(U8 fail_cause)
{
    rrm_error_et new_fail_cause = RRM_NO_ERROR;

    RRM_UT_TRACE_ENTER();

  switch(fail_cause)
  {
      case RRM_RRC_NO_ERROR:
            new_fail_cause = RRM_NO_ERROR;
            break;
      case RRM_RRC_INTERNAL_FAILURE:
            new_fail_cause = RRM_ERR_CELL_CONFIG_FAILURE;
            break;
      case RRM_RRC_LL_CONFIG_FAILURE:
            new_fail_cause = RRM_ERR_CELL_CONFIG_FAILURE;
            break;
      case RRM_RRC_LL_DEL_FAILURE:
            new_fail_cause = RRM_ERR_CELL_DELETION_FAILURE;
            break;
      case RRM_RRC_UNKNOWN_FAILURE:
            new_fail_cause = RRM_ERR_CELL_DELETION_EXPECTED;
            break;
      case RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE:
            new_fail_cause = RRM_ERR_EVENT_NOT_POSSIBLE;
            break;
      case RRM_RRC_CELL_START_TIMER_EXPIRED:
            new_fail_cause = RRM_ERR_CELL_START_FAILURE;
            break;
        default:
            break;

    }

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            " New Fail Cause by RRM:%d", fail_cause);
    RRM_UT_TRACE_EXIT();
    return new_fail_cause;
}
/****************************************************************************
* Function Name  : fail_cause_higher_range
* Inputs         : U8 fail_cause
* Outputs        : None
* Returns        : U16 new_fail_cause
* Description    : mapping of fail cause
****************************************************************************/
rrm_error_et
fail_cause_higher_range(U8 fail_cause)
{
    rrm_error_et new_fail_cause = RRM_NO_ERROR;

    RRM_UT_TRACE_ENTER();

    switch(fail_cause)
    {

      case RRM_RRC_CELL_STOP_TIMER_EXPIRED:
            new_fail_cause = RRM_ERR_CELL_STOP_FAILURE;
            break;
      case RRM_RRC_PHY_START_FAILURE:
            new_fail_cause = RRM_ERR_CELL_START_FAILURE;
            break;
      case RRM_RRC_PHY_STOP_FAILURE:
            new_fail_cause = RRM_ERR_CELL_STOP_FAILURE;
            break;
      case RRM_RRC_MAC_START_FAILURE:
            new_fail_cause = RRM_ERR_CELL_START_FAILURE;
            break;
      case RRM_RRC_MAC_STOP_FAILURE:
            new_fail_cause = RRM_ERR_CELL_STOP_FAILURE;
            break;
      case RRM_RRC_CELL_START_ALREADY_ONGOING:
            new_fail_cause = RRM_ERR_CELL_START_FAILURE;
            break;
      case RRM_RRC_CELL_STOP_ALREADY_ONGOING:
            new_fail_cause = RRM_ERR_CELL_STOP_FAILURE;
            break;
        default :
            break;

    }

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            " New Fail Cause by RRM:%d", fail_cause);
    RRM_UT_TRACE_EXIT();
    return new_fail_cause;
}
/*klock_works_changes_end*/




/****************************************************************************
* Function Name  : fail_cause_mapping 
* Inputs         : U8 fail_cause
* Outputs        : None
* Returns        : U16 new_fail_cause 
* Description    : mapping of fail cause
****************************************************************************/
rrm_error_et fail_cause_mapping(U8 fail_cause)
{
  rrm_error_et new_fail_cause = RRM_NO_ERROR; /* Coverity: CID 55840 */
  RRM_UT_TRACE_ENTER();
  
  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
          "Fail Cause:%d", fail_cause);
  /*klock_works_changes_start*/
  if (fail_cause<=RRM_RRC_CELL_START_TIMER_EXPIRED)

  {
      new_fail_cause=fail_cause_lower_range(fail_cause);
  }
  else
  {
      new_fail_cause=fail_cause_higher_range(fail_cause);
  }
  /*klock_works_changes_end*/


   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                " New Fail Cause by RRM:%d", fail_cause);
  RRM_UT_TRACE_EXIT();
  return new_fail_cause;
}

/*SPR 21660 changes start */
/****************************************************************************
* Function Name  : rmcm_rmif_send_stop_resp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : send stop success response to MIF
****************************************************************************/
rrm_return_et
rmcm_rmif_send_stop_resp
(
    U16 transaction_id,
    rrc_rrm_cell_stop_resp_t *rrc_rrm_cell_stop_resp 
)
{
     rrm_return_et ret_val = RRM_SUCCESS; 
     rrmcm_rmif_generic_resp_t *p_cell_generic_resp = RRM_PNULL;
//     rrc_rrm_cell_stop_resp_t *rrc_rrm_cell_stop_resp = RRM_PNULL;

     RRM_UT_TRACE_ENTER();

//     rrc_rrm_cell_stop_resp = (rrc_rrm_cell_stop_resp_t *)
//                                  p_cell_ctx->p_incoming_api_info;

     p_cell_generic_resp = rrm_mem_get(sizeof
                                      (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16284 , added NULL check for rrm_mem_get */
    if(p_cell_generic_resp != RRM_PNULL)
    {
     p_cell_generic_resp->cellindex = rrc_rrm_cell_stop_resp->cell_index;
     p_cell_generic_resp->response = rrc_rrm_cell_stop_resp->response; 
     p_cell_generic_resp->transaction_id = transaction_id;
         if(RRM_FAILURE ==  rrc_rrm_cell_stop_resp->response)
         {
             p_cell_generic_resp->fail_cause = fail_cause_mapping(
                     rrc_rrm_cell_stop_resp->fail_cause);

             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                     "Cell Stop Failed Fail Cause:%d",p_cell_generic_resp->fail_cause);
         }
         else
         {
             p_cell_generic_resp->fail_cause = RRM_NO_ERROR;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                     "Cell Stop Success For Cell Index:%d",
                     rrc_rrm_cell_stop_resp->cell_index);
         }
      
     /*
      * sending response to MIF
      */
      if(RRM_FAILURE ==  rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                             RRMCM_RMIF_CELL_STOP_RESP,
                             sizeof(rrmcm_rmif_generic_resp_t),
                             (void *)p_cell_generic_resp))
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "Failed to Send Cell Stop Resp:%d For Cell Index:%d",
                  RRMCM_RMIF_CELL_STOP_RESP,rrc_rrm_cell_stop_resp->cell_index);
	  /*LTE_RRM_KLOCWORK_WARN_4_7_12_START*/
	  ret_val = RRM_FAILURE;
	  /*LTE_RRM_KLOCWORK_WARN_4_7_12_END*/
      }
      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "Send Cell Stop Resp :%d To Mif For Cell Index:%d",
                  RRMCM_RMIF_CELL_STOP_RESP,rrc_rrm_cell_stop_resp->cell_index);
      }
    
    RRM_MEM_FREE(p_cell_generic_resp);
    }
    else
    {
	  RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
	                        "Memory allocation to p_cell_generic_resp failed");
      RRM_UT_TRACE_EXIT();
	  ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*SPR 21660 changes end */
/*Klockwork_fix_start*/
/****************************************************************************
* Function Name  : rmcm_rmif_cell_stop_resp_es_ld
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build the cell stop response and send it to RRC
****************************************************************************/
    rrm_void_t
rmcm_rmif_cell_stop_resp_es_ld(rrm_cell_context_t    *p_cell_ctx)
{
    RRM_UT_TRACE_ENTER();

        /* SPR-17852 END */
        /* MLB Changes end */
        /* SON ES MLB Started */
        if (RRM_PNULL != p_cell_ctx->p_son_info)
        {
            if (RRM_PNULL != p_cell_ctx->p_son_info->p_es_info)
            {
                /* SPR-17852 START */
                if (RRM_ZERO != p_cell_ctx->p_son_info->p_es_info->cell_timer_id[SON_ES_LD_SELF_TIMER]) 
                {
                    /* SPR-17852 END */

                    cell_stop_timer (p_cell_ctx->p_son_info->p_es_info->cell_timer_id[SON_ES_LD_SELF_TIMER]);
                    p_cell_ctx->p_son_info->p_es_info->cell_timer_id[SON_ES_LD_SELF_TIMER] = RRM_ZERO;
                }
            }
        }
        /* SON ES MLB end */
        /* DYNAMIC ICIC CHANGES START */ 
        /* SPR-17852 START */
        if (RRM_ZERO != p_cell_ctx->x2ap_icic_info_rpt_tmr)
        {
        /* SPR-17852 END */
            cell_stop_timer(p_cell_ctx->x2ap_icic_info_rpt_tmr);
            p_cell_ctx->x2ap_icic_info_rpt_tmr = RRM_PNULL;
        }
        /* DYNAMIC ICIC CHANGES END */
        /* BUG_11848_CHANGES_START */
        /* SPR-17852 START */
        if (RRM_ZERO != p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic)
        {
        /* SPR-17852 END */
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                      "Stopping ICIC timer");
            cell_stop_timer(p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic);
            p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic = RRM_PNULL;
        }
        p_cell_ctx->immediate_cell_start= RRM_FALSE;
        /* BUG_11848_CHANGES_END */
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/****************************************************************************
* Function Name  : RrmMifCellStopResp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build the cell stop response and send it to RRC
****************************************************************************/
rrm_return_et
rmcm_rmif_cell_stop_resp
(
   rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_stop_resp_t *rrc_rrm_cell_stop_resp = RRM_PNULL;    

    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_stop_resp = p_cell_ctx->p_incoming_api_info;
    if(RRM_FAILURE == rrc_rrm_cell_stop_resp->response)
    {
        if(RRM_FAILURE == rmcm_rmif_send_stop_resp(p_cell_ctx->ongoing_trans_id,rrc_rrm_cell_stop_resp))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed To Send Cell Stop Resp for Cell Index:%d",
                    p_cell_ctx->cell_index);
        }
        /*RIM changes start*/
    /* Spr 16211 Changes Start*/
        if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Sending RIM info req to RRC with PDU ext as STOP as cell has been successfully stopped");
            rrm_request_rim_info_req(p_cell_ctx, 
                    &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
                    RAN_INFO_REQ_STOP);
        }
    /* Spr 16211 Changes End*/
        /*RIM changes end*/

        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_OUT_OF_SERVICE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell Stop Failed for Cell Index:%d Cell State is:%s [%d]",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                p_cell_ctx->cell_state);
        ret_val = RRM_FAILURE;
    }
    else
    {
       /* Bug_857 start */
       RRM_GETTIMEOFDAY(&p_cell_ctx->kpi_stat.cell_stop_time, RRM_PNULL);
       /* Bug_857 end  */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Cell Stop Success response for cell index:%d",
                p_cell_ctx->cell_index);
        /*BUG:183*/
        ret_val = rmcm_cell_send_del_to_ue(p_cell_ctx);
        if (ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed To Send Cell delete Req for Cell Index:%d",
                    p_cell_ctx->cell_index);

        }
        else
        {
            p_cell_ctx->cell_stop_ongoing_del_ue_ctxt = RRM_TRUE;
            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_UEM_DEL);
        }
        /*BUG:183*/
        /*BUG:102 start*/
        p_cell_ctx->cell_stop_not_send_active_ue_count = RRM_TRUE;
        /*BUG:102 end*/

        /* MLB Changes start */
        /* SPR-17852 START */
        if (RRM_ZERO != p_cell_ctx->self_load_rpt_tmr)
        {
        /* SPR-17852 END */
            cell_stop_timer(p_cell_ctx->self_load_rpt_tmr);
            p_cell_ctx->self_load_rpt_tmr = RRM_ZERO;
        }
        /* eICIC_PHASE_1_2_CHANGES_START */
        rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
        /* SPR-17852 START */
        if(p_cell_ctx->cell_load_action.ld_process_timer_id) 
        {
          cell_stop_timer (p_cell_ctx->cell_load_action.ld_process_timer_id);
          p_cell_ctx->cell_load_action.ld_process_timer_id = RRM_PNULL;
        }
        /* SPR-17852 END */
        /* eICIC_PHASE_1_2_CHANGES_END */
        /* Stop Cell load process timer */
        /* MLB Changes end */
        /* SON ES MLB Started */
        /*Klockwork_fix_start*/
        rmcm_rmif_cell_stop_resp_es_ld(p_cell_ctx);
        /*Klockwork_fix_end*/

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_11648_FIX_START */
/****************************************************************************
* Function Name  : rmcm_rmif_cell_stop_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build the cell stop request and send it to RRC
****************************************************************************/
rrm_return_et
rmcm_rmif_cell_stop_req
(
  rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
//    rrc_rrm_cell_stop_req_t *p_cell_stop_req = RRM_PNULL;
    rrm_return_et ret_val = RRM_FAILURE;
  //  rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();
    if (p_g_rrm_cell_ctx->enb_cell_count != RRM_ONE)
    {
        /* Carrier Aggregation start*/
        p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.
            ca_config_bitmask |= RRM_CA_CELL_STOP_BITMASK ;

        rrm_broadcast_carrier_agg_configuration_change_event_at_eNB(
                p_cell_ctx->cell_index,
                p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask, p_cell_ctx->ongoing_trans_id );

        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_W_FOR_CELL_STOP_BROADCAST_RESP);
    
        p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;
        /* BUG_12416_FIX_START */
        if(( RRM_ZERO != p_cell_ctx->intra_eNB_cell_load_broadcast_timer )&&
                (qvTimerRunning(p_cell_ctx->intra_eNB_cell_load_broadcast_timer)))
        {
            cell_stop_timer( p_cell_ctx->intra_eNB_cell_load_broadcast_timer );
            p_cell_ctx->intra_eNB_cell_load_broadcast_timer = RRM_ZERO;
        }
        /* BUG_12416_FIX_END */
        /* Carrier Aggregation start*/

        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell State is :%s[%d]",
                CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
    }
    else
    {  
        /*SPR 21660 changes start*/
        if(RRM_FAILURE == build_and_send_cell_stop_req(p_cell_ctx->ongoing_trans_id,
                    p_cell_ctx->cell_index))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed To Send Cell Stop Req To RRC For Cell Index:%d",
                    p_cell_ctx->cell_index);
        }
        else
        {
#ifdef RRM_UT_FLAG        
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_stop_req);
#endif        
            CELL_M_FSM_SET_STATE(p_cell_ctx,
                    CELL_STATE_W_FOR_CELL_STOP_RESP);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell State is :%s[%d]",
                    CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
        }
        /*SPR 21660 changes end*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_11648_FIX_END */
/****************************************************************************
* Function Name  : rmcm_mif_rac_enable_diable_req 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build the cell start request and send it to RRC
****************************************************************************/
rrm_return_et
rmcm_mif_rac_enable_diable_req
(
 rrm_cell_context_t *p_cell_ctx
 )
{
    rrmcm_rmif_rac_enable_disable_req_t *p_rac_enb_dis_req = RRM_PNULL;
    rrmcm_rmif_rac_enable_disable_res_t *p_resp = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_rac_enb_dis_req = (rrmcm_rmif_rac_enable_disable_req_t *)
        (p_cell_ctx->p_incoming_api_info);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Flag enable_rac_flag:%d", 
            p_cell_ctx->enable_rac_flag);
    p_cell_ctx->enable_rac_flag = p_rac_enb_dis_req->enable_rac;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Updated Flag enable_rac_flag:%d recv flag:%d", 
            p_cell_ctx->enable_rac_flag,
            p_rac_enb_dis_req->enable_rac);

    p_resp = (rrmcm_rmif_rac_enable_disable_res_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_rac_enable_disable_res_t));
    if(p_resp == RRM_PNULL)
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_resp failed");
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_FAILURE;
    }
    else
    {

        p_resp->transaction_id =p_rac_enb_dis_req->transaction_id; 
        p_resp->bitmask = p_rac_enb_dis_req->bitmask; 
        p_resp->cell_index = p_cell_ctx->cell_index;
        p_resp->response   = RRM_SUCCESS;
        p_resp->fail_cause = RRM_NO_ERROR;

        if ( RRM_FAILURE == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_RAC_ENABLE_DISABLE_RES,
                    sizeof(rrmcm_rmif_rac_enable_disable_res_t),
                    (void *)p_resp))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to send RAC disable and enable resp");
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Message id %d send successfully	to MIF",
                    RRMCM_RMIF_RAC_ENABLE_DISABLE_RES);
            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_resp);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
* Function Name  : rmcm_rmif_cell_start_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build the cell start request and send it to RRC
****************************************************************************/

rrm_return_et
rmcm_rmif_cell_start_req
(
    rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
/* SPR 21660 changes start*/
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    ret_val = build_and_send_cell_start_req(p_cell_ctx->ongoing_trans_id,
            p_cell_ctx->cell_index);
    if(RRM_SUCCESS == ret_val)
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_start_req);
#endif        
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_W_FOR_CELL_START_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell State is :%s [%d]",
                CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
    }
    else
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_start_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_start_resp_F_inv_param);
#endif        
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed To Send Cell Start Req TO RRC For Cell Index:%d",
                p_cell_ctx->cell_index);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
/* SPR 21660 changes end*/
 
}
/* SPR 21660 changes start*/
     
/****************************************************************************
* Function Name  : build_and_send_cell_start_req 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build and send the cell start request
****************************************************************************/
rrm_return_et
build_and_send_cell_start_req
(
 U16  transaction_id,
 U8   cell_index
)
{
     rrc_rrm_cell_start_req_t *p_cell_start_req = RRM_PNULL;
     rrm_return_et ret_val = RRM_SUCCESS;
     rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};

     RRM_UT_TRACE_ENTER();

     p_cell_start_req = rrm_mem_get(sizeof(rrc_rrm_cell_start_req_t));
     if(p_cell_start_req == RRM_PNULL)
     {
       RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                            "Memory allocation to p_cell_start_req failed");
       RRM_UT_TRACE_EXIT();
       ret_val = RRM_FAILURE;
     }
     else
     {
         if(RRM_FAILURE == build_send_start_req(transaction_id,
                cell_index, p_cell_start_req))
         {
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                     "Failed To Send Cell Start Req TO RRC For Cell Index:%d",
                     cell_index);
            /* fill generic response */
             generic_resp_to_mif.cellindex = cell_index; 
             generic_resp_to_mif.transaction_id = transaction_id;
             generic_resp_to_mif.response = RRM_FAILURE;
             generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
            /* send generic response to mif */
             ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                     RRMCM_RMIF_CELL_START_RESP);
             if (RRM_FAILURE == ret_val)
             {
                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                         RRM_ERROR," Failed to send generic response to MIF");
             }
             ret_val = RRM_FAILURE;
         }
         else
         {
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                     "Successfull send cell start request");
         }
         RRM_MEM_FREE(p_cell_start_req);
     }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 21660 changes end */

/* UE MEAS CHANGES : STARTS */
/*******************************************************************
* Function Name  : rmcm_mif_meas_config_resp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles Meas Config Response for MIF in FSM
********************************************************************/
rrm_return_et
rmcm_mif_meas_config_resp
(
   rrm_cell_context_t *p_cell_ctx,
   U8                  status,
   rrm_error_et        error_code, /* Coverity_ID : 16486 */
   U16                 api_id
)
{
    rrmcm_rmif_generic_resp_t *p_cell_generic_resp = RRM_PNULL;
    void *ptr = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    if (RRM_PNULL == p_cell_generic_resp)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed to get memory for response message :%d for cell index:%d",
                api_id,
                p_cell_ctx->cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    else
    {
        p_cell_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_cell_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_cell_generic_resp->response = status;
        p_cell_generic_resp->fail_cause = error_code;

        ptr = (void *)p_cell_generic_resp;
        /*
         * sending failure response to MIF
         */
        if (RRM_FAILURE == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                    api_id,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    ptr))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    api_id,
                    p_cell_ctx->cell_index);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED
                    ,"success in sending :%d for cell index:%d",
                    api_id,
                    p_cell_ctx->cell_index);
        }
        RRM_MEM_FREE(p_cell_generic_resp);
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/****************************************************************************
 * Function Name  : rrmcm_get_intra_inter_rat_freq 
 * Inputs         : rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req 
 * Inputs         : U8                                     freq_index 
 * Inputs         : rrm_rat_type_et                        rat_type 
 * Outputs        : NONE
 * Returns        : ARFCN
 * Description    : Get the eutran/utran/geran frequency from the request received from SON 
 ****************************************************************************/
U16
rrmcm_get_intra_inter_rat_freq
(
   rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
   U8                                        freq_index,
   rrm_rat_type_et                           rat_type      
)
{
    U16               arfcn = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(rat_type == RRM_EUTRAN_CELL)
    {
      arfcn = p_meas_config_req->meas_config_req.
                            eutran_config_list[freq_index].earfcn;
    }
    else if(rat_type == RRM_UTRAN_CELL)
    {
        arfcn = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                  utran_config_list.utran_fdd_list[freq_index].uarfcn;
    }
    else if(rat_type == RRM_GERAN_CELL)
    {
        arfcn = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                  geran_config_list.geran_freq_info_list[freq_index].geran_car_freqs.
                  starting_arfcn;
    }
    else
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "Invalid RAT TYPE[%d]", rat_type);
    }
    RRM_UT_TRACE_EXIT();
    return arfcn;
}
/* SPR 16406 Start */
/* SPR 17845 Fix Start */
//Code Deleted
/* SPR 17845 Fix Stop */
/* SPR 16406 End */

/****************************************************************************
 * Function Name  : rrmcm_check_meas_req_for_cgi 
 * Inputs         : rrmcm_rmif_cell_son_meas_config_req_t *p_meas_req 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Check that whether Meas request received is for CGI i
 *                : reporting or not. 
 ****************************************************************************/
rrm_return_et
rrmcm_check_meas_req_for_cgi
(
   rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req, 
   rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    rrm_return_et                    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    /* Check for EUTRAN PCIs */
    freq_list = p_meas_config_req->meas_config_req.eutran_config_list_size;
    /* Coverity_fix_start_54995 */ 
    for (freq_list_index = RRM_ZERO; 
            ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT));
            freq_list_index++)
    {
        if(RRM_SON_EUTRAN_CELLS_TO_REPORT_CGI_PRESENT & 
                p_meas_config_req->meas_config_req.eutran_config_list
                [freq_list_index].bitmask)
        {
            /* SPR 16406 Start */
            /* SPR 17845 Fix Start */
            //Code Deleted
            /* SPR 17845 Fix Stop */
            /* SPR 16406 End */
            /* Request came for CGI of the listed PCIs */
            ret_val = RRM_SUCCESS;
            return ret_val;
        }
    }
    /* Coverity_fix_end_54995 */
    /*  for FDD UTRAN PCIs */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        utran_config_list.utran_fdd_list_size;

    /* cov_54995_start */
    for (freq_list_index = RRM_ZERO;
            (freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT);
            freq_list_index++)
        /* cov_54995_end */
    {
        if(RRM_SON_UTRAN_CELLS_TO_REPORT_CGI_PRESENT &
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_fdd_list[freq_list_index].bitmask)
        {
            /* Request came for CGI of the listed PCIs */
            ret_val = RRM_SUCCESS;
            return ret_val;
        }
    }

    /*  for TDD UTRAN PCIs */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        utran_config_list.utran_tdd_list_size;

    for (freq_list_index = 0; (freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT); freq_list_index++)
    {
        if(RRM_SON_UTRAN_TDD_CELLS_TO_REPORT_CGI_PRESENT &
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_tdd_list[freq_list_index].bitmask)
        {
            /* Request came for CGI of the listed PCIs */
            ret_val = RRM_SUCCESS;
            return ret_val;
        }
    }

    /* Check for GERAN PCIs */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        geran_config_list.geran_freq_info_list_size;

    for (freq_list_index = RRM_ZERO; (freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT); freq_list_index++)
    {
        if(RRM_SON_GERAN_CFI_CELLS_TO_REPORT_CGI_PRESENT &
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.geran_freq_info_list[freq_list_index].bitmask)
        {
            /* Request came for CGI of the listed PCIs */
            if(!(RRM_SON_GERAN_CFI_MEAS_OBJ_ID_PRESENT & 
                        p_meas_config_req->meas_config_req.inter_rat_meas_config.
                        geran_config_list.geran_freq_info_list[freq_list_index].bitmask))
            {
                *p_error_code = RRM_ERR_INVALID_PARAMS; 
            }
            ret_val = RRM_SUCCESS;
            return ret_val;
        }
    }
    /* Check for CDMA PCIs */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        cdma_config_list.cdma_freq_info_list_size;

    for (freq_list_index = RRM_ZERO; (freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT); freq_list_index++)
    {
        if(RRM_SON_CDMA_CFI_CELLS_TO_REPORT_CGI_PRESENT &
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_list_index].bitmask)
        {
            /* Request came for CGI of the listed PCIs */
            if(!(RRM_SON_CDMA_CFI_MEAS_OBJ_ID_PRESENT & 
                        p_meas_config_req->meas_config_req.inter_rat_meas_config.
                        cdma_config_list.cdma_freq_info_list[freq_list_index].bitmask))
            {
                *p_error_code = RRM_ERR_INVALID_PARAMS; 
            }
            ret_val = RRM_SUCCESS;
            return ret_val;
        }
    }



    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Fix 8172 Start */
/****************************************************************************
 * Function Name  : rrmcm_validate_utran_mand_params 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  rrmcm_rmif_cell_son_meas_config_req_t *p_meas_req 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Check that whether Meas request received contains 
 *                : mandatory params for Strongest cells reporting or not. 
 ****************************************************************************/
static rrm_return_et
rrmcm_validate_utran_mand_params
(
   rrm_cell_context_t                       *p_cell_ctx,
   rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
)
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* TDD Support SON Start */
    /* If T-Reselection is NOT present in cell ctxt and Meas config req */
    /*spr_22434_changes_start*/
    if(((p_meas_config_req->meas_config_req.inter_rat_meas_config.utran_config_list.
                    utran_fdd_list_size != RRM_ZERO) ||
                (p_meas_config_req->meas_config_req.inter_rat_meas_config.utran_config_list.
                 utran_tdd_list_size != RRM_ZERO)) &&
            !(p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.bitmask & RRM_SON_UTRAN_RESELECTION_PRESENT) &&
            !(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT))
    /*spr_22434_changes_end*/
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Invalid params received as UTRAN T-Reselection value is NOT "
                "configured at RRM and also not provided in Meas Config Req");
    }
    /* TDD Support SON End */                

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Fix 8172 End */

/****************************************************************************
 * Function Name  : rrmcm_validate_geran_mand_params 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  rrmcm_rmif_cell_son_meas_config_req_t *p_meas_req 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Check that whether Meas request received contains 
 *                : mandatory params for Strongest cells reporting or not. 
 ****************************************************************************/
static rrm_return_et
rrmcm_validate_geran_mand_params
(
   rrm_cell_context_t                       *p_cell_ctx,
   rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
)
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    rrm_return_et                    ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* Fix 8172 Start */
    /* If GERAN SF reselection params are present in meas config req */
    /*spr_22434_changes_start*/
    if((p_meas_config_req->meas_config_req.inter_rat_meas_config.geran_config_list.
                geran_freq_info_list_size != RRM_ZERO) &&
            (p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.bitmask & RRM_SON_MC_GERAN_T_RESELECTION_SF_PRESENT) &&
             /* If T-Reselection is NOT present in cell ctxt and Meas config req */
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
              geran_config_list.bitmask & RRM_SON_MC_GERAN_T_RESELECTION_PRESENT) &&
             !(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                 bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT)))
        /*spr_22434_changes_end*/
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "SF Reselection params Invalid as GERAN T-Reselection value is NOT "
                "configured at RRM and also not provided in Meas Config Req");
    }
    else
    {
    /* Fix 8172 Start */
        freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            geran_config_list.geran_freq_info_list_size;
    /* Coverity_fix_start_54995 */
        for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list)&& (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT));
        freq_list_index++)
        {
    /* Coverity_fix_end_54995 */ 
            if(!(RRM_SON_GERAN_CFI_CAR_FREQS_PRESENT &
                        p_meas_config_req->meas_config_req.inter_rat_meas_config.
                        geran_config_list.geran_freq_info_list[freq_list_index].bitmask))
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "geran_car_freqs params Not present for list index : %d", freq_list_index);
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_add_node_in_meas_context_list 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Inputs         : rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
 * Inputs         : U8                                        freq_index 
 * Inputs         : rrm_rat_type_et                           rat_type 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function adds the node in the meas context list. 
 ****************************************************************************/
rrm_return_et
rrmcm_add_node_in_meas_context_list
(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    U8                                        freq_index,
    rrm_rat_type_et                           rat_type,
    /* OFFSET FREQ CHANGES START */
    S8                                        offset_freq,
    S8                                        cell_ctx_index
    /* OFFSET FREQ CHANGES END */
)
{
    rrm_return_et                                ret_value = RRM_SUCCESS;
    meas_eutran_context_list_t       *p_meas_eutran_list = PNULL;
    meas_utran_context_list_t        *p_meas_utran_list = PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_context_list_t    *p_meas_utran_tdd_list = PNULL;
    /* TDD Support SON End */
    meas_geran_context_list_t        *p_meas_geran_list = PNULL;
    meas_cdma_context_list_t        *p_meas_cdma_list = PNULL;
    meas_cdma_node_t                *p_meas_cdma_node = PNULL;
    meas_eutran_node_t               *p_meas_eutran_node = PNULL;
    meas_utran_node_t                *p_meas_utran_node = PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_node_t            *p_meas_utran_tdd_node = PNULL;
    /* TDD Support SON End */
    meas_geran_node_t                *p_meas_geran_node = PNULL;
    RRM_UT_TRACE_ENTER();

    p_meas_eutran_list = &(p_cell_ctx->meas_eutran_list);
    p_meas_utran_list  = &(p_cell_ctx->meas_utran_list);
    /* TDD Support SON Start */
    p_meas_utran_tdd_list  = &(p_cell_ctx->meas_utran_tdd_list);
    /* TDD Support SON End */
    p_meas_geran_list  = &(p_cell_ctx->meas_geran_list);

    p_meas_cdma_list = &(p_cell_ctx->meas_cdma_list);
    if(rat_type == RRM_EUTRAN_CELL)
    {
        /* Get memory to save the received data */
        p_meas_eutran_node =
            (meas_eutran_node_t*)rrm_mem_get(sizeof(meas_eutran_node_t));   

        if (RRM_PNULL == p_meas_eutran_node)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "rrmcm_add_node_in_meas_context_list: Mem allocation fail");
            RRM_UT_TRACE_EXIT();
            ret_value = RRM_FAILURE;        
        }
        else
        {
            p_meas_eutran_node->meas_type = MEAS_TYPE_ANR;
            p_meas_eutran_node->cell_ctx_index = cell_ctx_index;

            /* store the parameters received in config req in the node */
            p_meas_eutran_node->eutran_config.earfcn = 
                p_meas_config_req->meas_config_req.eutran_config_list[freq_index].
                earfcn;
            p_meas_eutran_node->eutran_config.prev_offset_frequency = 
                INVALID_OFFSET_FREQ; 
            /* OFFSET FREQ CHANGES START */
	    /*coverity 29619, typecasted, rel2.0.1*/
            p_meas_eutran_node->eutran_config.offset_frequency = (rrm_q_offsetrange_et)offset_freq;
            /* OFFSET FREQ CHANGES END */

            ylPushTail(p_meas_eutran_list, &(p_meas_eutran_node)->sNode);

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "New node added to eutran list: ARFCN = %d, Offset freq = %d", 
                    p_meas_eutran_node->eutran_config.earfcn, 
                    p_meas_eutran_node->eutran_config.offset_frequency);
        }
    }
    else if (rat_type == RRM_UTRAN_CELL)
    {
        /* Get memory to save the received data */
        p_meas_utran_node =
            (meas_utran_node_t*)rrm_mem_get(sizeof(meas_utran_node_t));   

        if (RRM_PNULL == p_meas_utran_node)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "rrmcm_add_node_in_meas_context_list: Mem allocation fail");
            RRM_UT_TRACE_EXIT();
            ret_value = RRM_FAILURE;
        }
        else
        {
            p_meas_utran_node->meas_type = MEAS_TYPE_ANR;
            p_meas_utran_node->cell_ctx_index = cell_ctx_index;

            /* store the parameters received in config req in the node */
            p_meas_utran_node->utran_config.uarfcn = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_fdd_list[freq_index].uarfcn;
            p_meas_utran_node->utran_config.prev_offset_frequency = 
                INVALID_OFFSET_FREQ; 
            /* OFFSET FREQ CHANGES START */
            p_meas_utran_node->utran_config.offset_frequency = offset_freq; 
            /* OFFSET FREQ CHANGES END */

            ylPushTail( p_meas_utran_list, &(p_meas_utran_node)->sNode );

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "New node added to utran list: ARFCN = %d, Offset freq = %d", 
                    p_meas_utran_node->utran_config.uarfcn, 
                    p_meas_utran_node->utran_config.offset_frequency);
        }     

    }
    /* TDD Support SON Start */
    else if (rat_type == RRM_UTRAN_TDD_CELL)
    {
        /* Get memory to save the received data */
        p_meas_utran_tdd_node =
            (meas_utran_tdd_node_t*)rrm_mem_get(sizeof(meas_utran_tdd_node_t));   

        if (RRM_PNULL == p_meas_utran_tdd_node)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "rrmcm_add_node_in_meas_context_list: Mem allocation fail");
            RRM_UT_TRACE_EXIT();
            ret_value = RRM_FAILURE;
        }
        else
        {
            p_meas_utran_tdd_node->meas_type = MEAS_TYPE_ANR;
            p_meas_utran_tdd_node->cell_ctx_index = cell_ctx_index;

            /* store the parameters received in config req in the node */
            p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_tdd_list[freq_index].uarfcn;
            p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency = 
                INVALID_OFFSET_FREQ; 
            /* OFFSET FREQ CHANGES START */
            p_meas_utran_tdd_node->utran_tdd_config.offset_frequency = offset_freq; 
            /* OFFSET FREQ CHANGES END */

            ylPushTail( p_meas_utran_tdd_list, &(p_meas_utran_tdd_node)->sNode );

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "New node added to utran_tdd list: ARFCN = %d, Offset freq = %d", 
                    p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd, 
                    p_meas_utran_tdd_node->utran_tdd_config.offset_frequency);
        }     

    }
    /* TDD Support SON End */

    else if (rat_type == RRM_GERAN_CELL)
    {
        /* Get memory to save the received data */
        p_meas_geran_node =
            (meas_geran_node_t*)rrm_mem_get(sizeof(meas_geran_node_t));   

        if (RRM_PNULL == p_meas_geran_node)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "rrmcm_add_node_in_meas_context_list: Mem allocation fail");
            RRM_UT_TRACE_EXIT();
            ret_value = RRM_FAILURE;
        }
        else
        {
            p_meas_geran_node->meas_type    = MEAS_TYPE_ANR;
            p_meas_geran_node->cell_ctx_index = cell_ctx_index;

            /* store the parameters received in config req in the node */
            p_meas_geran_node->geran_config.starting_arfcn = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.geran_freq_info_list[freq_index].
                geran_car_freqs.starting_arfcn;

            p_meas_geran_node->geran_config.band_ind = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.geran_freq_info_list[freq_index].
                geran_car_freqs.band_ind;

            p_meas_geran_node->geran_config.prev_offset_frequency = 
                INVALID_OFFSET_FREQ; 
    
            /* OFFSET FREQ CHANGES START */
            p_meas_geran_node->geran_config.offset_frequency = offset_freq;
            /* OFFSET FREQ CHANGES END */

            /* Spr 18401 Changes Start */
            RRM_MEMCPY(&p_meas_geran_node->geran_config.following_arfcns, &p_meas_config_req->meas_config_req.
                       inter_rat_meas_config.geran_config_list.geran_freq_info_list[freq_index].
                       geran_car_freqs.following_arfcns,sizeof(rrm_son_geran_following_arfcns_t));
            /* Spr 18401 Changes End */
            ylPushTail( p_meas_geran_list, &(p_meas_geran_node)->sNode );
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "New node added to geran list: ARFCN = %d, Band Ind = %d Offset freq = %d", 
                    p_meas_geran_node->geran_config.starting_arfcn, 
                    p_meas_geran_node->geran_config.band_ind,
                    p_meas_geran_node->geran_config.offset_frequency);
        }     
    }
    else if (rat_type == RRM_CDMA_CELL)
    {
        /* Get memory to save the received data */
        p_meas_cdma_node =
            (meas_cdma_node_t*)rrm_mem_get(sizeof(meas_cdma_node_t));   

        if (RRM_PNULL == p_meas_cdma_node)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "rrmcm_add_node_in_meas_context_list: Mem allocation fail");
            RRM_UT_TRACE_EXIT();
            ret_value = RRM_FAILURE;
        }
        else
        {
            p_meas_cdma_node->meas_type    = MEAS_TYPE_ANR;
            p_meas_cdma_node->cell_ctx_index = cell_ctx_index;
            /* store the parameters received in config req in the node */
            p_meas_cdma_node->cdma_config.arfcn = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_index].arfcn;

            p_meas_cdma_node->cdma_config.band_class = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_index].band_class;

            p_meas_cdma_node->cdma_config.prev_offset_frequency = 
                INVALID_OFFSET_FREQ; 
            /* OFFSET FREQ CHANGES START */
            p_meas_cdma_node->cdma_config.offset_frequency = offset_freq;
            /* OFFSET FREQ CHANGES START */
/*
            p_meas_cdma_node->cdma_config.offset_frequency = 
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_index].
                offset_freq;
*/
            ylPushTail( p_meas_cdma_list, &(p_meas_cdma_node)->sNode );
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "New node added to CDMA list: ARFCN = %d, Band Class = %d Offset freq = %d", 
                    p_meas_cdma_node->cdma_config.arfcn, 
                    p_meas_cdma_node->cdma_config.band_class,
                    p_meas_cdma_node->cdma_config.offset_frequency);
        }     
    }

    RRM_UT_TRACE_EXIT();
    return ret_value;        
}

/*****************************************************************************
 * Function Name  : rrmcm_eutran_meas_context_key 
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        : arfcn  
 * Description    : This function is the keyof function for the meas_context 
 *                  linked list.
 ****************************************************************************/
static const void * rrmcm_eutran_meas_context_key(
                                                   const YLNODE    *p_ylnode 
                                                 )
{
    return  &(((meas_eutran_node_t *)p_ylnode)->eutran_config.earfcn);
}

/*****************************************************************************
 * Function Name  : rrmcm_utran_meas_context_key 
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        : arfcn  
 * Description    : This function is the keyof function for the meas_context 
 *                  linked list.
 ****************************************************************************/
static const void * rrmcm_utran_meas_context_key(
                                                  const YLNODE    *p_ylnode 
                                                 )
{
    return  &(((meas_utran_node_t *)p_ylnode)->utran_config.uarfcn);
}

/* TDD Support SON Start */
/*****************************************************************************
 * Function Name  : rrmcm_utran_tdd_meas_context_key 
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        : arfcn  
 * Description    : This function is the keyof function for the meas_context 
 *                  linked list.
 ****************************************************************************/
static const void * rrmcm_utran_tdd_meas_context_key(
                                                  const YLNODE    *p_ylnode 
                                                 )
{
    return  &(((meas_utran_tdd_node_t *)p_ylnode)->utran_tdd_config.uarfcn_tdd);
}
/* TDD Support SON End */

/*****************************************************************************
 * Function Name  : rrmcm_data_compare 
 * Inputs         : p_key1 - Pointer to the data1 to be compaired
 *                  p_key2 - Pointer to the data2 to be compaired
 * Outputs        : None
 * Returns        : 0 if data1 is same as data2
 *                  1 if data1 is not same as data2
 * Description    : This function compares the key passed to retrieve correct
 *                  node from linked list.
 ****************************************************************************/
static int rrmcm_data_compare 
(
 const void *p_key1,
 const void *p_key2
 )
{
    if (*(U16*)p_key1 == *(U16*)p_key2)
    {
        return (RRM_FAILURE);
    }
    else
    {
        return (RRM_SUCCESS);
    }
}

/****************************************************************************
 * Function Name  : rrmcm_find_utran_meas_context 
 * Inputs         : U16                   arfcn 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : ARFCN - Node
 * Description    : This function returns the meas context node from the utran
 *                : link list against the arfcn provided. 
 ****************************************************************************/
meas_utran_node_t *
rrmcm_find_utran_meas_context
(
    U16                   arfcn,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
)
{
    meas_utran_context_list_t        *p_meas_utran_list = PNULL;
    meas_utran_node_t                *p_meas_utran_node = PNULL;

    /* CSR00069389 Start */
    RRM_UT_TRACE_ENTER();
    /* CSR00069389 End */
    p_meas_utran_list  = &(p_cell_ctx->meas_utran_list);
    
    p_meas_utran_node =  (meas_utran_node_t *)
                              ylFind(p_meas_utran_list,
                                  &arfcn,
                                  rrmcm_utran_meas_context_key,
                                  rrmcm_data_compare);

    /* CSR00069389 Start */
    RRM_UT_TRACE_EXIT();
    /* CSR00069389 End */
    return p_meas_utran_node;                              
}

/* TDD Support SON Start */
/****************************************************************************
 * Function Name  : rrmcm_find_utran_tdd_meas_context 
 * Inputs         : U16                   arfcn 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : ARFCN - Node
 * Description    : This function returns the meas context node from the utran_tdd
 *                : link list against the arfcn provided. 
 ****************************************************************************/
meas_utran_tdd_node_t *
rrmcm_find_utran_tdd_meas_context
(
    U16                   arfcn,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
)
{
    meas_utran_tdd_context_list_t        *p_meas_utran_tdd_list = PNULL;
    meas_utran_tdd_node_t                *p_meas_utran_tdd_node = PNULL;

    /* CSR00069389 Start */
    RRM_UT_TRACE_ENTER();
    /* CSR00069389 End */
    p_meas_utran_tdd_list  = &(p_cell_ctx->meas_utran_tdd_list);
    
    p_meas_utran_tdd_node =  (meas_utran_tdd_node_t *)
                              ylFind(p_meas_utran_tdd_list,
                                  &arfcn,
                                  rrmcm_utran_tdd_meas_context_key,
                                  rrmcm_data_compare);

    /* CSR00069389 Start */
    RRM_UT_TRACE_EXIT();
    /* CSR00069389 End */
    return p_meas_utran_tdd_node;                              
}
/* TDD Support SON End */

/****************************************************************************
 * Function Name  : rrmcm_find_eutran_meas_context 
 * Inputs         : U16                   arfcn 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : ARFCN - Node
 * Description    : This function returns the meas context node from the eutran
 *                : link list against the arfcn provided. 
 ****************************************************************************/
meas_eutran_node_t *
rrmcm_find_eutran_meas_context
(
    U16                   arfcn,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
)
{
    meas_eutran_context_list_t       *p_meas_eutran_list = PNULL;
    meas_eutran_node_t               *p_meas_eutran_node = PNULL;

    /* CSR00069389 Start */
    RRM_UT_TRACE_ENTER();
    /* CSR00069389 End */

    p_meas_eutran_list = &(p_cell_ctx->meas_eutran_list);
    
    p_meas_eutran_node = (meas_eutran_node_t *)
                              ylFind(p_meas_eutran_list,
                                  &arfcn,
                                  rrmcm_eutran_meas_context_key,
                                  rrmcm_data_compare);

    /* CSR00069389 Start */
    RRM_UT_TRACE_EXIT();
    /* CSR00069389 End */
    return p_meas_eutran_node;                              
}

/****************************************************************************
 * Function Name  : rrmcm_find_geran_meas_context 
 * Inputs         : U16                   arfcn 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : ARFCN - Node
 * Description    : This function returns the meas context node from the geran
 *                : link list against the arfcn provided. 
 ****************************************************************************/
meas_geran_node_t *
rrmcm_find_geran_meas_context
(
    U16                   arfcn,
    rrm_son_geran_band_indicator_et     band_ind,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
)
{
    meas_geran_context_list_t       *p_meas_geran_list = RRM_PNULL;
    meas_geran_node_t               *p_meas_geran_node = RRM_PNULL;
    YLNODE                          *p_node            = RRM_PNULL;
    U8                              index               = RRM_NULL;

    /* CSR00069389 Start */
    RRM_UT_TRACE_ENTER();
    /* CSR00069389 End */
    p_meas_geran_list = &(p_cell_ctx->meas_geran_list);
    
    p_node = rrm_get_first_list_node(p_meas_geran_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_geran_node =  YMEMBEROF(meas_geran_node_t, sNode, p_node);
        /* Spr 18401 Changes Start */
        if(band_ind == p_meas_geran_node->geran_config.band_ind)
        {
            if(RRM_TRUE == check_geran_carrier_freq(
                                     p_meas_geran_node->geran_config.following_arfcns,
                                     p_meas_geran_node->geran_config.starting_arfcn,
                                     arfcn))
        {
            break;

        }
        }
        /* Spr 18401 Changes End */
        p_node = rrm_get_next_list_node(p_node);
    }

    if(RRM_PNULL == p_node)
    {
        p_meas_geran_node = RRM_PNULL;
    }
    /* CSR00069389 Start */
    RRM_UT_TRACE_EXIT();
    /* CSR00069389 End */
    return p_meas_geran_node;                              
}


/***************************************************************************** 
 *
 * Function Name  : rrmcm_find_cdma_meas_context 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : ARFCN - Node
 * Description    : This function returns the meas context node from the geran
 *                : link list against the arfcn provided. 
 ****************************************************************************/
meas_cdma_node_t *
rrmcm_find_cdma_meas_context
(
    U16                   arfcn,
    rrm_son_cdma_band_class_et              band_class,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
)
{
    meas_cdma_context_list_t       *p_meas_cdma_list    = RRM_PNULL;
    meas_cdma_node_t               *p_meas_cdma_node    = RRM_PNULL;
    YLNODE                          *p_node             = RRM_PNULL;
    U8                              index               = RRM_NULL;

    /* CSR00069389 Start */
    RRM_UT_TRACE_ENTER();
    /* CSR00069389 End */
    p_meas_cdma_list = &(p_cell_ctx->meas_cdma_list);
    
    p_node = rrm_get_first_list_node(p_meas_cdma_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_cdma_node =  YMEMBEROF(meas_cdma_node_t, sNode, p_node);
        if((arfcn == p_meas_cdma_node->cdma_config.arfcn) &&
            (band_class == p_meas_cdma_node->cdma_config.band_class))
        {
            break;
        }
        p_node = rrm_get_next_list_node(p_node);
    }

    if(RRM_PNULL == p_node)
    {
        p_meas_cdma_node = RRM_PNULL;
    }
    /* CSR00069389 Start */
    RRM_UT_TRACE_EXIT();
    /* CSR00069389 End */
    return p_meas_cdma_node;                              
}



/* MEAS CONFIG REL1.2: START*/

/****************************************************************************
* Function Name  : rrmcm_check_cell_state_validity 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U16 *p_error_code : error code in case of failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : If reconfig is reqd due to the Meas Config Req recvd from 
*          SON, this function checks if Cell is in a valid state to
*          trigger reconfig or not.
****************************************************************************/
static rrm_return_et
rrmcm_check_cell_state_validity(
    rrm_cell_context_t                       *p_cell_ctx,
    rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    rrm_return_et                    ret_val        = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    switch(p_cell_ctx->cell_state)
    {
        case CELL_STATE_W_FOR_CELL_RECONFIG_RESP:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_RECONFIG_RESP");
            *p_error_code = RRM_ERR_CELL_RECONFIG_ONGOING;
            break;

        case CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_RECONFIG_RESP:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_RECONFIG_RESP");
            *p_error_code = RRM_ERR_CELL_RECONFIG_ONGOING;
            break;

        case CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP");
            *p_error_code = RRM_ERR_CELL_STOP_ONGOING;
            break;

        case CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_START_RESP:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_START_RESP");
            *p_error_code = RRM_ERR_CELL_START_ONGOING;
            break;

        case CELL_STATE_W_FOR_CELL_DEL:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_DEL");
            *p_error_code = RRM_ERR_CELL_DELETION_ONGOING;
            break;

        case CELL_STATE_W_FOR_CELL_STOP_RESP:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_STOP_RESP");
            *p_error_code = RRM_ERR_CELL_STOP_ONGOING;
            break;

        /* Start CSR 00064477 */
        case CELL_STATE_W_FOR_CELL_START_RESP:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_START_RESP");
            *p_error_code = RRM_ERR_CELL_START_ONGOING;
            break;
        /* End CSR 00064477 */

        case CELL_STATE_OUT_OF_SERVICE:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_OUT_OF_SERVICE");
            *p_error_code = RRM_ERR_CELL_UNOPERATIONAL;
            break;

        case CELL_STATE_INACTIVE:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_INACTIVE");
            *p_error_code = RRM_ERR_CELL_UNOPERATIONAL;
            break;

        case CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_NRT:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell state = CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_NRT");
            *p_error_code = RRM_ERR_CELL_RECONFIG_ONGOING;
            break;

        default:
            ret_val = RRM_SUCCESS;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Cell is in a valid state = %d to trigger reconfig",
                p_cell_ctx->cell_state);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
* Function Name  :rrmcm_allocate_mem_and_init_meas_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : 
****************************************************************************/
rrm_return_et
rrmcm_allocate_mem_and_init_meas_reconfig_struct(
    rrm_cell_context_t              *p_cell_ctx
    )
{
    U8                    loop = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_cell_ctx->p_meas_config_sib_info_for_reconfig = 
        rrm_mem_get(sizeof(rrmcm_meas_config_sib_info_for_reconfig_t));
    if (RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Mem allocation to p_cell_ctx->p_meas_config_sib_info_for_reconfig failed");
        RRM_UT_TRACE_EXIT(); 
        return RRM_FAILURE;
    }
    else 
    {
        RRM_ASSERT(RRM_PNULL != p_cell_ctx->p_meas_config_sib_info_for_reconfig);

        RRM_MEMSET(p_cell_ctx->p_meas_config_sib_info_for_reconfig, RRM_NULL,
                sizeof(rrmcm_meas_config_sib_info_for_reconfig_t));

        for (loop = RRM_ZERO; loop < MAX_NO_INTER_FREQ; loop++)
        {
           p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
                     offset_freq[loop] = INVALID_OFFSET_FREQ;    
        }
        for (loop = RRM_ZERO; loop < RRM_MAX_NUM_UTRA_FDD_CARRIERS; loop++)
        {
           p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                     offset_freq[loop] = INVALID_OFFSET_FREQ;    
        }
        for (loop = RRM_ZERO; loop < MAX_NO_GERAN_FREQ_GROUUP; loop++)
        {
           p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
                     offset_freq[loop] = INVALID_OFFSET_FREQ;    
        }

        for (loop = RRM_ZERO; loop < MAX_NO_CDMA_FREQ_GROUUP; loop++)
        {
           p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
                     offset_freq[loop] = INVALID_OFFSET_FREQ;    
        }
    }
    RRM_UT_TRACE_EXIT();        
    return RRM_SUCCESS;
}

/****************************************************************************
* Function Name  : rrmcm_search_earfcn_in_cell_context
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*                  U16            earfcn
* Outputs        : None
* Returns        : Index of the earfcn in cell context list
* Description    : This function searches the earfcn in the freqs configured 
*          at RRM and returns the index if found and -1 if not found
****************************************************************************/
S16
rrmcm_search_earfcn_in_cell_context(
    rrm_cell_context_t              *p_cell_ctx, 
    U32                             earfcn
    )
{
    U8  list_size = RRM_NULL;
    U8  index     = RRM_ZERO;
    S16 ret_val   = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    list_size = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        num_valid_inter_freq_list;

    for(index = RRM_ZERO; index < list_size; index++)
    {
        if(earfcn == p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[index].
            eutra_carrier_arfcn)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "EARFCN %d found in idle_mode_mobility_inter_freq_params list at "
                "index = %d", earfcn, index);
            ret_val = index;
            break;
        }
    }
    if(FREQ_NOT_CONFIGURED == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "EARFCN %d NOT found in idle_mode_mobility_inter_freq_params list", earfcn);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
* Function Name  : rrmcm_search_uarfcn_fdd_in_cell_context
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*                  U16            uarfcn
* Outputs        : None
* Returns        : Index of the uarfcn in cell context list
* Description    : This function searches the uarfcn in the freqs configured 
*                  at RRM and returns the index if found and -1 if not found
****************************************************************************/
S16
rrmcm_search_uarfcn_fdd_in_cell_context(
    rrm_cell_context_t              *p_cell_ctx, 
    U16                             uarfcn
    )
{
    U8  list_size = RRM_NULL;
    U8  index     = RRM_NULL;
    S16 ret_val   = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    list_size = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
        num_irat_eutran_to_utran_fdd_carriers;

    for(index = RRM_NULL; index < list_size; index++)
    {
        if(uarfcn == p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            utra_carrier_arfcn)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "FDD UARFCN %d found in irat_eutran_to_utran_fdd_carriers list at "
                "index = %d", uarfcn, index);
            ret_val = index;
            break;
        }
    }
    if(FREQ_NOT_CONFIGURED == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "FDD UARFCN %d NOT found in irat_eutran_to_utran_fdd_carriers list", uarfcn);
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* TDD Support SON Start */
/****************************************************************************
* Function Name  : rrmcm_search_uarfcn_tdd_in_cell_context
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*                  U16            uarfcn_tdd
* Outputs        : None
* Returns        : Index of the uarfcn_tdd in cell context list
* Description    : This function searches the uarfcn_tdd in the freqs configured 
*                  at RRM and returns the index if found and -1 if not found
****************************************************************************/
S16
rrmcm_search_uarfcn_tdd_in_cell_context(
    rrm_cell_context_t              *p_cell_ctx, 
    U16                             uarfcn_tdd
    )
{
    U8  list_size = RRM_NULL;
    U8  index     = RRM_NULL;
    S16 ret_val   = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    list_size = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
        num_irat_eutran_to_utran_tdd_carriers;

    for(index = RRM_NULL; index < list_size; index++)
    {
        if(uarfcn_tdd == p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            utra_carrier_arfcn)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "TDD UARFCN %d found in irat_eutran_to_utran_tdd_carriers list at "
                "index = %d", uarfcn_tdd, index);
            ret_val = index;
            break;
        }
    }
    if(FREQ_NOT_CONFIGURED == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "TDD UARFCN %d NOT found in irat_eutran_to_utran_tdd_carriers list", uarfcn_tdd);
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TDD Support SON End */


/****************************************************************************
* Function Name  : rrmcm_search_geran_arfcn_in_cell_context
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U16            geran_arfcn
* Outputs        : None
* Returns        : Index of the geran arfcn in cell context list
* Description    : This function searches the geran arfcn in the freqs configured 
*          at RRM and returns the index if found and -1 of not found
****************************************************************************/
S16
rrmcm_search_geran_arfcn_in_cell_context(
    rrm_cell_context_t              *p_cell_ctx, 
    U16                             geran_arfcn,
    rrm_son_geran_band_indicator_et band_ind
    )
{
    U8  list_size = RRM_NULL;
    U8  index     = RRM_NULL;
    S16 ret_val   = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    list_size = p_cell_ctx->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
        num_irat_eutran_to_geran_carriers;

    for(index = RRM_NULL; index < list_size; index++)
    {
        if((geran_arfcn == p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
            irat_eutran_to_geran_carriers[index].geran_car_freqs.starting_arfcn)
            && (band_ind == p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                irat_eutran_to_geran_carriers[index].geran_car_freqs.band_ind))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Geran ARFCN %d Band Ind = %d found in irat_eutran_to_geran_carriers list at "
                "index = %d", geran_arfcn, band_ind, index);
            ret_val = index;
            break;
        }
    }
    if(FREQ_NOT_CONFIGURED == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Geran ARFCN %d NOT found in irat_eutran_to_geran_carriers list", geran_arfcn);
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * * Function Name  : fill_band_class_index_for_hrpd_cdma_type 
 * * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * *                : U8   band_class
 * *                : U8   cdma_type
 * *                : S8   *band_class_index
 * * Outputs        : None
 * * Returns        : Index of the geran arfcn in cell context list
 * * Description    : This function searches the cdma arfcn in the freqs configured
 * *          at RRM and returns the index if found and -1 of not found
 * ****************************************************************************/

/*klock_works_changes_start*/

rrm_void_t
fill_band_class_index_for_hrpd_cdma_type(
        rrm_cell_context_t              *p_cell_ctx,
        U8                              band_class,
        U8                              cdma_type,
        S8                              *band_class_index
        )
{
    U8                      hrpd_band_class_size = RRM_NULL;
    U8  index     = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    if(cdma_type == R_TYPE_HRPD)
    {
        hrpd_band_class_size = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
            cdma_params.idle_mode_mobility_irat_cdma_params.
            cell_reselection_params_hrpd.band_class_list.count;
        for(index = RRM_NULL; (index < hrpd_band_class_size) &&
                ( index  < RRMCM_RMIF_MAX_CDMA_BAND_CLASS) ; index++)
        {
            if(band_class == p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                    cdma_params.idle_mode_mobility_irat_cdma_params.
                    cell_reselection_params_hrpd.band_class_list.
                    band_class_info_cdma2000[index].band_class)
            {
                *band_class_index = index;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "cdma Band class for HRPD %d found at index %d in list", band_class,index);
                break;
            }
        }
    }

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * * Function Name  : fill_band_class_index_for_1x_rtt_cdma_type
 * * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * *                : U8   band_class
 * *                : U8   cdma_type
 * *                : S8   *band_class_index
 * * Outputs        : None
 * * Returns        : Index of the geran arfcn in cell context list
 * * Description    : This function searches the cdma arfcn in the freqs configured
 * *          at RRM and returns the index if found and -1 of not found
 * ****************************************************************************/

rrm_void_t
fill_band_class_index_for_1x_rtt_cdma_type
(
 rrm_cell_context_t              *p_cell_ctx,
 U8                              band_class,
 U8                              cdma_type,
 S8                              *band_class_index
 )
{
    U8  xrtt_band_class_size = RRM_NULL;
    U8  index     = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    if(cdma_type == R_TYPE_1X_RTT)
       {
           xrtt_band_class_size = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
               cdma_params.idle_mode_mobility_irat_cdma_params.
               cell_reselection_params_1xrtt.band_class_list.count;
           for(index = RRM_NULL; (index < xrtt_band_class_size) && 
                     ( index < RRMCM_RMIF_MAX_CDMA_BAND_CLASS); index++)
           {
               if(band_class == p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                       cdma_params.idle_mode_mobility_irat_cdma_params.
                       cell_reselection_params_1xrtt.band_class_list.
                       band_class_info_cdma2000[index].band_class)
               {
                   *band_class_index = index;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "cdma Band class for XRTT %d found at index %d in list", band_class,index);
                  break;
               }
           }
       }
     
   RRM_UT_TRACE_EXIT();

}
/*klock_works_changes_end*/



/****************************************************************************
 * * Function Name  : rrmcm_search_cdma_arfcn_in_cell_context
 * * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * *          U16            cdma_arfcn
 * * Outputs        : None
 * * Returns        : Index of the geran arfcn in cell context list
 * * Description    : This function searches the cdma arfcn in the freqs configured
 * *          at RRM and returns the index if found and -1 of not found
 * ****************************************************************************/
S16
rrmcm_search_cdma_arfcn_in_cell_context(
    rrm_cell_context_t              *p_cell_ctx, 
    U16                             cdma_arfcn,
    U8                              band_class,
    U8                              cdma_type,
    S8                           *band_class_index
    )
{
    U8  list_size = RRM_NULL;
 
    U8  index     = RRM_NULL;
    S16 ret_val   = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    list_size = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                cdma_params.num_valid_cdma2000_freq_cells;

    /*klock_works_changes_start*/

    fill_band_class_index_for_hrpd_cdma_type(p_cell_ctx, band_class, cdma_type, band_class_index);

    fill_band_class_index_for_1x_rtt_cdma_type(p_cell_ctx, band_class, cdma_type, band_class_index);

    /*klock_works_changes_end*/

/* Coverity 19oct Start : 54931 */
       if(*band_class_index != BAND_NOT_CONFIGURED)
/* Coverity 19oct End : 54931 */
       {
           for(index = RRM_NULL; index < list_size; index++)
           {
               if((cdma_arfcn == p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
                           cdma2000_freq_cells[index].arfcn) &&
                  (band_class == p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
                                               cdma2000_freq_cells[index].band_class))
               {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "CDMA ARFCN %d Band class = %d found in list at "
                        "index = %d", cdma_arfcn, band_class, index);
                    ret_val = index;
 
                    break;
               }
           }
       }

    
    if(FREQ_NOT_CONFIGURED == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "cdma ARFCN %d NOT found in list", cdma_arfcn);
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


S16
rrmcm_search_cdma_arfcn_in_cell_context_in_ncl_params(
    rrm_cell_context_t              *p_cell_ctx, 
    U16                             cdma_arfcn,
    U8                              band_class
    )
{
    U8  list_size = RRM_NULL;
 
    U8  index     = RRM_NULL;
    S16 ret_val   = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    list_size = p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_cdma2000_freq_cells;
 
          for(index = RRM_NULL; index < list_size; index++)
           {
               if((cdma_arfcn == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                           cdma2000_freq_cells[index].arfcn) &&
                  (band_class == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                                               cdma2000_freq_cells[index].band_class))
               {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "CDMA ARFCN %d Band class = %d found in list at "
                        "index = %d", cdma_arfcn, band_class, index);
                    ret_val = index;
 
                    break;
               }
           }
       

    
    if(FREQ_NOT_CONFIGURED == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "cdma ARFCN %d NOT found in list", cdma_arfcn);
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}






/****************************************************************************
* Function Name  : rrmcm_restore_meas_eutran_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : None
* Description    : This function restores the previous values of the data in
*          EUTRAN object nodes for the frequencies received in Meas 
*          Config Req, if the Meas Config Req fails due to 
*          validation fail or some other reason
****************************************************************************/
static rrm_void_t
rrmcm_restore_meas_eutran_list(
        rrm_cell_context_t                      *p_cell_ctx,                
        rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
        )
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    meas_eutran_context_list_t       *p_meas_eutran_list = RRM_PNULL;
    meas_eutran_node_t               *p_meas_eutran_node = RRM_PNULL;
    
    RRM_UT_TRACE_ENTER();

    /* Update EUTRAN nodes */
    freq_list = p_meas_config_req->meas_config_req.eutran_config_list_size;

    /* Coverity 54995 Fix Start */
    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) &&
                (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
        /* Coverity 54995 Fix End */
    {
        p_meas_eutran_node = rrmcm_find_eutran_meas_context(
                p_meas_config_req->meas_config_req.eutran_config_list
                [freq_list_index].earfcn, p_cell_ctx);
        if(RRM_PNULL != p_meas_eutran_node)
        {
            if(p_meas_eutran_node->eutran_config.prev_offset_frequency == INVALID_OFFSET_FREQ)
            {
                /* Delete Node */ 
                p_meas_eutran_list = &(p_cell_ctx->meas_eutran_list);
                rrm_list_delete_node(p_meas_eutran_list, (YLNODE*)p_meas_eutran_node);
                RRM_MEM_FREE(p_meas_eutran_node);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Node Deleted for EUTRAN freq = %d", p_meas_config_req->
                        meas_config_req.eutran_config_list[freq_list_index].earfcn);
            }
            else if(p_meas_eutran_node->eutran_config.prev_offset_frequency !=
                (S16)(p_meas_eutran_node->eutran_config.offset_frequency))
            {
                /* OFFSET FREQ CHANGES START */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Restoring offset freq value for EUTRAN arfcn = %d from %d to %d",
                        p_meas_eutran_node->eutran_config.earfcn,
                        p_meas_eutran_node->eutran_config.offset_frequency,
                        p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_freq_params
                        [p_meas_eutran_node->cell_ctx_index].cm_offset_freq);
		/*coverity 29618, rel2.0.1, */
                p_meas_eutran_node->eutran_config.offset_frequency =(rrm_q_offsetrange_et) 
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_freq_params
                    [p_meas_eutran_node->cell_ctx_index].cm_offset_freq;
                /* OFFSET FREQ CHANGES END */
                p_meas_eutran_node->eutran_config.prev_offset_frequency = INVALID_OFFSET_FREQ;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_restore_meas_utran_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : None
* Description    : This function restores the previous values of the data in
*          FDD UTRAN object nodes for the frequencies received in Meas 
*          Config Req, if the Meas Config Req fails due to 
*          validation fail or some other reason
****************************************************************************/
static rrm_void_t
rrmcm_restore_meas_utran_list(
        rrm_cell_context_t                       *p_cell_ctx,                
        rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
        )
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    meas_utran_context_list_t       *p_meas_utran_list  = RRM_PNULL;
    meas_utran_node_t                *p_meas_utran_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* Update UTRAN nodes */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   utran_config_list.utran_fdd_list_size;

    /* Coverity 54995 Fix Start */
    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) && (
                    freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
        /* Coverity 54995 Fix End */
    {
        p_meas_utran_node = rrmcm_find_utran_meas_context(
           p_meas_config_req->meas_config_req.inter_rat_meas_config.utran_config_list.
           utran_fdd_list[freq_list_index].uarfcn, p_cell_ctx);
        if(RRM_PNULL != p_meas_utran_node)
        {
            if(p_meas_utran_node->utran_config.prev_offset_frequency == INVALID_OFFSET_FREQ)
            {
                /* Delete Node */ 
                p_meas_utran_list  = &(p_cell_ctx->meas_utran_list);
                rrm_list_delete_node(p_meas_utran_list, (YLNODE*)p_meas_utran_node);
                RRM_MEM_FREE(p_meas_utran_node);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Node Deleted for FDD UTRAN freq = %d", p_meas_config_req->
                        meas_config_req.inter_rat_meas_config.utran_config_list.
                        utran_fdd_list[freq_list_index].uarfcn);
            }
            else if(p_meas_utran_node->utran_config.prev_offset_frequency !=
                p_meas_utran_node->utran_config.offset_frequency)
            {
                /* OFFSET FREQ CHANGES START */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Restoring offset freq value for FDD UTRAN arfcn = %d from %d to %d",
                    p_meas_utran_node->utran_config.uarfcn,
                    p_meas_utran_node->utran_config.offset_frequency,
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[p_meas_utran_node->cell_ctx_index].offset_freq);

                p_meas_utran_node->utran_config.offset_frequency = 
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[p_meas_utran_node->cell_ctx_index].offset_freq;
                /* OFFSET FREQ CHANGES END */
                p_meas_utran_node->utran_config.prev_offset_frequency = INVALID_OFFSET_FREQ;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/* TDD Support SON Start */
/****************************************************************************
* Function Name  : rrmcm_restore_meas_utran_tdd_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : None
* Description    : This function restores the previous values of the data in
*          TDD UTRAN object nodes for the frequencies received in Meas 
*          Config Req, if the Meas Config Req fails due to 
*          validation fail or some other reason
****************************************************************************/
static rrm_void_t
rrmcm_restore_meas_utran_tdd_list(
        rrm_cell_context_t                       *p_cell_ctx,                
        rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
        )
{
    U8                               freq_list = 0;
    U8                               freq_list_index = 0;
    meas_utran_tdd_context_list_t       *p_meas_utran_tdd_list  = RRM_PNULL;
    meas_utran_tdd_node_t                *p_meas_utran_tdd_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* Update UTRAN nodes */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   utran_config_list.utran_tdd_list_size;

    /* Coverity 54995 Fix Start */

    for (freq_list_index = 0; ((freq_list_index < freq_list) && (freq_list_index
                    < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
        /* Coverity 54995 Fix End */
    {
        p_meas_utran_tdd_node = rrmcm_find_utran_tdd_meas_context(
           p_meas_config_req->meas_config_req.inter_rat_meas_config.utran_config_list.
           utran_tdd_list[freq_list_index].uarfcn, p_cell_ctx);
        if(RRM_PNULL != p_meas_utran_tdd_node)
        {
            if(p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency == INVALID_OFFSET_FREQ)
            {
                /* Delete Node */ 
                p_meas_utran_tdd_list  = &(p_cell_ctx->meas_utran_tdd_list);
                rrm_list_delete_node(p_meas_utran_tdd_list, (YLNODE*)p_meas_utran_tdd_node);
                RRM_MEM_FREE(p_meas_utran_tdd_node);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Node Deleted for TDD UTRAN freq = %d", p_meas_config_req->
                        meas_config_req.inter_rat_meas_config.utran_config_list.
                        utran_tdd_list[freq_list_index].uarfcn);
            }
            else if(p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency !=
                p_meas_utran_tdd_node->utran_tdd_config.offset_frequency)
            {
                /* OFFSET FREQ CHANGES START */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Restoring offset freq value for TDD UTRAN arfcn = %d from %d to %d",
                    p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd,
                    p_meas_utran_tdd_node->utran_tdd_config.offset_frequency,
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[p_meas_utran_tdd_node->cell_ctx_index].offset_freq);

                p_meas_utran_tdd_node->utran_tdd_config.offset_frequency = 
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[p_meas_utran_tdd_node->cell_ctx_index].offset_freq;
                /* OFFSET FREQ CHANGES END */
                p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency = INVALID_OFFSET_FREQ;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* TDD Support SON End */


/****************************************************************************
* Function Name  : rrmcm_restore_meas_geran_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : None
* Description    : This function restores the previous values of the data in
*          GERAN object nodes for the frequencies received in Meas 
*          Config Req, if the Meas Config Req fails due to 
*          validation fail or some other reason
****************************************************************************/
static rrm_void_t
rrmcm_restore_meas_geran_list(
        rrm_cell_context_t                      *p_cell_ctx,                
        rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
        )
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    meas_geran_context_list_t        *p_meas_geran_list = RRM_PNULL;
    meas_geran_node_t                *p_meas_geran_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* Update GERAN nodes */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   geran_config_list.geran_freq_info_list_size;

    /* Coverity 54995 Fix Start */

    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) &&
                (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
        /* Coverity 54995 Fix End */
    {
        p_meas_geran_node = rrmcm_find_geran_meas_context(
           p_meas_config_req->meas_config_req.inter_rat_meas_config.geran_config_list.
           geran_freq_info_list[freq_list_index].geran_car_freqs.starting_arfcn, 
            p_meas_config_req->meas_config_req.inter_rat_meas_config.geran_config_list.
           geran_freq_info_list[freq_list_index].geran_car_freqs.band_ind, p_cell_ctx);
        if(RRM_PNULL != p_meas_geran_node)
        {
            if(p_meas_geran_node->geran_config.prev_offset_frequency == INVALID_OFFSET_FREQ)
            {
                /* Delete Node */ 
                p_meas_geran_list = &(p_cell_ctx->meas_geran_list);
                rrm_list_delete_node(p_meas_geran_list, (YLNODE*)p_meas_geran_node);
                RRM_MEM_FREE(p_meas_geran_node);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Node Deleted for GERAN freq = %d", p_meas_config_req->
                        meas_config_req.inter_rat_meas_config.geran_config_list.
                        geran_freq_info_list[freq_list_index].geran_car_freqs.starting_arfcn);
            }
            else if(p_meas_geran_node->geran_config.prev_offset_frequency != 
                p_meas_geran_node->geran_config.offset_frequency)
            {
                /* OFFSET FREQ CHANGES START */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Restoring offset freq value for GERAN arfcn = %d from %d to %d",
                    p_meas_geran_node->geran_config.starting_arfcn,
                    p_meas_geran_node->geran_config.offset_frequency,
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].offset_freq);
 
                p_meas_geran_node->geran_config.offset_frequency = 
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[p_meas_geran_node->cell_ctx_index].offset_freq;
                /* OFFSET FREQ CHANGES END */

                p_meas_geran_node->geran_config.prev_offset_frequency = INVALID_OFFSET_FREQ;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_restore_meas_cdma_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : None
* Description    : This function restores the previous values of the data in
*          CDMA object nodes for the frequencies received in Meas 
*          Config Req, if the Meas Config Req fails due to 
*          validation fail or some other reason
****************************************************************************/
static rrm_void_t
rrmcm_restore_meas_cdma_list(
        rrm_cell_context_t                      *p_cell_ctx,                
        rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req 
        )
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    meas_cdma_context_list_t        *p_meas_cdma_list = RRM_PNULL;
    meas_cdma_node_t                *p_meas_cdma_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* Update GERAN nodes */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   cdma_config_list.cdma_freq_info_list_size;

    /* Coverity 54995 Fix Start */
    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) &&
                (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
        /* Coverity 54995 Fix End */
    {
        p_meas_cdma_node = rrmcm_find_cdma_meas_context(
           p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
           cdma_freq_info_list[freq_list_index].arfcn, 
           p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
           cdma_freq_info_list[freq_list_index].band_class, p_cell_ctx);
        if(RRM_PNULL != p_meas_cdma_node)
        {
            if(p_meas_cdma_node->cdma_config.prev_offset_frequency == INVALID_OFFSET_FREQ)
            {
                /* Delete Node */ 
                p_meas_cdma_list = &(p_cell_ctx->meas_cdma_list);
                rrm_list_delete_node(p_meas_cdma_list, (YLNODE*)p_meas_cdma_node);
                RRM_MEM_FREE(p_meas_cdma_node);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Node Deleted for CDMA, band class = %d, freq = %d", 
                        p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
                        cdma_freq_info_list[freq_list_index].band_class,
                        p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
                        cdma_freq_info_list[freq_list_index].arfcn);
            }
            else if(p_meas_cdma_node->cdma_config.prev_offset_frequency != 
                p_meas_cdma_node->cdma_config.offset_frequency)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Restoring offset freq value for CDMA band_class = %d,arfcn = %d from %d to %d",
                    p_meas_cdma_node->cdma_config.band_class,
                    p_meas_cdma_node->cdma_config.arfcn,
                    p_meas_cdma_node->cdma_config.prev_offset_frequency,
                    p_meas_cdma_node->cdma_config.offset_frequency);
 
                p_meas_cdma_node->cdma_config.offset_frequency = 
                    p_meas_cdma_node->cdma_config.prev_offset_frequency;
                p_meas_cdma_node->cdma_config.prev_offset_frequency = INVALID_OFFSET_FREQ;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

 /*Klockwork_fix_start*/
 /****************************************************************************
 * Function Name  : rrmcm_compare_son_eutran_q_rx
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
 *          Meas Config Req received from SON
 *          U8 meas_req_index: index of the serving cell freq to be
 *          processed, in Meas Config Req Eutran list
 * Outputs        : None
 * Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
 *                  param values are same
 * Description    : This function compares the serving cell params configured
 *          at RRM with those received in Meas Config Req.
 ****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_q_rx(intra_freq_params_t          *p_cell_ctx_params,
                              rrm_son_meas_config_eutran_t *p_meas_config_req_params)
{
    rrm_bool_et      params_differ   = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
    if(p_meas_config_req_params->bitmask & RRM_SON_EUTRAN_Q_RX_LEV_MIN_PRESENT)
    {
        if(p_meas_config_req_params->q_rx_lev_min
                != p_cell_ctx_params->q_rx_lev_min_sib_3)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "q_rx_lev_min_sib_3 differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    if(p_meas_config_req_params->bitmask & RRM_SON_EUTRAN_P_MAX_PRESENT)
    {
        /* If p_max param is absent in cell ctxt */
        if(!(p_cell_ctx_params->bitmask & RRMCM_RMIF_P_MAX_SIB3_PRESENT))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_P_MAX_SIB3_PRESENT absent");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
        if(p_meas_config_req_params->p_max
                != p_cell_ctx_params->p_max_sib_3)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "p_max_sib_3 differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}
/****************************************************************************
 * Function Name  : rrmcm_compare_son_eutran_ap_ncl 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_ap_ncl(rrm_cell_context_t           *p_cell_ctx,
                                intra_freq_params_t          *p_cell_ctx_params,
                                rrm_son_meas_config_eutran_t *p_meas_config_req_params)
{
    rrm_bool_et      params_differ   = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_PRESENCE_ANTENNAE_PORT_PRESENT)
    {
        if(p_meas_config_req_params->presence_antenna_port
                != p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info.
                    presence_antenna_port1)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "presence_antenna_port1 differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_NEIGHBOR_CELL_CONFIG_PRESENT)
    {
        if(p_meas_config_req_params->neighbor_cell_config
                != p_cell_ctx_params->neigh_cell_config)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "neigh_cell_config differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    /*Klockwork_fix_start*/
     params_differ = rrmcm_compare_son_eutran_q_rx(p_cell_ctx_params ,
                                            p_meas_config_req_params);
    /*Klockwork_fix_end*/
    RRM_UT_TRACE_EXIT();
    return params_differ;

}

/****************************************************************************
* Function Name  : rrmcm_compare_son_eutran_meas_meas_bandwidth 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_meas_meas_bandwidth( rrm_cell_context_t   *p_cell_ctx,
                     rrm_son_meas_config_eutran_t    *p_meas_config_req_params)
{
    
    rrm_bool_et      params_differ   = RRM_FALSE; 
    RRM_UT_TRACE_ENTER();  
    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_MEAS_BANDWIDTH_PRESENT)
    {
        if(!(p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info.
                bitmask & RRMCM_RMIF_MEASUREMENT_BW_PRESENT))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRMCM_RMIF_MEASUREMENT_BW_PRESENT absent");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
        if((U32)p_meas_config_req_params->meas_bandwidth
            != (U32)(p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info.
                measurement_bandwidth))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "measurement_bandwidth differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}
/*Klockwork_fix_start*/
/****************************************************************************
* Function Name  : rrmcm_compare_son_eutran_reselection_sf
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_reselection_sf(intra_freq_params_t             *p_cell_ctx_params,
                                        rrm_son_meas_config_eutran_t    *p_meas_config_req_params )
{
    rrm_bool_et      params_differ   = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
        if(!(p_cell_ctx_params->bitmask &
            RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT))
        {
            params_differ = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT absent");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
        if((U32)p_meas_config_req_params->t_reselection_sf.sf_medium
                != (U32)(p_cell_ctx_params->speed_scale_factors.t_reselection_eutra_sf_medium))
        {
            params_differ = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "t_reselection_eutra_sf_medium differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
        if((U32)p_meas_config_req_params->t_reselection_sf.sf_high
                != (U32)(p_cell_ctx_params->speed_scale_factors.t_reselection_eutra_sf_high))
        {
            params_differ = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "t_reselection_eutra_sf_high differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    RRM_UT_TRACE_EXIT();
    return params_differ;

}
/*Klockwork_fix_end*/
/****************************************************************************
* Function Name  : rrmcm_compare_son_eutran_reselection 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_reselection( intra_freq_params_t             *p_cell_ctx_params,
                     rrm_son_meas_config_eutran_t    *p_meas_config_req_params)
{

    rrm_bool_et      params_differ   = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_RESELECTION_PRESENT)
    {
        if(p_meas_config_req_params->t_reselection
                != p_cell_ctx_params->t_reselection_eutra)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "t_reselection_eutra differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_RESELECTION_SF_PRESENT)

    {
        /*Klockwork_fix_start*/
        params_differ = rrmcm_compare_son_eutran_reselection_sf(p_cell_ctx_params ,p_meas_config_req_params);
        /*Klockwork_fix_end*/
        /* If speed scale params are absent in cell ctxt */
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;

}
/****************************************************************************
* Function Name  : rrmcm_compare_son_eutran_threshold_low
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_threshold_low( intra_freq_params_t             *p_cell_ctx_params,
                     rrm_son_meas_config_eutran_t    *p_meas_config_req_params)
{

    rrm_bool_et      params_differ   = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_THRESHOLD_LOW_PRESENT)
    {
        if(p_meas_config_req_params->threshX_low
                != p_cell_ctx_params->thresh_serving_low)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "thresh_serving_low differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT)
    {
        if(p_meas_config_req_params->cell_reselection_priority
                != p_cell_ctx_params->cell_reselection_priority)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "cell_reselection_priority differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_son_eutran_R9
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_son_eutran_R9( rrm_cell_context_t   *p_cell_ctx,
                     rrm_son_meas_config_eutran_t    *p_meas_config_req_params)
{

    rrm_bool_et      params_differ   = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_Q_QUAL_MIN_R9)
    {
        if(!(p_cell_ctx->operator_info.sib_3_info.bitmask & 
            RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1 absent");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
        if(p_meas_config_req_params->q_qualmin_r9
                != p_cell_ctx->operator_info.sib_3_info.q_qual_min_r9)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "q_qualmin_r9 differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    if(p_meas_config_req_params->bitmask
        & RRM_SON_EUTRAN_THRESHX_LOW_Q_R9)
    {
        if(!(p_cell_ctx->operator_info.sib_3_info.bitmask & 
            RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT absent");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
        if(p_meas_config_req_params->threshx_lowq_r9
                != p_cell_ctx->operator_info.sib_3_info.thresh_serving_lowq_r9)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "threshx_lowq_r9 differ");

            RRM_UT_TRACE_EXIT();
            return params_differ;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}
/*Klockwork_fix_2431*/
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_serv_cell_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the serving cell freq to be 
*          processed, in Meas Config Req Eutran list
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if 
*                  param values are same
* Description    : This function compares the serving cell params configured
*          at RRM with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_serv_cell_sib_params(
    rrm_cell_context_t                      *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    intra_freq_params_t             *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_eutran_t    *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                     params_differ               = RRM_FALSE;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_intra_freq_params);

    p_meas_config_req_params 
        = &(p_meas_config_req->meas_config_req.eutran_config_list[meas_req_index]);
    
    /*Klockwork_fix_2431*/

    params_differ = rrmcm_compare_son_eutran_meas_meas_bandwidth(p_cell_ctx,p_meas_config_req_params);
    if (params_differ == RRM_TRUE)
    {
         RRM_UT_TRACE_EXIT();
         return params_differ; 
    }   
    params_differ = rrmcm_compare_son_eutran_ap_ncl(p_cell_ctx ,p_cell_ctx_params, 
                                                        p_meas_config_req_params);
    if (params_differ == RRM_TRUE)
    {
         RRM_UT_TRACE_EXIT();
         return params_differ;
    }
  
    params_differ = rrmcm_compare_son_eutran_reselection(p_cell_ctx_params ,p_meas_config_req_params);
    if (params_differ == RRM_TRUE)
    {
         RRM_UT_TRACE_EXIT();
         return params_differ;
    }
    
    params_differ = rrmcm_compare_son_eutran_threshold_low(p_cell_ctx_params ,p_meas_config_req_params);
    if (params_differ == RRM_TRUE)
    {
         RRM_UT_TRACE_EXIT();
         return params_differ;
    }


    params_differ = rrmcm_compare_son_eutran_R9(p_cell_ctx ,p_meas_config_req_params);
    if (params_differ == RRM_TRUE)
    {
         RRM_UT_TRACE_EXIT();
         return params_differ;
    }
    /*Klockwork_fix_2431*/ 
    RRM_UT_TRACE_EXIT();
    return params_differ;
}
/*Klockwork_fix_start*/
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_sib_params_meas_bw
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_sib_params_meas_bw(inter_freq_params_t            *p_cell_ctx_params ,
                                                    rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ               = RRM_FALSE;
        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_MEAS_BANDWIDTH_PRESENT)
        {
            if(p_meas_config_req_params->meas_bandwidth
                    != p_cell_ctx_params->inter_freq_params_op_specific.allowed_meas_bandwidth)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "allowed_meas_bandwidth differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_sib_params_antennae_port
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_sib_params_antennae_port(inter_freq_params_t            *p_cell_ctx_params ,
                                                          rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;

        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_PRESENCE_ANTENNAE_PORT_PRESENT)
        {
            if(p_meas_config_req_params->presence_antenna_port
                    != p_cell_ctx_params->inter_freq_params_op_specific.presence_antenna_port1)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "presence_antenna_port1 differ");
        }
    }
   return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_neighbor_cell_config
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_neighbor_cell_config(inter_freq_params_t            *p_cell_ctx_params ,
                                                      rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
    if(p_meas_config_req_params->bitmask 
            & RRM_SON_EUTRAN_NEIGHBOR_CELL_CONFIG_PRESENT)
    {
        if(p_meas_config_req_params->neighbor_cell_config
                != p_cell_ctx_params->neigh_cell_config)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "neigh_cell_config differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_offset_freq
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_offset_freq(inter_freq_params_t            *p_cell_ctx_params ,
                                             rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
        if(p_meas_config_req_params->bitmask & RRM_SON_EUTRAN_OFFSET_FREQUENCY_PRESENT)
        {
            if(p_meas_config_req_params->offset_frequency
                    != p_cell_ctx_params->q_offset_freq)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "q_offset_freq differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_q_rx
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_q_rx(inter_freq_params_t            *p_cell_ctx_params ,
                                      rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
        if(p_meas_config_req_params->bitmask & RRM_SON_EUTRAN_Q_RX_LEV_MIN_PRESENT)
        {
            if(p_meas_config_req_params->q_rx_lev_min
                    != p_cell_ctx_params->q_rx_lev_min_sib_5)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "q_rx_lev_min_sib_5 differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_p_max
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_p_max(inter_freq_params_t            *p_cell_ctx_params ,
                                      rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
        if(p_meas_config_req_params->bitmask & RRM_SON_EUTRAN_P_MAX_PRESENT)
        {
            /* If p_max param is absent in cell ctxt */
            if(!(p_cell_ctx_params->bitmask & RRMCM_RMIF_P_MAX_PRESENT))
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_P_MAX_PRESENT absent");
            }
            if(p_meas_config_req_params->p_max
                    != p_cell_ctx_params->p_max)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "p_max differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_reselection
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_reselection(inter_freq_params_t            *p_cell_ctx_params ,
                                      rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;

    if(p_meas_config_req_params->bitmask
            & RRM_SON_EUTRAN_RESELECTION_PRESENT)
    {
        if(p_meas_config_req_params->t_reselection
                != p_cell_ctx_params->t_reselection_eutra)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "t_reselection_eutra differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_reselection_sf
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_reselection_sf(inter_freq_params_t            *p_cell_ctx_params ,
                                                rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;

        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_RESELECTION_SF_PRESENT) 
        {
            /* If speed scale params are absent in cell ctxt */
            if(!(p_cell_ctx_params->bitmask &
                        RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1))
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1 absent");
        }
        if((U32)p_meas_config_req_params->t_reselection_sf.sf_medium
                != (U32)(p_cell_ctx_params->speed_scale_factors.t_reselection_eutra_sf_medium))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "t_reselection_eutra_sf_medium differ");
        }
        if((U32)p_meas_config_req_params->t_reselection_sf.sf_high
                != (U32)(p_cell_ctx_params->speed_scale_factors.t_reselection_eutra_sf_high))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "t_reselection_eutra_sf_high differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_threshold_high
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_threshold_high(inter_freq_params_t            *p_cell_ctx_params ,
                                                rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;

        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_THRESHOLD_HIGH_PRESENT)
        {
            if(p_meas_config_req_params->threshX_high
                    != p_cell_ctx_params->thresh_x_high)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "thresh_x_high differ");
            }
        }
        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_THRESHOLD_LOW_PRESENT)
        {
            if(p_meas_config_req_params->threshX_low
                    != p_cell_ctx_params->thresh_x_low)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "thresh_x_low differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_cell_reselection
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_cell_reselection(inter_freq_params_t            *p_cell_ctx_params ,
                                                rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            /* If cell reselection priority param is absent in cell ctxt */    
            if(!(p_cell_ctx_params->bitmask &
                        RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT))
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT absent");
        }
        if(p_meas_config_req_params->cell_reselection_priority
                != p_cell_ctx_params->cell_reselection_priority)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "cell_reselection_priority differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_q_qual_min_r9
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_q_qual_min_r9(inter_freq_params_t            *p_cell_ctx_params ,
                                               rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
        if(p_meas_config_req_params->bitmask
                & RRM_SON_EUTRAN_Q_QUAL_MIN_R9)
        {
            if(!(p_cell_ctx_params->inter_freq_params_op_specific.bitmask &
                        RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT))
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT absent");
            }
            if(p_meas_config_req_params->q_qualmin_r9
                    != p_cell_ctx_params->inter_freq_params_op_specific.q_qual_min_r9)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "q_qualmin_r9 differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_q_r9
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_q_r9(inter_freq_params_t            *p_cell_ctx_params ,
                                      rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
    if(p_meas_config_req_params->bitmask
            & RRM_SON_EUTRAN_THRESHX_LOW_Q_R9)
    {
        if(!(p_cell_ctx_params->inter_freq_params_op_specific.bitmask &
                    RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT absent");
        }
        if(p_meas_config_req_params->threshx_lowq_r9
                != p_cell_ctx_params->inter_freq_params_op_specific.threshx_q_r9.thresh_serving_lowq_r9)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "threshx_lowq_r9 differ");
        }
    }
    return params_differ;
}
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_high_q_r9
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_high_q_r9(inter_freq_params_t            *p_cell_ctx_params ,
                                      rrm_son_meas_config_eutran_t   *p_meas_config_req_params)
{
    rrm_bool_et                     params_differ     = RRM_FALSE;
    if(p_meas_config_req_params->bitmask
            & RRM_SON_EUTRAN_THRESHX_HIGH_Q_R9)
    {
        if(!(p_cell_ctx_params->inter_freq_params_op_specific.bitmask &
                    RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT))
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT absent");
        }
        if(p_meas_config_req_params->threshx_highq_r9
                != p_cell_ctx_params->inter_freq_params_op_specific.threshx_q_r9.thresh_serving_highq_r9)
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "threshx_lowq_r9 differ");
        }
    }
    return params_differ;
}

/*Klockwork_fix_end*/


/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_eutran_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U8 cell_ctx_index : index of inter freq list at which the
*          freq to be compared is configured at RRM
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req Eutran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if 
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in inter freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_eutran_sib_params(
    rrm_cell_context_t                      *p_cell_ctx, 
    U8                                      cell_ctx_index,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();
    
    inter_freq_params_t             *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_eutran_t    *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                     params_differ               = RRM_FALSE;
    U8                              count                       = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_freq_params[cell_ctx_index]);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.eutran_config_list[meas_req_index]);
        
    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        /*Klockwork_fix_start*/
        params_differ = rrmcm_compare_meas_config_eutran_sib_params_meas_bw(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }
        params_differ = rrmcm_compare_meas_config_eutran_sib_params_antennae_port(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }
        params_differ = rrmcm_compare_meas_config_eutran_neighbor_cell_config(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }
        params_differ = rrmcm_compare_meas_config_eutran_offset_freq(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }
        params_differ = rrmcm_compare_meas_config_eutran_q_rx(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_p_max(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_reselection(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }
        
        params_differ = rrmcm_compare_meas_config_eutran_reselection_sf(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_threshold_high(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_cell_reselection(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_q_qual_min_r9(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_q_r9(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }

        params_differ = rrmcm_compare_meas_config_eutran_high_q_r9(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
        {
            break ;
        }
 
        /*Klockwork_fix_end*/

    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}

/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_utran_reselection_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and 
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection params 
*          configured at RRM for Utra freqs with those received in 
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_utran_reselection_sib_params(
    rrm_cell_context_t                      *p_cell_ctx, 
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req
    )
{
    RRM_UT_TRACE_ENTER();

    idle_mode_mobility_irat_utra_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_utran_t             *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.utran_config_list);

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->bitmask
                & RRM_SON_UTRAN_RESELECTION_PRESENT)
        {
            if(p_meas_config_req_params->t_reselection
                    != p_cell_ctx_params->irat_eutra_to_utra_reselection_params.
                    t_reselection_utra)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "t_reselection_utra differ");
                break;
            }
        }
        if(p_meas_config_req_params->bitmask
                & RRM_SON_UTRAN_RESELECTION_SF_PRESENT)
        {
            if(!(p_cell_ctx_params->irat_eutra_to_utra_reselection_params.
                        bitmask & 
                        RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT absent");
                break;
            }
            if((U32)p_meas_config_req_params->t_reselection_sf.sf_medium
                    != (U32)(p_cell_ctx_params->irat_eutra_to_utra_reselection_params.
                    speed_state_scale_factor.t_reselection_eutra_sf_medium))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "t_reselection_eutra_sf_medium differ");
                break;
            }
            if((U32)p_meas_config_req_params->t_reselection_sf.sf_high
                    != (U32)(p_cell_ctx_params->irat_eutra_to_utra_reselection_params.
                    speed_state_scale_factor.t_reselection_eutra_sf_high))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "t_reselection_eutra_sf_high differ");
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}

/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_utran_fdd_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U8 cell_ctx_index : index of Utra freq list at which the
*          freq to be compared is configured at RRM
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req Utran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if 
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in FDD Utra freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_utran_fdd_sib_params(
    rrm_cell_context_t                      *p_cell_ctx, 
    U8                                      cell_ctx_index,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    idle_mode_mobility_irat_utra_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_utran_t             *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.utran_config_list);

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                        irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                        bitmask &
                        RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT absent");
                break;
            }
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    cell_reselection_priority
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    cell_reselection_priority)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "cell_reselection_priority differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_THRESHOLD_HIGH_PRESENT)
        {
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    threshX_high
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    thresh_x_high)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_high differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_THRESHOLD_LOW_PRESENT)
        {
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    threshX_low
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    thresh_x_low)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_low differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_Q_RX_LEV_MIN_PRESENT)
        {
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    q_rx_lev_min
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    q_rx_lev_min)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "q_rx_lev_min differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_P_MAX_PRESENT)
        {
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    p_max
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    p_max_utra)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "p_max_utra differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_Q_QUAL_MIN_PRESENT)
        {
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    q_qual_min
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    q_qual_min)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "q_qual_min differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_THRESHX_LOW_Q_R9)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].bitmask &
                        RRMCM_RMIF_THRESHX_Q_R9_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_THRESHX_Q_R9_PRESENT absent");
                break; 
            }
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    threshx_lowq_r9
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].threshx_q_r9.
                    thresh_serving_lowq_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "threshx_lowq_r9 differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_THRESHX_HIGH_Q_R9)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].bitmask &
                        RRMCM_RMIF_THRESHX_Q_R9_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRMCM_RMIF_THRESHX_Q_R9_PRESENT absent");
                break; 
            }
            if(p_meas_config_req_params->utran_fdd_list[meas_req_index].
                    threshx_highq_r9
                    != p_cell_ctx_params->irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cell_ctx_index].threshx_q_r9.
                    thresh_serving_highq_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "threshx_highq_r9 differ");
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}

/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_utran_tdd_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U8 cell_ctx_index : index of Utra freq list at which the
*          freq to be compared is configured at RRM
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req Utran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if 
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in FDD Utra freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_utran_tdd_sib_params(
    rrm_cell_context_t                      *p_cell_ctx, 
    U8                                      cell_ctx_index,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    idle_mode_mobility_irat_utra_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_utran_t             *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.utran_config_list);

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_TDD_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_utran_tdd_list.
                        irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                        bitmask &
                        RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT absent");
                break;
            }
            if(p_meas_config_req_params->utran_tdd_list[meas_req_index].
                    cell_reselection_priority
                    != p_cell_ctx_params->irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                    cell_reselection_priority)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "cell_reselection_priority differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_TDD_THRESHOLD_HIGH_PRESENT)
        {
            if(p_meas_config_req_params->utran_tdd_list[meas_req_index].
                    threshX_high
                    != p_cell_ctx_params->irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                    thresh_x_high)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_high differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_TDD_THRESHOLD_LOW_PRESENT)
        {
            if(p_meas_config_req_params->utran_tdd_list[meas_req_index].
                    threshX_low
                    != p_cell_ctx_params->irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                    thresh_x_low)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_low differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT)
        {
            if(p_meas_config_req_params->utran_tdd_list[meas_req_index].
                    q_rx_lev_min
                    != p_cell_ctx_params->irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                    q_rx_lev_min)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "q_rx_lev_min differ");
                break;
            }
        }
        if(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask
                & RRM_SON_UTRAN_TDD_P_MAX_PRESENT)
        {
            if(p_meas_config_req_params->utran_tdd_list[meas_req_index].
                    p_max
                    != p_cell_ctx_params->irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                    p_max_utra)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "p_max_utra differ");
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}

/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_geran_sib_reselection_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and 
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection params 
*          configured at RRM for Utra freqs with those received in 
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_geran_reselection_sib_params(
    rrm_cell_context_t                      *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req
    )
{
    RRM_UT_TRACE_ENTER();

    idle_mode_mobility_irat_geran_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_geran_t             *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.geran_config_list);

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->bitmask
                & RRM_SON_MC_GERAN_T_RESELECTION_PRESENT)
        {
            if(p_meas_config_req_params->t_reselection
                    != p_cell_ctx_params->irat_eutra_to_geran_reselection_params.
                    t_reselection_geran)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "t_reselection_geran differ");
                break;
            }
        }
        if(p_meas_config_req_params->bitmask
                & RRM_SON_MC_GERAN_T_RESELECTION_SF_PRESENT)
        {
            if((U32)p_meas_config_req_params->t_reselection_sf.sf_medium
                    != (U32)(p_cell_ctx_params->irat_eutra_to_geran_reselection_params.
                    speed_state_scale_factor.t_reselection_eutra_sf_medium))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "t_reselection_eutra_sf_medium differ");
                break;
            }
            if((U32)p_meas_config_req_params->t_reselection_sf.sf_high
                    != (U32)(p_cell_ctx_params->irat_eutra_to_geran_reselection_params.
                    speed_state_scale_factor.t_reselection_eutra_sf_high))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "t_reselection_eutra_sf_high differ");
                break;
            }
        }
    }// end for
    RRM_UT_TRACE_EXIT();
    return params_differ;
}


/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_cdma_reselection_sib_hrpd_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and 
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection hrpd params 
*          configured at RRM for CDMA freqs with those received in 
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_cdma_reselection_sib_hrpd_params(
    rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params,
    rrm_son_meas_config_cdma_t              *p_meas_config_req_params
    )
{
    RRM_UT_TRACE_ENTER();

    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;
    U8                                      pre_reg_info_index          = RRM_NULL;
    U8                                      pre_reg_info_size           = RRM_NULL;


    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->bitmask
                & RRM_SON_MEAS_CONFIG_CDMA_PRE_REG_HRPD_INFO_PRESENT )
        {
            if(p_meas_config_req_params->hrpd_info.bitmask
                    & RRM_SON_CDMA_HRPD_REG_PARAMS_PRESENT)
            {   
                if(p_meas_config_req_params->hrpd_info.hrpd_reg_params.pre_reg_allowed
                                != p_cell_ctx_params->pre_reg_info_hrpd.pre_reg_allowed)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "pre_reg_allowed differ");
                    break;
                }
                if((p_meas_config_req_params->hrpd_info.hrpd_reg_params.bitmask
                        & RRM_SON_HRPD_PRE_REG_ZONE_ID_PRESENT) &&
                   (p_meas_config_req_params->hrpd_info.hrpd_reg_params.pre_reg_zone_id
                                != p_cell_ctx_params->pre_reg_info_hrpd.pre_reg_zone_id))
 
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "pre_reg_zone_id differ");
                    break;
                }
                if(p_meas_config_req_params->hrpd_info.hrpd_reg_params.bitmask
                        & RRM_SON_HRPD_SEC_PRE_REG_ZONE_ID_PRESENT)
                {

                    pre_reg_info_size = p_meas_config_req_params->hrpd_info.hrpd_reg_params.
                                        scndry_pre_reg_zone_id_list_size;
                    if(pre_reg_info_size != p_cell_ctx_params->pre_reg_info_hrpd.
                                secondary_list.count)
                    {
                        params_differ = RRM_TRUE;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_BRIEF, "secondary reg zone id size differ");
                        break;
                    }
                    else
                    {
                         for(pre_reg_info_index = RRM_NULL;  
                               pre_reg_info_index < pre_reg_info_size; 
                               pre_reg_info_index++)
                         {
                 
                             if(p_meas_config_req_params->hrpd_info.hrpd_reg_params.
                                     scndry_pre_reg_zone_id_list[pre_reg_info_index]
                                 != p_cell_ctx_params->pre_reg_info_hrpd.
                                    secondary_list.pre_reg_zone_id[pre_reg_info_index])
                             {
                                 params_differ = RRM_TRUE;
                                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                         RRM_BRIEF,
                                     "secondary reg zone id  for index[%d] differ",
                                     pre_reg_info_index);
                                 break;
                     
                             }
                         }

                         break;
                    }
                }
            }
            
            if(p_meas_config_req_params->hrpd_info.t_reselection
                    != p_cell_ctx_params->cell_reselection_params_hrpd.t_reselection_cdma2000)
            {
                 params_differ = RRM_TRUE;
                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                          "t_reselection_cdma differ");
                 break;
            }

            if(p_meas_config_req_params->hrpd_info.bitmask
                    & RRM_SON_CDMA_HRPD_RESELECTION_SF_PRESENT)
            {
                if((U32)(p_meas_config_req_params->hrpd_info.t_reselection_sf.sf_medium)
                                != (U32)(p_cell_ctx_params->cell_reselection_params_hrpd.
                                t_reselection_cdma2000_sf.t_reselection_eutra_sf_medium))
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "t_reselection_eutra_sf_medium differ");
                    break;
                }
                if((U32)(p_meas_config_req_params->hrpd_info.t_reselection_sf.sf_high)
                        != (U32)(p_cell_ctx_params->cell_reselection_params_hrpd.
                        t_reselection_cdma2000_sf.t_reselection_eutra_sf_high))
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "t_reselection_eutra_sf_high differ");
                    break;
                }
            }
        }

     }


    RRM_UT_TRACE_EXIT();
    return params_differ;
}

/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_cdma_reselection_sib_1xrtt_params
* Inputs         : 
*   rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params,
*   rrm_son_meas_config_cdma_t              *p_meas_config_req_params
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and 
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection 1xrtt params 
*          configured at RRM for CDMA freqs with those received in 
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_cdma_reselection_sib_1xrtt_params(
    rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params,
    rrm_son_meas_config_cdma_t              *p_meas_config_req_params
    )
{
    RRM_UT_TRACE_ENTER();

    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;


    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
       if(p_meas_config_req_params->bitmask
                & RRM_SON_MEAS_CONFIG_CDMA_1X_RTT_INFO_PRESENT )
        {
            if(p_meas_config_req_params->cdma_1xrtt_info.bitmask
                    & RRM_SON_CDMA_1XRTT_REG_PARAMS_PRESENT)
            {  
/*                
                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.sid
                            != p_cell_ctx_params->mobility_sib_8_params.sid[RRM_NULL])
*/
                if (RRM_MEMCMP(&(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.sid),
                            &(p_cell_ctx_params->mobility_sib_8_params.sid),sizeof(U16)))    
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "sid differ");
                    break;
                }
/*
                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.nid
                            != p_cell_ctx_params->mobility_sib_8_params.nid[RRM_NULL])
*/
                if (RRM_MEMCMP(&(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.nid),
                            &(p_cell_ctx_params->mobility_sib_8_params.nid),sizeof(U16)))    
 
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "nid differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.multiple_sid
                                != p_cell_ctx_params->mobility_sib_8_params.multiple_sid)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "multiple_sid differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.multiple_nid
                                != p_cell_ctx_params->mobility_sib_8_params.multiple_nid)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "multiple_nid differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.home_reg
                                != p_cell_ctx_params->mobility_sib_8_params.home_reg)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "home_reg differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.foreign_sid_reg
                                != p_cell_ctx_params->mobility_sib_8_params.foreign_sid_reg)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "foreign_sid_reg differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.foreign_nid_reg
                                != p_cell_ctx_params->mobility_sib_8_params.foreign_nid_reg)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "foreign_nid_reg differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.parameter_reg
                                != p_cell_ctx_params->mobility_sib_8_params.parame_reg)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "parameter_reg differ");
                    break;
                }
 
                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.power_up_reg
                                != p_cell_ctx_params->mobility_sib_8_params.power_up_reg)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "power_up_reg differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.reg_period
                                != p_cell_ctx_params->mobility_sib_8_params.reg_prd)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "reg_period differ");
                    break;
                }
/*
                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.reg_zone
                                != p_cell_ctx_params->mobility_sib_8_params.reg_zone[RRM_NULL])
*/
                if (RRM_MEMCMP(&(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.reg_zone),
                            &(p_cell_ctx_params->mobility_sib_8_params.reg_zone),sizeof(U16)))    
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "reg_zone differ");
                    break;
                }
 
                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.total_zone
                            != p_cell_ctx_params->mobility_sib_8_params.total_zone[RRM_NULL])
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "total_zone differ");
                    break;
                }

                if(p_meas_config_req_params->cdma_1xrtt_info.xrtt_reg_params.zone_timer
                            != p_cell_ctx_params->mobility_sib_8_params.zone_timer[RRM_NULL])
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "total_zone differ");
                    break;
                }

            }
 

            if(p_meas_config_req_params->cdma_1xrtt_info.t_reselection
                    != p_cell_ctx_params->cell_reselection_params_1xrtt.t_reselection_cdma2000)
            {
                 params_differ = RRM_TRUE;
                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                          "t_reselection_cdma differ");
                 break;
            }

            if(p_meas_config_req_params->cdma_1xrtt_info.bitmask
                    & RRM_SON_CDMA_1XRTT_RESELECTION_SF_PRESENT)
            {
                if((U32)(p_meas_config_req_params->cdma_1xrtt_info.t_reselection_sf.sf_medium)
                                != (U32)(p_cell_ctx_params->cell_reselection_params_1xrtt.
                                t_reselection_cdma2000_sf.t_reselection_eutra_sf_medium))
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "t_reselection_eutra_sf_medium differ");
                    break;
                }
                if((U32)(p_meas_config_req_params->cdma_1xrtt_info.t_reselection_sf.sf_high)
                        != (U32)(p_cell_ctx_params->cell_reselection_params_1xrtt.
                        t_reselection_cdma2000_sf.t_reselection_eutra_sf_high))
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "t_reselection_eutra_sf_high differ");
                    break;
                }
            }
        }
     }
 
    RRM_UT_TRACE_EXIT();
    return params_differ;
}


/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_cdma_resel_sib_ac_bar_config
* Inputs         : 
*   rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params,
*   rrm_son_meas_config_cdma_t              *p_meas_config_req_params
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and 
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection ac bar config 
*          params configured at RRM for CDMA freqs with those received in 
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_cdma_resel_sib_ac_bar_config(
    rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params,
    rrm_son_meas_config_cdma_t              *p_meas_config_req_params
    )
{

    U8                                      count           = RRM_NULL;
    rrm_bool_et                             params_differ   = RRM_FALSE;
    
    RRM_UT_TRACE_ENTER();

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->bitmask
                & RRM_SON_MEAS_CONFIG_AC_BARRING_CONFIG_1XRTT_PRESENT)
        {
            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_0_to_9_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_0_to_9_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_0_to_9_r9 differ");
                break;
            
            }

            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_10_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_10_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_10_r9 differ");
                break;
            
            }

            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_11_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_11_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_11_r9 differ");
                break;
            
            }
            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_12_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_12_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_12_r9 differ");
                break;
            
            }

            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_13_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_13_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_13_r9 differ");
                break;
            
            }

            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_14_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_14_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_14_r9 differ");
                break;
            
            }
 
            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_15_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_15_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_15_r9 differ");
                break;
            
            }
            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_msg_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_msg_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_msg_r9 differ");
                break;
            
            }

            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_reg_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_reg_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_reg_r9 differ");
                break;
            
            }

            if(p_meas_config_req_params->ac_barring_config_1xrtt_r9.
                    ac_barring_emg_r9 
                    != p_cell_ctx_params->ac_barring_config_1_xrtt_r9.
                    ac_barring_emg_r9)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "ac_barring_emg_r9 differ");
                break;
            
            }
 
        }
    }
 
    RRM_UT_TRACE_EXIT();
    return params_differ;
}
/*Klockwork_fix_start*/
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_cdma_reselection
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection params
*          configured at RRM for Utra freqs with those received in
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_cdma_reselection(rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params,
                                           rrm_son_meas_config_cdma_t                    *p_meas_config_req_params)
{
    rrm_bool_et                             params_differ               = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

        if(p_meas_config_req_params->bitmask
                & RRM_SON_MEAS_CONFIG_CDMA_SRCH_WNDO_SIZE_PRESENT)
        {
            if(p_meas_config_req_params->srch_wnd_size 
                    != p_cell_ctx_params->search_window_size)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "srch_wnd_size differ");
            
            }
        }

        if(p_meas_config_req_params->bitmask
                & RRM_SON_MEAS_CONFIG_CSFB_SUPPORT_FOR_DUAL_RX_UES_PRESENT)
        {
            if(p_meas_config_req_params->csfb_support_for_dual_Rx_Ues_r9 
                    != p_cell_ctx_params->csfb_support_for_dual_rx_ues_r9)
            {
                params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "csfb_support_for_dual_rx_Ues_r9 differ");

        }
            }
   RRM_UT_TRACE_EXIT();
   return params_differ;
}
/*Klockwork_fix_end*/

 
/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_cdma_reselection_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
* Outputs        : None
* Returns        : RRM_TRUE if any of the reselection params differ and 
*          RRM_FALSE if reselection param values are same
* Description    : This function compares the freq reselection params 
*          configured at RRM for Utra freqs with those received in 
*          Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_cdma_reselection_sib_params(
    rrm_cell_context_t                      *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req
    )
{
    RRM_UT_TRACE_ENTER();

    rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_cdma_t              *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;
    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.cdma_config_list);

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
       /*Klockwork_fix_start*/
        params_differ = rrmcm_compare_meas_config_cdma_reselection(p_cell_ctx_params ,p_meas_config_req_params);
        if(params_differ == RRM_TRUE)
            break;
       /*Klockwork_fix_end*/

        //calling here for comparison of ac barring config params
        if((rrmcm_compare_meas_config_cdma_resel_sib_ac_bar_config(p_cell_ctx_params,
                        p_meas_config_req_params)))
        {
             params_differ = RRM_TRUE;
             break;
        }
 
        //calling here for comparison of HRPD config params
        if((rrmcm_compare_meas_config_cdma_reselection_sib_hrpd_params(p_cell_ctx_params,
                        p_meas_config_req_params)))
        {
             params_differ = RRM_TRUE;
             break;
        }
        
        //calling here for comparison of 1XRTT config params
        if((rrmcm_compare_meas_config_cdma_reselection_sib_1xrtt_params(p_cell_ctx_params,
                        p_meas_config_req_params)))
        {
             params_differ = RRM_TRUE;
             break;
        }

       if(p_meas_config_req_params->bitmask
               & RRM_SON_MEAS_CONFIG_CSFB_REG_PARAM_1XRTT_PRESENT )
       {
           if(p_meas_config_req_params->csfb_registration_param_1xrtt_r9.power_down_reg_r9
                   != p_cell_ctx_params->mobility_sib_8_params.power_down_reg)
           {
               params_differ = RRM_TRUE;
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                     " power_down_reg differ");
               break;
           }
        }
    }
    // end for
    RRM_UT_TRACE_EXIT();
    return params_differ;
}




/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_geran_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U8 cell_ctx_index : index of Geran freq list at which the
*          freq to be compared is configured at RRM
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req Geran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if 
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in Geran freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_geran_sib_params(
    rrm_cell_context_t                      *p_cell_ctx,
    U8                                      cell_ctx_index,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    idle_mode_mobility_irat_geran_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_geran_t             *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;
    U8                                      index                       = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.geran_config_list);

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                geran_car_freqs.band_ind != 
                p_cell_ctx_params->irat_eutran_to_geran_list.
                irat_eutran_to_geran_carriers[cell_ctx_index].
                geran_car_freqs.band_ind) 
        {
            params_differ = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "band_ind differ");
            break;
        }
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                geran_car_freqs.following_arfcns.bitmask &
                RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_geran_list.
                        irat_eutran_to_geran_carriers[cell_ctx_index].geran_car_freqs.
                        following_arfcns.bitmask & RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT absent");
                break;
            }
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.exp_arfcn_list_size !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].
                    geran_car_freqs.following_arfcns.exp_arfcn_list_size)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "exp_arfcn_list_size differ");
                break;
            }
            for(index = RRM_NULL; index <
                    p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.exp_arfcn_list_size; index++)
            {
                if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                        geran_car_freqs.following_arfcns.exp_arfcn_list[index] !=
                        p_cell_ctx_params->irat_eutran_to_geran_list.
                        irat_eutran_to_geran_carriers[cell_ctx_index].
                        geran_car_freqs.following_arfcns.exp_arfcn_list[index])
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "exp_arfcn_list[%d] differ",index);
                    break;
                }
                /* Coverity 19oct : 54926 -delete */
            }
        }
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                geran_car_freqs.following_arfcns.bitmask &
                RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_geran_list.
                        irat_eutran_to_geran_carriers[cell_ctx_index].geran_car_freqs.
                        following_arfcns.bitmask & RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT absent");
                break;
            }
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.arfcn_spacing !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].
                    geran_car_freqs.following_arfcns.arfcn_spacing)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "arfcn_spacing differ");
                break;
            }
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.num_of_following_arfcn !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].
                    geran_car_freqs.following_arfcns.num_of_following_arfcn)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "num_of_following_arfcn differ");
                break;
            }
        }
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                geran_car_freqs.following_arfcns.bitmask &
                RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_geran_list.
                        irat_eutran_to_geran_carriers[cell_ctx_index].geran_car_freqs.
                        following_arfcns.bitmask & RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT absent");
                break;
            }
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.arfcn_bmp_list_size !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].
                    geran_car_freqs.following_arfcns.arfcn_bmp_list_size)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "arfcn_bmp_list_size differ");
                break;
            }
            for(index = RRM_NULL; index <
                    p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.arfcn_bmp_list_size; index++)
            {
                if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                        geran_car_freqs.following_arfcns.arfcn_bmp_list[index] !=
                        p_cell_ctx_params->irat_eutran_to_geran_list.
                        irat_eutran_to_geran_carriers[cell_ctx_index].
                        geran_car_freqs.following_arfcns.arfcn_bmp_list[index])
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "arfcn_bmp_list[%d] differ",index);
                    break;
                }
                if(RRM_TRUE == params_differ)
                {
                    break;
                }
            }
        }
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                bitmask &
                RRM_SON_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            if(!(p_cell_ctx_params->irat_eutran_to_geran_list.
                        irat_eutran_to_geran_carriers[cell_ctx_index].
                        bitmask & RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT))
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT absent");
                break;
            }
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    cell_reselection_priority !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].
                    cell_reselection_priority)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "cell_reselection_priority differ");
                break;
            }
        } 
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                bitmask & RRM_SON_GERAN_CFI_NCC_PERMITTED_PRESENT)
        {
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    ncc_permitted != 
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].ncc_permitted
              )
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "ncc_permitted differ");
                break;
            }
        } 
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                bitmask & RRM_SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT)
        {
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    q_rx_lev_min !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].q_rx_lev_min
              )
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "q_rx_lev_min differ");
                break;
            }
        } 
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                bitmask & RRM_SON_GERAN_CFI_MAX_ALLOWED_TRANS_PWR_PRESENT)
        {
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    p_max_geran !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].p_max_geran
              )
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "p_max_geran differ");
                break;
            }
        } 
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                bitmask & RRM_SON_GERAN_CFI_THRESHX_HIGH_PRESENT)
        {
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    threshX_high !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].threshX_high
              )
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "threshX_high differ");
                break;
            }
        } 
        if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                bitmask & RRM_SON_GERAN_CFI_THRESHX_LOW_PRESENT)
        {
            if(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    threshX_low !=
                    p_cell_ctx_params->irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[cell_ctx_index].threshX_low
              )
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "threshX_low differ");
                break;
            }
        } 
    }// end for
    RRM_UT_TRACE_EXIT();
    return params_differ;
}


/****************************************************************************
* Function Name  : rrmcm_compare_meas_config_cdma_sib_params
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          U8 cell_ctx_index : index of CDMA freq list at which the
*          freq to be compared is configured at RRM
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req CDMA list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_TRUE if any of the params differ and RRM_FALSE if 
*                  param values are same
* Description    : This function compares the freq params configured at RRM
*          in CDMA freq list with those received in Meas Config Req.
****************************************************************************/
static rrm_bool_et
rrmcm_compare_meas_config_cdma_sib_params(
    rrm_cell_context_t                      *p_cell_ctx,
    U8                                      cell_ctx_index,
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    rrmcm_idle_mode_mobility_irat_cdma_params_t   *p_cell_ctx_params          = RRM_PNULL;
    rrm_son_meas_config_cdma_t             *p_meas_config_req_params   = RRM_PNULL;
    rrm_bool_et                             params_differ               = RRM_FALSE;
    U8                                      count                       = RRM_NULL;
    U8                                      cdma_type                   = RRM_NULL;

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params);

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.cdma_config_list);

    cdma_type = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        cdma_config_list.cdma_freq_info_list[meas_req_index].cdma_type;

    /* Loop just to break there and then if params differ */
    for(count = RRM_NULL; count < RRM_1; count++)
    {

        if(cdma_type == R_TYPE_HRPD)
        {
            if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                band_class != p_cell_ctx_params->cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].band_class)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "band_class differ");
                break;
            }
            if(p_meas_config_req_params->cdma_freq_info_list[meas_req_index].bitmask
                    & RRM_SON_CDMA_RESELECTION_PRIORITY_PRESENT)
            {
                if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                    cell_reselection_priority != p_cell_ctx_params->cell_reselection_params_hrpd.
                    band_class_list.band_class_info_cdma2000[cell_ctx_index].
                    cell_reselection_priority)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "cell_reselection_priority differ");
                    break;
                }
 
            }
            if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                threshX_high != p_cell_ctx_params->cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_high)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_high differ");
                break;
            }
             if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                threshX_low != p_cell_ctx_params->cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_low)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_low differ");
                break;
            }
        }
        if(cdma_type == R_TYPE_1X_RTT)
        {
            if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                band_class != p_cell_ctx_params->cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].band_class)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "band_class differ");
                break;
            }
            if(p_meas_config_req_params->cdma_freq_info_list[meas_req_index].bitmask
                    & RRM_SON_CDMA_RESELECTION_PRIORITY_PRESENT)
            {
                if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                    cell_reselection_priority != p_cell_ctx_params->cell_reselection_params_1xrtt.
                    band_class_list.band_class_info_cdma2000[cell_ctx_index].
                    cell_reselection_priority)
                {
                    params_differ = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "cell_reselection_priority differ");
                    break;
                }
 
            }
            if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                threshX_high != p_cell_ctx_params->cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_high)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_high differ");
                break;
            }
             if (p_meas_config_req_params->cdma_freq_info_list[meas_req_index].
                threshX_low != p_cell_ctx_params->cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_low)
            {
                params_differ = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "thresh_x_low differ");
                break;
            }
 
        }
 
    }// end for
    RRM_UT_TRACE_EXIT();
    return params_differ;
}




/****************************************************************************
* Function Name  : rrmcm_check_eutran_mandatory_sib_and_meas_params_present
* Inputs         : rmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*                  rrm_cell_context_t *p_cell_ctx: pointer to cell context
*          U8 meas_req_index: index of the Meas Config Req Eutran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_FALSE if any of the mandatory params is absent and 
*          RRM_TRUE if all mandatory params are present
* Description    : This function checks if all the mandatory params reqd for
*          triggering Reconfig Req to RRC and creating a meas object 
*          node for the freq stored at meas_req_index in 
*          Meas Config Req are present in the req or not
****************************************************************************/
static rrm_bool_et
rrmcm_check_eutran_mandatory_sib_and_meas_params_present(
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    rrm_cell_context_t                      *p_cell_ctx,
    U8                                      meas_req_index
    )
{
    rrm_bool_et                     mand_param_present        = RRM_TRUE;
    rrm_son_meas_config_eutran_t    *p_meas_config_req_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            eutran_config_list[meas_req_index]);

    if(!(p_meas_config_req_params->bitmask &
        RRM_SON_EUTRAN_MEAS_BANDWIDTH_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "RRM_SON_EUTRAN_MEAS_BANDWIDTH_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_PRESENCE_ANTENNAE_PORT_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_PRESENCE_ANTENNAE_PORT_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_NEIGHBOR_CELL_CONFIG_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_NEIGHBOR_CELL_CONFIG_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_OFFSET_FREQUENCY_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_OFFSET_FREQUENCY_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_Q_RX_LEV_MIN_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_Q_RX_LEV_MIN_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_RESELECTION_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_RESELECTION_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_THRESHOLD_HIGH_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_THRESHOLD_HIGH_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->bitmask &
             RRM_SON_EUTRAN_THRESHOLD_LOW_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_EUTRAN_THRESHOLD_LOW_PRESENT absent");
    }
    else if(p_cell_ctx->operator_info.sib_3_info.bitmask & 
            RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
    {
        if(!(p_meas_config_req_params->bitmask &
                 RRM_SON_EUTRAN_THRESHX_LOW_Q_R9))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_EUTRAN_THRESHX_LOW_Q_R9 absent");
        }
        else if(!(p_meas_config_req_params->bitmask &
                 RRM_SON_EUTRAN_THRESHX_HIGH_Q_R9))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_EUTRAN_THRESHX_HIGH_Q_R9 absent");
        }
    }

    RRM_UT_TRACE_EXIT();
    return mand_param_present;
}

/****************************************************************************
* Function Name  : rrmcm_check_utran_fdd_mandatory_sib_and_meas_params_present
* Inputs         : rmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*                  rrm_cell_context_t *p_cell_ctx: pointer to cell context
*          U8 meas_req_index: index of the Meas Config Req Utran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_FALSE if any of the mandatory params is absent and 
*          RRM_TRUE if all mandatory params are present
* Description    : This function checks if all the mandatory params reqd for
*          triggering Reconfig Req to RRC and creating a meas object 
*          node for the freq stored at meas_req_index in 
*          Meas Config Req are present in the req or not
****************************************************************************/
static rrm_bool_et
rrmcm_check_utran_fdd_mandatory_sib_and_meas_params_present(
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    rrm_cell_context_t                      *p_cell_ctx,
    U8                                      meas_req_index
    )
{
    rrm_bool_et                    mand_param_present        = RRM_TRUE;
    rrm_son_meas_config_utran_t    *p_meas_config_req_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.utran_config_list);

    /* TDD Support SON Delete */

    if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_THRESHOLD_HIGH_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_THRESHOLD_HIGH_PRESENT absent");
    } 
    else if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_THRESHOLD_LOW_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_THRESHOLD_LOW_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_Q_RX_LEV_MIN_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_Q_RX_LEV_MIN_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_P_MAX_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_P_MAX_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_Q_QUAL_MIN_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_Q_QUAL_MIN_PRESENT absent");
    }
    else if(p_cell_ctx->operator_info.sib_3_info.bitmask & 
            RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
    {
        if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
                 RRM_SON_UTRAN_THRESHX_LOW_Q_R9))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_UTRAN_THRESHX_LOW_Q_R9 absent");
        }
        else if(!(p_meas_config_req_params->utran_fdd_list[meas_req_index].bitmask &
                 RRM_SON_UTRAN_THRESHX_HIGH_Q_R9))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_UTRAN_THRESHX_HIGH_Q_R9 absent");
        }
    }
    RRM_UT_TRACE_EXIT();
    return mand_param_present;
}

/* TDD Support SON Start */
/****************************************************************************
* Function Name  : rrmcm_check_utran_tdd_mandatory_sib_and_meas_params_present
* Inputs         : rmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*                  rrm_cell_context_t *p_cell_ctx: pointer to cell context
*          U8 meas_req_index: index of the Meas Config Req Utran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_FALSE if any of the mandatory params is absent and 
*          RRM_TRUE if all mandatory params are present
* Description    : This function checks if all the mandatory params reqd for
*          triggering Reconfig Req to RRC and creating a meas object 
*          node for the freq stored at meas_req_index in 
*          Meas Config Req are present in the req or not
****************************************************************************/
static rrm_bool_et
rrmcm_check_utran_tdd_mandatory_sib_and_meas_params_present(
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    /*SPR 17777 +-*/
    U8                                      meas_req_index
    )
{
    rrm_bool_et                    mand_param_present        = RRM_TRUE;
    rrm_son_meas_config_utran_t    *p_meas_config_req_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.utran_config_list);

    if(!(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_TDD_THRESHOLD_HIGH_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_TDD_THRESHOLD_HIGH_PRESENT absent");
    } 
    else if(!(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_TDD_THRESHOLD_LOW_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_TDD_THRESHOLD_LOW_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT absent");
    }
    else if(!(p_meas_config_req_params->utran_tdd_list[meas_req_index].bitmask &
             RRM_SON_UTRAN_TDD_P_MAX_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_UTRAN_TDD_P_MAX_PRESENT absent");
    }

    RRM_UT_TRACE_EXIT();
    return mand_param_present;
}
/* TDD Support SON End */

/****************************************************************************
* Function Name  : rrmcm_check_geran_mandatory_sib_and_meas_params_present
* Inputs         : rmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req Geran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_FALSE if any of the mandatory params is absent and 
*          RRM_TRUE if all mandatory params are present
* Description    : This function checks if all the mandatory params reqd for
*          triggering Reconfig Req to RRC and creating a meas object 
*          node for the freq stored at meas_req_index in 
*          Meas Config Req are present in the req or not
****************************************************************************/
static rrm_bool_et
rrmcm_check_geran_mandatory_sib_and_meas_params_present(
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    rrm_bool_et                    mand_param_present        = RRM_TRUE;
    rrm_son_meas_config_geran_t    *p_meas_config_req_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.geran_config_list);

    if(!(p_meas_config_req_params->bitmask &
                RRM_SON_MC_GERAN_T_RESELECTION_PRESENT))
    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_MC_GERAN_T_RESELECTION_PRESENT absent");
    }
    else if(RRM_NULL < p_meas_config_req_params->geran_freq_info_list_size)
    {
        if(!(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.bitmask & 
                    RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT)
                && !(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.bitmask & 
                    RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT)
                && !(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    geran_car_freqs.following_arfcns.bitmask & 
                    RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT, "
                "RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT and "
                "RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT absent");
        } 
        else if(!(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    bitmask & RRM_SON_GERAN_CFI_NCC_PERMITTED_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_SON_GERAN_CFI_NCC_PERMITTED_PRESENT absent");
        } 
        else if(!(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    bitmask & RRM_SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT absent");
        } 
        else if(!(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    bitmask & RRM_SON_GERAN_CFI_THRESHX_HIGH_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_GERAN_CFI_THRESHX_HIGH_PRESENT absent");
        }
        else if(!(p_meas_config_req_params->geran_freq_info_list[meas_req_index].
                    bitmask & RRM_SON_GERAN_CFI_THRESHX_LOW_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_GERAN_CFI_THRESHX_LOW_PRESENT absent");
        } 
    }
    RRM_UT_TRACE_EXIT();
    return mand_param_present;
}

/****************************************************************************
* Function Name  : rrmcm_check_cdma_mandatory_sib_and_meas_params_present
* Inputs         : rmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 meas_req_index: index of the Meas Config Req Geran list
*          of the freq to be compared
* Outputs        : None
* Returns        : RRM_FALSE if any of the mandatory params is absent and 
*          RRM_TRUE if all mandatory params are present
* Description    : This function checks if all the mandatory params reqd for
*          triggering Reconfig Req to RRC and creating a meas object 
*          node for the freq stored at meas_req_index in 
*          Meas Config Req are present in the req or not
****************************************************************************/
static rrm_bool_et
rrmcm_check_cdma_mandatory_sib_and_meas_params_present(
    rrmcm_rmif_cell_son_meas_config_req_t   *p_meas_config_req,
    U8                                      meas_req_index
    )
{
    rrm_bool_et                    mand_param_present        = RRM_TRUE;
    rrm_son_meas_config_cdma_t    *p_meas_config_req_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_meas_config_req_params = &(p_meas_config_req->meas_config_req.
            inter_rat_meas_config.cdma_config_list);
    /* Bug Fix 785 */
    if(!(((p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_PRE_REG_HRPD_INFO_PRESENT) ||
     (p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_1X_RTT_INFO_PRESENT)) &&
     (p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_SYS_TIME_INFO_PRESENT) &&
     (p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_SRCH_WNDO_SIZE_PRESENT)&&
     (p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CSFB_SUPPORT_FOR_DUAL_RX_UES_PRESENT)&&
     (p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CSFB_REG_PARAM_1XRTT_PRESENT)&&
     (p_meas_config_req->meas_config_req.inter_rat_meas_config.
           cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_AC_BARRING_CONFIG_1XRTT_PRESENT)))

    {
        mand_param_present = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "CDMA RESELECTION Params absent");
    }
    else if(RRM_NULL < p_meas_config_req_params->cdma_freq_info_list_size)
    {
        if(!(p_meas_config_req_params->cdma_freq_info_list[meas_req_index].bitmask 
                & RRM_SON_CDMA_FREQ_OFFSET_FREQ_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_CDMA_FREQ_OFFSET_FREQ_PRESENT absent");
        } 
        else if(!(p_meas_config_req_params->cdma_freq_info_list[meas_req_index].bitmask 
                & RRM_SON_CDMA_FREQ_CDMA_SRCH_WNDO_SIZE_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_CDMA_FREQ_CDMA_SRCH_WNDO_SIZE_PRESENT absent");
        } 
        else if(!(p_meas_config_req_params->cdma_freq_info_list[meas_req_index].bitmask 
                & RRM_SON_CDMA_RESELECTION_PRIORITY_PRESENT))
        {
            mand_param_present = RRM_FALSE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "RRM_SON_CDMA_RESELECTION_PRIORITY_PRESENT absent");
        } 
    }
    RRM_UT_TRACE_EXIT();
    return mand_param_present;
}



/****************************************************************************
* Function Name  : rrmcm_store_serv_cell_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          rrm_son_meas_config_eutran_t *p_meas_config_req_eutran_params:
*          Serving cell params received in Meas Config Req from SON
* Outputs        : None
* Returns        : None
* Description    : This function copies the serving cell param values received
*          in Meas Config Req from SON to the temp reconfig structure
****************************************************************************/
static rrm_void_t
rrmcm_store_serv_cell_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                        *p_meas_config_sib_info_for_reconfig,
    rrm_son_meas_config_eutran_t        *p_meas_config_req_eutran_params
    )
{
    RRM_UT_TRACE_ENTER();

    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_MEAS_BANDWIDTH_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->
        serv_cell_params.cell_reselection_info.bitmask |=
            RRMCM_RMIF_MEASUREMENT_BW_PRESENT;
	/*rrm_map_oam_bandwidth_value func written to remove warning, , rel2.0.1*/
        p_meas_config_sib_info_for_reconfig->
        serv_cell_params.cell_reselection_info.measurement_bandwidth
            = rrm_map_oam_bandwidth_value(p_meas_config_req_eutran_params->meas_bandwidth);
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_PRESENCE_ANTENNAE_PORT_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->
        serv_cell_params.cell_reselection_info.presence_antenna_port1
            = p_meas_config_req_eutran_params->presence_antenna_port;
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_NEIGHBOR_CELL_CONFIG_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.neigh_cell_config
            = p_meas_config_req_eutran_params->neighbor_cell_config;        
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_Q_RX_LEV_MIN_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_3
            = p_meas_config_req_eutran_params->q_rx_lev_min;        
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_P_MAX_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.bitmask |=
            RRMCM_RMIF_P_MAX_SIB3_PRESENT;

        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.p_max_sib_3
            = p_meas_config_req_eutran_params->p_max;        
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_RESELECTION_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.t_reselection_eutra
            = p_meas_config_req_eutran_params->t_reselection;  
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_RESELECTION_SF_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.bitmask |=
            RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT;
            
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.speed_scale_factors.
        t_reselection_eutra_sf_medium
            = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_eutran_params->t_reselection_sf.sf_medium;  
            
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.speed_scale_factors.
        t_reselection_eutra_sf_high
            = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_eutran_params->t_reselection_sf.sf_high;  
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_THRESHOLD_LOW_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.thresh_serving_low
            = p_meas_config_req_eutran_params->threshX_low;  
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.
        idle_mode_mobility_intra_freq_params.cell_reselection_priority
            = p_meas_config_req_eutran_params->cell_reselection_priority;  
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_Q_QUAL_MIN_R9)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.q_qualmin_r9 =
           p_meas_config_req_eutran_params->q_qualmin_r9;
        p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask |=
           RRMCM_SERV_CELL_Q_QUALMIN_R9_PRESENT; 
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_THRESHX_LOW_Q_R9)
    {
        p_meas_config_sib_info_for_reconfig->serv_cell_params.threshx_lowq_r9 =
           p_meas_config_req_eutran_params->threshx_lowq_r9;
        p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask |=
           RRMCM_SERV_CELL_THRESHX_LOWQ_R9_PRESENT; 
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_store_eutran_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          rrm_son_meas_config_eutran_t *p_meas_config_req_eutran_params:
*          Eutran params received in Meas Config Req from SON
*          arfcn_index : Index of the inter freq list in temp reconfig
*          struct where the param values are to be copied
* Outputs        : None
* Returns        : None
* Description    : This function copies the serving cell param values received
*          in Meas Config Req from SON to the temp reconfig structure.
****************************************************************************/
static rrm_void_t
rrmcm_store_eutran_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                        *p_meas_config_sib_info_for_reconfig,
    rrm_son_meas_config_eutran_t        *p_meas_config_req_eutran_params,
    U8                                  arfcn_index
    )
{
    RRM_UT_TRACE_ENTER();

    /* If new arfcn is to be added increment the list size */
    if(arfcn_index == p_meas_config_sib_info_for_reconfig->eutran_params.
            num_valid_inter_freq_list)
    {    
        p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list++; 

        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].eutra_carrier_arfcn = 
            p_meas_config_req_eutran_params->earfcn;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated num_valid_inter_freq_list = %d for adding new Earfcn = %d",
                p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list,
                p_meas_config_sib_info_for_reconfig->eutran_params.
                idle_mode_mobility_inter_freq_params[arfcn_index].eutra_carrier_arfcn);

    /* OFFSET FREQ CHANGES START */
        if(!(p_meas_config_req_eutran_params->bitmask &
            RRM_SON_EUTRAN_CM_OFFSET_FREQUENCY_PRESENT))
        {
            p_meas_config_sib_info_for_reconfig->eutran_params.
                idle_mode_mobility_inter_freq_params[arfcn_index].cm_offset_freq =
                p_meas_config_req_eutran_params->offset_frequency;

            p_meas_config_sib_info_for_reconfig->eutran_params.
                idle_mode_mobility_inter_freq_params[arfcn_index].bitmask |=
                RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT;
        }
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_CM_OFFSET_FREQUENCY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].cm_offset_freq =
            p_meas_config_req_eutran_params->cm_offset_frequency;

        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].bitmask |=
            RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT;
    }
    /* OFFSET FREQ CHANGES END */

    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_MEAS_BANDWIDTH_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.allowed_meas_bandwidth =
            p_meas_config_req_eutran_params->meas_bandwidth;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_PRESENCE_ANTENNAE_PORT_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.presence_antenna_port1 =
            p_meas_config_req_eutran_params->presence_antenna_port;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_NEIGHBOR_CELL_CONFIG_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
             neigh_cell_config =
            p_meas_config_req_eutran_params->neighbor_cell_config;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_OFFSET_FREQUENCY_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            q_offset_freq =
            p_meas_config_req_eutran_params->offset_frequency;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_Q_RX_LEV_MIN_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            q_rx_lev_min_sib_5 =
            p_meas_config_req_eutran_params->q_rx_lev_min;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_P_MAX_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].bitmask |=
            RRMCM_RMIF_P_MAX_PRESENT;
            
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            p_max =
            p_meas_config_req_eutran_params->p_max;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_RESELECTION_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            t_reselection_eutra =
            p_meas_config_req_eutran_params->t_reselection;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_RESELECTION_SF_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].bitmask |=
            RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1;
        
	/*coverity 16337, rel2.0.1 , */    
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            speed_scale_factors.t_reselection_eutra_sf_medium =
            (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_eutran_params->t_reselection_sf.sf_medium;
            
	/*coverity 16336, rel2.0.1 , */    
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            speed_scale_factors.t_reselection_eutra_sf_high =
            (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_eutran_params->t_reselection_sf.sf_high;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_THRESHOLD_HIGH_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            thresh_x_high =
            p_meas_config_req_eutran_params->threshX_high;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_THRESHOLD_LOW_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            thresh_x_low =
            p_meas_config_req_eutran_params->threshX_low;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].bitmask |=
            RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT;
            
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            cell_reselection_priority =
            p_meas_config_req_eutran_params->cell_reselection_priority;
    }
    if(p_meas_config_req_eutran_params->bitmask
            & RRM_SON_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT) 
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].bitmask |=
            RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT;
            
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            cell_reselection_priority =
            p_meas_config_req_eutran_params->cell_reselection_priority;
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_Q_QUAL_MIN_R9)
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.q_qual_min_r9 =
           p_meas_config_req_eutran_params->q_qualmin_r9;
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.bitmask |=
           RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT; 
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_THRESHX_LOW_Q_R9)
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.threshx_q_r9.thresh_serving_lowq_r9 =
           p_meas_config_req_eutran_params->threshx_lowq_r9;
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.bitmask |=
           RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT; 
    }
    if(p_meas_config_req_eutran_params->bitmask
        & RRM_SON_EUTRAN_THRESHX_HIGH_Q_R9)
    {
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.threshx_q_r9.thresh_serving_highq_r9 =
           p_meas_config_req_eutran_params->threshx_highq_r9;
        p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params[arfcn_index].
            inter_freq_params_op_specific.bitmask |=
           RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT; 
    }

    RRM_UT_TRACE_EXIT(); 
}

/****************************************************************************
* Function Name  : rrmcm_store_utran_reselection_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          rrm_son_meas_config_utran_t *p_meas_config_req_utran_params:
*          Utran reselection params received in Meas Config Req from SON
* Outputs        : None
* Returns        : None
* Description    : This function copies the Utran reselection param values 
*          received in Meas Config Req from SON to the temp reconfig
*          structure
****************************************************************************/
static
rrm_void_t rrmcm_store_utran_reselection_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    rrm_son_meas_config_utran_t        *p_meas_config_req_utran_params
    )
{
    RRM_UT_TRACE_ENTER();

    if(p_meas_config_req_utran_params->bitmask
            & RRM_SON_UTRAN_RESELECTION_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.t_reselection_utra
            = p_meas_config_req_utran_params->t_reselection;
    }
    if(p_meas_config_req_utran_params->bitmask
            & RRM_SON_UTRAN_RESELECTION_SF_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.bitmask |= 
            RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
            t_reselection_eutra_sf_medium
            = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_utran_params->t_reselection_sf.sf_medium;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.speed_state_scale_factor.
            t_reselection_eutra_sf_high
            = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_utran_params->t_reselection_sf.sf_high;
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_store_utran_fdd_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          U8 arfcn_index : Index of the inter freq list in temp reconfig
*          struct where the param values are to be copied
*          rrm_son_meas_config_utran_t *p_meas_config_req_utran_params:
*          Utran params received in Meas Config Req from SON
*          U8 meas_req_index: Index of the freq in Meas Config Req
*          Geran list from where the param values are to be copied
* Outputs        : None
* Returns        : None
* Description    : This function copies the Utran freq param values received
*          in Meas Config Req from SON to the temp reconfig structure.
****************************************************************************/
static 
rrm_void_t rrmcm_store_utran_fdd_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    U8                                  arfcn_index,
    rrm_son_meas_config_utran_t        *p_meas_config_req_utran_params,
    U8                                  meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    /* If new arfcn is to be added increment the list size */
    if(arfcn_index == p_meas_config_sib_info_for_reconfig->utran_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers)
    {
        /* SPR 22731 Fix Start */
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            bitmask |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT;
        /* SPR 22731 Fix End */
        
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers++;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].utra_carrier_arfcn =
            p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].uarfcn;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated num_irat_eutran_to_utran_fdd_carriers = %d for adding new"
                " FDD Uarfcn = %d", p_meas_config_sib_info_for_reconfig->utran_params.
                idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers,
                p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[arfcn_index].utra_carrier_arfcn);

        /* OFFSET FREQ CHANGES START */
        if(!(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask &
                    RRM_SON_UTRAN_OFFSET_FREQUENCY_PRESENT))
        {
            p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[arfcn_index].offset_freq
                = RRM_OAM_Q_OFFESET_RANGE_DB0;

            p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[arfcn_index].bitmask
                |= RRMCM_RMIF_OFFSET_FREQ_PRESENT;
        } 
    }

    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_OFFSET_FREQUENCY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[arfcn_index].offset_freq 
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].offset_frequency;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[arfcn_index].bitmask
            |= RRMCM_RMIF_OFFSET_FREQ_PRESENT;
    }
    /* OFFSET FREQ CHANGES END */

    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_CELL_RESELECTION_PRIORITY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[arfcn_index].
            bitmask |= RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].cell_reselection_priority 
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].
            cell_reselection_priority;
    }
    /*Coverity_fix_start_62520*/
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_THRESHOLD_HIGH_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].thresh_x_high
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].threshX_high;
    }
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_THRESHOLD_LOW_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].thresh_x_low
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].threshX_low;
    }
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_Q_RX_LEV_MIN_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].q_rx_lev_min 
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].q_rx_lev_min;
    }
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_P_MAX_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].p_max_utra
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].p_max;
    }
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_Q_QUAL_MIN_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].q_qual_min 
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].q_qual_min;
    }
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_THRESHX_LOW_Q_R9)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].threshx_q_r9.thresh_serving_lowq_r9 
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].threshx_lowq_r9;
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].bitmask |= 
            RRMCM_RMIF_THRESHX_Q_R9_PRESENT; 
    }
    if(p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_THRESHX_HIGH_Q_R9)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].threshx_q_r9.thresh_serving_highq_r9 
            = p_meas_config_req_utran_params->utran_fdd_list[meas_req_index].threshx_highq_r9;
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[arfcn_index].bitmask |= 
            RRMCM_RMIF_THRESHX_Q_R9_PRESENT; 
    }
    RRM_UT_TRACE_EXIT();
    /*Coverity_fix_end_62520*/
}

/* TDD Support SON Start */
/****************************************************************************
* Function Name  : rrmcm_store_utran_tdd_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          U8 arfcn_index : Index of the inter freq list in temp reconfig
*          struct where the param values are to be copied
*          rrm_son_meas_config_utran_t *p_meas_config_req_utran_params:
*          Utran params received in Meas Config Req from SON
*          U8 meas_req_index: Index of the freq in Meas Config Req
*          Geran list from where the param values are to be copied
* Outputs        : None
* Returns        : None
* Description    : This function copies the TDD Utran freq param values received
*          in Meas Config Req from SON to the temp reconfig structure.
****************************************************************************/
static 
rrm_void_t rrmcm_store_utran_tdd_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    U8                                  arfcn_index,
    rrm_son_meas_config_utran_t        *p_meas_config_req_utran_params,
    U8                                  meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    /* If new arfcn is to be added increment the list size */
        if(arfcn_index == p_meas_config_sib_info_for_reconfig->utran_params.
                idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers)
        {
            /* SPR 22731 Fix Start */
            p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                bitmask |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT;
            /* SPR 22731 Fix End */

            p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers++;

            p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[arfcn_index].utra_carrier_arfcn =
                p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].uarfcn;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Updated num_irat_eutran_to_utran_tdd_carriers = %d for adding new"
                    " TDD Uarfcn = %d", p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers,
                    p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[arfcn_index].utra_carrier_arfcn);

    /* OFFSET FREQ CHANGES START */
            if(!(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask &
                RRM_SON_UTRAN_TDD_OFFSET_FREQUENCY_PRESENT))
            {
                p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[arfcn_index].offset_freq
                    = RRM_OAM_Q_OFFESET_RANGE_DB0;

                p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
                    irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[arfcn_index].bitmask
                    |= RRMCM_RMIF_OFFSET_FREQ_PRESENT;
            } 
        }

    if(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_TDD_OFFSET_FREQUENCY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[arfcn_index].offset_freq 
            = p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].offset_frequency;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[arfcn_index].bitmask
            |= RRMCM_RMIF_OFFSET_FREQ_PRESENT;
    }
    /* OFFSET FREQ CHANGES END */

    if(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_TDD_CELL_RESELECTION_PRIORITY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[arfcn_index].
            bitmask |= RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT;

        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[arfcn_index].cell_reselection_priority 
            = p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].
            cell_reselection_priority;
    }
    if(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_TDD_THRESHOLD_HIGH_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[arfcn_index].thresh_x_high
            = p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].threshX_high;
    }
    if(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_TDD_THRESHOLD_LOW_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[arfcn_index].thresh_x_low
            = p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].threshX_low;
    }
    if(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[arfcn_index].q_rx_lev_min 
            = p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].q_rx_lev_min;
    }
    if(p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].bitmask
            & RRM_SON_UTRAN_TDD_P_MAX_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[arfcn_index].p_max_utra
            = p_meas_config_req_utran_params->utran_tdd_list[meas_req_index].p_max;
    }

    RRM_UT_TRACE_EXIT();
}
/* TDD Support SON End */



/****************************************************************************
* Function Name  : rrmcm_store_geran_reselection_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          rrm_son_meas_config_geran_t *p_meas_config_req_geran_params:
*          Geran reselection params received in Meas Config Req from SON
* Outputs        : None
* Returns        : None
* Description    : This function copies the Geran reselection param values 
*          received in Meas Config Req from SON to the temp reconfig
*          structure
****************************************************************************/
static rrm_void_t
rrmcm_store_geran_reselection_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    rrm_son_meas_config_geran_t        *p_meas_config_req_geran_params
    )
{
    RRM_UT_TRACE_ENTER();

    if(p_meas_config_req_geran_params->bitmask
            & RRM_SON_MC_GERAN_T_RESELECTION_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.t_reselection_geran
            = p_meas_config_req_geran_params->t_reselection;
    }
    if(p_meas_config_req_geran_params->bitmask
            & RRM_SON_MC_GERAN_T_RESELECTION_SF_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.bitmask |=
            RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
            t_reselection_eutra_sf_medium
            = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_geran_params->t_reselection_sf.sf_medium;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.speed_state_scale_factor.
            t_reselection_eutra_sf_high
            = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_geran_params->t_reselection_sf.sf_high;
    }
    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
* Function Name  : rrmcm_store_cdma_reselection_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          rrm_son_meas_config_cdma_t *p_meas_config_req_cdma_params:
*          Geran reselection params received in Meas Config Req from SON
* Outputs        : None
* Returns        : None
* Description    : This function copies the cdma reselection param values 
*          received in Meas Config Req from SON to the temp reconfig
*          structure
****************************************************************************/
static rrm_void_t
rrmcm_store_cdma_reselection_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    rrm_son_meas_config_cdma_t        *p_meas_config_req_cdma_params
    )
{
    U8                                            pre_reg_info_index          = RRM_NULL;
    U8                                            pre_reg_info_size           = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    

    if(p_meas_config_req_cdma_params->bitmask
            & RRM_SON_MEAS_CONFIG_CDMA_SRCH_WNDO_SIZE_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.search_window_size 
            = p_meas_config_req_cdma_params->srch_wnd_size;

    }
 
    if(p_meas_config_req_cdma_params->bitmask
            & RRM_SON_MEAS_CONFIG_CSFB_SUPPORT_FOR_DUAL_RX_UES_PRESENT)
    {
         p_meas_config_sib_info_for_reconfig->cdma_params.
               idle_mode_mobility_irat_cdma_params.csfb_support_for_dual_rx_ues_r9
                = p_meas_config_req_cdma_params->csfb_support_for_dual_Rx_Ues_r9;
    }
    
    if(p_meas_config_req_cdma_params->bitmask
            & RRM_SON_MEAS_CONFIG_AC_BARRING_CONFIG_1XRTT_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_0_to_9_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_0_to_9_r9;
        
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_10_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_10_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_11_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_11_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_12_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_12_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_13_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_13_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_14_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_14_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_15_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_15_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_msg_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_msg_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_reg_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_reg_r9;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.ac_barring_config_1_xrtt_r9.ac_barring_emg_r9
            = p_meas_config_req_cdma_params->ac_barring_config_1xrtt_r9.ac_barring_emg_r9;

   }
 
    if(p_meas_config_req_cdma_params->bitmask
            & RRM_SON_MEAS_CONFIG_CDMA_PRE_REG_HRPD_INFO_PRESENT )
    {
        if(p_meas_config_req_cdma_params->hrpd_info.bitmask
                & RRM_SON_CDMA_HRPD_REG_PARAMS_PRESENT)
        {
            p_meas_config_sib_info_for_reconfig->cdma_params.
                 idle_mode_mobility_irat_cdma_params.pre_reg_info_hrpd.pre_reg_allowed
                 = p_meas_config_req_cdma_params->hrpd_info.hrpd_reg_params.pre_reg_allowed;

            if(p_meas_config_req_cdma_params->hrpd_info.hrpd_reg_params.bitmask
                    & RRM_SON_HRPD_PRE_REG_ZONE_ID_PRESENT)
            {
                p_meas_config_sib_info_for_reconfig->cdma_params.
                    idle_mode_mobility_irat_cdma_params.pre_reg_info_hrpd.pre_reg_zone_id
                    = p_meas_config_req_cdma_params->hrpd_info.hrpd_reg_params.pre_reg_zone_id;
            }
 
            if(p_meas_config_req_cdma_params->hrpd_info.hrpd_reg_params.bitmask
                    & RRM_SON_HRPD_PRE_REG_ZONE_ID_PRESENT)
            {
                pre_reg_info_size = p_meas_config_req_cdma_params->hrpd_info.hrpd_reg_params.
                                    scndry_pre_reg_zone_id_list_size;
                p_meas_config_sib_info_for_reconfig->cdma_params.
                      idle_mode_mobility_irat_cdma_params.pre_reg_info_hrpd.
                      secondary_list.count = pre_reg_info_size;

                for(pre_reg_info_index = RRM_NULL;  
                      pre_reg_info_index < pre_reg_info_size && pre_reg_info_index < RRM_SON_MAX_SEC_PRE_REG_ZONES; 
                      pre_reg_info_index++)
                {
                    p_meas_config_sib_info_for_reconfig->cdma_params.
                        idle_mode_mobility_irat_cdma_params.pre_reg_info_hrpd.
                        secondary_list.pre_reg_zone_id[pre_reg_info_index]
                        = p_meas_config_req_cdma_params->hrpd_info.hrpd_reg_params.
                             scndry_pre_reg_zone_id_list[pre_reg_info_index];
                }
            
            }
        }

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.t_reselection_cdma2000
            = p_meas_config_req_cdma_params->hrpd_info.t_reselection;

        if(p_meas_config_req_cdma_params->hrpd_info.bitmask
                & RRM_SON_CDMA_HRPD_RESELECTION_SF_PRESENT)
        {

            /* coverity : CID 30991,30990 */
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                t_reselection_cdma2000_sf.t_reselection_eutra_sf_medium
                = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_cdma_params->hrpd_info.t_reselection_sf.sf_medium;

            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                t_reselection_cdma2000_sf.t_reselection_eutra_sf_high
                = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_cdma_params->hrpd_info.t_reselection_sf.sf_high;

        }
    }
 
   if(p_meas_config_req_cdma_params->bitmask
            & RRM_SON_MEAS_CONFIG_CDMA_1X_RTT_INFO_PRESENT )
    {
        if(p_meas_config_req_cdma_params->cdma_1xrtt_info.bitmask
                & RRM_SON_CDMA_1XRTT_REG_PARAMS_PRESENT)
        {
            RRM_MEMCPY(&(p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.sid),
                 &(p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.sid),
                 sizeof(U16));

            RRM_MEMCPY(&(p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.nid),
                 &(p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.nid),
                 sizeof(U16));
            
            /* SPR 7514 CDMA Fix Start */ 
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.multiple_sid
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.multiple_sid;


            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.multiple_nid
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.multiple_nid;
            /* SPR 7514 CDMA Fix End */

            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.home_reg
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.home_reg;

             p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.foreign_sid_reg
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.foreign_sid_reg;

            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.foreign_nid_reg
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.foreign_nid_reg;


            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.parame_reg
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.parameter_reg;


            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.power_up_reg
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.power_up_reg;

             p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.reg_prd
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.reg_period;

            RRM_MEMCPY(&(p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.reg_zone),
                &(p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.reg_zone),
                sizeof(U16));


            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.total_zone[RRM_NULL]
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.total_zone;


            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.zone_timer[RRM_NULL]
                = p_meas_config_req_cdma_params->cdma_1xrtt_info.xrtt_reg_params.zone_timer;
 
        }
 
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.t_reselection_cdma2000
            = p_meas_config_req_cdma_params->cdma_1xrtt_info.t_reselection;

        if(p_meas_config_req_cdma_params->cdma_1xrtt_info.bitmask
                & RRM_SON_CDMA_1XRTT_RESELECTION_SF_PRESENT)
        {
            /* coverity : CID 30989,30988 */
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                t_reselection_cdma2000_sf.t_reselection_eutra_sf_medium
                = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_cdma_params->cdma_1xrtt_info.t_reselection_sf.sf_medium;

            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                t_reselection_cdma2000_sf.t_reselection_eutra_sf_high
                = (rrm_oam_speed_state_scale_factors_et)p_meas_config_req_cdma_params->cdma_1xrtt_info.t_reselection_sf.sf_high;

        }
    }
          
   if(p_meas_config_req_cdma_params->bitmask
           & RRM_SON_MEAS_CONFIG_CSFB_REG_PARAM_1XRTT_PRESENT )
   {
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.mobility_sib_8_params.power_down_reg
            = p_meas_config_req_cdma_params->csfb_registration_param_1xrtt_r9.power_down_reg_r9;
   }




    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
* Function Name  : rrmcm_store_geran_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          U8 arfcn_index : Index of the inter freq list in temp reconfig
*          struct where the param values are to be copied
*          rrm_son_meas_config_geran_t *p_meas_config_req_geran_params:
*          Geran params received in Meas Config Req from SON
*          U8 meas_req_index: Index of the freq in Meas Config Req
*          Geran list from where the param values are to be copied
* Outputs        : None
* Returns        : None
* Description    : This function copies the Geran freq param values received
*          in Meas Config Req from SON to the temp reconfig structure.
****************************************************************************/
static rrm_void_t
rrmcm_store_geran_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    U8                                  arfcn_index,
    rrm_son_meas_config_geran_t        *p_meas_config_req_geran_params,
    U8                                  meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();

    /* If new arfcn is to be added increment the list size */
    if(arfcn_index == p_meas_config_sib_info_for_reconfig->geran_params.
            idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers)
    {
        /* SPR 22731 Fix Start */
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            bitmask |= RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT;
        /* SPR 22731 Fix End */

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers++;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.starting_arfcn
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.starting_arfcn;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated num_irat_eutran_to_geran_carriers = %d for adding new"
                " Geran arfcn = %d", p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.
                irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers,
                p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                irat_eutran_to_geran_carriers[arfcn_index].geran_car_freqs.
                starting_arfcn);

    /* OFFSET FREQ CHANGES START */
        if(!(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
                    bitmask & RRM_SON_GERAN_CFI_OFFSET_FREQ_PRESENT))
        {
            p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
                irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
                offset_freq = RRM_OAM_Q_OFFESET_RANGE_DB0; 

            p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
                irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
                bitmask |= RRMCM_GERAN_OFFSET_FREQ_PRESENT; 
        } 
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_OFFSET_FREQ_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            offset_freq 
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            offset_frequency;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            bitmask |= RRMCM_GERAN_OFFSET_FREQ_PRESENT; 
    }
    /* OFFSET FREQ CHANGES END */

    p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
        irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
        geran_car_freqs.band_ind
        = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
        geran_car_freqs.band_ind;

    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.bitmask & 
            RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.bitmask |=
            RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.exp_arfcn_list_size            
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.exp_arfcn_list_size;

        RRM_MEMCPY(p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.
                irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
                geran_car_freqs.following_arfcns.exp_arfcn_list, 
                p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
                geran_car_freqs.following_arfcns.exp_arfcn_list,
                sizeof(U16) * RRM_SON_MAX_GERAN_EXP_ARFCN_LIST_SIZE);
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.bitmask & 
            RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.bitmask |=
            RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.arfcn_spacing
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.arfcn_spacing;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.num_of_following_arfcn
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.num_of_following_arfcn;
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.bitmask & 
            RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.bitmask |=
            RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            geran_car_freqs.following_arfcns.arfcn_bmp_list_size
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            geran_car_freqs.following_arfcns.arfcn_bmp_list_size;

        RRM_MEMCPY(p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.
                irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
                geran_car_freqs.following_arfcns.arfcn_bmp_list, 
                p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
                geran_car_freqs.following_arfcns.arfcn_bmp_list,
                sizeof(U8) * RRM_SON_MAX_NUM_OF_OCTETS_IN_VAR_BITMAP);
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].bitmask |=
            RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            cell_reselection_priority
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            cell_reselection_priority;
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_NCC_PERMITTED_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            ncc_permitted
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            ncc_permitted;
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            q_rx_lev_min
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            q_rx_lev_min;
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_MAX_ALLOWED_TRANS_PWR_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].bitmask |=
            RRMCM_GERAN_P_MAX_GERAN_PRESENT;

        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            p_max_geran
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            p_max_geran;
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_THRESHX_HIGH_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            threshX_high
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            threshX_high;
    }
    if(p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            bitmask & RRM_SON_GERAN_CFI_THRESHX_LOW_PRESENT)
    {
        p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[arfcn_index].
            threshX_low
            = p_meas_config_req_geran_params->geran_freq_info_list[meas_req_index].
            threshX_low;
    }
   
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_store_cdma_sib_params_in_cell_ctx 
* Inputs         : rrmcm_meas_config_sib_info_for_reconfig_t
*          *p_meas_config_sib_info_for_reconfig:
*          Pointer to the temporary structure where SIB info reqd to 
*          trigger reconfig is to be stored 
*          U8 arfcn_index : Index of the inter freq list in temp reconfig
*          struct where the param values are to be copied
*          rrm_son_meas_config_cdma_t *p_meas_config_req_cdma_params:
*          Geran params received in Meas Config Req from SON
*          U8 meas_req_index: Index of the freq in Meas Config Req
*          Geran list from where the param values are to be copied
* Outputs        : None
* Returns        : None
* Description    : This function copies the CDMA freq param values received
*          in Meas Config Req from SON to the temp reconfig structure.
****************************************************************************/
static rrm_void_t
rrmcm_store_cdma_sib_params_in_cell_ctx(
    rrmcm_meas_config_sib_info_for_reconfig_t
                                       *p_meas_config_sib_info_for_reconfig,
    U8                                  arfcn_index,
    S8                                 cell_ctx_index,  /* CID: 55181 - Fix: S8 type caught in U8 */
    rrm_son_meas_config_cdma_t        *p_meas_config_req_cdma_params,
    U8                                  meas_req_index
    )
{
    RRM_UT_TRACE_ENTER();
    /* If new arfcn is to be added increment the list size */
    if(arfcn_index == p_meas_config_sib_info_for_reconfig->cdma_params.
            num_valid_cdma2000_freq_cells)
    {
        p_meas_config_sib_info_for_reconfig->cdma_params.
            cdma2000_freq_cells[arfcn_index].arfcn 
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].arfcn;

        p_meas_config_sib_info_for_reconfig->cdma_params.
            cdma2000_freq_cells[arfcn_index].band_class 
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].band_class;

        /* coverity : CID 30994 */
        p_meas_config_sib_info_for_reconfig->cdma_params.
            cdma2000_freq_cells[arfcn_index].type 
            = (rrm_oam_ncl_type_et)p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].cdma_type;


         p_meas_config_sib_info_for_reconfig->cdma_params.
                         num_valid_cdma2000_freq_cells++;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated valid_cdma2000_freq_cells = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->
                cdma_params.num_valid_cdma2000_freq_cells,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);
                
    }
    
        

    if(p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            cdma_type == R_TYPE_HRPD)
    {
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                band_class_list.count++;
 
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
            band_class_list.band_class_info_cdma2000[cell_ctx_index].band_class
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            band_class;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated band_class = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].band_class,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);
        if(p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].bitmask
                & RRM_SON_CDMA_RESELECTION_PRIORITY_PRESENT)
        {
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].cell_reselection_priority
                = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
                cell_reselection_priority;

            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].presence_bitmask 
                |= RRMCM_RMIF_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Updated cell_reselection_priority = %d for adding new"
                    " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                    idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                    band_class_list.band_class_info_cdma2000[cell_ctx_index].
                    cell_reselection_priority,
                    p_meas_config_sib_info_for_reconfig->cdma_params.
                    cdma2000_freq_cells[arfcn_index].arfcn);
 
        }

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
            band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_high
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            threshX_high;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated thresh_x_high = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_high,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
            band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_low
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            threshX_low;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated thresh_x_low = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_low,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);
        

    }


 
    if(p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            cdma_type == R_TYPE_1X_RTT)
    {
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                band_class_list.count++;
 
        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
            band_class_list.band_class_info_cdma2000[cell_ctx_index].band_class
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            band_class;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated band_class = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].band_class,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);
        
        if(p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].bitmask
                & RRM_SON_CDMA_RESELECTION_PRIORITY_PRESENT)
        {
            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].cell_reselection_priority
                = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
                cell_reselection_priority;

            p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].presence_bitmask 
                |= RRMCM_RMIF_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;



            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Updated cell_reselection_priority = %d for adding new"
                    " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                    idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                    band_class_list.band_class_info_cdma2000[cell_ctx_index].
                    cell_reselection_priority,
                    p_meas_config_sib_info_for_reconfig->cdma_params.
                    cdma2000_freq_cells[arfcn_index].arfcn);

        }

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
            band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_high
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            threshX_high;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated thresh_x_high = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_high,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);
        

        p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
            band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_low
            = p_meas_config_req_cdma_params->cdma_freq_info_list[meas_req_index].
            threshX_low;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updated thresh_x_low = %d for adding new"
                " CDMA arfcn = %d", p_meas_config_sib_info_for_reconfig->cdma_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt.
                band_class_list.band_class_info_cdma2000[cell_ctx_index].thresh_x_low,
                p_meas_config_sib_info_for_reconfig->cdma_params.
                cdma2000_freq_cells[arfcn_index].arfcn);
        
    } 
        
    RRM_UT_TRACE_EXIT();
}




/****************************************************************************
* Function Name  : rrmcm_check_utran_fdd_presence_in_cell_ctx 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if at least 1 freq is configured at RRM or present
*          in temp reconfig struct otherwise RRM_FALSE
* Description    : This function checks if any of the freq is configured in 
*          Utran Fdd list of RRM or in the temp reconfig struct.
****************************************************************************/
static rrm_bool_et
rrmcm_check_utran_fdd_presence_in_cell_ctx(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    rrm_bool_et     ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if((p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT) &&
                (p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                 idle_mode_mobility_irat_utra_params.bitmask &
                 RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT))
    {
        ret_val = RRM_TRUE;
    }
    else
    {
        ret_val = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* TDD Support SON Start */
/****************************************************************************
* Function Name  : rrmcm_check_utran_tdd_presence_in_cell_ctx 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if at least 1 freq is configured at RRM or present
*          in temp reconfig struct otherwise RRM_FALSE
* Description    : This function checks if any of the freq is configured in 
*          Utran TDD list of RRM or in the temp reconfig struct.
****************************************************************************/
static rrm_bool_et
rrmcm_check_utran_tdd_presence_in_cell_ctx(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    rrm_bool_et     ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if((p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT) &&
                (p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                 idle_mode_mobility_irat_utra_params.bitmask &
                 RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT))
    {
        ret_val = RRM_TRUE;
    }
    else
    {
        ret_val = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TDD Support SON End */

/****************************************************************************
* Function Name  : rrmcm_check_geran_freq_presence_in_cell_ctx 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if at least 1 freq is configured at RRM or present
*          in temp reconfig struct otherwise RRM_FALSE
* Description    : This function checks if any of the freq is configured in 
*          Geran freq list of RRM or in the temp reconfig struct.
****************************************************************************/
static rrm_bool_et
rrmcm_check_geran_freq_presence_in_cell_ctx(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    rrm_bool_et     ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if((p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT) &&
                (p_cell_ctx->ran_info.mobility_params.
                 idle_mode_mobility_params.
                 idle_mode_mobility_irat_geran_params.bitmask &
                 RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT)) 
    {
        ret_val = RRM_TRUE;
    }
    else
    {
        ret_val = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
* Function Name  : rrmcm_check_cdma_freq_presence_in_cell_ctx 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_TRUE if at least 1 freq is configured at RRM or present
*          in temp reconfig struct otherwise RRM_FALSE
* Description    : This function checks if any of the freq is configured in 
*          CDMA freq list of RRM or in the temp reconfig struct.
****************************************************************************/
static rrm_bool_et
rrmcm_check_cdma_freq_presence_in_cell_ctx(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    rrm_bool_et     ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                 bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT) 
    {
        ret_val = RRM_TRUE;
    }
    else
    {
        ret_val = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
* Function Name  : rrmcm_copy_serv_cell_params_to_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : This function copies the configured values of serving cell
*          params at RRM to temp reconfig struct
****************************************************************************/
static rrm_void_t
rrmcm_copy_serv_cell_params_to_reconfig_struct(
        rrm_cell_context_t                       *p_cell_ctx
    )
{
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);
    }

    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                serv_cell_params.cell_reselection_info),
            &(p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info),
            sizeof(rrm_intra_freq_cell_reselection_info_t));

    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                serv_cell_params.idle_mode_mobility_intra_freq_params),
            &(p_cell_ctx->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params),
            sizeof(intra_freq_params_t));

    if(p_cell_ctx->operator_info.sib_3_info.bitmask & 
                RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1)
    {
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.q_qualmin_r9 =
            p_cell_ctx->operator_info.sib_3_info.q_qual_min_r9;
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask |=
           RRMCM_SERV_CELL_Q_QUALMIN_R9_PRESENT; 
    }
    if(p_cell_ctx->operator_info.sib_3_info.bitmask & 
                RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
    {
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.threshx_lowq_r9 =
            p_cell_ctx->operator_info.sib_3_info.thresh_serving_lowq_r9;
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask |=
           RRMCM_SERV_CELL_THRESHX_LOWQ_R9_PRESENT; 
    }
    p_cell_ctx->p_meas_config_sib_info_for_reconfig->
        bitmask |= RRMCM_SERV_CELL_PARAMS_PRESENT;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Params for Configured INTRA frequency at RRM copied to "
            "reconfig struct");

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_copy_eutra_params_to_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : This function copies the configured values of eutra 
*          reselection and freq params at RRM to temp reconfig struct
****************************************************************************/
static rrm_void_t
rrmcm_copy_eutra_params_to_reconfig_struct(
    rrm_cell_context_t                       *p_cell_ctx
    )
{
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);
    }

    p_cell_ctx->p_meas_config_sib_info_for_reconfig->
        bitmask |= RRMCM_INTER_FREQ_PARAMS_PRESENT;

    /* Copy all inter freq params to 
       p_meas_config_sib_info_for_reconfig */
    p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
        num_valid_inter_freq_list = 
        p_cell_ctx->ran_info.mobility_params.
        idle_mode_mobility_params.num_valid_inter_freq_list;

    RRM_MEMCPY(p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
            idle_mode_mobility_inter_freq_params,
            p_cell_ctx->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params,
            sizeof(inter_freq_params_t) * MAX_NO_INTER_FREQ);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Params for Configured EUTRA frequencies at RRM copied to "
            "reconfig struct");
            
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_copy_utra_params_to_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : This function copies the configured values of utra 
*          freq params at RRM to temp reconfig struct
****************************************************************************/
static rrm_void_t
rrmcm_copy_utra_params_to_reconfig_struct(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    RRM_UT_TRACE_ENTER();
    
    if(RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);
    }

    p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
        RRMCM_UTRA_FREQ_PARAMS_PRESENT;

    /* Fix 8172 Start */
    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
        idle_mode_mobility_irat_utra_params),
        &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params),
        sizeof(idle_mode_mobility_irat_utra_params_t));
    /* Fix 8172 End */
    
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Params for Configured UTRA frequencies at RRM copied to "
            "reconfig struct");
            
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
* Function Name  : rrmcm_copy_cdma_reselection_params_to_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : This function copies the configured values of cdma
*          reselection params at RRM to temp reconfig struct
****************************************************************************/
static rrm_void_t
rrmcm_copy_cdma_reselection_params_to_reconfig_struct(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    RRM_UT_TRACE_ENTER();
    
    if(RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);
    }

    p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
        RRMCM_CDMA_FREQ_PARAMS_PRESENT;

    p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.num_valid_cdma2000_freq_cells 
        = p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_cdma2000_freq_cells;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "num_valid_cdma2000_freq_cells in ran_info = %d  "
            "num_valid_cdma2000_freq_cells in reconfig_sib_info = %d",
            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_cdma2000_freq_cells,
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.num_valid_cdma2000_freq_cells);
   
/* prabhat's review start: we can copy the whole idle mode params at once */
    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params), 
             &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_cdma_params),
            sizeof(rrmcm_idle_mode_mobility_irat_cdma_params_t));
/* prabhat's review end */

    rrm_cpy_cdma2000_freq_cells(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
            p_cell_ctx->p_meas_config_sib_info_for_reconfig);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Reselection Params for Configured CDMA frequencies at RRM copied to "
            "reconfig struct");
       
    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
* Function Name  : rrmcm_copy_geran_params_to_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : This function copies the configured values of geran 
*          freq params at RRM to temp reconfig struct
****************************************************************************/
static rrm_void_t
rrmcm_copy_geran_params_to_reconfig_struct(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    RRM_UT_TRACE_ENTER();
    
    if(RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);
    }

    p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
        RRMCM_GERAN_FREQ_PARAMS_PRESENT;

    /* Copy entire GERAN params */
    /* Fix 8172 Start */
    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
        idle_mode_mobility_irat_geran_params),
        &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_geran_params),
        sizeof(idle_mode_mobility_irat_geran_params_t));
    /* Fix 8172 End */

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Params for Configured GERAN frequencies at RRM copied to "
            "reconfig struct");
            
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
* Function Name  : rrmcm_copy_cdma_params_to_reconfig_struct 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : This function copies the configured values of cdma 
*          freq params at RRM to temp reconfig struct
****************************************************************************/
static rrm_void_t
rrmcm_copy_cdma_params_to_reconfig_struct(
    rrm_cell_context_t                       *p_cell_ctx
)
{
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL == p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
        rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);
    }

    p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
        RRMCM_CDMA_FREQ_PARAMS_PRESENT;
    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd), 
            &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd),
            sizeof(rrmcm_rmif_cell_reselection_params_cdma2000_t));

    RRM_MEMCPY(&(p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
            idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt), 
            &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_cdma_params.cell_reselection_params_1xrtt),
            sizeof(rrmcm_rmif_cell_reselection_params_cdma2000_t));

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Params for Configured CDMA frequencies at RRM copied to "
            "reconfig struct");
    RRM_UT_TRACE_EXIT();
}




static rrm_bool_et
rrmcm_handle_meas_config_utran_reselection_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_return_et                            *p_state_validation
)
{
    rrm_bool_et                      params_differ = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    params_differ = rrmcm_compare_meas_config_utran_reselection_sib_params(
            p_cell_ctx, p_meas_config_req);

    /* if different configuration is present at RRM */
    if(RRM_TRUE == params_differ)
    {
        if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code)) /*Kshitij 13568 rel1.3*/
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Cell state not valid to trigger reconfig. Sending failure to SON");
            *p_state_validation = RRM_FAILURE;
        }
        else
        {
            /* Fix 8172 Start */
            rrmcm_copy_utra_params_to_reconfig_struct(p_cell_ctx);
            /* Fix 8172 End */

            rrmcm_store_utran_reselection_sib_params_in_cell_ctx(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                    &(p_meas_config_req->meas_config_req.
                        inter_rat_meas_config.utran_config_list));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Reconfig reqd for UTRA Reselection params");
            *p_state_validation = RRM_SUCCESS;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}

static rrm_bool_et
rrmcm_handle_meas_config_geran_reselection_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_error_et                             *p_error_code,/* Coverity_ID : 16486 */
    rrm_return_et                            *p_state_validation
)
{
    rrm_bool_et                      params_differ = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    params_differ = rrmcm_compare_meas_config_geran_reselection_sib_params(
            p_cell_ctx, p_meas_config_req);

    /* if different configuration is present at RRM */
    if(RRM_TRUE == params_differ)
    {
        if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code)) /*Kshitij 13566 rel1.3*/
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Cell state not valid to trigger reconfig. Sending failure to SON");
            *p_state_validation = RRM_FAILURE;
        }
        else
        {
            /* Fix 8172 Start */
            rrmcm_copy_geran_params_to_reconfig_struct(p_cell_ctx);
            /* Fix 8172 End */

            rrmcm_store_geran_reselection_sib_params_in_cell_ctx(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                    &(p_meas_config_req->meas_config_req.
                        inter_rat_meas_config.geran_config_list));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Reconfig reqd for GERAN Reselection params");
            *p_state_validation = RRM_SUCCESS;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}

static rrm_bool_et
rrmcm_handle_meas_config_cdma_reselection_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_return_et                            *p_state_validation
)
{
    rrm_bool_et                      params_differ = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    params_differ = rrmcm_compare_meas_config_cdma_reselection_sib_params(
            p_cell_ctx, p_meas_config_req);

    /* if different configuration is present at RRM */
    if(RRM_TRUE == params_differ)
    {
        if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code)) /*Kshitij 13566 rel1.3*/
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Cell state not valid to trigger reconfig. Sending failure to SON");
            *p_state_validation = RRM_FAILURE;
        }
        else
        {
            rrmcm_copy_cdma_reselection_params_to_reconfig_struct(p_cell_ctx);

            rrmcm_store_cdma_reselection_sib_params_in_cell_ctx(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                    &(p_meas_config_req->meas_config_req.
                        inter_rat_meas_config.cdma_config_list));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Reconfig reqd for cdma Reselection params");
            *p_state_validation = RRM_SUCCESS;
        }
    }
    RRM_UT_TRACE_EXIT();
    return params_differ;
}



/****************************************************************************
* Function Name  : rrmcm_update_meas_eutran_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 arfcn : Freq value
*          U8 arfcn_index : index of Eutran freq list in temp reconfig
*          struct if reconfig is reqd for that freq
*          U8 freq_list_index: index of the Meas Config Req Eutran list
*          of the freq for which node is to be created/updated         
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : None
* Description    : This function copies the meas param to reconfig struct if
*          reconfig is reqd for that freq, else creates or updates
*          node for the fre
****************************************************************************/
static rrm_return_et
rrmcm_update_meas_eutran_list(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    U32                                      arfcn,
    S16                                      arfcn_index,
    U8                                       freq_list_index,
    rrm_bool_et                              reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              is_arfcn_new
	)
{
    rrm_return_et                    ret_val         = RRM_SUCCESS;
    meas_eutran_node_t               *p_search_eutran_node = PNULL;
    S8                               offset_freq        = INVALID_OFFSET_FREQ;
    S8                               cell_ctx_index     = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    /* Check if meas object exists for the EARFCN */
    p_search_eutran_node = rrmcm_find_eutran_meas_context(arfcn,
            p_cell_ctx);

    /* If meas object does not exist */
    if (p_search_eutran_node == RRM_PNULL)
    {
        /* OFFSET FREQ CHANGES START */
        if(p_meas_config_req->meas_config_req.eutran_config_list[freq_list_index].
                bitmask & RRM_SON_EUTRAN_CM_OFFSET_FREQUENCY_PRESENT)
        {
            offset_freq = p_meas_config_req->meas_config_req.eutran_config_list[freq_list_index].
                cm_offset_frequency;
        }
        /* If freq is configured, fetch the Offset freq */
        else if(RRM_FALSE == is_arfcn_new)
        {
            offset_freq = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[arfcn_index].cm_offset_freq;
            cell_ctx_index = arfcn_index;
        }
        else
        {
            /* Meas Config Req doesnot contain meas params */
            offset_freq = p_meas_config_req->meas_config_req.eutran_config_list[freq_list_index].
                offset_frequency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Freq is not configured and Meas Config Req does not contain"
                    " meas params.So assigning q_offset_freq to CM Offset freq");
        }

        if(p_cell_ctx->meas_eutran_list.count < MAX_SON_MEAS_CONFIG_OBJECT)
        {
            /* Add node in meas context list */
            rrmcm_add_node_in_meas_context_list(p_cell_ctx,
                    p_meas_config_req, freq_list_index, RRM_EUTRAN_CELL, offset_freq, cell_ctx_index);
        }
        else
        {
            ret_val = RRM_FAILURE;
            *p_error_code = RRM_ERR_MAX_MEAS_OBJ_CREATED;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Max objects created. New node cannot be added");
        }		
        /* OFFSET FREQ CHANGES END */
    }
    /* If meas object exists */
    else
    {
        /* If meas params present in Meas Config Req */
        if(p_meas_config_req->meas_config_req.eutran_config_list[freq_list_index].
                bitmask & RRM_SON_EUTRAN_CM_OFFSET_FREQUENCY_PRESENT)
        {
            /* If reconfig is reqd for this freq */
            if(RRM_TRUE == reconfig_reqd)
            {
                /* Copy meas params to temp reconfig struct */
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
                    offset_freq[arfcn_index] = p_meas_config_req->meas_config_req.
                    eutran_config_list[freq_list_index].cm_offset_frequency;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Updated Eutran Offset Freq for EARFCN = %d in "
                        "reconfig struct", arfcn);
            }
            else
            {
                /* Copy meas params to the existing node */
                p_search_eutran_node->eutran_config.prev_offset_frequency = 
                    p_search_eutran_node->eutran_config.offset_frequency;

                p_search_eutran_node->eutran_config.offset_frequency =
                    p_meas_config_req->meas_config_req.eutran_config_list[freq_list_index].
                    cm_offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Updated Eutran node data for EARFCN = %d Prev Offset "
                        "freq = %d   Current Offset freq = %d", arfcn,
                        p_search_eutran_node->eutran_config.prev_offset_frequency,
                        p_search_eutran_node->eutran_config.offset_frequency);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}

/****************************************************************************
* Function Name  : rrmcm_update_meas_utran_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 arfcn : Freq value
*          U8 arfcn_index : index of Utran freq list in temp reconfig
*          struct if reconfig is reqd for that freq
*          U8 freq_list_index: index of the Meas Config Req Utran list
*          of the freq for which node is to be created/updated         
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : None
* Description    : This function copies the meas param to reconfig struct if
*          reconfig is reqd for that freq, else creates or updates
*          node for the fre
****************************************************************************/
static rrm_return_et
rrmcm_update_meas_utran_list(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    U16                                      arfcn,
    S16                                      arfcn_index,
    U8                                       freq_list_index,
    rrm_bool_et                              reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              is_arfcn_new
	)
{
    rrm_return_et                    ret_val         = RRM_SUCCESS;
    meas_utran_node_t               *p_search_utran_node = PNULL;
    S8                               offset_freq        = INVALID_OFFSET_FREQ;
    S8                               cell_ctx_index     = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    /* Check if meas object exists for the UARFCN */
    p_search_utran_node = rrmcm_find_utran_meas_context(arfcn,
            p_cell_ctx);

    /* If meas object does not exist */
    if (p_search_utran_node == RRM_PNULL)
    {
        /* OFFSET FREQ CHANGES START */
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.utran_fdd_list[freq_list_index].
                bitmask & RRM_SON_UTRAN_OFFSET_FREQUENCY_PRESENT)
        {
            offset_freq = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_fdd_list[freq_list_index].offset_frequency;
        }
        /* If freq is configured, fetch the Offset freq */
        else if(RRM_FALSE == is_arfcn_new)
        {
            offset_freq = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[arfcn_index].offset_freq;
            cell_ctx_index = arfcn_index;
        }
        else
        {
            /* Meas Config Req doesnot contain meas params */
            offset_freq = RRM_OAM_Q_OFFESET_RANGE_DB0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Freq is not configured and Meas Config Req does not contain"
                " meas params.Assigning default value 0 DB to offset freq");
        }
        if(p_cell_ctx->meas_utran_list.count < MAX_SON_MEAS_CONFIG_OBJECT)
        {
            /* Add node in meas context list */
            rrmcm_add_node_in_meas_context_list(p_cell_ctx,
                    p_meas_config_req, freq_list_index, RRM_UTRAN_CELL, offset_freq, cell_ctx_index);
        }
        else
        {
            ret_val = RRM_FAILURE;
            *p_error_code = RRM_ERR_MAX_MEAS_OBJ_CREATED;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Max objects created. New node cannot be added");
        }		
        /* OFFSET FREQ CHANGES END */
    }
    /* If meas object exists */
    else
    {
        /* If meas params present in Meas Config Req */
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.utran_fdd_list[freq_list_index].
                bitmask & RRM_SON_UTRAN_OFFSET_FREQUENCY_PRESENT)
        {
            /* If reconfig is reqd for this freq */
            if(RRM_TRUE == reconfig_reqd)
            {
                /* Copy meas params to temp reconfig struct */
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    offset_freq[arfcn_index] = p_meas_config_req->meas_config_req.
                    inter_rat_meas_config.utran_config_list.
                    utran_fdd_list[freq_list_index].offset_frequency;
            }
            else
            {
                p_search_utran_node->utran_config.prev_offset_frequency = 
                        p_search_utran_node->utran_config.offset_frequency;

                /* Copy meas params to the existing node */
                p_search_utran_node->utran_config.offset_frequency = 
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    utran_config_list.utran_fdd_list[freq_list_index].
                    offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Updated FDD Utran node data for UARFCN = %d Prev Offset "
                        "freq = %d   Current Offset freq = %d", arfcn, 
                        p_search_utran_node->utran_config.prev_offset_frequency,
                        p_search_utran_node->utran_config.offset_frequency);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}

/* TDD Support SON Start */
/****************************************************************************
* Function Name  : rrmcm_update_meas_utran_tdd_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 arfcn : Freq value
*          U8 arfcn_index : index of Utran freq list in temp reconfig
*          struct if reconfig is reqd for that freq
*          U8 freq_list_index: index of the Meas Config Req Utran list
*          of the freq for which node is to be created/updated         
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : None
* Description    : This function copies the meas param to reconfig struct if
*          reconfig is reqd for that freq, else creates or updates
*          node for the fre
****************************************************************************/
static rrm_return_et
rrmcm_update_meas_utran_tdd_list(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    U16                                      arfcn,
    S16                                      arfcn_index,
    U8                                       freq_list_index,
    rrm_bool_et                              reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              is_arfcn_new
	)
{
    rrm_return_et                    ret_val         = RRM_SUCCESS;
    meas_utran_tdd_node_t            *p_search_utran_tdd_node = PNULL;
    S8                               offset_freq        = INVALID_OFFSET_FREQ;
    S8                               cell_ctx_index     = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    /* Check if meas object exists for the UARFCN */
    p_search_utran_tdd_node = rrmcm_find_utran_tdd_meas_context(arfcn,
            p_cell_ctx);

    /* If meas object does not exist */
    if (p_search_utran_tdd_node == RRM_PNULL)
    {
        /* OFFSET FREQ CHANGES START */
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.utran_tdd_list[freq_list_index].
                bitmask & RRM_SON_UTRAN_TDD_OFFSET_FREQUENCY_PRESENT)
        {
            offset_freq = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_tdd_list[freq_list_index].offset_frequency;
        }
        /* If freq is configured, fetch the Offset freq */
        else if(RRM_FALSE == is_arfcn_new)
        {
            offset_freq = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[arfcn_index].offset_freq;
            cell_ctx_index = arfcn_index;
        }
        else
        {
            /* Meas Config Req doesnot contain meas params */
            offset_freq = RRM_OAM_Q_OFFESET_RANGE_DB0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Freq is not configured and Meas Config Req does not contain"
                " meas params.Assigning default value 0 DB to offset freq");
        }
        if(p_cell_ctx->meas_utran_tdd_list.count < MAX_SON_MEAS_CONFIG_OBJECT)
        {
            /* Add node in meas context list */
            rrmcm_add_node_in_meas_context_list(p_cell_ctx,
                    p_meas_config_req, freq_list_index, RRM_UTRAN_TDD_CELL, offset_freq, cell_ctx_index);
        }
        else
        {
            ret_val = RRM_FAILURE;
            *p_error_code = RRM_ERR_MAX_MEAS_OBJ_CREATED;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Max objects created. New node cannot be added");
        }		
        /* OFFSET FREQ CHANGES END */
    }
    /* If meas object exists */
    else
    {
        /* If meas params present in Meas Config Req */
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.utran_tdd_list[freq_list_index].
                bitmask & RRM_SON_UTRAN_TDD_OFFSET_FREQUENCY_PRESENT)
        {
            /* If reconfig is reqd for this freq */
            if(RRM_TRUE == reconfig_reqd)
            {
                /* Copy meas params to temp reconfig struct */
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    offset_freq[arfcn_index] = p_meas_config_req->meas_config_req.
                    inter_rat_meas_config.utran_config_list.
                    utran_tdd_list[freq_list_index].offset_frequency;
            }
            else
            {
                p_search_utran_tdd_node->utran_tdd_config.prev_offset_frequency = 
                        p_search_utran_tdd_node->utran_tdd_config.offset_frequency;

                /* Copy meas params to the existing node */
                p_search_utran_tdd_node->utran_tdd_config.offset_frequency = 
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    utran_config_list.utran_tdd_list[freq_list_index].
                    offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Updated TDD Utran node data for UARFCN = %d Prev Offset "
                        "freq = %d   Current Offset freq = %d", arfcn, 
                        p_search_utran_tdd_node->utran_tdd_config.prev_offset_frequency,
                        p_search_utran_tdd_node->utran_tdd_config.offset_frequency);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}
/* TDD Support SON End */

/****************************************************************************
* Function Name  : rrmcm_update_meas_geran_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 arfcn : Freq value
*          U8 arfcn_index : index of Geran freq list in temp reconfig
*          struct if reconfig is reqd for that freq
*          U8 freq_list_index: index of the Meas Config Req Geran list
*          of the freq for which node is to be created/updated         
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : None
* Description    : This function copies the meas param to reconfig struct if
*          reconfig is reqd for that freq, else creates or updates
*          node for the freq
****************************************************************************/
static rrm_return_et
rrmcm_update_meas_geran_list(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    U16                                      arfcn,
    rrm_son_geran_band_indicator_et          band_ind,
    S16                                      arfcn_index,
    U8                                       freq_list_index,
    rrm_bool_et                              reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              is_arfcn_new
	)
{
    rrm_return_et                    ret_val         = RRM_SUCCESS;
    meas_geran_node_t               *p_search_geran_node = PNULL;
    S8                               offset_freq        = INVALID_OFFSET_FREQ;
    S8                               cell_ctx_index     = FREQ_NOT_CONFIGURED;

    RRM_UT_TRACE_ENTER();

    /* Check if meas object exists for the ARFCN */
    p_search_geran_node = rrmcm_find_geran_meas_context(arfcn, band_ind,
            p_cell_ctx);

    /* If meas object does not exist */
    if (p_search_geran_node == RRM_PNULL)
    {
        /* OFFSET FREQ CHANGES START */
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            geran_config_list.geran_freq_info_list[freq_list_index].
                bitmask & RRM_SON_GERAN_CFI_OFFSET_FREQ_PRESENT)
        {
            offset_freq = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.geran_freq_info_list[freq_list_index].offset_frequency;
        }
        /* If freq is configured, fetch the Offset freq */
        else if(RRM_FALSE == is_arfcn_new)
        {
            offset_freq = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                irat_eutran_to_geran_carriers[arfcn_index].offset_freq;
            cell_ctx_index = arfcn_index;
        }
        else
        {
            /* Meas Config Req doesnot contain meas params */
            offset_freq = RRM_OAM_Q_OFFESET_RANGE_DB0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Freq is not configured and Meas Config Req does not contain"
                " meas params.Assigning default value 0 DB to offset freq");
        }

        if(p_cell_ctx->meas_geran_list.count < MAX_SON_MEAS_CONFIG_OBJECT)
        {
            /* Add node in meas context list */
            rrmcm_add_node_in_meas_context_list(p_cell_ctx,
                    p_meas_config_req, freq_list_index, RRM_GERAN_CELL, offset_freq, cell_ctx_index);
        }
        else
        {
            ret_val = RRM_FAILURE;
            *p_error_code = RRM_ERR_MAX_MEAS_OBJ_CREATED;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Max objects created. New node cannot be added");
        }		
        /* OFFSET FREQ CHANGES END */
    }
    /* If meas object exists */
    else
    {
        /* If meas params present in Meas Config Req */
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            geran_config_list.geran_freq_info_list[freq_list_index].
                bitmask & RRM_SON_GERAN_CFI_OFFSET_FREQ_PRESENT)
        {
            /* If reconfig is reqd for this freq */
            if(RRM_TRUE == reconfig_reqd)
            {
                /* Copy meas params to temp reconfig struct */
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
                    offset_freq[arfcn_index] = p_meas_config_req->meas_config_req.
                    inter_rat_meas_config.geran_config_list.
                    geran_freq_info_list[freq_list_index].offset_frequency;
            }
            else
            {
                p_search_geran_node->geran_config.prev_offset_frequency = 
                    p_search_geran_node->geran_config.offset_frequency;

                /* Copy meas params to the existing node */
                p_search_geran_node->geran_config.offset_frequency = 
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    geran_config_list.geran_freq_info_list[freq_list_index].
                    offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Updated geran node data for GERAN Freq = %d Prev Offset "
                        "freq = %d   Current Offset freq = %d", arfcn, 
                        p_search_geran_node->geran_config.prev_offset_frequency,
                        p_search_geran_node->geran_config.offset_frequency);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}

/****************************************************************************
* Function Name  : rrmcm_update_meas_cdma_list 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U8 arfcn : Freq value
*          U8 arfcn_index : index of CDMA freq list in temp reconfig
*          struct if reconfig is reqd for that freq
*          U8 freq_list_index: index of the Meas Config Req CDMA list
*          of the freq for which node is to be created/updated         
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : None
* Description    : This function copies the meas param to reconfig struct if
*          reconfig is reqd for that freq, else creates or updates
*          node for the freq
****************************************************************************/
static rrm_return_et
rrmcm_update_meas_cdma_list(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    U16                                      arfcn,
    rrm_son_cdma_band_class_et               band_class,
    S16                                      arfcn_index,
    U8                                       freq_list_index,
    rrm_bool_et                              reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              is_arfcn_new
	)
{
    rrm_return_et                    ret_val         = RRM_SUCCESS;
    meas_cdma_node_t               *p_search_cdma_node = PNULL;
    S8                               offset_freq        = INVALID_OFFSET_FREQ;
    S8                               cell_ctx_index     = FREQ_NOT_CONFIGURED;


    RRM_UT_TRACE_ENTER();
    /* Check if meas object exists for the ARFCN */
    p_search_cdma_node = rrmcm_find_cdma_meas_context(arfcn, band_class,
            p_cell_ctx);
    /* If meas object does not exist */
    if (p_search_cdma_node == RRM_PNULL)
    {
        if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            cdma_config_list.cdma_freq_info_list[freq_list_index].
                bitmask & RRM_SON_CDMA_FREQ_OFFSET_FREQ_PRESENT)
        {
            offset_freq = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_list_index].offset_freq;
        }
        else if(RRM_FALSE == is_arfcn_new)
        {
            offset_freq = p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
                                offset_freq[arfcn_index];
            cell_ctx_index = arfcn_index;
        }
        else
        {
            offset_freq = RRM_OAM_Q_OFFESET_RANGE_DB0;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Freq is not configured and Meas Config Req does not contain"
                " meas params.Assigning default value 0 DB to offset freq");
        }

        if(p_cell_ctx->meas_cdma_list.count < MAX_SON_MEAS_CONFIG_OBJECT)
        {
            rrmcm_add_node_in_meas_context_list(p_cell_ctx,
                    p_meas_config_req, freq_list_index, RRM_CDMA_CELL, offset_freq, cell_ctx_index);
        }
        else
        {
            ret_val = RRM_FAILURE;
            *p_error_code = RRM_ERR_MAX_MEAS_OBJ_CREATED;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Max objects created. New node cannot be added");
        }		
    }
    /* If meas object exists */
    else
    {
        /* If meas params present in Meas Config Req */
         if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
            cdma_config_list.cdma_freq_info_list[freq_list_index].
                bitmask & RRM_SON_CDMA_FREQ_OFFSET_FREQ_PRESENT)
        {
            /* If reconfig is reqd for this freq */
            if(RRM_TRUE == reconfig_reqd)
            {
                /* Copy meas params to temp reconfig struct */
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.
                    offset_freq[arfcn_index] = p_meas_config_req->meas_config_req.
                    inter_rat_meas_config.cdma_config_list.
                    cdma_freq_info_list[freq_list_index].offset_freq;
            }
            else
            {
                p_search_cdma_node->cdma_config.prev_offset_frequency = 
                    p_search_cdma_node->cdma_config.offset_frequency;
 
                /* Copy meas params to the existing node */
                p_search_cdma_node->cdma_config.offset_frequency = 
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    cdma_config_list.cdma_freq_info_list[freq_list_index].
                    offset_freq;
 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Updated cdma node data for CDMA Freq = %d Prev Offset "
                        "freq = %d   Current Offset freq = %d", arfcn, 
                        p_search_cdma_node->cdma_config.prev_offset_frequency,
                        p_search_cdma_node->cdma_config.offset_frequency);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}





/****************************************************************************
* Function Name  : rrmcm_validate_meas_config_eutran_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : This function  Validates utran params, creates and updates
*          Eutran meas object nodes and updates temp reconfig struct
*          if reconfig is reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_meas_config_eutran_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    U8                               freq_list       = RRM_NULL;
    U8                               freq_list_index = RRM_NULL;
    S16                              arfcn_index     = FREQ_NOT_CONFIGURED;
    U32                              self_earfcn     = RRM_NULL;
    U32                              arfcn           = RRM_NULL;
    rrm_bool_et                      params_differ   = RRM_FALSE;
    rrm_bool_et                      mand_params_present  = RRM_FALSE;
    rrm_bool_et                      eutran_params_copied = RRM_FALSE;
    rrm_return_et                    ret_val         = RRM_SUCCESS;
    rrm_bool_et                      is_arfcn_new    = RRM_FALSE;
    /* coverity : CID 29616*/
    rrm_bool_et                      reconfig_reqd = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    self_earfcn = p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn;
    freq_list = p_meas_config_req->meas_config_req.eutran_config_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "EUTRAN list size = %d", freq_list);
    /*CID 54995:start*/
    for (freq_list_index = RRM_ZERO; (freq_list_index < freq_list)
            && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT); freq_list_index++)
    /*CID 54995:end*/
    {
        /* OFFSET FREQ CHANGES START */
        is_arfcn_new = RRM_FALSE;
        /* OFFSET FREQ CHANGES END */

        arfcn = p_meas_config_req->meas_config_req.eutran_config_list
            [freq_list_index].earfcn;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Processing EARFCN = %d", arfcn);
        /* Fix for Coverity, LTE_RRM_MALL:CID:11124 [Prasant]*/    

        if(self_earfcn == arfcn)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Req for serving cell freq received");

            params_differ = rrmcm_compare_meas_config_serv_cell_sib_params(
                    p_cell_ctx, p_meas_config_req , freq_list_index);
            if(RRM_TRUE == params_differ)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Configured Serving cell freq params and meas config request"
                        "params differ");
                if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code)) /*Kshitij 13568 rel1.3*/
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Cell state not valid to trigger reconfig. Sending failure to SON");
                    ret_val = RRM_FAILURE;
                    break;
                }
                *p_reconfig_reqd = RRM_TRUE;

                /* Copy intra freq params from cell context to the struct
                   to be used for reconfig */
                rrmcm_copy_serv_cell_params_to_reconfig_struct(p_cell_ctx);

                /* overwrite the intra freq params with new values */
                rrmcm_store_serv_cell_sib_params_in_cell_ctx(
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                        &(p_meas_config_req->meas_config_req.
                            eutran_config_list[freq_list_index]));
            }    
        }
        else
        {
            arfcn_index = rrmcm_search_earfcn_in_cell_context(p_cell_ctx, arfcn);
            /* If arfcn is not configured at RRM */
            if(FREQ_NOT_CONFIGURED == arfcn_index)
            {
                /* OFFSET FREQ CHANGES START */
                is_arfcn_new = RRM_TRUE;
                /* OFFSET FREQ CHANGES END */

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "EARFCN %d is not configured at RRM", arfcn);
                /* If no. of already configured arfcn = MAX, new arfcn 
                   cannot be added */ 
                if(RRM_FALSE == eutran_params_copied)
                {
                    if(MAX_NO_INTER_FREQ ==
                            p_cell_ctx->ran_info.mobility_params.
                            idle_mode_mobility_params.
                            num_valid_inter_freq_list)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Max no. of EARFCNs already configured at RRM.Cannot add freq."
                                "Sending Failure");
                        ret_val = RRM_FAILURE;
                        *p_error_code = RRM_ERR_MAX_INTER_FREQS_CONFIGURED;
                        break;
                    }
                }
                /*Fix for SPR#699, in below condition checking for equality instead of greater value 
                 *than MAX_NO_INTER_FREQ
                 */
                else if(MAX_NO_INTER_FREQ ==   
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
                        num_valid_inter_freq_list)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Max count for EARFCNs reached for reconfig.Cannot add freq.Sending Failure");
                    ret_val = RRM_FAILURE;
                    *p_error_code = RRM_ERR_MAX_INTER_FREQS_CONFIGURED;
                    break;
                }
                mand_params_present = rrmcm_check_eutran_mandatory_sib_and_meas_params_present(
                        p_meas_config_req, p_cell_ctx, freq_list_index);
                if(RRM_TRUE == mand_params_present)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "All Mandatory params are present.Reconfig required for adding Inter-freq"
                            " = %d", arfcn);
                    /* if the freq is not configured at RRM, add it to the inter
                       freq param list at index next to last*/
                    if(RRM_FALSE == eutran_params_copied)
                    {
                        /* If all EUTRAN params not copied yet to 
                           p_meas_config_sib_info_for_reconfig */
                        arfcn_index = p_cell_ctx->ran_info.mobility_params.
                            idle_mode_mobility_params.num_valid_inter_freq_list;
                    }
                    else
                    {
                        /* Few freq might have been added in reconfig struct, 
                         * so add after those */
                        arfcn_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
                            num_valid_inter_freq_list;
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "All mandatory params are NOT present in MEAS CONFIG REQUEST");

                    /* Send FAILURE to SON*/
                    ret_val = RRM_FAILURE;
                    *p_error_code = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                    break;
                }
            }
            /* If arfcn is already configured at RRM */
            else
            {
                if (MAX_NO_INTER_FREQ > arfcn_index ) /* Coverity: CID 30636 */
                {
                    params_differ = rrmcm_compare_meas_config_eutran_sib_params(
                            p_cell_ctx, arfcn_index, p_meas_config_req , freq_list_index);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "EARFCN %d is configured at RRM at index = %d. "
                            "Params_differ = %d", arfcn, arfcn_index, params_differ);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "ARFCN_INDEX is greater than 7");
                }
            }

            if((RRM_TRUE == params_differ) || (RRM_TRUE == mand_params_present))
            {
                if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code))/*Kshitij 13568 rel1.3*/
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Cell state not valid to trigger reconfig. Sending failure to SON");
                    ret_val = RRM_FAILURE;
                    break;
                }
                *p_reconfig_reqd = RRM_TRUE;

                /* If all EUTRAN params not copied yet to 
                   p_meas_config_sib_info_for_reconfig */
                if(RRM_FALSE == eutran_params_copied)
                {
                    rrmcm_copy_eutra_params_to_reconfig_struct(p_cell_ctx);
                    eutran_params_copied = RRM_TRUE;
                }
                /* overwrite the inter freq params with new values */
                rrmcm_store_eutran_sib_params_in_cell_ctx(
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                        &(p_meas_config_req->meas_config_req.
                            eutran_config_list[freq_list_index]), arfcn_index);
            }
            if (MAX_NO_INTER_FREQ > arfcn_index ) /* Coverity: CID 30626 */
            {
                /* coverity : CID 29616*/
                reconfig_reqd = (RRM_ZERO == (params_differ || mand_params_present))? RRM_FALSE : RRM_TRUE;
                ret_val = rrmcm_update_meas_eutran_list(p_cell_ctx, p_meas_config_req, arfcn, 
                        arfcn_index, freq_list_index, reconfig_reqd, p_error_code, is_arfcn_new);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "ARFCN_INDEX is greater than 7");
            }
            if(RRM_FAILURE ==  ret_val)
            {
                break;
            }
        }
    }//end for

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
* Function Name  : rrmcm_validate_meas_config_utran_fdd_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : This function  Validates utran params, creates and updates
*          Utran FDD meas object nodes and updates temp reconfig struct
*          if reconfig is reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_meas_config_utran_fdd_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              *p_utran_params_copied,
    rrm_bool_et                               utran_resel_params_copied
)
{
    U8                               freq_list       = RRM_NULL;
    U8                               freq_list_index = RRM_NULL;
    S8                               arfcn_index     = FREQ_NOT_CONFIGURED;
    U16                              arfcn           = RRM_NULL;
    rrm_bool_et                      params_differ   = RRM_FALSE;
    rrm_bool_et                      mand_params_present       = RRM_FALSE;
    rrm_bool_et                      cell_ctx_utran_fdd_list_present = RRM_FALSE;
    rrm_return_et                    ret_val                   = RRM_SUCCESS;
    rrm_bool_et                      is_arfcn_new    = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    cell_ctx_utran_fdd_list_present = 
        rrmcm_check_utran_fdd_presence_in_cell_ctx(p_cell_ctx);

    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        utran_config_list.utran_fdd_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "FDD UTRAN list size = %d", freq_list);
    /* Fix 8172 End */
    /*CID 54995:Coverity_Fix_Start*/
    for(freq_list_index = 0; (( freq_list_index < freq_list) && 
        (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT )); freq_list_index++)
    /*CID 54995:Coverity_Fix_End*/
    {
        /* OFFSET FREQ CHANGES START */
        is_arfcn_new = RRM_FALSE;
        /* OFFSET FREQ CHANGES END */

        arfcn = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.utran_fdd_list[freq_list_index].uarfcn;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Processing FDD UARFCN = %d", arfcn);

        if(RRM_TRUE == cell_ctx_utran_fdd_list_present)
        {
            arfcn_index = rrmcm_search_uarfcn_fdd_in_cell_context(p_cell_ctx, arfcn);                    
        }

        /* If arfcn is not configured at RRM */
        if(FREQ_NOT_CONFIGURED == arfcn_index)
        {
            /* OFFSET FREQ CHANGES START */
            is_arfcn_new = RRM_TRUE;
            /* OFFSET FREQ CHANGES END */

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "FDD UARFCN %d is not configured at RRM", arfcn);

            /* If new arfcn is to be configured at RRM and
               no. of already configured arfcn = MAX, new arfcn
               cannot be added */
            if(RRM_FALSE == *p_utran_params_copied)
            {
                if(RRM_TRUE == cell_ctx_utran_fdd_list_present)
                {
                    if(p_cell_ctx->ran_info.mobility_params.
                            idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                            irat_eutran_to_utran_fdd_list.
                            num_irat_eutran_to_utran_fdd_carriers == 
                            RRM_MAX_NUM_UTRA_FDD_CARRIERS)
                    {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Max no. of FDD UARFCNs already configured at RRM.Cannot add freq."
                                "Sending Failure");

                        ret_val = RRM_FAILURE;
                        *p_error_code = RRM_ERR_MAX_UTRA_FDD_FREQS_CONFIGURED;
                        break;
                    }
                }
            }
            else if(RRM_MAX_NUM_UTRA_FDD_CARRIERS == 
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    num_irat_eutran_to_utran_fdd_carriers)
            {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Max count for FDD UARFCNs reached for reconfig.Cannot add freq.Sending Failure");
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MAX_UTRA_FDD_FREQS_CONFIGURED;
                break;
            } 
            mand_params_present = rrmcm_check_utran_fdd_mandatory_sib_and_meas_params_present(
                    p_meas_config_req, p_cell_ctx, freq_list_index);
            if(RRM_TRUE == mand_params_present)
            {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "All Mandatory params are present.Reconfig required for adding FDD UTRA freq"
                        " = %d", arfcn);

                /* if the freq is not configured at RRM, add it to the utran
                   freq param list at last*/
                if(RRM_FALSE == *p_utran_params_copied)
                {
                    /* If all UTRAN params not copied yet to
                       p_meas_config_sib_info_for_reconfig */
                    arfcn_index = p_cell_ctx->ran_info.mobility_params.
                        idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.
                        irat_eutran_to_utran_fdd_list.
                        num_irat_eutran_to_utran_fdd_carriers;

                    cell_ctx_utran_fdd_list_present = RRM_TRUE;
                }
                else
                {
                    /* Few freq might have been added in reconfig struct, 
                     * so add after those */
                    arfcn_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                        num_irat_eutran_to_utran_fdd_carriers;
                }
            }
            /* All mandatory SIB params not present in meas config req */
            else
            {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "All mandatory params are NOT present in MEAS CONFIG REQUEST");

                /* Send FAILURE to SON*/
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                break;
            }
        }
        /* If arfcn is already configured at RRM */
        else
        {
            params_differ = rrmcm_compare_meas_config_utran_fdd_sib_params(
                    p_cell_ctx, arfcn_index, p_meas_config_req , freq_list_index);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "FDD UARFCN %d is configured at RRM at index = %d. "
                    "Params_differ = %d", arfcn, arfcn_index, params_differ);
        }

        if((RRM_TRUE == params_differ) || (RRM_TRUE == mand_params_present))
        {
            if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code))/*Kshitij 13569  rel1.3*/
            {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell state not valid to trigger reconfig. Sending failure to SON");
                ret_val = RRM_FAILURE;
                break;
            }
            *p_reconfig_reqd = RRM_TRUE;

            /* If all UTRAN params not copied yet to
               p_meas_config_sib_info_for_reconfig */
            if(RRM_FALSE == *p_utran_params_copied)
            {
                /* Copy all utra freq params to
                   p_meas_config_sib_info_for_reconfig */
                if(RRM_FALSE == utran_resel_params_copied)
                {
                /* Fix 8172 Start */
                    rrmcm_copy_utra_params_to_reconfig_struct(p_cell_ctx);
                }
                /* Fix 8172 End */
                *p_utran_params_copied = RRM_TRUE;
            }
            /* overwrite the utra freq params with new values */ 
            rrmcm_store_utran_fdd_sib_params_in_cell_ctx(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                    arfcn_index, &(p_meas_config_req->meas_config_req.
                        inter_rat_meas_config.utran_config_list), freq_list_index);
        }
        /* Coverity_ID : 29617 */
        ret_val = rrmcm_update_meas_utran_list(p_cell_ctx, p_meas_config_req, arfcn,
                arfcn_index, freq_list_index, (rrm_bool_et)(params_differ || mand_params_present) , 
                p_error_code, is_arfcn_new);
        if(RRM_FAILURE ==  ret_val)
        {
            break;
        }

    }
    /*Coverity_fix_end_54995*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* TDD Support SON Start */

/****************************************************************************
* Function Name  : rrmcm_validate_meas_config_utran_tdd_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : This function  Validates utran params, creates and updates
*          Utran TDD meas object nodes and updates temp reconfig struct
*          if reconfig is reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_meas_config_utran_tdd_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_bool_et                              *p_utran_params_copied,
    rrm_bool_et                               utran_resel_params_copied
)
{
    U8                               freq_list       = RRM_NULL;
    U8                               freq_list_index = RRM_NULL;
    S8                               arfcn_index     = FREQ_NOT_CONFIGURED;
    U16                              arfcn           = RRM_NULL;
    rrm_bool_et                      params_differ   = RRM_FALSE;
    rrm_bool_et                      mand_params_present       = RRM_FALSE;
    rrm_bool_et                      cell_ctx_utran_tdd_list_present = RRM_FALSE;
    rrm_return_et                    ret_val                   = RRM_SUCCESS;
    rrm_bool_et                      is_arfcn_new    = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    cell_ctx_utran_tdd_list_present = 
        rrmcm_check_utran_tdd_presence_in_cell_ctx(p_cell_ctx);

    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        utran_config_list.utran_tdd_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "TDD UTRAN list size = %d", freq_list);
    /* Fix 8172 End */

    /* cov_54995_start */
    for(freq_list_index = 0; 
            (freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT); 
            freq_list_index++)
        /* cov_54995_end */
    {
        /* OFFSET FREQ CHANGES START */
        is_arfcn_new = RRM_FALSE;
        /* OFFSET FREQ CHANGES END */

        arfcn = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.utran_tdd_list[freq_list_index].uarfcn;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Processing TDD UARFCN = %d", arfcn);

        if(RRM_TRUE == cell_ctx_utran_tdd_list_present)
        {
            arfcn_index = rrmcm_search_uarfcn_tdd_in_cell_context(p_cell_ctx, arfcn);                    
        }

        /* If arfcn is not configured at RRM */
        if(FREQ_NOT_CONFIGURED == arfcn_index)
        {
            /* OFFSET FREQ CHANGES START */
            is_arfcn_new = RRM_TRUE;
            /* OFFSET FREQ CHANGES END */

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "TDD UARFCN %d is not configured at RRM", arfcn);

            /* If new arfcn is to be configured at RRM and
               no. of already configured arfcn = MAX, new arfcn
               cannot be added */
            if(RRM_FALSE == *p_utran_params_copied)
            {
                if(RRM_TRUE == cell_ctx_utran_tdd_list_present)
                {
                    if(p_cell_ctx->ran_info.mobility_params.
                            idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                            irat_eutran_to_utran_tdd_list.
                            num_irat_eutran_to_utran_tdd_carriers == 
                            RRM_MAX_NUM_UTRA_TDD_CARRIERS)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Max no. of TDD UARFCNs already configured at RRM.Cannot add freq."
                                "Sending Failure");

                        ret_val = RRM_FAILURE;
                        *p_error_code = RRM_ERR_MAX_UTRA_TDD_FREQS_CONFIGURED;
                        break;
                    }
                }
            }
            else if(RRM_MAX_NUM_UTRA_TDD_CARRIERS == 
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                    num_irat_eutran_to_utran_tdd_carriers)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Max count for TDD UARFCNs reached for reconfig.Cannot add freq.Sending Failure");
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MAX_UTRA_TDD_FREQS_CONFIGURED;
                break;
            } 
            mand_params_present = rrmcm_check_utran_tdd_mandatory_sib_and_meas_params_present(
                    p_meas_config_req,freq_list_index);
                    /*SPR 17777 +-*/
            if(RRM_TRUE == mand_params_present)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "All Mandatory params are present.Reconfig required for adding TDD UTRA freq"
                        " = %d", arfcn);

                /* if the freq is not configured at RRM, add it to the utran
                   freq param list at last*/
                if(RRM_FALSE == *p_utran_params_copied)
                {
                    /* If all UTRAN params not copied yet to
                       p_meas_config_sib_info_for_reconfig */
                    arfcn_index = p_cell_ctx->ran_info.mobility_params.
                        idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.
                        irat_eutran_to_utran_tdd_list.
                        num_irat_eutran_to_utran_tdd_carriers;

                    cell_ctx_utran_tdd_list_present = RRM_TRUE;
                }
                else
                {
                    /* Few freq might have been added in reconfig struct, 
                     * so add after those */
                    arfcn_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                        num_irat_eutran_to_utran_tdd_carriers;
                }
            }
            /* All mandatory SIB params not present in meas config req */
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "All mandatory params are NOT present in MEAS CONFIG REQUEST");

                /* Send FAILURE to SON*/
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                break;
            }
        }
        /* If arfcn is already configured at RRM */
        else
        {
            params_differ = rrmcm_compare_meas_config_utran_tdd_sib_params(
                    p_cell_ctx, arfcn_index, p_meas_config_req , freq_list_index);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "TDD UARFCN %d is configured at RRM at index = %d. "
                    "Params_differ = %d", arfcn, arfcn_index, params_differ);
        }

        if((RRM_TRUE == params_differ) || (RRM_TRUE == mand_params_present))
        {
            if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code))/*Kshitij 13569  rel1.3*/
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell state not valid to trigger reconfig. Sending failure to SON");
                ret_val = RRM_FAILURE;
                break;
            }
            *p_reconfig_reqd = RRM_TRUE;

            /* If all UTRAN params not copied yet to
               p_meas_config_sib_info_for_reconfig */
            if(RRM_FALSE == *p_utran_params_copied)
            {
                /* Copy all utra freq params to
                   p_meas_config_sib_info_for_reconfig */
                if(RRM_FALSE == utran_resel_params_copied)
                {
                    /* Fix 8172 Start */
                    rrmcm_copy_utra_params_to_reconfig_struct(p_cell_ctx);
                }
                /* Fix 8172 End */
                *p_utran_params_copied = RRM_TRUE;
            }
            /* overwrite the utra freq params with new values */ 
            rrmcm_store_utran_tdd_sib_params_in_cell_ctx(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                    arfcn_index, &(p_meas_config_req->meas_config_req.
                        inter_rat_meas_config.utran_config_list), freq_list_index);
        }
        ret_val = rrmcm_update_meas_utran_tdd_list(p_cell_ctx, p_meas_config_req, arfcn,
                arfcn_index, freq_list_index, (rrm_bool_et)(params_differ || mand_params_present) , 
                p_error_code, is_arfcn_new);
        if(RRM_FAILURE ==  ret_val)
        {
            break;
        }

    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
* Function Name  : rrmcm_validate_meas_config_utran_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : This function  Validates utran params, creates and updates
*          Utran meas object nodes and updates temp reconfig struct
*          if reconfig is reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_meas_config_utran_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code, /* Coverity_ID : 16486 */
    rrm_rat_type_et                          *p_restore_till_freq_type
)
{
    rrm_bool_et                      utran_params_copied       = RRM_FALSE;
    rrm_bool_et                      utran_resel_params_copied = RRM_FALSE;
    rrm_return_et                    ret_val                   = RRM_SUCCESS;
    rrm_return_et                    state_validation          = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();

    /* Fix 8172 Start */
    /* If reselection params are present in meas config req */
    if((p_meas_config_req->meas_config_req.inter_rat_meas_config.
            utran_config_list.bitmask & RRM_SON_UTRAN_RESELECTION_PRESENT) ||
            (p_meas_config_req->meas_config_req.inter_rat_meas_config.
             utran_config_list.bitmask & RRM_SON_UTRAN_RESELECTION_SF_PRESENT)) 
    {
        if(RRM_TRUE == rrmcm_handle_meas_config_utran_reselection_params(
                    p_cell_ctx, p_meas_config_req, p_error_code, &state_validation))
        {
            if(RRM_SUCCESS == state_validation)
            {
                *p_reconfig_reqd = RRM_TRUE;
                utran_resel_params_copied = RRM_TRUE;
            }
            else
            {
                ret_val = RRM_FAILURE;
                /* If UTRAN Reselection params validation fails, Restore EUTRAN list */
                *p_restore_till_freq_type = RRM_EUTRAN_CELL;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
    }

    ret_val = rrmcm_validate_meas_config_utran_fdd_params(
                p_cell_ctx, p_meas_config_req, p_reconfig_reqd, p_error_code, 
                &utran_params_copied, utran_resel_params_copied);

    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Validation FAILURE for FDD Utran params");
        /* If FDD UTRAN validation fails, Restore EUTRAN and UTRAN lists */
        *p_restore_till_freq_type = RRM_UTRAN_CELL;
    }
    else
    {
        ret_val = rrmcm_validate_meas_config_utran_tdd_params(
                p_cell_ctx, p_meas_config_req, p_reconfig_reqd, p_error_code, 
                &utran_params_copied, utran_resel_params_copied);

        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Validation FAILURE for TDD Utran params");
            /* If TDD UTRAN validation fails, Restore EUTRAN and UTRAN lists */
            *p_restore_till_freq_type = RRM_UTRAN_TDD_CELL;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TDD Support SON End */

/****************************************************************************
* Function Name  : rrmcm_validate_meas_config_cdma_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : This function  Validates cdma params, creates and updates
*          Geran meas object nodes and updates temp reconfig struct
*          if reconfig is reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_meas_config_cdma_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    U8                               freq_list       = RRM_NULL;
    U8                               freq_list_index = RRM_NULL;
    S8                               arfcn_index     = FREQ_NOT_CONFIGURED;
    U16                              arfcn           = RRM_NULL;
    rrm_bool_et                      params_differ   = RRM_FALSE;
    rrm_bool_et                      cdma_params_copied       = RRM_FALSE;
    rrm_bool_et                      cdma_resel_params_copied = RRM_FALSE;
    rrm_bool_et                      mand_params_present       = RRM_FALSE;
    rrm_bool_et                      cell_ctx_cdma_list_present = RRM_FALSE;
    rrm_return_et                    ret_val                   = RRM_SUCCESS;
    rrm_return_et                      state_validation          = RRM_FAILURE;
    U8                               cdma_type   = RRM_NULL;
    U8                                band_class  = RRM_NULL;
    S8                              band_class_index = BAND_NOT_CONFIGURED;
    rrm_bool_et                      is_arfcn_new              = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    cell_ctx_cdma_list_present =
        rrmcm_check_cdma_freq_presence_in_cell_ctx(p_cell_ctx);

    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        cdma_config_list.cdma_freq_info_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "CDMA list size = %d", freq_list);
    /* Coverity 54995 Fix End */


    /* If reselection params are present in meas config req */

    if((p_meas_config_req->meas_config_req.inter_rat_meas_config.
         cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_PRE_REG_HRPD_INFO_PRESENT) || 
       (p_meas_config_req->meas_config_req.inter_rat_meas_config.
         cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_1X_RTT_INFO_PRESENT) ||
       (p_meas_config_req->meas_config_req.inter_rat_meas_config.
         cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_SYS_TIME_INFO_PRESENT) ||
       (p_meas_config_req->meas_config_req.inter_rat_meas_config.
         cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CDMA_SRCH_WNDO_SIZE_PRESENT)||
       (p_meas_config_req->meas_config_req.inter_rat_meas_config.
         cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CSFB_SUPPORT_FOR_DUAL_RX_UES_PRESENT)||
       (p_meas_config_req->meas_config_req.inter_rat_meas_config.
          cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_CSFB_REG_PARAM_1XRTT_PRESENT)||
       (p_meas_config_req->meas_config_req.inter_rat_meas_config.
          cdma_config_list.bitmask & RRM_SON_MEAS_CONFIG_AC_BARRING_CONFIG_1XRTT_PRESENT))
                      

    {
        /* If at least one freq is configured at RRM or Meas config req contains
           freqs to be configured*/
        if((RRM_TRUE == cell_ctx_cdma_list_present) || (RRM_NULL < freq_list))
        {
            if(RRM_TRUE == rrmcm_handle_meas_config_cdma_reselection_params(
                    p_cell_ctx, p_meas_config_req, p_error_code, &state_validation))
            {
                if(RRM_SUCCESS == state_validation)
                {

                    *p_reconfig_reqd = RRM_TRUE;
                    cdma_resel_params_copied = RRM_TRUE;
                }
                else
                {
                    ret_val = RRM_FAILURE;
                    RRM_UT_TRACE_EXIT();
                    return ret_val;
                }
            }
        }
        else if(RRM_NULL == freq_list)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Reselection params Invalid as no CDMA freq is configured at RRM");
            ret_val = RRM_FAILURE;
            *p_error_code = RRM_ERR_NO_CDMA_FREQ_CONFIGURED;
        }
    }


    /* Coverity 54995 Fix Start */
    for(freq_list_index = 0; ((freq_list_index < freq_list) && (freq_list_index
                    < MAX_SON_MEAS_CONFIG_OBJECT));freq_list_index++)
        /* Coverity 54995 Fix End */
    {
        /* OFFSET FREQ CHANGES START */
        is_arfcn_new = RRM_FALSE;
        /* OFFSET FREQ CHANGES END */


        arfcn = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            cdma_config_list.cdma_freq_info_list[freq_list_index].arfcn;
        band_class = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            cdma_config_list.cdma_freq_info_list[freq_list_index].band_class;
        cdma_type = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                        cdma_config_list.cdma_freq_info_list[freq_list_index].cdma_type;


        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Processing CDMA, cdma_type = %d, band class = %d, " 
                "Freq = %d ", cdma_type, band_class,arfcn);

        if(RRM_TRUE == cell_ctx_cdma_list_present)
        {
            arfcn_index = rrmcm_search_cdma_arfcn_in_cell_context(p_cell_ctx, arfcn,
                    band_class,cdma_type,&band_class_index);
        }

        /* If arfcn is not configured at RRM */
        if((FREQ_NOT_CONFIGURED != arfcn_index) &&
                (BAND_NOT_CONFIGURED != band_class_index))
        /* If arfcn is already configured at RRM */
        {
            params_differ = rrmcm_compare_meas_config_cdma_sib_params(
                    p_cell_ctx, band_class_index, p_meas_config_req , freq_list_index);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CDMA freq %d is configured at RRM at index = %d. "
                    "Params_differ = %d", arfcn, arfcn_index, params_differ);

        }
        else
        {
            /* OFFSET FREQ CHANGES START */
            is_arfcn_new = RRM_TRUE;
            /* OFFSET FREQ CHANGES END */

            /* Coverity 19oct Start : 54931 */
            if(band_class_index == BAND_NOT_CONFIGURED)
            {
                if(cdma_type == R_TYPE_HRPD)
                {
                    if( (p_cell_ctx->p_meas_config_sib_info_for_reconfig-> 
                        cdma_params.idle_mode_mobility_irat_cdma_params.
                        cell_reselection_params_hrpd.band_class_list.count) < RRMCM_RMIF_MAX_CDMA_BAND_CLASS)
                    {
                        band_class_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                            cdma_params.idle_mode_mobility_irat_cdma_params.
                            cell_reselection_params_hrpd.band_class_list.count;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "cdma Band class for HRPD %d NOT found in list", band_class);
                    }
                    else
                    {
                      band_class_index = RRMCM_RMIF_MAX_CDMA_BAND_CLASS - RRM_ONE;
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Invalid count (%d) for cdma for HRPD  in list", p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                             cdma_params.idle_mode_mobility_irat_cdma_params.cell_reselection_params_hrpd.band_class_list.count);
                    }
                }


                if(cdma_type == R_TYPE_1X_RTT)
                {
                    if( (p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                        cdma_params.idle_mode_mobility_irat_cdma_params.
                        cell_reselection_params_1xrtt.band_class_list.count) < RRMCM_RMIF_MAX_CDMA_BAND_CLASS)
                    {
                        /* CID 55181 */
                        band_class_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                            cdma_params.idle_mode_mobility_irat_cdma_params.
                            cell_reselection_params_1xrtt.band_class_list.count;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "cdma Band class for 1XRTT %d NOT found in list", band_class);
                    }
                    else
                    {
                        /* CID 55181 */
                        band_class_index = RRMCM_RMIF_MAX_CDMA_BAND_CLASS - RRM_ONE;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Invalid count (%d) for cdma  for 1XRTT in list",
                                p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.idle_mode_mobility_irat_cdma_params.
                                cell_reselection_params_1xrtt.band_class_list.count);
                    }
                }

            }
            /* Coverity 19oct End : 54931 */

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "arfcn_index[%d],band_class_index[%d]", arfcn_index, band_class_index);
            if (cdma_type == R_TYPE_HRPD)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "CDMA freq %d for HRPD band class %d is not configured at RRM", arfcn, band_class);
            }
            else if(cdma_type == R_TYPE_1X_RTT)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "CDMA freq %d for XRTT band class %d is not configured at RRM", arfcn, band_class);
            }
                /* If new arfcn is to be configured at RRM and
               no. of already configured arfcn = MAX, new arfcn
               cannot be added */
            if(RRM_FALSE == cdma_params_copied)
            {
                if(RRM_TRUE == cell_ctx_cdma_list_present)
                {
                    if(p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                        cdma_params.num_valid_cdma2000_freq_cells 
                        == RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Max no. of CDMA freqs already configured at RRM.Cannot add freq."
                                "Sending Failure");
                        ret_val = RRM_FAILURE;
                        *p_error_code = RRM_ERR_MAX_CDMA_FREQS_CONFIGURED;
                        break;
                    }
                }
            }
            else if(RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS ==
                   p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                        cdma_params.num_valid_cdma2000_freq_cells)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                       "Max count for CDMA freqs reached for reconfig.Cannot add freq.Sending Failure");
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MAX_CDMA_FREQS_CONFIGURED;
                break;
            }       
            mand_params_present = rrmcm_check_cdma_mandatory_sib_and_meas_params_present(
                    p_meas_config_req, freq_list_index);
            if(RRM_TRUE == mand_params_present)
            {
                /* if the freq is not configured at RRM, add it to the cdma
                   freq param list at last*/
                if(RRM_FALSE == cdma_params_copied)
                {
                    /* If all GERAN params not copied yet to
                       p_meas_config_sib_info_for_reconfig */
                    arfcn_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                                cdma_params.num_valid_cdma2000_freq_cells;
                    cell_ctx_cdma_list_present = RRM_TRUE;
                }
                else
                {
                     arfcn_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                                cdma_params.num_valid_cdma2000_freq_cells;
                    
                }

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "All Mandatory params are present.Reconfig required for adding"
                        " CDMA freq = %d, at index = %d", arfcn, arfcn_index);
            }
            /* All mandatory SIB params not present in meas config req */
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "All mandatory params are NOT present in MEAS CONFIG REQUEST");

                /* Send FAILURE to SON*/
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                break;
            }
        }

        if((RRM_TRUE == params_differ) || (RRM_TRUE == mand_params_present))
        {
            if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code)) /*Kshitij 13570 rel1.3*/
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell state not valid to trigger reconfig. Sending failure to SON");
                ret_val = RRM_FAILURE;
                break;
            }
            *p_reconfig_reqd = RRM_TRUE;

            /* If all CDMA params not copied yet to
               p_meas_config_sib_info_for_reconfig */
            if(RRM_FALSE == cdma_params_copied)
            {
                /* Copy all geran freq params to
                   p_meas_config_sib_info_for_reconfig */
                if(RRM_FALSE == cdma_resel_params_copied)
                {
                    rrmcm_copy_cdma_reselection_params_to_reconfig_struct(p_cell_ctx);
                }
                rrmcm_copy_cdma_params_to_reconfig_struct(p_cell_ctx);
                cdma_params_copied = RRM_TRUE;
            }
            /* Coverity_ID_fix_start : 55181 */
            if (BAND_NOT_CONFIGURED != band_class_index)
            {
                rrmcm_store_cdma_sib_params_in_cell_ctx(
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                        arfcn_index,band_class_index, &(p_meas_config_req->meas_config_req.
                            inter_rat_meas_config.cdma_config_list), freq_list_index);
            }
            /* Coverity_ID_fix_end : 55181 */
            }
        /* coverity : CID 30995 , 30992 */
        ret_val = rrmcm_update_meas_cdma_list(p_cell_ctx, p_meas_config_req, arfcn,(rrm_son_cdma_band_class_et) band_class, 
                arfcn_index, freq_list_index, (rrm_bool_et)(params_differ || mand_params_present) , p_error_code, is_arfcn_new);
        if(RRM_FAILURE ==  ret_val)
        {
            break;
        }
    }//end for
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
* Function Name  : rrmcm_validate_meas_config_geran_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_bool_et *p_reconfig_reqd : indicates reconfig reqd 
*          status
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : This function  Validates geran params, creates and updates
*          Geran meas object nodes and updates temp reconfig struct
*          if reconfig is reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_meas_config_geran_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    U8                               freq_list       = RRM_NULL;
    U8                               freq_list_index = RRM_NULL;
    /* coverity : CID 29617*/
    S16                               arfcn_index     = FREQ_NOT_CONFIGURED;
    U16                              arfcn           = RRM_NULL;
    rrm_son_geran_band_indicator_et  band_ind        = RRM_SON_GERAN_DCS_1800;
    rrm_bool_et                      params_differ   = RRM_FALSE;
    rrm_bool_et                      geran_params_copied       = RRM_FALSE;
    rrm_bool_et                      geran_resel_params_copied = RRM_FALSE;
    rrm_bool_et                      mand_params_present       = RRM_FALSE;
    rrm_bool_et                      cell_ctx_geran_list_present = RRM_FALSE;
    rrm_return_et                    ret_val                   = RRM_SUCCESS;
    rrm_return_et                    state_validation          = RRM_FAILURE;
    rrm_bool_et                      is_arfcn_new              = RRM_FALSE;
    /* coverity : CID 29617*/
    rrm_bool_et                      reconfig_reqd = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    /* Fix 8172 Start */
    /* If reselection params are present in meas config req */
    if((p_meas_config_req->meas_config_req.inter_rat_meas_config.
                        geran_config_list.bitmask & RRM_SON_MC_GERAN_T_RESELECTION_PRESENT) ||
                    (p_meas_config_req->meas_config_req.inter_rat_meas_config.
                     geran_config_list.bitmask & RRM_SON_MC_GERAN_T_RESELECTION_SF_PRESENT))
    {
        if(RRM_TRUE == rrmcm_handle_meas_config_geran_reselection_params(
                    p_cell_ctx, p_meas_config_req, p_error_code, &state_validation))
        {
            if(RRM_SUCCESS == state_validation)
            {

                *p_reconfig_reqd = RRM_TRUE;
                geran_resel_params_copied = RRM_TRUE;
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
    }
    cell_ctx_geran_list_present =
        rrmcm_check_geran_freq_presence_in_cell_ctx(p_cell_ctx);

    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
        geran_config_list.geran_freq_info_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "GERAN list size = %d", freq_list);
    /* Fix 8172 End */

    for(freq_list_index = 0; freq_list_index < freq_list;
            freq_list_index++)
    {
        /* OFFSET FREQ CHANGES START */
        is_arfcn_new = RRM_FALSE;
        /* OFFSET FREQ CHANGES END */

        arfcn = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            geran_config_list.geran_freq_info_list[freq_list_index].
            geran_car_freqs.starting_arfcn;
        band_ind = p_meas_config_req->meas_config_req.inter_rat_meas_config.
            geran_config_list.geran_freq_info_list[freq_list_index].
            geran_car_freqs.band_ind;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Processing GERAN Freq = %d Band Ind = %d", arfcn, band_ind);

        if(RRM_TRUE == cell_ctx_geran_list_present)
        {
            arfcn_index = rrmcm_search_geran_arfcn_in_cell_context(p_cell_ctx, arfcn,
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.geran_freq_info_list[freq_list_index].
                geran_car_freqs.band_ind);
        }

        /* If arfcn is not configured at RRM */
        if(FREQ_NOT_CONFIGURED == arfcn_index)
        {
            /* OFFSET FREQ CHANGES START */
            is_arfcn_new = RRM_TRUE;
            /* OFFSET FREQ CHANGES END */

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "GERAN freq %d is not configured at RRM", arfcn);

            /* If new arfcn is to be configured at RRM and
               no. of already configured arfcn = MAX, new arfcn
               cannot be added */
            if(RRM_FALSE == geran_params_copied)
            {
                if(RRM_TRUE == cell_ctx_geran_list_present)
                {
                    if(p_cell_ctx->ran_info.mobility_params.
                            idle_mode_mobility_params.
                            idle_mode_mobility_irat_geran_params.
                            irat_eutran_to_geran_list.
                            num_irat_eutran_to_geran_carriers ==
                            MAX_NO_GERAN_FREQ_GROUUP)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Max no. of GERAN freqs already configured at RRM.Cannot add freq."
                                "Sending Failure");
                        ret_val = RRM_FAILURE;
                        *p_error_code = RRM_ERR_MAX_GERAN_FREQS_CONFIGURED;
                        break;
                    }
                }
            }
            else if(MAX_NO_GERAN_FREQ_GROUUP ==
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
                    idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                    num_irat_eutran_to_geran_carriers)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Max count for GERAN freqs reached for reconfig.Cannot add freq.Sending Failure");
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MAX_GERAN_FREQS_CONFIGURED;
                break;
            }        
            mand_params_present = rrmcm_check_geran_mandatory_sib_and_meas_params_present(
                    p_meas_config_req, freq_list_index);
            if(RRM_TRUE == mand_params_present)
            {
                /* if the freq is not configured at RRM, add it to the geran
                   freq param list at last*/
                if(RRM_FALSE == geran_params_copied)
                {
                    /* If all GERAN params not copied yet to
                       p_meas_config_sib_info_for_reconfig */
                    arfcn_index = p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_geran_params.
                        irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers;
                    cell_ctx_geran_list_present = RRM_TRUE;
                }
                else
                {
                    arfcn_index = p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
                        idle_mode_mobility_irat_geran_params.
                        irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers;
                }

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "All Mandatory params are present.Reconfig required for adding"
                        " GERAN freq = %d, at index = %d", arfcn, arfcn_index);
            }
            /* All mandatory SIB params not present in meas config req */
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "All mandatory params are NOT present in MEAS CONFIG REQUEST");

                /* Send FAILURE to SON*/
                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                break;
            }
        }
        /* If arfcn is already configured at RRM */
        else
        {
            params_differ = rrmcm_compare_meas_config_geran_sib_params(
                    p_cell_ctx, arfcn_index, p_meas_config_req , freq_list_index);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "GERAN freq %d is configured at RRM at index = %d. "
                    "Params_differ = %d", arfcn, arfcn_index, params_differ);

        }

        if((RRM_TRUE == params_differ) || (RRM_TRUE == mand_params_present))
        {
            if(RRM_FAILURE == rrmcm_check_cell_state_validity(p_cell_ctx, p_error_code)) /*Kshitij 13570 rel1.3*/
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell state not valid to trigger reconfig. Sending failure to SON");
                ret_val = RRM_FAILURE;
                break;
            }
            *p_reconfig_reqd = RRM_TRUE;

            /* If all GERAN params not copied yet to
               p_meas_config_sib_info_for_reconfig */
            if(RRM_FALSE == geran_params_copied)
            {
                /* Copy all geran freq params to
                   p_meas_config_sib_info_for_reconfig */
                if(RRM_FALSE == geran_resel_params_copied)
                {
                /* Fix 8172 Start */
                    rrmcm_copy_geran_params_to_reconfig_struct(p_cell_ctx);
                }
                /* Fix 8172 End */
                geran_params_copied = RRM_TRUE;
            }

            rrmcm_store_geran_sib_params_in_cell_ctx(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig,
                    arfcn_index, &(p_meas_config_req->meas_config_req.
                        inter_rat_meas_config.geran_config_list), freq_list_index);
        }

        /* coverity : CID 29617*/
        reconfig_reqd = (RRM_ZERO == (params_differ || mand_params_present))? RRM_FALSE : RRM_TRUE;
        ret_val = rrmcm_update_meas_geran_list(p_cell_ctx, p_meas_config_req, arfcn, band_ind, 
                arfcn_index, freq_list_index, reconfig_reqd, 
                p_error_code, is_arfcn_new);
        if(RRM_FAILURE ==  ret_val)
        {
            break;
        }
    }//end for
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
* Function Name  : rrmcm_restore_meas_context_lists 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          rrm_rat_type_et restore_till_freq_type : indicetes which 
*          all lists out of Eutran, Utran and Geran are to be restored
* Outputs        : None
* Returns        : None
* Description    : This function restores the meas object lists in case
*          of any failure of the Meas Config Req
****************************************************************************/
static rrm_void_t
rrmcm_restore_meas_context_lists(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_rat_type_et                          restore_till_freq_type
)
{
    RRM_UT_TRACE_ENTER();

    switch(restore_till_freq_type)
    {
        case RRM_CDMA_CELL:
            rrmcm_restore_meas_cdma_list(p_cell_ctx, p_meas_config_req);
        case RRM_GERAN_CELL:
            rrmcm_restore_meas_geran_list(p_cell_ctx, p_meas_config_req);
        /* TDD Support SON Start */            
        case RRM_UTRAN_TDD_CELL:
            rrmcm_restore_meas_utran_tdd_list(p_cell_ctx, p_meas_config_req);
        /* TDD Support SON End */
        case RRM_UTRAN_CELL:
            rrmcm_restore_meas_utran_list(p_cell_ctx, p_meas_config_req);
        case RRM_EUTRAN_CELL:
            rrmcm_restore_meas_eutran_list(p_cell_ctx, p_meas_config_req);
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Invalid value[%d] for restore_till_freq_type", restore_till_freq_type);
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
* Function Name  : rrmcm_validate_and_process_meas_config_req_params 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
*          rrmcm_rmif_cell_son_meas_config_req_t *p_meas_config_req:
*          Meas Config Req received from SON
*          U16 *p_error_code : error code in case of any failure
* Outputs        : None
* Returns        : None
* Description    : This function  Validates params, updates meas context lists
*              and triggers reconfig if reqd
****************************************************************************/
static rrm_return_et
rrmcm_validate_and_process_meas_config_req_params(
    rrm_cell_context_t                       *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
    rrm_bool_et                              *p_reconfig_reqd,
    rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    rrm_return_et                    ret_val        = RRM_SUCCESS;
    rrm_rat_type_et                  restore_till_freq_type = RRM_CELL_UNDEFINED;        

    RRM_UT_TRACE_ENTER();

    ret_val = rrmcm_validate_meas_config_eutran_params(
        p_cell_ctx, p_meas_config_req, p_reconfig_reqd, p_error_code);
    if(RRM_SUCCESS == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Validation SUCCESS for Eutran params");
        ret_val = rrmcm_validate_meas_config_utran_params(
                p_cell_ctx, p_meas_config_req, p_reconfig_reqd, p_error_code, &restore_till_freq_type);
        if(RRM_SUCCESS == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Validation SUCCESS for Utran params");
            ret_val = rrmcm_validate_meas_config_geran_params(
                    p_cell_ctx, p_meas_config_req, p_reconfig_reqd, p_error_code);
            if(RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Validation SUCCESS for Geran params. Reconfig Reqd = %d",
                        *p_reconfig_reqd);
                ret_val = rrmcm_validate_meas_config_cdma_params(
                        p_cell_ctx, p_meas_config_req, p_reconfig_reqd, p_error_code);
                if (RRM_SUCCESS == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Validation SUCCESS for CDMA params");
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Validation FAILURE for CDMA params");
                     /* If CDMA validation fails, Restore EUTRA, UTRAN, GERAN and CDMA lists */
                     restore_till_freq_type = RRM_CDMA_CELL;
                }
 
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Validation FAILURE for Geran params");
                /* If GERAN validation fails, Restore EUTRAN, UTRAN and GERAN lists */
                restore_till_freq_type = RRM_GERAN_CELL;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Validation FAILURE for Utran params");

            /* TDD Support SON Delete */
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Validation FAILURE for Eutran params");
        /* If EUTRAN validation fails, Restore EUTRAN list */
        restore_till_freq_type = RRM_EUTRAN_CELL;
    }

    if(RRM_FAILURE == ret_val)
    {
        *p_reconfig_reqd = RRM_FALSE;

        rrmcm_restore_meas_context_lists(p_cell_ctx, p_meas_config_req, restore_till_freq_type);

        /* If reconfig req has been triggered in previous req */
        if((CELL_STATE_W_FOR_CELL_RECONFIG_RESP != p_cell_ctx->cell_state) &&
            (RRM_PNULL != p_cell_ctx->p_meas_config_sib_info_for_reconfig))
        {
            RRM_MEM_FREE(p_cell_ctx->p_meas_config_sib_info_for_reconfig);    
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Memory freed for p_meas_config_sib_info_for_reconfig struct");
        }
    }
    else if(RRM_TRUE == *p_reconfig_reqd)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Validation SUCCESS for ALL params. Triggering Reconfig");
        /* Trigger reconfig */
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove = RRM_FALSE;
        ret_val = build_send_rrc_reconfig_req_for_son(p_cell_ctx);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
* Function Name  : rrmcm_update_meas_context_list_data 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : None
* Description    : Before the processing of Meas Config Req received from SON
*          this function updates the already existing meas object 
*          nodes to distinguish them from those which will be created
*          through the current request
****************************************************************************/
static rrm_void_t
rrmcm_update_meas_context_list_data(
    rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    meas_eutran_context_list_t      *p_meas_eutran_list = RRM_PNULL;
    meas_utran_context_list_t       *p_meas_utran_list  = RRM_PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_context_list_t   *p_meas_utran_tdd_list  = RRM_PNULL;
    /* TDD Support SON End */
    meas_geran_context_list_t       *p_meas_geran_list  = RRM_PNULL;
    meas_cdma_context_list_t       *p_meas_cdma_list  = RRM_PNULL;
    meas_cdma_node_t               *p_meas_cdma_node  = RRM_PNULL;
    meas_eutran_node_t              *p_meas_eutran_node = RRM_PNULL;
    meas_utran_node_t               *p_meas_utran_node  = RRM_PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_node_t           *p_meas_utran_tdd_node  = RRM_PNULL;
    /* TDD Support SON End */
    meas_geran_node_t               *p_meas_geran_node  = RRM_PNULL;
    YLNODE                          *p_node             = RRM_PNULL;
    U8                              index               = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_meas_eutran_list = &(p_cell_ctx->meas_eutran_list);
    p_meas_utran_list  = &(p_cell_ctx->meas_utran_list);
    /* TDD Support SON Start */
    p_meas_utran_tdd_list  = &(p_cell_ctx->meas_utran_tdd_list);
    /* TDD Support SON End */
    p_meas_geran_list  = &(p_cell_ctx->meas_geran_list);
    p_meas_cdma_list  = &(p_cell_ctx->meas_cdma_list);
    p_node = rrm_get_first_list_node(p_meas_eutran_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_eutran_node =  YMEMBEROF(meas_eutran_node_t, sNode, p_node);
        if(INVALID_OFFSET_FREQ == p_meas_eutran_node->eutran_config.prev_offset_frequency)
        {
            p_meas_eutran_node->eutran_config.prev_offset_frequency = 
                p_meas_eutran_node->eutran_config.offset_frequency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "For EARFCN = %d, Updated prev_offset_frequency = %d",
                p_meas_eutran_node->eutran_config.earfcn,
                p_meas_eutran_node->eutran_config.prev_offset_frequency);
        }        
        p_node = rrm_get_next_list_node(p_node);
    }

    p_node = rrm_get_first_list_node(p_meas_utran_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_utran_node =  YMEMBEROF(meas_utran_node_t, sNode, p_node);
        if(INVALID_OFFSET_FREQ == p_meas_utran_node->utran_config.prev_offset_frequency)
        {
            p_meas_utran_node->utran_config.prev_offset_frequency = 
                p_meas_utran_node->utran_config.offset_frequency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "For UARFCN = %d, Updated prev_offset_frequency = %d",
                p_meas_utran_node->utran_config.uarfcn,
                p_meas_utran_node->utran_config.prev_offset_frequency);
        }        
        p_node = rrm_get_next_list_node(p_node);
    }

    /* TDD Support SON Start */
    p_node = rrm_get_first_list_node(p_meas_utran_tdd_list);
    for(index = 0; RRM_PNULL != p_node; index++)
    {
        p_meas_utran_tdd_node =  YMEMBEROF(meas_utran_tdd_node_t, sNode, p_node);
        if(INVALID_OFFSET_FREQ == p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency)
        {
            p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency = 
                p_meas_utran_tdd_node->utran_tdd_config.offset_frequency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "For UARFCN = %d, Updated prev_offset_frequency = %d",
                p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd,
                p_meas_utran_tdd_node->utran_tdd_config.prev_offset_frequency);
        }        
        p_node = rrm_get_next_list_node(p_node);
    }
    /* TDD Support SON End */

    p_node = rrm_get_first_list_node(p_meas_geran_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_geran_node =  YMEMBEROF(meas_geran_node_t, sNode, p_node);
        if(INVALID_OFFSET_FREQ == p_meas_geran_node->geran_config.prev_offset_frequency)
        {
            p_meas_geran_node->geran_config.prev_offset_frequency = 
                p_meas_geran_node->geran_config.offset_frequency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "For GERAN ARFCN = %d, Updated prev_offset_frequency = %d",
                p_meas_geran_node->geran_config.starting_arfcn,
                p_meas_geran_node->geran_config.prev_offset_frequency);
        }        
        p_node = rrm_get_next_list_node(p_node);
    }
    p_node = rrm_get_first_list_node(p_meas_cdma_list);
    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_cdma_node =  YMEMBEROF(meas_cdma_node_t, sNode, p_node);
        if(INVALID_OFFSET_FREQ == p_meas_cdma_node->cdma_config.prev_offset_frequency)
        {
            p_meas_cdma_node->cdma_config.prev_offset_frequency =
                p_meas_cdma_node->cdma_config.offset_frequency;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "For CDMA Type = %d, Band class = %d & ARFCN = %d " 
                "Updated prev_offset_frequency = %d",
                p_meas_cdma_node->cdma_config.cdma_type,
                p_meas_cdma_node->cdma_config.band_class,
                p_meas_cdma_node->cdma_config.arfcn,
                p_meas_cdma_node->cdma_config.prev_offset_frequency);
        }
        p_node = rrm_get_next_list_node(p_node);
     }

    
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrmcm_check_meas_req_for_duplicate_freqs
 *   DESCRIPTION:
 *          This function checks the meas config request for the presence of
 *          duplicate frequencies. If any duplicate freq is present, returns
 *          failure.
 *   RETURNS:
 *             rrm_return_et
 ******************************************************************************/
rrm_return_et
rrmcm_check_meas_req_for_duplicate_freqs
(
   rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req,
   rrm_error_et                             *p_error_code /* Coverity_ID : 16486 */
)
{
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;
    U8                               following_list_index = RRM_ZERO;
    rrm_return_et                    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* Check for EUTRAN frequencies */
    freq_list = p_meas_config_req->meas_config_req.eutran_config_list_size;
    /* Coverity 54995 Fix Start */
    if(freq_list > MAX_SON_MEAS_CONFIG_OBJECT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "EUTRAN freq list size is greater than max value so overwriting"
                "with max value");
        freq_list = MAX_SON_MEAS_CONFIG_OBJECT;
    }
    /* Coverity 54995 Fix End */

    /* Coverity_fix_start_54995 */
    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list)&& (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT - RRM_ONE));
    freq_list_index++)
    {
    /* Coverity_fix_end_54995 */
        /* Start fix for Coverity_ID : 62562 */
        for((following_list_index = freq_list_index + RRM_ONE);
                ((following_list_index < freq_list) && (following_list_index < MAX_SON_MEAS_CONFIG_OBJECT));
                (following_list_index++))
            /* End fix for Coverity_ID : 62562 */

        {
            if(p_meas_config_req->meas_config_req.eutran_config_list
                    [freq_list_index].earfcn == p_meas_config_req->
                    meas_config_req.eutran_config_list[following_list_index].earfcn)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Duplicate EUTRAN freq = %d present at index %d and %d",
                p_meas_config_req->meas_config_req.eutran_config_list
                [freq_list_index].earfcn, freq_list_index, following_list_index);

                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_INVALID_PARAMS;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
    }

    /*  for UTRAN frequencies */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   utran_config_list.utran_fdd_list_size;
    /* Coverity 54995 Fix Start */
    if(freq_list > MAX_SON_MEAS_CONFIG_OBJECT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "UTRAN freq list size is greater than max value so overwriting"
                "with max value");
        freq_list = MAX_SON_MEAS_CONFIG_OBJECT;
    }
    /* Coverity 54995 Fix End */

    for (freq_list_index = RRM_ZERO; freq_list_index < freq_list; freq_list_index++)
    {
        for(following_list_index = freq_list_index + RRM_ONE;
                following_list_index < freq_list; following_list_index++)
        {
            if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    utran_config_list.utran_fdd_list[freq_list_index].uarfcn ==
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    utran_config_list.utran_fdd_list[following_list_index].uarfcn)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Duplicate FDD UTRAN freq = %d present at index %d and %d",
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_fdd_list[freq_list_index].uarfcn,
                freq_list_index, following_list_index);

                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_INVALID_PARAMS;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
    }
    /* TDD Support SON Start */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   utran_config_list.utran_tdd_list_size;
    /* Coverity 54995 Fix Start */
    if(freq_list > MAX_SON_MEAS_CONFIG_OBJECT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "UTRAN freq list size is greater than max value so overwriting"
                "with max value");
        freq_list = MAX_SON_MEAS_CONFIG_OBJECT;
    }
    /* Coverity 54995 Fix End */

    for (freq_list_index = 0; freq_list_index < freq_list; freq_list_index++)
    {
        for(following_list_index = freq_list_index + 1;
                following_list_index < freq_list; following_list_index++)
        {
            if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    utran_config_list.utran_tdd_list[freq_list_index].uarfcn ==
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    utran_config_list.utran_tdd_list[following_list_index].uarfcn)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Duplicate TDD UTRAN freq = %d present at index %d and %d",
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                utran_config_list.utran_tdd_list[freq_list_index].uarfcn,
                freq_list_index, following_list_index);

                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_INVALID_PARAMS;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
    }
    /* TDD Support SON End */
    
    /* Check for GERAN frequencies */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   geran_config_list.geran_freq_info_list_size;
    /* Coverity 54995 Fix Start */
    if(freq_list > MAX_SON_MEAS_CONFIG_OBJECT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "GERAN freq list size is greater than max value so overwriting"
                "with max value");
        freq_list = MAX_SON_MEAS_CONFIG_OBJECT;
    }
    /* Coverity 54995 Fix End */

    for (freq_list_index = RRM_ZERO; freq_list_index < freq_list; freq_list_index++)
    {
        for(following_list_index = freq_list_index + RRM_ONE;
                following_list_index < freq_list; following_list_index++)
        {
            if(p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    geran_config_list.geran_freq_info_list[freq_list_index].
                    geran_car_freqs.starting_arfcn ==
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    geran_config_list.geran_freq_info_list
                    [following_list_index].geran_car_freqs.starting_arfcn)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Duplicate GERAN freq = %d present at index %d and %d",
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                geran_config_list.geran_freq_info_list[freq_list_index].
                geran_car_freqs.starting_arfcn, freq_list_index, following_list_index);

                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_INVALID_PARAMS;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
    }

        /* Check for CDMA frequencies */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                       cdma_config_list.cdma_freq_info_list_size;
    /* Coverity 54995 Fix Start */
    if(freq_list > MAX_SON_MEAS_CONFIG_OBJECT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "CDMA freq list size is greater than max value so overwriting"
                "with max value");
        freq_list = MAX_SON_MEAS_CONFIG_OBJECT;
    }
    /* Coverity 54995 Fix End */

    for (freq_list_index = RRM_ZERO; freq_list_index < freq_list; freq_list_index++)
    {
        for(following_list_index = freq_list_index + RRM_ONE;
                following_list_index < freq_list; following_list_index++)
        {
            if((p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    cdma_config_list.cdma_freq_info_list
                    [freq_list_index].band_class ==
                    p_meas_config_req->meas_config_req.inter_rat_meas_config.
                    cdma_config_list.cdma_freq_info_list
                    [following_list_index].band_class) &&
                (p_meas_config_req->meas_config_req.inter_rat_meas_config.
                     cdma_config_list.cdma_freq_info_list
                     [freq_list_index].arfcn ==
                     p_meas_config_req->meas_config_req.inter_rat_meas_config.
                     cdma_config_list.cdma_freq_info_list
                     [following_list_index].arfcn))
                    
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Duplicate CDMA band_class = %d , and freq = %d, present at index %d and %d",
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_list_index].band_class,
                p_meas_config_req->meas_config_req.inter_rat_meas_config.
                cdma_config_list.cdma_freq_info_list[freq_list_index].arfcn,
                freq_list_index, following_list_index);

                ret_val = RRM_FAILURE;
                *p_error_code = RRM_ERR_INVALID_PARAMS;
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
          }
      }
 
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* OFFSET FREQ CHANGES START */
static rrm_void_t
rrmcm_commit_off_freq_from_nodes_to_cell_params(
    rrm_cell_context_t *p_cell_ctx,
    rrmcm_rmif_cell_son_meas_config_req_t    *p_meas_config_req
)
{
    meas_eutran_node_t              *p_meas_eutran_node = RRM_PNULL;
    meas_utran_node_t               *p_meas_utran_node  = RRM_PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_node_t           *p_meas_utran_tdd_node  = RRM_PNULL;
    /* TDD Support SON End */
    meas_geran_node_t               *p_meas_geran_node  = RRM_PNULL;
    meas_cdma_node_t               *p_meas_cdma_node  = RRM_PNULL;
    U8                               freq_list = RRM_ZERO;
    U8                               freq_list_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Update EUTRAN offset freq */
    freq_list = p_meas_config_req->meas_config_req.eutran_config_list_size;
    /* Coverity: CID 54995 */
    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT));
        freq_list_index++)
    {
        p_meas_eutran_node = rrmcm_find_eutran_meas_context(
                p_meas_config_req->meas_config_req.eutran_config_list
                [freq_list_index].earfcn, p_cell_ctx);
        if(RRM_PNULL != p_meas_eutran_node)
        {
            if(FREQ_NOT_CONFIGURED != p_meas_eutran_node->cell_ctx_index)
            {
                if(p_meas_eutran_node->eutran_config.earfcn !=
                        p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn)
                {
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_freq_params
                        [p_meas_eutran_node->cell_ctx_index].cm_offset_freq =
                        p_meas_eutran_node->eutran_config.offset_frequency; 

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "For EARFCN = %d, Updated offset_frequency = %d in cell ctx params",
                            p_meas_eutran_node->eutran_config.earfcn,
                            p_meas_eutran_node->eutran_config.offset_frequency);
                }
            }        
        }
    }

    /* Update UTRAN offset freq */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   utran_config_list.utran_fdd_list_size;

    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
    {
        p_meas_utran_node = rrmcm_find_utran_meas_context(
                p_meas_config_req->meas_config_req.inter_rat_meas_config.utran_config_list.
                utran_fdd_list[freq_list_index].uarfcn, p_cell_ctx);
        if(RRM_PNULL != p_meas_utran_node)
        {
            if(FREQ_NOT_CONFIGURED != p_meas_utran_node->cell_ctx_index)
            {
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers
                    [p_meas_utran_node->cell_ctx_index].offset_freq =
                    p_meas_utran_node->utran_config.offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "For FDD UARFCN = %d, Updated offset_frequency = %d in cell ctx params",
                        p_meas_utran_node->utran_config.uarfcn,
                        p_meas_utran_node->utran_config.offset_frequency);
            }        
        }
    }
    /* TDD Support SON Start */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   utran_config_list.utran_tdd_list_size;

    for (freq_list_index = 0; ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
    {
        p_meas_utran_tdd_node = rrmcm_find_utran_tdd_meas_context(
                p_meas_config_req->meas_config_req.inter_rat_meas_config.utran_config_list.
                utran_tdd_list[freq_list_index].uarfcn, p_cell_ctx);
        if(RRM_PNULL != p_meas_utran_tdd_node)
        {
            if(FREQ_NOT_CONFIGURED != p_meas_utran_tdd_node->cell_ctx_index)
            {
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers
                    [p_meas_utran_tdd_node->cell_ctx_index].offset_freq =
                    p_meas_utran_tdd_node->utran_tdd_config.offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "For TDD UARFCN = %d, Updated offset_frequency = %d in cell ctx params",
                        p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd,
                        p_meas_utran_tdd_node->utran_tdd_config.offset_frequency);
            }        
        }
    }
    /* TDD Support SON End */

    /* Update GERAN offset freq */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                   geran_config_list.geran_freq_info_list_size;

    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
    {
        p_meas_geran_node = rrmcm_find_geran_meas_context(
                p_meas_config_req->meas_config_req.inter_rat_meas_config.geran_config_list.
                geran_freq_info_list[freq_list_index].geran_car_freqs.starting_arfcn,
                p_meas_config_req->meas_config_req.inter_rat_meas_config.geran_config_list.
                geran_freq_info_list[freq_list_index].geran_car_freqs.band_ind, p_cell_ctx);

        if(RRM_PNULL != p_meas_geran_node)
        {
            if(FREQ_NOT_CONFIGURED != p_meas_geran_node->cell_ctx_index)
            {
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers
                    [p_meas_geran_node->cell_ctx_index].offset_freq =
                    p_meas_geran_node->geran_config.offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "For GERAN ARFCN = %d Band Ind = %d, Updated offset_frequency ="
                        " %d in cell ctx params", 
                        p_meas_geran_node->geran_config.starting_arfcn,
                        p_meas_geran_node->geran_config.band_ind,
                        p_meas_geran_node->geran_config.offset_frequency);
            }        
        }
    }
/* Update CDMA freq */
        /* Check for CDMA frequencies */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                       cdma_config_list.cdma_freq_info_list_size;

    for (freq_list_index = RRM_ZERO; ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
    {
        p_meas_cdma_node = rrmcm_find_cdma_meas_context(
           p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
           cdma_freq_info_list[freq_list_index].arfcn, 
           p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
           cdma_freq_info_list[freq_list_index].band_class, p_cell_ctx);
 
       if (RRM_NULL != p_meas_cdma_node)
       {
            if(FREQ_NOT_CONFIGURED != p_meas_cdma_node->cell_ctx_index)
            {
/*
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers
                    [p_meas_geran_node->cell_ctx_index].offset_freq =
                    p_meas_geran_node->geran_config.offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "For GERAN ARFCN = %d Band Ind = %d, Updated offset_frequency ="
                        " %d in cell ctx params", 
                        p_meas_geran_node->geran_config.starting_arfcn,
                        p_meas_geran_node->geran_config.band_ind,
                        p_meas_geran_node->geran_config.offset_frequency);
*/
             }        
            
       
       
       
       }
    }
/* Update CDMA freq */
        /* Check for CDMA frequencies */
    freq_list = p_meas_config_req->meas_config_req.inter_rat_meas_config.
                       cdma_config_list.cdma_freq_info_list_size;

    for (freq_list_index = 0; ((freq_list_index < freq_list) && (freq_list_index < MAX_SON_MEAS_CONFIG_OBJECT)); freq_list_index++)
    {
        p_meas_cdma_node = rrmcm_find_cdma_meas_context(
           p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
           cdma_freq_info_list[freq_list_index].arfcn, 
           p_meas_config_req->meas_config_req.inter_rat_meas_config.cdma_config_list.
           cdma_freq_info_list[freq_list_index].band_class, p_cell_ctx);
 
       if (RRM_NULL != p_meas_cdma_node)
       {
            if(FREQ_NOT_CONFIGURED != p_meas_cdma_node->cell_ctx_index)
            {
/*
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers
                    [p_meas_geran_node->cell_ctx_index].offset_freq =
                    p_meas_geran_node->geran_config.offset_frequency;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "For GERAN ARFCN = %d Band Ind = %d, Updated offset_frequency ="
                        " %d in cell ctx params", 
                        p_meas_geran_node->geran_config.starting_arfcn,
                        p_meas_geran_node->geran_config.band_ind,
                        p_meas_geran_node->geran_config.offset_frequency);
*/
             }        
            
       
       
       
       }
    }
 
    RRM_UT_TRACE_EXIT();
}
/* OFFSET FREQ CHANGES END */
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rmcm_mif_meas_config_req_non_cgi
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Create Meas context per freq and store parameters received
 : in meas config request in that.
 ****************************************************************************/
rrm_error_et
rmcm_mif_meas_config_req_non_cgi(rrm_cell_context_t                     *p_cell_ctx,
                                 rrmcm_rmif_cell_son_meas_config_req_t  *p_meas_config_req,
                                 U8                                     *resp_send,
                                 rrm_return_et                          *result)

{
        rrm_error_et                           error_code = RRM_NO_ERROR;
        rrm_bool_et                            reconfig_reqd  = RRM_FALSE;
        *result = rrmcm_validate_utran_mand_params(p_cell_ctx, p_meas_config_req);
        RRM_UT_TRACE_ENTER();
        if((*result) == RRM_SUCCESS) 
        {
        /* Fix 8172 End */
            *result = rrmcm_validate_geran_mand_params(p_cell_ctx, p_meas_config_req);
            if(RRM_FAILURE == (*result))
            {
                error_code = RRM_ERR_INVALID_PARAMS;
#ifdef RRM_UT_FLAG        
                RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
                RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F_inv_param);
#endif        
		
            }
        }
        if(RRM_SUCCESS == (*result))
        {
            *result = rrmcm_check_meas_req_for_duplicate_freqs(
                        p_meas_config_req, &error_code);

            if(RRM_SUCCESS == *result)
            {
                /* Update Prev offset freq value for the list nodes */ 
                rrmcm_update_meas_context_list_data(p_cell_ctx);

                /* Validate params, update meas context lists
                   and trigger reconfig if reqd */
                *result = rrmcm_validate_and_process_meas_config_req_params(p_cell_ctx, 
                        p_meas_config_req, &reconfig_reqd, &error_code);

                /* If reconfig req is triggered to RRC, meas config resp will be sent
                 * to SON on receipt of reconfig resp from RRC */
                if(RRM_TRUE == reconfig_reqd)
                {
                    *resp_send = RRM_FAILURE;
#ifdef RRM_UT_FLAG        
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F_inv_param);
#endif        
                }
                /* OFFSET FREQ CHANGES START */
                else
                {
                    rrmcm_commit_off_freq_from_nodes_to_cell_params(p_cell_ctx, p_meas_config_req);
                }
                /* OFFSET FREQ CHANGES END */
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Returning Failure to SON due to Duplicate freq presence in Meas Config Req");
               
		
            }
        }
 RRM_UT_TRACE_EXIT();
 return error_code;
     
}
/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rmcm_mif_meas_config_req 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Create Meas context per freq and store parameters received 
 : in meas config request in that.
 ****************************************************************************/
rrm_return_et
rmcm_mif_meas_config_req
(
    rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    rrm_return_et                          result = RRM_SUCCESS; /* Coverity: CID 56723 */
    rrm_error_et                           error_code = RRM_NO_ERROR; /* Coverity_ID : 16486 */
    U8                                     resp_send = RRM_SUCCESS;
    rrm_return_et                           ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_son_meas_config_req_t  *p_meas_config_req = RRM_PNULL;

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);    
    RRM_UT_TRACE_ENTER();
    /*15074_start*/
    p_meas_config_req = (rrmcm_rmif_cell_son_meas_config_req_t *)
        (p_cell_ctx->p_incoming_api_info); 
    /*15074_end*/
    /* Fix for Coverity, LTE_RRM_MALL:CID:11125, [Prasant] */
    if ((!p_meas_config_req->meas_config_req.eutran_config_list_size) &&
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
               utran_config_list.utran_fdd_list_size)) &&
            /* TDD Support SON Start */
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
               utran_config_list.utran_tdd_list_size)) &&
            /* TDD Support SON End */
            /* Fix 8172 Start */
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
               utran_config_list.bitmask)) &&
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
               geran_config_list.geran_freq_info_list_size)) &&
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
               geran_config_list.bitmask)) &&
            /* Fix 8172 End */
            (!(p_meas_config_req->meas_config_req.inter_rat_meas_config.
               cdma_config_list.cdma_freq_info_list_size))
            )
        
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "rmcm_mif_meas_config_req: Empty Meas Config Request "
                "received for cell index = %u",
                (U16)p_meas_config_req->cellindex);

        result = RRM_FAILURE;
        error_code = RRM_ERR_INVALID_PARAMS;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F_inv_param);
#endif        
	

        /* Send Resp to RMIF. */
        rmcm_mif_meas_config_resp(p_cell_ctx, (U8)result, error_code, RRMCM_RMIF_MEAS_CONFIG_RESP); /* Coverity: CID 56723 */

        RRM_UT_TRACE_EXIT();
        return result;
    }
    /*Check that whether the req is to get the CGI of newly detected cells*/
    ret_val = rrmcm_check_meas_req_for_cgi(p_meas_config_req, &error_code);
    if(ret_val == RRM_SUCCESS) 
    {
        /* Check if the ue_index is present required for CGI reporting */
        if((RRM_ERR_INVALID_PARAMS == error_code) || 
            (!(RRM_SON_UE_INDEX_PRESENT & p_meas_config_req->meas_config_req.bitmask)))
        {
            result = RRM_FAILURE;
            error_code = RRM_ERR_INVALID_PARAMS;   
        }
        else 
        {
            resp_send = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "rmcm_mif_meas_config_req: Request for CGI Detection");

            rrm_uem_send_meas_config_req_for_cgi_reporting( p_cell_ctx, 
                    &(p_meas_config_req->meas_config_req));
        }
    }
    else
    {
        /* Fix 8172 Start */
        /*Klockwork_fix_start*/
        error_code = rmcm_mif_meas_config_req_non_cgi(p_cell_ctx ,p_meas_config_req ,
                                                      &resp_send ,&result);
        /*Klockwork_fix_end*/
    }
    if(resp_send == RRM_SUCCESS)
    {
        /* Send Resp to RMIF. */
        rmcm_mif_meas_config_resp(p_cell_ctx, (U8)result, error_code, RRMCM_RMIF_MEAS_CONFIG_RESP);/* Coverity: CID 56723 */
    }

    RRM_UT_TRACE_EXIT();
    return result;
}
/* MEAS CONFIG REL1.2: END*/

/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_eutran_freq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_earfcn_remove_list: List of EARFCNs to be deleted
 *                  U8   earfcn_remove_list_size :No. of EARFCNs to be deleted
 * Outputs        : None
 * Returns        : None
 * Description    : Fill the freq list info in the reconfig structure (SIB 5)
 *                  by not including the requested frequencies to be deleted
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_eutran_freq
(
    rrm_cell_context_t      *p_cell_ctx,
    U16                     *p_earfcn_remove_list,
    U8                      earfcn_remove_list_size
)
{
    rrm_bool_et                     remove_freq         = RRM_FALSE;
    U8                              cell_ctx_index      = RRM_ZERO;
    U8                              del_list_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    idle_mode_mobility_params_t     *p_cell_ctx_params  = RRM_PNULL;
    rrmcm_eutran_params_t           *p_reconfig_eutran_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params);
    p_reconfig_eutran_params = &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params);

    /* For each freq configured in cell context check its presence in remove list of Req */
    for(cell_ctx_index = RRM_ZERO; cell_ctx_index < p_cell_ctx_params->num_valid_inter_freq_list;
            cell_ctx_index++)
    {
        remove_freq = RRM_FALSE;

        for(del_list_index = RRM_ZERO; del_list_index < earfcn_remove_list_size; del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(p_cell_ctx_params->idle_mode_mobility_inter_freq_params[cell_ctx_index].
                    eutra_carrier_arfcn ==
                    p_earfcn_remove_list[del_list_index])
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Removing Earfcn = %d from cell index = %d",
                    p_earfcn_remove_list[del_list_index], cell_ctx_index);
                remove_freq = RRM_TRUE;

                /* Start: Enh 317 */
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
                    RRMCM_INTER_FREQ_PARAMS_PRESENT;
                /* End: Enh 317 */
                break;
            }
        }
        if(remove_freq == RRM_FALSE)
        {
            /* If the freq is not present in the requested remove list copy it to reconfig struct */
            RRM_MEMCPY(&(p_reconfig_eutran_params->idle_mode_mobility_inter_freq_params[reconfig_index]),
               &(p_cell_ctx_params->idle_mode_mobility_inter_freq_params[cell_ctx_index]),
                sizeof(inter_freq_params_t));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Copied earfcn = %d in reconfig struct", p_cell_ctx_params->
                idle_mode_mobility_inter_freq_params[cell_ctx_index].eutra_carrier_arfcn);

            reconfig_index++;
            p_reconfig_eutran_params->num_valid_inter_freq_list = reconfig_index;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_eutran_del_ncl
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_earfcn_remove_list: List of EARFCNs to be deleted
 *                  U8   earfcn_remove_list_size :No. of EARFCNs to be deleted
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Fill the freq nbr list info in the reconfig structure (SIB 5)
 *                  by not including the nbrs of requested frequencies to be deleted
 ****************************************************************************/
rrm_return_et
rrmcm_construct_reconfig_struct_for_eutran_del_ncl(rrm_cell_context_t     *p_cell_ctx,
                                                   U16                    *p_earfcn_remove_list,
                                                   rrm_bool_et            *remove_nbr,
                                                   U8                     earfcn_remove_list_size,
                                                   U8                     ncl_index ,
                                                   /*spr_fix_start_12668*/
                                                   U8                     *reconfig_index 
                                                   /*spr_fix_end_12668*/)
{
    rrm_return_et                   ret_val      = RRM_SUCCESS;
    U8                              del_list_index      = RRM_ZERO;
    ncl_params_t                    *p_cell_ctx_ncl_params = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_cell_ctx_ncl_params = &(p_cell_ctx->ran_info.ncl_params);
        for(del_list_index = RRM_ZERO;
                del_list_index < earfcn_remove_list_size;
                del_list_index++)
        {
            /* If freq of the nbr is present in the remove list of Req do not copy it */
            if(p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells[ncl_index].
                    eutra_carrier_arfcn ==
                    p_earfcn_remove_list[del_list_index])
            {
            *remove_nbr = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Removing Nbr: Earfcn = %d, PCI = %d Blacklist Status = %d",
                    p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells[ncl_index].eutra_carrier_arfcn,
                    p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells[ncl_index].phy_cell_id,
                    p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells[ncl_index].blacklisted);

                /* If first time nbr is detected to be removed */
                if(!(RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED & p_cell_ctx->updated_nrt_bitmask) &&
                    !(RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED & p_cell_ctx->updated_nrt_bitmask))
                {
                    if(!(p_cell_ctx->p_ncl_built_from_updated_nrt_info))
                    {
                        p_cell_ctx->p_ncl_built_from_updated_nrt_info = rrm_mem_get(sizeof(ncl_params_t));
                        if (p_cell_ctx->p_ncl_built_from_updated_nrt_info == RRM_FAILURE)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Memory allocation to p_cell_ctx->p_ncl_built_from_updated_nrt_info failed" );
                            ret_val = RRM_FAILURE ;
                            RRM_UT_TRACE_EXIT();
                            return ret_val;
                        }
                        RRM_MEMSET(p_cell_ctx->p_ncl_built_from_updated_nrt_info, RRM_ZERO, sizeof(ncl_params_t));
                    }
                    p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_inter_freq_cell
                        = ncl_index;

                    /* If this nbr is not at the first index in the nbr list */
                    if(RRM_ZERO < ncl_index)
                    {
                        /* Copy the already scanned nbrs at once */
                        RRM_MEMCPY(p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.inter_freq_cells,
                                p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells,
                                ncl_index * sizeof(inter_freq_cells_t));
                    }

                    *reconfig_index = ncl_index;

                    /* Start: Enh 317 */
                    if(RRM_TRUE == p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells[ncl_index]. 
                       broadcast_status)
                    {
                        p_cell_ctx->updated_nrt_bitmask |= RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED;
                    }
                    else
                    {
                        p_cell_ctx->updated_nrt_bitmask |= RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED;
                    }
                    /* End: Enh 317 */

                }
                break;
            }
        }
  RRM_UT_TRACE_EXIT();
  return ret_val;
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_eutran_ncl
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_earfcn_remove_list: List of EARFCNs to be deleted
 *                  U8   earfcn_remove_list_size :No. of EARFCNs to be deleted
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE 
 * Description    : Fill the freq nbr list info in the reconfig structure (SIB 5)
 *                  by not including the nbrs of requested frequencies to be deleted
 ****************************************************************************/
rrm_return_et
rrmcm_construct_reconfig_struct_for_eutran_ncl
(
    rrm_cell_context_t      *p_cell_ctx,
    U16                     *p_earfcn_remove_list,
    U8                      earfcn_remove_list_size
)
{
    rrm_bool_et                     remove_nbr         = RRM_FALSE;
    U8                              ncl_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    ncl_params_t                    *p_cell_ctx_ncl_params = RRM_PNULL;
    rrm_return_et                   ret_val = RRM_SUCCESS ; 
    RRM_UT_TRACE_ENTER();

    p_cell_ctx_ncl_params = &(p_cell_ctx->ran_info.ncl_params);

    /* For each Inter-freq nbr stored in the cell context, check presence of its freq in the
        remove list of the frequencies in the Req */
    for(ncl_index = RRM_ZERO; ncl_index < p_cell_ctx_ncl_params->lte_ncl.num_valid_inter_freq_cell;
            ncl_index++)
    {
        remove_nbr = RRM_FALSE;

        /*Klockwork_fix_start*/
        /*spr_fix_start_12668*/
        ret_val  = rrmcm_construct_reconfig_struct_for_eutran_del_ncl(p_cell_ctx, p_earfcn_remove_list ,
                &remove_nbr ,earfcn_remove_list_size ,ncl_index ,&reconfig_index);
        if(ret_val == RRM_FAILURE)
        {
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /*spr_fix_end_12668*/
        /*Klockwork_fix_end*/

        /* If the nbr is detected NOT to be removed but some prev nbr was removed,
           Copy the nbr in reconfig struct */
        if((remove_nbr == RRM_FALSE) && (RRM_PNULL != p_cell_ctx->p_ncl_built_from_updated_nrt_info))
        {
            RRM_MEMCPY(&(p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.inter_freq_cells[reconfig_index]),
                    &(p_cell_ctx_ncl_params->lte_ncl.inter_freq_cells[ncl_index]),
                    sizeof(inter_freq_cells_t));

            reconfig_index++;
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_inter_freq_cell = reconfig_index;

        }
    }

    /* Start: Enh 317 */
    if((RRM_PNULL != p_cell_ctx->p_ncl_built_from_updated_nrt_info) &&  /* Coverity: CID 56698 */
       (RRM_ZERO < p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_inter_freq_cell))
    {
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->bitmask |=
            RRMCM_RMIF_LTE_NCL_PRESENT;
    }
    /* End: Enh 317 */

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/* Start: Enh 317 */
/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_utran_fdd_freq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_uarfcn_fdd_remove_list: List of FDD UARFCNs to be deleted
 *                  U8   uarfcn_fdd_remove_list_size :No. of FDD UARFCNs to be deleted
 * Outputs        : None
 * Returns        : None
 * Description    : Fill the FDD UTRAN freq list info in the reconfig structure (SIB 6)
 *                  by not including the requested frequencies to be deleted
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_utran_fdd_freq
(
    rrm_cell_context_t      *p_cell_ctx,
    U16                     *p_uarfcn_fdd_remove_list,
    U8                      uarfcn_fdd_remove_list_size
)
{
    rrm_bool_et                     remove_freq         = RRM_FALSE;
    U8                              cell_ctx_index      = RRM_ZERO;
    U8                              del_list_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    irat_eutran_utran_fdd_list_t    *p_cell_ctx_params  = RRM_PNULL;
    irat_eutran_utran_fdd_list_t    *p_reconfig_utran_fdd_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list);
    p_reconfig_utran_fdd_params = &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list);

    /* For each freq configured in cell context check its presence in remove list of Req */
    for(cell_ctx_index = RRM_ZERO; cell_ctx_index < p_cell_ctx_params->num_irat_eutran_to_utran_fdd_carriers;
            cell_ctx_index++)
    {
        remove_freq = RRM_FALSE;

        for(del_list_index = RRM_ZERO; del_list_index < uarfcn_fdd_remove_list_size; del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(p_cell_ctx_params->irat_eutran_to_utran_fdd_carriers[cell_ctx_index].
                    utra_carrier_arfcn ==
                    p_uarfcn_fdd_remove_list[del_list_index])
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Removing FDD Uarfcn = %d from cell index = %d",
                    p_uarfcn_fdd_remove_list[del_list_index], cell_ctx_index);
                remove_freq = RRM_TRUE;

                p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
                    RRMCM_UTRA_FREQ_PARAMS_PRESENT;
                break;
            }
        }
        if(remove_freq == RRM_FALSE)
        {
            /* If the freq is not present in the requested remove list copy it to reconfig struct */
            RRM_MEMCPY(&(p_reconfig_utran_fdd_params->irat_eutran_to_utran_fdd_carriers[reconfig_index]),
               &(p_cell_ctx_params->irat_eutran_to_utran_fdd_carriers[cell_ctx_index]),
                sizeof(irat_eutran_utran_fdd_carriers_t));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Copied FDD uarfcn = %d in reconfig struct", p_cell_ctx_params->
                irat_eutran_to_utran_fdd_carriers[cell_ctx_index].utra_carrier_arfcn);

            reconfig_index++;
            p_reconfig_utran_fdd_params->num_irat_eutran_to_utran_fdd_carriers = reconfig_index;
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_utran_tdd_freq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_uarfcn_tdd_remove_list: List of TDD UARFCNs to be deleted
 *                  U8   uarfcn_tdd_remove_list_size :No. of TDD UARFCNs to be deleted
 * Outputs        : None
 * Returns        : None
 * Description    : Fill the TDD UTRAN freq list info in the reconfig structure (SIB 6)
 *                  by not including the requested frequencies to be deleted
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_utran_tdd_freq
(
    rrm_cell_context_t      *p_cell_ctx,
    U16                     *p_uarfcn_tdd_remove_list,
    U8                      uarfcn_tdd_remove_list_size
)
{
    rrm_bool_et                     remove_freq         = RRM_FALSE;
    U8                              cell_ctx_index      = RRM_ZERO;
    U8                              del_list_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    irat_eutran_utran_tdd_list_t    *p_cell_ctx_params  = RRM_PNULL;
    irat_eutran_utran_tdd_list_t    *p_reconfig_utran_tdd_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list);
    p_reconfig_utran_tdd_params = &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list);

    /* For each freq configured in cell context check its presence in remove list of Req */
    for(cell_ctx_index = RRM_ZERO; cell_ctx_index < p_cell_ctx_params->num_irat_eutran_to_utran_tdd_carriers;
            cell_ctx_index++)
    {
        remove_freq = RRM_FALSE;

        for(del_list_index = RRM_ZERO; del_list_index < uarfcn_tdd_remove_list_size; del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(p_cell_ctx_params->irat_eutran_to_utran_tdd_carriers[cell_ctx_index].
                    utra_carrier_arfcn ==
                    p_uarfcn_tdd_remove_list[del_list_index])
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Removing TDD Uarfcn = %d from cell index = %d",
                    p_uarfcn_tdd_remove_list[del_list_index], cell_ctx_index);
                remove_freq = RRM_TRUE;

                p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
                    RRMCM_UTRA_FREQ_PARAMS_PRESENT;
                break;
            }
        }
        if(remove_freq == RRM_FALSE)
        {
            /* If the freq is not present in the requested remove list copy it to reconfig struct */
            RRM_MEMCPY(&(p_reconfig_utran_tdd_params->irat_eutran_to_utran_tdd_carriers[reconfig_index]),
               &(p_cell_ctx_params->irat_eutran_to_utran_tdd_carriers[cell_ctx_index]),
                sizeof(irat_eutran_utran_tdd_carriers_t));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Copied TDD uarfcn = %d in reconfig struct", p_cell_ctx_params->
                irat_eutran_to_utran_tdd_carriers[cell_ctx_index].utra_carrier_arfcn);

            reconfig_index++;
            p_reconfig_utran_tdd_params->num_irat_eutran_to_utran_tdd_carriers = reconfig_index;
        }
    }
    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_utran_ncl
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_uarfcn_fdd_remove_list: List of FDD UARFCNs to be deleted
 *                  U8   uarfcn_fdd_remove_list_size :No. of FDD UARFCNs to be deleted
 *                  U16 *p_uarfcn_tdd_remove_list: List of TDD UARFCNs to be deleted
 *                  U8   uarfcn_tdd_remove_list_size :No. of TDD UARFCNs to be deleted
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE 
 * Description    : Fill the freq nbr list info in the reconfig structure 
 *                  by not including the nbrs of requested frequencies to be deleted
 ****************************************************************************/
rrm_return_et
rrmcm_construct_reconfig_struct_for_utran_ncl
(
    rrm_cell_context_t      *p_cell_ctx,
    U16                     *p_uarfcn_fdd_remove_list,
    U8                      uarfcn_fdd_remove_list_size,
    U16                     *p_uarfcn_tdd_remove_list,
    U8                      uarfcn_tdd_remove_list_size
)
{
    rrm_bool_et                     remove_nbr         = RRM_FALSE;
    U8                              ncl_index      = RRM_ZERO;
    U8                              del_list_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    ncl_params_t                    *p_cell_ctx_ncl_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_ncl_params = &(p_cell_ctx->ran_info.ncl_params);

    /* For each Inter-freq nbr stored in the cell context, check presence of its freq in the
        remove list of the frequencies in the Req */
    for(ncl_index = RRM_ZERO; ncl_index < p_cell_ctx_ncl_params->inter_rat_ncl.num_valid_utran_freq_cell;
            ncl_index++)
    {
        remove_nbr = RRM_FALSE;

        for(del_list_index = RRM_ZERO;
                (del_list_index < uarfcn_fdd_remove_list_size) || (del_list_index < uarfcn_tdd_remove_list_size);
                del_list_index++)
        {
            /* If freq of the nbr is present in the any of the remove list of Req(FDD/TDD) do not copy it */
            if(((del_list_index < uarfcn_fdd_remove_list_size) &&
                (p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells[ncl_index].uarfcndl ==
                    p_uarfcn_fdd_remove_list[del_list_index])) ||
               ((del_list_index < uarfcn_tdd_remove_list_size) &&
                (p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells[ncl_index].uarfcndl ==
                    p_uarfcn_tdd_remove_list[del_list_index]))) 
            {
                remove_nbr = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Removing Nbr: Uarfcn = %d, PCI = %d Blacklist Status = %d",
                        p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells[ncl_index].uarfcndl,
                        p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells[ncl_index].pcpich_scrambling_code,
                        p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells[ncl_index].blacklisted);

                /* If first UTRAN nbr is detected to be removed */
                if(!(RRM_UTRAN_NBRS_UPDATED & p_cell_ctx->updated_nrt_bitmask))
                {
                    if(!(p_cell_ctx->p_ncl_built_from_updated_nrt_info))
                    {
                        p_cell_ctx->p_ncl_built_from_updated_nrt_info = rrm_mem_get(sizeof(ncl_params_t));
                        if (p_cell_ctx->p_ncl_built_from_updated_nrt_info == RRM_FAILURE)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_cell_ctx->p_ncl_built_from_updated_nrt_info failed" );
                            RRM_UT_TRACE_EXIT();
                            return RRM_FAILURE;
                        }

                        RRM_MEMSET(p_cell_ctx->p_ncl_built_from_updated_nrt_info, RRM_ZERO, sizeof(ncl_params_t));
                    }

                    p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_utran_freq_cell
                        = ncl_index;

                    /* If this nbr is not at the first index in the nbr list */
                    if(RRM_ZERO < ncl_index)
                    {
                        /* Copy the already scanned nbrs at once */
                        RRM_MEMCPY(p_cell_ctx->p_ncl_built_from_updated_nrt_info->
                                inter_rat_ncl.utran_freq_cells,
                                p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells,
                                ncl_index * sizeof(utran_freq_cells_t));
                    }

                    reconfig_index = ncl_index;
                    p_cell_ctx->updated_nrt_bitmask |= RRM_UTRAN_NBRS_UPDATED;
                }
                break;
            }
        }
        /* If the nbr is detected NOT to be removed but some prev nbr was removed,
            Copy the nbr in reconfig struct */
        if((remove_nbr == RRM_FALSE) && (RRM_UTRAN_NBRS_UPDATED & p_cell_ctx->updated_nrt_bitmask))
        {
            RRM_MEMCPY(&(p_cell_ctx->p_ncl_built_from_updated_nrt_info->
                inter_rat_ncl.utran_freq_cells[reconfig_index]),
               &(p_cell_ctx_ncl_params->inter_rat_ncl.utran_freq_cells[ncl_index]),
                sizeof(inter_freq_cells_t));

            reconfig_index++;
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->
            inter_rat_ncl.num_valid_utran_freq_cell = reconfig_index;
        }
    }

    if((p_cell_ctx->p_ncl_built_from_updated_nrt_info) && 
        (RRM_ZERO < p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_utran_freq_cell))
    {
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->bitmask |=
            RRMCM_RMIF_INTER_RAT_NCL_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_utran_freq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  rrm_son_meas_config_obj_remove_req_t
 *                      *p_meas_config_obj_remove_req : Pointer to the req rcvd
 *                      from MIF
 * Outputs        : None
 * Returns        : None
 * Description    : Call the handlers to construct the reconfig structure
 *                  for UTRAN by deleting the requested frequencies
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_utran_freq
(
    rrm_cell_context_t                         *p_cell_ctx,
    rrm_son_meas_config_obj_remove_req_t       *p_meas_config_obj_remove_req
)
{
    RRM_UT_TRACE_ENTER();

    if(RRM_ZERO < p_meas_config_obj_remove_req->uarfcn_fdd_remove_list_size)
    {
        /* Prepare the frequency list with requested nbrs removed */
        rrmcm_construct_reconfig_struct_for_utran_fdd_freq(p_cell_ctx,
                p_meas_config_obj_remove_req->uarfcn_fdd_remove_list,
                p_meas_config_obj_remove_req->uarfcn_fdd_remove_list_size);
    }
    if(RRM_ZERO < p_meas_config_obj_remove_req->uarfcn_tdd_remove_list_size)
    {
        /* Prepare the frequency list with requested nbrs removed */
        rrmcm_construct_reconfig_struct_for_utran_tdd_freq(p_cell_ctx,
                p_meas_config_obj_remove_req->uarfcn_tdd_remove_list,
                p_meas_config_obj_remove_req->uarfcn_tdd_remove_list_size);
    }

    /* If any UTRAN freq is removed, copy reselection params from Cell ctxt for SIB broadcast */
    if(p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask &
        RRMCM_UTRA_FREQ_PARAMS_PRESENT)
    {
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->
            utran_params.idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.t_reselection_utra =
            p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.
            irat_eutra_to_utra_reselection_params.t_reselection_utra;

        if(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params.bitmask &
                RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT)
        {
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutra_to_utra_reselection_params.speed_state_scale_factor =
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.
                irat_eutra_to_utra_reselection_params.speed_state_scale_factor ;

            p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                utran_params.idle_mode_mobility_irat_utra_params.
                irat_eutra_to_utra_reselection_params.bitmask |=
                RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT;
        }

        /* If any UTRAN freq is removed, find and remove the nbrs of that freq from NCL */
        if((p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
            && (p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_utran_freq_cell))
        {
            rrmcm_construct_reconfig_struct_for_utran_ncl(p_cell_ctx,
                    p_meas_config_obj_remove_req->uarfcn_fdd_remove_list,
                    p_meas_config_obj_remove_req->uarfcn_fdd_remove_list_size,
                    p_meas_config_obj_remove_req->uarfcn_tdd_remove_list,
                    p_meas_config_obj_remove_req->uarfcn_tdd_remove_list_size);
        }
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_geran_freq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_geran_remove_list: List of FDD UARFCNs to be deleted
 *                  U8   geran_remove_list_size :No. of FDD UARFCNs to be deleted
 * Outputs        : None
 * Returns        : None
 * Description    : Fill the GERAN freq list info in the reconfig structure (SIB 7)
 *                  by not including the requested frequencies to be deleted
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_geran_freq
(
    rrm_cell_context_t              *p_cell_ctx,
    rrm_son_geran_carrier_freqs_t   *p_geran_remove_list,
    U8                              geran_remove_list_size
)
{
    rrm_bool_et                     remove_freq         = RRM_FALSE;
    U8                              cell_ctx_index      = RRM_ZERO;
    U8                              del_list_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    irat_eutran_geran_list_t    *p_cell_ctx_params  = RRM_PNULL;
    irat_eutran_geran_list_t    *p_reconfig_geran_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_params = &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list);
    p_reconfig_geran_params = &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
        idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list);

    /* For each freq configured in cell context check its presence in remove list of Req */
    for(cell_ctx_index = RRM_ZERO; cell_ctx_index < p_cell_ctx_params->num_irat_eutran_to_geran_carriers;
            cell_ctx_index++)
    {
        remove_freq = RRM_FALSE;

        for(del_list_index = RRM_ZERO; del_list_index < geran_remove_list_size; del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(p_cell_ctx_params->irat_eutran_to_geran_carriers[cell_ctx_index].
                    geran_car_freqs.starting_arfcn ==
                    p_geran_remove_list[del_list_index].starting_arfcn)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Removing Geran arfcn = %d from cell index = %d",
                        p_geran_remove_list[del_list_index].starting_arfcn, cell_ctx_index);
                remove_freq = RRM_TRUE;

                p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask |=
                    RRMCM_GERAN_FREQ_PARAMS_PRESENT;
                break;
            }
        }
        if(remove_freq == RRM_FALSE)
        {
            /* If the freq is not present in the requested remove list copy it to reconfig struct */
            RRM_MEMCPY(&(p_reconfig_geran_params->irat_eutran_to_geran_carriers[reconfig_index]),
               &(p_cell_ctx_params->irat_eutran_to_geran_carriers[cell_ctx_index]),
                sizeof(irat_eutran_geran_carriers_t));

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Copied Geran arfcn = %d in reconfig struct", p_cell_ctx_params->
                irat_eutran_to_geran_carriers[cell_ctx_index].geran_car_freqs.starting_arfcn);

            reconfig_index++;
            p_reconfig_geran_params->num_irat_eutran_to_geran_carriers = reconfig_index;
        }
    }
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_geran_ncl
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  U16 *p_geran_remove_list: List of GERAN ARFCNs to be deleted
 *                  U8   geran_remove_list_size :No. of GERAN ARFCNs to be deleted
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE 
 * Description    : Fill the freq nbr list info in the reconfig structure 
 *                  by not including the nbrs of requested frequencies to be deleted
 ****************************************************************************/
rrm_return_et
rrmcm_construct_reconfig_struct_for_geran_ncl
(
    rrm_cell_context_t              *p_cell_ctx,
    rrm_son_geran_carrier_freqs_t   *p_geran_remove_list,
    U8                              geran_remove_list_size
)
{
    rrm_bool_et                     remove_nbr         = RRM_FALSE;
    U8                              ncl_index      = RRM_ZERO;
    U8                              del_list_index      = RRM_ZERO;
    U8                              reconfig_index      = RRM_ZERO;
    ncl_params_t                    *p_cell_ctx_ncl_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctx_ncl_params = &(p_cell_ctx->ran_info.ncl_params);

    /* For each Inter-freq nbr stored in the cell context, check presence of its freq in the
        remove list of the frequencies in the Req */
    for(ncl_index = RRM_ZERO; ncl_index < p_cell_ctx_ncl_params->inter_rat_ncl.num_valid_geran_cell;
            ncl_index++)
    {
        remove_nbr = RRM_FALSE;

        for(del_list_index = RRM_ZERO;
                (del_list_index < geran_remove_list_size) && (del_list_index < MAX_SON_MEAS_CONFIG_OBJECT);
                del_list_index++)
        {
            /* If freq of the nbr is present in the any of the remove list of Req(FDD/TDD) do not copy it */
            if((del_list_index < geran_remove_list_size) &&
                (p_cell_ctx_ncl_params->inter_rat_ncl.geran_freq_cells[ncl_index].bcch_arfcn ==
                    p_geran_remove_list[del_list_index].starting_arfcn)) 
            {
                remove_nbr = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Removing Nbr: Geran arfcn = %d, PCI = %d Blacklist Status = %d",
                        p_cell_ctx_ncl_params->inter_rat_ncl.geran_freq_cells[ncl_index].bcch_arfcn,
                        p_cell_ctx_ncl_params->inter_rat_ncl.geran_freq_cells[ncl_index].pci,
                        p_cell_ctx_ncl_params->inter_rat_ncl.geran_freq_cells[ncl_index].blacklisted);

                /* If first GERAN nbr is detected to be removed */
                if(!(RRM_GERAN_NBRS_UPDATED & p_cell_ctx->updated_nrt_bitmask))
                {
                    if(!(p_cell_ctx->p_ncl_built_from_updated_nrt_info))
                    {
                        p_cell_ctx->p_ncl_built_from_updated_nrt_info = rrm_mem_get(sizeof(ncl_params_t));
                        if (p_cell_ctx->p_ncl_built_from_updated_nrt_info == RRM_FAILURE)
                        {
                             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                       "Memory allocation to p_cell_ctx->p_ncl_built_from_updated_nrt_info failed" );
                             RRM_UT_TRACE_EXIT();
                             return RRM_FAILURE;
                        }

                        RRM_MEMSET(p_cell_ctx->p_ncl_built_from_updated_nrt_info, RRM_ZERO, sizeof(ncl_params_t));
                    }

                    p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_geran_cell
                        = ncl_index;

                    /* If this nbr is not at the first index in the nbr list */
                    if(RRM_ZERO < ncl_index)
                    {
                        /* Copy the already scanned nbrs at once */
                        RRM_MEMCPY(p_cell_ctx->p_ncl_built_from_updated_nrt_info->
                                inter_rat_ncl.geran_freq_cells,
                                p_cell_ctx_ncl_params->inter_rat_ncl.geran_freq_cells,
                                ncl_index * sizeof(geran_freq_ncl_t));
                    }

                    reconfig_index = ncl_index;
                    p_cell_ctx->updated_nrt_bitmask |= RRM_GERAN_NBRS_UPDATED;
                }
                break;
            }
        }
        /* If the nbr is detected NOT to be removed but some prev nbr was removed,
            Copy the nbr in reconfig struct */
        if((remove_nbr == RRM_FALSE) && (RRM_GERAN_NBRS_UPDATED & p_cell_ctx->updated_nrt_bitmask))
        {
            RRM_MEMCPY(&(p_cell_ctx->p_ncl_built_from_updated_nrt_info->
                inter_rat_ncl.geran_freq_cells[reconfig_index]),
               &(p_cell_ctx_ncl_params->inter_rat_ncl.geran_freq_cells[ncl_index]),
                sizeof(inter_freq_cells_t));

            reconfig_index++;
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->
            inter_rat_ncl.num_valid_geran_cell = reconfig_index;
        }
    }

    if((p_cell_ctx->p_ncl_built_from_updated_nrt_info) && 
        (RRM_ZERO < p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_geran_cell))
    {
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->bitmask |=
            RRMCM_RMIF_INTER_RAT_NCL_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_geran
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  rrm_son_meas_config_obj_remove_req_t
 *                      *p_meas_config_obj_remove_req : Pointer to the req rcvd
 *                      from MIF
 * Outputs        : None
 * Returns        : None
 * Description    : Call the handlers to construct the reconfig structure
 *                  for GERAN by deleting the requested frequencies
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_geran
(
    rrm_cell_context_t                         *p_cell_ctx,
    rrm_son_meas_config_obj_remove_req_t       *p_meas_config_obj_remove_req
)
{
    RRM_UT_TRACE_ENTER();

    if(RRM_ZERO < p_meas_config_obj_remove_req->geran_remove_list_size)
    {
        /* Prepare the frequency list with requested nbrs removed */
        rrmcm_construct_reconfig_struct_for_geran_freq(p_cell_ctx,
                p_meas_config_obj_remove_req->geran_remove_list,
                p_meas_config_obj_remove_req->geran_remove_list_size);
    }

    /* If any GERAN freq is removed, copy reselection params from Cell ctxt for SIB broadcast */
    if(p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask &
        RRMCM_GERAN_FREQ_PARAMS_PRESENT)
    {
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->
            geran_params.idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.t_reselection_geran =
            p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params.
            irat_eutra_to_geran_reselection_params.t_reselection_geran;

        if(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_geran_params.irat_eutra_to_geran_reselection_params.bitmask &
                RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT)
        {
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                geran_params.idle_mode_mobility_irat_geran_params.
                irat_eutra_to_geran_reselection_params.speed_state_scale_factor =
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_geran_params.
                irat_eutra_to_geran_reselection_params.speed_state_scale_factor ;

            p_cell_ctx->p_meas_config_sib_info_for_reconfig->
                geran_params.idle_mode_mobility_irat_geran_params.
                irat_eutra_to_geran_reselection_params.bitmask |=
                RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT;
        }

        /* If any GERAN freq is removed, find and remove the nbrs of that freq from NCL */
        if((p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
            && (p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_geran_cell))
        {
            rrmcm_construct_reconfig_struct_for_geran_ncl(p_cell_ctx,
                    p_meas_config_obj_remove_req->geran_remove_list,
                    p_meas_config_obj_remove_req->geran_remove_list_size);
        }
    }

    RRM_UT_TRACE_EXIT();
}


/* End: Enh 317 */

/****************************************************************************
 * Function Name  : rrmcm_construct_reconfig_struct_for_freq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 *                  rrm_son_meas_config_obj_remove_req_t
 *                      *p_meas_config_obj_remove_req : Pointer to the req rcvd
 *                      from MIF
 * Outputs        : None
 * Returns        : None
 * Description    : Call the handlers to construct the reconfig structure
 *                  by deleting the requested frequencies
 ****************************************************************************/
rrm_void_t
rrmcm_construct_reconfig_struct_for_freq
(
    rrm_cell_context_t                         *p_cell_ctx,
    rrm_son_meas_config_obj_remove_req_t       *p_meas_config_obj_remove_req
)
{
    RRM_UT_TRACE_ENTER();

    p_cell_ctx->updated_nrt_bitmask = RRM_ZERO;

    if(RRM_ZERO < p_meas_config_obj_remove_req->earfcn_remove_list_size)
    {
        rrmcm_construct_reconfig_struct_for_eutran_freq(p_cell_ctx,
                p_meas_config_obj_remove_req->earfcn_remove_list,
                p_meas_config_obj_remove_req->earfcn_remove_list_size);

        /* Start: Enh 317 */
        if((p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & 
             RRMCM_INTER_FREQ_PARAMS_PRESENT) &&
        /* End: Enh 317 */     
            (p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT))
        {
            rrmcm_construct_reconfig_struct_for_eutran_ncl(p_cell_ctx,
                    p_meas_config_obj_remove_req->earfcn_remove_list,
                    p_meas_config_obj_remove_req->earfcn_remove_list_size);
        }
    }

    /* Start: Enh 317 */
    rrmcm_construct_reconfig_struct_for_utran_freq(p_cell_ctx,
        p_meas_config_obj_remove_req);

    rrmcm_construct_reconfig_struct_for_geran(p_cell_ctx,
        p_meas_config_obj_remove_req);
    /* End: Enh 317 */

    RRM_UT_TRACE_EXIT();
}

/* UE MEAS CHANGES : ENDS */
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrmcm_print_nbr_list_for_lte_ncl
 * Inputs         : ncl_params_t     *p_ncl_params
 * Outputs        : None
 * Returns        : None
 * Description    : Prints the nbr list from cell context
 ****************************************************************************/
static rrm_void_t
rrmcm_print_nbr_list_for_lte_ncl(ncl_params_t     *p_ncl_params)
{
    U8                  index = RRM_NULL;

    RRM_UT_TRACE_ENTER(); 
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "LTE Intra-freq Nbr List[%d]:", p_ncl_params->lte_ncl.num_valid_intra_freq_cell);
    for(index = RRM_NULL; index < p_ncl_params->lte_ncl.num_valid_intra_freq_cell;
            index++)
    {

        if (RRM_THREE == p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.num_mnc_digit)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "\nIntra-freq Neighbour : %d mcc[%d%d%d] mnc[%d%d%d] Cell Identity[0x%x%x%x%x] PCI[%d]"
                    " broadcast_status[%d] Blacklist[%d] X2 status[%d] HO status[%d] PCI Conflict[%d]", index + RRM_1,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ZERO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ONE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_TWO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ZERO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ONE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_TWO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_ZERO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_ONE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_TWO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_THREE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].phy_cell_id,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].broadcast_status,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].blacklisted,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].x2_status,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].ho_status,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].is_pci_conflict);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "\nIntra-freq Neighbour : %d mcc[%d%d%d] mnc[%d%d] Cell Identity[0x%x%x%x%x] PCI[%d]"
                    " broadcast_status[%d] Blacklist[%d] X2 status[%d] HO status[%d] PCI Conflict[%d]", index + RRM_1,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ZERO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ONE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_TWO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ZERO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ONE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_ZERO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_ONE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_TWO],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].cell_id.cell_identity[RRM_THREE],
                    p_ncl_params->lte_ncl.intra_freq_cells[index].phy_cell_id,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].broadcast_status,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].blacklisted,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].x2_status,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].ho_status,
                    p_ncl_params->lte_ncl.intra_freq_cells[index].is_pci_conflict);
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "LTE Inter-freq Nbr List[%d]:", p_ncl_params->lte_ncl.num_valid_inter_freq_cell);
    for(index = RRM_NULL; index < p_ncl_params->lte_ncl.num_valid_inter_freq_cell;
            index++)
    {
        if (RRM_THREE == p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.num_mnc_digit)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "\nInter-freq Neighbour [%d]:mcc[%d%d%d] mnc[%d%d%d]"
                    " Cell Identity[0x%x%x%x%x] Earfcn[%d] PCI[%d] broadcast_status[%d] Blacklist[%d]"
                    " X2 status[%d] HO status[%d] q_offset[%d] cio[%d], tac[0x%x%x] r_stx_power[%d]",
                    index + RRM_1,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_TWO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_TWO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_TWO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_THREE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].eutra_carrier_arfcn,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].phy_cell_id,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].broadcast_status,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].blacklisted,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].x2_status,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].ho_status,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].q_offset,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cio,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].tac[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].tac[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].r_stx_power);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "\nInter-freq Neighbour [%d]:mcc[%d%d] mnc[%d%d%d]"
                    " Cell Identity[0x%x%x%x%x] Earfcn[%d] PCI[%d] broadcast_status[%d] Blacklist[%d]"
                    " X2 status[%d] HO status[%d] q_offset[%d] cio[%d], tac[0x%x%x] r_stx_power[%d]",
                    index + RRM_1,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mcc[RRM_TWO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.primary_plmn_id.mnc[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_TWO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cell_id.cell_identity[RRM_THREE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].eutra_carrier_arfcn,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].phy_cell_id,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].broadcast_status,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].blacklisted,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].x2_status,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].ho_status,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].q_offset,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].cio,
                    p_ncl_params->lte_ncl.inter_freq_cells[index].tac[RRM_ZERO],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].tac[RRM_ONE],
                    p_ncl_params->lte_ncl.inter_freq_cells[index].r_stx_power);
        }

    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrmcm_print_nbr_list_for_inter_rat_utran_ncl
 * Inputs         : ncl_params_t     *p_ncl_params
 * Outputs        : None
 * Returns        : None
 * Description    : Prints the nbr list from cell context
 ****************************************************************************/
static rrm_void_t
rrmcm_print_nbr_list_for_inter_rat_utran_ncl(ncl_params_t     *p_ncl_params)
{
    U8                  index = RRM_NULL;
    RRM_UT_TRACE_ENTER();
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
        "UTRAN Nbr List:[%d]", p_ncl_params->inter_rat_ncl.num_valid_utran_freq_cell);
        for(index = RRM_NULL; index < p_ncl_params->inter_rat_ncl.num_valid_utran_freq_cell;
            index++)
        {

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "\nUTRAN Neighbour[%d]:UTRAN Cell ID = %d %d RNC ID[%d] PCI[%d] URA[%d] LAC[%d %d] RAC[%d]"
                    " Blacklist[%d] HO status[%d] UARFCN UL[%d]/DL[%d] PSHO %s, VoIP %s",
                    index + RRM_1,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].uc_id.cell_id[RRM_ONE],
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].uc_id.cell_id[RRM_ZERO],
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].uc_id.rnc_id,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].pcpich_scrambling_code,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].ura,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].rai.lai.lac[RRM_ZERO],
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].rai.lai.lac[RRM_ONE],
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].rai.rac,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].blacklisted,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].ho_status,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].uarfcnul,
                    p_ncl_params->inter_rat_ncl.utran_freq_cells[index].uarfcndl,
                    (RRM_ZERO == p_ncl_params->inter_rat_ncl.utran_freq_cells[index].ps_ho_supported) ? "not supported" : "supported",
                    (RRM_ZERO == p_ncl_params->inter_rat_ncl.utran_freq_cells[index].voip_capable) ? "not supported" : "supported");

            if(p_ncl_params->inter_rat_ncl.utran_freq_cells[index].uc_id.bitmask &
                    RRM_UTRAN_EXTN_RNC_ID_PRESENT)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                        "Extended RNC ID = %d", p_ncl_params->inter_rat_ncl.utran_freq_cells[index].
                        uc_id.extended_rnc_id);
            }
        }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rrmcm_print_nbr_list_for_nrt
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : Prints the nbr list from cell context
 ****************************************************************************/
static rrm_void_t
rrmcm_print_nbr_list_for_nrt
(
 rrm_cell_context_t *p_cell_ctx
 )
{
    U8                  index = RRM_NULL;
    ncl_params_t        *p_ncl_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_ncl_params = &(p_cell_ctx->ran_info.ncl_params);

    if(p_ncl_params->bitmask & RRMCM_RMIF_LTE_NCL_PRESENT)
    {
        /*Klockwork_fix_start*/
        rrmcm_print_nbr_list_for_lte_ncl(p_ncl_params);
        /*Klockwork_fix_end*/
    }
    if(p_ncl_params->bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
    {
    /* SPR-9815-fix start */
        /*Klockwork_fix_start*/
        rrmcm_print_nbr_list_for_inter_rat_utran_ncl(p_ncl_params);
        /*Klockwork_fix_end*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
        "GERAN Nbr List:[%d]", p_ncl_params->inter_rat_ncl.num_valid_geran_cell);
        
        for(index = RRM_NULL; index < p_ncl_params->inter_rat_ncl.num_valid_geran_cell;
            index++)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "\nGERAN Neighbour[%d]: Cell ID[%d] PCI[%d] RAC[%d] BandIndicator[%d] BCCH ARFCN[%d]"
            " Offset freq[%d] Blacklisted[%d] DTM %s, DTM HO %s,VoIP %s",index + RRM_1,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].cell_id,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].pci,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].rac,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].band_indicator,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].bcch_arfcn,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].offset_freq,
            p_ncl_params->inter_rat_ncl.geran_freq_cells[index].blacklisted,
            (RRM_ZERO == p_ncl_params->inter_rat_ncl.geran_freq_cells[index].dtm_supported) ? "not supported":"supported",
            (RRM_ZERO == p_ncl_params->inter_rat_ncl.geran_freq_cells[index].dtm_ho_supported) ? "not supported":"supported",
            (RRM_ZERO == p_ncl_params->inter_rat_ncl.geran_freq_cells[index].voip_capable) ? "not supported":"supported");
        }

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
        "CDMA Nbr List:[%d]", p_ncl_params->inter_rat_ncl.num_valid_cdma2000_freq_cells);
        for(index = RRM_NULL; index < p_ncl_params->inter_rat_ncl.num_valid_cdma2000_freq_cells;
            index++)
        {
            /* Start 7514 NRT Fix - SIB 8 */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "\nCDMA Neighbour [%d]: CDMA arfcn = %d, band_class = %d , pn_offset = %d & type = %d", 
            index + RRM_1,
            p_ncl_params->inter_rat_ncl.cdma2000_freq_cells[index].arfcn,
            p_ncl_params->inter_rat_ncl.cdma2000_freq_cells[index].band_class, 
            p_ncl_params->inter_rat_ncl.cdma2000_freq_cells[index].pn_offset,
            p_ncl_params->inter_rat_ncl.cdma2000_freq_cells[index].type);
            /* End 7514 NRT Fix - SIB 8 */
        }
    }
    RRM_UT_TRACE_EXIT();
}

/* RACH_OPTIMIZATION_CHANGES_START */
/****************************************************************************
 * Function Name  : rmcm_mif_rach_info_ind
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Processes the RACH info ind from MIF.
 ****************************************************************************/
rrm_return_et
rmcm_mif_rach_info_ind
(
 rrm_cell_context_t *p_cell_ctx /*cell context*/
 )
{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    rrm_mac_config_perf_stats_req_t     *p_out_config_perf_stats_req = RRM_PNULL;
    U32                                  cell_prefs_bitmap = 0x00;

    RRM_UT_TRACE_ENTER();
    p_out_config_perf_stats_req = rrm_mem_get
        (sizeof(rrm_mac_config_perf_stats_req_t));
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    if (RRM_PNULL == p_out_config_perf_stats_req)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Memory allocation failed for p_out_config_perf_stats_req");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_out_config_perf_stats_req, RRM_ZERO, sizeof(rrm_mac_config_perf_stats_req_t));

    p_out_config_perf_stats_req->duration = 
        p_cell_ctx->cell_rach_info.rach_l2_periodic_timer;

    if(RRM_ZERO == p_out_config_perf_stats_req->duration)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "RACH L2 reports need to be stopped from MAC");
        /*As duration value as ZERO is invalid at MAC interface, so setting duration as 1*/
        p_out_config_perf_stats_req->duration = RRM_ONE;
        /*As req from SON is to stop the reports so setting periodicReporting as APERIODIC
          that means no further reports are required from L2*/
        p_out_config_perf_stats_req->periodicReporting = RRM_ZERO;

        /** Dynamic UE Scheduling Start **/

        /* logic for enabling and disabling the bitmask :
           we have getter and setter function for getting and setting the bitmap 
           for cell and ue perfs, which we stoare in cell context for each cell.
           our problem was when sending l2_perfs req then api must take care of
           last bitmap configured at mac in curren request. if it is not taken 
           care then mac understand to disable the report dispachment corresponding
           to that bitmask only. so approach to include the last bitmap also in api
           req.

           Now how to use :
           setter function ask user to provide the resultant bitmap to save in cell
           context after full making correct bitmap.
       
           Bitmap : enable the bit : get the bitmap using getter function.use the byte
           pointer to access the specific byte, as below we have used. perform the OR
           operation of that bit that user want to enable. pass that value back to setter
           function of that bitmap.

           Bitmap :  disable the bit : do same as enable except performing OR operation 
           perform the AND operation.*/  



        /*set the ue prefs bitamp */
        rrm_set_ue_prefs_stats_bitmap( p_cell_ctx->cell_index ,RRM_ZERO );
 
        /*Bit mapping is according to mentioned in MAC API doc, kindly refer to it*/
        p_out_config_perf_stats_req->uePerfStatsToReportBitMap = 
                                     rrm_get_l2_ue_prefs_stats_bitmap( p_cell_ctx->cell_index );

        cell_prefs_bitmap = rrm_get_l2_cell_prefs_stats_bitmap( p_cell_ctx->cell_index );

        /* disabling the 2nd bit,thatswhy AND operation performed */
        cell_prefs_bitmap &= 0xFFFFFFFD; 
        rrm_set_cell_prefs_stats_bitmap( p_cell_ctx->cell_index ,cell_prefs_bitmap );

        /*Setting value for cell related stats as 2 as we require reports related to RACH only*/
        p_out_config_perf_stats_req->cellPerfStatsToReportBitMap = 
                                     rrm_get_l2_cell_prefs_stats_bitmap( p_cell_ctx->cell_index );

       /** Dynamic UE Scheduling End **/

    }
    else
    {    
        /*Reports are to requested periodically*/
        p_out_config_perf_stats_req->periodicReporting = RRM_ONE; 
        p_out_config_perf_stats_req->uePerfStatsToReportBitMap = 0x00;

        /** Dynamic UE Scheduling Start **/
        
        cell_prefs_bitmap = rrm_get_l2_cell_prefs_stats_bitmap( p_cell_ctx->cell_index );

        /* enabling the 2nd bit,thatswhy AND operation performed */
        cell_prefs_bitmap |= 0x02;

        /* set the cell perfs bitmap least 2nd bit to one */
        rrm_set_cell_prefs_stats_bitmap( p_cell_ctx->cell_index , cell_prefs_bitmap ); 
        /*Setting value for cell related stats as 2 as we require reports related to RACH only*/
        p_out_config_perf_stats_req->cellPerfStatsToReportBitMap = 
                                     rrm_get_l2_cell_prefs_stats_bitmap( p_cell_ctx->cell_index );
  
        /** Dynamic UE Scheduling End **/
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Sending l2_perf_stats_req to MAC");
    
    l2_perf_stats_req(p_out_config_perf_stats_req,
            RRM_MODULE_ID,
            RRM_ONE,
            p_cell_ctx->cell_index
            );
    /* COVERITY : RESOURCE LEAK : CID : 54325 fix start */
    if( RRM_NULL != p_out_config_perf_stats_req )
        RRM_MEM_FREE(p_out_config_perf_stats_req);
    /* COVERITY : RESOURCE LEAK : CID : 54325 fix end */
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/* RACH_OPTIMIZATION_CHANGES_END */
/****************************************************************************
 * Function Name  : rmcm_mif_meas_config_obj_remove_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Delete the requested frequencies to stop SON measurements
 *                  for those frequencies by cell reconfig.
 ****************************************************************************/
rrm_return_et
rmcm_mif_meas_config_obj_remove_req
(
    rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    U8                                     result              = RRM_SUCCESS;
    rrm_error_et                           error_code          = RRM_NO_ERROR; /* Coverity_ID : 16486 */
    rrm_return_et                          ret_val             = RRM_SUCCESS;
    U8                                     del_list_index      = RRM_ZERO;

    rrmcm_rmif_cell_son_meas_config_obj_remove_req_t  *p_meas_config_obj_remove_req = RRM_PNULL;

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    RRM_UT_TRACE_ENTER();

    p_meas_config_obj_remove_req = (rrmcm_rmif_cell_son_meas_config_obj_remove_req_t *)
        p_cell_ctx->p_incoming_api_info;

    /* Start: Enh 317 */    
    if ((!p_meas_config_obj_remove_req->meas_config_obj_remove_req.earfcn_remove_list_size) &&
        (!p_meas_config_obj_remove_req->meas_config_obj_remove_req.uarfcn_fdd_remove_list_size) &&
        (!p_meas_config_obj_remove_req->meas_config_obj_remove_req.uarfcn_tdd_remove_list_size) &&
        (!p_meas_config_obj_remove_req->meas_config_obj_remove_req.geran_remove_list_size) &&
        (!p_meas_config_obj_remove_req->meas_config_obj_remove_req.cdma_remove_list_size))
    /* End: Enh 317 */    
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "rmcm_mif_meas_config_obj_remove_req: Empty Meas Config Obj Remove Request "
                "received for cell index = %u",
                (U16)p_meas_config_obj_remove_req->cellindex);

        error_code = RRM_ERR_INVALID_PARAMS;
    }
    else
    {
        S8 band_class_index = BAND_NOT_CONFIGURED;

        for(del_list_index = RRM_ZERO; (del_list_index < p_meas_config_obj_remove_req->
                meas_config_obj_remove_req.earfcn_remove_list_size)
                /* Coverity 19oct Start : 54996 */
                && (del_list_index < MAX_SON_MEAS_CONFIG_OBJECT); del_list_index++)
                /* Coverity 19oct End : 54996 */
        {
            /* If the freq is found in the remove list do not copy it */
            if(FREQ_NOT_CONFIGURED == rrmcm_search_earfcn_in_cell_context(p_cell_ctx, 
                p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                earfcn_remove_list[del_list_index]))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "rmcm_mif_meas_config_obj_remove_req: Sending FAILURE to SON");
                error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;

                break;
            }
        }

        /* Start: Enh 317 */    
        for(del_list_index = RRM_ZERO; (del_list_index < p_meas_config_obj_remove_req->
                meas_config_obj_remove_req.uarfcn_fdd_remove_list_size)
                && (del_list_index < MAX_SON_MEAS_CONFIG_OBJECT); del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(FREQ_NOT_CONFIGURED == rrmcm_search_uarfcn_fdd_in_cell_context(p_cell_ctx, 
                p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                uarfcn_fdd_remove_list[del_list_index]))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "rmcm_mif_meas_config_obj_remove_req: Sending FAILURE to SON");
                error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;

                break;
            }
        }

        for(del_list_index = RRM_ZERO; (del_list_index < p_meas_config_obj_remove_req->
                meas_config_obj_remove_req.uarfcn_tdd_remove_list_size)
                && (del_list_index < MAX_SON_MEAS_CONFIG_OBJECT); del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(FREQ_NOT_CONFIGURED == rrmcm_search_uarfcn_tdd_in_cell_context(p_cell_ctx, 
                p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                uarfcn_tdd_remove_list[del_list_index]))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "rmcm_mif_meas_config_obj_remove_req: Sending FAILURE to SON");
                error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;

                break;
            }
        }

        for(del_list_index = RRM_ZERO; (del_list_index < p_meas_config_obj_remove_req->
                meas_config_obj_remove_req.geran_remove_list_size)
                && (del_list_index < MAX_SON_MEAS_CONFIG_OBJECT); del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(FREQ_NOT_CONFIGURED == rrmcm_search_geran_arfcn_in_cell_context(p_cell_ctx, 
                p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                geran_remove_list[del_list_index].starting_arfcn,
                p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                geran_remove_list[del_list_index].band_ind))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "rmcm_mif_meas_config_obj_remove_req: Sending FAILURE to SON");
                error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;

                break;
            }
        }

        for(del_list_index = RRM_ZERO; (del_list_index < p_meas_config_obj_remove_req->
                meas_config_obj_remove_req.cdma_remove_list_size)
                && (del_list_index < MAX_SON_MEAS_CONFIG_OBJECT); del_list_index++)
        {
            /* If the freq is found in the remove list do not copy it */
            if(FREQ_NOT_CONFIGURED == rrmcm_search_cdma_arfcn_in_cell_context(p_cell_ctx, 
                        p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                        cdma_remove_list[del_list_index].arfcn,
                        p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                        cdma_remove_list[del_list_index].band_class,
                        p_meas_config_obj_remove_req->meas_config_obj_remove_req.
                        cdma_remove_list[del_list_index].cdma_type, &band_class_index
                        ))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "rmcm_mif_meas_config_obj_remove_req: Sending FAILURE to SON");
                error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;

                break;
            }
        }

        /* End: Enh 317 */

        if(RRM_NO_ERROR == error_code)
        {
            /* Allocate memory for constructing Reconfig struct */
            rrmcm_allocate_mem_and_init_meas_reconfig_struct(p_cell_ctx);

            rrmcm_construct_reconfig_struct_for_freq(p_cell_ctx,
                    &(p_meas_config_obj_remove_req->meas_config_obj_remove_req));

            p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove = RRM_TRUE;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Triggering Cell Reconfig For MEAS OBJ REMOVAL purpose");

            if(RRM_FAILURE == build_send_rrc_reconfig_req_for_son(p_cell_ctx))
            {
                RRM_MEM_FREE(p_cell_ctx->p_meas_config_sib_info_for_reconfig);
                p_cell_ctx->p_meas_config_sib_info_for_reconfig = RRM_PNULL;

                if(p_cell_ctx->p_ncl_built_from_updated_nrt_info)
                {
                    RRM_MEM_FREE(p_cell_ctx->p_ncl_built_from_updated_nrt_info);
                    p_cell_ctx->p_ncl_built_from_updated_nrt_info = RRM_PNULL;
                }
                error_code = RRM_ERR_INTERNAL_FAILURE;
            }
        }
    }
    if(RRM_NO_ERROR != error_code)
    {
        ret_val = RRM_FAILURE;
        result = RRM_FAILURE;
        rmcm_mif_meas_config_resp(p_cell_ctx, result, error_code, RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_RESP);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/* SPS related changes start */
/****************************************************************************
 * Function Name  : rrm_reallocate_mem_n1_pucch_an_sps_status
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function reallocates memory to keep the status of n1_pucch_an for SPS 
 *                  in case of cell_reconfig
****************************************************************************/
rrm_return_et
rrm_reallocate_mem_n1_pucch_an_sps_status
(
    rrm_cell_context_t	*p_cell_ctx
)
{
    /* SPR 11003 Fix Start */
    U16                     n1_pucch_an_left_for_sps                 = RRM_ZERO;
    rrm_return_et           ret_val = RRM_SUCCESS;
    /* +- SPR 18268 */
    U16                      max_num_sps_ue = RRM_ZERO;
    U16                      max_ue_per_cell = RRM_ZERO;
    /* +- SPR 18268 */
    U16                     total_ues_configured_in_cell = RRM_ZERO;
    U16                     n1_pucch_an = RRM_ZERO;
    U16                     final_n1_calc = RRM_ZERO;
    U16                     total_count_of_n1_pucch_an = RRM_ZERO;
    U16                     temp_total_count_of_n1_pucch_an = RRM_ZERO;
    U16                     temp_total_ue_in_cell = RRM_ZERO;
    U8                      delta_pucch_shift = RRM_ZERO;
    U8                      n_cs_an = RRM_ZERO;
    U16                     sr_periodicity_in_ms = RRM_ZERO;
    /* SPR 12387 Fix Start */
    U8                      sr_periodicity = RRM_ZERO;
#ifdef TDD_MODE_FLAG
    U16                             ul_opportunity_cnt = RRM_ZERO;
    /* cov_66961_start */
	rrm_oam_sub_frame_asgmnt_et                      tdd_subfrm_config = RRM_OAM_SA0;
    /* cov_66961_end */
	U16                          transient_data_for_sr = RRM_ZERO;
#endif
	U16                         runtime_calculated = RRM_ZERO;
	U16                         cfg_configured = RRM_ZERO;
    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */
    /* SPR 12387 Fix End */


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    max_num_sps_ue = p_cell_ctx->operator_info.admission_control_info.max_sps_ues;
    max_ue_per_cell = p_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell;
    n1_pucch_an = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an;
    n_cs_an = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an;
    delta_pucch_shift = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift;

    /* n1_pucch_an is an index so adding 1 to get the total number of indexes */
    total_count_of_n1_pucch_an = n1_pucch_an + RRM_ONE
        +
        n_cs_an * (delta_pucch_shift + RRM_ONE);

    temp_total_count_of_n1_pucch_an = total_count_of_n1_pucch_an;
	/* SPR 12387 Fix Start */
         RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
          	   " OAM configured params:- n1_pucch_an(%d) , n_cs_an(%d) , delta_pucch_shift(%d) ",
                   n1_pucch_an,n_cs_an,(delta_pucch_shift + RRM_ONE));
	/* SPR 12387 Fix End */
    /* Below a rough estimation is done on the N1 resources by considering the fact that
     * for every UE a minimum 1 resource is required for SR and for SPS UE, additional 4 N1 resources are
     * required. Based on this input a rough estimation is done for SR Periodicity.
     */
    total_ues_configured_in_cell = max_ue_per_cell + (RRM_FOUR * max_num_sps_ue);

    (RRM_ZERO == (total_ues_configured_in_cell % total_count_of_n1_pucch_an))              ?
        (sr_periodicity_in_ms = total_ues_configured_in_cell / total_count_of_n1_pucch_an) :
        (sr_periodicity_in_ms = (total_ues_configured_in_cell / total_count_of_n1_pucch_an) + RRM_ONE);

    /* SPR 12387 Fix Start */
#ifdef TDD_MODE_FLAG
	tdd_subfrm_config = p_cell_ctx->ran_info.physical_layer_params.\
			    physical_layer_param_tdd_frame_structure.sub_frame_assignment;
    ul_opportunity_cnt = find_ul_opportunity_for_sr_periodicity_calc(tdd_subfrm_config);

	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
			" There are [%d] UL SF as per the [%d] TDD SF configuration"
            " so modulate the calculated SR periodicty of [%d ms]",
            ul_opportunity_cnt,
            p_cell_ctx->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure.sub_frame_assignment, sr_periodicity_in_ms);

    sr_periodicity_in_ms = sr_periodicity_in_ms * (SUBFRAMES_IN_ONE_FRAME/ul_opportunity_cnt);
#endif
    /* SPR 19221: CID 107989 Fix Start */
    /* SPR 18871 Fix Start */
    if (sr_periodicity_in_ms <= SR_PERIODICITY_1MS)
    {
	    sr_periodicity = SR_PERIODICITY_6;
	    runtime_calculated = SR_PERIODICITY_1MS;
    }
    else if (sr_periodicity_in_ms <= SR_PERIODICITY_2MS)
    {
	    sr_periodicity = SR_PERIODICITY_5;
	    runtime_calculated = SR_PERIODICITY_2MS;
    }
    /* SPR 18871 Fix End */
    else if (sr_periodicity_in_ms <= SR_PERIODICITY_5MS)
    /* SPR 19221: CID 107989 Fix End */
	{
		sr_periodicity = SR_PERIODICITY_0;
		runtime_calculated = SR_PERIODICITY_5MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_10MS)
	{
		sr_periodicity = SR_PERIODICITY_1;
		runtime_calculated = SR_PERIODICITY_10MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_20MS)
	{
		sr_periodicity = SR_PERIODICITY_2;
		runtime_calculated = SR_PERIODICITY_20MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_40MS)
	{
		sr_periodicity = SR_PERIODICITY_3;
		runtime_calculated = SR_PERIODICITY_40MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_80MS)
	{
		sr_periodicity = SR_PERIODICITY_4;
		runtime_calculated = SR_PERIODICITY_80MS;
	}
    /* SPR 19221: CID 107989 Fix Start */
    /* Code Deleted */
    /* SPR 19221: CID 107989 Fix End */
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
				"Default value chosen for SR Periodicity as value is wrong(%d) after calculation",
				sr_periodicity);
		sr_periodicity = SR_PERIODICITY_4;
		runtime_calculated = SR_PERIODICITY_80MS;
	}
	
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
			" As per available UL SF, New SR periodicity is [%d ms ]. "
                        "Now validate it for configured upper and lower bounds of SR periodicity",
			runtime_calculated);


    /* SPR 20653 Fix Start */
	switch(p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity)
        /* SPR 20653 Fix End */
	{
		case SR_PERIODICITY_0:
			cfg_configured = SR_PERIODICITY_5MS;
			break;

		case SR_PERIODICITY_1:
			cfg_configured = SR_PERIODICITY_10MS;
			break;

		case SR_PERIODICITY_2:
			cfg_configured = SR_PERIODICITY_20MS;
			break;

		case SR_PERIODICITY_3:
			cfg_configured = SR_PERIODICITY_40MS;
			break;

		case SR_PERIODICITY_4:
			cfg_configured = SR_PERIODICITY_80MS;
			break;
            /* SPR 18871 Fix Start */
		case SR_PERIODICITY_5:
			cfg_configured = SR_PERIODICITY_2MS;
			break;
		case SR_PERIODICITY_6:
			cfg_configured = SR_PERIODICITY_1MS;
			break;
            /* SPR 18871 Fix End */
		default :
            /* SPR 20653 Fix Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect Value(%d) configured from CFG, so picking up 10ms Periodicity",
                    p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity);
            /* SPR 20653 Fix End */
			cfg_configured = SR_PERIODICITY_10MS;
	}

    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
	/* SPR 7952_FIX_START */
#ifndef TDD_MODE_FLAG
    /* SPR 20653 Fix Start */
    /*spr_22345_changes_start*/
	if( runtime_calculated < cfg_configured )
    /*spr_22345_changes_end*/
	{
		sr_periodicity = p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity;
		sr_periodicity_in_ms = cfg_configured;
    /*spr_22345_changes_start*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"Due to the lower bound restriction:Value chosen for SR Periodicity is(%d)ms "
                "while RRM calculated SR periodicity was (%d)ms",
				cfg_configured, runtime_calculated);
    /*spr_22345_changes_end*/
	}
    /* Code removed */
    /* SPR 20653 Fix End */
	else
    {
		sr_periodicity_in_ms = runtime_calculated;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Pass both the upper/lower bounds: Value chosen for SR Periodicity is(%d)ms",
                runtime_calculated);
    }
	/* SPR 7957_FIX_END */
#else
    /* SPR 20653 Fix Start */
    /*spr_22345_changes_start*/
	if( runtime_calculated < cfg_configured )
        /*spr_22345_changes_end*/
	{
		sr_periodicity = p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity;
		sr_periodicity_in_ms = cfg_configured;
		transient_data_for_sr = cfg_configured;
    /*spr_22345_changes_start*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"Due to the lower bound restriction:Value chosen for SR Periodicity is(%d)ms "
                "while RRM calculated SR periodicity was (%d)ms",
				cfg_configured, runtime_calculated);
        /*spr_22345_changes_end*/
	}
    /* Code Removed */
    /* SPR 20653 Fix End */
	else
    {
        transient_data_for_sr = runtime_calculated;
        sr_periodicity_in_ms = runtime_calculated;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Pass both the upper/lower bounds: Value chosen for SR Periodicity is(%d)ms",
                runtime_calculated);
    }
	if(p_cell_ctx->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Validate SR periodicty (%d ms)against configured TDD SF config (%d)",
                transient_data_for_sr ,tdd_subfrm_config );
        if ((RRM_OAM_SA0 == tdd_subfrm_config) ||
                (RRM_OAM_SA1 == tdd_subfrm_config) ||
                (RRM_OAM_SA2 == tdd_subfrm_config) ||
                (RRM_OAM_SA6 == tdd_subfrm_config)
           )
        {
            sr_periodicity_in_ms = transient_data_for_sr;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "After TDD SF config validation: Value chosen for SR Periodicity is(%d)ms "
                    "in TDD UL/DL Config 0, 1, 2, 6",
                    transient_data_for_sr);
        }
        else if ((RRM_OAM_SA3 == tdd_subfrm_config) ||
                (RRM_OAM_SA4 == tdd_subfrm_config) ||
                (RRM_OAM_SA5 == tdd_subfrm_config)
                )
        {
            if (sr_periodicity < SR_PERIODICITY_1)
            {
                sr_periodicity = SR_PERIODICITY_1;
                sr_periodicity_in_ms = SR_PERIODICITY_10MS;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "As per TDD SF config validation:Value of SR in %dms can't be supported "
                        "in TDD UL/DL Config 3,4,5 so taking minimum of 10ms",
                        transient_data_for_sr);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Value chosen for SR Periodicity is 10 ms");
            }
            else
            {
                sr_periodicity_in_ms = transient_data_for_sr;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "After TDD SF config validation:Value chosen for SR Periodicity is(%d)ms",
                        transient_data_for_sr);
            } 
        }
    }

#endif    

     p_cell_ctx->sr_data.sr_periodicity = sr_periodicity;

    /* Now, based on this periodicity, RRM will check how many N1 resources are required to 
     * adjust "Maximum Number of UEs" configured from OAM. This logic shall decrement the 
     * total N1 Indexes and allocates them to free pool so that those indexes can be used for
     * SPS UEs.
     */
#ifdef TDD_MODE_FLAG
	temp_total_ue_in_cell = ul_opportunity_cnt * 
		( sr_periodicity_in_ms / SUBFRAMES_IN_ONE_FRAME ) * 
		total_count_of_n1_pucch_an;

#else
	temp_total_ue_in_cell = sr_periodicity_in_ms * total_count_of_n1_pucch_an;
#endif
    final_n1_calc = temp_total_count_of_n1_pucch_an;
    while (temp_total_ue_in_cell > max_ue_per_cell)
    {
        final_n1_calc = temp_total_count_of_n1_pucch_an;
        temp_total_count_of_n1_pucch_an--;
#ifdef TDD_MODE_FLAG
       temp_total_ue_in_cell = ul_opportunity_cnt * 
                                ( sr_periodicity_in_ms / SUBFRAMES_IN_ONE_FRAME ) * 
                                 temp_total_count_of_n1_pucch_an;
                                      
#else
       temp_total_ue_in_cell = sr_periodicity_in_ms * temp_total_count_of_n1_pucch_an;
#endif
    /* SPR 12387 Fix End */
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Total of [%d]UEs will use [%d]N1 Idx For SR with Estimated Periodicity[%d / %d ms]",
            max_ue_per_cell, final_n1_calc, sr_periodicity, sr_periodicity_in_ms);
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Out of Total N1 Idx from OAM[%d], [%d] are allocated for SPS",
            total_count_of_n1_pucch_an, (total_count_of_n1_pucch_an - final_n1_calc));

    if(final_n1_calc == total_count_of_n1_pucch_an)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Less n1_pucch_an configured[%d] for SPS and SR  for Cell_indx :%d",
                n1_pucch_an,
                p_cell_ctx->cell_index);

	/* SPR 8053 Fix start */
	/* SPR_8597_FIX_START*/
	p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx = 
		total_count_of_n1_pucch_an - RRM_ONE;
	/* SPR_8597_FIX_END*/
	/* coverity fix 76800 start */
	//p_cell_ctx->sps_n1_pucch_an_start_indx = RRM_ZERO;
	//n1_pucch_an_left_for_sps = RRM_ZERO;
	/* coverity fix 76800 end */
	/* SPR 8053 Fix end */
    }
   else
   {
    /* SPR_8597_FIX_START*/
        p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx = 
            final_n1_calc - RRM_ONE;
        /* SPR_8597_FIX_END*/
        p_cell_ctx->sps_n1_pucch_an_start_indx = final_n1_calc;
        /* SPR_8597_FIX_START*/
        n1_pucch_an_left_for_sps =
            (n1_pucch_an + RRM_ONE) +  (n_cs_an * (delta_pucch_shift + RRM_ONE))
            -
		    (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx);
    /* SPR_8597_FIX_END*/
	    if (RRM_PNULL != p_cell_ctx->sps_n1_pucch_an_marked_st)
    	{
		RRM_MEM_FREE(p_cell_ctx->sps_n1_pucch_an_marked_st);
	        p_cell_ctx->sps_n1_pucch_an_marked_st = RRM_PNULL;
    	}
	    /*  allocate the memory to store the status of n1_pucch_an resource for SPS */
    	p_cell_ctx->sps_n1_pucch_an_marked_st = (U8 *) rrm_mem_get(sizeof(U8)*n1_pucch_an_left_for_sps);
    	if ( RRM_PNULL == p_cell_ctx->sps_n1_pucch_an_marked_st )
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "sps_n1_pucch_an_marked_st is NULL for Cell_indx :%d",
                  p_cell_ctx->cell_index);
          RRM_UT_TRACE_EXIT();
          ret_val = RRM_FAILURE;
      }
    	else
      {
          RRM_MEMSET(p_cell_ctx->sps_n1_pucch_an_marked_st, RRM_ZERO, sizeof(U8)* n1_pucch_an_left_for_sps);
      }
   }

    /* SPR 11003 Fix End */
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_allocate_mem_n1_pucch_an_sps_status
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function allocates memory to keep the status of n1_pucch_an for SPS 
****************************************************************************/
rrm_return_et
rrm_allocate_mem_n1_pucch_an_sps_status
(
    rrm_cell_context_t	*p_cell_ctx
)
{
    U16             n1_pucch_an_left_for_sps                 = RRM_ZERO;

    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    /* SPR 11003 Fix Start */
    /* SPR_8597_FIX_START */
    n1_pucch_an_left_for_sps =
        (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an + RRM_ONE) +
        (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an * 
         p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift)
        -
        (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx);
    /* SPR_8597_FIX_END */    
    /* SPR 11003 Fix End */
    /*  allocate the memory to store the status of n1_pucch_an resource for SPS */
    p_cell_ctx->sps_n1_pucch_an_marked_st = (U8 *) rrm_mem_get(sizeof(U8)*n1_pucch_an_left_for_sps);
    if ( RRM_PNULL == p_cell_ctx->sps_n1_pucch_an_marked_st )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                " sps_n1_pucch_an_marked_st is NULL for Cell_indx :%d",
                p_cell_ctx->cell_index);
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_MEMSET(p_cell_ctx->sps_n1_pucch_an_marked_st, RRM_ZERO, sizeof(U8)* n1_pucch_an_left_for_sps);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_allocate_n1_pucch_an_res_for_sps
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function allocates the starting n1_pucch_an resource index for SPS 
****************************************************************************/
rrm_return_et
rrm_set_n1_pucch_an_res_for_sps
(
    rrm_cell_context_t	*p_cell_ctx
)
{
    /* SPR 11003 Fix Start */
    rrm_return_et           ret_val = RRM_SUCCESS;
    /* +- SPR 18268 */
    U16                      max_num_sps_ue = RRM_ZERO;
    U16                      max_ue_per_cell = RRM_ZERO;
    /* +- SPR 18268 */
    U16                     total_ues_configured_in_cell = RRM_ZERO;
    U16                     n1_pucch_an = RRM_ZERO;
    U16                     final_n1_calc = RRM_ZERO;
    U16                     total_count_of_n1_pucch_an = RRM_ZERO;
    U16                     temp_total_ue_in_cell = RRM_ZERO;
    U16                     temp_total_count_of_n1_pucch_an = RRM_ZERO;
    U8	                    delta_pucch_shift = RRM_ZERO;
    U8                      n_cs_an = RRM_ZERO;
    U16                     sr_periodicity_in_ms = RRM_ZERO;
	/* SPR 12387 Fix Start */
    U8                      sr_periodicity = RRM_ZERO;
#ifdef TDD_MODE_FLAG
	U16                         ul_opportunity_cnt = RRM_ZERO;
    /* cov_66962_start */
	rrm_oam_sub_frame_asgmnt_et                      tdd_subfrm_config = RRM_OAM_SA0;
    /* cov_66962_end */
	U16                          transient_data_for_sr = RRM_ZERO;
#endif
	U16                         runtime_calculated = RRM_ZERO;
	U16                         cfg_configured = RRM_ZERO;
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
	/* SPR 12387 Fix End */


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    max_num_sps_ue = p_cell_ctx->operator_info.admission_control_info.max_sps_ues;
    max_ue_per_cell = p_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell;
    n1_pucch_an = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an;
    n_cs_an = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an;
    delta_pucch_shift = p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift;

    /* n1_pucch_an is an index so adding 1 to get the total number of indexes */
    total_count_of_n1_pucch_an = n1_pucch_an + RRM_ONE
        +
        n_cs_an * (delta_pucch_shift + RRM_ONE);
    temp_total_count_of_n1_pucch_an = total_count_of_n1_pucch_an;
	/* SPR 12387 Fix Start */
         RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
          	   " OAM configured params:- n1_pucch_an(%d) , n_cs_an(%d) , delta_pucch_shift(%d) ",
                   n1_pucch_an,n_cs_an,(delta_pucch_shift + RRM_ONE));
	/* SPR 12387 Fix End */
    /* Below a rough estimation is done on the N1 resources by considering the fact that
     * for every UE a minimum 1 resource is required for SR and for SPS UE, additional 4 N1 resources are
     * required. Based on this input a rough estimation is done for SR Periodicity.
     */
    total_ues_configured_in_cell = max_ue_per_cell + (RRM_FOUR * max_num_sps_ue);

    (RRM_ZERO == (total_ues_configured_in_cell % total_count_of_n1_pucch_an))              ?
        (sr_periodicity_in_ms = total_ues_configured_in_cell / total_count_of_n1_pucch_an) :
        (sr_periodicity_in_ms = (total_ues_configured_in_cell / total_count_of_n1_pucch_an) + RRM_ONE);

	/* SPR 12387 Fix Start */
#ifdef TDD_MODE_FLAG
	tdd_subfrm_config = p_cell_ctx->ran_info.physical_layer_params.\
			    physical_layer_param_tdd_frame_structure.sub_frame_assignment;
	ul_opportunity_cnt = find_ul_opportunity_for_sr_periodicity_calc(tdd_subfrm_config);

	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
			" There are [%d] UL SF as per the [%d] TDD SF configuration"
			" so modulate the calculated SR periodicty of [%d ms]",
			ul_opportunity_cnt,
			p_cell_ctx->ran_info.physical_layer_params.
			physical_layer_param_tdd_frame_structure.sub_frame_assignment, sr_periodicity_in_ms);

	sr_periodicity_in_ms = sr_periodicity_in_ms * (SUBFRAMES_IN_ONE_FRAME/ul_opportunity_cnt);
#endif
	/* SPR 19221: CID 107990 Fix Start */
	/* SPR 18871 Fix Start */
	if (sr_periodicity_in_ms <= SR_PERIODICITY_1MS)
	{
		sr_periodicity = SR_PERIODICITY_6;
		runtime_calculated = SR_PERIODICITY_1MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_2MS)
	{
		sr_periodicity = SR_PERIODICITY_5;
		runtime_calculated = SR_PERIODICITY_2MS;
	}
	/* SPR 18871 Fix End */
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_5MS)
	/* SPR 19221: CID 107990 Fix End */
	{
		sr_periodicity = SR_PERIODICITY_0;
		runtime_calculated = SR_PERIODICITY_5MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_10MS)
	{
		sr_periodicity = SR_PERIODICITY_1;
		runtime_calculated = SR_PERIODICITY_10MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_20MS)
	{
		sr_periodicity = SR_PERIODICITY_2;
		runtime_calculated = SR_PERIODICITY_20MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_40MS)
	{
		sr_periodicity = SR_PERIODICITY_3;
		runtime_calculated = SR_PERIODICITY_40MS;
	}
	else if (sr_periodicity_in_ms <= SR_PERIODICITY_80MS)
	{
		sr_periodicity = SR_PERIODICITY_4;
		runtime_calculated = SR_PERIODICITY_80MS;
	}
    /* SPR 19221: CID 107990 Fix Start */
    /* Code Deleted */
    /* SPR 19221: CID 107990 Fix End */
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
				"Default value chosen for SR Periodicity as value is wrong(%d) after calculation",
				sr_periodicity);
		sr_periodicity = SR_PERIODICITY_4;
		runtime_calculated = SR_PERIODICITY_80MS;
	}

	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
			" As per available UL SF, New SR periodicity is [%d ms ]. "
                        "Now validate it for configured upper and lower bounds of SR periodicity",
			runtime_calculated);

    /* SPR 20653 Fix Start */
	switch(p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity)
        /* SPR 20653 Fix End */
	{
		case SR_PERIODICITY_0:
			cfg_configured = SR_PERIODICITY_5MS;
			break;

		case SR_PERIODICITY_1:
			cfg_configured = SR_PERIODICITY_10MS;
			break;

		case SR_PERIODICITY_2:
			cfg_configured = SR_PERIODICITY_20MS;
			break;

		case SR_PERIODICITY_3:
			cfg_configured = SR_PERIODICITY_40MS;
			break;

		case SR_PERIODICITY_4:
			cfg_configured = SR_PERIODICITY_80MS;
			break;
            /* SPR 18871 Fix Start */
		case SR_PERIODICITY_5:
			cfg_configured = SR_PERIODICITY_2MS;
			break;
		case SR_PERIODICITY_6:
			cfg_configured = SR_PERIODICITY_1MS;
			break;
            /* SPR 18871 Fix End */
		default :
            /* SPR 20653 Fix Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect Value(%d) configured from CFG, so picking up 10ms Periodicity",
                    p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity);
            /* SPR 20653 Fix End */
			cfg_configured = SR_PERIODICITY_10MS;
	}

    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
	/* SPR 7952_FIX_START */
#ifndef TDD_MODE_FLAG
    /* SPR 20653 Fix Start */
    /*spr_22345_changes_start*/
	if( runtime_calculated < cfg_configured )
    /*spr_22345_changes_end*/
	{
		sr_periodicity = p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity;
		sr_periodicity_in_ms = cfg_configured;
    /*spr_22345_changes_start*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"Due to the lower bound restriction:Value chosen for SR Periodicity is(%d)ms "
                "while RRM calculated SR periodicity was (%d)ms",
				cfg_configured, runtime_calculated);
    /*spr_22345_changes_end*/
	}
    /* Code removed */
    /* SPR 20653 Fix End */
	else
	{
		sr_periodicity_in_ms = runtime_calculated;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"Pass both the upper/lower bounds: Value chosen for SR Periodicity is(%d)ms",
				runtime_calculated);
	}
	/* SPR 7957_FIX_END */
#else
    /* SPR 20653 Fix Start */
    /*spr_22345_changes_start*/
	if( runtime_calculated < cfg_configured )
        /*spr_22345_changes_end*/
	{
		sr_periodicity = p_cell_ctx->operator_info.admission_control_info.min_sr_periodicity;
		sr_periodicity_in_ms = cfg_configured;
		transient_data_for_sr = cfg_configured;
    /*spr_22345_changes_start*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"Due to the lower bound restriction:Value chosen for SR Periodicity is(%d)ms "
                "while RRM calculated SR periodicity was (%d)ms",
				cfg_configured, runtime_calculated);
    /*spr_22345_changes_end*/
	}
    /* Code Removed */
    /* SPR 20653 Fix End */
	else
    {
        transient_data_for_sr = runtime_calculated;
        sr_periodicity_in_ms = runtime_calculated;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Pass both the upper/lower bounds: Value chosen for SR Periodicity is(%d)ms",
                runtime_calculated);
    }
	if(p_cell_ctx->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Validate SR periodicty (%d ms)against configured TDD SF config (%d)",
                transient_data_for_sr ,tdd_subfrm_config );
        if ((RRM_OAM_SA0 == tdd_subfrm_config) ||
                (RRM_OAM_SA1 == tdd_subfrm_config) ||
                (RRM_OAM_SA2 == tdd_subfrm_config) ||
                (RRM_OAM_SA6 == tdd_subfrm_config)
           )
        {
            sr_periodicity_in_ms = transient_data_for_sr;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "After TDD SF config validation: Value chosen for SR Periodicity is(%d)ms "
                    "in TDD UL/DL Config 0, 1, 2, 6",
                    transient_data_for_sr);
        }
        else if ((RRM_OAM_SA3 == tdd_subfrm_config) ||
                (RRM_OAM_SA4 == tdd_subfrm_config) ||
                (RRM_OAM_SA5 == tdd_subfrm_config)
                )
        {
            if (sr_periodicity < SR_PERIODICITY_1)
            {
                sr_periodicity = SR_PERIODICITY_1;
                sr_periodicity_in_ms = SR_PERIODICITY_10MS;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "As per TDD SF config validation:Value of SR in %dms can't be supported "
                        "in TDD UL/DL Config 3,4,5 so taking minimum of 10ms",
                        transient_data_for_sr);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Value chosen for SR Periodicity is 10 ms");
            }
            else
            {
                sr_periodicity_in_ms = transient_data_for_sr;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "After TDD SF config validation:Value chosen for SR Periodicity is(%d)ms",
                        transient_data_for_sr);
            } 
        }
    }

#endif    

    p_cell_ctx->sr_data.sr_periodicity = sr_periodicity;
    /* Now, based on this periodicity, RRM will check how many N1 resources are required to 
     * adjust "Maximum Number of UEs" configured from OAM. This logic shall decrement the 
     * total N1 Indexes and allocates them to free pool so that those indexes can be used for
     * SPS UEs.
     */
#ifdef TDD_MODE_FLAG
	temp_total_ue_in_cell = ul_opportunity_cnt * 
		( sr_periodicity_in_ms / SUBFRAMES_IN_ONE_FRAME ) * 
		total_count_of_n1_pucch_an;

#else
	temp_total_ue_in_cell = sr_periodicity_in_ms * total_count_of_n1_pucch_an;
#endif
    final_n1_calc = temp_total_count_of_n1_pucch_an;
    while (temp_total_ue_in_cell > max_ue_per_cell)
    {
        final_n1_calc = temp_total_count_of_n1_pucch_an;
        temp_total_count_of_n1_pucch_an--;
#ifdef TDD_MODE_FLAG
		temp_total_ue_in_cell = ul_opportunity_cnt * 
			( sr_periodicity_in_ms / SUBFRAMES_IN_ONE_FRAME ) * 
			temp_total_count_of_n1_pucch_an;

#else
		temp_total_ue_in_cell = sr_periodicity_in_ms * temp_total_count_of_n1_pucch_an;
#endif
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Total of [%d]UEs will use [%d]N1 Idx For SR with Estimated Periodicity[%d / %dms]",
            max_ue_per_cell, final_n1_calc, sr_periodicity,sr_periodicity_in_ms);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Out of Total N1 Idx from OAM[%d], [%d] are allocated for SPS",
            total_count_of_n1_pucch_an, (total_count_of_n1_pucch_an - final_n1_calc));
    /*
    ** fill the starting index of  n1_pucch_an Persistent List starting for SPS
    */
    if(final_n1_calc == total_count_of_n1_pucch_an)
        {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                           " Less n1_pucch_an configured[%d] for SPS and SR  for Cell_indx :%d",
                n1_pucch_an,
                                           p_cell_ctx->cell_index);
            
            /* SPR 8053 Fix start */
        /* SPR_8597_FIX_START */
        p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx = 
            total_count_of_n1_pucch_an - RRM_ONE;
            /*SPR_8597_FIX_END*/
            p_cell_ctx->sps_n1_pucch_an_start_indx = RRM_ZERO;
            /* SPR 8053 Fix end */
        }
        else
        {
            /* SPR_8597_FIX_START */
        p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx = 
            final_n1_calc - RRM_ONE;
        /*SPR_8597_FIX_END*/
        p_cell_ctx->sps_n1_pucch_an_start_indx = final_n1_calc;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /* SPR 11003 Fix End */
}
/* SPS related changes end */

/*Klockworik_fix_start*/
/****************************************************************************
 * Function Name  : rrm_look_into_cbsr_for_finding_4xn_support
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : mxn_support
 * Description    : This function look into cbsr for finding the 4xn support
 ****************************************************************************/
rrm_antenna_mxn_et
rrm_look_into_cbsr_for_finding_4xn_support_cbsr(const rrm_cell_context_t  *p_cell_ctxt,
                                                U8                        index)
{
    rrm_antenna_mxn_et mxn_support; 
            if( RRM_ZERO != ( 0xC0 & (p_cell_ctxt->ran_info.antenna_info.cbsr[index].
                             value[RRM_ZERO])))
            {
        mxn_support = Anetnna_4x4;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "CBSR value for TM-3 governs Antenna 4x4, by doing AND operation with"
                "0xC0 on first byte of cbsr is non zero.");
            }
            else 
            {
        mxn_support = Anetnna_4x2;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "CBSR value for TM-3 governs Antenna 4x2,As by doing AND operation with"
                "0xC0 on first byte of cbsr in zero");
            }

 return mxn_support;
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrm_look_into_cbsr_for_finding_4xn_support
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
                  : rrm_antenna_mxn_et *p_mxn_support
 * Outputs        : None
 * Returns        : rrm_void_t
 * Description    : This function look into cbsr for finding the 4xn support
****************************************************************************/
rrm_void_t
rrm_look_into_cbsr_for_finding_4xn_support( const rrm_cell_context_t *p_cell_ctxt,
                                            rrm_antenna_mxn_et       *p_mxn_support  )
{

    U8                num_of_cbsr = p_cell_ctxt->ran_info.antenna_info.num_cbsr;
    U8                index = RRM_ZERO;
    rrm_bool_et       type_found = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

/* This part of code written to select the MxN antenna type for 
   Four Antenna port count .  here we expects to get correct 
   CBSR info OAM. then we match the cbsr type which is common for
   4x2 and 4x4 . so the only way to distinguish between them is
   CBSR value. 
   Here we look for the type which comes first and look the CBSR
   and exit from loop. 
   TM-3 has different type and TM-4 has different. if either of this
   type met first then we look its cbsr value for being candidate of
   Antenna 4x4. if this info does not specify the Anetnna 4x4 then 
   RRM will consider it 4x2.
   
*/

    for(index = RRM_ZERO; index < num_of_cbsr ; index++ )
    {
        if( RRM_ONE == p_cell_ctxt->ran_info.antenna_info.cbsr[index].type )
        {
            /*Klockwork_fix_start*/
            *p_mxn_support = rrm_look_into_cbsr_for_finding_4xn_support_cbsr(p_cell_ctxt ,index);
            /*Klockwork_fix_end*/
            type_found = RRM_TRUE;
            break;
        }
        else if( RRM_THREE == p_cell_ctxt->ran_info.antenna_info.cbsr[index].type )
        {
            if( p_cell_ctxt->ran_info.antenna_info.cbsr[index].value[RRM_ZERO] ||
                p_cell_ctxt->ran_info.antenna_info.cbsr[index].value[RRM_ONE ] ||
                p_cell_ctxt->ran_info.antenna_info.cbsr[index].value[RRM_TWO ] ||
                p_cell_ctxt->ran_info.antenna_info.cbsr[index].value[RRM_THREE] ) 
            {
                *p_mxn_support = Anetnna_4x4;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "CBSR value for TM-4 governs Antenna 4x4,As first FOUR byte of cbsr contanis"
                "non zero info" );
            }
            else
            {
                *p_mxn_support = Anetnna_4x2;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "CBSR value for TM-4 governs Antenna 4x2,As first Four byte are zero");
            }

            type_found = RRM_TRUE;
            break;
        }
    }
  
/* if type is not found then here we select the least 4xn configuration which is 
   Anetnna 4x2 .
*/
    if( RRM_FALSE == type_found )
    {
        *p_mxn_support = Anetnna_4x2;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
        "CBSR type for TM-3 and TM-4 is not found.So Antenna 4x2 is configuring");
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_get_mxn_antenna_type_support_on_cbsr_and_port
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
                  : rrm_antenna_mxn_et *p_mxn_support
 * Outputs        : None
 * Returns        : rrm_void_t
 * Description    : This function look into cbsr for finding the 4xn support
****************************************************************************/
rrm_void_t
rrm_get_mxn_antenna_type_support_on_cbsr_and_port_count( rrm_cell_context_t *p_cell_context )
{

    RRM_UT_TRACE_ENTER();

    switch( p_cell_context->ran_info.antenna_info.antenna_ports_count_number )
    {
		/*Coverity_fix_start_62531 */
        case ANTENNA_PORTS_COUNT_AN1:
		/*Coverity_fix_end_62531 */
        {
            p_cell_context->mxn_antenna_support = Anetnna_1x1; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Antenna mxn 1x1 feature is setting,as number of port at cell is ONE ");
            break;
        }
		/*Coverity_fix_start_62532 */
        case ANTENNA_PORTS_COUNT_AN2:
		/*Coverity_fix_end_62532 */
        {
            p_cell_context->mxn_antenna_support = Anetnna_2x2;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Antenna mxn 2x2 feature is setting,as number of port at cell is TWO ");
            break;
        }
		/*Coverity_fix_start_62533 */
        case ANTENNA_PORTS_COUNT_AN4:
		/*Coverity_fix_end_62533 */
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Antenna mxn 4xn feature is going to determine,as number of antenna port is FOUR");
            rrm_look_into_cbsr_for_finding_4xn_support( p_cell_context,
                                                     &( p_cell_context->mxn_antenna_support) ); 
            break;
        }
            /* CID:62533 Fix End */
        default:
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Wrong Antenna port count is received,so mxn 1x1 is setting");
        }
    }

    RRM_UT_TRACE_EXIT();

}

/* Carrier_Aggregation_Start */
/*Klockwork_fix_2431*/
/****************************************************************************
 * Function Name  :rrm_check_is_load_calculation_window_size_same
 * Inputs         : operator_info_t operator_info
 *                : rrm_ca_mac_scheduler_params_t
 *                : reconfig_ca_mac_scheduler_params
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function is used to check whether mac_scheduler param
 *                : value recieve in cell reconfig req is same to already
 *                : stored value in cell context or not.
 ****************************************************************************/
rrm_bool_et
rrm_check_is_load_calculation_window_size_same(rrm_ca_mac_scheduler_params_t *p_reconfig_ca_mac_scheduler_params,
                                               rrm_ca_mac_scheduler_params_t ca_mac_scheduler_params)
{

    rrm_bool_et ret_val = RRM_TRUE;
    if (RRM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->load_calcualtion_window_size != 
                    ca_mac_scheduler_params.load_calcualtion_window_size)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param load_calcualtion_window_size is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param load_calcualtion_window_size is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    return ret_val;
}
/****************************************************************************
 * Function Name  :rrm_check_is_threshold_same
 * Inputs         : operator_info_t operator_info
 *                : rrm_ca_mac_scheduler_params_t
 *                : reconfig_ca_mac_scheduler_params
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function is used to check whether mac_scheduler param
 *                : value recieve in cell reconfig req is same to already
 *                : stored value in cell context or not.
 ****************************************************************************/
rrm_bool_et
rrm_check_is_threshold_same(rrm_ca_mac_scheduler_params_t *p_reconfig_ca_mac_scheduler_params,
                            rrm_ca_mac_scheduler_params_t ca_mac_scheduler_params)
{
    rrm_bool_et ret_val = RRM_TRUE;    
    if (RRM_LOAD_DISPARITY_THRESHOLD_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_LOAD_DISPARITY_THRESHOLD_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->load_disparity_threshold != 
                    ca_mac_scheduler_params.load_disparity_threshold)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param load_disparity_threshold is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param load_disparity_threshold is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    if (RRM_MCS_DIFF_THRESHOLD_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_MCS_DIFF_THRESHOLD_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->mcs_diff_threshold != 
                    ca_mac_scheduler_params.mcs_diff_threshold)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param mcs_diff_threshold is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param mcs_diff_threshold is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  :rrm_check_is_prb_usage_same
 * Inputs         : operator_info_t operator_info
 *                : rrm_ca_mac_scheduler_params_t
 *                : reconfig_ca_mac_scheduler_params
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function is used to check whether mac_scheduler param
 *                : value recieve in cell reconfig req is same to already
 *                : stored value in cell context or not.
 ****************************************************************************/
rrm_bool_et rrm_check_is_prb_usage_same(rrm_ca_mac_scheduler_params_t *p_reconfig_ca_mac_scheduler_params,
                                        rrm_ca_mac_scheduler_params_t ca_mac_scheduler_params)
{
    rrm_bool_et ret_val = RRM_TRUE;    
    if (RRM_PRB_USAGE_WATER_MARK_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_PRB_USAGE_WATER_MARK_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->prb_usage_water_mark != 
                    ca_mac_scheduler_params.prb_usage_water_mark)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param prb_usage_water_mark is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param prb_usage_water_mark is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    if (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->dl_deact_command_thresh != 
                    ca_mac_scheduler_params.dl_deact_command_thresh)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param  dl_deact_command_thresh is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param dl_deact_command_thresh is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    if (RRM_DL_DEACT_MCS_LOW_THRESH_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_DL_DEACT_MCS_LOW_THRESH_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->dl_deact_mcs_low_thresh != 
                    ca_mac_scheduler_params.dl_deact_mcs_low_thresh)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param dl_deact_mcs_low_thresh is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param dl_deact_mcs_low_thresh is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  :rrm_check_is_q_load_up_same
 * Inputs         : operator_info_t operator_info
 *                : rrm_ca_mac_scheduler_params_t
 *                : reconfig_ca_mac_scheduler_params
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function is used to check whether mac_scheduler param
 *                : value recieve in cell reconfig req is same to already
 *                : stored value in cell context or not.
 ****************************************************************************/
rrm_bool_et rrm_check_is_q_load_up_same(rrm_ca_mac_scheduler_params_t *p_reconfig_ca_mac_scheduler_params,
                                        rrm_ca_mac_scheduler_params_t ca_mac_scheduler_params)
{
    rrm_bool_et ret_val = RRM_TRUE;

    if (RRM_DL_Q_LOAD_UP_THRESH_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_DL_Q_LOAD_UP_THRESH_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->dl_qload_up_threshold != 
                    ca_mac_scheduler_params.dl_qload_up_threshold)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param dl_qload_up_threshold is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param dl_qload_up_threshold is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    if (RRM_DL_Q_LOAD_LOW_THRESH_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_DL_Q_LOAD_LOW_THRESH_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->dl_qload_low_threshold != 
                    ca_mac_scheduler_params.dl_qload_low_threshold)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param dl_qload_low_threshold is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param dl_qload_low_threshold is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    if (RRM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->act_deact_trigger_count_threshold != 
                    ca_mac_scheduler_params.act_deact_trigger_count_threshold)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param act_deact_trigger_count_threshold is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param act_deact_trigger_count_threshold is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    /* SPR 16422 START */
    if (RRM_CQI_VALIDITY_TIMER_PRESENT & p_reconfig_ca_mac_scheduler_params->bitmask)
    {
        if (RRM_CQI_VALIDITY_TIMER_PRESENT & ca_mac_scheduler_params.bitmask)
        {
            if (p_reconfig_ca_mac_scheduler_params->cqi_validity_timer != 
                    ca_mac_scheduler_params.cqi_validity_timer)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CA MAC scheduler param cqi_validity_timer is not equal");
                RRM_UT_TRACE_EXIT();
                return RRM_FALSE;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "CA MAC scheduler param act_deact_trigger_count_threshold is not present in cell context");
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
    }
    /* SPR 16422 START */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*Klockwork_fix_2431_end*/
/****************************************************************************
 * Function Name  : rrm_check_is_ca_mac_sch_param_value_same
 * Inputs         : operator_info_t operator_info 
 *                : rrm_ca_mac_scheduler_params_t 
 *                : reconfig_ca_mac_scheduler_params
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function is used to check whether mac_scheduler param
 *                : value recieve in cell reconfig req is same to already 
 *                : stored value in cell context or not. 
 ****************************************************************************/
rrm_bool_et
rrm_check_is_ca_mac_sch_param_value_same
(
    operator_info_t *p_operator_info,
    rrm_ca_mac_scheduler_params_t *p_reconfig_ca_mac_scheduler_params
)
{
    rrm_bool_et ret_val = RRM_TRUE;
    rrm_ca_mac_scheduler_params_t ca_mac_scheduler_params = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();
    if ((RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask) &&
            (RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & 
             p_operator_info->ca_config.bitmask))
    {
        ca_mac_scheduler_params = p_operator_info->ca_config.ca_mac_scheduler_params;
        /*Klockwork_fix_2431*/
        ret_val = rrm_check_is_load_calculation_window_size_same(p_reconfig_ca_mac_scheduler_params ,ca_mac_scheduler_params); 
        if (ret_val == RRM_FALSE)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }
        ret_val = rrm_check_is_threshold_same(p_reconfig_ca_mac_scheduler_params ,ca_mac_scheduler_params);
        if (ret_val == RRM_FALSE)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }

        ret_val = rrm_check_is_prb_usage_same(p_reconfig_ca_mac_scheduler_params ,ca_mac_scheduler_params);
        if (ret_val == RRM_FALSE)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }

        ret_val = rrm_check_is_q_load_up_same(p_reconfig_ca_mac_scheduler_params ,ca_mac_scheduler_params);
        if (ret_val == RRM_FALSE)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_FALSE;
        }

    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "CA MAC scheduler params are not present in cell context");
        RRM_UT_TRACE_EXIT();
        return RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_TRUE;
}
/****************************************************************************
 * Function Name  : rrm_map_scell_deactivation_timer
 * Inputs         : rrm_scell_deactivation_timer_et scell_deactivation_timer 
 * Outputs        : None
 * Returns        : U8
 * Description    : This function is used to map scell deactivation timer 
 ****************************************************************************/
/*SPR 19705+*/
U16
rrm_map_scell_deactivation_timer (
            rrm_scell_deactivation_timer_et scell_deactivation_timer)
{

    U16 rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF32_M_SEC; /* Default value : RRM_SCELL_RF32 */
    RRM_UT_TRACE_ENTER();
    switch (scell_deactivation_timer)
    {
        case RRM_SCELL_RF2:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF2_M_SEC;
            break;
        case RRM_SCELL_RF4:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF4_M_SEC;
            break;
        case RRM_SCELL_RF8:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF8_M_SEC;
            break;
        case RRM_SCELL_RF16:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF16_M_SEC;
            break;
        case RRM_SCELL_RF32:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF32_M_SEC;
            break;
        case RRM_SCELL_RF64:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF64_M_SEC;
            break;
        case RRM_SCELL_RF128:
            rrm_scell_deactivation_timer = RRM_SCELL_DEACT_TIMER_RF128_M_SEC;
            break;
        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                 "Invalid scell deactivation timer[%d] in cell config req"
                 "By default assigning RRM_SCELL_DEACT_TIMER_RF32", scell_deactivation_timer);
    }
    RRM_UT_TRACE_EXIT();
    return rrm_scell_deactivation_timer;
}
/*SPR 19705 -*/
/****************************************************************************
 * Function Name  : rrm_update_ca_mac_scheduler_params
 * Inputs         : *p_ca_mac_scheduler_reconfig 
 * Outputs        : *p_rrm_ca_mac_scheduler_params
 * Returns        : Void
 * Description    : This function is used to update ca mac scheduler 
 *                  params in cell context 
 ****************************************************************************/
rrm_void_t
rrm_update_ca_mac_scheduler_params
(   
    rrm_ca_mac_scheduler_params_t *p_rrm_ca_mac_scheduler_params, 
    rrm_ca_mac_scheduler_params_t *p_ca_mac_scheduler_reconfig
)
{

    RRM_UT_TRACE_ENTER();
    if (RRM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->load_calcualtion_window_size =
            p_ca_mac_scheduler_reconfig->load_calcualtion_window_size;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT;
    }
    if (RRM_LOAD_DISPARITY_THRESHOLD_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->load_disparity_threshold =
            p_ca_mac_scheduler_reconfig->load_disparity_threshold;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_LOAD_DISPARITY_THRESHOLD_PRESENT;
    }
    if (RRM_MCS_DIFF_THRESHOLD_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->mcs_diff_threshold =
            p_ca_mac_scheduler_reconfig->mcs_diff_threshold;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_MCS_DIFF_THRESHOLD_PRESENT;
    }
    if (RRM_PRB_USAGE_WATER_MARK_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->prb_usage_water_mark =
            p_ca_mac_scheduler_reconfig->prb_usage_water_mark;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_PRB_USAGE_WATER_MARK_PRESENT;
    }
    if (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->dl_deact_command_thresh =
            p_ca_mac_scheduler_reconfig->dl_deact_command_thresh;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_DL_DEACT_COMMAND_THRESH_PRESENT;
    }
    if (RRM_DL_DEACT_MCS_LOW_THRESH_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->dl_deact_mcs_low_thresh =
            p_ca_mac_scheduler_reconfig->dl_deact_mcs_low_thresh;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_DL_DEACT_MCS_LOW_THRESH_PRESENT;
    }
    if (RRM_DL_Q_LOAD_UP_THRESH_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->dl_qload_up_threshold =
            p_ca_mac_scheduler_reconfig->dl_qload_up_threshold;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_DL_Q_LOAD_UP_THRESH_PRESENT;
    }
    if (RRM_DL_Q_LOAD_LOW_THRESH_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->dl_qload_low_threshold =
            p_ca_mac_scheduler_reconfig->dl_qload_low_threshold;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_DL_Q_LOAD_LOW_THRESH_PRESENT;
    }
    if (RRM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->act_deact_trigger_count_threshold =
            p_ca_mac_scheduler_reconfig->act_deact_trigger_count_threshold;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT;
    }
    /* SPR 16422 START */
    if (RRM_CQI_VALIDITY_TIMER_PRESENT & p_ca_mac_scheduler_reconfig->bitmask)
    {
        p_rrm_ca_mac_scheduler_params->cqi_validity_timer =
            p_ca_mac_scheduler_reconfig->cqi_validity_timer;
        p_rrm_ca_mac_scheduler_params->bitmask |= RRM_CQI_VALIDITY_TIMER_PRESENT;
    } 
    /* SPR 16422 END */
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_validate_ca_reconfig_params
 * Inputs         : *p_ca_reconfig 
 * Outputs        : *p_rrm_ca_config
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function is used to update ca params in cell context 
 ****************************************************************************/
rrm_return_et
rrm_validate_ca_reconfig_params 
(
    operator_info_t *p_operator_info,
    rrm_ca_config_t *p_ca_reconfig,
    rrm_cell_index_t cell_index
)
{
    rrm_return_et       ret_val                     = RRM_SUCCESS;
    rrm_bool_et         rrm_scell_deact_timer_check = RRM_FALSE;
    /*SPR 19705 +*/
    U16                  rrm_scell_deact_timer       = RRM_ZERO;
    /*SPR 19705-+*/
    rrm_ca_config_t     *p_rrm_ca_config            = RRM_PNULL;


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_operator_info);
    if (RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask)
    {
        p_rrm_ca_config = &p_operator_info->ca_config;
    }

    if ((RRM_SCELL_DEACTIVATION_TIMER_PRESENT & p_ca_reconfig->bitmask) &&
            (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & p_ca_reconfig->ca_mac_scheduler_params.bitmask))
    {
        /* If scell_deactivation_timer value is infinity then no need to validate 
           with dl_deact_command_thresh */
        if (RRM_SCELL_RFINFINITY != p_ca_reconfig->scell_deactivation_timer)
        {
            rrm_scell_deact_timer = rrm_map_scell_deactivation_timer (
                    p_ca_reconfig->scell_deactivation_timer);
            if (rrm_scell_deact_timer < 
                        p_ca_reconfig->ca_mac_scheduler_params.dl_deact_command_thresh)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "dl_deact_command_thresh = %d is greater than scell_deactivation_timer = %d"
                        "in cell reconfiguration",
                        p_ca_reconfig->ca_mac_scheduler_params.dl_deact_command_thresh,
                        p_ca_reconfig->scell_deactivation_timer);
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
        }
        rrm_scell_deact_timer_check = RRM_TRUE;
    }
    /* Checking whether CA params are already present in cell context or not */ 
    if (RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask)
    {
        /* If dl_deact_command_thresh is not present in cell reconfig request then validate 
            scell_deactivation_timer with already stored dl_deact_command_thresh in cell context */
        if ((rrm_scell_deact_timer_check != RRM_TRUE) &&
                (RRM_SCELL_DEACTIVATION_TIMER_PRESENT & p_ca_reconfig->bitmask) &&
                (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & 
                 p_rrm_ca_config->ca_mac_scheduler_params.bitmask))
        {
            /* If scell_deactivation_timer value is infinity then no need to validate 
               with dl_deact_command_thresh */
            if (RRM_SCELL_RFINFINITY != p_ca_reconfig->scell_deactivation_timer)
            {
                rrm_scell_deact_timer = rrm_map_scell_deactivation_timer (
                        p_ca_reconfig->scell_deactivation_timer);
                if (rrm_scell_deact_timer < 
                        p_rrm_ca_config->ca_mac_scheduler_params.dl_deact_command_thresh)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "dl_deact_command_thresh = %d in cell context is greater than"
                            "scell_deactivation_timer = %d in cell reconfiguration",
                            p_rrm_ca_config->ca_mac_scheduler_params.dl_deact_command_thresh,
                            p_ca_reconfig->scell_deactivation_timer);
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                else
                {
                    rrm_scell_deact_timer_check = RRM_TRUE;
                }
            }
        }
        /* If scell_deactivation_timer is not present in cell reconfig request then validate 
            dl_deact_command_thresh with already stored scell_deactivation_timer in cell context */
        if ((rrm_scell_deact_timer_check != RRM_TRUE) &&
                (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & 
                 p_ca_reconfig->ca_mac_scheduler_params.bitmask) &&
                (RRM_SCELL_DEACTIVATION_TIMER_PRESENT & 
                 p_rrm_ca_config->bitmask))
        {
            /* If scell_deactivation_timer value is infinity then no need to validate 
               with dl_deact_command_thresh */
            if (RRM_SCELL_RFINFINITY != p_rrm_ca_config->scell_deactivation_timer)
            {
                rrm_scell_deact_timer = rrm_map_scell_deactivation_timer (
                        p_rrm_ca_config->scell_deactivation_timer);
                if (rrm_scell_deact_timer < 
                        p_ca_reconfig->ca_mac_scheduler_params.dl_deact_command_thresh)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "dl_deact_command_thresh = %d in cell reconfig is greater than"
                            "scell_deactivation_timer = %d in cell context",
                            p_ca_reconfig->ca_mac_scheduler_params.dl_deact_command_thresh,
                            p_rrm_ca_config->scell_deactivation_timer);
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
            }
        }
    }
    if (RRM_IS_CA_ELIGIBLE_INFO_PRESENT & p_ca_reconfig->bitmask)
    {
        /* Checking whether cell becomes CA to non CA, if yes then update 
           cell change object in global context to notify other cells on same enb */ 
    /*spr_12440_fix_start */
    if (RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask)
        {
            if ((RRM_TRUE == p_rrm_ca_config->is_ca_eligible) 
                    && (RRM_FALSE== p_ca_reconfig->is_ca_eligible))
            {
                rrm_update_cell_change_object (cell_index, RRM_CA_CELL_CA_TO_NON_CA);
            }
        }
    /*spr_12440_fix_end */
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_commit_ca_reconfig_mac_sch_info
 * Inputs         : *p_ca_reconfig 
 * Outputs        : *p_rrm_ca_config
 * Returns        : VOID
 * Description    : This function is used to update ca reconfig mac
 *                : scheduler params in cell context 
 ****************************************************************************/
rrm_void_t
rrm_commit_ca_reconfig_mac_sch_info 
(
    operator_info_t *p_operator_info,
    rrm_ca_config_t *p_ca_reconfig
)
{
    rrm_ca_config_t     *p_rrm_ca_config            = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_operator_info);
    p_rrm_ca_config = &p_operator_info->ca_config;
    if (RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & p_ca_reconfig->bitmask)
    {
        rrm_update_ca_mac_scheduler_params (&p_rrm_ca_config->ca_mac_scheduler_params, 
                &p_ca_reconfig->ca_mac_scheduler_params);
        p_rrm_ca_config->bitmask |= RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}
/** eICIC_PHASE_1_2_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_commit_eicic_provision_reconfig_info
 * Inputs         : *p_eicic_reconfig 
 * Outputs        : *p_rrm_eicic_config
 * Returns        : VOID
 * Description    : This function is used to update eicic provision reconfig 
 *                : params in cell context 
 ****************************************************************************/
rrm_void_t
rrm_commit_eicic_provision_reconfig_info 
(
    rrm_cell_context_t   *p_cell_ctx,
    rrm_eicic_info_t     *p_eicic_reconfig
)
{
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();
/*EICIC_TDD_CHANGES_START*/
    if((p_cell_ctx->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)&& 
          (p_cell_ctx->ran_info.physical_layer_params.bitmask  & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT))
    {    
         abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
    }
    else
    {
        abs_size = RRM_MAX_PATTERN_BYTE;
    }    
/*EICIC_TDD_CHANGES_END*/

    if (p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT)
    {
        p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type = p_eicic_reconfig->eicic_provisioned_type;
        /*SPR 14131 start*/
        if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
        {    
          rrm_send_enable_disable_ind_to_son(p_cell_ctx);
        }
        /*SPR 14131 end*/
    }
    if (p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_REQUIRED_PER_RECONFIG_TO_MAC_PRESENT)
    {
        p_cell_ctx->operator_info.eicic_info.eicic_timer_info.mac_eicic_meas_report_periodicity = p_eicic_reconfig->eicic_timer_info.
                                                                                                              mac_eicic_meas_report_periodicity;
        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.eicic_timer_info.bitmask |= RRMCM_RMIF_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT;
    } 
    if (p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT)
    {
        RRM_MEMSET(p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied,RRM_ZERO,RRM_MAX_PATTERN_BYTE);       
       rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                  p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                  p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied);
    }
    if (p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT)
    {
        RRM_MEMSET(p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied,RRM_ZERO,RRM_MAX_PATTERN_BYTE);       
       rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                  p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                  p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied);

    }
    /**13956_fix_start*/
    if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT)
    {
        RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);       
        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT;
       rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                  p_eicic_reconfig->abs_info.abs_pattern.victim_abs_pattern,
                  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern);
    }
    if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_ABS_RECONFIG_LOW_LOAD_ABS_PRESENT)
    {
        RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);       
        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT;
       rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                  p_eicic_reconfig->abs_info.abs_pattern.low_load_abs_pattern,
                  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern);
    }
    /*eicic_subset_pattern_fix_start*/
    if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT)
    {
        RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,RRM_ZERO,RRM_MAX_PATTERN_BYTE);       
        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT;
       rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                  p_eicic_reconfig->abs_info.abs_pattern.victim_meas_subset,
                  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset);
    }    
   /**13956_fix_end*/
   RRM_UT_TRACE_EXIT();
}
/** eICIC_PHASE_1_2_CHANGES_END */
/****************************************************************************
 * Function Name  : rrm_commit_ca_reconfig_info
 * Inputs         : *p_ca_reconfig 
 * Outputs        : *p_rrm_ca_config
 * Returns        : VOID
 * Description    : This function is used to update ca reconfig 
 *                : params in cell context 
 ****************************************************************************/
rrm_void_t
rrm_commit_ca_reconfig_info 
(
    operator_info_t *p_operator_info,
    rrm_ca_config_t *p_ca_reconfig
)
{
    rrm_ca_config_t     *p_rrm_ca_config            = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_operator_info);
    p_rrm_ca_config = &p_operator_info->ca_config;

    if (RRM_IS_CA_ELIGIBLE_INFO_PRESENT & p_ca_reconfig->bitmask)
    {
        p_rrm_ca_config->is_ca_eligible = p_ca_reconfig->is_ca_eligible;
    }
    else if (!(RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Assigning default value because CA param is_ca_eligible is not present"
            "in cell context as well as cell reconfig req"); 
        p_rrm_ca_config->is_ca_eligible = RRM_IS_CA_ELIGIBLE_DEFAULT_VALUE;
        p_rrm_ca_config->bitmask |= RRM_IS_CA_ELIGIBLE_INFO_PRESENT;
    }
    if (RRM_NUM_OF_REPORT_PRESENT & p_ca_reconfig->bitmask)
    {
        p_rrm_ca_config->num_of_report = p_ca_reconfig->num_of_report;
    }
    else if (!(RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Assigning default value because CA param num_of_report is not present"
            "in cell context as well as cell reconfig req"); 
        p_rrm_ca_config->num_of_report = RRM_NUM_OF_REPORT_DEFAULT_VALUE;
        p_rrm_ca_config->bitmask |= RRM_NUM_OF_REPORT_PRESENT;
    }
    if (RRM_CA_APPLICABLE_BITRATE_DL_PRESENT & p_ca_reconfig->bitmask)
    {
        p_rrm_ca_config->ca_applicable_bitrate_dl = p_ca_reconfig->ca_applicable_bitrate_dl;
    }
    else if (!(RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Assigning default value because CA param ca_applicable_bitrate_dl is not present"
            "in cell context as well as cell reconfig req"); 
        p_rrm_ca_config->ca_applicable_bitrate_dl = RRM_CA_APPL_BITRATE_UL_DL_DEFAULT_VALUE;
        p_rrm_ca_config->bitmask |= RRM_CA_APPLICABLE_BITRATE_DL_PRESENT;
    }
    if (RRM_IS_MASA_INFO_PRESENT & p_ca_reconfig->bitmask)
    {
        p_rrm_ca_config->is_masa = p_ca_reconfig->is_masa;
    }
    else if (!(RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Assigning default value because CA param is_masa is not present"
            "in cell context as well as cell reconfig req"); 
        p_rrm_ca_config->is_masa = p_ca_reconfig->is_masa;
        p_rrm_ca_config->bitmask |= RRM_IS_MASA_DEFAULT_VALUE;
    }
    if (RRM_SCELL_DEACTIVATION_TIMER_PRESENT & p_ca_reconfig->bitmask)
    {
        p_rrm_ca_config->scell_deactivation_timer = p_ca_reconfig->scell_deactivation_timer;
    }
    else if (!(RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_operator_info->bitmask))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "Assigning default value because CA param scell_deactivation_timer is not present"
                "in cell context as well as cell reconfig req"); 
        /* Coverity_ID_Fix : 60870 */
        p_rrm_ca_config->scell_deactivation_timer = RRM_SCELL_RF32;
        p_rrm_ca_config->bitmask |= RRM_SCELL_DEACTIVATION_TIMER_PRESENT;
    }
    /* Here calling function to update MAC scheduler params in cell context */
    if (RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & p_ca_reconfig->bitmask)
    {
        rrm_commit_ca_reconfig_mac_sch_info (p_operator_info, p_ca_reconfig);
        p_rrm_ca_config->bitmask |= RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}
/* Carrier_Aggregation_End */

/*klock_works_changes_start*/
/* Bug_12689_fix: Start */
/****************************************************************************
 * Function Name  : rrm_check_if_pci_conflict_intra_ncl_present 
 * Inputs         : *p_cell_ctx
 * Outputs        : 
 * Returns        : VOID
 * Description    : This function checks if any cell has conflicting PCI with  
 *                : Serving cell them mark that cell as conflicting.
 ****************************************************************************/
rrm_void_t
rrm_check_if_pci_conflict_intra_ncl_present
(
 rrm_cell_context_t *p_cell_ctx
 )
{
    U8                  intra_freq_count = RRM_ZERO;
    ncl_params_t        *p_ncl_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_ncl_params = &(p_cell_ctx->ran_info.ncl_params);

    for(intra_freq_count = RRM_ZERO;
            intra_freq_count < p_ncl_params->lte_ncl.num_valid_intra_freq_cell;
            intra_freq_count++)
    {
        if(p_ncl_params->lte_ncl.intra_freq_cells[intra_freq_count].phy_cell_id ==
                p_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id)
        {
            p_ncl_params->lte_ncl.intra_freq_cells[intra_freq_count].is_pci_conflict = RRM_TRUE;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_BRIEF,"PCI conflict occured with the Serving Cell for PCI: %d",
                    p_ncl_params->lte_ncl.intra_freq_cells[intra_freq_count].phy_cell_id);
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* Bug_12689_fix: End */

/*EICIC_TDD_CHANGES_START*/
/****************************************************************************
 * Function Name  : rrm_find_abs_frame_size 
 * Inputs         : tdd_frame_structure_t
 * Outputs        : None
 * Returns        : U8
 * Description    : this function find the abs size as per tdd config.
 ****************************************************************************/
U8 
rrm_find_abs_frame_size(tdd_frame_structure_t *p_physical_layer_param_tdd_frame_structure)
{
    U8 abs_size = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    
    switch(p_physical_layer_param_tdd_frame_structure->sub_frame_assignment)
    {
        case RRM_OAM_SA0:
            abs_size = RRM_MAX_ABS_PATTERN_BYTE_TDD_0;
            break;

        case RRM_OAM_SA1:
        case RRM_OAM_SA2:
        case RRM_OAM_SA3:
        case RRM_OAM_SA4:
        case RRM_OAM_SA5:

            abs_size = RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5;
            break; 

        case RRM_OAM_SA6:
            abs_size = RRM_MAX_ABS_PATTERN_BYTE_TDD_6;
            break;

        default:
            /*14515_FIX_START*/
            abs_size = RRM_MAX_ABS_PATTERN_BITS_FDD;
            /*14515_FIX_END*/
    }            
    RRM_UT_TRACE_EXIT();
    return abs_size;
}
/****************************************************************************
 * Function Name  : rrm_cellm_fill_abs_pattern_for_tdd
 * Inputs         : rrm_cell_context_t
 *                  rrmcm_rmif_cell_config_req_t
 * Outputs        : None
 * Returns        : Void
 * Description    : this function fill the incoming abs in the cell context.
 ****************************************************************************/
rrm_return_et
rrm_cellm_fill_abs_pattern_for_tdd
(
  rrm_cell_context_t            *p_cell_ctx, /*cell context*/
  rrmcm_rmif_cell_config_req_t  *p_cell_config_req 
)
{

    U8                  low_load_abs_pattern_index = RRM_ZERO;
    U8                  victim_abs_pattern_index = RRM_ZERO;
    U8                  abs_size = RRM_ZERO;
    rrm_return_et       ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);

    /*14999_start*/
    /*code_deleted*/
    /*14999_end*/

    if (RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT & p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
    {
        for (low_load_abs_pattern_index = RRM_ZERO; 
                low_load_abs_pattern_index < abs_size;
                low_load_abs_pattern_index++)
        {
            p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern[low_load_abs_pattern_index] =
                p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern[low_load_abs_pattern_index];
        }
        rrm_copy_tdd_bits(abs_size,p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern);
    }
    /** Filling high load ABS pattern configured from OAM */
    /*eicic ut fix 23Sept2014 start*/
    if (RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT & p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
    {
        for(victim_abs_pattern_index = RRM_ZERO;
                victim_abs_pattern_index < abs_size;
                victim_abs_pattern_index++)
        {
            p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern[victim_abs_pattern_index] =
                p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern[victim_abs_pattern_index];
        }
        rrm_copy_tdd_bits(abs_size,p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern);
    }
    /*eicic ut fix 23Sept2014 end*/
    /*eicic_subset_pattern_fix_start*/
    if (RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
    {
        for(victim_abs_pattern_index = RRM_ZERO;
                victim_abs_pattern_index < abs_size;
                victim_abs_pattern_index++)
        {
            p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset[victim_abs_pattern_index] =
                p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset[victim_abs_pattern_index];
        
        }
        rrm_copy_tdd_bits(abs_size,p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*EICIC_TDD_CHANGES_END*/
rrm_return_et
rmcm_rmif_chek_params_range_and_tdd_config_of_cell_config_req
(
 rrmcm_rmif_cell_config_req_t *p_cell_config_req,
 rrm_cell_context_t           *p_cell_ctx,
 rrm_return_et                *ret_val 
)
{  
    rrm_error_et  fail_cause            = RRM_NO_ERROR;
	/*SPR 20908 +-*/
    /*SPR 19705 +*/
    U16            rrm_scell_deact_timer = RRM_ZERO;
    /*SPR 19705 -*/

    RRM_UT_TRACE_ENTER();

    if (RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_cell_config_req->operator_info.bitmask)
    {
#ifdef TDD_MODE_FLAG        
        /* CA TDD changes start */ 
        /* Check tdd config- For CA , tdd config 5 is not supported */
        if(RRM_OAM_SA5 == p_cell_ctx->ran_info.physical_layer_params.
                physical_layer_param_tdd_frame_structure.sub_frame_assignment)
        {
            *ret_val = RRM_FAILURE;
            fail_cause = RRM_ERR_INVALID_PARAMS;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "CA is not supported for TDD config 5 cell_index = %d",p_cell_ctx->cell_index); 
        }
        /* CA TDD changes end */ 
#endif        
        /*CA STAGE 2*/ 
	/*SPR 20908 +-*/
	/*SPR 21096 +-*/
        /*CA STAGE 2*/       
        if (RRM_DL_DEACT_COMMAND_THRESH_PRESENT & 
                p_cell_config_req->operator_info.ca_config.ca_mac_scheduler_params.bitmask)
        {
            /* If scell_deactivation_timer value is infinity then no need to validate with dl_deact_command_thresh */
            if ((RRM_SCELL_DEACTIVATION_TIMER_PRESENT & 
                        p_cell_config_req->operator_info.ca_config.bitmask) &&
                    (RRM_SCELL_RFINFINITY != p_cell_config_req->operator_info.ca_config.scell_deactivation_timer))
            {
                rrm_scell_deact_timer = rrm_map_scell_deactivation_timer (
                        p_cell_config_req->operator_info.ca_config.scell_deactivation_timer);
                if ((rrm_scell_deact_timer < 
                            p_cell_config_req->operator_info.ca_config.ca_mac_scheduler_params.dl_deact_command_thresh))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "CA config params validation failed scell_deactivation_timer %d < dl_deact_command_thresh %d",
                            rrm_scell_deact_timer, p_cell_config_req->operator_info.ca_config.ca_mac_scheduler_params.dl_deact_command_thresh); 
                    *ret_val = RRM_FAILURE;
                    fail_cause = RRM_ERR_INVALID_PARAMS;
                }
            }
        }

        /* CA is not supported in TDD config 5 , Sending failure in case of TDD config 5  or
           CA config param validation is failed */
        if (RRM_FAILURE == *ret_val)
        {
            if((RRM_SUCCESS == rmcm_rmif_send_config_resp(p_cell_ctx,
                    RRM_FAILURE,
                    fail_cause)) && (RRM_NO_ERROR == fail_cause))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_INFO,"Config Resp Send For Cell Index:%d",
                        p_cell_ctx->cell_index);
                *ret_val = RRM_SUCCESS;
            }
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}   
/*SPR 17778 Fix Start*/
/****************************************************************************
 *  * Function Name  :rrm_validate_idle_mode_params 
 *  * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 *  * Outputs        : None
 *  * Returns        : RRM_SUCCESS/RRM_FAILURE
 *  * Description    : Validate that duplicate carrier earfcnn is not configured
 *****************************************************************************/
rrm_return_et
rrm_validate_idle_mode_params
(rrm_cell_context_t *p_cell_ctx)
{
    idle_mode_mobility_params_t       idle_mode_mobility_params = {RRM_NULL};
    U8                            inter_freq_param_count= RRM_NULL;
    U8                            count = RRM_NULL;
    rrm_return_et                 ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if (RRM_PNULL != p_cell_ctx)
    {
        idle_mode_mobility_params = 
            p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params;
        for (inter_freq_param_count = 0;
                ((inter_freq_param_count< p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.num_valid_inter_freq_list)&&
                 (inter_freq_param_count < MAX_NO_INTER_FREQ)); inter_freq_param_count++)
        {
            for (count = inter_freq_param_count + RRM_ONE; 
                    ((count < p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.num_valid_inter_freq_list)&&
                     (count < MAX_NO_INTER_FREQ)); count++)
            {
                if(idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[inter_freq_param_count].eutra_carrier_arfcn == 
                        idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[count].eutra_carrier_arfcn )
                {
                    ret_val =  RRM_FAILURE;
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "Duplicate inter freq Earfcn received in idle mode mobility params");
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "inter_freq_param_count %u --- duplicate index %u --- earfcn %d,",inter_freq_param_count,count,
                            idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[inter_freq_param_count].eutra_carrier_arfcn);
                    break;
                }
            } 
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 17778 Fix End*/
/*klock_works_changes_end*/
/****************************************************************************
 * Function Name  : rmcm_rmif_cell_config_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Initialises the cell context cell_resource and other parameters
 ****************************************************************************/
rrm_return_et
rmcm_rmif_cell_config_req
(
    rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    rrm_return_et                      ret_val                   = RRM_SUCCESS;
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    U8               abs_size = RRM_ZERO;
#endif    
    U8               eicic_ret_val = RRM_SUCCESS;
    /*EICIC_TDD_CHANGES_END*/
    rrc_rrm_cell_setup_req_t           *p_cell_setup_req         = RRM_PNULL;
    rrmcm_rmif_cell_config_req_t       *p_cell_config_req        = RRM_PNULL;

    /* SPR 10498 Fix Start */
    rrm_daho_cell_config_info_t* p_daho_cfg = RRM_PNULL;
    U8 index = 0;
    /* SPR 10498 Fix End */
#ifdef LTE_EMBMS_SUPPORTED
    rrmcm_mbsfn_subframe_config_list_t *p_mbsfn_config = RRM_PNULL;
    /*SPR 18089:start*/
    rrm_return_et                       embms_ret_val  = RRM_SUCCESS;
    /*SPR 18089:end*/
#endif
    RRM_UT_TRACE_ENTER();
   
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    
    p_cell_config_req = (rrmcm_rmif_cell_config_req_t *)
                        (p_cell_ctx->p_incoming_api_info);
    
    RRM_MEMCPY (&(p_cell_ctx->ran_info), 
                &(p_cell_config_req->ran_info),
                sizeof(ran_t));
#ifdef LTE_EMBMS_SUPPORTED

    p_cell_ctx->rrm_cell_embms_data.operator_config_neigh_cell_config =
        p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.neigh_cell_config;
    rrm_store_neigh_cell_config_for_inter_cell(
            p_cell_ctx->rrm_cell_embms_data.operator_inter_cell_neigh_cell_config,
            p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.num_valid_inter_freq_list,
            p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_freq_params);

    /*SPR 18903:start*/
    RRM_MEMCPY(p_cell_ctx->rrm_cell_embms_data.inter_cell_neigh_cell_config,
                p_cell_ctx->rrm_cell_embms_data.operator_inter_cell_neigh_cell_config,
                sizeof(U8));  
    p_cell_ctx->rrm_cell_embms_data.neigh_cell_config =
        p_cell_ctx->rrm_cell_embms_data.operator_config_neigh_cell_config;
    /*SPR 18903:end*/

    /*Checking subframe allocations received from  OAM is not NULL
    * If NULL returns FAILURE */
    if (RRMCM_RMIF_MBSFN_CONFIGURATION_INFO_PRESENT &
        p_cell_ctx->ran_info.physical_layer_params.bitmask)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                 "checking sf_alloc_info is NULL or NOT for MBSFN info in SIB2"); 
        p_mbsfn_config = &(p_cell_ctx->ran_info.physical_layer_params.
                physical_layer_param_mbsfn_config_info);

        if (RRM_TRUE == rrm_check_sf_alloc_is_null(p_mbsfn_config))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                 " Returning Failure as sf_alloc_info is NULL "); 
    /*SPR 18089:start*/
            embms_ret_val = RRM_FAILURE;
    /*SPR 18089:end*/
        }
        /*
         * Updating operator configured neigh cell config to eMBMS data in cell context
         */
        p_cell_ctx->rrm_cell_embms_data.is_sib2_operator_configured = RRM_ONE;


    }
#endif
    RRM_MEMCPY (&(p_cell_ctx->epc_info), 
                &(p_cell_config_req->epc_info),
                sizeof(epc_t));

    /* Carrier_Aggregation_Start */
    RRM_MEMCPY (&(p_cell_ctx->global_cell_id),
                &(p_cell_config_req->global_cell_id),
                sizeof(rrm_global_cell_id_t));    

    /* SPR 20908 Start */
    RRM_MEMCPY((&p_cell_ctx->l2_comm_info_params),
            &(p_cell_config_req->l2_comm_info_params)
            ,sizeof(rrm_oam_lower_layer_comm_info_t));
    /* SPR 20908 End */
    /*klock_works_changes_start*/   
    /* CA TDD changes start */ 
    if (RRM_FAILURE==rmcm_rmif_chek_params_range_and_tdd_config_of_cell_config_req(p_cell_config_req, p_cell_ctx, &ret_val))
    /* CA TDD changes end */ 
       {
         RRM_UT_TRACE_EXIT();   
         return ret_val;
       }    
    /*klock_works_changes_start*/

    /* Changing the x2_status value as locally connected if the neighbour value 
       reported by OAM is allowed and the cell is present on the same eNodeB*/
       /* SPR 10779 start */
    rrm_cellm_chk_and_change_x2_status(); 
       /* SPR 10779 end */
    /* Carrier_Aggregation_End */

    RRM_MEMCPY (&(p_cell_ctx->operator_info), 
                &(p_cell_config_req->operator_info),
                sizeof(operator_info_t));

    /* SPR 18641_18843 fix start */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "ul_sinr_threshold_to_actv_tti[%d], ul_sinr_threshold_to_deactv_tti[%d], rrm_ue_used_rb_threshold[%d]",
            p_cell_ctx->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti,
            p_cell_ctx->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti,
            p_cell_ctx->operator_info.tti_bundling_info.rrm_ue_used_rb_threshold);
    /* SPR 18641_18843 fix end */

/*EICIC_TDD_CHANGES_START*/    
#ifdef TDD_MODE_FLAG  
    if((p_cell_config_req->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)&& 
          (p_cell_config_req->ran_info.physical_layer_params.bitmask  & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT))
    {    
         abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                                          " return failure as physical_layer_param_tdd_frame_structur is not present for TDD")
        eicic_ret_val = RRM_FAILURE;
    }    
    if((RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_config_req->operator_info.bitmask)&& 
       (RRMCM_RMIF_ABS_INFO_PRESENT &  p_cell_config_req->operator_info.eicic_info.bitmask ) &&
       (RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_config_req->operator_info.eicic_info.abs_info.bitmask))
    {
        if(RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
        {
            if(RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,abs_size))
            {
                eicic_ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                    " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
            }    
        }
        if(RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
        {
          if(RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,abs_size))
          {
              eicic_ret_val = RRM_FAILURE;
              RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                    " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
          }    
       }
       if(RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT &  p_cell_config_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
       {
           if(RRM_FAILURE == rrm_validate_abs_pattern_for_tdd(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,abs_size))
           {
               eicic_ret_val = RRM_FAILURE;
               RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                    " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
           }    
       }    
    }    
#endif    
/*EICIC_TDD_CHANGES_END*/    
    /* Bug_12689_fix: Start */
    rrm_check_if_pci_conflict_intra_ncl_present(p_cell_ctx);
    /* Bug_12689_fix: End */

    /* SPR 10498 Fix Start */
    rrmcm_print_nbr_list_for_nrt(p_cell_ctx);
    p_daho_cfg = &p_cell_ctx->operator_info.daho_cell_config_info; 
    if(p_daho_cfg->bitmask & EUTRA_INTER_FREQ_DAHO_CELL_PRESENT)
    {
        for(index = RRM_ZERO;
                (index < p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.count)
                && (index < MAX_NO_INTER_FREQ); index++)
        {
            RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_BRIEF,
                    "Inter-freq DAHO cell %d : EARFCN = %d, PCI = %d", index + RRM_ONE,
                    p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.
                    rrm_eutran_inter_freq_daho_cell_config_info[index].earfcn,
                    p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.
                    rrm_eutran_inter_freq_daho_cell_config_info[index].phy_cell_id);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_BRIEF,
                "No inter-freq DAHO Cell present");
    }
    /* SPR 10498 Fix End */

    /* Resetting Parameter */
    p_cell_ctx->administrative_procedure_ongoing = RRM_FALSE;
 
    /* SPS related changes start */
    /* RoHC check removal for SPS - start */
    ret_val = set_sps_on_off_for_cell_config(p_cell_config_req, p_cell_ctx);
    /* RoHC check removal for SPS - end */
    /* SPS related changes end */
    /* SPR 19706 Changes Start */
    if(RRM_FAILURE == ret_val)
    {
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* SPR 19706 Changes End */

    p_cell_ctx->ongoing_trans_id = 
                            p_cell_config_req->transaction_id;
    p_cell_ctx->bitmask = RRM_ZERO; 

    if (p_cell_config_req->bitmask 
            & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
    {	
        RRM_MEMCPY(&(p_cell_ctx->access_mgmt_params),
                    &(p_cell_config_req->access_mgmt_params),
                    sizeof(access_mgmt_params_t));
        p_cell_ctx->bitmask |= RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT; 
    }
    /*memory allocation for building cell setup request
     */
    p_cell_setup_req = rrm_mem_get(sizeof(rrc_rrm_cell_setup_req_t));
    if (p_cell_setup_req == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                 "Memory allocation to  p_cell_setup_req failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }
 
    RRM_MEMSET(p_cell_setup_req, RRM_ZERO, sizeof(rrc_rrm_cell_setup_req_t));
    
    /* getting transaction id and immediate start needed
     * from Config request 
     */

    if(RRM_FALSE == p_cell_config_req->immediate_start_needed)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
               "Immediate Start Needed");
    }
    else
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
               "Immediate Start Not Needed");
    } 
    p_cell_ctx->immediate_cell_start =  p_cell_config_req->immediate_start_needed; 
  
/* MC,MR & HO START  */ 

    RRM_MEMCPY (&(p_cell_ctx->ho_parameters),
                &(p_cell_config_req->ho_parameters),
                sizeof(ho_params_t));    

    RRM_MEMCPY (&(p_cell_ctx->global_cell_id),
                &(p_cell_config_req->global_cell_id),
                sizeof(rrm_global_cell_id_t));    
/* MC,MR & HO END */ 

    /* Soft Lock changes Start */
    RRM_MEMCPY (&(p_cell_ctx->block_cell_params_ho),
                &(p_cell_config_req->block_cell_params_ho),
                sizeof(rrm_block_cell_params_ho_t));
    /* Soft Lock changes End */

    /*Load balancing changes start*/
    p_cell_ctx->svr_cell_load_info.bitmask = RRM_ZERO;
    p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.ul.bitmask = RRM_ZERO;
    p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.dl.bitmask = RRM_ZERO;

    p_cell_ctx->svr_cell_load_info.bitmask |= RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT;
    p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val = RRM_MAX_AVLB_CAPCTY;
    p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val = RRM_MAX_AVLB_CAPCTY;
    if(RRMCM_RMIF_CELL_CAPACITY_CLASS_PRESENT & p_cell_config_req->bitmask)
    {
        p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.ul.bitmask |= RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT;
        p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_class_val = p_cell_config_req->cell_cap_class;

        p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.dl.bitmask |= RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT;
        p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_class_val = p_cell_config_req->cell_cap_class;
    }
    /*Load balancing changes end*/

    /* uplink mu mimo chnage start*/
    p_cell_ctx->uplink_sinr_threshold =
    p_cell_config_req->uplink_sinr_threshold;
    p_cell_ctx->uplink_prb_budget_threshold =
    p_cell_config_req->uplink_prb_budget_threshold;
    p_cell_ctx->uplink_prb_budget_down_threshold =
    p_cell_config_req->uplink_prb_budget_down_threshold;
    /* uplink mu mimo chnage end*/

    /* BUG_11317_FIX_START */
    p_cell_ctx->pusch_bler_threshold = p_cell_config_req->pusch_bler_threshold;
    /* BUG_11317_FIX_END */
    /* this function find the mxn support feature license like : 1x1 ,2x2 , 4x2,4x4*/
    rrm_get_mxn_antenna_type_support_on_cbsr_and_port_count( p_cell_ctx );
    /* dyanmic ue scheduling Start*/
    /* This part of code is wriiten if hysteresis does not come from OAM
       then RRM should configure the default hysteresis delta and set the bitmask
    */
    if( RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT & p_cell_ctx->operator_info.bitmask  )
    {
        if( !( RRM_UE_SCHEDULING_HYSTERESIS_PRESENT & p_cell_ctx->operator_info.rrm_ue_scheduling_info.bitmask ))
        {
            p_cell_ctx->operator_info.rrm_ue_scheduling_info.ue_scheduling_hysteresis = 
                                      RRM_DEFAULT_HYSTERESIS_DELTA;

            p_cell_ctx->operator_info.rrm_ue_scheduling_info.bitmask |= RRM_UE_SCHEDULING_HYSTERESIS_PRESENT;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"Default Hysteresis is configuring ,as it is not coming from OAM");
        }

	p_cell_ctx->ue_schedule_to_dl = p_cell_ctx->operator_info.rrm_ue_scheduling_info.max_ue_scheduled_dl;
        p_cell_ctx->ue_schedule_to_ul = p_cell_ctx->operator_info.rrm_ue_scheduling_info.max_ue_scheduled_ul;
    }
    /* Dynamic Ue scheduling End*/
    /* dynamic pdcch start*/
    p_cell_ctx->dynamic_pdcch = 
    p_cell_config_req->dynamic_pdcch;
    /* dynamic pdcch end*/
 
    /* SPR 19309 + */
    p_cell_ctx->cfi_value =
        p_cell_config_req->cfi_value;
    /* SPR 19309 - */

    /* SPR 19310 + */
    p_cell_ctx->num_of_eul =
        p_cell_config_req->num_of_eul;
    p_cell_ctx->size_of_eul =
        p_cell_config_req->size_of_eul;
    /* SPR 19310 - */

    /* Active ue reports comes from mac. this reports are timer based and mac is configured
       for the reports timer in second. this timer info goes in mac_perf_stats_req. 
       As rach feature also have timer configuraiton for reports in perf stats request api.
       Report timer configuration at mac will be overriden by rach feature if rach feature
       configures at mac. 
    */
    p_cell_ctx->active_ue_reports_timer = p_cell_config_req->active_ue_reports_timer;

    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */

    /* Uplink power control starts */
    RRM_MEMCPY( &(p_cell_ctx->rrm_olpc_config_params),
                &(p_cell_config_req->rrm_olpc_config_params),
                sizeof(p_cell_ctx->rrm_olpc_config_params ) );
    /* Uplink power control end */
    /*
     * Initialize the Radio Admission Control parameters
     */
    rrm_cellm_init_rac_rbc_params(p_cell_ctx);

    /* building the RRC cell setup request from MIF config request 
     * and sending to RRC
     */

    /*CA start: for filling format 1b data SPS resources is always allocated*/
       ret_val =  rrm_set_n1_pucch_an_res_for_sps(p_cell_ctx);
    /*CA end: for filling format 1b data SPS resources is always allocated*/

    /*DYNAMIC ICIC START*/
    /*
    ** Copy the dynamic ICIC data recived from MIF in the respective
    ** structure in cell context
    */
    /*SPR 17778 Fix Start*/
    if (ret_val == RRM_SUCCESS)
    {
        ret_val = rrm_validate_idle_mode_params(p_cell_ctx);
    }
    /*SPR 17778 Fix End*/
    RRM_MEMCPY( &(p_cell_ctx->dynamic_icic_data.pdsch_config_params),
                &(p_cell_config_req->rrm_pdsch_config_params),
                sizeof(rrm_pdsch_config_params_t));

    /*DYNAMIC ICIC END*/

    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */
    p_cell_ctx->mac_ecid_meas_start_sfn = p_cell_config_req->mac_ecid_meas_start_sfn;

#ifdef ENDC_ENABLED
    if(RRMCM_RMIF_ENDC_INFO_PRESENT & p_cell_config_req->operator_info.bitmask)
	{
		p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_ENDC_INFO_PRESENT;
		p_cell_ctx->operator_info.endc_info.sgnb_ambr_share = p_cell_config_req->operator_info.endc_info.sgnb_ambr_share;
		p_cell_ctx->operator_info.endc_info.min_num_ue_thp_report = p_cell_config_req->operator_info.endc_info.min_num_ue_thp_report;

		p_cell_ctx->operator_info.endc_info.max_meas_freq_scg_nr =
            p_cell_config_req->operator_info.endc_info.max_meas_freq_scg_nr;

		p_cell_ctx->operator_info.endc_info.max_meas_id_scg_nr =
            p_cell_config_req->operator_info.endc_info.max_meas_id_scg_nr;
	}
#endif
    if((RRM_SUCCESS == ret_val)&&(eicic_ret_val == RRM_SUCCESS) && (RRM_SUCCESS == build_send_rrc_setup_req (p_cell_ctx, 
                                                p_cell_setup_req))
#ifdef LTE_EMBMS_SUPPORTED
    /*SPR 18089:start*/
      && (RRM_SUCCESS == embms_ret_val )
    /*SPR 18089:end*/
#endif
       )
    {
         /* state transition
         */
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                             CELL_STATE_W_FOR_CONFIG_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                             "CELLM Send Setup Req to RRC For Cell Index:%d "
                             "CELLM State Is:%s ",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        ret_val = RRM_SUCCESS;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_setup_req);
#endif        
	
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                               "CELLM Failed To Send Setup Req To RRC "
                             "For Cell Index:%d Cell State Is:%s",
                             p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);

#ifdef RRM_UT_FLAG        
       RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_config_resp_F);
       RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_config_resp_F_cell_config_failure);
#endif        
       
       /*Send failure to MIF*/
       if(RRM_SUCCESS == rmcm_rmif_send_config_resp(p_cell_ctx,
											 RRM_FAILURE,
		                RRM_ERR_CELL_CONFIG_FAILURE))
       {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                   RRM_DETAILED,"Config Resp Send For Cell Index:%d",
                                  p_cell_ctx->cell_index);
      }
      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "Failed to Send Config Resp For Cell Index :%d",
                             p_cell_ctx->cell_index);
      }
    }
    RRM_MEM_FREE(p_cell_setup_req);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : set_sps_on_off_for_cell_config_enable
 * Inputs         : rrmcm_rmif_cell_config_req_t *p_cell_config_req
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Checks whether SPS is to be kept ON/OFF for this cell
 *                  on the basis of SPS_CRNTI_RANGE
 ****************************************************************************/
/* SPR 19706 Changes Start */
rrm_return_et
/* SPR 19706 Changes End */
set_sps_on_off_for_cell_config_enable(rrmcm_rmif_cell_config_req_t    *p_cell_config_req ,
                                      rrm_cell_context_t              *p_cell_ctx ,
                                      U8                              qci_count)
{
    RRM_UT_TRACE_ENTER();
    /* SPR 19706 Changes Start */
    rrm_return_et              ret_val = RRM_SUCCESS;
    /* SPR 19706 Changes End */

            if ( p_cell_config_req->epc_info.epc_params.qos_config_params[qci_count].bitmask &
                    RRMCM_RMIF_SPS_CONFIG_ENABLED_PRESENT )
            {
                if ( p_cell_config_req->epc_info.epc_params.qos_config_params[qci_count].sps_config_enabled )
                {
                    /* SPR 19706 Changes Start */
                    if (RRM_ONE == p_cell_config_req->epc_info.epc_params.qos_config_params[qci_count].erb_service_profile.data_transfer_mode)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Failed to set SPS config, SPS cannot be enabled with RLC Mode set to AM(1) for QCI: %d", (qci_count+RRM_ONE));
                        RRM_UT_TRACE_EXIT();
                        ret_val = RRM_FAILURE;
                        return ret_val;

                    }
                    /* SPR 19706 Changes End */
                    if(RRM_ONE == p_cell_config_req->epc_info.epc_params.qos_config_params[qci_count].erb_service_profile.enable_rohc)
                    {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                              "ROHC is enabled for SPS-enabled QCI:%d", (qci_count+RRM_ONE));
                    }
                    /* RoHC check removal for SPS - start */
                    else
                    {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "ROHC is not enabled for SPS-enabled QCI:%d", (qci_count+RRM_ONE));
                    }

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "SPS feature is anyways being enabled for SPS-enabled QCI:%d", (qci_count+RRM_ONE));
                    
                    p_cell_ctx->sps_on = RRM_TRUE;
                    p_cell_ctx->sps_ues_count = RRM_ZERO;
                    p_cell_ctx->sps_n1_pucch_an_marked_st = RRM_PNULL;
                    p_cell_ctx->sps_long_drx_cycle_start_offset = RRM_ZERO;
                    /*SPR_8597_FIX_START*/
                    p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx = RRM_ZERO;
                    /*SPR_8597_FIX_END*/
                    p_cell_ctx->sps_n1_pucch_an_start_indx = RRM_ZERO;
                    /* RoHC check removal for SPS - end */
                }
                /* Start SPR:9262 */
                else
                {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " sps_config_enabled is false for QCI:%d", 
                        (qci_count+RRM_ONE));
                }
            }
            else
            {
                /* if sps config enabled TAG is absent for a QCI */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " SPS_CONFIG_ENABLED tag is not present for QCI:%d, bitmask =%d", 
                        (qci_count+RRM_ONE),
                        p_cell_config_req->epc_info.epc_params.qos_config_params[qci_count].bitmask);
            }
            /* End SPR:9262 */
    RRM_UT_TRACE_EXIT();
    /* SPR 19706 Changes Start */
    return ret_val;
    /* SPR 19706 Changes End */
}
/*Klockwork_fix_end*/

/* SPS related changes start - Global Variable removal */
/****************************************************************************
 * Function Name  : set_sps_on_off_for_cell_config
 * Inputs         : rrmcm_rmif_cell_config_req_t *p_cell_config_req
 *                : rrm_cell_context_t           *p_cell_ctx
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Checks whether SPS is to be kept ON/OFF for this cell
 *                  on the basis of SPS_CRNTI_RANGE
 ****************************************************************************/
rrm_return_et
set_sps_on_off_for_cell_config(
        rrmcm_rmif_cell_config_req_t    *p_cell_config_req,
        rrm_cell_context_t              *p_cell_ctx
        )
{
    rrm_return_et              ret_val = RRM_SUCCESS;
    U8                         qci_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(p_cell_config_req->operator_info.bitmask & RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT)
    {
        for (qci_count = RRM_ZERO;
             ((qci_count < p_cell_config_req->epc_info.epc_params.num_valid_qos_profiles)&&
              (qci_count < RRM_MAX_QCI));
             qci_count++)
        {
            /*Klockwork_fix_start*/
            /* SPR 19706 Changes Start */
            ret_val = set_sps_on_off_for_cell_config_enable(p_cell_config_req ,p_cell_ctx ,qci_count);
            if (RRM_FAILURE == ret_val)
            {
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
            /* SPR 19706 Changes Start */
            /*Klockwork_fix_end*/
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "SPS is kept OFF for Cell Index :%d, since SPS_CRNTI_RANGE is absent for this cell",
                    p_cell_ctx->cell_index);
    }
    /* Start SPR:9262 */
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "SPS feature is %s for this cell=%d",
                    (p_cell_ctx->sps_on == RRM_TRUE)?"ON":"OFF",
                    p_cell_ctx->cell_index);
    /* End SPR:9262 */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPS related changes end - Global Variable removal */

/****************************************************************************
 * Function Name  : rmcm_rmif_send_config_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles Success response for Config in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_config_resp
(
    rrm_cell_context_t *p_cell_ctx, /*cell context*/
		U8 response,
    rrm_error_et fail_cause /* Coverity: CID 55839 */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_config_resp  *p_cellm_rmif_config_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cellm_rmif_config_resp = rrm_mem_get(sizeof
                                      (rrmcm_rmif_cell_config_resp));
    if (p_cellm_rmif_config_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cellm_rmif_config_resp failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_MEMCPY(&(p_cellm_rmif_config_resp->global_cell_id),
                &(p_cell_ctx->global_cell_id),
                sizeof(rrm_global_cell_id_t));

     p_cellm_rmif_config_resp->cellindex = p_cell_ctx->cell_index;
     p_cellm_rmif_config_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
     p_cellm_rmif_config_resp->response = response;
     p_cellm_rmif_config_resp->fail_cause = fail_cause;
     if (fail_cause != RRM_NO_ERROR)
     {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
             "Cell Config Failed: Fail Cause:%d",fail_cause);
     }
     else
     {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
             "CELL Configured Successfully");
     }

     /*
      * sending failure response to MIF
      */
      if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                             RRMCM_RMIF_CELL_CONFIG_RESP,
                             sizeof(rrmcm_rmif_cell_config_resp),
                             (void *)p_cellm_rmif_config_resp))
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "CELLM Send Config Resp To MIF For Cell Index:%d",
                  p_cell_ctx->cell_index);
          ret_val = RRM_SUCCESS;
          /* DYNAMIC ICIC CHANGES START */ 
          /* BUG 9787 Fix Start */
          if (RRM_NO_ERROR == fail_cause)
          {
            rrm_l2_build_send_reconfig_schedule_params(p_cell_ctx);
          }
          /* BUG 9787 Fix End */
          /* DYNAMIC ICIC CHANGES END */
      }
      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "CELLM Failed To Send Config Resp To MIF Cell Index:%d",
                  p_cell_ctx->cell_index);
          ret_val = RRM_FAILURE;
      }
      RRM_MEM_FREE(p_cellm_rmif_config_resp);                                             
      RRM_UT_TRACE_EXIT();
      return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_rrc_cell_setup_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : handle cell setup response in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rrc_cell_setup_resp( rrm_cell_context_t *p_cell_ctx /*cell context*/)
{
    rrm_return_et	               ret_val = RRM_SUCCESS;
    rrm_error_et                   fail_cause = RRM_NO_ERROR;
    rrc_rrm_cell_setup_resp_t    *rrc_rrm_cell_setup_resp =  RRM_PNULL;
    rrmcm_rmif_generic_resp_t    *p_generic_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    rrc_rrm_cell_setup_resp = (rrc_rrm_cell_setup_resp_t *)p_cell_ctx->p_incoming_api_info;
    RRM_ASSERT(RRM_PNULL != rrc_rrm_cell_setup_resp);


    if (RRM_SUCCESS != rrc_rrm_cell_setup_resp->response)
    {
        /*Building and sending fail response to MIF*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Fail cause of Config From RRC:%d For cell Index:%d",
                rrc_rrm_cell_setup_resp->fail_cause, p_cell_ctx->cell_index);

        fail_cause = fail_cause_mapping(rrc_rrm_cell_setup_resp->fail_cause); 

        if (p_cell_ctx->cell_reconfig_deletion_required)
        {
            /* BUG_876_CHANGES_START*/
            if (RRM_CELLM_REF_SIG_PWR_NOT_UPDATED == p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
            {
            /*Building and sending fail response to MIF for reconfig*/
            p_generic_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_resp_t));
            /*  , coverity  id :16285 , added NULL check for rrm_mem_get */
            if(p_generic_resp != RRM_PNULL)
            {
                p_generic_resp->cellindex = p_cell_ctx->cell_index;
                p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
                p_generic_resp->response =  rrc_rrm_cell_setup_resp->response;
                p_generic_resp->fail_cause = RRM_ERR_CELL_DELETION_EXPECTED;
                ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                        RRMCM_RMIF_CELL_RECONFIG_RESP,
                        sizeof(rrmcm_rmif_generic_resp_t),
                        (void *)p_generic_resp);
                    /* Coverity 74312 Fix Start */
                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                                "Send failed for RRMCM_RMIF_CELL_RECONFIG_RESP");
                    }
                    /* Coverity 74312 Fix End */

                    RRM_MEM_FREE(p_generic_resp);
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                            "Memory allocation to p_generic_resp failed");
                    ret_val = RRM_FAILURE;
                }
            }
            else
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                        "Reconfig Failed for ICIC");
                p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;
            }
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                    "Reconfig Failed for ICIC");
            p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;
	    /*SPR 20908 Start*/
	    RRM_MEMSET(&p_cell_ctx->l2_comm_info_params,RRM_ZERO,sizeof(rrm_oam_lower_layer_comm_info_t));
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                    "L2 Comm Info reverted on RRM");
	    /*SPR 20908 End*/
                /*State transition*/
    /* Coverity 65129 fix start */
                CELL_M_FSM_SET_STATE(p_cell_ctx, 
                        CELL_STATE_W_FOR_CELL_DEL_RECONFIG_FAILED);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Cell Reconfig Failed Cell State is:%s",
                        CELL_FSM_STATE[p_cell_ctx->cell_state]);
    /* Coverity 65129 fix end */
            /* BUG_876_CHANGES_END*/

        }
        else
        {
            ret_val = rmcm_rmif_send_config_resp(p_cell_ctx,
                    rrc_rrm_cell_setup_resp->response,
                    fail_cause);
            /* Coverity 74312 Fix Start */
            if(RRM_FAILURE == ret_val)
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                        "Send failed for rrc_rrm_cell_setup_resp ");
            }
            /* Coverity 74312 Fix End */
            /*State transition*/
            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_IDLE);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell Setup Failed Cell State is: %s",
                    CELL_FSM_STATE[p_cell_ctx->cell_state]);
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
        /*Configure MAC CELL CONFIG*/
	    rrm_request_l2_cell_config_req(
    /*SPR 17777 +-*/
    /* eICIC_PHASE_1_2_CHANGES_START */
                                        p_cell_ctx
    /* eICIC_PHASE_1_2_CHANGES_START */
                                        );

    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 21660 changes start */

/****************************************************************************
 * Function Name  : rmcm_rmif_send_start_resp
 * Inputs         : rrc_rrm_cell_start_resp_t  *rrc_rrm_cell_start_resp 
 *                : U16   transaction_id : transaction id 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Send Start Response to mif From Cell FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_start_resp
(
 rrc_rrm_cell_start_resp_t  *rrc_rrm_cell_start_resp,
 U16   transaction_id 
)
{
   rrm_return_et ret_val = RRM_SUCCESS;
   rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
//   rrc_rrm_cell_start_resp_t  *rrc_rrm_cell_start_resp = RRM_PNULL;
//   rrc_rrm_cell_start_resp = p_cell_ctx->p_incoming_api_info;

   RRM_UT_TRACE_ENTER();

   p_generic_resp = rrm_mem_get(sizeof
                                   (rrmcm_rmif_generic_resp_t));

   /*  , coverity  id :16282 , added NULL check for rrm_mem_get */
   if(p_generic_resp != RRM_PNULL)
   {
       p_generic_resp->cellindex = rrc_rrm_cell_start_resp->cell_index;
       p_generic_resp->transaction_id = transaction_id;
       p_generic_resp->response = rrc_rrm_cell_start_resp->response;
       if(RRM_FAILURE == rrc_rrm_cell_start_resp->response)
       {				
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Fail cause of Start From RRC:%d for cell index:%d",
                   rrc_rrm_cell_start_resp->fail_cause,
                   rrc_rrm_cell_start_resp->cell_index);
           p_generic_resp->fail_cause = fail_cause_mapping(
                   rrc_rrm_cell_start_resp->fail_cause);
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                   RRM_ERROR,"Cell Start Failed");

       }
       else
       {
           p_generic_resp->fail_cause = RRM_NO_ERROR;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Cell Start Success For Cell Index:%d",
                   rrc_rrm_cell_start_resp->cell_index);
       }

       if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                   RRMCM_RMIF_CELL_START_RESP,
                   sizeof(rrmcm_rmif_generic_resp_t),
                   (void *)p_generic_resp))

       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                   "failure in sending Start Resp:%d for cell index:%d",
                   RRMCM_RMIF_CELL_START_RESP,
                   rrc_rrm_cell_start_resp->cell_index);
           ret_val = RRM_FAILURE;
       }
       else
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                   "Success in sending Start Resp:%d for cell index:%d",
                   RRMCM_RMIF_CELL_START_RESP,
                   rrc_rrm_cell_start_resp->cell_index);
           ret_val = RRM_SUCCESS;
       }
       RRM_MEM_FREE(p_generic_resp);
   }
   else
   {
       RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
               "Memory allocation to p_generic_resp failed");
       ret_val = RRM_FAILURE;
   }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/* SPR 21660 changes end */

/****************************************************************************
 * Function Name  : rrm_rrc_cell_start_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rrm_rrc_cell_start_resp in FSM
 ****************************************************************************/

rrm_return_et
rrm_rrc_cell_start_resp
(
    rrm_cell_context_t *p_cell_ctx /* cell context */
)
{
    rrm_return_et  ret_val = RRM_FAILURE;
    rrc_rrm_cell_start_resp_t  *rrc_rrm_cell_start_resp = RRM_PNULL;
    cell_timer_buf_t timer_buf;

    RRM_UT_TRACE_ENTER();
    rrc_rrm_cell_start_resp = p_cell_ctx->p_incoming_api_info;
    if (RRM_FAILURE == rrc_rrm_cell_start_resp->response)
    {
#ifdef RRM_UT_FLAG        
       RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_start_resp_F);
#endif        
      
       /*Building and Sending failure response to MIF
        */ 
       /* SPR 21660 changes start */
       ret_val = rmcm_rmif_send_start_resp(rrc_rrm_cell_start_resp,
					                 p_cell_ctx->ongoing_trans_id);
       /* SPR 21660 changes end */
       if(RRM_FAILURE == ret_val)
	     {
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
            RRM_ERROR,"Failure in sending Failure response for Cell Start ");
	     }

       /*State transition
        */
       if((CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_ACTIVE_STATE == p_cell_ctx->ongoing_proc_triggered) ||
          (CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_INACTIVE_STATE == p_cell_ctx->ongoing_proc_triggered)  ||
          (CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_OOS_STATE == p_cell_ctx->ongoing_proc_triggered))
       {
          switch(p_cell_ctx->ongoing_proc_triggered)
          {
            case CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_ACTIVE_STATE:
               CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
               break;

            case CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_INACTIVE_STATE:
               CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_INACTIVE);
               break;

            case CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_OOS_STATE:
               CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_OUT_OF_SERVICE);
               break;
	    /*LTE_RRM_WARNING_REMOVAL_START */
	    default :
	    ;
	    /*LTE_RRM_WARNING_REMOVAL_END */
          }
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
               "Cell State triggered from external procedure(OAM/SON) is failed so keeping Cell in same STATE[%d]",
                    p_cell_ctx->cell_state);
          p_cell_ctx->ongoing_proc_triggered = CELLM_PROC_TRIGGERRED_SET_TO_NONE;
       }
       else
       {
         CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_OUT_OF_SERVICE);
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
               "Cell State Is:%s[%d]",
               CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
       }
    /* Spr 16211 Changes Start*/
        if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Sending RIM info req with PDU ext as STOP as cell has not been successfully started");
            rrm_request_rim_info_req(p_cell_ctx, 
                    &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
                    RAN_INFO_REQ_STOP);
        }
    /* Spr 16211 Changes End*/
    }
    else
    {
#ifdef RRM_UT_FLAG        
       RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_start_resp_S);
#endif        
       /* SPR 21660 changes start */
       ret_val = rmcm_rmif_send_start_resp(rrc_rrm_cell_start_resp,
               p_cell_ctx->ongoing_trans_id);
       /* SPR 21660 changes end */
	    if(RRM_FAILURE == ret_val)
	    {
		    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Cell Start Resp:Failed to Send to MIF ");
	    }
        /*Bug_857 start */
        RRM_GETTIMEOFDAY(&p_cell_ctx->kpi_stat.cell_start_time, RRM_PNULL);
        /*Bug_857 end*/
        /* CSR-81563[SPR-11383]-fix start */
        if (RRM_ZERO != p_cell_ctx->kpi_stat.cell_stop_time.tv_sec)
        {
            p_cell_ctx->kpi_stat.accumulative_duration += p_cell_ctx->kpi_stat.cell_start_time.tv_sec - p_cell_ctx->kpi_stat.cell_stop_time.tv_sec;
        }
        /* CSR-81563[SPR-11383]-fix end */

        /*RIM changes start*/
        /* Spr 16211 Changes Start*/
        if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Sending RIM info req as cell has been successfully started");
            rrm_request_rim_info_req(p_cell_ctx, 
                    &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
                    RAN_INFO_REQ_MULTI_REPORT);
        }
    /* Spr 16211 Changes End*/
        /*RIM changes end*/
        /*CSR_00059028_CHANGES_START */
        p_cell_ctx->immediate_cell_start = RRM_TRUE;
        /*CSR_00059028_CHANGES_END */

	    CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
        CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
        /*BUG:102 start*/
        p_cell_ctx->cell_stop_not_send_active_ue_count = RRM_FALSE;
        /*BUG:102 end*/
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell State Is:%s[%d]",
			    CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
        /* MLB Changes start */
        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO])
        {
            timer_buf.cell_index = p_cell_ctx->cell_index;
            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO;
            p_cell_ctx->self_load_rpt_tmr = cell_start_timer(CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO,
                    (rrm_void_t *)&timer_buf,
                    sizeof (cell_timer_buf_t), p_cell_ctx);
            /* Coverity ID 78280 Fix Start*/
            rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx,
                    p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
            /* Coverity ID 78280 Fix End*/
        }
        /* SON ES MLB Started */
        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO])
        {
            timer_buf.cell_index = p_cell_ctx->cell_index;
            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO;
              /* CID : 60713 fix start*/
	    /* SPR 21831 Start */
	    if(RRM_PNULL != p_cell_ctx->p_son_info)
	    {
		    if(RRM_PNULL != p_cell_ctx->p_son_info->p_es_info)
		    {
	    /* SPR 21831 End */
			    p_cell_ctx->p_son_info->p_es_info->cell_timer_id[SON_ES_LD_SELF_TIMER] =
				    cell_start_timer ( CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO , (rrm_void_t *)&timer_buf,
						    sizeof (cell_timer_buf_t), p_cell_ctx);
	    /* SPR 21831 Start */
		    }
	    }
	    /* SPR 21831 End */
        /* CID : 60713 fix end */
        }
        /* MLB Ph2 Start */
        /*SPR 22982 Fix Start*/
        /*Code Removed*/
        /*SPR 22982 Fix Stop*/

        
        rrm_cellm_start_ld_process_timer (p_cell_ctx);
        /* MLB Ph2 End */
        ret_val = rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx,
                 p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
        /* MLB Changes end */
        /* BUG_11848_CHANGES_START */
        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_RECONFIG_TIMER_FOR_ICIC])
        {
            timer_buf.cell_index = p_cell_ctx->cell_index;
            timer_buf.timer_type = CELL_RECONFIG_TIMER_FOR_ICIC;
            p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic =
                cell_start_timer(CELL_RECONFIG_TIMER_FOR_ICIC,
                                 (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
        }
        /* BUG_11848_CHANGES_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /*SPR 14810 start*/
        /* SPR 21419 Fix Start */
        /* Code Deleted */
        /* SPR 21419 Fix Stop */
        /* eICIC_PHASE_1_2_CHANGES_END */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_rmif_send_reconfig_ongoing_start_succ
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Reconfig is completed and send success cell start 
 *                : response to MIF
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_reconfig_ongoing_start_succ
(
  rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    rrm_return_et ret_val = RRM_SUCCESS; 
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    rrc_rrm_cell_start_resp_t *rrc_rrm_cell_start_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    rrc_rrm_cell_start_resp = (rrc_rrm_cell_start_resp_t *)
        p_cell_ctx->p_incoming_api_info;

    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16281 , added NULL check for rrm_mem_get */
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = rrc_rrm_cell_start_resp->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        /*chk reconfig is failed or success*/
        if(p_cell_ctx->stop_reconfig_fail & RRM_RECONFIG_FAIL)
        {
            p_generic_resp->response = RRM_FAILURE;
            p_generic_resp->fail_cause = fail_cause_mapping(
                    p_cell_ctx->ongoing_procedure_fail_cause);
        }
        else
        {
            p_generic_resp->response = rrc_rrm_cell_start_resp->response;
            p_generic_resp->fail_cause = RRM_NO_ERROR;
        }

        if(RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_RECONFIG_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_generic_resp))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_RECONFIG_RESP,
                    p_cell_ctx->cell_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_RECONFIG_RESP,
                    p_cell_ctx->cell_index);
            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 * Function Name  : rmcm_rmif_reconfig_ongoing_start_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_rmif_reconfig_ongoing_start_resp in FSM
 ****************************************************************************/

rrm_return_et
rmcm_rmif_reconfig_ongoing_start_resp
(
    rrm_cell_context_t *p_cell_ctx /* cell context */
)
{
    rrm_return_et  ret_val = RRM_FAILURE;
    rrc_rrm_cell_start_resp_t *p_rrc_rrm_cell_start_resp = RRM_PNULL;
    p_rrc_rrm_cell_start_resp = (rrc_rrm_cell_start_resp_t *)
						                         p_cell_ctx->p_incoming_api_info;

    RRM_UT_TRACE_ENTER();
    
    
    if (RRM_FAILURE == p_rrc_rrm_cell_start_resp->response)
    {
        /*Reconfig fail and cell start fails
         */
         ret_val = rmcm_rmif_send_reconfig_ongoing_start_stop_fail(p_cell_ctx);
         if (RRM_FAILURE == ret_val)
         {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                       RRM_DETAILED, "Failed to send generic response to MIF"); 
				 }
				 CELL_M_FSM_SET_STATE(p_cell_ctx,
                                CELL_STATE_W_FOR_CELL_DEL);
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Reconfig Failed for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
    }
    else
    {
        /*reconfig fail and cell start success
         */
        ret_val =rmcm_rmif_send_reconfig_ongoing_start_succ(p_cell_ctx);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_BRIEF, "Failed to send generic response to MIF");
        /*CID 97136 Start*/
        }
        /*CID 97136 End*/
        /*RIM changes start*/
        /* Spr 16211 Changes Start*/
        if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Sending RIM info Req to all neighbouring Inter RAT cells "
                    "as cell has started successfully");
            rrm_request_rim_info_req(p_cell_ctx,
                    &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
                    RAN_INFO_REQ_MULTI_REPORT);
        }
        /* CID 97136 Start */
        /* Spr 16211 Changes End*/
        /*RIM changes end*/

	    /* DYNAMIC ICIC CHANGES START */  
	    /* BUG 9787 Fix Start */
	    rrm_l2_build_send_reconfig_schedule_params(p_cell_ctx);
	    /* BUG 9787 Fix End */
	    /* DYNAMIC ICIC CHANGES END */
	    /* CID 97136 End */
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                                 CELL_STATE_ACTIVE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Cell Reconfig Success for Cell Index:%d Cell State is:%s",
                    p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*Klockwork_fix_2431_start*/
/****************************************************************************
 * Function Name  : rrm_decision_cell_stop_physical_layer_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None 
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_param(rrm_cell_context_t  *p_cell_ctx,
                                            rrm_bool_et         *stop_flag)
{
    RRM_UT_TRACE_ENTER();

   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT))
   {
       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_pdsch.p_b)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "p_b Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b, 
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b);
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled !=
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_srs.srsEnabled)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "SRS Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
                   physical_layer_param_srs.srsEnabled);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_decision_cell_stop_physical_layer_param_srs
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_param_srs(rrm_cell_context_t *p_cell_ctx,
                                                rrm_bool_et *stop_flag)
{
    RRM_UT_TRACE_ENTER();
   
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT))
   {
       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.
               srs_bandwidth_config !=
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_srs.srs_bandwidth_config)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "SRS BW Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srs_bandwidth_config, 
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_srs.srs_bandwidth_config);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.
               srs_max_up_pts != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_srs.srs_max_up_pts)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "SRS Max Up Pts Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srs_max_up_pts, 
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_srs.srs_max_up_pts);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.
               ack_nack_srs_simultaneous_transmission != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_srs.ack_nack_srs_simultaneous_transmission)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "SRS Ack/Nack Simul Trans Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.ack_nack_srs_simultaneous_transmission, 
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_srs.ack_nack_srs_simultaneous_transmission);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_param_prach
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_param_prach(rrm_cell_context_t *p_cell_ctx,
                                                  rrm_bool_et *stop_flag)
{
    RRM_UT_TRACE_ENTER(); 
    
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT))
   {
       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.
               root_sequence_index != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.
               root_sequence_index )
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Root sequence Index Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.root_sequence_index ,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.root_sequence_index
                   );
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.
               configuration_index != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.
               configuration_index)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   " Config Index Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.configuration_index ,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.configuration_index
                   );
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.
               high_speed_flag != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.
               high_speed_flag)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "High Speed Flag Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.high_speed_flag ,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.high_speed_flag
                   );
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.
               zero_correlation_zone_config != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.
               zero_correlation_zone_config)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Zero Correlation Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.zero_correlation_zone_config ,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.zero_correlation_zone_config
                   );
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.
               frequency_offset != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.
               frequency_offset)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Frequency Offset Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_prach.frequency_offset ,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_prach.frequency_offset);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_param_pucch
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
    rrm_void_t
rrm_decision_cell_stop_physical_layer_param_pucch(rrm_cell_context_t *p_cell_ctx,
                                                  rrm_bool_et *stop_flag)
{
    RRM_UT_TRACE_ENTER();

   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT))
   {
       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.
               delta_pucch_shift != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_pucch.delta_pucch_shift
         )
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Delta PUCCH Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi !=
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_pucch.n_rb_cqi)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "N-RB-CQI Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi, 
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an !=
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.
               physical_layer_param_pucch.n_cs_an)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "N-CS-AN Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an !=
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pucch.
               n1_pucch_an)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "N1-PUCCH-AN Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_param_pusch
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
    rrm_void_t
rrm_decision_cell_stop_physical_layer_param_pusch(rrm_cell_context_t *p_cell_ctx ,
                                                  rrm_bool_et        *stop_flag)
{
    RRM_UT_TRACE_ENTER();
       
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT))
   {
       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.
               n_sb != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.
               n_sb)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "N-SB Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.n_sb,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.n_sb);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.
               pusch_hopping_mode != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.
               pusch_hopping_mode)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Pushc Hopping Mode Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.pusch_hopping_mode,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.pusch_hopping_mode);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.
               hopping_offset != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.
               hopping_offset)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Hopping Offset Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.hopping_offset,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.hopping_offset);
       }

       if(p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.
               enable_64_qam != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.
               enable_64_qam )
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Enable 64 QAM Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pusch.enable_64_qam,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_pusch.enable_64_qam);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_param_ul_ref_sig
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
    rrm_void_t
rrm_decision_cell_stop_physical_layer_param_ul_ref_sig(rrm_cell_context_t *p_cell_ctx,
                                                       rrm_bool_et *stop_flag)
{
    RRM_UT_TRACE_ENTER();

   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT))
   {
       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               group_hopping_enabled != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               group_hopping_enabled)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Group Hopping Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_hopping_enabled,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_hopping_enabled);
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               group_assignment_pusch != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               group_assignment_pusch)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Group Assignment Pusch Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_assignment_pusch,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_assignment_pusch);
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               sequence_hopping_enabled != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               sequence_hopping_enabled)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Sequence Hopping Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.sequence_hopping_enabled, 
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.sequence_hopping_enabled);
       }

       if (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               cyclic_shift != 
               p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.
               cyclic_shift)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Cyclic Shift Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.cyclic_shift,
                   p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.cyclic_shift);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_ran_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_ran_param(rrm_cell_context_t *p_cell_ctx,
                                                rrm_bool_et *stop_flag)
{
    RRM_UT_TRACE_ENTER(); 

   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT))
   {
       if (p_cell_ctx->ran_info.rf_params.rf_configurations.psch_power_offset !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.psch_power_offset)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Primary Synchronization signal EPRE/EPRERS Reconfigured Old Value(%d), New Value(%d)",
                   p_cell_ctx->ran_info.rf_params.rf_configurations.psch_power_offset,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.psch_power_offset);
       }

       if (p_cell_ctx->ran_info.rf_params.rf_configurations.ssch_power_offset !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ssch_power_offset)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Secondary Synchronization signal EPRE/EPRERS Reconfigured Old Value(%d), New Value(%d)",
                   p_cell_ctx->ran_info.rf_params.rf_configurations.ssch_power_offset,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ssch_power_offset);
       }

       if (p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.reference_signal_power)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Reference  Signal Power Reconfigured Old Value(%d), New Value(%d)",
                   p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.reference_signal_power);
       }

       if (p_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.phy_cell_id)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "Old Cell Id(%d), New Cell Id(%d)",
                   p_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.phy_cell_id);
       }

       if (p_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.dl_bandwidth)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   " Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.dl_bandwidth);
       }
       /* + SPR 17904 */
       if (p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.dl_earfcn )
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                   " Reconfigured dl_earfcn Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.dl_earfcn);
       }
       if (p_cell_ctx->ran_info.rf_params.rf_configurations.ul_earfcn !=
               p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ul_earfcn )
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                   " Reconfigured ul_earfcn Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.rf_params.rf_configurations.ul_earfcn,
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ul_earfcn);
       }
       /* - SPR 17904 */

       if ((p_cell_ctx->ran_info.rf_params.rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT) &&
               (p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT))
       {
           if (p_cell_ctx->ran_info.rf_params.rf_configurations.ul_bandwidth !=
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ul_bandwidth)
           {
                *stop_flag = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                       "UL BW Reconfigured Old = [%d], New = [%d]", 
                       p_cell_ctx->ran_info.rf_params.rf_configurations.ul_bandwidth,
                       p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ul_bandwidth);
           }
       }
       /* Absent during Config but Present during Reconfig */
       if ((!(p_cell_ctx->ran_info.rf_params.rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT) &&
                   (p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT))
               ||
               /* Present during Config but absent during Reconfig */
               ((p_cell_ctx->ran_info.rf_params.rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT) &&
                !(p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT)))
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                   "UL BW not present earlier now Configured as [%d]", 
                   p_cell_ctx->p_new_reconfig_data->ran_info.rf_params.rf_configurations.ul_bandwidth);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_rach_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_rach_param(rrm_cell_context_t *p_cell_ctx,
                                                 rrm_bool_et *stop_flag)
{
    RRM_UT_TRACE_ENTER();
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.bitmask & RRMCM_RMIF_MAC_LAYER_PARAM_RACH_PRESENT))
   {

       if(p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.number_of_ra_preambles !=
               p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.number_of_ra_preambles)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Number of RA Preambles Reconfigured ");
       }
       if(p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.bitmask !=
               p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.bitmask)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "GroupA Info Reconfigured ");
       }
       else
       {
           if(p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a !=
                   p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a)
           {
                *stop_flag = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                       "GroupA Info Size of RA Reconfigured ");
           }
            /* SPR 10649 Fix Start*/
            if(p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_size_group_a !=
                   p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.
                   preamble_info.ra_preamble_groupA_info.message_size_group_a)
           {
                *stop_flag = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                       "GroupA Info Message Size GroupA Reconfigured ");
           }
            /* SPR 10649 Fix End */
       } 
       /* BUG_571_CHANGE_END */ 

       if( p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.response_window_size !=
               p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.response_window_size)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Response Window Size Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.response_window_size,
                   p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.response_window_size);
       }

       if( p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.contention_resolution_timer !=
               p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.contention_resolution_timer)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Contention Resolution Timer Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_rach.contention_resolution_timer,
                   p_cell_ctx->p_new_reconfig_data->ran_info.mac_layer_params.mac_layer_param_rach.contention_resolution_timer);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_sib_2_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_sib_2_param(rrm_cell_context_t *p_cell_ctx,
                                                  rrm_bool_et         *stop_flag)
{
   RRM_UT_TRACE_ENTER();
   /* BUG_571_CHANGE_START */
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT))
   {
       if(p_cell_ctx->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle !=
               p_cell_ctx->p_new_reconfig_data->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle)
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Default Paging Cycle Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle ,
                   p_cell_ctx->p_new_reconfig_data->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle);
       }

       if(p_cell_ctx->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.nB !=
               p_cell_ctx->p_new_reconfig_data->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.nB)
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "N-B Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.nB ,
                   p_cell_ctx->p_new_reconfig_data->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.nB);
       }

       if(p_cell_ctx->operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length !=
               p_cell_ctx->p_new_reconfig_data->operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length)
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "UL Cyclic Prefix Length Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length ,
                   p_cell_ctx->p_new_reconfig_data->operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_phich
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_phich(rrm_cell_context_t *p_cell_ctx,
                                            rrm_bool_et         *stop_flag)
{
    RRM_UT_TRACE_ENTER();
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->operator_info.bitmask & RRMCM_RMIF_PHICH_CONFIG_PRESENT))
   {
       if(p_cell_ctx->operator_info.phich_config.phich_resource !=
               p_cell_ctx->p_new_reconfig_data->operator_info.phich_config.phich_resource)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "PHICH Resource Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.phich_config.phich_resource,
                   p_cell_ctx->p_new_reconfig_data->operator_info.phich_config.phich_resource);
       }

       if(p_cell_ctx->operator_info.phich_config.phich_duration !=
               p_cell_ctx->p_new_reconfig_data->operator_info.phich_config.phich_duration)
       {
            *stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "PHICH Duration Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.phich_config.phich_duration,
                   p_cell_ctx->p_new_reconfig_data->operator_info.phich_config.phich_duration);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_decision_cell_stop_physical_layer_mac
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_physical_layer_mac(rrm_cell_context_t *p_cell_ctx,
                                          rrm_bool_et         *stop_flag)
{
   RRM_UT_TRACE_ENTER();
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->operator_info.bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT))
   {
       if(p_cell_ctx->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset !=
               p_cell_ctx->p_new_reconfig_data->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset)
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "PHICH Power Offset Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset,
                   p_cell_ctx->p_new_reconfig_data->operator_info.rrm_mac_config.mac_downlink_power_control_common.phichPowerOffset);
       }

       if(p_cell_ctx->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset !=
               p_cell_ctx->p_new_reconfig_data->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset)
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "PCFICH Power Offset Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset,
                   p_cell_ctx->p_new_reconfig_data->operator_info.rrm_mac_config.mac_downlink_power_control_common.pcfichPowerOffset);
       }
   }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_decision_cell_stop_operator_info
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : None
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_void_t
rrm_decision_cell_stop_operator_info(rrm_cell_context_t *p_cell_ctx,
                                     rrm_bool_et         *stop_flag)
{
   RRM_UT_TRACE_ENTER();
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->operator_info.bitmask & RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT))
   {
       if(p_cell_ctx->operator_info.cell_params.dl_cyclic_prefix !=
               p_cell_ctx->p_new_reconfig_data->operator_info.cell_params.dl_cyclic_prefix)
       {
           *stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "DL Cyclic Prefix Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->operator_info.cell_params.dl_cyclic_prefix,
                   p_cell_ctx->p_new_reconfig_data->operator_info.cell_params.dl_cyclic_prefix);
       }
   }
   RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_2431_end*/
/****************************************************************************
 * Function Name  : rrm_decision_cell_stop
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : decision should be made for reconfig in FSM
 ****************************************************************************/
rrm_bool_et
rrm_decision_cell_stop
(
 rrm_cell_context_t *p_cell_ctx
 )
{
   rrm_bool_et stop_flag = RRM_FALSE;
   RRM_UT_TRACE_ENTER();

       /*Klockwork_fix_2431_start*/
        rrm_decision_cell_stop_physical_layer_param(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/
   
       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_param_srs(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/
    
       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_param_prach(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/


       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_param_pucch(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/
   
       
       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_param_pusch(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/

     /*Klockwork_fix_2431_start*/
     rrm_decision_cell_stop_physical_layer_param_ul_ref_sig(p_cell_ctx, &stop_flag);
     /*Klockwork_fix_2431_end*/

       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_ran_param(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/


       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_rach_param(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/

       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_sib_2_param(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/
   
       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_phich(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/
       
       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_physical_layer_mac(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/

       /*Klockwork_fix_2431_start*/
       rrm_decision_cell_stop_operator_info(p_cell_ctx, &stop_flag);
       /*Klockwork_fix_2431_end*/

   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT))
   {
       if ((p_cell_ctx->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT) && 
               (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT))
       {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                       "PRS can be Reconfigured" );
       }
   }

#ifdef TDD_MODE_FLAG
   if ((p_cell_ctx->p_new_reconfig_data->bitmask & RRMCM_RMIF_RAN_INFO_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT) &&
       (p_cell_ctx->p_new_reconfig_data->ran_info.physical_layer_params.bitmask & 
             RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT))
   {
       if ( p_cell_ctx->ran_info.physical_layer_params.
               physical_layer_param_tdd_frame_structure.sub_frame_assignment !=
               p_cell_ctx->p_new_reconfig_data->ran_info.
               physical_layer_params.physical_layer_param_tdd_frame_structure.sub_frame_assignment)
       {
           stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   " Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.
                   physical_layer_param_tdd_frame_structure.sub_frame_assignment,
                   p_cell_ctx->p_new_reconfig_data->ran_info.
                   physical_layer_params.physical_layer_param_tdd_frame_structure.sub_frame_assignment);
       }
       if ( p_cell_ctx->ran_info.physical_layer_params.
               physical_layer_param_tdd_frame_structure.special_sub_frame_patterns !=
               p_cell_ctx->p_new_reconfig_data->ran_info.
               physical_layer_params.physical_layer_param_tdd_frame_structure.special_sub_frame_patterns)
       {
           stop_flag = RRM_TRUE;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   " Reconfigured Old = [%d], New = [%d]", 
                   p_cell_ctx->ran_info.physical_layer_params.
                   physical_layer_param_tdd_frame_structure.special_sub_frame_patterns,
                   p_cell_ctx->p_new_reconfig_data->ran_info.
                   physical_layer_params.physical_layer_param_tdd_frame_structure.special_sub_frame_patterns);
       }
   }
#endif   
    /* SPR 8597 Fix start: SPS toggling creating crash */
    if(p_cell_ctx->p_new_reconfig_data->cell_reconfig_sps_on != 
       p_cell_ctx->sps_on)
    {
        stop_flag = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "SPS feature Reconfigured: Old = [%d], New = [%d]", 
                   p_cell_ctx->sps_on, p_cell_ctx->p_new_reconfig_data->cell_reconfig_sps_on);
    }
    /* SPR 8597 Fix end : SPS toggling creating crash */

    /* SPR 11906 Fix start */
   
   /* SPR 11906 Fix start */
   /*SPR 21417 FIXED START */
    if (p_cell_ctx->p_new_reconfig_data->ran_info.bitmask & RRMCM_RMIF_ANTENNA_PORTS_COUNT_NO_PRESENT)
    {
  /*SPR 21417 FIXED END */

        if( p_cell_ctx->p_new_reconfig_data->ran_info.antenna_info.antenna_ports_count_number !=
                p_cell_ctx->ran_info.antenna_info.antenna_ports_count_number)
        {
            stop_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "antenna_ports_count_number Reconfigured Old = [%d], New = [%d]",
                    p_cell_ctx->ran_info.antenna_info.antenna_ports_count_number,
                    p_cell_ctx->p_new_reconfig_data->ran_info.antenna_info.antenna_ports_count_number);
        }
    }
    /* SPR 11906 Fix end */
    
 

   RRM_UT_TRACE_EXIT();
   
   return stop_flag;
}
/*Klockwork_fix_start*/
/******************************************************************
* Function Name  : rrm_decision_cell_delete_icic
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : cell need to be delte for reconfig request in FSM
*******************************************************************/
rrm_return_et
rrm_decision_cell_delete_icic(rrm_cell_context_t *p_cell_ctx)
{
    rrm_return_et ret_val = RRM_FAILURE;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
    RRM_UT_TRACE_ENTER();
    if (RRM_CELLM_REF_SIG_PWR_NOT_UPDATED == p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
    {
        generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
        generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
        generic_resp_to_mif.response = RRM_FAILURE;
        generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_F_inv_param);
#endif        

        ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                RRMCM_RMIF_CELL_RECONFIG_RESP);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "cellm_fsm_process_event:"  
                    "Failed to send generic response to MIF");
        }
    }
    /* BUG_876_CHANGES_END*/
    CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "CELL State is :%s[%d]",CELL_FSM_STATE[p_cell_ctx->cell_state],
            p_cell_ctx->cell_state);
     RRM_UT_TRACE_EXIT();
     return ret_val;
}
/*Klockwork_fix_end*/
/******************************************************************
* Function Name  : rrm_decision_cell_delete 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : cell need to be delte for reconfig request in FSM
*******************************************************************/
rrm_return_et
rrm_decision_cell_delete
(
  rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_FAILURE;
    /* BUG_371 FIX START */ 
    /* BUG_371 FIX END */ 

    RRM_UT_TRACE_ENTER();

    /* BUG_12416_FIX_START */
    if (RRM_FAILURE == rmcm_rmif_broadcast_cell_del_req(p_cell_ctx))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR," Failed to process cell delete in cell_reconfig api");
        ret_val = RRM_FAILURE;
    }
    else
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_cell_delete_req);
#endif        
        /* SPR 21251 +- */
        p_cell_ctx->cell_reconfig_deletion_required = RRM_TRUE;
        ret_val = RRM_SUCCESS;
    }
    /* BUG_12416_FIX_END */

    /* BUG_371 FIX START */ 
    /* BUG_371 FIX END */ 

    /* SRS End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Carrier_Aggregation_End */
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rmcm_mif_reconfig_req_ca_config
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_reconfig_req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_mif_reconfig_req_ca_config(rrm_cell_context_t              *p_cell_ctx ,
                                rrmcm_rmif_generic_resp_t       *generic_resp_to_mif ,
                                rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req ,
                                rrm_bool_t                      *is_ca_eligible_prev_config , 
                                rrm_error_et                    *fail_cause )
{
        /* SPR 14573 fix START  */
        rrm_return_et   ret_val                = RRM_SUCCESS;
        /* Validating ca reconfig params */
        if (RRM_FAILURE == (rrm_validate_ca_reconfig_params (&p_cell_ctx->operator_info,
                            &p_reconfig_req->operator_info.ca_config, p_cell_ctx->cell_index)))
        {
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                "Invalid params value recieved in cell reconfig cell_index = %d",
                 p_cell_ctx->cell_index); 
            ret_val = RRM_FAILURE;
            *fail_cause = RRM_ERR_INVALID_PARAMS;
        }
        *is_ca_eligible_prev_config = p_cell_ctx->operator_info.ca_config.is_ca_eligible;
        /* cov_65136 changes removed as code removed for checking TDD Mode */
        /* SPR 14573 fix END  */
        /*  CA config param validation is failed */
        if (RRM_FAILURE == ret_val)
        {
            generic_resp_to_mif->cellindex = p_cell_ctx->cell_index; 
            generic_resp_to_mif->transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif->response = RRM_FAILURE;
            generic_resp_to_mif->fail_cause = *fail_cause;
            ret_val = build_and_send_generic_resp_to_mif(generic_resp_to_mif, 
                    RRMCM_RMIF_CELL_RECONFIG_RESP);
            if(RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_BRIEF,"Config Response FAILURE Sent For Cell Index:%d", p_cell_ctx->cell_index);

            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to Send Config Resp FAILURE For Cell Index :%d", p_cell_ctx->cell_index);

            }
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_mif_reconfig_req_non_ca_config
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_reconfig_req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_mif_reconfig_req_non_ca_config(rrm_cell_context_t           *p_cell_ctx ,
                                    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req ,
                                    rrmcm_rmif_generic_resp_t    *generic_resp_to_mif )
{
	rrm_return_et ret_val = RRM_SUCCESS;
	RRM_UT_TRACE_ENTER();
	/* BUG_371 FIX START */
	if(RRM_FAILURE == ( ret_val = build_send_rrc_reconfig_req (p_cell_ctx, 
					p_cell_reconfig_req,
					CELL_RECONFIG_PROC)))
		/* BUG_371 FIX END */
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Failed To Send ReConfig Req To RRC For Cell Index:%d",
				p_cell_ctx->cell_index);
		generic_resp_to_mif->cellindex = p_cell_ctx->cell_index; 
		generic_resp_to_mif->transaction_id = p_cell_ctx->ongoing_trans_id;
		generic_resp_to_mif->response = RRM_FAILURE;
		generic_resp_to_mif->fail_cause = RRM_ERR_INVALID_PARAMS;
#ifdef RRM_UT_FLAG        
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_F);
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_F_inv_param);
#endif        

		ret_val = build_and_send_generic_resp_to_mif(generic_resp_to_mif, 
				RRMCM_RMIF_CELL_RECONFIG_RESP);
		if (RRM_FAILURE == ret_val)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
					"Failed to Sen Reconfig Generic Resp To MIF");
		}
		/*reconfig send fail cell state*/
		/*spr 21625 fix start*/
		/* Code removed */
		/*spr 21625 fix end*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"Cell Reconfig Failed for Cell Index:%d Cell State is:%s[%d]",
				p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
				p_cell_ctx->cell_state);

		ret_val = RRM_FAILURE;
	}
	/* BUG_371 FIX START */
	else if(RRM_PARTIAL_SUCCESS == ret_val )
	{
		/**13868_fix_start*/

		/* SPR 11937_11941 Fix start */
		commit_cell_reconfig_params(p_cell_ctx);
		/* SPR 11937_11941 Fix end */
		if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask != RRM_ZERO)
		{
			if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT)
			{   
				if( RRM_FAILURE == build_and_send_uem_eicic_provision_reconfig_req(p_cell_ctx))
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"Could not sent the eicic provision to uem");
					p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
				}
				else
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
							"Success returned during sending reconfig for eicic provision to uem ");
				}    
			}
			else   
			{
				if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT)
				{
					if(RRM_FAILURE == build_and_send_l2_cell_config_req_for_eicic_reconfig(&p_cell_ctx->rrm_eicic_cell_info.mac_config_data,
								p_cell_ctx->cell_index,
								p_cell_ctx->ongoing_trans_id))
					{
						/*SPR 14529 start*/
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
								"Failure returned during the processing of l2_cell_config_req");
						generic_resp_to_mif->cellindex = p_cell_ctx->cell_index;
						generic_resp_to_mif->transaction_id = p_cell_ctx->ongoing_trans_id;
						generic_resp_to_mif->response = RRM_FAILURE;
						generic_resp_to_mif->fail_cause = RRM_ERR_CELL_RECONFIG_ONGOING;
						ret_val = build_and_send_generic_resp_to_mif(generic_resp_to_mif,
								RRMCM_RMIF_CELL_RECONFIG_RESP);
						if (RRM_FAILURE == ret_val)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
									"Failed to Send Reconfig Generic Resp To MIF");
						}
						/*spr 21625 fix start*/
						/* Code removed */
						/*spr 21625 fix end*/
						if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
						{
							RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
							p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
						}
						p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
						p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask = RRM_ZERO;
						/*SPR 14529 end*/

					}
					else
					{  
						CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
								"Success returned during the processing of l2_cell_config_req");
					}
				}
			}
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
					"ReConfig Req To RRC For Cell Index:%d was not required.Send SUCCESS to MIF",
					p_cell_ctx->cell_index);

			if( p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_ABS_RECONFIG_INVALID_PARAM)
			{
				generic_resp_to_mif->cellindex = p_cell_ctx->cell_index; 
				generic_resp_to_mif->transaction_id = p_cell_ctx->ongoing_trans_id;
				generic_resp_to_mif->response = RRM_FAILURE;
				generic_resp_to_mif->fail_cause = RRM_ERR_INVALID_PARAMS;
			}
			else
			{
				generic_resp_to_mif->cellindex = p_cell_ctx->cell_index; 
				generic_resp_to_mif->transaction_id = p_cell_ctx->ongoing_trans_id;
				generic_resp_to_mif->response = RRM_SUCCESS;
				generic_resp_to_mif->fail_cause = RRM_NO_ERROR;
			}
			ret_val = build_and_send_generic_resp_to_mif(generic_resp_to_mif, 
					RRMCM_RMIF_CELL_RECONFIG_RESP);
			/*reconfig send fail cell state*/
			if (RRM_FAILURE == ret_val)
			{
				RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_ERROR,
						"Failed to Send Reconfig Generic Resp To MIF");
			}
			/*spr 21625 fix start*/
			/* Code removed */
			/*spr 21625 fix end*/
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
					"Cell Reconfig Successful for Cell Index:%d Cell State is:%s[%d]",
					p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
					p_cell_ctx->cell_state);
		}   
		ret_val = RRM_SUCCESS;
		/**13868_fix_end*/
	}
	/* BUG_371 FIX END */ 
	else
	{
#ifdef RRM_UT_FLAG        
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_reconfig_req);
#endif        
		/*spr 21625 fix start*/
		if(p_cell_ctx->cell_state == CELL_STATE_ALREADY_BLOCKED )
		{
			CELL_M_FSM_SET_STATE(p_cell_ctx,
					CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK);
		}
		/*spr 21625 fix end*/
		else
		{
			/*spr 21625 fix start*/
			/* Code removed */
			/*spr 21625 fix end*/
			/*spr 9631 fix start*/
			CELL_M_FSM_SET_STATE(p_cell_ctx,
					CELL_STATE_W_FOR_CELL_RECONFIG_RESP);

		}

		/*spr 9631 fix end*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"Cell ReConfig Send To RRC for Cell Index:%d Cell State is:%s[%d]",
				p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
				p_cell_ctx->cell_state);
		ret_val = RRM_SUCCESS;
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Klockwork_fix_end*/
/*SPR 14132 start*/
/****************************************************************************
 * Function Name  : rmcm_mif_compare_threshold_param_values
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context,
 *                  rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles range check in FSM
 ****************************************************************************/
rrm_return_et
rmcm_mif_compare_threshold_param_values
( rrm_cell_context_t               *p_cell_ctx,
  rrmcm_rmif_cell_reconfig_req_t   *p_reconfig_req
)
{
     U32             dl_sinr_threshold_low_mark;
     U32             dl_sinr_threshold_high_mark;
     U8              abs_usage_high_threshold;
     U8              abs_usage_low_threshold;
     rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
     rrm_return_et   ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if(RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT & p_reconfig_req->operator_info.eicic_info.bitmask)
    {
        dl_sinr_threshold_low_mark = p_reconfig_req->operator_info.eicic_info.dl_sinr_threshold_low_mark;   
    }
    else
    {
        dl_sinr_threshold_low_mark = p_cell_ctx->operator_info.eicic_info.dl_sinr_threshold_low_mark; 
    }    
    if(RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT & p_reconfig_req->operator_info.eicic_info.bitmask)
    {
        dl_sinr_threshold_high_mark = p_reconfig_req->operator_info.eicic_info.dl_sinr_threshold_high_mark;   
    }
    else
    {
        dl_sinr_threshold_high_mark = p_cell_ctx->operator_info.eicic_info.dl_sinr_threshold_high_mark; 
    }    
    if((RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.bitmask))
    {
        abs_usage_high_threshold = p_reconfig_req->operator_info.eicic_info.abs_info.abs_usage_high_threshold; 
    }
    else
    {
        abs_usage_high_threshold = p_cell_ctx->operator_info.eicic_info.abs_info.abs_usage_high_threshold; 
    }
    if((RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.bitmask))
    {
        abs_usage_low_threshold = p_reconfig_req->operator_info.eicic_info.abs_info.abs_usage_low_threshold;
    }    
    else
    {
        abs_usage_low_threshold = p_cell_ctx->operator_info.eicic_info.abs_info.abs_usage_low_threshold; 
    }    
    if( abs_usage_high_threshold <= abs_usage_low_threshold)
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_BRIEF,"abs_usage_high_threshold:%d", abs_usage_high_threshold);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                    RRM_BRIEF,"abs_usage_low_threshold:%d", abs_usage_low_threshold);
    }    
    if(dl_sinr_threshold_high_mark <= dl_sinr_threshold_low_mark)
    {
          ret_val = RRM_FAILURE;
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_BRIEF,"dl_sinr_threshold_high_mark:%d", dl_sinr_threshold_high_mark);
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                    RRM_BRIEF,"dl_sinr_threshold_low_mark:%d",dl_sinr_threshold_low_mark);
 

    }    

    if(RRM_FAILURE == ret_val)
    {
        generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
        generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
        generic_resp_to_mif.response = RRM_FAILURE;
        generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
        ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                RRMCM_RMIF_CELL_RECONFIG_RESP);
        if(RRM_SUCCESS == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"Config Response FAILURE Sent For Cell Index:%d", p_cell_ctx->cell_index);

        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to Send Config Resp FAILURE For Cell Index :%d", p_cell_ctx->cell_index);

        }
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    } 

    RRM_UT_TRACE_EXIT();
    return ret_val;
}    
/*SPR 14132 end*/
/****************************************************************************
 * Function Name  : rmcm_mif_reconfig_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_reconfig_req in FSM
 ****************************************************************************/
rrm_return_et 
rmcm_mif_reconfig_req
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req = RRM_PNULL;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
    /* Carrier_Aggregation_Start */
    rrm_bool_et         is_reconfig_req_for_ca_params = RRM_FALSE;
    rrm_bool_et         recnf_req_for_mac_sch_params  = RRM_FALSE;
    rrm_error_et        fail_cause                    = RRM_NO_ERROR; 
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
#ifdef TDD_MODE_FLAG    
    rrm_return_et eicic_ret_val  = RRM_SUCCESS;
#endif    
    /*EICIC_TDD_CHANGES_END*/
    /* Carrier_Aggregation_End */
    rrm_bool_t          is_ca_eligible_prev_config = RRM_FALSE;
    U8                  index = RRM_ZERO;
    /** eICIC_PHASE_1_2_CHANGES_START*/
    rrm_bool_t          x2_up_vd_neigh          = RRM_FALSE;
    /** eICIC_PHASE_1_2_CHANGES_END */
    /*SPR 14399 start*/
    cell_timer_buf_t  timer_buf;
    /*SPR 14399 end*/
#ifdef LTE_EMBMS_SUPPORTED
    U8 embms_reconfig                                          = RRM_ZERO;
    U8 si_offset[MAX_SI_MESSAGE]                               = {RRM_ZERO};
    static rrm_embms_sf_info_t  embms_scheduling_data[RRM_MAX_SF_VALUE] = 
                                                                {{RRM_ZERO}};
    rrmcm_mbsfn_config_info_t *p_mbsfn_subframe_config_info    = RRM_PNULL;
    rrmcm_mbsfn_subframe_config_list_t *p_mbsfn_sf_config_list = RRM_PNULL;
    rrm_rf_list_t                 rf_list                      = {RRM_ZERO}; 
    rrm_embms_mcch_mtch_list mcch_mtch_list                    = {RRM_ZERO};
    U8  reconfig_required                                      = RRM_ZERO;
    /*SPR 18089:start*/
    U8  trigger_resceduler_req_to_mac                          = RRM_ZERO;
    /*SPR 18089:end*/
#endif

    /* SPR 21412 Cell Reconfig Fix Start */
    /* SPR 21412 Cell Reconfig Fix End */

    RRM_UT_TRACE_ENTER();

    p_reconfig_req = (rrmcm_rmif_cell_reconfig_req_t *)
        (p_cell_ctx->p_incoming_api_info); 

    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = RRM_MAX_PATTERN_BYTE;
#endif
    /*EICIC_TDD_CHANGES_END*/
    /*SPR 14132 start*/

    if (RRMCM_RMIF_EICIC_INFO_PRESENT & p_reconfig_req->operator_info.bitmask)
    {    
        if((RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT & p_reconfig_req->operator_info.eicic_info.bitmask)|| 
                (RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT & p_reconfig_req->operator_info.eicic_info.bitmask)|| 
                (p_reconfig_req->operator_info.eicic_info.abs_info.bitmask & RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT) ||
                (p_reconfig_req->operator_info.eicic_info.abs_info.bitmask & RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT))
        {
            if(RRM_FAILURE == rmcm_mif_compare_threshold_param_values(p_cell_ctx,p_reconfig_req)) 
            {
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }    
        }
    } 
    /*EICIC_TDD_CHANGES_START*/    
    /*Review comments changes start*/
    if ((RRMCM_RMIF_OPERATOR_INFO_PRESENT & p_reconfig_req->bitmask) &&
            (RRMCM_RMIF_EICIC_INFO_PRESENT & p_reconfig_req->operator_info.bitmask))
    {
        if((RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT & p_reconfig_req->operator_info.eicic_info.bitmask)&&
                (p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR_AND_VICTIM))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR,"Reconfig Failed as RRM_OAM_ACT_AS_AGGRESSOR_AND_VICTIM provision type is not supported in this release");

            generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
            generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                    RRMCM_RMIF_CELL_RECONFIG_RESP);
            if(RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_BRIEF,"Reconfig Response FAILURE Sent For Cell Index:%d", p_cell_ctx->cell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to Send Reconfig Resp FAILURE For Cell Index :%d", p_cell_ctx->cell_index);
            }
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }    
    }    
    /*Review comments changes end*/
/* + SPR 17665 + */

     ret_val = validation_mac_reconfig_req(p_reconfig_req, p_cell_ctx);

      if(ret_val == RRM_FAILURE)
      {
          generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
          generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
          generic_resp_to_mif.response = RRM_FAILURE;
          generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
          ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                  RRMCM_RMIF_CELL_RECONFIG_RESP);
          if(RRM_SUCCESS == ret_val)
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                      RRM_WARNING,"Reconfig Response FAILURE Sent For Cell Index:%d", p_cell_ctx->cell_index);
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "Failed to Send Reconfig Resp FAILURE For Cell Index :%d", p_cell_ctx->cell_index);
          }
          RRM_UT_TRACE_EXIT();
          return RRM_FAILURE;
      } 
        

/* - SPR 17665 - */
#ifdef TDD_MODE_FLAG  
    /*SPR 14889 start*/
    if((RRMCM_RMIF_RAN_INFO_PRESENT & p_reconfig_req->bitmask)&&
            (RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT & p_reconfig_req->ran_info.bitmask )&&
            (RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT & p_reconfig_req->ran_info.physical_layer_params.bitmask))
    {
        if((RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask)&&
                (RRMCM_RMIF_ABS_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                (RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.bitmask)&&
                (p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type != RRM_OAM_EICIC_DEACTIVATED))
        {
            eicic_ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    " Reconfiguration of TDD config not allowed since eICIC is activated and patterns are configured.")
        }
    }
    /*SPR 14889 end*/
    if((RRMCM_RMIF_EICIC_INFO_PRESENT & p_reconfig_req->operator_info.bitmask)&& 
            (RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
            (RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask))
    {
        if(RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
        {
            if(RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,abs_size))
            {
                eicic_ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
            }    
        }
        if(RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
        {
            if(RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,abs_size))
            {
                eicic_ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
            }    
        }
        if(RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
        {
            if(RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,abs_size))
            {
                eicic_ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
            }    
        }    

        if(RRM_FAILURE == eicic_ret_val)
        {
            generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
            generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                    RRMCM_RMIF_CELL_RECONFIG_RESP);
            if(RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_BRIEF,"Config Response FAILURE Sent For Cell Index:%d", p_cell_ctx->cell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to Send Config Resp FAILURE For Cell Index :%d", p_cell_ctx->cell_index);
            }
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }    
    }
#endif    
    /*EICIC_TDD_CHANGES_END*/    
    /*SPR 14132 end*/

#ifdef LTE_EMBMS_SUPPORTED
    /*
     * If SIB2 is reconfgured by Operator*/

    rrm_trace_cell_embms_data(&(p_cell_ctx->rrm_cell_embms_data));

    if (((RRMCM_RMIF_RAN_INFO_PRESENT & p_reconfig_req->bitmask) &&
                (RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT & p_reconfig_req->ran_info.bitmask)) &&
            (RRMCM_RMIF_MBSFN_CONFIGURATION_INFO_PRESENT & p_reconfig_req->ran_info.
             physical_layer_params.bitmask ))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "Checking sf_alloc info is NULL or NOT for "
                "reconfigured MBSFN info in SIB2");

        p_mbsfn_sf_config_list  = 
            &(p_reconfig_req->ran_info.physical_layer_params.
                    physical_layer_param_mbsfn_config_info);

        if (RRM_TRUE == rrm_check_sf_alloc_is_null(p_mbsfn_sf_config_list))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "Reconfigured MBSFN info is NULL, So, sending failure to OAM");
            fail_cause = RRM_ERR_INVALID_PARAMS; 
            ret_val = RRM_FAILURE;
            reconfig_required = RRM_ZERO;
        }
        else
        {
            /** 1.If SIB 2 is not on broadcast, then RRM will store the contents
             *    of MBSFN info in cell context.
             *  2. If SIB 2 is already on broadcast in the system, then RRM will 
             *     a) Align received info with SI scheduling algorithm
             *     b) Calculate neigh_cell_config IE to be broadcsated
             *     c) If neigh_cell_config IE gets updated, changed then it is 
             *        broadcasted in SIB 3 
             *     d) else RRM will not Broadcast neigh_cell_config IE 
             *     e) RRM will send this MBSFN info to SON in SF_INFO_IND after
             *        successfull rrc reconfig resp
             **/
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "Reconfigured MBSFN info is not NULL ");
            if(( MBMS_SIB_2_ON_BROADCAST & 
                 p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast) ||
               ( MBMS_SIB_13_ON_BROADCAST & 
                 p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast))
            {
                p_cell_ctx->rrm_cell_embms_data.embms_sf_reserved_list = RRM_ZERO;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "current_sib_on_broadcast: %d ",
                    p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast);

                for(index = RRM_ZERO; 
                        (index < p_mbsfn_sf_config_list->count) && 
                        (index < RRM_MAX_MBSFN_ALLOCATIONS); index++)
                {
                    p_mbsfn_subframe_config_info = 
                        &(p_mbsfn_sf_config_list->
                                mbsfn_subframe_config_info[index]);

                    rrm_get_valid_sf_list( p_mbsfn_subframe_config_info->
                            subframe_allocation.sf_alloc_choice,
                            p_mbsfn_subframe_config_info->subframe_allocation.
                            subframe_allocation,
                            &rf_list); 
                    /*Prepare INPUT for marking the MBMS frames as BUSY*/	
                    rrm_prepares_input_data_for_algo( 
                            p_mbsfn_subframe_config_info->
                            radio_frame_allocation_period,
                            p_mbsfn_subframe_config_info->
                            radio_frame_allocation_offset,
                            rf_list,
                            &mcch_mtch_list
                            ); 
                }

                /* Function written for UT purposes*/
                //rrm_print_mcch_mtch_list(&mcch_mtch_list);
                rrm_fills_embms_info_from_rf_list(embms_scheduling_data,
                        &mcch_mtch_list);

                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "SIB2/SIB13 is on Broadcast So, aligning reconfigured MBSFN info"
                        "with SI scheduling and calculating neigh_cell_config info");

                
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                        RRM_DETAILED,
                        "RRM detecting MBMS collision with SI");
                ret_val = rrm_detect_mbms_collision_with_si( p_cell_ctx, 
                        embms_scheduling_data, si_offset);
                if (RRM_FAILURE != ret_val)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_DETAILED, "MBSFN is collision free with SI");
                    /*Prepares SF_RESERVED_LIST */
                    rrm_prepares_embms_list_of_reserved_sf(&mcch_mtch_list,
                            &p_cell_ctx->rrm_cell_embms_data.
                            embms_sf_reserved_list); 
                    p_cell_ctx->rrm_cell_embms_data.
                        align_drx_cqi |= MBMS_ALIGN_DRX_CQI_PRESENT;
                    p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status |= 
                        MBMS_SIB_2_SCHEDULE_BROADCAST;
                    p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status |= 
                        MBMS_SEND_ECU_IND_TO_SON;
                    p_cell_ctx->rrm_cell_embms_data.bitmask |= 
                        RRMCM_OPERATOR_RECONFIG_SIB_2_PRESENT ;

                    rrm_cal_inter_intra_neigh_config(
                            &(p_cell_ctx->rrm_cell_embms_data),
                            &mcch_mtch_list, 
                            &(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params),
                            &(p_cell_ctx->ran_info.ncl_params.lte_ncl));

                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                            "SI is Successfully aligned with reconfigured MBSFN info");
                    reconfig_required = RRM_ONE;
                    ret_val = RRM_SUCCESS;

                    /*SPR 18435:Fix Start*/
                    if(RRM_FALSE == rrm_compare_si_offset_with_configured_offsets(si_offset,
                                p_cell_ctx->rrm_cell_embms_data.si_start_offset))
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                                "returned false from rrm_compare_si_offset_with_configured_offsets");

                    }
                    else
                    {

                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                                "Storing calculated si_start_offsets to embms context");
                        p_cell_ctx->rrm_cell_embms_data.
                            mbms_broadcast_status |= MBMS_SIB_1_SCHEDULE_BROADCAST;
                        RRM_MEMCPY(
                                p_cell_ctx->rrm_cell_embms_data.si_start_offset,
                                si_offset,
                                (MAX_SI_MESSAGE)*(sizeof(U8)));
                    }
                    /*SPR 18435:Fix End*/
                }
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "SI is NOt ALigned with  Reconfgured MBSFN info");
                    fail_cause = RRM_ERR_INVALID_PARAMS;
                    reconfig_required = RRM_ZERO;
                    ret_val = RRM_FAILURE;
                }

            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                        "Storing SIB2 in cell context for cell[%d] as SIB_2 is not on BROADCAST", 
                        p_cell_ctx->cell_index);
                /*Store content in Cell Context*/
                p_cell_ctx->ran_info.physical_layer_params.bitmask |= 
                    RRMCM_RMIF_MBSFN_CONFIGURATION_INFO_PRESENT;

                p_cell_ctx->rrm_cell_embms_data.
                    is_sib2_operator_configured = RRM_ONE;

                RRM_MEMCPY(&p_cell_ctx->ran_info.physical_layer_params.
                        physical_layer_param_mbsfn_config_info,
                        &p_reconfig_req->ran_info.physical_layer_params.
                        physical_layer_param_mbsfn_config_info,
                        sizeof(mbsfn_subframe_config_list_t) ); 

                ret_val = RRM_SUCCESS;

            }

        }
        rrm_trace_cell_embms_data(&(p_cell_ctx->rrm_cell_embms_data));
        embms_reconfig = RRM_ONE;
    }

    if (RRM_FAILURE != ret_val)
    {
        if ((RRMCM_RMIF_OPERATOR_INFO_PRESENT & p_reconfig_req->bitmask))
        {
/* SPR 18334 : START */
/*deleted*/
/* SPR 18334 : END */
            if (RRMCM_RMIF_MBMS_POWER_INFO_PRESENT &
                    p_reconfig_req->operator_info.bitmask)
            {
                /*SPR 18089:start*/
                if (MBMS_SIB_13_ON_BROADCAST &
                        p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast)
                {
                    if (p_cell_ctx->operator_info.mbms_power_info.cell_pwer_offset !=
                            p_reconfig_req->operator_info.mbms_power_info.cell_pwer_offset)
                    {
                        trigger_resceduler_req_to_mac = RRM_ONE;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                                "Triggering rescheduler req to MAC for cell [%d] "
                                "cell_pwer_offset[%d]",
                                p_cell_ctx->cell_index,
                                p_reconfig_req->operator_info.mbms_power_info.cell_pwer_offset);
                        p_cell_ctx->rrm_cell_embms_data.bitmask |= 
                            RRMCM_RECONFIG_EMBMS_POWER_OFFSET_PRESENT;

                        p_cell_ctx->operator_info.mbms_power_info.cell_pwer_offset =
                            p_reconfig_req->operator_info.mbms_power_info.cell_pwer_offset;

                        p_cell_ctx->operator_info.bitmask |=RRMCM_RMIF_MBMS_POWER_INFO_PRESENT;
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                                "cell_pwer_offset[%d] is not changed in CELL RECONFIG",
                                p_cell_ctx->operator_info.mbms_power_info.cell_pwer_offset);
                    }
                    if(p_cell_ctx->operator_info.mbms_power_info.transmission_power !=
                            p_reconfig_req->operator_info.mbms_power_info.transmission_power)
                    {
                        reconfig_required = RRM_ONE;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                                "Triggering CELL RECONFIG REQ to RRC for cell [%d] "
                                "transmission_power [%d]",
                                p_cell_ctx->cell_index,
                                p_reconfig_req->operator_info.mbms_power_info.transmission_power);
                        p_cell_ctx->rrm_cell_embms_data.bitmask |= 
                            RRMCM_RECONFIG_EMBMS_POWER_OFFSET_PRESENT;

                        /* SPR 18435: Fix Start*/
                        RRM_MEMCPY(&si_offset,p_cell_ctx->rrm_cell_embms_data.si_start_offset,
                                   (MAX_SI_MESSAGE)*(sizeof(U8)));
                        /* SPR 18435: Fix End*/

                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                                "transmission_power[%d] is not changed in CELL RECONFIG",
                                p_cell_ctx->operator_info.mbms_power_info.transmission_power);
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                            "Storing reconfigured MBMS Power Offsets for cell [%d]",
                            p_cell_ctx->cell_index);
                    /*Store content in CELL_CONTEXT and setting its bitmask*/
                    p_cell_ctx->operator_info.bitmask |=
                        RRMCM_RMIF_MBMS_POWER_INFO_PRESENT;
                    p_cell_ctx->operator_info.mbms_power_info.cell_pwer_offset =
                        p_reconfig_req->operator_info.mbms_power_info.cell_pwer_offset;
                    p_cell_ctx->operator_info.mbms_power_info.transmission_power =
                        p_reconfig_req->operator_info.mbms_power_info.
                        transmission_power;

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                            "cell_pwer_offset[%d], transmission_power[%d]",
                            p_cell_ctx->operator_info.mbms_power_info.cell_pwer_offset,
                            p_cell_ctx->operator_info.mbms_power_info.transmission_power);
                    ret_val = RRM_SUCCESS;
                }
                embms_reconfig = RRM_ONE;
            }
                /*SPR 18089:end*/
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "RECONFIG FAILED as sf_alloc is NULL");
    }
 
     /*
     * If SIB 13 or SIB 2 were on BROADCAST 
     * and Reconfig Req of either of SIB13 or MBSFN info in SIB2 are received 
     * then, need to Trigger req to L3 */

    if (embms_reconfig == RRM_ONE)
    {
        if ((RRM_ONE == reconfig_required))
        {
            p_cell_ctx->p_new_reconfig_data = rrm_mem_get(sizeof 
                    (rrmcm_rmif_cell_reconfig_req_t)); 
            if(p_cell_ctx->p_new_reconfig_data != RRM_PNULL)
            {
                RRM_MEMSET(p_cell_ctx->p_new_reconfig_data,RRM_ZERO,
                        sizeof(rrmcm_rmif_cell_reconfig_req_t));
                RRM_MEMCPY(p_cell_ctx->p_new_reconfig_data,
                        p_reconfig_req,
                        sizeof(rrmcm_rmif_cell_reconfig_req_t));
            }
            /* CID 30594:start*/
            if (RRM_PNULL == p_cell_ctx->p_new_reconfig_data)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Memory allocation to p_new_reconfig_data failed" );
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
            /* CID 30594:end*/

            p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
            if (p_cell_reconfig_req == RRM_PNULL)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Memory allocation to p_cell_reconfig_req failed" );
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }

            /* CID 97684:start */
            RRM_MEMSET(p_cell_reconfig_req, RRM_ZERO, sizeof(rrc_rrm_cell_reconfig_req_t));
            /* CID 97684:end */
            /*build and send reconfig resp to L3*/
            if ((MBMS_SIB_13_SCHEDULE_BROADCAST & 
                        p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status) &&
                    (!(MBMS_SIB_2_SCHEDULE_BROADCAST & p_cell_ctx->rrm_cell_embms_data.
                       mbms_broadcast_status))) 
            {
                ret_val = build_send_rrc_reconfig_req_for_mbms(p_cell_ctx,
                        p_cell_reconfig_req, p_cell_ctx->rrm_cell_embms_data.
                        si_start_offset
                        );
            }
            else
            {
                ret_val = build_send_rrc_reconfig_req_for_mbms(
                        p_cell_ctx,p_cell_reconfig_req,
                        si_offset);
            }
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to send Reconfig Req to RRC");
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Successfully send Reconfig Req to RRC");
                p_cell_ctx->rrm_cell_embms_data.m2ap_mbsfn_resp.m2ap_resp_status = 
                    RRMCM_CELL_RECONFIG_REQ_SEND;
                CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_MBMS);
            }
            RRM_MEM_FREE(p_cell_reconfig_req);
            RRM_UT_TRACE_EXIT();
            return ret_val; 
        }
        else
        {
                /*SPR 18089:start*/
            if (RRM_ONE == trigger_resceduler_req_to_mac )
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rrm_l2_build_send_reconfig_schedule_params ");
                rrm_l2_build_send_reconfig_schedule_params(p_cell_ctx);
                
                /*SPR 18468: Fix Start*/
                p_cell_ctx->rrm_cell_embms_data.bitmask = RRM_ZERO;
                /*SPR 18468: Fix End*/
            }
                /*SPR 18089:end*/
            if (RRM_ONE == trigger_resceduler_req_to_mac )

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "No Need to send Reconfig Req to Lower Layers for MBMS "
                    "Sending Reconfig RESP to OAM");

            /*Send OAM_RECONFIG_RESP to MIF*/
            generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
            generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif.response = ret_val;
            generic_resp_to_mif.fail_cause = fail_cause;
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                    RRMCM_RMIF_CELL_RECONFIG_RESP);
            if(RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_DETAILED,"Sending Reconfig Response to MIF"
                        "For Cell Index:%d", p_cell_ctx->cell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed to Reconfig eMBMS Params For Cell Index :%d", 
                        p_cell_ctx->cell_index);
            }
            RRM_UT_TRACE_EXIT();
            return ret_val; 
        }
    }

#endif
    /* Carrier_Aggregation_Start */
    if ((RRMCM_RMIF_OPERATOR_INFO_PRESENT & p_reconfig_req->bitmask) &&
            (RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_reconfig_req->operator_info.bitmask))
    {
        /*Klockwork_fix_start*/
        ret_val = rmcm_mif_reconfig_req_ca_config(p_cell_ctx ,&generic_resp_to_mif ,
                p_reconfig_req,&is_ca_eligible_prev_config ,&fail_cause); 
        if(ret_val == RRM_FAILURE)
        {
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /*Klockwork_fix_end*/
    }
    /* Checking whether cell reconfig request is only for CA parameters on not */
    /**13862_fix_start*/ 
    if (RRMCM_RMIF_OPERATOR_INFO_PRESENT & p_reconfig_req->bitmask)
        /**13862_fix_end*/    
    {   
        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask       = 0x00;
        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = 0x00;

        /** eICIC_PHASE_1_2_CHANGES_START*/
        /* SPR 14342 start */
        if (RRMCM_RMIF_EICIC_INFO_PRESENT & p_reconfig_req->operator_info.bitmask)  
            /* SPR 14342 end */
        {
            /* SPR14157start */
            x2_up_vd_neigh = rrm_check_for_x2_link_status(p_cell_ctx);
            /* SPR14157end*/

            if( ( p_reconfig_req->operator_info.eicic_info.bitmask & RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT ) && 
                    ( p_reconfig_req->operator_info.eicic_info.eicic_timer_info.bitmask & RRMCM_RMIF_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT))
            {
                p_cell_ctx->rrm_eicic_cell_info.mac_config_data.mac_eicic_meas_report_periodicity = p_reconfig_req->operator_info.eicic_info.eicic_timer_info.mac_eicic_meas_report_periodicity; 
                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_REQUIRED_PER_RECONFIG_TO_MAC_PRESENT; 
                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;

            }    

            if (RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT & p_reconfig_req->operator_info.eicic_info.bitmask)
            {
                /**13867_fix_start*/
                //code_deleted 
                /**13867_fix_end*/
                if( ( p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR) &&
                        ( p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type != RRM_OAM_ACT_AS_AGGRESSOR ))
                { 
                    /*
                     ** To indicate that MAC_CELL_CONFIG_REQ will be triggered as a part of Cell Reconfig 
                     */
                    switch( p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type )
                    {
                        case RRM_OAM_ACT_AS_VICTIM :
                            {
                                RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                        RRM_ZERO,
                                        RRM_MAX_PATTERN_BYTE);
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                {    
                                    if(RRM_FALSE == x2_up_vd_neigh )
                                    {  

                                        /*eicic_subset_pattern_fix_start*/
                                        if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                                ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                                                ( RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask))
                                        {
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;
                                            RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, p_reconfig_req->operator_info.eicic_info.
                                                    abs_info.abs_pattern.victim_meas_subset,RRM_MAX_PATTERN_BYTE);
                                        }
                                        /*eicic_subset_pattern_fix_end*/
                                        if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                                ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                                                ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask )
                                          )

                                        {
                                            RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                                    p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                                    RRM_MAX_PATTERN_BYTE);
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                            /**13956_fix_start*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_LOW_LOAD_ABS_PRESENT;
                                            /**13956_fix_end*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                        }
                                        else if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                                                ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.bitmask ) &&
                                                ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask )
                                               )

                                        {
                                            RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                                    p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                                    RRM_MAX_PATTERN_BYTE);
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;

                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                                    " eICIC abs pattern is not present neither in  cell_cntxt nor in reconfig for provision type (%d). ",
                                                    p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                            /*SPR 15211 start*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                            /*SPR 15211 end*/
                                        }    
                                    }
                                    else
                                    {

                                        /*eicic_subset_pattern_fix_start*/
                                        if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                                ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                                                ( RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask))
                                        {
                                            RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,
                                                    RRM_ZERO,
                                                    RRM_MAX_PATTERN_BYTE);
                                            rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                                                    p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset, 
                                                    p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset); 
                                        }
                                        /*eicic_subset_pattern_fix_end*/

                                        RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                RRM_ZERO,
                                                RRM_MAX_PATTERN_BYTE);
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;

                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                    }
                                }
                                break;
                            }
                        case RRM_OAM_EICIC_DEACTIVATED :
                            {
                                RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                        RRM_ZERO,
                                        RRM_MAX_PATTERN_BYTE);

                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;

                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                break;
                            }
                        default:
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                        " Invalid eICIC provision type (%d). Cant't configure eICIC data ",
                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                /*SPR 15211 start*/
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                /*SPR 15211 end*/
                            }
                    }
                }
                else if(( p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_EICIC_DEACTIVATED ) &&
                        ( p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type != RRM_OAM_EICIC_DEACTIVATED ))
                {
                    switch( p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type)
                    {
                        /*
                         ** To indicate that MAC_CELL_CONFIG_REQ will be triggered as a part of Cell Reconfig 
                         */
                        case RRM_OAM_ACT_AS_AGGRESSOR:

                            if( RRM_FALSE == x2_up_vd_neigh )  
                            {  
                                /**13960_fix_start*/      
                                switch(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl)
                                {
                                    case RRM_LOW :
                                        {
                                            if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                                    ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask  ) &&
                                                    ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.
                                                      abs_pattern.bitmask ))
                                            {
                                                RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                        p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                                        RRM_MAX_PATTERN_BYTE);
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                                /**13894_fix_start*/
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_LOW_LOAD_ABS_PRESENT;
                                                /**13894_fix_end*/
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                            }
                                            else if(( RRMCM_RMIF_ABS_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                                                    ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.bitmask  ) &&
                                                    ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask  ))

                                            {
                                                RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                                        RRM_MAX_PATTERN_BYTE);
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;

                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                        " eICIC abs pattern is not present neither in  cell_cntxt nor in reconfig for provision type (%d). ",
                                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                                /*SPR 15211 start*/
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                                /*SPR 15211 end*/
                                            }    
                                        }     
                                        break;

                                    case RRM_MEDIUM :

                                        if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->cell_load_action.
                                                    u.comp_load_info.mid_load.eicic_load_config.abs_pattern))
                                        {
                                            RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,
                                                    RRM_MAX_PATTERN_BYTE);
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                    " eICIC abs pattern is no present in mid load for provision type (%d). ",
                                                    p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);

                                            /*SPR 15211 start*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM; 
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                            /*SPR 15211 end*/
                                        }  
                                        break;
                                    case RRM_HIGH :

                                        if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->cell_load_action.
                                                    u.comp_load_info.high_load.eicic_load_config.abs_pattern))
                                        {
                                            RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,
                                                    RRM_MAX_PATTERN_BYTE);
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                    " eICIC abs pattern is no present in high load for provision type (%d). ",
                                                    p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);

                                            /*SPR 15211 start*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                            /*SPR 15211 end*/
                                        }  

                                        break ;
                                    case RRM_OVERLOAD :

                                        if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->cell_load_action.
                                                    u.comp_load_info.over_load.eicic_load_config.abs_pattern))

                                        {
                                            RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,
                                                    RRM_MAX_PATTERN_BYTE);
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                    " eICIC abs pattern is no present in over load for provision type (%d). ",
                                                    p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                            /*SPR 15211 start*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM; 
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                            /*SPR 15211 end*/
                                        }  
                                        break;
                                    default :     
                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                " system is in invalid load[%d] for provision type (%d) ",
                                                p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl,
                                                p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                        break;
                                } 
                                /**13960_fix_end*/ 

                            }
                            /**13867_fix_start*/ 
                            else
                            {
                                p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type = 
                                    p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type;
                                /*SPR 14131 start*/
                                if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB) 
                                {    
                                    rrm_send_enable_disable_ind_to_son(p_cell_ctx);
                                }
                                /*SPR 14131 end*/
                            }	
                            /**13867_fix_start*/

                            break ;         
                        case RRM_OAM_ACT_AS_VICTIM:
                            {
                                if( RRM_FALSE == x2_up_vd_neigh )  
                                {
                                    /*eicic_subset_pattern_fix_start*/
                                    if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                                            ( RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask))
                                    {
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;
                                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, p_reconfig_req->operator_info.eicic_info.abs_info.
                                                abs_pattern.victim_meas_subset,RRM_MAX_PATTERN_BYTE);
                                    }
                                    /*eicic_subset_pattern_fix_end*/
                                    if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask  ) &&
                                            ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask  ))
                                    {
                                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                                RRM_MAX_PATTERN_BYTE);
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                                        /**13867_fix_start*/
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT;
                                        /**13867_fix_end*/

                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                    }
                                    else if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                                            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.abs_info.bitmask  ) &&
                                            ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask  ))
                                    {
                                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                                RRM_MAX_PATTERN_BYTE);
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;

                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                " eICIC abs pattern is not present neither in  cell_cntxt nor in reconfig for provision type (%d). ",
                                                p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                        /*SPR 15211 start*/
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                        /*SPR 15211 end*/
                                    }  
                                } 
                                else
                                {    
                                    /*eicic_subset_pattern_fix_start*/
                                    if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                                            ( RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask))
                                    {
                                        /*SPR 15211 start*/
                                        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                                        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                                        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT;
                                        /*SPR 15211 end*/
                                        RRM_MEMSET( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,
                                                RRM_ZERO,
                                                RRM_MAX_PATTERN_BYTE);
                                        rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset, 
                                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset);
                                    }
                                    /*eicic_subset_pattern_fix_end*/
                                    /**13867_fix_start*/ 
                                    p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type = 
                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type;
                                    /**13867_fix_end*/
                                    /*SPR 14810 start*/
                                    /*SPR 21081 Fix Start*/
                                    if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
                                    {
                                        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                                            eicic_timer_info.aggressor_sel_timer;
                                        /*SPR 14810 stop*/
                                        /*SPR 14399 start*/
                                        /*CID:71446 start*/
                                        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                    " CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL starts ");
                                            cell_stop_timer (p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer);
                                            timer_buf.cell_index = p_cell_ctx->cell_index;
                                            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
                                            p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer
                                                =
                                                cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                                                        (rrm_void_t *)&timer_buf,
                                                        sizeof(cell_timer_buf_t),
                                                        p_cell_ctx);
                                        }
                                        /*SPR 14399 end*/
                                    }
                                    /*SPR 21081 Fix Stop*/
                                    /*SPR 14131 start*/
                                    if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB) 
                                    {    
                                        rrm_send_enable_disable_ind_to_son(p_cell_ctx);
                                    }
                                    /*SPR 14131 end*/
                                    /*CID:71446 end*/
                                }
                            }
                            break ;
                        default:
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                        " Invalid eICIC provision type (%d). Cant't configure eICIC data ",
                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                            }
                    }

                }
                else if( ( p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM ) && 
                        ( p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type != RRM_OAM_ACT_AS_VICTIM ))
                {

                    /*
                     ** To indicate that first a req to UEM will be triggered as a part of Cell Reconfig 
                     */
                    switch( p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type)
                    {
                        case RRM_OAM_EICIC_DEACTIVATED:
                            {
                            /*SPR 21234 Fix Start*/
                            /*RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                        RRM_ZERO,
                                    RRM_MAX_PATTERN_BYTE);*/
                            /*SPR 21234 Fix Stop*/
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                            /*SPR 21234 Fix Start*/
                            //p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                            /*SPR 21234 Fix Stop*/
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;
                                break;
                            }
                        case RRM_OAM_ACT_AS_AGGRESSOR:
                            { 
                                RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                        RRM_ZERO,
                                        RRM_MAX_PATTERN_BYTE);

                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;
                                /**13960_fix_start*/ 
                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                if( RRM_FALSE == x2_up_vd_neigh )  
                                {        
                                    switch(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl)
                                    {
                                        case RRM_LOW :
                                            {
                                                if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                                                        ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask  ) &&
                                                        ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.
                                                          abs_pattern.bitmask ))
                                                {
                                                    RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                            p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                                            RRM_MAX_PATTERN_BYTE);
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                                    /**13867_fix_start*/  
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_LOW_LOAD_ABS_PRESENT;
                                                    /**13867_fix_end*/
                                                }
                                                else if(( RRMCM_RMIF_ABS_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                                                        ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.bitmask  ) &&
                                                        ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask  ))

                                                {
                                                    RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                            p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                                            RRM_MAX_PATTERN_BYTE);
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;

                                                }
                                                else
                                                {
                                                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                            " eICIC abs pattern is not present neither in  cell_cntxt nor in reconfig for provision type (%d). ",
                                                            p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                                    /*SPR 15211 start*/
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                                    p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                                    /*SPR 15211 end*/
                                                }    
                                            }     
                                            break;

                                        case RRM_MEDIUM :

                                            if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->cell_load_action.
                                                        u.comp_load_info.mid_load.eicic_load_config.abs_pattern))
                                            {
                                                RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                        p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,
                                                        RRM_MAX_PATTERN_BYTE);
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                        " eICIC abs pattern is no present in mid load for provision type (%d). ",
                                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);

                                                /*SPR 15211 start*/
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                                /*SPR 15211 end*/
                                            }  
                                            break;
                                        case RRM_HIGH :

                                            if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->cell_load_action.
                                                        u.comp_load_info.high_load.eicic_load_config.abs_pattern))
                                            {
                                                RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                        p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,
                                                        RRM_MAX_PATTERN_BYTE);
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                        " eICIC abs pattern is no present in high load for provision type (%d). ",
                                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);

                                                /*SPR 15211 start*/
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                                /*SPR 15211 end*/
                                            }  

                                            break ;
                                        case RRM_OVERLOAD :

                                            if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->cell_load_action.
                                                        u.comp_load_info.over_load.eicic_load_config.abs_pattern))

                                            {
                                                RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                                        p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,
                                                        RRM_MAX_PATTERN_BYTE);
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                        " eICIC abs pattern is no present in over load for provision type (%d). ",
                                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                                /*SPR 15211 start*/
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                                /*SPR 15211 end*/
                                            }  
                                            break;
                                        default :     
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                    " system is in invalid load[%d] for provision type (%d) ",
                                                    p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl,
                                                    p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                                            /*SPR 15211 start*/
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_INVALID_PARAM;
                                            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                                            /*SPR 15211 end*/
                                            break;
                                    }
                                    /**13960_fix_end*/ 
                                }
                            }   
                            break;

                        default:
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                        " Invalid eICIC provision type (%d). Cant't configure eICIC data ",
                                        p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);
                            }
                    }    
                }
                else
                {
                    /* SPR 20151 Fix Start */
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            " No need to reconfigure eICIC related data, due to eicic_provisioned_type check "
                            "Old eicic_prov_mode (%d) New eicic prov_mode (%d) is same",
                            p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type,
                            p_reconfig_req->operator_info.eicic_info.eicic_provisioned_type);

                    p_reconfig_req->operator_info.eicic_info.bitmask &= ~RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT;

                    /* SPR 20151 Fix Stop */
                }
                /* SPR 20453 Fix Start */
                /*Code removed*/
                /* SPR 20453 Fix Stop */
            }

            /* victimabs / low load abs`  */
            /* SPR 20151 Fix Start */
            if( (( RRM_ZERO == (p_reconfig_req->operator_info.eicic_info.bitmask & RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT ))) &&
                    (p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type != RRM_OAM_EICIC_DEACTIVATED)
              )
                /* SPR 20151 Fix Stop */
            { 
                if ( ( p_reconfig_req->operator_info.eicic_info.bitmask & RRMCM_RMIF_ABS_INFO_PRESENT ) &&
                        ( p_reconfig_req->operator_info.eicic_info.abs_info.bitmask & RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT ) &&
                        ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT & 
                          /* SPR 20453 Fix Start */
                          p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask ) &&
                        (RRM_ZERO != RRM_MEMCMP(&(p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern),
                                                &(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern),
                                                RRM_MAX_PATTERN_BYTE))
                        /* SPR 20453 Fix Stop */

                   )
                {
                    if ((p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_LOW)&&
                            (p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type & RRM_OAM_ACT_AS_AGGRESSOR))
                        /**13956_fix_end*/

                    {
                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                RRM_MAX_PATTERN_BYTE);
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_LOW_LOAD_ABS_PRESENT;
                    }
                    else
                    {
                        /*SPR 15211 start*/
                        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT;
                        /*SPR 15211 end*/
                        RRM_MEMSET( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE);
                        rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern);

                    }    
                }
                /*FIX_14510_START*/ 
                if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                        ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask  ) &&
                        /* SPR 20453 Fix Start */
                        ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask) &&
                        (RRM_ZERO != RRM_MEMCMP(&(p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern),
                                                &(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern),
                                                RRM_MAX_PATTERN_BYTE))
                        /* SPR 20453 Fix Stop */


                  )
                {	
                    /**13956_fix_start*/
                    if((p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type & RRM_OAM_ACT_AS_VICTIM)&&( RRM_FALSE == x2_up_vd_neigh ))
                        /**13956_fix_end*/
                    {
                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                RRM_MAX_PATTERN_BYTE);
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT;
                    } 
                    else
                    {
                        /*SPR 15211 start*/
                        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT;
                        /*SPR 15211 end*/
                        RRM_MEMSET( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE);
                        rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern);
                    }
                }    
                /*FIX_14510_END*/

                /*eicic_subset_pattern_fix_start*/
                if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                        ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                        /* SPR 20453 Fix Start */
                        ( RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask) &&
                        (RRM_ZERO != RRM_MEMCMP(&(p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset),
                                                &(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset),
                                                RRM_MAX_PATTERN_BYTE))
                        /* SPR 20453 Fix Stop */

                  )
                {
                    if(( RRM_FALSE == x2_up_vd_neigh ) && (p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type & RRM_OAM_ACT_AS_VICTIM))
                    {
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;
                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, p_reconfig_req->operator_info.eicic_info.abs_info.
                                abs_pattern.victim_meas_subset,RRM_MAX_PATTERN_BYTE);
                    }
                    else
                    {
                        /*SPR 15211 start*/
                        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT;
                        /*SPR 15211 end*/
                        RRM_MEMSET( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,
                                RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE);
                        rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,
                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset);

                    }
                }
                /*eicic_subset_pattern_fix_end*/
            }    
            /**13867_fix_start*/
            else
            {
                if ( ( p_reconfig_req->operator_info.eicic_info.bitmask & RRMCM_RMIF_ABS_INFO_PRESENT ) &&
                        ( p_reconfig_req->operator_info.eicic_info.abs_info.bitmask & RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT ) &&
                        ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask )
                   )
                {
                    /*SPR 15211 start*/
                    p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                    p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                    p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                    p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT;
                    /*SPR 15211 end*/
                    RRM_MEMSET(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                            RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                            p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                            p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern);
                }    


                if (RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
                {
                    /*SPR 15211 start*/
                    p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                    p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                    p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                    p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT;
                    /*SPR 15211 end*/
                    RRM_MEMSET( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                            RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                            p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern, 
                            p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern);

                }
                /*eicic_subset_pattern_fix_start*/
                if( ( RRMCM_RMIF_ABS_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.bitmask ) &&
                        ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_reconfig_req->operator_info.eicic_info.abs_info.bitmask ) &&
                        ( RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT & p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.bitmask))
                {
                    if(( RRM_FALSE == x2_up_vd_neigh ) && (p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type & RRM_OAM_ACT_AS_VICTIM)) 
                    {
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT; 
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;    
                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, p_reconfig_req->operator_info.eicic_info.abs_info.                 
                                abs_pattern.victim_meas_subset,RRM_MAX_PATTERN_BYTE);
                    }
                    else
                    {
                        /*SPR 15211 start*/
                        p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask |= RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT;
                        /*SPR 15211 end*/
                        RRM_MEMSET( p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,
                                RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE);
                        rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                                p_reconfig_req->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset, 
                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset);

                    }    
                } 
                /*eicic_subset_pattern_fix_end*/
            }  
            /**13867_fix_end*/
        }
        /** eICIC_PHASE_1_2_CHANGES_END*/

        if (RRMCM_RMIF_CA_CONFIG_INFO_PRESENT == p_reconfig_req->operator_info.bitmask)
        {
            is_reconfig_req_for_ca_params = RRM_TRUE;
            /* Checking CA mac scheduler params is present in cell reconfig request
               and value are not same as stored in cell context then send reconfig req 
               to L2 */
            if ((RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & 
                        p_reconfig_req->operator_info.ca_config.bitmask) &&
                    (RRM_TRUE != rrm_check_is_ca_mac_sch_param_value_same(
                                                                          &p_cell_ctx->operator_info,
                                                                          &p_reconfig_req->operator_info.ca_config.ca_mac_scheduler_params)))
            {
                recnf_req_for_mac_sch_params = RRM_TRUE;
            }
            else
            {
                rrm_commit_ca_reconfig_info (&p_cell_ctx->operator_info,
                        &p_reconfig_req->operator_info.ca_config);
                p_cell_ctx->operator_info.ca_config.bitmask |=
                    RRMCM_RMIF_CA_CONFIG_INFO_PRESENT;
            }

        }
        else if ( RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT == p_reconfig_req->operator_info.bitmask )
        {
            is_reconfig_req_for_ca_params = RRM_TRUE;
            if (RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT & p_reconfig_req->operator_info.rrm_tm_mode_table.bitmask)
            {
                p_cell_ctx->operator_info.rrm_tm_mode_table.tm_mode_for_strngnt_qci =
                    p_reconfig_req->operator_info.rrm_tm_mode_table.tm_mode_for_strngnt_qci;
                p_cell_ctx->operator_info.rrm_tm_mode_table.bitmask |=
                    RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT;
            }
            for ( index = RRM_ZERO; index < p_reconfig_req->operator_info.rrm_tm_mode_table.count; index ++)
            {
                p_cell_ctx->operator_info.rrm_tm_mode_table.rrm_tm_mode_table_row[index] = 
                    p_reconfig_req->operator_info.rrm_tm_mode_table.rrm_tm_mode_table_row[index]; 
            }
            p_cell_ctx->operator_info.rrm_tm_mode_table.count =
                p_reconfig_req->operator_info.rrm_tm_mode_table.count;
            p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT;
        }
        else if ((RRMCM_RMIF_CA_CONFIG_INFO_PRESENT | RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT) == 
                p_reconfig_req->operator_info.bitmask )
        {
            is_reconfig_req_for_ca_params = RRM_TRUE;
            /* Checking CA mac scheduler params is present in cell reconfig request
               and value are not same as stored in cell context then send reconfig req 
               to L2 */
            if ((RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & 
                        p_reconfig_req->operator_info.ca_config.bitmask) &&
                    (RRM_TRUE != rrm_check_is_ca_mac_sch_param_value_same(
                                                                          &p_cell_ctx->operator_info,
                                                                          &p_reconfig_req->operator_info.ca_config.ca_mac_scheduler_params)))
            {
                recnf_req_for_mac_sch_params = RRM_TRUE;
            }
            else
            {
                rrm_commit_ca_reconfig_info (&p_cell_ctx->operator_info,
                        &p_reconfig_req->operator_info.ca_config);
                p_cell_ctx->operator_info.ca_config.bitmask |=
                    RRMCM_RMIF_CA_CONFIG_INFO_PRESENT;
            }

            if (RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT & p_reconfig_req->operator_info.rrm_tm_mode_table.bitmask)
            {
                p_cell_ctx->operator_info.rrm_tm_mode_table.tm_mode_for_strngnt_qci =
                    p_reconfig_req->operator_info.rrm_tm_mode_table.tm_mode_for_strngnt_qci;
                p_cell_ctx->operator_info.rrm_tm_mode_table.bitmask |=
                    RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT;
            }
            for ( index = RRM_ZERO; index < p_reconfig_req->operator_info.rrm_tm_mode_table.count; index ++)
            {
                p_cell_ctx->operator_info.rrm_tm_mode_table.rrm_tm_mode_table_row[index] = 
                    p_reconfig_req->operator_info.rrm_tm_mode_table.rrm_tm_mode_table_row[index]; 
            }
            p_cell_ctx->operator_info.rrm_tm_mode_table.count =
                p_reconfig_req->operator_info.rrm_tm_mode_table.count;
            p_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT;

        }
    }
    /* Changing the x2_status value as locally connected if the neighbour value 
       reported by OAM is allowed and the cell is present on the same eNodeB*/
    /* SPR 10779 start */
    rrm_cellm_chk_and_change_x2_status(); 
    /* SPR 10779 end */
    /* Carrier_Aggregation_End */

    /*allocating memory for storing new configuration*/
    p_cell_ctx->p_new_reconfig_data = rrm_mem_get(sizeof 
            (rrmcm_rmif_cell_reconfig_req_t)); 
    /*  , coverity  id :16269 , added NULL check for rrm_mem_get */
    if(p_cell_ctx->p_new_reconfig_data != RRM_PNULL)
    {
        RRM_MEMSET(p_cell_ctx->p_new_reconfig_data,RRM_ZERO,
                sizeof(rrmcm_rmif_cell_reconfig_req_t));
        /*storing data*/
        RRM_MEMCPY(p_cell_ctx->p_new_reconfig_data,
                p_reconfig_req,
                sizeof(rrmcm_rmif_cell_reconfig_req_t));
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_ctx->p_new_reconfig_data failed"
                "Send Failure to MIF as RECONFIG RESP");
        /* SPR 13339 Fix Start */
        generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
        generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
        generic_resp_to_mif.response = RRM_FAILURE;
        generic_resp_to_mif.fail_cause = RRM_ERR_SYS_MEM_ALLOC_FAILURE;

        ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                RRMCM_RMIF_CELL_RECONFIG_RESP);
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_ERROR,
                    "Failed to Send Reconfig Generic Resp To MIF");
        }
        /*reconfig send fail cell state*/
        /* SPR_14003_Fix_Start */
        //CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
        /* SPR_14003_Fix_End */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell Reconfig Failed for Cell Index:%d Cell State is:%s[%d]",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                p_cell_ctx->cell_state);
        /* SPR 13339 Fix End */
        return RRM_FAILURE;
    }

    /* SPS related changes start - Global Variable removal */
    /* RoHC check removal for SPS - start */
    ret_val = set_sps_on_off_for_cell_reconfig(p_reconfig_req, p_cell_ctx);

    /* RoHC check removal for SPS - end */
    /* SPS related changes end - Global Variable removal */

    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */


    /*
     ** OAM/BUG 27 : Once we reconfig any parameter,RRM is sending 1016 error.
     ** If cell stop is required for the Cell Reconfiguration ,RRM stops the
     ** the cell and triggers reconfiguration.
     **
     ** In case of successful reconfiguration:-
     ** Cell's state becomes In-Service both at L3 and RRM with the
     ** new configuration provided at the time of cell reconfiguration.
     **
     ** In case of un-successful reconfiguration:-
     ** Cell's state becomes In-Service both at L3 and RRM with the
     ** same old configuration provided at the time of cell configuration.
     ** Also Reconfiguarton Failure is recieved at RRM.
     */
    /* BUG_11848_CHANGES_START */
    /* SPR_16141_CHANGES_START */
    if (RRM_TRUE == rrm_decision_cell_stop(p_cell_ctx))
        /* SPR_16141_CHANGES_END */
        /* BUG_11848_CHANGES_END */
    {
        /* Bug Id 633 Fix Start */
        /* Cell Stop procedure during cell reconfiguration is commented and
         * cell delete procedure is activated as L2 doesn't support cell stop
         * for the 2a parameters
         */

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "For Reconfig Cell Need to Delete and Configure Cell Index:%d",
                p_cell_ctx->cell_index);
        /* SPR 21412 Cell Reconfig Fix Start */
                    /* SPR 21412 Cell Reconfig Fix End */
                    if(RRM_FAILURE == rrm_decision_cell_delete(p_cell_ctx))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Reconfig:cell delete failed for cell index:%d",
                                p_cell_ctx->cell_index);
                        ret_val = RRM_FAILURE;
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Reconfig:cell deleted success for cell_index:%d",
                                p_cell_ctx->cell_index);
                        /* SPR 21412 Cell Reconfig Fix Start */
                        /* SPR 21412 Cell Reconfig Fix End */
                        ret_val = RRM_SUCCESS;
                    }
                    /* SPR 21412 Cell Reconfig Fix Start */
        /* SPR 21412 Cell Reconfig Fix End */
        /* Bug Id 633 Fix End */
    }
    else    
    {
        p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
        if (p_cell_reconfig_req == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_reconfig_req failed" );
            RRM_UT_TRACE_EXIT();
            RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
            return RRM_FAILURE;
        }
        /* Carrier_Aggregation_Start */
        /* If cell reconfig req is only for ca params then no need to send 
           reconfig request to L3 */
        if (RRM_FALSE == is_reconfig_req_for_ca_params)
        {
            /*Klockwork_fix_start*/
            ret_val = rmcm_mif_reconfig_req_non_ca_config(p_cell_ctx ,
                    p_cell_reconfig_req ,&generic_resp_to_mif );
            /*Klockwork_fix_end*/
            /* Carrier_Aggregation_End */
            /* BUG_371 FIX START */ 
            /* Carrier_Aggregation_Start */
        }
        else
        {
            /* If recnf_req_for_mac_sch_params is FALSE then return SUCCESS with RRM_NO_ERROR to mif */
            ret_val = RRM_SUCCESS;
            generic_resp_to_mif.fail_cause = RRM_NO_ERROR;
            /* If reconfig request is only for ca mac scheduler then sending MAC
               scheduler reconfig req to L2 */
            if (RRM_TRUE == recnf_req_for_mac_sch_params)
            {
                if( RRM_FAILURE == (ret_val = rrm_send_mac_scheduler_ca_agg_config_param( p_cell_ctx,
                                &p_reconfig_req->operator_info)))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Could not sent the mac scheduler reconfig to MAC for CA scheduler param");
                    generic_resp_to_mif.fail_cause = RRM_ERR_INTERNAL_FAILURE;
                }
                else
                {
                    rrm_commit_ca_reconfig_info (&p_cell_ctx->operator_info,
                            &p_reconfig_req->operator_info.ca_config);
                    p_cell_ctx->operator_info.bitmask |= 
                        RRMCM_RMIF_CA_CONFIG_INFO_PRESENT;
                }
            }


            if( RRM_ZERO == p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask ) 
            {
                generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
                generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
                generic_resp_to_mif.response = ret_val;
                ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                        RRMCM_RMIF_CELL_RECONFIG_RESP);
                if (RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
                            "Failed to Send Reconfig Generic Resp To MIF");
                }
                CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Cell reconfig is not sending to lower RRC for Cell Index:%d Cell State is:%s[%d]",
                        p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                        p_cell_ctx->cell_state);
            }
            /* first perform the broadcasting the cell change info to other cell */
            if ((RRMCM_RMIF_CA_CONFIG_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) &&
                    (RRM_TRUE == is_ca_eligible_prev_config)&&
                    (RRM_FALSE == p_reconfig_req->operator_info.ca_config.is_ca_eligible))
            {
                rrm_broadcast_carrier_agg_configuration_change_event_at_eNB(
                        p_cell_ctx->cell_index,
                        p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask, p_cell_ctx->ongoing_trans_id );

                if( RRM_TRUE == rrm_cell_have_scell_ue( p_cell_ctx ) )
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Cell index [%d] have ue using another cell as scell, and this cell have become ca to non ca",
                            p_cell_ctx->cell_index);
                    /*SPR 13316:start*/
                    rrm_cell_changed_from_CA_to_NON_CA( p_cell_ctx->cell_index, p_cell_ctx->ongoing_trans_id );
                    /*SPR 13316:end*/
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Cell index [%d] dont have ue using another cell as scell",p_cell_ctx->cell_index);
                }
                p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;
            }
            /* Carrier Aggregation end */ 
        }
        RRM_MEM_FREE(p_cell_reconfig_req);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : set_sps_on_off_for_cell_reconfig
 * Inputs         : rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req
                  : rrm_cell_context_t             *p_cell_ctx
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function sets the SPS feature ON/OFF
 ****************************************************************************/
rrm_void_t
set_sps_on_off_for_cell_reconfig_qos(rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req ,
                                     rrm_cell_context_t             *p_cell_ctx,                           
                                     U8                              qci_count)
{
    RRM_UT_TRACE_ENTER();
                if ( p_reconfig_req->epc_info.epc_params.qos_config_params[qci_count].bitmask &
                        RRMCM_RMIF_SPS_CONFIG_ENABLED_PRESENT )
                {
                    if ( p_reconfig_req->epc_info.epc_params.qos_config_params[qci_count].sps_config_enabled )
                    {
                        if(RRM_ONE == p_reconfig_req->epc_info.epc_params.qos_config_params[qci_count].erb_service_profile.enable_rohc)
                        {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "ROHC is enabled for SPS-enabled QCI:%d", (qci_count+1));
                        }
                        /* RoHC check removal for SPS - start */
                        else
                        {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "ROHC is not enabled for SPS-enabled QCI:%d", (qci_count+1));
                        }

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "SPS feature is anyways being enabled for SPS-enabled QCI:%d", (qci_count+1));
                        p_cell_ctx->p_new_reconfig_data->cell_reconfig_sps_on = RRM_TRUE;
                        /* RoHC check removal for SPS - end */
                    }
                    /* Start SPR:9262 */
                    else
                    {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "sps_config_enabled is false for QCI:%d", 
                            (qci_count+RRM_ONE));
                    }
                }
                else
                {
                    /* if sps config enabled TAG is absent for a QCI */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            " SPS_CONFIG_ENABLED tag is not present for QCI:%d, bitmask =%d", 
                            (qci_count+RRM_ONE),
                            p_reconfig_req->epc_info.epc_params.qos_config_params[qci_count].bitmask);
                }
                /* End SPR:9262 */
    RRM_UT_TRACE_EXIT();
}

/*Klockwork_fix_end*/


/* SPS related changes start - Global Variable removal */
/****************************************************************************
 * Function Name  : set_sps_on_off_for_cell_reconfig
 * Inputs         : rrmcm_rmif_cell_reconfig_req_t *p_reconfig_req
                  : rrm_cell_context_t             *p_cell_ctx
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function sets the SPS feature ON/OFF
 ****************************************************************************/
rrm_return_et
set_sps_on_off_for_cell_reconfig(
            rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req,
            rrm_cell_context_t              *p_cell_ctx
            )
{
    rrm_return_et              ret_val = RRM_SUCCESS;
    U8                         qci_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    p_cell_ctx->p_new_reconfig_data->cell_reconfig_sps_on = p_cell_ctx->sps_on;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "nwe sps =%d, old =%d ",p_cell_ctx->p_new_reconfig_data->cell_reconfig_sps_on,p_cell_ctx->sps_on);
    if (((p_reconfig_req->bitmask & RRMCM_RMIF_OPERATOR_INFO_PRESENT) &&
                (p_reconfig_req->operator_info.bitmask & RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT)) ||
            (RRM_TRUE == p_cell_ctx->sps_on))
    {
        if(p_reconfig_req->bitmask & RRMCM_RMIF_EPC_INFO_PRESENT)
        {

            for (qci_count = 0;
                    ((qci_count < p_reconfig_req->epc_info.epc_params.num_valid_qos_profiles)&&
                     (qci_count < RRM_MAX_QCI));
                    qci_count++)
            {

                 /*Klockwork_fix_start*/
                 set_sps_on_off_for_cell_reconfig_qos(p_reconfig_req ,p_cell_ctx ,qci_count);
                 /*Klockwork_fix_end*/
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "SPS is kept OFF for Cell Index :%d, since SPS_CRNTI_RANGE is absent or SPS was OFF at the time of Cell Config for this cell",
                p_cell_ctx->cell_index);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPS related changes end - Global Variable removal */

/******************************************************************
* Function Name  : rmcm_cell_stop_send_reconfig_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : cell is stoppedsend reconfig request in FSM
*******************************************************************/

rrm_return_et
rmcm_cell_stop_send_reconfig_req
(
   rrm_cell_context_t *p_cell_ctx
)
{

    rrm_return_et ret_val = RRM_FAILURE;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    
    p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
    if (p_cell_reconfig_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_reconfig_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    if (RRM_FAILURE == build_send_rrc_reconfig_req (p_cell_ctx, 
                                                    p_cell_reconfig_req,
                                                    CELL_RECONFIG_PROC))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed To Send Reconfig Req TO RRC For Cell Index :%d",
                     p_cell_ctx->cell_index);
        /* Send cell Start to RRC */
        ret_val = rmcm_start_for_reconfig(p_cell_ctx);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_ERROR,"failure in rmcm_start_for_reconfig");
        }
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "successfully send reconfig req for cell :%d",
                     p_cell_ctx->cell_index);
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_RECONFIG_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                     "Cell Reconfig Ongoing Waiting For ReConfig Resp "
								"for Cell Index:%d Cell State is:%s",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        ret_val = RRM_SUCCESS;
    }
    
    RRM_MEM_FREE(p_cell_reconfig_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*Cell update start*/
/****************************************************************************
 * Function Name  : rmcm_mif_send_update_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update resp in FSM
 ****************************************************************************/
rrm_return_et
rmcm_mif_send_update_resp(rrm_cell_context_t *p_cell_ctx /* cell context */)
{
   rrm_return_et ret_val = RRM_SUCCESS;
   rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
   rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;

   RRM_UT_TRACE_ENTER();

   p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
                                      p_cell_ctx->p_incoming_api_info;
   p_generic_resp = rrm_mem_get(sizeof
                     (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :29546 , added NULL check for rrm_mem_get */
   if(p_generic_resp != RRM_PNULL)
   {
       p_generic_resp->cellindex = p_rrc_rrm_cell_reconfig_resp->cell_index;
       p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
       p_generic_resp->response =  p_rrc_rrm_cell_reconfig_resp->response;

       if(RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
       {
           p_generic_resp->fail_cause =fail_cause_mapping(
                   p_rrc_rrm_cell_reconfig_resp->fail_cause);
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Update Fail Cause:%d",
                   p_rrc_rrm_cell_reconfig_resp->fail_cause);

       }
       else
       {
           p_generic_resp->fail_cause= RRM_NO_ERROR;
       }

       if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                   RRMCM_RMIF_CELL_UPDATE_RESP,
                   sizeof(rrmcm_rmif_generic_resp_t),
                   (void *)p_generic_resp))
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                   "failure in sending :%d for cell index:%d",
                   RRMCM_RMIF_CELL_UPDATE_RESP,
                   p_rrc_rrm_cell_reconfig_resp->cell_index);
           ret_val = RRM_FAILURE;
       }
       else
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                   "success in sending :%d for cell index:%d",
                   RRMCM_RMIF_CELL_UPDATE_RESP,
                   p_rrc_rrm_cell_reconfig_resp->cell_index);
           ret_val = RRM_SUCCESS;
       }
       RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
       RRM_MEM_FREE(p_generic_resp);
   }
   else
   {
       RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
               "Memory allocation to p_generic_resp failed");
       ret_val = RRM_FAILURE;
   }
   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rmif_update_ongoing_update_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RrmRrcCellStopUpdateResp in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_update_ongoing_update_resp
(
    rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
                                      p_cell_ctx->p_incoming_api_info;

    if (RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
    {
        /*Required to be checked when update is failed and start is success*/
        p_cell_ctx->stop_update_fail |= RRM_UPDATE_FAIL;

        ret_val = rmcm_mif_send_update_resp(p_cell_ctx);
        if(ret_val == RRM_FAILURE)
        {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR,"failure in rmcm_mif_send_update_fail_resp");
        }
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                             CELL_STATE_W_FOR_CELL_DEL);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_BRIEF,"Update Fail Cell State Is:%s For Cell Index:%d",
                  CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
    }
    else
    {
        commit_update_param(p_cell_ctx);
        ret_val = rmcm_start_for_update(p_cell_ctx);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in rmcm_start_for_update");
        }
        ret_val = RRM_SUCCESS;
   }

   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/****************************************************************************
 * Function Name  : commit_update_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the update parameters in cell context
 ****************************************************************************/
rrm_void_t
commit_update_param
(
  rrm_cell_context_t *p_cell_ctx
)
{
    U8          valid_plmn = RRM_ZERO;
    U8          plmn_count = RRM_ZERO;
    U8          mcc_digits = RRM_ZERO;
    U8          mnc_digits = RRM_ZERO;
    rrmcm_rmif_cell_update_req_t *p_rrmcm_rmif_cell_update_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrmcm_rmif_cell_update_req = (rrmcm_rmif_cell_update_req_t *) p_cell_ctx->p_new_update_data;
    RRM_ASSERT(RRM_PNULL != p_rrmcm_rmif_cell_update_req);

    if(p_rrmcm_rmif_cell_update_req->bitmask &
                           RRMCM_RMIF_PCI_VALUE_PRESENT)
    {
        p_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id =
                               p_rrmcm_rmif_cell_update_req->pci_value;
    }

    if(p_rrmcm_rmif_cell_update_req->bitmask &
                            RRMCM_RMIF_UPDATED_PLMN_INFO)
    {
        valid_plmn = p_rrmcm_rmif_cell_update_req->updated_plmn_info.no_of_valid_plmns;

        p_cell_ctx->epc_info.epc_params.general_epc_params.num_valid_plmn = valid_plmn;
        /* SPR 10730 Fix Start */
        /* SPR 10730 Fix Start */
        for(plmn_count=RRM_ZERO; plmn_count < valid_plmn; plmn_count++)
        {
            p_cell_ctx->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].plmn_id.\
                                                                     num_mnc_digit =
            p_rrmcm_rmif_cell_update_req->updated_plmn_info.plmn_list[plmn_count].num_mnc_digit;

            for (mnc_digits = RRM_ZERO;((mnc_digits < p_rrmcm_rmif_cell_update_req->updated_plmn_info.\
                   plmn_list[plmn_count].num_mnc_digit) && (mnc_digits < MAX_MNC_DIGITS));mnc_digits++)
            {
                p_cell_ctx->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].plmn_id.\
                                                                    mnc[mnc_digits] =
                p_rrmcm_rmif_cell_update_req->updated_plmn_info.plmn_list[plmn_count].mnc[mnc_digits];
            }

            for(mcc_digits = RRM_ZERO; mcc_digits < MAX_MCC_DIGITS; mcc_digits++)
            {
                p_cell_ctx->epc_info.epc_params.general_epc_params.plmn_list[plmn_count].plmn_id.\
                                                                         mcc[mcc_digits] =
                p_rrmcm_rmif_cell_update_req->updated_plmn_info.plmn_list[plmn_count].mcc[mcc_digits];
            }
        }
        /* SPR 10730 Fix End */
    }
    RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rmcm_rmif_send_update_ongoing_start_succ
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Update is completed and send success cell start
 *                : response to MIF
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_update_ongoing_start_succ
(
  rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    rrc_rrm_cell_start_resp_t *rrc_rrm_cell_start_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    rrc_rrm_cell_start_resp = (rrc_rrm_cell_start_resp_t *)
        p_cell_ctx->p_incoming_api_info;

    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :29548 , added NULL check for rrm_mem_get */
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = rrc_rrm_cell_start_resp->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        /*chk update is failed or success*/
        if(p_cell_ctx->stop_update_fail & RRM_UPDATE_FAIL)
        {
            p_generic_resp->response = RRM_FAILURE;
            p_generic_resp->fail_cause = fail_cause_mapping(
                    p_cell_ctx->ongoing_procedure_fail_cause);
        }
        else
        {
            p_generic_resp->response = rrc_rrm_cell_start_resp->response;
            p_generic_resp->fail_cause = RRM_NO_ERROR;
        }

        if(RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_UPDATE_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_generic_resp))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_UPDATE_RESP,
                    p_cell_ctx->cell_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_UPDATE_RESP,
                    p_cell_ctx->cell_index);
            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rmif_send_update_ongoing_start_stop_fail
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles cell stop failure in case of update in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_update_ongoing_start_stop_fail
(
  rrm_cell_context_t *p_cell_ctx
)
{
   rrm_return_et ret_val = RRM_SUCCESS;
   rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;

   RRM_UT_TRACE_ENTER();

     p_generic_resp = rrm_mem_get(sizeof
                                    (rrmcm_rmif_generic_resp_t));
    if (p_generic_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

   p_generic_resp->cellindex = p_cell_ctx->cell_index;
   p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
   p_generic_resp->fail_cause = RRM_ERR_CELL_DELETION_EXPECTED;
   p_generic_resp->response= RRM_FAILURE;


   if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                           RRMCM_RMIF_CELL_UPDATE_RESP,
                          sizeof(rrmcm_rmif_generic_resp_t),
                           (void *)p_generic_resp))

    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "failure in sending :%d for cell index:%d",
                                RRMCM_RMIF_CELL_UPDATE_RESP,
                                 p_cell_ctx->cell_index);
          ret_val = RRM_FAILURE;
    }
    else
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "success in sending :%d for cell index:%d",
                              RRMCM_RMIF_CELL_UPDATE_RESP,
                               p_cell_ctx->cell_index);
          ret_val = RRM_SUCCESS;
     }
   RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
   RRM_MEM_FREE(p_generic_resp);
   RRM_UT_TRACE_EXIT();
   return ret_val;

}

/****************************************************************************
 * Function Name  : rmcm_rmif_update_ongoing_start_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_rmif_update_ongoing_start_resp in FSM
 ****************************************************************************/

rrm_return_et
rmcm_rmif_update_ongoing_start_resp
(
    rrm_cell_context_t *p_cell_ctx /* cell context */
)
{
    rrm_return_et  ret_val = RRM_FAILURE;
    rrc_rrm_cell_start_resp_t *p_rrc_rrm_cell_start_resp = RRM_PNULL;
    p_rrc_rrm_cell_start_resp = (rrc_rrm_cell_start_resp_t *)
                                                 p_cell_ctx->p_incoming_api_info;

    RRM_UT_TRACE_ENTER();


    if (RRM_FAILURE == p_rrc_rrm_cell_start_resp->response)
    {
        /*Update fail and cell start fails
         */
         ret_val = rmcm_rmif_send_update_ongoing_start_stop_fail(p_cell_ctx);
         if (RRM_FAILURE == ret_val)
         {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                       RRM_BRIEF, "Failed to send generic response to MIF");
          }
         
         /*Coverity_fix_start_54966*/
         CELL_M_FSM_SET_STATE(p_cell_ctx,
                                    CELL_STATE_W_FOR_CELL_DEL);
         /*Coverity_fix_end_54966*/
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Update Failed for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
    }
    else
    {
        /*update fail and cell start success
         */
        ret_val =rmcm_rmif_send_update_ongoing_start_succ(p_cell_ctx);
         if (RRM_FAILURE == ret_val)
         {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                       RRM_BRIEF, "Failed to send generic response to MIF");
         }

        CELL_M_FSM_SET_STATE(p_cell_ctx,
                                 CELL_STATE_ACTIVE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "Cell Update Success for Cell Index:%d Cell State is:%s",
                    p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*********************************************************************
* Function Name  : rmcm_start_for_update
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles start request to RRC in for update in FSM
**********************************************************************/
rrm_return_et
rmcm_start_for_update
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrc_rrm_cell_start_req_t *p_cell_start_req = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "send cell start req for cell :%d",
              p_cell_ctx->cell_index);

    p_cell_start_req = rrm_mem_get(sizeof(rrc_rrm_cell_start_req_t));
    if (p_cell_start_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_start_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* SPR 21660 changes start */
    ret_val =build_send_start_req(p_cell_ctx->ongoing_trans_id,
            p_cell_ctx->cell_index, p_cell_start_req);
    /* SPR 21660 changes end */
    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed To Send Cell Start Req to RRC");
        generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
        generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
        generic_resp_to_mif.response = RRM_FAILURE;
        generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
        ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                RRMCM_RMIF_CELL_UPDATE_RESP);
        /* Coverity Fix 75540 Start */
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Failure returned by the function build_and_send_generic_resp_to_mif");
        }
        /* Coverity Fix 75540 End */
        /*Chnage the cell state*/
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_W_FOR_CELL_DEL);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell Update Failed for Cell Index:%d Cell State is:%s",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        ret_val = RRM_FAILURE;
    }
    else
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                     CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_START_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Update Ongoing for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
       ret_val = RRM_SUCCESS;
    }
    RRM_MEM_FREE(p_cell_start_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************
* Function Name  : rmcm_cell_stop_send_update_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : cell is stopped send update request in FSM
*******************************************************************/

rrm_return_et
rmcm_cell_stop_send_update_req
(
   rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();

    p_cell_ctx->p_new_reconfig_data = 
                 rrm_mem_get(sizeof(rrmcm_rmif_cell_reconfig_req_t));
    if (p_cell_ctx->p_new_reconfig_data == RRM_PNULL)
   {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_ctx->p_new_reconfig_data failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
   }

    /*Internally cell update uses cell reconfig API for sending requset, 
     *so using rrmcm_rmif_cell_reconfig_req_t.
     */

    if (RRM_FAILURE == build_send_rrc_update_req (p_cell_ctx))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed To Send Update Req TO RRC For Cell Index :%d",
                     p_cell_ctx->cell_index);
        /* Send cell Start to RRC */
        ret_val = rmcm_start_for_update(p_cell_ctx);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                       RRM_ERROR,"failure in rmcm_start_for_update");
        }
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "successfully send update req for cell :%d",
                     p_cell_ctx->cell_index);
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_UPDATE_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                     "Cell Update Ongoing Waiting For Update Resp "
                                "for Cell Index:%d Cell State is:%s",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
        ret_val = RRM_SUCCESS;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rmif_update_ongoing_stopped_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles stop response in case of update procedure in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_update_ongoing_stopped_resp
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrc_rrm_cell_stop_resp_t   *rrc_rrm_cell_stop_resp = RRM_PNULL;
    rrm_return_et               ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_stop_resp = (rrc_rrm_cell_stop_resp_t *)
                              p_cell_ctx->p_incoming_api_info;
    RRM_ASSERT(RRM_PNULL != rrc_rrm_cell_stop_resp);
    if (RRM_FAILURE == rrc_rrm_cell_stop_resp->response)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF,"Cell stop operation failed");
        ret_val = rmcm_rmif_send_update_ongoing_start_stop_fail(p_cell_ctx);
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_BRIEF,"Send failure for update");
        }
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                              CELL_STATE_W_FOR_CELL_DEL);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Cell Update Failed for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Cell Succefully stopped");
        if (RRM_SUCCESS == rmcm_cell_stop_send_update_req(p_cell_ctx))
         {
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                     "successfully send cell stop send update");
             ret_val = RRM_SUCCESS;
         }
         else
         {
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                     "unsuccessfully send cell stop send update");
             ret_val = RRM_FAILURE;
         }

    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/*********************************************************************
* Function Name  : cell_stop_for_update
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles stop request for update in FSM
**********************************************************************/

rrm_return_et
cell_stop_for_update
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
    rrc_rrm_cell_stop_req_t *p_cell_stop_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_cell_stop_req = rrm_mem_get(sizeof(rrc_rrm_cell_stop_req_t));
    if (p_cell_stop_req == RRM_PNULL)
   {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_stop_req failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
   }

    /* filling cell stop req
     */
       /*SPR 21660 changes start_Shivani*/
        if(RRM_FAILURE == build_send_stop_req(p_cell_ctx->ongoing_trans_id,
                    p_cell_ctx->cell_index, p_cell_stop_req))
        /*SPR 21660 changes end_Shivani*/
     {
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                 "UPDATE ONGOING: Failed To Send Cell stop req to RRC");
         generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
         generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
               generic_resp_to_mif.response = RRM_FAILURE;
         generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
         ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                       RRMCM_RMIF_CELL_UPDATE_RESP);
         if (RRM_FAILURE == ret_val)
         {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                       RRM_BRIEF, "Failed to send generic response to MIF");
         }
         /*State transition
         */
         CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
         RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
         ret_val = RRM_FAILURE;
     }
     else
     {
         p_cell_ctx->stop_update_fail |=RRM_UPDATE_ONGOING;
         /*State transition
         */
        CELL_M_FSM_SET_STATE(p_cell_ctx,
             CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_STOP_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Update Ongoing: Waiting For Cell Stop Resp From RRC"
                                                 "for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);

        CELL_STATE_CHNAGE_IND(p_cell_ctx,
                         CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_STOP_RESP);
    }
    RRM_MEM_FREE(p_cell_stop_req);
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_mif_update_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_update_req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_mif_update_req
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_update_req_t  *p_update_req = RRM_PNULL;
    rrmcm_rmif_generic_resp_t  *p_generic_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_update_req = (rrmcm_rmif_cell_update_req_t *)
                                         (p_cell_ctx->p_incoming_api_info);
    /*allocating memory for storing new configuration*/
    p_cell_ctx->p_new_update_data = (rrm_void_t *)rrm_mem_get(sizeof
                                       (rrmcm_rmif_cell_update_req_t));
    if (p_cell_ctx->p_new_update_data == RRM_PNULL)
   {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_ctx->p_new_update_data failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
   }

    RRM_MEMSET(p_cell_ctx->p_new_update_data,RRM_ZERO,
            sizeof(rrmcm_rmif_cell_update_req_t));
    /*storing data*/
    RRM_MEMCPY(p_cell_ctx->p_new_update_data,
               p_update_req,
               sizeof(rrmcm_rmif_cell_update_req_t));

    if (p_update_req->pci_value != 
        p_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id)
    {
       /* build and cell stop req
        */
        if(RRM_FAILURE == cell_stop_for_update(p_cell_ctx))
        {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                     "Cell update:cell stopped failed for cell index:%d",
                                   p_cell_ctx->cell_index);
           ret_val = RRM_FAILURE;
        }
        else
        {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                   "Cell Update:cell stopped success for cell_index:%d",
                                   p_cell_ctx->cell_index);
           ret_val = RRM_SUCCESS;
        }

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                   "For Update Cell Need to Delete and Configure Cell Index:%d",
                                   p_cell_ctx->cell_index);
    }
    else
    {
        /*No cell update required, send message to MIF*/
        p_generic_resp = rrm_mem_get(sizeof
                        (rrmcm_rmif_generic_resp_t));
        if(RRM_PNULL != p_generic_resp) /* Coverity: CID 29547 */
        {
            p_generic_resp->cellindex = 
                p_update_req->cellindex;
            p_generic_resp->transaction_id = 
                p_update_req->transaction_id;
            p_generic_resp->response = RRM_SUCCESS;
            p_generic_resp->fail_cause = RRM_NO_ERROR;

            if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                        RRMCM_RMIF_CELL_UPDATE_RESP,
                        sizeof(rrmcm_rmif_generic_resp_t),
                        (void *)p_generic_resp))

            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "failure in sending :%d for cell index:%d",
                        RRMCM_RMIF_CELL_UPDATE_RESP,
                        p_update_req->cellindex);
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "success in sending :%d for cell index:%d",
                        RRMCM_RMIF_CELL_UPDATE_RESP,
                        p_update_req->cellindex);
                ret_val = RRM_SUCCESS;
            }
            RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
            RRM_MEM_FREE(p_generic_resp);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Memory Allocation failure for p_generic_resp");
            RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
            return RRM_FAILURE;
        }
   }
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/*Cell update end*/
/*klock_works_changes_start*/
/*********************************************************************
 * Function Name  : build_send_cell_stop_failure
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles build stop request failure for reconfig in FSM
 **********************************************************************/
rrm_return_et
build_send_cell_stop_failure
(
 rrm_cell_context_t *p_cell_ctx
 )

{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "RECONFIG ONGOING: Failed To Send Cell stop req to RRC");
    generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
    generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
    generic_resp_to_mif.response = RRM_FAILURE;
    generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
    ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
            RRMCM_RMIF_CELL_RECONFIG_RESP);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF, "Failed to send generic response to MIF");
    }
    /*State transition
     */
    CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Cell Index:%d Cell State is:%s",
            p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
    ret_val = RRM_FAILURE;

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_end*/

/*********************************************************************
* Function Name  : cell_stop_for_reconfig
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles stop request for reconfig in FSM
**********************************************************************/

rrm_return_et
cell_stop_for_reconfig
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_stop_req_t *p_cell_stop_req = RRM_PNULL;
   
    RRM_UT_TRACE_ENTER();
    p_cell_stop_req = rrm_mem_get(sizeof(rrc_rrm_cell_stop_req_t));
    if (p_cell_stop_req == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_stop_req failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }
    /* filling cell stop req 
     */
       /*SPR 21660 changes start_Shivani*/
        if(RRM_FAILURE == build_send_stop_req(p_cell_ctx->ongoing_trans_id,
                    p_cell_ctx->cell_index, p_cell_stop_req))
        /*SPR 21660 changes end_Shivani*/
     {
        /*klock_works_changes_start*/
        ret_val=build_send_cell_stop_failure(p_cell_ctx);
        /*klock_works_changes_end*/
     
     }
     else
     {
         p_cell_ctx->stop_reconfig_fail |=RRM_RECONFIG_ONGOING;
         /*State transition
         */
        CELL_M_FSM_SET_STATE(p_cell_ctx,
             CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Reconfig Ongoing: Waiting For Cell Stop Resp From RRC"
												 "for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);

        CELL_STATE_CHNAGE_IND(p_cell_ctx,
						 CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP);
    }
    RRM_MEM_FREE(p_cell_stop_req);
    RRM_UT_TRACE_EXIT();
    
    return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_rmif_send_reconfig_ongoing_start_stop_fail
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles cell stop failure in case of reconfig in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_reconfig_ongoing_start_stop_fail
(
  rrm_cell_context_t *p_cell_ctx
)
{
   rrm_return_et ret_val = RRM_SUCCESS;
   rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;

   RRM_UT_TRACE_ENTER();
   
	 p_generic_resp = rrm_mem_get(sizeof
                                    (rrmcm_rmif_generic_resp_t));
   if (p_generic_resp == RRM_PNULL)
   {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
   }

   p_generic_resp->cellindex = p_cell_ctx->cell_index;
   p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
   p_generic_resp->fail_cause = RRM_ERR_CELL_DELETION_EXPECTED;
   p_generic_resp->response= RRM_FAILURE;
   

   if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                           RRMCM_RMIF_CELL_RECONFIG_RESP,
                          sizeof(rrmcm_rmif_generic_resp_t),
                           (void *)p_generic_resp))
   
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "failure in sending :%d for cell index:%d",
                                RRMCM_RMIF_CELL_RECONFIG_RESP,
                                 p_cell_ctx->cell_index);
          ret_val = RRM_FAILURE;
    }
    else
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "success in sending :%d for cell index:%d",
                              RRMCM_RMIF_CELL_RECONFIG_RESP,
                               p_cell_ctx->cell_index);
          ret_val = RRM_SUCCESS;
     }
   RRM_MEM_FREE(p_generic_resp);
   RRM_UT_TRACE_EXIT();
   return ret_val;

}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrmcm_chk_cell_stop_send_reconfig_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles stop response in case of reconfigure procedure in FSM
 ****************************************************************************/
rrm_return_et
rrmcm_chk_cell_stop_send_reconfig_req(rrm_cell_context_t *p_cell_ctx)
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if (RRM_SUCCESS == rmcm_cell_stop_send_reconfig_req(p_cell_ctx))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "successfully send cell stop send reconfig");
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "unsuccessfully send cell stop send reconfig");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rmcm_rmif_reconfig_ongoing_stopped_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles stop response in case of reconfigure procedure in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_reconfig_ongoing_stopped_resp
(
	rrm_cell_context_t *p_cell_ctx
)
{ 
    rrc_rrm_cell_stop_resp_t   *rrc_rrm_cell_stop_resp = RRM_PNULL;
    rrm_return_et               ret_val = RRM_SUCCESS;
    
    RRM_UT_TRACE_ENTER();

    rrc_rrm_cell_stop_resp = (rrc_rrm_cell_stop_resp_t *)
                              p_cell_ctx->p_incoming_api_info;
    RRM_ASSERT(RRM_PNULL != rrc_rrm_cell_stop_resp);
    if (RRM_FAILURE == rrc_rrm_cell_stop_resp->response)
    { 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF,"Cell stop operation failed");
        ret_val = rmcm_rmif_send_reconfig_ongoing_start_stop_fail(p_cell_ctx);
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_BRIEF,"Send failure for reconfig");
        }
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                              CELL_STATE_W_FOR_CELL_DEL);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Cell Reconfig Failed for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);

        RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
    }
    else
    {

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Cell Succefully stopped");
        /*RIM changes start*/
    /* Spr 16211 Changes Start*/
        if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Sending RIM info req to RRC with PDU ext as STOP as "
                    "cell has been successfully stopped");
            rrm_request_rim_info_req(p_cell_ctx,
                    &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
                    RAN_INFO_REQ_STOP);
        }
    /* Spr 16211 Changes End*/
        /*RIM changes end*/
        /*Klockwork_fix_start*/
        ret_val = rrmcm_chk_cell_stop_send_reconfig_req(p_cell_ctx);
        /*Klockwork_fix_end*/
         
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rmif_send_stop_fail_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles cell stop fail in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_send_stop_fail_resp
(
  rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    rrc_rrm_cell_stop_resp_t *rrc_rrm_cell_stop_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
     rrc_rrm_cell_stop_resp = p_cell_ctx->p_incoming_api_info;
    p_generic_resp = rrm_mem_get(sizeof
                                    (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16283 , added NULL check for rrm_mem_get */
   if(p_generic_resp != RRM_PNULL)
   {
       p_generic_resp->cellindex = rrc_rrm_cell_stop_resp->cell_index;
       p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
       p_generic_resp->response = RRM_FAILURE;
       p_generic_resp->fail_cause= fail_cause_mapping(
               rrc_rrm_cell_stop_resp->fail_cause);

       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
               "Fail cause at RRC :%d for Cell Index:%d",
               rrc_rrm_cell_stop_resp->fail_cause,
               p_cell_ctx->cell_index);

       if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                   RRMCM_RMIF_CELL_STOP_RESP,
                   sizeof(rrmcm_rmif_generic_resp_t),
                   (void *)p_generic_resp))

       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                   "failure in sending :%d for cell index:%d",
                   RRMCM_RMIF_CELL_STOP_RESP,
                   p_cell_ctx->cell_index);
           ret_val = RRM_FAILURE;
       }
       else
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                   "success in sending :%d for cell index:%d",
                   RRMCM_RMIF_CELL_STOP_RESP,
                   p_cell_ctx->cell_index);
           ret_val = RRM_SUCCESS;
       }
       RRM_MEM_FREE(p_generic_resp);
   }
   else
   {
         RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
	                       "Memory allocation to p_generic_resp failed");
	 ret_val = RRM_FAILURE;
   }

   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rmif_cell_del_req_reconfig_fail
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_rmif_cell_del_req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_cell_del_req_reconfig_fail
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_FAILURE;
    cell_son_attr_info_list_t  *p_cell_attribute_info = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if (p_cell_ctx->p_son_info != RRM_PNULL)
    {
        if (p_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)
        {
            p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
            if (p_cell_attribute_info != RRM_PNULL)
            {
                if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                    p_cell_attribute_info->p_cell_state=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_active_ue != RRM_PNULL)
                {
                      /* SPR-17852 START */
                        if ((RRM_TRUE == p_cell_attribute_info->
                                 p_active_ue->flag_periodic_active_ue) &&
                            (p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER])) 
                        {
                           cell_stop_timer(p_cell_attribute_info->
                           cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);
                      
                           p_cell_attribute_info->
                           cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;
                          /* SPR-17852 END */

                        p_cell_attribute_info->timer_status
                            [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                    }
                    RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                    p_cell_attribute_info->p_active_ue=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                    p_cell_attribute_info->p_ue_threshold=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                    p_cell_attribute_info->p_s1_msg_notification=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_ue_meas_result_notification
                        != RRM_PNULL)
                {
                      /* SPR-17852 START */
                        if ((RUNNING == p_cell_attribute_info->
                                        timer_status[SON_UE_MEAS_CONFIG_TIMER]) &&
                            (p_cell_attribute_info->cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]))
                        {
                           cell_stop_timer(p_cell_attribute_info->
                           cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]);

                           p_cell_attribute_info->
                           cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] = RRM_PNULL;
                      /* SPR-17852 END */
                        p_cell_attribute_info->timer_status
                            [SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                    }
                    RRM_MEM_FREE(p_cell_attribute_info->p_ue_meas_result_notification);
                    p_cell_attribute_info->p_ue_meas_result_notification=RRM_PNULL;
                }
            }
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            p_cell_ctx->p_son_info->p_anr_info=RRM_PNULL;
        }
        if (p_cell_ctx->p_son_info->p_es_info != RRM_PNULL)
        {
            p_cell_attribute_info = p_cell_ctx->p_son_info->p_es_info;
            if (p_cell_attribute_info != RRM_PNULL)
            {
                if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                    p_cell_attribute_info->p_cell_state=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_active_ue != RRM_PNULL)
                {
                      /* SPR-17852 START */
                        if ((RRM_TRUE == p_cell_attribute_info->
                                 p_active_ue->flag_periodic_active_ue) &&
                            (p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER])) 
                        {
                           cell_stop_timer(p_cell_attribute_info->
                           cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

                           p_cell_attribute_info->
                             cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;
                      /* SPR-17852 END */

                        p_cell_attribute_info->timer_status
                            [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                    }
                    RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                    p_cell_attribute_info->p_active_ue=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                    p_cell_attribute_info->p_ue_threshold=RRM_PNULL;
                }
                if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                    p_cell_attribute_info->p_s1_msg_notification=RRM_PNULL;
                }
            }
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
            p_cell_ctx->p_son_info->p_es_info=RRM_PNULL;
        }

        /* MRO Changes: Deallocating memory for MRO attributes */
        if (p_cell_ctx->p_son_info->p_mro_info != RRM_PNULL)
        {
            p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
            if (p_cell_attribute_info != RRM_PNULL)
            {
                if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                    p_cell_attribute_info->p_cell_state=RRM_PNULL;
                }
            }
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mro_info);
            p_cell_ctx->p_son_info->p_mro_info = RRM_PNULL;
        }
        /* MRO Changes deallocation completed */
        /* SPR 20267 Fix Start */
        if (p_cell_ctx->p_son_info->p_mlb_info != RRM_PNULL)
        {
            p_cell_attribute_info = p_cell_ctx->p_son_info->p_mlb_info;
            if (p_cell_attribute_info != RRM_PNULL)
            {
                if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                {
                    RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                    p_cell_attribute_info->p_cell_state=RRM_PNULL;
                }
            }
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mlb_info);
            p_cell_ctx->p_son_info->p_mlb_info = RRM_PNULL;
        }
        /* SPR 20267 Fix End */
        RRM_MEM_FREE(p_cell_ctx->p_son_info);
        p_cell_ctx->p_son_info=RRM_PNULL;
    }
    /*construct and send message to ue*/
    ret_val = rmcm_cell_send_del_to_ue(p_cell_ctx);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Failure: from rmcm_cell_send_del_to_ue");

    }
    CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_UEM_DEL);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Send Del Req to Ue Cell State is:%s[%d]",
            CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state );

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_11648_FIX_START */
/****************************************************************************
 * Function Name  : rrmcm_cm_cell_stop_broadcast_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles  rrmcm_cm_cell_stop_broadcast_resp in FSM
 ****************************************************************************/
rrm_return_et
rrmcm_cm_cell_stop_broadcast_resp
(
   rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{
    rrc_rrm_cell_stop_req_t *p_cell_stop_req = RRM_PNULL;
    rrm_return_et ret_val = RRM_FAILURE;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
    static int cell_stop_broadcast_resp_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    cell_stop_broadcast_resp_count++;
    /*Current cell doesnot send cell_stop msg to itself. So count is one less from total no. of cells present on eNb*/
    if(cell_stop_broadcast_resp_count == ((p_g_rrm_cell_ctx->enb_cell_count)-RRM_ONE))
    {
        cell_stop_broadcast_resp_count = RRM_ZERO;

        p_cell_stop_req = rrm_mem_get(sizeof(rrc_rrm_cell_stop_req_t));

        if(p_cell_stop_req == RRM_PNULL)
        {
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_stop_req failed");
            RRM_UT_TRACE_EXIT();
            ret_val = RRM_FAILURE;
        }
        else
        {
            /*Constructing Cell stop request*/
            /*SPR 21660 changes start_Shivani*/
            if(RRM_FAILURE == build_send_stop_req(p_cell_ctx->ongoing_trans_id,
                        p_cell_ctx->cell_index, p_cell_stop_req))
                /*SPR 21660 changes end_Shivani*/
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "Failed To Send Cell Stop Req To RRC For Cell Index:%d",
                        p_cell_ctx->cell_index);
                generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
                generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
                generic_resp_to_mif.response = RRM_FAILURE;
                generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
                ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                        RRMCM_RMIF_CELL_STOP_RESP);
                if (RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            "cellm_fsm_process_event: Failed to send generic response to MIF");
                }
                ret_val = RRM_FAILURE;
            }
            else
            {
#ifdef RRM_UT_FLAG
                RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_stop_req);
#endif
                CELL_M_FSM_SET_STATE(p_cell_ctx,
                        CELL_STATE_W_FOR_CELL_STOP_RESP);
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Cell State is :%s[%d]",
                        CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);

                ret_val = RRM_SUCCESS;
            }
            RRM_MEM_FREE(p_cell_stop_req);
        }
        RRM_UT_TRACE_EXIT();
    }
    return ret_val;
}
/* BUG_11648_FIX_END */

/* CA_Stage3_Change: Start */
/****************************************************************************
 * Function Name  : rrmcm_cm_cell_delete_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rrmcm_cm_cell_delete_resp in FSM
 ****************************************************************************/
rrm_return_et
rrmcm_cm_cell_delete_resp
(
 rrm_cell_context_t *p_cell_ctx
 )
{

    rrm_return_et ret_val = RRM_FAILURE;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
    static int cell_del_resp_cell_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    cell_del_resp_cell_count++;
    /*Current cell doesnot send cell_deletion msg to itself. So count is one less from total no. of cells present on eNb*/
    if(cell_del_resp_cell_count == ((p_g_rrm_cell_ctx->enb_cell_count)-RRM_ONE))
    {
        cell_del_resp_cell_count = RRM_ZERO;
        if(RRM_FAILURE == build_send_rrc_del_req (p_cell_ctx))
        {
           RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending del req to RRC");
            /*SPR 21369 Start*/
            p_cell_ctx->bitmask =RRM_ZERO;
            /*SPR 21369 End*/
            generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
            generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
#ifdef RRM_UT_FLAG
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F);
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F_inv_param);
#endif

            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                    RRMCM_RMIF_CELL_DELETE_RESP);
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "cellm_fsm_process_event:"
                        "Failed to send generic response to MIF");
            }
            /* BUG_12416_FIX_START */
            if(p_cell_ctx->cell_reconfig_deletion_required)
            {
                 /* Coverity ID 82862 Fix Start*/
                 rrm_decision_cell_delete_icic(p_cell_ctx);
                 /* Coverity ID 82862 Fix End*/
            }
            /* BUG_12416_FIX_END */
 
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "Send Cell Del req to RRC for cell index:%d",
                    p_cell_ctx->cell_index);
            CELL_M_FSM_SET_STATE(p_cell_ctx,
                    CELL_STATE_DELETE_IN_PROGRESS);
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Cell State is :%s[%d]",CELL_FSM_STATE[p_cell_ctx->cell_state],
                    p_cell_ctx->cell_state);
            ret_val = RRM_SUCCESS;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CA_Stage3_Change: End */

/*klock_works_changes_start*/
rrm_return_et     
chek_and_send_rrc_del_req
(
 rrm_cell_context_t         *p_cell_ctx
 )
{ 
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
        rrm_return_et              ret_val = RRM_SUCCESS;
    	/*SPR 17852 Start*/
	cell_son_attr_info_list_t  *p_cell_attribute_info = RRM_PNULL;
    U16                        sr_idx = RRM_ZERO;
    U16                        cqi_ri_index_count = RRM_ZERO;
	U16                        sr_periodicity = RRM_ZERO;
    /* SPR 20221 Fix Start */
    U16                         n2_pucch_res_index_max_value = RRM_ZERO;
    U16                     n2_pucch_res_index_tbl[MAX_N2_PUCCH_AN]     = {RRM_ZERO};
    /* Code Deleted */
    /* SPR 20221 Fix End */
	U16                        n_one_pucch_an = RRM_ZERO;
	/*SPR 17852 End*/
        RRM_UT_TRACE_ENTER();
        if(RRM_FAILURE == build_send_rrc_del_req (p_cell_ctx))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending del req to RRC");
            generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
            /*SPR 21369 Start*/
            p_cell_ctx->bitmask =RRM_ZERO;
            /*SPR 21369 End*/
            generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
#ifdef RRM_UT_FLAG        
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F);
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F_inv_param);
#endif        

            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                    RRMCM_RMIF_CELL_DELETE_RESP);
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                     "cellm_fsm_process_event:"  
                    "Failed to send generic response to MIF");
        }
        ret_val = RRM_FAILURE;
    }
    /*SPR 17852 Start*/
    else
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_req);
#endif        
	
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Send Cell Del req to RRC for cell index:%d",
                p_cell_ctx->cell_index);
        CELL_STATE_CHNAGE_IND(p_cell_ctx, CELL_STATE_DELETE_IN_PROGRESS);
        if (p_cell_ctx->p_son_info != RRM_PNULL)
        {
            if (p_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_active_ue != RRM_PNULL)
                    {
                      /* SPR-17852 START */
                        if ((RRM_TRUE == p_cell_attribute_info->
                                 p_active_ue->flag_periodic_active_ue) &&
                          (p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]))
                        {
                           cell_stop_timer(p_cell_attribute_info->
                           cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

                           p_cell_attribute_info->
                             cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;
                      /* SPR-17852 END */

                           p_cell_attribute_info->timer_status
                               [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                        }
                        RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                        p_cell_attribute_info->p_active_ue=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                        p_cell_attribute_info->p_ue_threshold=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                        p_cell_attribute_info->p_s1_msg_notification=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_ue_meas_result_notification
                                                   != RRM_PNULL)
                    {
                      /* SPR-17852 START */
                        if ((RUNNING == p_cell_attribute_info->
                                        timer_status[SON_UE_MEAS_CONFIG_TIMER]) &&
                          (p_cell_attribute_info->cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]))
                        {
                           cell_stop_timer(p_cell_attribute_info->
                           cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]);

                           p_cell_attribute_info->
                           cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] = RRM_PNULL;
                      /* SPR-17852 END */
                           p_cell_attribute_info->timer_status
                               [SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                        }
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_meas_result_notification);
                        p_cell_attribute_info->p_ue_meas_result_notification=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
                p_cell_ctx->p_son_info->p_anr_info=RRM_PNULL;
            }
            if (p_cell_ctx->p_son_info->p_es_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_es_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    /* SPR-17852 START */
                    if (RRM_ZERO != p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER])
                    {
                    /* SPR-17852 END */
                        cell_stop_timer (p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER]);
                        p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER] = RRM_ZERO;
                    }
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_active_ue != RRM_PNULL)
                    {
                      /* SPR-17852 START */
                        if ((RRM_TRUE == p_cell_attribute_info->
                                p_active_ue->flag_periodic_active_ue) &&
                            (p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER])) 
                        {
                            cell_stop_timer(p_cell_attribute_info->
                                    cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

                            p_cell_attribute_info->
                                    cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;
                      /* SPR-17852 END */
                            p_cell_attribute_info->timer_status
                                [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                        }
                        RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                        p_cell_attribute_info->p_active_ue=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                        p_cell_attribute_info->p_ue_threshold=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                        p_cell_attribute_info->p_s1_msg_notification=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
                p_cell_ctx->p_son_info->p_es_info=RRM_PNULL;
            }
            /* MRO changes: Deallocating memory for MRO info */
            if (p_cell_ctx->p_son_info->p_mro_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_mro_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mro_info);
                p_cell_ctx->p_son_info->p_mro_info = RRM_PNULL;
            }
            /* MRO changes end */
            /* SPR 20267 Fix Start */
            if (p_cell_ctx->p_son_info->p_mlb_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_mlb_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mlb_info);
                p_cell_ctx->p_son_info->p_mlb_info = RRM_PNULL;
            }
            /* SPR 20267 Fix End */
            RRM_MEM_FREE(p_cell_ctx->p_son_info);
            p_cell_ctx->p_son_info=RRM_PNULL;
        }

        /* Deleting the common resource */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "rmcm_rmif_cell_del_req:- Deleting common pool resources.....");
       
        /*MEMORY_PROFILING*/
	    find_sr_periodicity_from_cell_context(p_cell_ctx, &sr_periodicity, &n_one_pucch_an);    
        /*SPR 23347 Fix Start*/
        if(p_cell_ctx->sr_res != RRM_PNULL)
        {
            /*SPR 23347 Fix End*/
            for(sr_idx = RRM_ZERO;
                    sr_idx < n_one_pucch_an;
                    sr_idx++)
            {
                /*SPR 23347 Fix Start*/
                if(p_cell_ctx->sr_res[sr_idx] != RRM_PNULL)
                {
                    /*SPR 23347 Fix End*/
                    RRM_MEM_FREE(p_cell_ctx->sr_res[sr_idx]);
                }
            }
            /*SPR 23347 Fix Start*/
        }
        if(RRM_PNULL != p_cell_ctx->sr_res)
        RRM_MEM_FREE(p_cell_ctx->sr_res);
        /*SPR 23347 Fix End*/
        /*MEMORY_PROFILING*/
        
        /*MEMORY_PROFILING*/
        /* SPR 20221 Fix Start */
        /* Code Deleted */
        rrm_cellm_get_valid_n2_pucch_index(p_cell_ctx,
                &n2_pucch_res_index_tbl[RRM_ZERO],
                &n2_pucch_res_index_max_value);
        /* SPR 20221 FIx End */
        for(cqi_ri_index_count = RRM_ZERO; cqi_ri_index_count < n2_pucch_res_index_max_value;
             cqi_ri_index_count++)
        {
            RRM_MEM_FREE(p_cell_ctx->cqi_ri_res[cqi_ri_index_count]);
        }

        RRM_MEM_FREE(p_cell_ctx->cqi_ri_res);
        /*MEMORY_PROFILING*/
        
        /* SRS Start */
        /* Deleting SRS resources */

/* SRS_FREQ_HOPPING_START */
        rrm_set_srs_resources_free(p_cell_ctx);
        /*SRS End */
/* SRS_FREQ_HOPPING_END */
        /* SPR 10450 Fix Start */
        rrm_set_drx_resources_free(p_cell_ctx);
        /* SPR 10450 Fix End */
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_DELETE_IN_PROGRESS);
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Cell State is :%s[%d]",CELL_FSM_STATE[p_cell_ctx->cell_state],
                p_cell_ctx->cell_state);
        ret_val = RRM_SUCCESS;
      }
     /*SPR 17852 End*/
        RRM_UT_TRACE_EXIT();
        return ret_val;
}    
/*klock_works_changes_end*/    
/* BUG_12416_FIX_START */
/****************************************************************************
 * Function Name  : rmcm_rmif_cell_del_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Broadcast the cell delete req to all eNb cells
 ****************************************************************************/
rrm_return_et
rmcm_rmif_broadcast_cell_del_req(rrm_cell_context_t *p_cell_ctx)
 {
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* Carrier Aggragation start*/
    if (p_g_rrm_cell_ctx->enb_cell_count != RRM_ONE)
    {
        p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.
            cell_index = p_cell_ctx->cell_index;
        p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.
            ca_config_bitmask |= RRM_CA_CELL_DELETE_BITMASK ;

        rrm_broadcast_carrier_agg_configuration_change_event_at_eNB(
                p_cell_ctx->cell_index,
                p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask ,p_cell_ctx->ongoing_trans_id);


        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_W_FOR_CELL_INFO_CHANGE_RESP);
        
        p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;
       /* BUG_12416_FIX_START */ 
        if(( RRM_ZERO != p_cell_ctx->intra_eNB_cell_load_broadcast_timer )&&
                (qvTimerRunning(p_cell_ctx->intra_eNB_cell_load_broadcast_timer)))
        {
            cell_stop_timer( p_cell_ctx->intra_eNB_cell_load_broadcast_timer );
            p_cell_ctx->intra_eNB_cell_load_broadcast_timer = RRM_ZERO;
        }
        /* BUG_12416_FIX_END */
    }
    /* Carrier Aggregation end*/
    else
    {
        /*klock_works_changes_start*/ 
        if( RRM_FAILURE == chek_and_send_rrc_del_req(p_cell_ctx))
        {
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }    
        /*klock_works_changes_end*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;

 }
/* BUG_11648_FIX_START */
/****************************************************************************
 * Function Name  : rmcm_rmif_cell_del_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_rmif_cell_del_req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_cell_del_req
(
 rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et   ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    if (RRM_FAILURE == rmcm_rmif_broadcast_cell_del_req(p_cell_ctx))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "failure in cell deletion");
    }
    else
    {
        ret_val = RRM_SUCCESS;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_11648_FIX_END */
/* BUG_12416_FIX_END */
/****************************************************************************
 * Function Name  : rmcm_rmif_cell_del_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RrmRrcCellDeleteResp in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rmif_cell_del_resp
(
        rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et	ret_val = RRM_FAILURE;
    rrm_rrc_cell_del_resp_t *p_cell_del_resp = RRM_PNULL;
    cell_son_attr_info_list_t  *p_cell_attribute_info = RRM_PNULL;
    U16                        sr_idx = RRM_ZERO;
    U16                        cqi_ri_index_count = RRM_ZERO;
    /*Bug 831 Changes Start*/
    U8                                      ncl_count = RRM_ZERO;
    /*Bug 831 Changes End*/
    U16                     sr_periodicity = RRM_ZERO;
    U8                         n2_pucch_res_index_max_value = RRM_ZERO;
    /* SPR 11003 Fix Start */
    U16                      n_one_pucch_an = RRM_ZERO;
    /* SPR 11003 Fix End */
    U8                         n_rb_cqi = RRM_ZERO;
    /* SPR 10749 Fix Start */
    U8            no_of_ue_in_one_n2_rb = RRM_ZERO;
    /* SPR 10749 Fix End */

    /* BUG_371 FIX START */ 
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {0};
    /* BUG_371 FIX END */ 
    /* SPR 21412 Cell Reconfig Fix Start */
    /* SPR 21412 Cell Reconfig Fix End */

    RRM_UT_TRACE_ENTER();

    p_cell_del_resp = (rrm_rrc_cell_del_resp_t *)p_cell_ctx->p_incoming_api_info;
    if (RRM_FAILURE == p_cell_del_resp->response)
    {
        /*send deletion done with fail cause*/
        p_cell_ctx->deletion_flag = RRM_TRUE;
        p_cell_ctx->ongoing_procedure_fail_cause= p_cell_del_resp->fail_cause;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "received failure response for cell delete from rrc.");
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_resp_F_cm);
#endif        
        /* Coverity 74671 Fix Start */
        /* Coverity 74671 Fix End */
        /* BUG_371 FIX START */ 
        generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
        generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
        generic_resp_to_mif.response = RRM_FAILURE;
        generic_resp_to_mif.fail_cause = RRM_ERR_CELL_DELETION_FAILURE;

        /* SPR 14391 Fix Start */
        if(RRM_TRUE == p_cell_ctx->cell_reconfig_deletion_required)
        {
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                    RRMCM_RMIF_CELL_RECONFIG_RESP);

            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "Send Reconfig Resp Failure , Cell State is:%s[%d]",
                    CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
        }
        else if(RRM_FALSE == p_cell_ctx->cell_reconfig_deletion_required)
        {
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                    RRMCM_RMIF_CELL_DELETE_RESP);

            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_IDLE);
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "Send Delete Resp Failure , Cell State is:%s[%d]",
                    CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
        }
        /* SPR 14391 Fix End */
        /* BUG_371 FIX END */ 
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "Success response is received for cell delete from rrc");
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_resp_S_cm);
#endif        
        /* Coverity 74671 Fix Start */
        /* Coverity 74671 Fix End */

        /* DYNAMIC ICIC CHANGES START */ 
        /* SPR 17834 Fix Start */
        /* SPR-17852 START */
        if (RRM_PNULL != p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic)
        {
		/* SPR-17852 END */
            cell_stop_timer(p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic);
            p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic = RRM_PNULL;
        }

        /* SPR-17852 START */
        if (RRM_PNULL != p_cell_ctx->x2ap_icic_info_rpt_tmr)
	{
		/* SPR-17852 END */
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "ICIC: Reporting Timer Stopped");
            cell_stop_timer(p_cell_ctx->x2ap_icic_info_rpt_tmr);
            p_cell_ctx->x2ap_icic_info_rpt_tmr = RRM_PNULL;
        }
        /* DYNAMIC ICIC CHANGES END */
        /* SPR 17834 Fix End */

        /* SPR 21412 Cell Reconfig Fix Start*/
        /* SPR 21412 Cell Reconfig Fix End */

    }
    /*Bug 831 Changes Start*/
    for(ncl_count = RRM_ZERO;
            ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ;
            ncl_count++)
    {
        if( (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                    abs_info_sent == RRM_SEND_ABS_PATTERN ) ||
                ( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                  abs_info_sent == RRM_EICIC_ABS_PATTERN ))
        {
            if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                        p_cell_ctx,LOAD_INFO_EICIC_ABS_INACTIVE,ncl_count))
            {
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                    abs_info_sent = RRM_EICIC_ABS_INACTIVE;
                /*Bug 783 Changes Start */
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Successfully shared ABS Inactivity to Neighbour PCI [%d]"
                        "Resetting  abs_usage_rep_status to  [%d] in case of ABS Inactive.",
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id,
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status);
                /*Bug 783 Changes End */
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Unable to share ABS inactive with Neighbour[%d] abs_info_sent: [%d]",
                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id,
                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent);
        }
    }
    /*Bug 831 Changes End*/

    /* SPR 17834 Fix Start */
    /* MLB Changes start */
    /* SPR-17852 START */
    if (RRM_PNULL != p_cell_ctx->self_load_rpt_tmr)
    {
	    /* SPR-17852 END */
        cell_stop_timer(p_cell_ctx->self_load_rpt_tmr);
        p_cell_ctx->self_load_rpt_tmr = RRM_PNULL;
    }
    rrm_hndl_rsu_stop_req_for_ncl(p_cell_ctx,RRM_PNULL);
    /* SPR_12896_FIX_START */
    /* SPR-17852 START */
    if (RRM_PNULL != p_cell_ctx->cell_load_action.ld_process_timer_id)
    {
        /* SPR-17852 END */
        cell_stop_timer (p_cell_ctx->cell_load_action.ld_process_timer_id);
        p_cell_ctx->cell_load_action.ld_process_timer_id = RRM_PNULL;
    }
    /* SPR 17834 Fix End */
    /* SPR_12896_FIX_END */
    /* MLB Changes end */
    /*cov_fix_end_64536*/
    /*SPR:12251:start*/
    if (RRM_ZERO == p_cell_ctx->cell_reconfig_deletion_required)
    {
        /*SPR:12251:start*/
        if (p_cell_ctx->p_son_info != RRM_PNULL)
        {
            if (p_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_active_ue != RRM_PNULL)
                    {
                        if (RRM_TRUE == p_cell_attribute_info->
                                p_active_ue->flag_periodic_active_ue)
                        {
                            cell_stop_timer(p_cell_attribute_info->
                                    cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

                            p_cell_attribute_info->timer_status
                                [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                        }
                        RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                        p_cell_attribute_info->p_active_ue=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                        p_cell_attribute_info->p_ue_threshold=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                        p_cell_attribute_info->p_s1_msg_notification=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_ue_meas_result_notification
                            != RRM_PNULL)
                    {
                        if (RUNNING == p_cell_attribute_info->
                                timer_status[SON_UE_MEAS_CONFIG_TIMER])
                        {
                            cell_stop_timer(p_cell_attribute_info->
                                    cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]);

                            p_cell_attribute_info->timer_status
                                [SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                        }
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_meas_result_notification);
                        p_cell_attribute_info->p_ue_meas_result_notification=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
                p_cell_ctx->p_son_info->p_anr_info=RRM_PNULL;
            }
            if (p_cell_ctx->p_son_info->p_es_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_es_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if ((RRM_ZERO != p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER])
                            && (RRM_TRUE == qvTimerRunning(p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER])))
                    {
                        cell_stop_timer (p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER]);
                        p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER] = RRM_ZERO;
                    }
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_active_ue != RRM_PNULL)
                    {
                        if (RRM_TRUE == p_cell_attribute_info->
                                p_active_ue->flag_periodic_active_ue)
                        {
                            cell_stop_timer(p_cell_attribute_info->
                                    cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

                            p_cell_attribute_info->timer_status
                                [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                        }
                        RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                        p_cell_attribute_info->p_active_ue=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                        p_cell_attribute_info->p_ue_threshold=RRM_PNULL;
                    }
                    if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                        p_cell_attribute_info->p_s1_msg_notification=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
                p_cell_ctx->p_son_info->p_es_info=RRM_PNULL;
            }
            /* MRO changes: Deallocating memory for MRO info */
            if (p_cell_ctx->p_son_info->p_mro_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_mro_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mro_info);
                p_cell_ctx->p_son_info->p_mro_info = RRM_PNULL;
            }
            /* MRO changes end */
            /* SPR 20267 Fix Start */ 
            if (p_cell_ctx->p_son_info->p_mlb_info != RRM_PNULL)
            {
                p_cell_attribute_info = p_cell_ctx->p_son_info->p_mlb_info;
                if (p_cell_attribute_info != RRM_PNULL)
                {
                    if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
                    {
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                        p_cell_attribute_info->p_cell_state=RRM_PNULL;
                    }
                }
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mlb_info);
                p_cell_ctx->p_son_info->p_mlb_info = RRM_PNULL;
            }
            /* SPR 20267 Fix End */
            RRM_MEM_FREE(p_cell_ctx->p_son_info);
            p_cell_ctx->p_son_info=RRM_PNULL;
        }
        /* Deleting the common resource */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "rmcm_rmif_cell_del_req:- Deleting common pool resources.....");

        /*MEMORY_PROFILING*/
        find_sr_periodicity_from_cell_context(p_cell_ctx, &sr_periodicity, &n_one_pucch_an);   
 
	/* SPR_18169 Fix Start */	
        if (RRM_PNULL != p_cell_ctx->sr_res)
        {
            /* SPR_18169 Fix End */

            for(sr_idx = RRM_ZERO;
                    sr_idx < n_one_pucch_an;
                    sr_idx++)
            {
                /*SPR 23347 Fix Start*/
                if(p_cell_ctx->sr_res[sr_idx] != RRM_PNULL)
                {
                    /*SPR 23347 Fix End*/
                    RRM_MEM_FREE(p_cell_ctx->sr_res[sr_idx]);
                }
                /*SPR 23347 Fix Start*/
            }
            /*SPR 23347 Fix End*/
            /* SPR_18169 Fix Start */
        }
        /* SPR_18169 Fix End */
        /*SPR 23347 Fix Start*/
        if(RRM_PNULL != p_cell_ctx->sr_res)
	    RRM_MEM_FREE(p_cell_ctx->sr_res);
        /*SPR 23347 Fix End*/
        /*MEMORY_PROFILING*/

        /*MEMORY_PROFILING*/
        n_rb_cqi = p_cell_ctx->ran_info.physical_layer_params.
            physical_layer_param_pucch.n_rb_cqi;
        if(RRM_ZERO == n_rb_cqi)
        {
            n_rb_cqi = RRM_TWO;
        }
        /* OAM has configured the delta pucch values 0,1,2
           RRM needs to map the values to 1,2,3 delta_pucch_shift + 1 is required */
        /* SPR 10749 Fix Start */
        /*Cov_fix_start_64536*/
        no_of_ue_in_one_n2_rb =  RRM_MAX_NUM_OF_UE_IN_SINGLE_RB_FOR_FORMAT2_2A_2B;
        /* Coverity 63920 fix start */
        /* Coverity 63920 fix end */
        n2_pucch_res_index_max_value = (n_rb_cqi * no_of_ue_in_one_n2_rb);
        /* SPR 10749 Fix End */
        /*Cov_fix_end_64536*/
        /* Klocwork 29 may changes start*/
        if (RRM_PNULL != p_cell_ctx->cqi_ri_res)
        {
            for(cqi_ri_index_count = RRM_ZERO; cqi_ri_index_count < n2_pucch_res_index_max_value;
                    cqi_ri_index_count++)
            {
                if (RRM_PNULL != p_cell_ctx->cqi_ri_res[cqi_ri_index_count])
                {        RRM_MEM_FREE(p_cell_ctx->cqi_ri_res[cqi_ri_index_count]);
                }
            }
        }

        /* Klocwork 29 may changes end*/
        if (RRM_PNULL != p_cell_ctx->cqi_ri_res)
        {
            RRM_MEM_FREE(p_cell_ctx->cqi_ri_res);
        }
        /* Deleting SRS resources */
        /* SRS Start */
        /* Deleting SRS resources */

        /* SRS_FREQ_HOPPING_START */
        rrm_set_srs_resources_free(p_cell_ctx);
        /*SRS End */
        /* SRS_FREQ_HOPPING_END */
        /* SPR 10450 Fix Start */
        rrm_set_drx_resources_free(p_cell_ctx);
        /* SPR 10450 Fix End */
    }
    /*construct and send message to ue*/
    ret_val = rmcm_cell_send_del_to_ue(p_cell_ctx);
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Failure: from rmcm_cell_send_del_to_ue");

    }

    CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_UEM_DEL);
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Send Del Req to Ue Cell State is:%s[%d]",
            CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state );

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*********************************************************************
 * Function Name  : rmcm_cell_send_del_to_ue
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : send cell delete to UE in FSM
 *********************************************************************/
rrm_return_et
rmcm_cell_send_del_to_ue
(
   rrm_cell_context_t  *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmuem_cm_delete_all_ue_context_req_t *p_ue_del_ctx = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_ue_del_ctx = rrm_mem_get(sizeof(rrmuem_cm_delete_all_ue_context_req_t));

    /*  , coverity  id :16265 , added NULL check for rrm_mem_get */
    if(p_ue_del_ctx != RRM_PNULL)
    {
        p_ue_del_ctx->cell_index = p_cell_ctx->cell_index;
        p_ue_del_ctx->transaction_id = p_cell_ctx->ongoing_trans_id;

        if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
                    RRMUEM_CM_DELETE_ALL_UE_CONTEXT_REQ,
                    sizeof(rrmuem_cm_delete_all_ue_context_req_t),
                    (void *)p_ue_del_ctx))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMUEM_CM_DELETE_ALL_UE_CONTEXT_REQ,
                    p_cell_ctx->cell_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }

        CELL_M_FSM_SET_STATE(p_cell_ctx,
                CELL_STATE_UEM_DEL);

        RRM_MEM_FREE(p_ue_del_ctx);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_ue_del_ctx failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*********************************************************************
 * Function Name  : rmcm_rrc_ignored_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_failed_event in FSM
 *********************************************************************/
rrm_return_et
rmcm_rrc_ignored_event
(
        rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et	ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
              "Event Ignored for API [%d]", p_cell_ctx->api_id);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*********************************************************************
 * Function Name  : rmcm_mif_failed_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_failed_event in FSM
 *********************************************************************/
rrm_return_et
rmcm_mif_failed_event
(
        rrm_cell_context_t *p_cell_ctx   /* cell context */
)
{
    U16 resp_api_id = RRM_ZERO;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    rrm_return_et	ret_val = RRM_SUCCESS;
    /*  , coverity  id :16268 , added NULL check for rrm_mem_get */
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_generic_resp->response = RRM_FAILURE;

        switch(p_cell_ctx->api_id)
        {
            case RRMCM_RMIF_CELL_CONFIG_REQ:
                resp_api_id = RRMCM_RMIF_CELL_CONFIG_RESP;
                p_generic_resp->fail_cause= RRM_ERR_CELL_ALREADY_CONFIGURED;
                break;
            case RRMCM_RMIF_CELL_RECONFIG_REQ:
                resp_api_id = RRMCM_RMIF_CELL_RECONFIG_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_DELETE_REQ:
                resp_api_id = RRMCM_RMIF_CELL_DELETE_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_START_REQ:
                resp_api_id =RRMCM_RMIF_CELL_START_RESP;
                if(p_cell_ctx->cell_state == CELL_STATE_ACTIVE)
                {
                    p_generic_resp->fail_cause= RRM_ERR_CELL_ALREADY_OPERATIONAL;
                }
                else
                {
                    p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                }
                break;
            case RRMCM_RMIF_CELL_STOP_REQ:
                resp_api_id = RRMCM_RMIF_CELL_STOP_RESP;
                if(p_cell_ctx->cell_state == CELL_STATE_INACTIVE)
                {
                    p_generic_resp->fail_cause= RRM_ERR_CELL_UNOPERATIONAL;
                }
                else
                {
                    p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                }
                break;
            case RRMCM_RMIF_CELL_UPDATE_REQ:
                resp_api_id = RRMCM_RMIF_CELL_UPDATE_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break; 
            case RRMCM_RMIF_CELL_START_ADMISSION_REQ:
                resp_api_id = RRMCM_RMIF_CELL_START_ADMISSION_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_STOP_ADMISSION_REQ:
                resp_api_id = RRMCM_RMIF_CELL_STOP_ADMISSION_RESP;
                p_generic_resp->fail_cause= RRM_ERR_CELL_UNOPERATIONAL;
                break;
            case RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ANR_REQ:
                resp_api_id = RRMCM_RMIF_CELL_SET_ATTRIBUTE_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
                /* MRO changes started*/
            case RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_MRO_REQ:
                resp_api_id = RRMCM_RMIF_CELL_SET_ATTRIBUTE_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
                /* MRO changes started*/
            case RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ES_REQ:
                resp_api_id =RRMCM_RMIF_CELL_SET_ATTRIBUTE_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_REGISTER_FROM_ANR_REQ:
                resp_api_id = RRMCM_RMIF_CELL_REGISTER_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_REGISTER_FROM_ES_REQ:
                resp_api_id =RRMCM_RMIF_CELL_REGISTER_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_RAC_ENABLE_DISABLE_REQ:
                resp_api_id =RRMCM_RMIF_RAC_ENABLE_DISABLE_RES;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_DEREGISTER_FROM_ANR_REQ:
                resp_api_id = RRMCM_RMIF_CELL_DEREGISTER_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_DEREGISTER_FROM_ES_REQ:
                resp_api_id = RRMCM_RMIF_CELL_DEREGISTER_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
                /* UE MEAS CHANGES : STARTS */        
            case RRMCM_RMIF_MEAS_CONFIG_FROM_ANR_REQ:
                resp_api_id = RRMCM_RMIF_MEAS_CONFIG_RESP;
                if(RRM_SUCCESS == rrmcm_check_cell_state_validity(p_cell_ctx, &p_generic_resp->fail_cause))
                {
                    p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                }
                break;
            case RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ:
                resp_api_id = RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_RESP;
                if(RRM_SUCCESS == rrmcm_check_cell_state_validity(p_cell_ctx, &p_generic_resp->fail_cause))
                {
                    p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                }
                break;
            case RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK:
                resp_api_id = RRMCM_RMIF_CELL_STOP_ADMISSION_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;
            case RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK:
                resp_api_id = RRMCM_RMIF_CELL_START_ADMISSION_RESP;
                p_generic_resp->fail_cause= RRM_ERR_EVENT_NOT_POSSIBLE;
                break;

            default:
                /* Do Nothing */
                break;
                /* UE MEAS CHANGES : ENDS */        
        }

        /* Fix for Crash */
        p_cell_ctx->p_incoming_api_info = RRM_PNULL;
        /* Fix for Crash */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Recv Wrong Event in Wrong State Send Failure [Fail cause:%d]",
                p_generic_resp->fail_cause);
        if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    resp_api_id,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_generic_resp))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    p_cell_ctx->api_id,
                    p_cell_ctx->cell_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Success in sending :%d for Cell Index:%d",
                    resp_api_id,
                    p_cell_ctx->cell_index);
        }
        RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name,RRM_ERROR, 
                "Memory allocation to p_generic_resp failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*********************************************************************
 * Function Name  : rmcm_rrc_failed_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_rrc_failed_event in FSM
 *********************************************************************/
rrm_return_et
rmcm_rrc_failed_event
(
        rrm_cell_context_t *p_cell_ctx   /* cell context */
)
{
   U8 current_cell_state = RRM_NULL;
   U8 expected_cell_state = RRM_NULL;
   U8 expected_cell_sub_state = RRM_NULL;
   rrm_return_et ret_val = RRM_FAILURE;
   RRM_UT_TRACE_ENTER();

   switch(p_cell_ctx->api_id)
   {
       case RRC_RRM_UPDATED_PWS_SI_LIST_REQ:
               current_cell_state = p_cell_ctx->cell_state;
               expected_cell_state = CELL_STATE_PWS_ONGOING;
               expected_cell_sub_state = PWS_ONGOING_ACTIVE;
               ret_val = RRM_CELL_INVALID_STATE_FOR_PWS;
               break;
       case RRC_RRM_UPDATED_PWS_SI_LIST_CNF:
               current_cell_state = p_cell_ctx->cell_state;
               expected_cell_state = CELL_STATE_PWS_ONGOING;
               expected_cell_sub_state = PWS_W_FOR_UPDATE_CNF;
               ret_val = RRM_CELL_INVALID_STATE_FOR_PWS;
               break;
       case S1AP_RRM_PWS_REQ:
               current_cell_state = p_cell_ctx->cell_state;
               expected_cell_state = CELL_STATE_ACTIVE;
               expected_cell_sub_state = PWS_IDLE;
               ret_val = RRM_CELL_INVALID_STATE_FOR_PWS;
               break;
       case S1AP_RRM_PWS_CNF:
               current_cell_state = p_cell_ctx->cell_state;
               expected_cell_state = CELL_STATE_PWS_ONGOING;
               expected_cell_sub_state = PWS_W_FOR_PWS_CNF;
               ret_val = RRM_CELL_INVALID_STATE_FOR_PWS;
               break;
       case S1AP_RRM_KILL_REQ:
               current_cell_state = p_cell_ctx->cell_state;
               expected_cell_state = CELL_STATE_PWS_ONGOING;
               expected_cell_sub_state = PWS_ONGOING_ACTIVE;
               ret_val = RRM_CELL_INVALID_STATE_FOR_PWS;
               break;
       case S1AP_RRM_KILL_CNF:
               current_cell_state = p_cell_ctx->cell_state;
               expected_cell_state = CELL_STATE_PWS_ONGOING;
               expected_cell_sub_state = PWS_W_FOR_KILL_CNF;
               ret_val = RRM_CELL_INVALID_STATE_FOR_PWS;
               break;
               /*RIM changes start*/
       case S1AP_RRM_RIM_INFO:
               //fail_cause = RRM_ERR_EVENT_NOT_POSSIBLE;
               current_cell_state = p_cell_ctx->cell_state;
               ret_val = RRM_SUCCESS;
               break;
       case S1AP_RRM_RIM_INFO_APP_ERROR:
               //fail_cause = RRM_ERR_EVENT_NOT_POSSIBLE;
               current_cell_state = p_cell_ctx->cell_state;
               ret_val = RRM_SUCCESS;
               break;
               /*RIM changes end*/
#ifdef LTE_EMBMS_SUPPORTED
       case M2AP_RRM_MBMS_SF_INFO_REQ:
               current_cell_state = p_cell_ctx->cell_state;
               ret_val = RRM_CELL_NOT_AVAILABLE;
               break;
#endif
       default:
               /* Do Nothing */
               ret_val = RRM_FAILURE;
               break;
   }

    /*Some of the event are freed in mgr.c also. Free all the memory in mgr.c*/
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
             "API id [%d] is recived in invalid Cell state [%d] \n\
              expected cell state and  substate is [%d] and [%d] to successfully\
              process this API" ,p_cell_ctx->api_id,current_cell_state,
              expected_cell_state,expected_cell_sub_state );

   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_mif_send_reconfig_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig response in FSM
 ****************************************************************************/
rrm_return_et
rmcm_mif_send_reconfig_resp
(
   rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
        p_cell_ctx->p_incoming_api_info;
    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16273 , added NULL check for rrm_mem_get */
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = p_rrc_rrm_cell_reconfig_resp->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_generic_resp->response =  p_rrc_rrm_cell_reconfig_resp->response;
        if(RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
        {
            p_generic_resp->fail_cause =fail_cause_mapping( 
                    p_rrc_rrm_cell_reconfig_resp->fail_cause);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Reconfig Fail Cause:%d",
                    p_rrc_rrm_cell_reconfig_resp->fail_cause);

        }
        else
        {
            p_generic_resp->fail_cause= RRM_NO_ERROR;

        }
        if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_RECONFIG_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_generic_resp))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_RECONFIG_RESP,
                    p_rrc_rrm_cell_reconfig_resp->cell_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_RECONFIG_RESP,
                    p_rrc_rrm_cell_reconfig_resp->cell_index);

            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_rrc_reconfig_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig resp in FSM
 ****************************************************************************/
rrm_return_et 
rmcm_rrc_reconfig_resp(rrm_cell_context_t *p_cell_ctx /* cell context */)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;
	/* +- SPR 18268 */
	U16 max_num_ue_per_cell_bfr_reconfig = RRM_ZERO;
	/* +- SPR 18268 */
	srs_t *p_srs_info_bfr_reconfig = RRM_PNULL;
	pucch_t *p_cqi_sr_info_bfr_reconfig = RRM_PNULL;
	/*SPR 14529 start*/
	rrmcm_rmif_generic_resp_t generic_resp_to_mif = {RRM_ZERO};
	/*SPR 14529 end*/
	U16 meas_resp_api_id = RRM_ZERO;
	rrm_error_et fail_cause = RRM_NO_ERROR; /* Coverity_ID: 55833 */

	RRM_UT_TRACE_ENTER();

	p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
		p_cell_ctx->p_incoming_api_info;

	if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
	{
		if(RRM_FALSE == p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove)
		{
			meas_resp_api_id = RRMCM_RMIF_MEAS_CONFIG_RESP;
		}
		else
		{
			meas_resp_api_id = RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_RESP;
		}
	}

	if (RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
	{
		if(RRM_CELLM_REF_SIG_PWR_NOT_UPDATED != p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
					RRM_BRIEF,"Failure for Dynamic icic reconfig:"
					" Reconfig Resp From RRC::%d",
					p_rrc_rrm_cell_reconfig_resp->fail_cause);

			/* SPR 16491 Fix Start */
			/*spr 21625 fix start*/
			if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
			{
				CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
			}
			else
				/*spr 21625 fix end*/
			{
				if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
				{
					/* BUG_876_CHANGES_START*/
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
					CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
					/* BUG_876_CHANGES_END*/
				}
				else
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
				}
			}
			/* SPR 16491 Fix Stop */
		}
		else
		{
			/*Coverity_fix_start_54969*/
			/*need to chk fail cause*/
			switch(p_rrc_rrm_cell_reconfig_resp->fail_cause)
			{
				case RRM_RRC_LL_CONFIG_FAILURE:
				case RRM_RRC_INTERNAL_FAILURE:
					/* Fix 8219 Start */
				case RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE:
					/* Fix 8219 End */
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
							RRM_BRIEF,"Fail Cause of RRC:%d for cell Index:%d",
							p_rrc_rrm_cell_reconfig_resp->fail_cause,
							p_cell_ctx->cell_index);
					if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
					{
						/* send meas config response with failure cause */
						/* Coverity ID 82934 Fix Start */
						ret_val = rmcm_mif_meas_config_resp(p_cell_ctx, p_rrc_rrm_cell_reconfig_resp->response,
								RRM_ERR_RRC_FAILURE, meas_resp_api_id);  
						if(ret_val == RRM_FAILURE)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
									RRM_ERROR,"failure in rmcm_mif_meas_config_resp");
						}
						/* Coverity ID 82934 Fix End */
					}
					else
					{
						ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
						/* Coverity ID 82934 Fix Start */
						if(ret_val == RRM_FAILURE)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
									RRM_ERROR,"failure in rmcm_mif_send_reconfig_resp");
						}
						/* Coverity ID 82934 Fix End */
					}

					if(!(p_cell_ctx->scheduled_etws_warning_list.count)&&
							!(p_cell_ctx->scheduled_cmas_warning_list.count))
					{
						/* SPR 16491 Fix Start */
						/*spr 21625 fix start*/
						if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
						{
							CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
						}
						else
							/*spr 21625 fix end*/
						{
							if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
							{
								CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
								CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
							}
							else
							{
								CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
							}
						}
						/* SPR 16491 Fix Stop */
					}
					else
					{
						CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_PWS_ONGOING);
					}
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
							RRM_BRIEF,"Reconfig Fail Cell State Is:%s For Cell Index:%d",
							CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
					break;

				case RRM_RRC_UNKNOWN_FAILURE:
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
							RRM_BRIEF,"Fail Cause of RRC:%d for cell Index:%d",
							p_rrc_rrm_cell_reconfig_resp->fail_cause,
							p_cell_ctx->cell_index);

					if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
					{
						/* send meas config response with failure cause */
						/* Coverity ID 82934 Fix Start */
						ret_val = rmcm_mif_meas_config_resp(p_cell_ctx, p_rrc_rrm_cell_reconfig_resp->response,
								RRM_ERR_RRC_FAILURE, meas_resp_api_id);  
						if(ret_val == RRM_FAILURE)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
									RRM_ERROR,"failure in "
									" rmcm_mif_meas_config_resp");
						}
						/* Coverity ID 82934 Fix End */
					}
					else
					{
						ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
						/* Coverity ID 82934 Fix Start */
						if(ret_val == RRM_FAILURE)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
									RRM_ERROR,"failure in "
									" rmcm_mif_send_reconfig_resp");
						}
						/* Coverity ID 82934 Fix End */
					}
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_DEL);
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
							RRM_BRIEF,"Reconfig Fail Cell State Is:%s For Cell Index:%d",
							CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
					break;

				default:
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"unknown failure for reconfig from RRC:%d",
							p_rrc_rrm_cell_reconfig_resp->fail_cause);
					/* SPR 16491 Fix Start */
					/*spr 21625 fix start*/
					if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
					{
						CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
					}
					else
						/*spr 21625 fix end*/
					{
						if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
						{
							/*BUG_866_CHANGES_START*/
							CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
							CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
						}
						else
						{
							CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
						}
					}
					/* SPR 16491 Fix Stop */
					ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
					/* Coverity ID 82934 Fix Start */
					if(ret_val == RRM_FAILURE)
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
								RRM_ERROR,"failure in"
								"rmcm_mif_send_reconfig_resp");
					}
					/* Coverity ID 82934 Fix End */
					/*BUG_866_CHANGES_END*/
			}
		}

		/* eICIC_PHASE_1_2_CHANGES_START */
		p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask =  RRM_ZERO;
		p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
		/* eICIC_PHASE_1_2_CHANGES_END */
		/* Coverity ID 82934 Fix Start */
		/* Coverity ID 82934 Fix End */
		/*Coverity_fix_end_54969*/
	}
	else
	{

		/* Carrier Aggregation start*/
		/* first perform the broadcasting the cell change info to other cell */
		if( RRM_TRUE == p_cell_ctx->cell_modify_notification_obj.is_cell_changed )
		{
			rrm_broadcast_carrier_agg_configuration_change_event_at_eNB(
					p_cell_ctx->cell_index,
					p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask ,p_cell_ctx->ongoing_trans_id);

			if( RRM_CA_CELL_CA_TO_NON_CA & p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask )
			{
				if( RRM_TRUE == rrm_cell_have_scell_ue( p_cell_ctx ) )
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"Cell index [%d] have ue using another cell as scell, and this cell have become ca to non ca",
							p_cell_ctx->cell_index);

					/*SPR 13316:start*/
					rrm_cell_changed_from_CA_to_NON_CA( p_cell_ctx->cell_index, p_cell_ctx->ongoing_trans_id);
					/*SPR 13316:end*/
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
							"Cell index [%d] dont have ue using another cell as scell",p_cell_ctx->cell_index);
				}
			}

			p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;
		}
		/* Carrier Aggregation end */

		/* Reconfig Resp recvd corresponding to the req triggered by Meas Config */
		if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
		{
			/*Reconfig Crash for Meas Config: Fix Start*/
			commit_reconfig_param(p_cell_ctx); 
			/*Reconfig Crash for Meas Config: Fix End*/

			/* send meas config response with success */
			/* Coverity_ID : 56236, 55833 */
			fail_cause = fail_cause_mapping(p_rrc_rrm_cell_reconfig_resp->fail_cause);
			rmcm_mif_meas_config_resp(p_cell_ctx, p_rrc_rrm_cell_reconfig_resp->response,
					fail_cause, meas_resp_api_id);
			/* SPR 13014: Moved state change after the memory free as
			 * in case of dequeue, this procedure is conflicting with the
			 * memory allocation of the dequeued message procedure */

			/* free the memory for new SON cell configuration */
			RRM_MEM_FREE(p_cell_ctx->p_meas_config_sib_info_for_reconfig);
			if(p_cell_ctx->p_ncl_built_from_updated_nrt_info)
			{
				RRM_MEM_FREE(p_cell_ctx->p_ncl_built_from_updated_nrt_info);
				p_cell_ctx->p_ncl_built_from_updated_nrt_info = RRM_PNULL;
			}
			/* Start CSR 00064477 */
			/*spr 21625 fix start*/
			if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
			{
				CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
			}
			else
				/*spr 21625 fix end*/
			{
				if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
				}
				else
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
				}
			}
			/* End CSR 00064477 */

		}
		else
		{
			/* BUG_876_CHANGES_START */
			/* BUG_876_CHANGES_END*/
			p_cqi_sr_info_bfr_reconfig = (pucch_t*)rrm_mem_get(sizeof(pucch_t));
			if (p_cqi_sr_info_bfr_reconfig == RRM_PNULL)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"Memory allocation to p_cqi_sr_info_bfr_reconfig failed" );
				RRM_UT_TRACE_EXIT();
				return RRM_FAILURE;
			}

			if(p_cell_ctx->ran_info.physical_layer_params.bitmask & 
					RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)
			{
				p_srs_info_bfr_reconfig = (srs_t*)rrm_mem_get(sizeof(srs_t));
				if (p_srs_info_bfr_reconfig == RRM_PNULL)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"Memory allocation to p_srs_info_bfr_reconfig failed" );
					RRM_UT_TRACE_EXIT();
					RRM_MEM_FREE(p_cqi_sr_info_bfr_reconfig);
					return RRM_FAILURE;
				}
				RRM_MEMCPY(p_srs_info_bfr_reconfig ,&(p_cell_ctx->ran_info.
							physical_layer_params.physical_layer_param_srs),sizeof(srs_t));
			}

			RRM_MEMCPY(p_cqi_sr_info_bfr_reconfig ,&(p_cell_ctx->ran_info.
						physical_layer_params.physical_layer_param_pucch),sizeof(pucch_t));

			max_num_ue_per_cell_bfr_reconfig = p_cell_ctx->operator_info.admission_control_info.
				max_num_ue_per_cell; 
			/*Reconfig Crash for Meas Config: Fix Start*/
			commit_cell_reconfig_params(p_cell_ctx);
			/*Reconfig Crash for Meas Config: Fix End*/

			/*
			 ** Update the PUCCH/PUSCH resource pool as per the new configuration
			 */
			update_pucch_pusch_resources_on_reconfig( p_cell_ctx ,
					p_srs_info_bfr_reconfig , 
					p_cqi_sr_info_bfr_reconfig,
					max_num_ue_per_cell_bfr_reconfig);

			if(RRM_PNULL != p_cqi_sr_info_bfr_reconfig)
			{
				RRM_MEM_FREE(p_cqi_sr_info_bfr_reconfig);
			}
			if(RRM_PNULL != p_srs_info_bfr_reconfig)
			{
				RRM_MEM_FREE(p_srs_info_bfr_reconfig);
			}                

			/*CSR_00059028_CHANGES_START */
			if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
			{
				/*CSR_00059028_CHANGES_END */
				/* DYNAMIC ICIC CHANGES START */  
				/* BUG 9787 Fix Start */
				rrm_l2_build_send_reconfig_schedule_params(p_cell_ctx);
				/* BUG 9787 Fix End */
				/* DYNAMIC ICIC CHANGES END */

				/* SPR 10885 Fix Start */
				if(RRM_PNULL != p_cell_ctx->p_new_reconfig_data)
				{
					/** Dynamic UE Scheduling Start **/
					if(((rrmcm_rmif_cell_reconfig_req_t *)( p_cell_ctx->p_new_reconfig_data))->bitmask
							& RRMCM_RMIF_OPERATOR_INFO_PRESENT)
					{
						if(((rrmcm_rmif_cell_reconfig_req_t *)(p_cell_ctx->p_new_reconfig_data))->bitmask 
								& RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT )
						{
							rrm_send_active_ue_report_enable_prefs( p_cell_ctx->cell_index );
						}
					}
					/** Dynamic UE Scheduling End **/
					/*CSR_00059028_CHANGES_START */
				}
				/* SPR 10885 Fix End */
				/*spr 21625 fix start*/
				if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
				}
				else
					/*spr 21625 fix end*/
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
					CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
				}
			}
			else
			{
				/*spr 21625 fix start*/
				if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
				}
				else
					/*spr 21625 fix end*/
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
				}

			}
			/*CSR_00059028_CHANGES_END */

			/* BUG_876_CHANGES_START */
			/* BUG_876_CHANGES_END*/

			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
					RRM_BRIEF,"Reconfig Succ Cell State Is:%s For Cell Index:%d",
					CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);

			ret_val = RRM_SUCCESS;

			/** eICIC_PHASE_1_2_CHANGES_START */
			if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT)
			{
				if( RRM_FAILURE == build_and_send_uem_eicic_provision_reconfig_req(p_cell_ctx))
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"Could not sent the eicic provision to uem");
					p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
				}
				else
				{
					CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
							"Success returned during sending reconfig for eicic provision to uem ");
				}    
			}
			else if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT)
			{
				if(RRM_FAILURE == build_and_send_l2_cell_config_req_for_eicic_reconfig(&p_cell_ctx->rrm_eicic_cell_info.mac_config_data,
							p_cell_ctx->cell_index,
							p_cell_ctx->ongoing_trans_id))
				{
					/*SPR 14529 start*/
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
							"Failure returned during the processing of l2_cell_config_req");
					generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
					generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
					generic_resp_to_mif.response = RRM_FAILURE;
					generic_resp_to_mif.fail_cause = RRM_ERR_CELL_RECONFIG_ONGOING;
					ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
							RRMCM_RMIF_CELL_RECONFIG_RESP);
					if (RRM_FAILURE == ret_val)
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
								"Failed to Send Reconfig Generic Resp To MIF");
					}
					/*spr 21625 fix start*/
					if(p_cell_ctx->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK)
					{
						CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
					}
					else
						/*spr 21625 fix end*/
					{
						CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
					}
					if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
					{
						RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
						p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
					}
					p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
					p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask = RRM_ZERO;
					/*SPR 14529 end*/
				}
				else
				{  
					CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
							"Success returned during the processing of l2_cell_config_req");

				}
			}
			else 
			{
				RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
						"No need to trigger cell_config to L2 as a part of Cell Reconfiguration ");
			}

			if( RRM_ZERO == p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask)
			{
				ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
			}
			/** eICIC_PHASE_1_2_CHANGES_END */ 
		}
	}

	/* SPR 10885 Fix Start */
	/*SPR 5676 Fix Start*/
	/* free the memory for new configuration*/
	/*BUG:9237 start*/
	//coverity_fix_req
	if( (RRM_PNULL != p_cell_ctx->p_new_reconfig_data ) &&
			(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask == RRM_ZERO))
	{   
		RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
		p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
	}
	/*SPR 5676 Fix End*/
	/* SPR 10885 Fix End */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* SPR 10934 Fix Start */
rrm_void_t
commit_cell_reselection_params_cdma2000
(
 inter_rat_ncl_t                    *p_commit_inter_rat_ncl,
 rrmcm_rmif_cdma2000_freq_cells_t   *p_cdma2000_freq_cells,
 U8                                  num_valid_cdma2000_freq_cells
 )
{
    U8           cdma2000_bandclass        = RRM_ZERO;
    U8           cdma2000_bandclass_commit = RRM_ZERO;
    rrm_bool_et  record_found              = RRM_FALSE;


    RRM_UT_TRACE_ENTER();

    /*
    ** (band_class + arfcn + pn_offset) acts as a composite primary key
    ** if This key matches in alreadt present NCL , reconfig data  is updated at the same location
    ** else a new entry is created.
    */
    for(cdma2000_bandclass = RRM_ZERO;
            cdma2000_bandclass < num_valid_cdma2000_freq_cells; cdma2000_bandclass++)
    {
        for(cdma2000_bandclass_commit = RRM_ZERO;
                cdma2000_bandclass_commit < p_commit_inter_rat_ncl->num_valid_cdma2000_freq_cells; cdma2000_bandclass_commit++)
        {
            record_found = RRM_FALSE;

            if((p_commit_inter_rat_ncl->cdma2000_freq_cells[cdma2000_bandclass_commit].
                        band_class) == (p_cdma2000_freq_cells[cdma2000_bandclass].band_class))
            {
                if(( p_commit_inter_rat_ncl->cdma2000_freq_cells[cdma2000_bandclass_commit].arfcn ) ==
                        (p_cdma2000_freq_cells[cdma2000_bandclass].arfcn))
                {
                  if(( p_commit_inter_rat_ncl->cdma2000_freq_cells[cdma2000_bandclass_commit].pn_offset ) ==
                        (p_cdma2000_freq_cells[cdma2000_bandclass].pn_offset))
                  {
                      record_found = RRM_TRUE;
                      break;
                  }

                }

            }
        }

        if( RRM_TRUE == record_found )
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                       RRM_DETAILED,"Commiting an existing record at position  [%d] in NCL list", cdma2000_bandclass_commit);

            RRM_MEMCPY(&(p_commit_inter_rat_ncl->cdma2000_freq_cells[cdma2000_bandclass_commit]),
                    &(p_cdma2000_freq_cells[cdma2000_bandclass]), sizeof(rrmcm_rmif_cdma2000_freq_cells_t));

        }
        else
        {
            RRM_MEMSET( &(p_commit_inter_rat_ncl->cdma2000_freq_cells[p_commit_inter_rat_ncl->num_valid_cdma2000_freq_cells]),
                        RRM_ZERO, sizeof(rrmcm_rmif_cdma2000_freq_cells_t));

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                       RRM_DETAILED,"Commiting a New Record at position [%d] in NCL list", 
                            p_commit_inter_rat_ncl->num_valid_cdma2000_freq_cells);
            RRM_MEMCPY(&(p_commit_inter_rat_ncl->cdma2000_freq_cells[p_commit_inter_rat_ncl->num_valid_cdma2000_freq_cells]),
                    &(p_cdma2000_freq_cells[cdma2000_bandclass]), sizeof(rrmcm_rmif_cdma2000_freq_cells_t));
            
            p_commit_inter_rat_ncl->num_valid_cdma2000_freq_cells++;
        }

    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_check_reconf_1xrtt_ncl_list
 * Inputs         : p_cell_context,p_inter_rat_ncl
 * Outputs        : None
 * Returns        : Void
 * Description    :rrm_check_reconf_1xrtt_ncl_list 
 ****************************************************************************/
U8
rrm_check_reconf_1xrtt_ncl_list(inter_rat_ncl_t                 *p_inter_rat_ncl ,
                                rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
                                U16                              valid_cdma2000_freq_cells,
                                S32                              *XRTT_FOUND )
{
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma               = RRM_PNULL;
    U8                                            valid_1xrtt_cell_index    = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_irat_cdma     = &(p_reconfig_req_from_mif->ran_info.mobility_params.
                          idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    if(p_irat_cdma->cdma2000_cell_param.bitmask &
            RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_1xrtt_cell_index = RRM_ZERO;
                valid_1xrtt_cell_index < valid_cdma2000_freq_cells;
                valid_1xrtt_cell_index++)
        {
            (*XRTT_FOUND) = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_1xrtt.cdma2000_1xrtt_cell_id),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[valid_1xrtt_cell_index].CID),
                    RRMCM_RMIF_CDMA2000_1XRTT_CELL_ID_LENGTH);
            if(!(*XRTT_FOUND))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "XRTT type at [%d] idx in inter rat ncl matched with irat cdma entry",valid_1xrtt_cell_index );
                break;
            }
        }
    }
  RRM_UT_TRACE_EXIT();
  return valid_1xrtt_cell_index;
}
/****************************************************************************
 * Function Name  : rrm_check_reconf_hrpd_ncl_list
 * Inputs         : p_cell_context,p_inter_rat_ncl
 * Outputs        : None
 * Returns        : Void
 * Description    :rrm_check_reconf_hrpd_1xrtt_ncl_list
 ****************************************************************************/
U8
rrm_check_reconf_hrpd_ncl_list(inter_rat_ncl_t                 *p_inter_rat_ncl ,
                               rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif,
                               U16                              valid_cdma2000_freq_cells,                       
                               S32                             *HRPD_FOUND )
{
    RRM_UT_TRACE_ENTER();
    rrmcm_idle_mode_mobility_irat_cdma_params_t  *p_irat_cdma               = RRM_PNULL;
    U8                                           valid_hrpd_cell_index      = RRM_ZERO;
    p_irat_cdma     = &(p_reconfig_req_from_mif->ran_info.mobility_params.
                              idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params);

    if(p_irat_cdma->cdma2000_cell_param.bitmask &
            RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG)
    {
        for(valid_hrpd_cell_index = RRM_ZERO;
                valid_hrpd_cell_index < valid_cdma2000_freq_cells;
                valid_hrpd_cell_index++)
        {
            (*HRPD_FOUND) = RRM_MEMCMP(&(p_irat_cdma->cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id),
                                       &(p_inter_rat_ncl->cdma2000_freq_cells[valid_hrpd_cell_index].CID),
                                       RRM_CDMA2000_HRPD_CELL_ID_LENGTH);
            if(!(*HRPD_FOUND))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "HRPD type at [%d] idx in inter rat ncl matched with irat cdma entry", valid_hrpd_cell_index );
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return valid_hrpd_cell_index;
}

/*Klockwork_fix_end*/

rrm_void_t
commit_reconf_hrpd_1xrtt_ncl_list
(
 rrm_cell_context_t   *p_cell_context,
 rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif
)
{
    U16    valid_cdma2000_freq_cells                          = RRM_ZERO;
    U16    cdma2000_freq_cells                                = RRM_ZERO;
    U8     valid_1xrtt_cell_index                             = RRM_ZERO;
    U8     valid_hrpd_cell_index                              = RRM_ZERO;
    S32    HRPD_FOUND                                         = RRM_ONE;
    S32    XRTT_FOUND                                         = RRM_ONE;
    U8     tmp_num_valid_cdma2000_freq_cells                  = RRM_ZERO;
    
    inter_rat_ncl_t     *p_inter_rat_ncl                      = RRM_PNULL;

    rrmcm_rmif_cdma2000_freq_cells_t  
       tmp_cdma2000_freq_cells[RRMCM_RMIF_NUM_CDMA2000_FREQ_CELLS] = {{0}};

    RRM_UT_TRACE_ENTER();

    p_inter_rat_ncl = &(p_reconfig_req_from_mif->ran_info.ncl_params.inter_rat_ncl);


    valid_cdma2000_freq_cells = p_inter_rat_ncl->num_valid_cdma2000_freq_cells;
    
    /*Klockwork_fix_start*/
    valid_1xrtt_cell_index = rrm_check_reconf_1xrtt_ncl_list(p_inter_rat_ncl, p_reconfig_req_from_mif,
                                                             valid_cdma2000_freq_cells, &XRTT_FOUND);
    valid_hrpd_cell_index =  rrm_check_reconf_hrpd_ncl_list(p_inter_rat_ncl, p_reconfig_req_from_mif,
                                                            valid_cdma2000_freq_cells, &HRPD_FOUND);
    /*Klockwork_fix_end*/

    for(cdma2000_freq_cells = RRM_ZERO;
            cdma2000_freq_cells < valid_cdma2000_freq_cells; cdma2000_freq_cells++)
    {
        if(!XRTT_FOUND || !HRPD_FOUND)
        {
            if((cdma2000_freq_cells == valid_hrpd_cell_index) ||
                    (cdma2000_freq_cells == valid_1xrtt_cell_index))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                          " XRTT/ HRPD type at [%d] idx in inter rat ncl ", cdma2000_freq_cells );
                continue;
            }
        }
       
        /* 
        ** Prepare NCL list that was given to L3 at the time of cell reconfiguration procedure 
        */
        RRM_MEMCPY(&(tmp_cdma2000_freq_cells[tmp_num_valid_cdma2000_freq_cells]),
                    &(p_inter_rat_ncl->cdma2000_freq_cells[cdma2000_freq_cells]),
                    sizeof(rrmcm_rmif_cdma2000_freq_cells_t));
        tmp_num_valid_cdma2000_freq_cells++;
    }

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
              " [%d] numner of records recieved in reconfig req for NCL", tmp_num_valid_cdma2000_freq_cells );
    /* 
    ** Commit NCL list ( that was given to L3 at the time of cell reconfiguration procedure) 
    ** in Cell Context.
    */
    commit_cell_reselection_params_cdma2000(&(p_cell_context->ran_info.ncl_params.inter_rat_ncl),
                                              tmp_cdma2000_freq_cells , 
                                              tmp_num_valid_cdma2000_freq_cells 
                                           );
    RRM_UT_TRACE_EXIT();
}
/* SPR 10934 Fix End */
/*Klockwork_fix_start*/

/****************************************************************************
 * Function Name  : rrm_commit_inter_rat_ncl_utra_freq_cells
 * Inputs         : p_cell_context,p_inter_rat_ncl,p_inter_rat_ncl_commit
 * Outputs        : None
 * Returns        : Void
 * Description    : Commits Utran freq cells
 ****************************************************************************/
rrm_void_t
rrm_commit_inter_rat_ncl_utra_freq_cells(/*SPR 17777 +-*/ 
                                         inter_rat_ncl_t     *p_inter_rat_ncl,
                                         inter_rat_ncl_t     *p_inter_rat_ncl_commit)
{
    U8                             utra_freq = RRM_ZERO;
   U8                             index = RRM_ZERO;
   RRM_UT_TRACE_ENTER();
   for( utra_freq = RRM_ZERO;( utra_freq < p_inter_rat_ncl->num_valid_utran_freq_cell ) &&
                              (utra_freq < RRM_MAX_UTRAN_NBRS);
                                utra_freq++ )
   {
       if( p_inter_rat_ncl->utran_freq_cells[utra_freq].bitmask & 
                             RRM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT)
       {
           /* RECONFIG SELF REVIEW FIX START */
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].bitmask |=
                            RRM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT;
           /* RECONFIG SELF REVIEW FIX END */
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].cell_access_mode =
           p_inter_rat_ncl->utran_freq_cells[utra_freq].cell_access_mode;
       }
       if( p_inter_rat_ncl->utran_freq_cells[utra_freq].bitmask &
                               RRM_UTRAN_FREQ_CSG_ID_PRESENT )
       {
           /* RECONFIG SELF REVIEW FIX START */
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].bitmask |=
                                   RRM_UTRAN_FREQ_CSG_ID_PRESENT;

           for( index = RRM_ZERO; index < RRM_OAM_MAX_NUM_CSG_OCTETS;
                                   index++ )
           {
               p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].csg_identity[index] =
               p_inter_rat_ncl->utran_freq_cells[utra_freq].csg_identity[index];
           } 
           /* RECONFIG SELF REVIEW FIX END */
       }
       if( p_inter_rat_ncl->utran_freq_cells[utra_freq].bitmask &
                                  RRM_UTRAN_FREQ_UARFCNUL_PRESENT )
       {
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].bitmask |= 
                                                RRM_UTRAN_FREQ_UARFCNUL_PRESENT;
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uarfcnul =
           p_inter_rat_ncl->utran_freq_cells[utra_freq].uarfcnul;
       }
      
       /* Fix 9926 Start */
       if( p_inter_rat_ncl->utran_freq_cells[utra_freq].rai.lai.plmn_identity.
                                  presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG )
       /* Fix 9926 End */
       {
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].rai.lai.plmn_identity.presence_bitmask |=
                                          PLMN_IDENTITY_MCC_PRESENCE_FLAG;
 
           for( index = RRM_ZERO; index < MCC_OCTET_SIZE ; index++ )
           {
               p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].rai.lai.plmn_identity.mcc[index] =
               p_inter_rat_ncl->utran_freq_cells[utra_freq].rai.lai.plmn_identity.mcc[index];
           }
       }
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].rai.lai.plmn_identity.mnc = 
       p_inter_rat_ncl->utran_freq_cells[utra_freq].rai.lai.plmn_identity.mnc;
       for( index = RRM_ZERO; index < RRM_OAM_MAX_NUM_LAC_OCTETS ; index++)
       {
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].rai.lai.lac[index] =
           p_inter_rat_ncl->utran_freq_cells[utra_freq].rai.lai.lac[index];
       }
       
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].rai.rac = 
       p_inter_rat_ncl->utran_freq_cells[utra_freq].rai.rac;

       if( p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uc_id.bitmask & 
                                   RRM_UTRAN_EXTN_RNC_ID_PRESENT )
       {
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uc_id.bitmask |=
                                    RRM_UTRAN_EXTN_RNC_ID_PRESENT;
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uc_id.rnc_id =
           p_inter_rat_ncl->utran_freq_cells[utra_freq].uc_id.rnc_id;
       }
       for(index = RRM_ZERO; index < RRM_UTRAN_CELL_IDENTITY_OCTETS; index++ )
       {      
           p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uc_id.cell_id[index] =
           p_inter_rat_ncl->utran_freq_cells[utra_freq].uc_id.cell_id[index]; 
       }
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uc_id.extended_rnc_id =
       p_inter_rat_ncl->utran_freq_cells[utra_freq].uc_id.extended_rnc_id;

       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].pci = 
       p_inter_rat_ncl->utran_freq_cells[utra_freq].pci;
  
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].ura =
       p_inter_rat_ncl->utran_freq_cells[utra_freq].ura;
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].uarfcndl =
       p_inter_rat_ncl->utran_freq_cells[utra_freq].uarfcndl;
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].pcpich_scrambling_code=
       p_inter_rat_ncl->utran_freq_cells[utra_freq].pcpich_scrambling_code;
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].pcpich_tx_power=
       p_inter_rat_ncl->utran_freq_cells[utra_freq].pcpich_tx_power;
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].blacklisted=
       p_inter_rat_ncl->utran_freq_cells[utra_freq].blacklisted;
       /* SRVCC SUPPORT START */
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].ps_ho_supported=
       p_inter_rat_ncl->utran_freq_cells[utra_freq].ps_ho_supported;
       p_inter_rat_ncl_commit->utran_freq_cells[utra_freq].voip_capable=
       p_inter_rat_ncl->utran_freq_cells[utra_freq].voip_capable;                  
       /* SRVCC SUPPORT END */
   }
   RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :  rrm_commit_inter_rat_ncl_geran_freq_cells
 * Inputs         : p_cell_context,p_inter_rat_ncl,p_inter_rat_ncl_commit
 * Outputs        : None
 * Returns        : Void
 * Description    : Commits Geran freq cells
 ****************************************************************************/
 rrm_void_t
 rrm_commit_inter_rat_ncl_geran_freq_cells(/*SPR 17777 +-*/
                                          inter_rat_ncl_t     *p_inter_rat_ncl,
                                          inter_rat_ncl_t     *p_inter_rat_ncl_commit)
{

   U8                             index = RRM_ZERO;
   U8                             geran_greq = RRM_ZERO;
   RRM_UT_TRACE_ENTER();
   for( geran_greq = RRM_ZERO; (geran_greq < p_inter_rat_ncl->num_valid_geran_cell)&&
                               (geran_greq < RRM_MAX_GERAN_NBRS); geran_greq++ )
   {
       if(p_inter_rat_ncl->geran_freq_cells[geran_greq].bitmask & RRM_GERAN_FREQ_CELL_CSG_ID_PRESENT)
       {
           /* RECONFIG SELF REVIEW FIX START */
           p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].bitmask |=
                                         RRM_GERAN_FREQ_CELL_CSG_ID_PRESENT;
           /* RECONFIG SELF REVIEW FIX END */
           for( index = RRM_ZERO; index < RRM_OAM_MAX_NUM_CSG_OCTETS ;index++)
           {
               p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].csg_id[index] =
               p_inter_rat_ncl->geran_freq_cells[geran_greq].csg_id[index];
           }
       }
       if( p_inter_rat_ncl->geran_freq_cells[geran_greq].bitmask & RRM_GERAN_FREQ_CELL_ACCESS_MODE_PRESENT)
       {
           /* RECONFIG SELF REVIEW FIX START */
           p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].bitmask |=
                                            RRM_GERAN_FREQ_CELL_ACCESS_MODE_PRESENT;
           /* RECONFIG SELF REVIEW FIX END */
           p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].cell_access_mode =
           p_inter_rat_ncl->geran_freq_cells[geran_greq].cell_access_mode; 
       }
       if( p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].lai.plmn_identity.presence_bitmask &
             PLMN_IDENTITY_MCC_PRESENCE_FLAG )
       {
            p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].lai.plmn_identity.presence_bitmask |=
                                    PLMN_IDENTITY_MCC_PRESENCE_FLAG;
           for( index = RRM_ZERO; index < MCC_OCTET_SIZE; index++)
           {
               p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].lai.plmn_identity.mcc[index] =
               p_inter_rat_ncl->geran_freq_cells[geran_greq].lai.plmn_identity.mcc[index];
           }
       }
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].lai.plmn_identity.mnc =
       p_inter_rat_ncl->geran_freq_cells[geran_greq].lai.plmn_identity.mnc;

       for(index = RRM_ZERO; index < RRM_OAM_MAX_NUM_LAC_OCTETS; index++)
       {
           p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].lai.lac[index] =
           p_inter_rat_ncl->geran_freq_cells[geran_greq].lai.lac[index];
       }   
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].bsic = 
       p_inter_rat_ncl->geran_freq_cells[geran_greq].bsic;
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].cell_id = 
       p_inter_rat_ncl->geran_freq_cells[geran_greq].cell_id;

       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].band_indicator =
       p_inter_rat_ncl->geran_freq_cells[geran_greq].band_indicator;
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].bcch_arfcn=
       p_inter_rat_ncl->geran_freq_cells[geran_greq].bcch_arfcn;
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].pci=
       p_inter_rat_ncl->geran_freq_cells[geran_greq].pci;
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].offset_freq = 
       p_inter_rat_ncl->geran_freq_cells[geran_greq].offset_freq; 
       p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].blacklisted=
       p_inter_rat_ncl->geran_freq_cells[geran_greq].blacklisted;
	/* SPR 15393 Fix Start */
       if( p_inter_rat_ncl->geran_freq_cells[geran_greq].bitmask & RRM_GERAN_FREQ_CELL_RAC_PRESENT)
       {
           p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].bitmask |=
                                            RRM_GERAN_FREQ_CELL_RAC_PRESENT;
           p_inter_rat_ncl_commit->geran_freq_cells[geran_greq].rac=
           p_inter_rat_ncl->geran_freq_cells[geran_greq].rac; 
       }
	/* SPR 15393 Fix Stop */

   }
  RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

rrm_void_t
rrm_commit_inter_rat_ncl_utran_freq_cells( rrm_cell_context_t   *p_cell_context)
{

    inter_rat_ncl_t         *p_inter_rat_ncl= RRM_PNULL;
    inter_rat_ncl_t               *p_inter_rat_ncl_commit = RRM_PNULL; /*info to commit */
    /* SPR 10934 Fix Start */
    rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req_from_mif = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_reconfig_req_from_mif = (rrmcm_rmif_cell_reconfig_req_t *)(p_cell_context->p_new_reconfig_data);
    /* SPR 10934 Fix End */

    p_inter_rat_ncl  = &(((rrmcm_rmif_cell_reconfig_req_t *)
                             (p_cell_context->p_new_reconfig_data))->ran_info.ncl_params.
                              inter_rat_ncl);
    p_inter_rat_ncl_commit = &(p_cell_context->ran_info.ncl_params.inter_rat_ncl);

    p_inter_rat_ncl_commit->num_valid_utran_freq_cell = 
        p_inter_rat_ncl->num_valid_utran_freq_cell;
    /*Klockwork_fix_start*/
    /*SPR 17777 +-*/
    rrm_commit_inter_rat_ncl_utra_freq_cells(p_inter_rat_ncl ,p_inter_rat_ncl_commit);
    /*Klockwork_fix_end*/
   
   p_inter_rat_ncl_commit->num_valid_geran_cell = 
   p_inter_rat_ncl->num_valid_geran_cell;

   /*coverity 25396, MAX_GERAN_FREQ replaced with RRM_MAX_GERAN_FREQ, aditya rel1.3.1*/
   /*Klockwork_fix_start*/
    /*SPR 17777 +-*/
   rrm_commit_inter_rat_ncl_geran_freq_cells(p_inter_rat_ncl ,p_inter_rat_ncl_commit);
   /*Klockwork_fix_end*/
    
   /* SPR 10934 Fix Start */
   commit_reconf_hrpd_1xrtt_ncl_list( p_cell_context, p_reconfig_req_from_mif);
   /* SPR 10934 Fix End */
    
   RRM_UT_TRACE_EXIT();
}

/*SPR 10329:fix start*/
/*SPR 16494 START*/
/*code deleted*/
/*SPR 16494 END*/
/*SPR 10329:end*/

/*10329_START*/
/*********************************************************************************
 * Function Name  :search_enb_id_from_global_list_for_reconfig 
 * Inputs         : rrm_global_enb_id_key_t *p_ncl_list_plmn_info,  
 *                : rrm_enb_gu_group_id_list_t *p_enb_gu_group_id_list
 * Outputs        : None
 * Returns        : rrm_enb_gu_group_id_node_t
 * Description    : searches enb_id present in NCL and if found then upadate eNb 
 *                  NCL pointer.
 *                  
 *********************************************************************************/
rrm_global_context_t *p_g_rrm_cell_ctx;

rrm_void_t 
search_enb_id_from_global_list_for_reconfig
(
    /*SPR 17777 +-*/
    rrm_oam_eutran_global_cell_id_t     cell_id,
    S32                               cell_access_mode,
    rrm_enb_gu_group_id_node_t       **p_enb_gu_group_id
)
{

    U32     cell_id_cpy = RRM_ZERO;
    U32     cell_id_in_ncl = RRM_ZERO;
    U32     cell_id_stored_in_enb = RRM_ZERO;
    U32     cell_id_copied_from_enbid = RRM_ZERO;
    rrm_enb_gu_group_id_node_t *p_enb_id_node = RRM_PNULL;
    YLNODE *p_node = RRM_PNULL;
    p_node = ylFirst (&p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);
    RRM_UT_TRACE_ENTER();   

    while(p_node)
    {
        p_enb_id_node = (rrm_enb_gu_group_id_node_t *)p_node;

        if(RRM_ZERO == (RRM_MEMCMP(&(cell_id.primary_plmn_id), &p_enb_id_node->enb_key_id.plmn_id ,
                        sizeof(rrm_oam_cell_plmn_info_t))))
        {
            RRM_MEMCPY(&cell_id_cpy,&cell_id.cell_identity, RRM_FOUR);
            cell_id_in_ncl = RRM_NTOHL(cell_id_cpy);

            RRM_MEMCPY(&cell_id_copied_from_enbid,p_enb_id_node->enb_key_id.eNb_id, RRM_FOUR);
            cell_id_stored_in_enb = RRM_NTOHL(cell_id_copied_from_enbid) ;  
            /*SPR 10329:fix start*/
            /*10329_START*/
            if(cell_id_stored_in_enb == cell_id_in_ncl)
            /*10329_end*/
            {
                if(RRM_OAM_ACCESS_MODE_OPEN == cell_access_mode)
                {
                    cell_id_in_ncl =  cell_id_in_ncl >> RRM_TWELVE;
                    cell_id_stored_in_enb = cell_id_stored_in_enb >> RRM_TWELVE;
                    if (RRM_ZERO == (cell_id_in_ncl ^ cell_id_stored_in_enb))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "cell access mode = [%d] matched with enb_id ",
                                cell_access_mode);
                        *p_enb_gu_group_id = p_enb_id_node ;
                    }
                }
                else 
                {
                    cell_id_in_ncl =  cell_id_in_ncl >> RRM_FOUR;
                    cell_id_stored_in_enb = cell_id_stored_in_enb >> RRM_FOUR;
                    if (RRM_ZERO == (cell_id_in_ncl ^ cell_id_stored_in_enb))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "cell access mode = [%d] cell_id matched with enb_id ",
                                cell_access_mode);

                        *p_enb_gu_group_id = p_enb_id_node ;
                    }
                }
            }
        }
        p_node = ylNext(p_node);
    }
    RRM_UT_TRACE_EXIT();
}
/*10329_END*/

/* BUG_371 FIX START */

rrm_void_t
rrm_commit_ncl_params( rrm_cell_context_t   *p_cell_context )
{

    ncl_params_t            *p_ncl_params = RRM_PNULL;
    ncl_params_t                  *p_ncl_params_commit = RRM_PNULL; /*info to commit in cell context*/
    U8                             intra_freq = RRM_ZERO;
    U8                             inter_freq = RRM_ZERO;
    U8                             index = RRM_ZERO;
    U8                             commit_intra_freq = RRM_ZERO;
    U8                             commit_inter_freq = RRM_ZERO;
    U8                             cell_count = RRM_ZERO;
    rrm_bool_et                    is_cell_present_in_list = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_ncl_params  = &(((rrmcm_rmif_cell_reconfig_req_t *)
                             (p_cell_context->p_new_reconfig_data))->ran_info.ncl_params
                              );

    p_ncl_params_commit = &(p_cell_context->ran_info.ncl_params ) ;

    if( p_ncl_params->bitmask & RRMCM_RMIF_LTE_NCL_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_ncl_params_commit->bitmask |= RRMCM_RMIF_LTE_NCL_PRESENT;
        /*RECONFIG SELF REVIEW FIX END*/

        for(intra_freq = RRM_ZERO; (intra_freq < p_ncl_params->lte_ncl.num_valid_intra_freq_cell)
                && (intra_freq < MAX_INTRA_FREQ_CELLS);
                intra_freq++ )
        {
            is_cell_present_in_list = RRM_FALSE;

            for(cell_count = RRM_ZERO ; cell_count < p_ncl_params_commit->lte_ncl.num_valid_intra_freq_cell ; cell_count++)
            {
                /*10329_START*/
                if ((( p_ncl_params_commit->lte_ncl.intra_freq_cells[cell_count].phy_cell_id ==
                                p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].phy_cell_id)) &&
                        (RRM_ZERO == (RRM_MEMCMP(&p_ncl_params_commit->lte_ncl.intra_freq_cells[cell_count].cell_id.primary_plmn_id,
                                                 &p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].cell_id.primary_plmn_id,
                                                 sizeof(rrm_oam_cell_plmn_info_t)))))
                    /*10329_END*/
                {
                    commit_intra_freq = cell_count;
                    is_cell_present_in_list = RRM_TRUE;
                    break;
                }
            }
            if(RRM_FALSE == is_cell_present_in_list)
            {
                commit_intra_freq = p_ncl_params_commit->lte_ncl.num_valid_intra_freq_cell;
                p_ncl_params_commit->lte_ncl.num_valid_intra_freq_cell++;
            }
                 
                    
            if(p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                  RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                     RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].cell_id =
                p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].cell_id;
            }
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                           RRMCM_RMIF_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT )
            {
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].cio =
                p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].cio;
            }
 
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                     RRMCM_RMIF_INTRA_FREQ_Q_OFFSET_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                      RRMCM_RMIF_INTRA_FREQ_Q_OFFSET_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].q_offset =
                 p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].q_offset;
            }
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                     RRMCM_RMIF_INTER_FREQ_R_STX_POWER_PRESENT )
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                     RRMCM_RMIF_INTER_FREQ_R_STX_POWER_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].r_stx_power =
                p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].r_stx_power;
            }
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                     RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT )
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                      RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].cell_access_mode =
                p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].cell_access_mode;
            }
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                 RRMCM_RMIF_CSG_ID_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                     RRMCM_RMIF_CSG_ID_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                for( index = RRM_ZERO ; index < RRM_OAM_MAX_NUM_CSG_OCTETS ; index++)
                {
                    p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].csg_identity[index] =
                    p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].csg_identity[index];
                }
            }
            /* changes Start */
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                  RRMCM_RMIF_INTRA_FREQ_TAC_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                     RRMCM_RMIF_INTRA_FREQ_TAC_PRESENT;

                for(index = RRM_ZERO; index < MAX_TAC_SIZE ; index++)
                {
                    p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].tac[index]=
                    p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].tac[index];
                }
                /*RECONFIG SELF REVIEW FIX END*/
            }
 
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask & 
                                RRMCM_RMIF_EUTRAN_STRENGTH_RSRP_PRESENT)
            {
            }

            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                RRMCM_RMIF_EUTRAN_STRENGTH_RSRQ_PRESENT )
            {
            }

            p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].broadcast_status = 
            p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].broadcast_status;
                
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                                    RRMCM_RMIF_INTRA_FREQ_HO_STATUS_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                                     RRMCM_RMIF_INTRA_FREQ_HO_STATUS_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].ho_status = 
                        p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].ho_status;
            }

             /**13956_fix_start*/
            if( p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask &
                    RRMCM_RMIF_INTRA_FREQ_INTERFERENCE_SCHEME_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].bitmask |=
                    RRMCM_RMIF_INTRA_FREQ_INTERFERENCE_SCHEME_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].interference_scheme =
                    p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].interference_scheme;
            }
            /*13956_fix_end*/
            /**13867_fix_start*/
            if(p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].bitmask & RRMCM_RMIF_INTRA_FREQ_X2_STATUS_PRESENT)
             {
              p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].x2_status = 
              p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].x2_status;
             } 
             /**13867_fix_end*/

           
           /* Changes End */
            p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].blacklisted = 
            p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].blacklisted;
            
            p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].x2_link_up_status = 
            p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].x2_link_up_status;

            p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].phy_cell_id =
                p_ncl_params->lte_ncl.intra_freq_cells[intra_freq].phy_cell_id;

            /*10329_START*/
            search_enb_id_from_global_list_for_reconfig(/*SPR 17777 +-*/
                    p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].cell_id,
                    p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].cell_access_mode,
                    &p_ncl_params_commit->lte_ncl.intra_freq_cells[commit_intra_freq].p_enb_gu_group_id);
            /*10329_END*/
        }

        for(inter_freq = RRM_ZERO; (inter_freq < p_ncl_params->lte_ncl.num_valid_inter_freq_cell)&&
                                    (inter_freq < MAX_INTER_FREQ_CELLS) ; inter_freq++  )
        {
            is_cell_present_in_list = RRM_FALSE;

            for(cell_count = RRM_ZERO ; cell_count < p_ncl_params_commit->lte_ncl.num_valid_inter_freq_cell ; cell_count++)
            {
                /*10329_START*/
                if (( p_ncl_params_commit->lte_ncl.inter_freq_cells[cell_count].phy_cell_id ==
                            p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].phy_cell_id) &&
                        (RRM_ZERO == (RRM_MEMCMP(&p_ncl_params_commit->lte_ncl.inter_freq_cells[cell_count].cell_id.primary_plmn_id,
                                                 &p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].cell_id.primary_plmn_id,
                                                 sizeof(rrm_oam_cell_plmn_info_t)))))
                    /*0329_END*/
                {
                    commit_inter_freq = cell_count;
                    is_cell_present_in_list = RRM_TRUE;
                    break;
                }
            }
            if(RRM_FALSE == is_cell_present_in_list)
            {
                commit_inter_freq = p_ncl_params_commit->lte_ncl.num_valid_inter_freq_cell;
                p_ncl_params_commit->lte_ncl.num_valid_inter_freq_cell++;
            }
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask &
                    RRMCM_RMIF_INTER_FREQ_GLOBAL_CELL_ID_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].bitmask |=
                    RRMCM_RMIF_INTER_FREQ_GLOBAL_CELL_ID_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].cell_id =
                 p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].cell_id;

            }
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask &
                                RRMCM_RMIF_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].bitmask |=
                                     RRMCM_RMIF_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].cio =
                p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].cio;
            }
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask & 
                                RRMCM_RMIF_INTER_FREQ_R_STX_POWER_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].bitmask |=
                                      RRMCM_RMIF_INTER_FREQ_R_STX_POWER_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].r_stx_power =
                   p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].r_stx_power;
            }
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask &
                                   RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].bitmask |=
                                     RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT;
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].cell_access_mode =
                  p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].cell_access_mode;
            }
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask &
                                  RRMCM_RMIF_CSG_ID_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].bitmask |=
                                      RRMCM_RMIF_CSG_ID_PRESENT;

                for( index = RRM_ZERO; index < RRM_OAM_MAX_NUM_CSG_OCTETS ; index++ )
                {
                    p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].csg_identity[index] =
                    p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].csg_identity[index]; 
                }
                /*RECONFIG SELF REVIEW FIX END*/
            }
            /* Changes Start */
	    /*coverity 25403, commented since code has no effect, , rel1.3.1*/
            p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].broadcast_status = 
                p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].broadcast_status;
                /*RECONFIG SELF REVIEW FIX END*/
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask & 
                                             RRMCM_RMIF_INTER_FREQ_TAC_PRESENT )
            {
                for( index = RRM_ZERO; index < MAX_TAC_SIZE ; index++)
                {
                    p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].tac[index] =
                    p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].tac[index];
                } 
            } 
            if( p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].bitmask &
                                    RRMCM_RMIF_INTER_FREQ_HO_STATUS_PRESENT)
            {
                /* RECONFIG SELF REVIEW FIX START */
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].bitmask |=
                                      RRMCM_RMIF_INTER_FREQ_HO_STATUS_PRESENT;
 
                /*RECONFIG SELF REVIEW FIX END*/
                p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].ho_status = 
                        p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].ho_status;
            }

            p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].eutra_carrier_arfcn =
            p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].eutra_carrier_arfcn;

            p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].x2_link_up_status = 
            p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].x2_link_up_status;

            p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].x2_status = 
            p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].x2_status;
            /* changes end */
            p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].phy_cell_id =
            p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].phy_cell_id;

            p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].blacklisted = 
                p_ncl_params->lte_ncl.inter_freq_cells[inter_freq].blacklisted;

            /*10329_START*/
            search_enb_id_from_global_list_for_reconfig(/*SPR 17777 +-*/
                    p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].cell_id,
                    p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].cell_access_mode,
                    &p_ncl_params_commit->lte_ncl.inter_freq_cells[commit_inter_freq].p_enb_gu_group_id);
            /*10329_END*/
        }
    }
    if(p_ncl_params->bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
    {
         /* RECONFIG SELF REVIEW FIX START */
         p_ncl_params_commit->bitmask |= RRMCM_RMIF_INTER_RAT_NCL_PRESENT;
         /*RECONFIG SELF REVIEW FIX END*/
         p_ncl_params_commit->inter_rat_ncl.num_valid_utran_freq_cell = 
         p_ncl_params->inter_rat_ncl.num_valid_utran_freq_cell;


         rrm_commit_inter_rat_ncl_utran_freq_cells(p_cell_context);
    }

    RRM_UT_TRACE_EXIT();

}



rrm_void_t
rrm_commit_common_eutran_params( rrm_cell_context_t   *p_cell_context)
{


    common_eutran_params_t        *p_common_eutran_params = RRM_PNULL;
    common_eutran_params_t              *p_common_eutran_params_commit = RRM_PNULL; /*info to commit */
    RRM_UT_TRACE_ENTER();

    p_common_eutran_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                             (p_cell_context->p_new_reconfig_data))->ran_info.common_eutran_params
                              );

    p_common_eutran_params_commit = &(p_cell_context->ran_info.common_eutran_params) ;

    *p_common_eutran_params_commit = *p_common_eutran_params;
    
    RRM_UT_TRACE_EXIT(); 
}



rrm_void_t
rrm_commit_rf_params( rrm_cell_context_t   *p_cell_context)
{
    rf_params_t
                                                   *p_rf_params = RRM_PNULL; /* info from mif :*/
    rf_params_t                                    *p_rf_params_commit = RRM_PNULL; /*info to commit */
    RRM_UT_TRACE_ENTER();

    p_rf_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.rf_params
                            );

    p_rf_params_commit = &(p_cell_context->ran_info.rf_params) ; 

    if( p_rf_params->rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_EARFCN_PRESENT)
    {
       /* RECONFIG SELF REVIEW FIX START */
        p_rf_params_commit->rf_configurations.ul_earfcn =  p_rf_params->rf_configurations.ul_earfcn;

        p_rf_params_commit->rf_configurations.bitmask |= RRMCM_RMIF_RF_CONFIGURATION_UL_EARFCN_PRESENT;
        /*RECONFIG SELF REVIEW FIX END*/
    }
    if( p_rf_params->rf_configurations.bitmask & RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rf_params_commit->rf_configurations.bitmask |= RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT;

        /*RECONFIG SELF REVIEW FIX END*/
        p_rf_params_commit->rf_configurations.ul_bandwidth =  p_rf_params->rf_configurations.ul_bandwidth;
    }
    /* RECONFIG SELF REVIEW FIX START */
    if( p_rf_params->rf_configurations.bitmask & RRMCM_RMIF_MAX_RS_EPRE_PRESENT )
    {
        p_rf_params_commit->rf_configurations.bitmask |= RRMCM_RMIF_MAX_RS_EPRE_PRESENT;
        p_rf_params_commit->rf_configurations.max_rs_epre =
        p_rf_params->rf_configurations.max_rs_epre;
    }
    
    p_rf_params_commit->rf_configurations.frequency_band_indicator =
    p_rf_params->rf_configurations.frequency_band_indicator;
  
    p_rf_params_commit->rf_configurations.dl_earfcn =
    p_rf_params->rf_configurations.dl_earfcn;

    p_rf_params_commit->rf_configurations.dl_bandwidth =
    p_rf_params->rf_configurations.dl_bandwidth;

    p_rf_params_commit->rf_configurations.reference_signal_power =
    p_rf_params->rf_configurations.reference_signal_power;

    p_rf_params_commit->rf_configurations.phy_cell_id =
    p_rf_params->rf_configurations.phy_cell_id;

    p_rf_params_commit->rf_configurations.psch_power_offset =
    p_rf_params->rf_configurations.psch_power_offset;

    p_rf_params_commit->rf_configurations.ssch_power_offset =
    p_rf_params->rf_configurations.ssch_power_offset;

    p_rf_params_commit->rf_configurations.pbch_power_offset =
    p_rf_params->rf_configurations.pbch_power_offset;
   /*RECONFIG SELF REVIEW FIX END*/
    RRM_UT_TRACE_EXIT();
}




rrm_void_t
rrm_commit_rrc_timers_and_constants(rrm_cell_context_t    *p_cell_context)
{
    rrc_timers_and_constants_t
                                                   *p_timer_n_const = RRM_PNULL; /* info from mif :*/
    rrc_timers_and_constants_t                     *p_timer_n_const_commit = RRM_PNULL; /*info to commit */
    RRM_UT_TRACE_ENTER();

    p_timer_n_const = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.rrc_timers_and_constants
                            );

    p_timer_n_const_commit = &(p_cell_context->ran_info.rrc_timers_and_constants);

    if(p_timer_n_const->bitmask & RRMCM_RMIF_RRC_TIMERS_PRESENT)
    {
        p_timer_n_const_commit->rrc_timers = p_timer_n_const->rrc_timers;
        /* RECONFIG SELF REVIEW FIX START */
        p_timer_n_const_commit->bitmask |= RRMCM_RMIF_RRC_TIMERS_PRESENT;
        /* RECONFIG SELF REVIEW FIX START */
    }
    if(p_timer_n_const->bitmask & RRMCM_RMIF_RRC_CONSTANTS_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_timer_n_const_commit->bitmask |= RRMCM_RMIF_RRC_CONSTANTS_PRESENT;
        /* RECONFIG SELF REVIEW FIX START */
        p_timer_n_const_commit->rrc_constants = p_timer_n_const->rrc_constants;
        
    }
    
    RRM_UT_TRACE_EXIT();
}


rrm_void_t
rrm_commit_idle_mode_mobility_geran_list_params(rrm_cell_context_t    *p_cell_context)
{
    idle_mode_mobility_irat_geran_params_t
                                                   *p_irat_geran_list = RRM_PNULL; /* info from mif :*/
    idle_mode_mobility_irat_geran_params_t         *p_irat_geran_list_commit = RRM_PNULL; /*info to commit */
    RRM_UT_TRACE_ENTER();

    p_irat_geran_list = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                           idle_mode_mobility_params.idle_mode_mobility_irat_geran_params );

    p_irat_geran_list_commit = &(p_cell_context->ran_info.mobility_params.
                                  idle_mode_mobility_params.idle_mode_mobility_irat_geran_params );
   
      

    /* RECONFIG SELF REVIEW FIX START */
    p_irat_geran_list_commit->irat_eutra_to_geran_reselection_params.bitmask |= 
    p_irat_geran_list->irat_eutra_to_geran_reselection_params.bitmask;
    /*RECONFIG SELF REVIEW FIX END*/

    p_irat_geran_list_commit->irat_eutra_to_geran_reselection_params.t_reselection_geran =
    p_irat_geran_list->irat_eutra_to_geran_reselection_params.t_reselection_geran;

    if(p_irat_geran_list->irat_eutra_to_geran_reselection_params.bitmask &
               RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT)
    {
       /* RECONFIG SELF REVIEW FIX START */
        p_irat_geran_list_commit->irat_eutra_to_geran_reselection_params.bitmask |=
                                  RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT;
       /*RECONFIG SELF REVIEW FIX END*/
       p_irat_geran_list_commit->irat_eutra_to_geran_reselection_params.speed_state_scale_factor = 
       p_irat_geran_list->irat_eutra_to_geran_reselection_params.speed_state_scale_factor;
    }
    if (p_irat_geran_list->bitmask & RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT)
    {
       p_irat_geran_list_commit->bitmask |= RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT;
       RRM_MEMCPY(&p_irat_geran_list_commit->irat_eutran_to_geran_list, 
               &p_irat_geran_list->irat_eutran_to_geran_list,
               sizeof(irat_eutran_geran_list_t));
    }

   RRM_UT_TRACE_EXIT();
}



rrm_void_t
rrm_commit_idle_mode_mobility_utra_fdd_list( rrm_cell_context_t    *p_cell_context)
{

    irat_eutran_utran_fdd_list_t                    *p_irat_utra_params = RRM_PNULL; /* info from mif :*/
    irat_eutran_utran_fdd_list_t                    *p_irat_utra_params_commit = RRM_PNULL; /*info to commit */
    U8                                              fdd_carriers_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /*coverity 23065: typecasted to irat_eutran_utran_fdd_list_t: , rel 1.3*/
    p_irat_utra_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                           idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                           irat_eutran_to_utran_fdd_list );


    /*coverity 23066: typecasted to irat_eutran_utran_fdd_list_t: , rel 1.3*/
    p_irat_utra_params_commit = &((p_cell_context->ran_info.mobility_params.
                                  idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.
                                  irat_eutran_to_utran_fdd_list));
    /* coverity fix 77424 start */
    p_irat_utra_params_commit->num_irat_eutran_to_utran_fdd_carriers =
	    p_irat_utra_params->num_irat_eutran_to_utran_fdd_carriers;
    /* coverity fix 77424 end */
    /*+ Coverity CID : 21923, 21922 +  
      changing  for(fdd_carriers_count = RRM_ZERO ; fdd_carriers_count < fdd_carriers_count;fdd_carriers_count++)   */
    for(fdd_carriers_count = RRM_ZERO ; fdd_carriers_count < p_irat_utra_params_commit->\
            num_irat_eutran_to_utran_fdd_carriers; fdd_carriers_count++)
    {
        if( p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].bitmask & 
            RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT ) 
        {
            /* RECONFIG SELF REVIEW FIX START */
            p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
            cell_reselection_priority =
            p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
            cell_reselection_priority;

            p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].bitmask |=
                                                    RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT;
            /*RECONFIG SELF REVIEW FIX END*/
      
        }
        if(p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].bitmask &
             RRMCM_RMIF_THRESHX_Q_R9_PRESENT)
        {
            /* RECONFIG SELF REVIEW FIX START */
            p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].bitmask |=
                                RRMCM_RMIF_THRESHX_Q_R9_PRESENT; 
            /*RECONFIG SELF REVIEW FIX END*/
            p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
            threshx_q_r9 =
            p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
            threshx_q_r9;

        /* OFFSET CHANGES */
        if (p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].bitmask &
             RRMCM_RMIF_OFFSET_FREQ_PRESENT)
        {
            /* RECONFIG SELF REVIEW FIX START */
            p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].bitmask |=
                                RRMCM_RMIF_OFFSET_FREQ_PRESENT;
            /*RECONFIG SELF REVIEW FIX END*/
            p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
            offset_freq =
            p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
            offset_freq;
         /* end */
        }

        /* RECONFIG SELF REVIEW FIX START */  
        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        utra_carrier_arfcn =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        utra_carrier_arfcn;

        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        q_rx_lev_min =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        q_rx_lev_min;

        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        q_qual_min =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        q_qual_min;
 
        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        thresh_x_high =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        thresh_x_high;
 
        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        thresh_x_low =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        thresh_x_low;

        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        p_max_utra =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        p_max_utra;

        p_irat_utra_params_commit->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        offset_freq =
        p_irat_utra_params->irat_eutran_to_utran_fdd_carriers[fdd_carriers_count].
        offset_freq;
        /*RECONFIG SELF REVIEW FIX END*/
    }
   } 
    
RRM_UT_TRACE_EXIT(); 
}




rrm_void_t
rrm_commit_idle_mode_mobility_irat_utra_params( rrm_cell_context_t   *p_cell_context)
{

    idle_mode_mobility_irat_utra_params_t      *p_irat_utra_params = RRM_PNULL; /* info from mif :*/
    idle_mode_mobility_irat_utra_params_t            *p_irat_utra_params_commit = RRM_PNULL; /*info to commit */
    RRM_UT_TRACE_ENTER();

    p_irat_utra_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                           idle_mode_mobility_params.idle_mode_mobility_irat_utra_params );

    p_irat_utra_params_commit = &(p_cell_context->ran_info.mobility_params.
                                  idle_mode_mobility_params.idle_mode_mobility_irat_utra_params );
 
   p_irat_utra_params_commit->bitmask |= p_irat_utra_params->bitmask;

   if( p_irat_utra_params->bitmask & RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT)
   {
       rrm_commit_idle_mode_mobility_utra_fdd_list(p_cell_context);
       /* RECONFIG SELF REVIEW FIX START */
       p_irat_utra_params_commit->bitmask |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT;
       /*RECONFIG SELF REVIEW FIX END*/
   }
   if( p_irat_utra_params->bitmask & RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT)
   {
       /* no bit mask inside*/
       p_irat_utra_params_commit->irat_eutran_to_utran_tdd_list =
       p_irat_utra_params->irat_eutran_to_utran_tdd_list;
       /* RECONFIG SELF REVIEW FIX START */
       p_irat_utra_params_commit->bitmask  |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT;
       /*RECONFIG SELF REVIEW FIX END*/
   }

   if( p_irat_utra_params->irat_eutra_to_utra_reselection_params.bitmask &
                   RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT)
   {
       p_irat_utra_params_commit->irat_eutra_to_utra_reselection_params.speed_state_scale_factor =
       p_irat_utra_params->irat_eutra_to_utra_reselection_params.speed_state_scale_factor ;

       /* RECONFIG SELF REVIEW FIX START */
       p_irat_utra_params_commit->irat_eutra_to_utra_reselection_params.bitmask |=
                                  RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT;
       /*RECONFIG SELF REVIEW FIX END*/
   }

   p_irat_utra_params_commit->irat_eutra_to_utra_reselection_params.t_reselection_utra =
   p_irat_utra_params->irat_eutra_to_utra_reselection_params.t_reselection_utra;
   
   RRM_UT_TRACE_EXIT();
}

/* Coverity 23090, Added return type rrm_void_t in Rel 1.3:  */

rrm_void_t
rrm_commit_idle_mode_mobility_inter_freq_params( rrm_cell_context_t   *p_cell_context)
{
    inter_freq_params_t      *p_inter_freq_params = RRM_PNULL; /* info from mif :*/
    inter_freq_params_t            *p_inter_freq_params_commit = RRM_PNULL; /*info to commit in cell context */
    U8				    num_valid_inter_freq_list = RRM_ZERO;
    U8                              inter_freq_count = RRM_ZERO;                     
    RRM_UT_TRACE_ENTER();

    p_inter_freq_params = (((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                           idle_mode_mobility_params.idle_mode_mobility_inter_freq_params );

    p_inter_freq_params_commit = (p_cell_context->ran_info.mobility_params.
                                  idle_mode_mobility_params.idle_mode_mobility_inter_freq_params );

     
    num_valid_inter_freq_list = (((rrmcm_rmif_cell_reconfig_req_t *)
                              (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                               idle_mode_mobility_params.num_valid_inter_freq_list );

    for( inter_freq_count = RRM_ZERO ; inter_freq_count < num_valid_inter_freq_list ;
                                                              inter_freq_count++)
    {
        /* RECONFIG SELF REVIEW FIX START */
/*        p_inter_freq_params_commit[inter_freq_count].bitmask |= 
        p_inter_freq_params[inter_freq_count].bitmask;*/

        if(p_inter_freq_params[inter_freq_count].bitmask & RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT)
        {
            p_inter_freq_params_commit[inter_freq_count].bitmask |=
                                                         RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT;

            p_inter_freq_params_commit[inter_freq_count].cell_reselection_priority = 
            p_inter_freq_params[inter_freq_count].cell_reselection_priority;
        }
        
        /* OFFSET CHANGES */

      if (p_inter_freq_params[inter_freq_count].bitmask & RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT)
       {
             p_inter_freq_params_commit[inter_freq_count].bitmask |=
                                                         RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT;
             p_inter_freq_params_commit[inter_freq_count].cm_offset_freq =
             p_inter_freq_params[inter_freq_count].cm_offset_freq;
       }
       /* END */
        if( p_inter_freq_params[inter_freq_count].bitmask & RRMCM_RMIF_P_MAX_PRESENT )
        {
            p_inter_freq_params_commit[inter_freq_count].p_max = p_inter_freq_params[inter_freq_count].p_max;
        }
        if(p_inter_freq_params[inter_freq_count].bitmask & RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1 )
        {
            p_inter_freq_params_commit[inter_freq_count].bitmask |= 
                                      RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1;
            p_inter_freq_params_commit[inter_freq_count].speed_scale_factors =
            p_inter_freq_params[inter_freq_count].speed_scale_factors;

        } 

        p_inter_freq_params_commit[inter_freq_count].eutra_carrier_arfcn =
        p_inter_freq_params[inter_freq_count].eutra_carrier_arfcn; 

        p_inter_freq_params_commit[inter_freq_count].q_rx_lev_min_sib_5 =
        p_inter_freq_params[inter_freq_count].q_rx_lev_min_sib_5;
 
        p_inter_freq_params_commit[inter_freq_count].q_offset_freq =
        p_inter_freq_params[inter_freq_count].q_offset_freq;

        p_inter_freq_params_commit[inter_freq_count].cm_offset_freq =
        p_inter_freq_params[inter_freq_count].cm_offset_freq;
  
        p_inter_freq_params_commit[inter_freq_count].t_reselection_eutra =
        p_inter_freq_params[inter_freq_count].t_reselection_eutra;

        p_inter_freq_params_commit[inter_freq_count].thresh_x_high =
        p_inter_freq_params[inter_freq_count].thresh_x_high;
 
        p_inter_freq_params_commit[inter_freq_count].thresh_x_low =
        p_inter_freq_params[inter_freq_count].thresh_x_low;

        p_inter_freq_params_commit[inter_freq_count].neigh_cell_config =
        p_inter_freq_params[inter_freq_count].neigh_cell_config;

        if( p_inter_freq_params[inter_freq_count].inter_freq_params_op_specific.bitmask &
                                                        RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT )
        {
            p_inter_freq_params_commit[inter_freq_count].inter_freq_params_op_specific.bitmask |=
                                                         RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT;

            p_inter_freq_params_commit[inter_freq_count].inter_freq_params_op_specific.q_qual_min_r9 =
            p_inter_freq_params[inter_freq_count].inter_freq_params_op_specific.q_qual_min_r9;
        }
        if( p_inter_freq_params[inter_freq_count].inter_freq_params_op_specific.bitmask & 
                                                  RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT )
        {
            p_inter_freq_params_commit[inter_freq_count].inter_freq_params_op_specific.bitmask |=
                                                       RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT;

            p_inter_freq_params_commit[inter_freq_count].inter_freq_params_op_specific.threshx_q_r9 =
            p_inter_freq_params[inter_freq_count].inter_freq_params_op_specific.threshx_q_r9;
        }
         
        p_inter_freq_params_commit[inter_freq_count].inter_freq_params_op_specific.allowed_meas_bandwidth =
        p_inter_freq_params[inter_freq_count].inter_freq_params_op_specific.allowed_meas_bandwidth;

        p_inter_freq_params_commit[inter_freq_count].inter_freq_params_op_specific.presence_antenna_port1 =
        p_inter_freq_params[inter_freq_count].inter_freq_params_op_specific.presence_antenna_port1; 
            
        /*RECONFIG SELF REVIEW FIX END*/ 
    }
    RRM_UT_TRACE_EXIT();
}




rrm_void_t
rrm_commit_mobility_idle_intra_freq_params(rrm_cell_context_t   *p_cell_context)
{
    intra_freq_params_t      *p_intra_freq_params = RRM_PNULL; /* info from mif :*/
    intra_freq_params_t            *p_intra_freq_params_commit = RRM_PNULL; /*info to commit */
    RRM_UT_TRACE_ENTER();

    p_intra_freq_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                           idle_mode_mobility_params.idle_mode_mobility_intra_freq_params);

    p_intra_freq_params_commit = &(p_cell_context->ran_info.mobility_params.
                                  idle_mode_mobility_params.idle_mode_mobility_intra_freq_params );

    /* RECONFIG SELF REVIEW FIX START */
    p_intra_freq_params_commit->bitmask |= p_intra_freq_params->bitmask;
    /*RECONFIG SELF REVIEW FIX END*/
    if( p_intra_freq_params->bitmask & RRMCM_RMIF_Q_RX_LEV_MIN_OFFSET_PRESENT)
    {
        p_intra_freq_params_commit->q_rx_lev_min_offset =
                          p_intra_freq_params->q_rx_lev_min_offset;
    }
    if( p_intra_freq_params->bitmask & RRMCM_RMIF_S_INTRA_SEARCH_PRESENT )
    {
        p_intra_freq_params_commit->s_intra_search = p_intra_freq_params->s_intra_search;
 
    }
    if(p_intra_freq_params->bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT)
    {
        p_intra_freq_params_commit->s_non_intra_search = p_intra_freq_params->s_non_intra_search;
    }
    if( p_intra_freq_params->bitmask & RRMCM_RMIF_P_MAX_SIB1_PRESENT)
    {
       p_intra_freq_params_commit->p_max_sib_1 = p_intra_freq_params->p_max_sib_1;
    }
    if( p_intra_freq_params->bitmask & RRMCM_RMIF_P_MAX_SIB3_PRESENT)
    {
       p_intra_freq_params_commit->p_max_sib_3 = p_intra_freq_params->p_max_sib_3;
    }
    if( p_intra_freq_params->bitmask & RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT)
    {
       p_intra_freq_params_commit->speed_scale_factors = 
       p_intra_freq_params->speed_scale_factors;
    }
    p_intra_freq_params_commit->q_rx_lev_min_sib_1 =
    p_intra_freq_params->q_rx_lev_min_sib_1;
    p_intra_freq_params_commit->q_rx_lev_min_sib_3 =
    p_intra_freq_params->q_rx_lev_min_sib_3 ;
    p_intra_freq_params_commit->t_reselection_eutra =
    p_intra_freq_params->t_reselection_eutra;
    p_intra_freq_params_commit->thresh_serving_low =
    p_intra_freq_params->thresh_serving_low;
    p_intra_freq_params_commit->neigh_cell_config =
    p_intra_freq_params->neigh_cell_config ;
    p_intra_freq_params_commit->cell_reselection_priority =
    p_intra_freq_params->cell_reselection_priority;
    
  RRM_UT_TRACE_EXIT(); 

}


rrm_void_t
rrm_commit_mobility_idle_commom_mobility_params(rrm_cell_context_t   *p_cell_context)
{


    common_params_t          *p_common_params = RRM_PNULL; /* info for reconfig from mif :*/
    common_params_t                *p_common_params_commit = RRM_PNULL; /*info to commit in cell conext  */
    RRM_UT_TRACE_ENTER();

    p_common_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params.
                           idle_mode_mobility_params.idle_mode_mobility_common_params);

    p_common_params_commit = &(p_cell_context->ran_info.mobility_params.
                               idle_mode_mobility_params.idle_mode_mobility_common_params);

    if( p_common_params->bitmask & RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_common_params_commit->bitmask = RRM_ZERO;
        p_common_params_commit->bitmask |=
                                RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT;

        p_common_params_commit->speed_state_params = 
        p_common_params->speed_state_params;
    }
    /* RECONFIG SELF REVIEW FIX END */
    p_common_params_commit->q_hyst = p_common_params->q_hyst;
   
    RRM_UT_TRACE_EXIT();
}


rrm_void_t
rrm_commit_ran_mobility_params(rrm_cell_context_t   *p_cell_context)
{
    mobility_params_t        *p_mobility_params = RRM_PNULL; /* info from mif :*/
    mobility_params_t        *p_mobility_commit = RRM_PNULL; /* info to commit in cell context*/

    RRM_UT_TRACE_ENTER();

    p_mobility_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mobility_params);

    p_mobility_commit = &(p_cell_context->ran_info.mobility_params);

    if(p_mobility_params->bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT)
    {

        /* RECONFIG SELF REVIEW FIX START */

        /* this bitmask is ored with cell context's mobility patams bitmask.
           due to this person dont need to set the bitmask inside every if 
           condition .
        */
        p_mobility_commit->bitmask |= p_mobility_params->bitmask; 
        /*RECONFIG SELF REVIEW FIX END*/

        if(p_mobility_params->idle_mode_mobility_params.bitmask & 
                 RRMCM_RMIF_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT )
        {
            rrm_commit_mobility_idle_commom_mobility_params(p_cell_context);

        }
        if(p_mobility_params->idle_mode_mobility_params.bitmask &
                  RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS )
        {
            rrm_commit_mobility_idle_intra_freq_params(p_cell_context);
        }
        if(p_mobility_params->idle_mode_mobility_params.bitmask &
                 RRMCM_MIF_IDLE_MODE_MOBILITY_INTER_FREQ_PARAMS)
        {
            rrm_commit_idle_mode_mobility_inter_freq_params(p_cell_context);
        }

        if(p_mobility_params->idle_mode_mobility_params.bitmask &
                     RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT)
        {
            rrm_commit_idle_mode_mobility_irat_utra_params(p_cell_context);
        }
        if(p_mobility_params->idle_mode_mobility_params.bitmask &
                     RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT)
        {
            rrm_commit_idle_mode_mobility_geran_list_params(p_cell_context);
        }
    }
    RRM_UT_TRACE_EXIT();
}



rrm_void_t
rrm_commit_ran_mac_layer_params( rrm_cell_context_t   *p_cell_context)
{

    mac_layer_params_t        *p_mac_layer_params = RRM_PNULL; /* info from mif :*/
    mac_layer_params_t              *p_mac_layer_commit = RRM_PNULL; /*info to commit */
    U8                        drx_profile_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_mac_layer_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.mac_layer_params);

    p_mac_layer_commit = &(p_cell_context->ran_info.mac_layer_params);

    p_mac_layer_commit->bitmask |= p_mac_layer_params->bitmask;
    
    if( p_mac_layer_params->bitmask & RRMCM_RMIF_MAC_LAYER_PARAM_RACH_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        if( p_mac_layer_params->mac_layer_param_rach.preamble_info.bitmask &
                                RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT )
        {
            p_mac_layer_commit->mac_layer_param_rach.preamble_info.bitmask = RRM_ZERO;
            p_mac_layer_commit->mac_layer_param_rach.preamble_info.bitmask |=
                                RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT;

            p_mac_layer_commit->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info =
            p_mac_layer_params->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info;
        }
          
        p_mac_layer_commit->mac_layer_param_rach.preamble_info.number_of_ra_preambles =
        p_mac_layer_params->mac_layer_param_rach.preamble_info.number_of_ra_preambles;

        p_mac_layer_commit->mac_layer_param_rach.power_ramping_step =
        p_mac_layer_params->mac_layer_param_rach.power_ramping_step;

        p_mac_layer_commit->mac_layer_param_rach.preamble_initial_received_target_power =
        p_mac_layer_params->mac_layer_param_rach.preamble_initial_received_target_power;

        p_mac_layer_commit->mac_layer_param_rach.preamble_trans_max =
        p_mac_layer_params->mac_layer_param_rach.preamble_trans_max;

        p_mac_layer_commit->mac_layer_param_rach.response_window_size =
        p_mac_layer_params->mac_layer_param_rach.response_window_size;

        p_mac_layer_commit->mac_layer_param_rach.contention_resolution_timer =
        p_mac_layer_params->mac_layer_param_rach.contention_resolution_timer;

        p_mac_layer_commit->mac_layer_param_rach.max_harq_msg_3tx =
        p_mac_layer_params->mac_layer_param_rach.max_harq_msg_3tx;

    }
        /*RECONFIG SELF REVIEW FIX END*/
    if( p_mac_layer_params->bitmask & RRMCM_RMIF_MAC_LAYER_PARAM_DRX_PRESENT)
    {
        /*spr 579 fix start*/
        p_mac_layer_commit->mac_layer_param_drx.drx_enabled = 
                 p_mac_layer_params->mac_layer_param_drx.drx_enabled;
        /*spr 579 fix end*/
        p_mac_layer_commit->mac_layer_param_drx.num_valid_drx_profiles = 
                 p_mac_layer_params->mac_layer_param_drx.num_valid_drx_profiles;
        for(drx_profile_count = RRM_ZERO; drx_profile_count < 
              p_mac_layer_commit->mac_layer_param_drx.num_valid_drx_profiles; drx_profile_count++)
        {
            RRM_MEMCPY(&p_mac_layer_commit->mac_layer_param_drx.drx_config[drx_profile_count],
                       &p_mac_layer_params->mac_layer_param_drx.drx_config[drx_profile_count],
                    sizeof(drx_config_t));
        }
    }
    /* BUG_371 FIX START */
    p_mac_layer_commit->ul_sync_loss_timer = p_mac_layer_params->ul_sync_loss_timer;
    p_mac_layer_commit->n_gap =  p_mac_layer_params->n_gap;
    /* BUG_371 FIX END */



    p_mac_layer_commit->ul_sync_loss_timer = p_mac_layer_params->ul_sync_loss_timer;
    p_mac_layer_commit->n_gap =  p_mac_layer_params->n_gap;
    /* BUG_371 FIX END */

    

    RRM_UT_TRACE_EXIT();
}


rrm_void_t
rrm_commit_ran_phy_info(rrm_cell_context_t   *p_cell_context)
{


    rrm_physical_layer_params_t        *p_phy_layer_params = PNULL;
    rrm_physical_layer_params_t              *p_phy_layer_params_commit = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_phy_layer_params = &(((rrmcm_rmif_cell_reconfig_req_t *)
                          (p_cell_context->p_new_reconfig_data))->ran_info.physical_layer_params);
  
    p_phy_layer_params_commit = &(p_cell_context->ran_info.physical_layer_params);

    /* RECONFIG SELF REVIEW FIX START */
    p_phy_layer_params_commit->bitmask |= p_phy_layer_params->bitmask;
    /* RECONFIG SELF REVIEW FIX END */

    if( p_phy_layer_params->bitmask &
           RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT)
    {
        p_phy_layer_params_commit->physical_layer_param_pdsch =
        p_phy_layer_params->physical_layer_param_pdsch;

    }
    if( p_phy_layer_params->bitmask &
                 RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        if(p_phy_layer_params->physical_layer_param_srs.bitmask &
                                                    RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT )
        {
            p_phy_layer_params_commit->physical_layer_param_srs.bitmask = RRM_ZERO;
            p_phy_layer_params_commit->physical_layer_param_srs.bitmask |=
                                       RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT; 
            p_phy_layer_params_commit->physical_layer_param_srs.srs_max_up_pts =
            p_phy_layer_params->physical_layer_param_srs.srs_max_up_pts;
        }
        p_phy_layer_params_commit->physical_layer_param_srs.srsEnabled =
        p_phy_layer_params->physical_layer_param_srs.srsEnabled;
     
        p_phy_layer_params_commit->physical_layer_param_srs.ack_nack_srs_simultaneous_transmission=
        p_phy_layer_params->physical_layer_param_srs.ack_nack_srs_simultaneous_transmission;

        p_phy_layer_params_commit->physical_layer_param_srs.srs_subframe_config =
        p_phy_layer_params->physical_layer_param_srs.srs_subframe_config;

        p_phy_layer_params_commit->physical_layer_param_srs.srs_bandwidth_config =
        p_phy_layer_params->physical_layer_param_srs.srs_bandwidth_config;
        /* SPR 21429 Fix Start */
        if(p_phy_layer_params->physical_layer_param_srs.bitmask &
                                                    RRMCM_SRS_DURATION_PRESENT )
        {
            p_phy_layer_params_commit->physical_layer_param_srs.bitmask |=
                                       RRMCM_SRS_DURATION_PRESENT; 
            p_phy_layer_params_commit->physical_layer_param_srs.srs_duration =
            p_phy_layer_params->physical_layer_param_srs.srs_duration;
        }
        if(p_phy_layer_params->physical_layer_param_srs.bitmask &
                                                    RRMCM_SRS_HOPPING_ENABLE_PRESENT )
        {
            p_phy_layer_params_commit->physical_layer_param_srs.bitmask |=
                                       RRMCM_SRS_HOPPING_ENABLE_PRESENT; 
            p_phy_layer_params_commit->physical_layer_param_srs.srs_hopping_enable =
            p_phy_layer_params->physical_layer_param_srs.srs_hopping_enable;
        }
        /* SPR 21429 Fix End */
        /* RECONFIG SELF REVIEW FIX END */

    }
    if( p_phy_layer_params->bitmask & 
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT)
    {
        p_phy_layer_params_commit->physical_layer_param_prach =
        p_phy_layer_params->physical_layer_param_prach;
    }
        
    if( p_phy_layer_params->bitmask &
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        if( p_phy_layer_params->physical_layer_param_pucch.bitmask &
                        PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT )
        {
            p_phy_layer_params_commit->physical_layer_param_pucch.bitmask = RRM_ZERO;
            p_phy_layer_params_commit->physical_layer_param_pucch.tdd_ack_nack_feedback_mode =
            p_phy_layer_params->physical_layer_param_pucch.tdd_ack_nack_feedback_mode;

            p_phy_layer_params_commit->physical_layer_param_pucch.bitmask |=
                                       PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;            
        }

        p_phy_layer_params_commit->physical_layer_param_pucch.delta_pucch_shift =
        p_phy_layer_params->physical_layer_param_pucch.delta_pucch_shift;
        p_phy_layer_params_commit->physical_layer_param_pucch.n_rb_cqi =
        p_phy_layer_params->physical_layer_param_pucch.n_rb_cqi;
        p_phy_layer_params_commit->physical_layer_param_pucch.n_cs_an =
        p_phy_layer_params->physical_layer_param_pucch.n_cs_an;
        p_phy_layer_params_commit->physical_layer_param_pucch.n1_pucch_an =
        p_phy_layer_params->physical_layer_param_pucch.n1_pucch_an;
        p_phy_layer_params_commit->physical_layer_param_pucch.cqi_pucch_resource_index =
        p_phy_layer_params->physical_layer_param_pucch.cqi_pucch_resource_index;
        /* BUG_371 FIX START */
        p_phy_layer_params_commit->physical_layer_param_pucch.pucch_cqi_sinr_value =
            p_phy_layer_params->physical_layer_param_pucch.pucch_cqi_sinr_value;
        /* BUG_371 FIX END */
        /*RECONFIG SELF REVIEW FIX END*/ 
        p_phy_layer_params_commit->physical_layer_param_pucch.pucch_cqi_sinr_value =
        p_phy_layer_params->physical_layer_param_pucch.pucch_cqi_sinr_value;
        /* BUG_371 FIX END */
        /*RECONFIG SELF REVIEW FIX END*/ 
    }
    if( p_phy_layer_params->bitmask &
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT )
    {
        p_phy_layer_params_commit->physical_layer_param_pusch =
        p_phy_layer_params->physical_layer_param_pusch;
    }
    if( p_phy_layer_params->bitmask & 
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT )
    {
        p_phy_layer_params_commit->physical_layer_param_ul_reference_signal =
        p_phy_layer_params->physical_layer_param_ul_reference_signal;

    }
    if( p_phy_layer_params->bitmask &
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT )
    {
        p_phy_layer_params_commit->physical_layer_param_ul_power_control =
        p_phy_layer_params->physical_layer_param_ul_power_control;

    }
    if( p_phy_layer_params->bitmask &
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT )
    {
        p_phy_layer_params_commit->physical_layer_param_prs =
        p_phy_layer_params->physical_layer_param_prs;
    }
    if( p_phy_layer_params->bitmask &
                            RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT )
    {
        p_phy_layer_params_commit->physical_layer_param_tdd_frame_structure =
        p_phy_layer_params->physical_layer_param_tdd_frame_structure;
/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
         RRM_MEMSET(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
         RRM_MEMSET(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
         RRM_MEMSET(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
         RRM_MEMSET(p_cell_context->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
         RRM_MEMSET(p_cell_context->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
         RRM_MEMSET(p_cell_context->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
      
         p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask &= ~RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT;
         p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask &= ~RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT; 
         p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask &= ~RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT;
         p_cell_context->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.bitmask &= ~RRMCM_RMIF_ABS_PATTERN_PRESENT; 
         p_cell_context->cell_load_action.u.comp_load_info.over_load.eicic_load_config.bitmask &= ~RRMCM_RMIF_ABS_PATTERN_PRESENT;
         p_cell_context->cell_load_action.u.comp_load_info.high_load.eicic_load_config.bitmask &= ~RRMCM_RMIF_ABS_PATTERN_PRESENT;
#endif
/*EICIC_TDD_CHANGES_END*/         
    }

   RRM_UT_TRACE_EXIT();
}

/*klock_works_changes_start*/
rrm_void_t
commit_rlc_layer_params
(
 ran_t *p_ran_info,
 ran_t *p_ran_info_commit
)
{
    U8             srb_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

        p_ran_info_commit->rlc_layer_params.num_valid_srb_info =
                p_ran_info->rlc_layer_params.num_valid_srb_info;
        for (srb_count = RRM_ZERO; srb_count < p_ran_info_commit->rlc_layer_params.num_valid_srb_info; srb_count++)
        {
            p_ran_info_commit->rlc_layer_params.rlc_layer_param_srb[srb_count].bitmask |= 
                 p_ran_info->rlc_layer_params.rlc_layer_param_srb[srb_count].bitmask;
            p_ran_info_commit->rlc_layer_params.rlc_layer_param_srb[srb_count].default_configuration = 
                 p_ran_info->rlc_layer_params.rlc_layer_param_srb[srb_count].default_configuration;
            if (p_ran_info->rlc_layer_params.rlc_layer_param_srb[srb_count].bitmask & 
                        RRMCM_RMIF_SRB_INFO_PRESENT)
            {
                p_ran_info_commit->rlc_layer_params.rlc_layer_param_srb[srb_count].bitmask |= 
                       RRMCM_RMIF_SRB_INFO_PRESENT;
                RRM_MEMCPY(&p_ran_info_commit->rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params,
                           &p_ran_info->rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params,
                           sizeof(srb_info_t));
            }
        }

    RRM_UT_TRACE_EXIT();
}
/*klock_works_changes_end*/


rrm_void_t
rrm_commit_ran_info(rrm_cell_context_t *p_cell_context)
{

    ran_t          *p_ran_info = &(((rrmcm_rmif_cell_reconfig_req_t *)
                                         (p_cell_context->p_new_reconfig_data))->ran_info);/*info coming for reconfig data*/

    ran_t          *p_ran_info_commit = &(p_cell_context->ran_info); /*info to commit in cell context */

    RRM_UT_TRACE_ENTER();

    if( p_ran_info->bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_ran_phy_info(p_cell_context);
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT )
    {
         /* RECONFIG SELF REVIEW FIX START */
         p_ran_info_commit->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT;
         /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_ran_mac_layer_params(p_cell_context); 
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_RLC_LAYER_PARAMS_PRESENT )
    {
        /*klock_works_changes_start*/

        commit_rlc_layer_params(p_ran_info, p_ran_info_commit);

        /*klock_works_changes_end*/
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_ran_mobility_params(p_cell_context);
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_rrc_timers_and_constants(p_cell_context);
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_RF_PARAMS_PRESENT )
    {
         /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_RF_PARAMS_PRESENT;
         /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_rf_params(p_cell_context);
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_NCL_PARAMS_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_ncl_params(p_cell_context);
    }
    if( p_ran_info->bitmask & RRMCM_RMIF_COMMON_EUTRAN_PARAMS_PRESENT)
    {
         /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_COMMON_EUTRAN_PARAMS_PRESENT;
         /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_common_eutran_params(p_cell_context);
    }
    if(p_ran_info->bitmask & RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_ran_info_commit->bitmask |= RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT;
        /*BUG_866_CHANGES_START*/
        p_ran_info_commit->cell_restriction_params.cell_and_access_barring.cell_barred = 
                               p_ran_info->cell_restriction_params.cell_and_access_barring.cell_barred;
        /* SPR 10730 Fix Start */
        /* Code deleted */
        /* SPR 10730 Fix End */
        p_ran_info_commit->cell_restriction_params.cell_and_access_barring.barring_for_emergency = 
                               p_ran_info->cell_restriction_params.cell_and_access_barring.barring_for_emergency;
        p_ran_info_commit->cell_restriction_params.cell_and_access_barring.cell_access_info.intra_frequency_reselection = 
                               p_ran_info->cell_restriction_params.cell_and_access_barring.cell_access_info.intra_frequency_reselection;
        /*BUG_866_CHANGES_END*/
        /* RECONFIG SELF REVIEW FIX END */
    }  
    if(p_ran_info->bitmask & RRMCM_RMIF_CONNECTED_MODE_MOBILITY_PARAMS_PRESENT)
    {
        if (p_ran_info->connected_mode_mobility_params.bitmask & RRMCM_RMIF_COMMON_PARAMS_FOR_EUTRA_PRESENT)
        {
            RRM_MEMCPY(&p_ran_info_commit->connected_mode_mobility_params.common_params_for_eutra,
                       &p_ran_info->connected_mode_mobility_params.common_params_for_eutra,
                       sizeof(rrm_common_params_for_eutra_t));
        }
        if (p_ran_info->connected_mode_mobility_params.bitmask & 
                 RRMCM_RMIF_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT)
        {
            RRM_MEMCPY(&p_ran_info_commit->connected_mode_mobility_params.irat,
                       &p_ran_info->connected_mode_mobility_params.irat,
                       sizeof(rrm_irat_params_t));
        }
    }  

    /* BUG_371 FIX START */
    if(p_ran_info->bitmask & RRMCM_RMIF_S1AP_PARAMS_PRESENT)
    {
        RRM_MEMCPY(&p_ran_info_commit->s1ap_params,
                &p_ran_info->s1ap_params,
                sizeof(s1ap_params_t));
    }
    /* BUG_371 FIX END */ 
    RRM_UT_TRACE_EXIT();
}




rrm_void_t
rrm_commit_epc_info(rrm_cell_context_t *p_cell_context)
{
    /* SPR_19279_START */
    rrmcm_rmif_cell_reconfig_req_t    *p_rrmcm_rmif_cell_reconfig = RRM_PNULL;
    p_rrmcm_rmif_cell_reconfig  =  ((rrmcm_rmif_cell_reconfig_req_t *)
                            (p_cell_context->p_new_reconfig_data)) ;
    /* SPR_19279_END */

    epc_t          *p_epc_info = &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->epc_info);

    epc_t                *p_epc_info_commit = RRM_PNULL;
    U8                    index = RRM_ZERO;
    U8                    max_plmn = RRM_ZERO;
    U8                    max_mnc = RRM_ZERO;
    U8                    i = RRM_ZERO;
    /*BUG_866_CHANGES_START*/
    U8                    j = RRM_ZERO;

    /* Fix DISABLE_QCI_NOT_WORKING : Start */
    /* Fix DISABLE_QCI_NOT_WORKING : End */
    /*BUG_866_CHANGES_END*/

    RRM_UT_TRACE_ENTER();

    p_epc_info_commit = &(p_cell_context->epc_info) ;

    /*BUG_866_CHANGES_START*/
    /* Fix DISABLE_QCI_NOT_WORKING : Start */
    /* Fix DISABLE_QCI_NOT_WORKING : End */
    /*BUG_866_CHANGES_END*/

    if( p_epc_info->epc_params.bitmask &
            RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT )
    {
        p_epc_info_commit->epc_params.bitmask |= RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT;

        if( p_epc_info->epc_params.general_epc_params.bitmask & RRMCM_RMIF_EA_ID_PRESENT)
        {
            /* RECONFIG SELF REVIEW FIX START */
            for( index = RRM_ZERO; index < MAX_EAID ; index++ )
            {
                p_epc_info_commit->epc_params.general_epc_params.eaid[index] =
                    p_epc_info->epc_params.general_epc_params.eaid[index];
            }
            /*Coverity_fix_start_54932*/
            p_epc_info->epc_params.general_epc_params.bitmask |= 
                RRMCM_RMIF_EA_ID_PRESENT;
            /* Coverity_fix_end_54932*/                                            
            /* RECONFIG SELF REVIEW FIX END*/
        }
        for( index = RRM_ZERO; index < MAX_TAC_SIZE ;index++)
        {
            p_epc_info_commit->epc_params.general_epc_params.tac[index] = 
                p_epc_info->epc_params.general_epc_params.tac[index];
        }
        max_plmn = p_epc_info_commit->epc_params.general_epc_params.num_valid_plmn =
            p_epc_info->epc_params.general_epc_params.num_valid_plmn;

        /* SPR 10730 Fix Start */
        for( index = RRM_ZERO; index < max_plmn; index++)
        {
            if(p_epc_info->epc_params.general_epc_params.plmn_list[index].plmn_id.bitmask & 
                    RRMCM_MCC_PRESENCE_BITMASK)
            {
                p_epc_info_commit->epc_params.general_epc_params.plmn_list[index].plmn_id.bitmask |=
                    MAX_MCC_DIGITS;               
                for( i = RRM_ZERO ; i < MAX_MCC_DIGITS ; i++)
                {
                    p_epc_info_commit->epc_params.general_epc_params.plmn_list[index].plmn_id.mcc[i] =
                        p_epc_info->epc_params.general_epc_params.plmn_list[index].plmn_id.mcc[i]; 
                }

            }
            max_mnc = p_epc_info_commit->epc_params.general_epc_params.plmn_list[index].plmn_id.num_mnc_digit = 
                p_epc_info->epc_params.general_epc_params.plmn_list[index].plmn_id.num_mnc_digit;

            for( i = RRM_ZERO; i < max_mnc ; i++)
            {
                p_epc_info_commit->epc_params.general_epc_params.plmn_list[index].plmn_id.mnc[i] =
                    p_epc_info->epc_params.general_epc_params.plmn_list[index].plmn_id.mnc[i];
            }
            if(p_epc_info->epc_params.general_epc_params.plmn_list[index].bitmask &
                    RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT )
            {
                p_epc_info_commit->epc_params.general_epc_params.plmn_list[index].cell_reserved_for_operator_use =
                    p_epc_info->epc_params.general_epc_params.plmn_list[index].cell_reserved_for_operator_use;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Commit cell_reserved_for_operator_use in cell context as [%d]",
                        p_epc_info_commit->epc_params.general_epc_params.plmn_list[index].cell_reserved_for_operator_use);
            }

            /* SPR 10730 Fix End */
        }
        /* RECONFIG SELF REVIEW FIX END*/
        /*SPR_19279_START*/
        RRM_MEMCPY(p_cell_context->global_cell_id.primary_plmn_id.mcc,p_rrmcm_rmif_cell_reconfig->epc_info.
                epc_params.general_epc_params.plmn_list[RRM_ZERO].plmn_id.mcc,
                MAX_MCC_DIGITS);
        RRM_MEMCPY(p_cell_context->global_cell_id.primary_plmn_id.mnc,p_rrmcm_rmif_cell_reconfig->epc_info. 
                epc_params.general_epc_params.plmn_list[RRM_ZERO].plmn_id.mnc,
                MAX_MNC_DIGITS);
        p_cell_context->global_cell_id.primary_plmn_id.num_mnc_digit = 
            p_rrmcm_rmif_cell_reconfig->epc_info.
                epc_params.general_epc_params.plmn_list[RRM_ZERO].plmn_id.num_mnc_digit;
        /*SPR_19279_END*/
    }

    /* Fix DISABLE_QCI_NOT_WORKING : Start */
    /* As operator can modify, delete, add qos profiles. So, RRM should update its database as per the details provided by OAM without applying any of the intelligency */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "Num Qos Profile Configured Already Configured [%d], Num Qos Profile Change Request [%d]",
            p_epc_info_commit->epc_params.num_valid_qos_profiles, p_epc_info->epc_params.num_valid_qos_profiles);

    p_epc_info_commit->epc_params.num_valid_qos_profiles = p_epc_info->epc_params.num_valid_qos_profiles;

    for (j = 0; j < p_epc_info->epc_params.num_valid_qos_profiles; j++)
    {
        RRM_MEMCPY(&(p_epc_info_commit->epc_params.qos_config_params[j]),
                &(p_epc_info->epc_params.qos_config_params[j]),
                sizeof(qos_config_params_t));
    }

    /* Fix DISABLE_QCI_NOT_WORKING : End */
    RRM_UT_TRACE_EXIT();
}




rrm_void_t
rrm_commit_access_mgmt_params( rrm_cell_context_t *p_cell_context)
{

    access_mgmt_params_t           *p_access_mgmt_param= RRM_PNULL;
    access_mgmt_params_t           *p_access_mgmt_param_commit = RRM_PNULL;
    U8                              index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
  
    p_access_mgmt_param   = &(((rrmcm_rmif_cell_reconfig_req_t *)
                                         (p_cell_context->p_new_reconfig_data))->access_mgmt_params );

    p_access_mgmt_param_commit = &(p_cell_context->access_mgmt_params);

    p_access_mgmt_param_commit->bitmask |= p_access_mgmt_param->bitmask;

    if(p_access_mgmt_param->bitmask & RRMCM_RMIF_CSG_ID_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_access_mgmt_param_commit->bitmask |= RRMCM_RMIF_CSG_ID_PRESENT;
        /* RECONFIG SELF REVIEW FIX START */
        for( index = RRM_ZERO; index < NUM_CSG_OCTETS ; index++)
        {
            p_access_mgmt_param_commit->csg_id[index] = 
            p_access_mgmt_param->csg_id[index];
        }
    }

    p_access_mgmt_param_commit->hnb_name_size = 
    p_access_mgmt_param->hnb_name_size;

    for( index = RRM_ZERO; index < p_access_mgmt_param->hnb_name_size;index++ )
    {
        p_access_mgmt_param_commit->hnb_name[index] = 
        p_access_mgmt_param->hnb_name[index];
    }
    p_access_mgmt_param_commit->access_mode = p_access_mgmt_param->access_mode;

    p_access_mgmt_param_commit->max_csg_members = 
    p_access_mgmt_param->max_csg_members ;

    p_access_mgmt_param_commit->max_non_csg_members = 
    p_access_mgmt_param->max_non_csg_members;

    p_access_mgmt_param_commit->max_resource_non_csg_members = 
    p_access_mgmt_param->max_resource_non_csg_members;

    RRM_UT_TRACE_EXIT();
}



rrm_void_t
rrm_commit_operator_mac_config(rrm_cell_context_t *p_cell_context)
{

    /* + SPR 17665 + */

    U8 count = 0;

    /* - SPR 17665 - */
    rrmc_mac_config_t    *p_rrmc_mac_config = RRM_PNULL;
    rrmc_mac_config_t          *p_rrmc_mac_config_commit = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_rrmc_mac_config =  &(((rrmcm_rmif_cell_reconfig_req_t *)
             (p_cell_context->p_new_reconfig_data))->operator_info.rrm_mac_config );

    p_rrmc_mac_config_commit = &(p_cell_context->operator_info.rrm_mac_config);

    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/

    p_rrmc_mac_config_commit->mac_downlink_power_control_common =
    p_rrmc_mac_config->mac_downlink_power_control_common;

    /* BUG_371 FIX START */
    p_rrmc_mac_config_commit->start_rarnti_range =
                p_rrmc_mac_config->start_rarnti_range;
    
    p_rrmc_mac_config_commit->end_rarnti_range =
                  p_rrmc_mac_config->end_rarnti_range;
    /* BUG_371 FIX END */
    
    /* + SPR 17665 + */
    if(p_rrmc_mac_config->bitmask & RRMCM_RMIF_DCI_FORMAT_FOR_SI_MSG_PRESENT)
    {

        p_rrmc_mac_config_commit->rrm_dci_format_for_si_msg =  p_rrmc_mac_config->rrm_dci_format_for_si_msg;

    }

   if(p_rrmc_mac_config->bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT)  
   {
       for(count = RRM_ZERO; count < RBS_FOR_DCI_1A_SIZE; count++)

       {

           p_rrmc_mac_config_commit->num_rbs_per_tbs_dci_1a[count] =

               p_rrmc_mac_config->num_rbs_per_tbs_dci_1a[count];


       }

   }
   if(p_rrmc_mac_config->bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT)
   {    
       for(count = RRM_ZERO; count < RBS_FOR_DCI_1C_SIZE; count++)

       {

           p_rrmc_mac_config_commit->num_rbs_per_tbs_dci_1c[count] =

               p_rrmc_mac_config->num_rbs_per_tbs_dci_1c[count];


       }
   }
   /* - SPR 17665 - */
    RRM_UT_TRACE_EXIT();
}



rrm_void_t
rrm_commit_operator_info_sib_2_radio_resource_config( rrm_cell_context_t *p_cell_context)
{

    rrm_radio_resource_config_common_sib_t    *p_radio_resource_config = RRM_PNULL;
    rrm_radio_resource_config_common_sib_t          *p_radio_resource_config_commit = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_radio_resource_config = &(((rrmcm_rmif_cell_reconfig_req_t *)
                              (p_cell_context->p_new_reconfig_data))->operator_info.sib_2_info.
                               radio_res_config_common_sib );

    p_radio_resource_config_commit = &(p_cell_context->operator_info.sib_2_info.
                                     radio_res_config_common_sib);

    p_radio_resource_config_commit->bitmask |= 
    p_radio_resource_config->bitmask;

    p_radio_resource_config_commit->rrm_bcch_config =
    p_radio_resource_config->rrm_bcch_config;

    p_radio_resource_config_commit->rrm_pcch_config =
    p_radio_resource_config->rrm_pcch_config;

    p_radio_resource_config_commit->ul_cyclic_prefix_length =
    p_radio_resource_config->ul_cyclic_prefix_length;

   if( p_radio_resource_config->bitmask & RRMCM_RMIF_BARRING_INFO_PRESENT)
   {
       p_radio_resource_config_commit->bitmask |= 
                                       RRMCM_RMIF_BARRING_INFO_PRESENT;

       if( p_radio_resource_config->access_barring_info.bitmask &
              RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT )
       {
          p_radio_resource_config_commit->access_barring_info.bitmask |= 
                               RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT;

          p_radio_resource_config_commit->access_barring_info.ac_barring_for_mo_signalling = 
          p_radio_resource_config->access_barring_info.ac_barring_for_mo_signalling;
       }
       if( p_radio_resource_config->access_barring_info.bitmask &
               RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
       {
           p_radio_resource_config_commit->access_barring_info.bitmask |= 
                              RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT ;

           p_radio_resource_config_commit->access_barring_info.ac_barring_for_mo_data =
           p_radio_resource_config->access_barring_info.ac_barring_for_mo_data;
       }
       if(p_radio_resource_config->access_barring_info.bitmask &
                RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT)
       {
           p_radio_resource_config_commit->access_barring_info.ssac_barring_r9.bitmask |=
                                           RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT;
 
           if( p_radio_resource_config->access_barring_info.ssac_barring_r9.bitmask &
                            RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT)
           {
               p_radio_resource_config_commit->access_barring_info.ssac_barring_r9.bitmask |=
                                               RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT;
               p_radio_resource_config_commit->access_barring_info.ssac_barring_r9.
               ssac_barring_for_mmtel_voice_r9 =
               p_radio_resource_config->access_barring_info.ssac_barring_r9.
               ssac_barring_for_mmtel_voice_r9;
           }
           if( p_radio_resource_config->access_barring_info.ssac_barring_r9.bitmask &
                             RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT )
           {
               p_radio_resource_config_commit->access_barring_info.ssac_barring_r9.bitmask |=
                                        RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT;
               p_radio_resource_config_commit->access_barring_info.ssac_barring_r9.
               ssac_barring_for_mmtel_video_r9 =
               p_radio_resource_config->access_barring_info.ssac_barring_r9.
               ssac_barring_for_mmtel_video_r9;
           }
       }
   }
   RRM_UT_TRACE_EXIT();
}


rrm_void_t
rrm_commit_operator_sib_4_info( rrm_cell_context_t *p_cell_context )
{

    rrm_sib_type_4_info_t    *p_rrm_sib_type_4_info = RRM_PNULL;
    rrm_sib_type_4_info_t          *p_rrm_sib_type_4_info_commit = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrm_sib_type_4_info =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                           (p_cell_context->p_new_reconfig_data))->operator_info.sib_4_info );

    p_rrm_sib_type_4_info_commit = &(p_cell_context->operator_info.sib_4_info);

    p_rrm_sib_type_4_info_commit->csg_id_range.bitmask |= 
    p_rrm_sib_type_4_info->csg_id_range.bitmask;

    if( p_rrm_sib_type_4_info->csg_id_range.bitmask & 
              RRMCM_RMIF_CELL_ID_RANGE_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rrm_sib_type_4_info_commit->csg_id_range.bitmask |= RRMCM_RMIF_CELL_ID_RANGE_PRESENT;
        /* RECONFIG SELF REVIEW FIX END*/
        p_rrm_sib_type_4_info_commit->csg_id_range.range = 
        p_rrm_sib_type_4_info->csg_id_range.range;      
    }
    p_rrm_sib_type_4_info_commit->csg_id_range.start = 
    p_rrm_sib_type_4_info->csg_id_range.start;

    RRM_UT_TRACE_EXIT();
}



rrm_void_t
rrm_commit_operator_info_sib_3_info( rrm_cell_context_t *p_cell_context )
{

    rrm_sib_type_3_info_t     *p_rrm_sib_type_3_info = RRM_PNULL;

    rrm_sib_type_3_info_t           *p_rrm_sib_type_3_info_commit = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_rrm_sib_type_3_info =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                              (p_cell_context->p_new_reconfig_data))->operator_info.sib_3_info );

    p_rrm_sib_type_3_info_commit = &(p_cell_context->operator_info.sib_3_info);
   
    p_rrm_sib_type_3_info_commit->bitmask |= p_rrm_sib_type_3_info->bitmask;

    if(  p_rrm_sib_type_3_info->intra_freq_reselection_info.bitmask & 
                                 RRMCM_RMIF_MEASUREMENT_BW_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rrm_sib_type_3_info_commit->intra_freq_reselection_info.bitmask |=
                                      RRMCM_RMIF_MEASUREMENT_BW_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        p_rrm_sib_type_3_info_commit->intra_freq_reselection_info.measurement_bandwidth =
        p_rrm_sib_type_3_info->intra_freq_reselection_info.measurement_bandwidth;
       
    } 
    p_rrm_sib_type_3_info_commit->intra_freq_reselection_info.presence_antenna_port1 = 
        p_rrm_sib_type_3_info->intra_freq_reselection_info.presence_antenna_port1;

    if( p_rrm_sib_type_3_info->bitmask & RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rrm_sib_type_3_info_commit->bitmask |= RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        p_rrm_sib_type_3_info_commit->s_intra_search = 
        p_rrm_sib_type_3_info->s_intra_search;
    } 
    if( p_rrm_sib_type_3_info->bitmask & RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rrm_sib_type_3_info_commit->bitmask |= RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        p_rrm_sib_type_3_info_commit->s_non_intra_search =
        p_rrm_sib_type_3_info->s_non_intra_search;
    } 
    if( p_rrm_sib_type_3_info->bitmask & RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1)
    {
         /* RECONFIG SELF REVIEW FIX START */
         p_rrm_sib_type_3_info_commit->bitmask |= RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1;
         /* RECONFIG SELF REVIEW FIX END */
         p_rrm_sib_type_3_info_commit->q_qual_min_r9 = 
         p_rrm_sib_type_3_info->q_qual_min_r9;
    }
    if( p_rrm_sib_type_3_info->bitmask &  RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rrm_sib_type_3_info_commit->bitmask |= RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        p_rrm_sib_type_3_info_commit->thresh_serving_lowq_r9 = 
        p_rrm_sib_type_3_info->thresh_serving_lowq_r9;
    }
    RRM_UT_TRACE_EXIT();
}



rrm_void_t
rrm_commit_operator_info_sib_2_info( rrm_cell_context_t *p_cell_context )
{

    rrm_sib_type_2_info_t    *p_rrm_sib_type_2_info = RRM_PNULL;
    rrm_sib_type_2_info_t          *p_rrm_sib_type_2_info_commit = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_rrm_sib_type_2_info =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                             (p_cell_context->p_new_reconfig_data))->operator_info.sib_2_info );

    p_rrm_sib_type_2_info_commit = &(p_cell_context->operator_info.sib_2_info);

    rrm_commit_operator_info_sib_2_radio_resource_config(p_cell_context); 

    p_rrm_sib_type_2_info_commit->rrm_freq_info.bitmask |= 
    p_rrm_sib_type_2_info->rrm_freq_info.bitmask;

    if( p_rrm_sib_type_2_info->rrm_freq_info.bitmask & 
                            RRMCM_RMIF_UL_CARRIER_FREQ_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_rrm_sib_type_2_info_commit->rrm_freq_info.bitmask |=
                                      RRMCM_RMIF_UL_CARRIER_FREQ_PRESENT;
        /*RECONFIG SELF REVIEW FIX END*/
        p_rrm_sib_type_2_info_commit->rrm_freq_info.ul_carrier_freq =
        p_rrm_sib_type_2_info->rrm_freq_info.ul_carrier_freq;
    }
    p_rrm_sib_type_2_info_commit->rrm_freq_info.additional_spectrum_emission = 
          p_rrm_sib_type_2_info->rrm_freq_info.additional_spectrum_emission;

    p_rrm_sib_type_2_info_commit->time_alignment_timer =
          p_rrm_sib_type_2_info->time_alignment_timer;  

    p_rrm_sib_type_2_info_commit->ac_barring_for_csfb_r10 =
          p_rrm_sib_type_2_info->ac_barring_for_csfb_r10;

    RRM_UT_TRACE_EXIT(); 
}


rrm_void_t
rrm_commit_operator_info_sib_1_info( rrm_cell_context_t *p_cell_context )
{

    rrm_sib_type_1_info_t    *p_rrm_sib_type_1_info = RRM_PNULL;
    rrm_sib_type_1_info_t          *rrm_sib_type_1_info_commit = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_rrm_sib_type_1_info =  &(((rrmcm_rmif_cell_reconfig_req_t *)
          (p_cell_context->p_new_reconfig_data))->operator_info.sib_1_info );

    rrm_sib_type_1_info_commit = &(p_cell_context->operator_info.sib_1_info );

    rrm_sib_type_1_info_commit->bitmask |= p_rrm_sib_type_1_info->bitmask;

    if(( p_rrm_sib_type_1_info->bitmask & RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT))
    {
       /* RECONFIG SELF REVIEW FIX START */ 
       rrm_sib_type_1_info_commit->bitmask |= 
                                   RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT;
       /*RECONFIG SELF REVIEW FIX END*/

       if( p_rrm_sib_type_1_info->cell_selection_info.bitmask &
                                   RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT)
       {
           /* RECONFIG SELF REVIEW FIX START */
           rrm_sib_type_1_info_commit->cell_selection_info.bitmask |= 
                                       RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT;
           /*RECONFIG SELF REVIEW FIX END*/
           rrm_sib_type_1_info_commit->cell_selection_info.q_qual_min_offset_r9_present=
           p_rrm_sib_type_1_info->cell_selection_info.q_qual_min_offset_r9_present;
       }
       rrm_sib_type_1_info_commit->cell_selection_info.q_qual_min_r9 = 
       p_rrm_sib_type_1_info->cell_selection_info.q_qual_min_r9 ; 
    }
    
    /* BUG_371 FIX START */
    /*rrm_sib_type_1_info_commit->cell_access_info =
    p_rrm_sib_type_1_info->cell_access_info;*/
    /* BUG_371 FIX END */ 

    rrm_sib_type_1_info_commit->si_window_length = 
    p_rrm_sib_type_1_info->si_window_length;

    rrm_sib_type_1_info_commit->scheduling_info_list = 
    p_rrm_sib_type_1_info->scheduling_info_list;

    rrm_sib_type_1_info_commit->ims_emergency_support_r9 =
    p_rrm_sib_type_1_info->ims_emergency_support_r9;

    if( p_cell_context->sib_present_at_cell_reconfig_time_bitmask !=  p_cell_context->sib_present_at_cell_config_time_bitmask)
    {
        /* Spr 16115 fix Start */
        p_cell_context->sib_present_at_cell_config_time_bitmask |= p_cell_context->sib_present_at_cell_reconfig_time_bitmask;
        /* Spr 16115 fix End */
    }

    RRM_UT_TRACE_EXIT();
}
/* SPR 21429 Fix Start */
/****************************************************************************
 * Function Name  : rrm_commit_admission_control_info
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : Void
 * Description    : Update admission_control_info for cell reconfig
 ****************************************************************************/

rrm_void_t
rrm_commit_admission_control_info( rrm_cell_context_t *p_cell_context )
{

    admission_control_info_t    *p_admission_control_info = RRM_PNULL;
    admission_control_info_t    *p_admission_control_info_commit = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_admission_control_info  =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->operator_info.admission_control_info );
    p_admission_control_info_commit = &(p_cell_context->operator_info.admission_control_info);

    if(p_admission_control_info->bitmask & RRMCM_MIN_SR_PERIODICITY_PRESENT )
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MIN_SR_PERIODICITY_PRESENT;
        p_admission_control_info_commit->min_sr_periodicity =
            p_admission_control_info->min_sr_periodicity;
    }
    if(p_admission_control_info->bitmask & RRMCM_MIN_RI_PERIODICITY_PRESENT )
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MIN_RI_PERIODICITY_PRESENT;
        p_admission_control_info_commit->min_ri_periodicity =
            p_admission_control_info->min_ri_periodicity;
    }
    if(p_admission_control_info->bitmask & RRMCM_MIN_CQI_PERIODICITY_PRESENT )
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MIN_CQI_PERIODICITY_PRESENT;
        p_admission_control_info_commit->min_cqi_periodicity =
            p_admission_control_info->min_cqi_periodicity;
    }
    if(p_admission_control_info->bitmask & RRMCM_SRB_BIT_RATE_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_SRB_BIT_RATE_PRESENT;
        p_admission_control_info_commit->srb_bit_rate =
            p_admission_control_info->srb_bit_rate;
    }
    if(p_admission_control_info->bitmask & RRMCM_SRB_BIT_RATE_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_SRB_BIT_RATE_PRESENT;
        p_admission_control_info_commit->srb_bit_rate =
            p_admission_control_info->srb_bit_rate;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_NUM_UE_PER_CELL_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_NUM_UE_PER_CELL_PRESENT;
        p_admission_control_info_commit->max_num_ue_per_cell =
            p_admission_control_info->max_num_ue_per_cell;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT;
        p_admission_control_info_commit->max_num_gbr_drbs_per_ue =
            p_admission_control_info->max_num_gbr_drbs_per_ue;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT;
        p_admission_control_info_commit->max_num_ngbr_drbs_per_ue =
            p_admission_control_info->max_num_ngbr_drbs_per_ue;
    }
    if(p_admission_control_info->bitmask & RRMCM_NGBR_THRESHOLD_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_NGBR_THRESHOLD_PRESENT;
        p_admission_control_info_commit->ngbr_threshold =
            p_admission_control_info->ngbr_threshold;
    }
    if(p_admission_control_info->bitmask & RRMCM_MIN_BITRATE_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MIN_BITRATE_PRESENT;
        p_admission_control_info_commit->minimum_bitrate =
            p_admission_control_info->minimum_bitrate;
    }
    if(p_admission_control_info->bitmask & RRMCM_NON_DEFAULT_BEARER_MULTIPLIER_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_NON_DEFAULT_BEARER_MULTIPLIER_PRESENT;
        p_admission_control_info_commit->non_default_bearer_multiplier =
            p_admission_control_info->non_default_bearer_multiplier;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_TOTAL_DL_GBR_PRB_BUDGET)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_TOTAL_DL_GBR_PRB_BUDGET;
        p_admission_control_info_commit->dl_prb_budget_gbr =
            p_admission_control_info->dl_prb_budget_gbr;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_TOTAL_UL_GBR_PRB_BUDGET)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_TOTAL_UL_GBR_PRB_BUDGET;
        p_admission_control_info_commit->ul_prb_budget_gbr =
            p_admission_control_info->ul_prb_budget_gbr;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_TOTAL_DL_NGBR_PRB_BUDGET)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_TOTAL_DL_NGBR_PRB_BUDGET;
        p_admission_control_info_commit->dl_prb_budget_ngbr =
            p_admission_control_info->dl_prb_budget_ngbr;
    }
    if(p_admission_control_info->bitmask & RRMCM_MAX_TOTAL_UL_NGBR_PRB_BUDGET)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_MAX_TOTAL_UL_NGBR_PRB_BUDGET;
        p_admission_control_info_commit->ul_prb_budget_ngbr =
            p_admission_control_info->ul_prb_budget_ngbr;
    }
    if(p_admission_control_info->bitmask & RRMCM_DL_BW_FOR_CONTROL_PRBS)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_DL_BW_FOR_CONTROL_PRBS;
        p_admission_control_info_commit->dl_bw_for_control_prbs =
            p_admission_control_info->dl_bw_for_control_prbs;
    }
    if(p_admission_control_info->bitmask & RRMCM_RB_FACTOR_FOR_BITRATE)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_RB_FACTOR_FOR_BITRATE;
        p_admission_control_info_commit->rb_factor_for_bitrate =
            p_admission_control_info->rb_factor_for_bitrate;
    }
    if(p_admission_control_info->bitmask & RRMCM_RMIF_RESOURCE_RESERVED_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_RMIF_RESOURCE_RESERVED_PRESENT;
        p_admission_control_info_commit->resource_reserved_for_existing_users =
            p_admission_control_info->resource_reserved_for_existing_users;
    }
    if(p_admission_control_info->bitmask & RRMCM_RMIF_PROXIMITY_IND_STATUS_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_RMIF_PROXIMITY_IND_STATUS_PRESENT;
        p_admission_control_info_commit->proximity_indication_status =
            p_admission_control_info->proximity_indication_status;
    }
    if(p_admission_control_info->bitmask & RRMCM_SRS_PERIODICITY_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_SRS_PERIODICITY_PRESENT;
        p_admission_control_info_commit->srs_periodicity =
            p_admission_control_info->srs_periodicity;
    }
    if(p_admission_control_info->bitmask & RRMCM_AVAILABLE_GBR_LIMIT_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_AVAILABLE_GBR_LIMIT_PRESENT;
        RRM_MEMCPY(&p_admission_control_info_commit->avail_gbr_limit,
                &p_admission_control_info->avail_gbr_limit,
                sizeof(avail_gbr_limit_t));
    }
    if(p_admission_control_info->bitmask & RRMCM_SNR_MAP_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_SNR_MAP_PRESENT;
        if(p_admission_control_info->snr_map.snr_dep_params.downlink_snr_dep_params.bitmask & DL_PRB_PER_BPS_PRESENT)
        {
            p_admission_control_info_commit->snr_map.snr_dep_params.downlink_snr_dep_params.bitmask |= DL_PRB_PER_BPS_PRESENT;
            p_admission_control_info_commit->snr_map.snr_dep_params.downlink_snr_dep_params.dl_prb_per_bps =
                p_admission_control_info->snr_map.snr_dep_params.downlink_snr_dep_params.dl_prb_per_bps;
        }
        p_admission_control_info_commit->snr_map.snr_dep_params.downlink_snr_dep_params.dl_mcs =
            p_admission_control_info->snr_map.snr_dep_params.downlink_snr_dep_params.dl_mcs;

        if(p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.bitmask & PUSCH_INFO_SNR_MAP_PRESENT)
        {
            p_admission_control_info_commit->snr_map.snr_dep_params.uplink_snr_dep_params.bitmask |= PUSCH_INFO_SNR_MAP_PRESENT;
            RRM_MEMCPY(&p_admission_control_info_commit->snr_map.snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated,
                    &p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated,
                    sizeof(rrc_phy_pusch_configuration_dedicated_ue_service_profile_t));
        }
        if(p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.bitmask & UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT)
        {
            p_admission_control_info_commit->snr_map.snr_dep_params.uplink_snr_dep_params.bitmask |= UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT;
            RRM_MEMCPY(&p_admission_control_info_commit->snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control,
                    &p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control,
                    sizeof(rrc_phy_uplink_power_control_dedicated_ue_service_profile_t));
        }
        if(p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.bitmask & UL_PRB_PER_BPS_PRESENT)
        {
            p_admission_control_info_commit->snr_map.snr_dep_params.uplink_snr_dep_params.bitmask |= UL_PRB_PER_BPS_PRESENT;
            p_admission_control_info_commit->snr_map.snr_dep_params.uplink_snr_dep_params.ul_prb_per_bps =
                p_admission_control_info->snr_map.snr_dep_params.uplink_snr_dep_params.ul_prb_per_bps;
        }
    }
    if(p_admission_control_info->bitmask & RRMCM_UE_SERVICE_PROFILE_PRESENT)
    {
        p_admission_control_info_commit->bitmask |= RRMCM_UE_SERVICE_PROFILE_PRESENT;

        if(p_admission_control_info->ue_service_profile.bitmask & RRM_SERVICE_PROFILE_UE_ADM_EXTENDED_WAIT_TIME_PRESENT)
        {
            p_admission_control_info_commit->ue_service_profile.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_EXTENDED_WAIT_TIME_PRESENT;
            p_admission_control_info_commit->ue_service_profile.extended_wait_time = 
                p_admission_control_info->ue_service_profile.extended_wait_time;
        }
        if(p_admission_control_info->ue_service_profile.bitmask & RRM_SERVICE_PROFILE_UE_ADM_WAIT_TIME_PRESENT)
        {
            p_admission_control_info_commit->ue_service_profile.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_WAIT_TIME_PRESENT;
        p_admission_control_info_commit->ue_service_profile.wait_time = 
            p_admission_control_info->ue_service_profile.wait_time;
        }
        if(p_admission_control_info->ue_service_profile.bitmask & RRM_SERVICE_PROFILE_UE_ADM_INITIAL_UE_LOC_PRESENT)
        {
            p_admission_control_info_commit->ue_service_profile.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_INITIAL_UE_LOC_PRESENT;
        p_admission_control_info_commit->ue_service_profile.initial_ue_location = 
            p_admission_control_info->ue_service_profile.initial_ue_location;
        }
      
        if(p_admission_control_info->ue_service_profile.radio_res_config.bitmask & RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_MAC_CONFIG_PRESENT)
        {
            p_admission_control_info_commit->ue_service_profile.radio_res_config.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_MAC_CONFIG_PRESENT;
            RRM_MEMCPY(&p_admission_control_info_commit->ue_service_profile.radio_res_config.mac_config,
                    &p_admission_control_info->ue_service_profile.radio_res_config.mac_config,
                    sizeof(rrm_mac_config_ue_service_profile_t));
        }
        if(p_admission_control_info->ue_service_profile.radio_res_config.bitmask & RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT)
        {
            p_admission_control_info_commit->ue_service_profile.radio_res_config.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT;
            if(p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask & RRC_SERVICE_PROFILE_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT)
            {
                p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask |= RRC_SERVICE_PROFILE_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT;
                RRM_MEMCPY(&p_admission_control_info_commit->ue_service_profile.radio_res_config.physical_config_dedicated.pusch_configuration_dedicated,
                        &p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.pusch_configuration_dedicated,
                        sizeof(rrc_phy_pusch_configuration_dedicated_ue_service_profile_t));
            }
            if(p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask & RRC_SERVICE_PROFILE_PHY_ANTENNA_INFORMATION_PRESENT)
            {
                p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask |= RRC_SERVICE_PROFILE_PHY_ANTENNA_INFORMATION_PRESENT;
                RRM_MEMCPY(&p_admission_control_info_commit->ue_service_profile.radio_res_config.physical_config_dedicated.antenna_information,
                        &p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.antenna_information,
                        sizeof(rrc_phy_antenna_information_ue_service_profile_t));
            }
            if(p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask & RRC_SERVICE_PROFILE_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT)
            {
                p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask |= RRC_SERVICE_PROFILE_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;
                RRM_MEMCPY(&p_admission_control_info_commit->ue_service_profile.radio_res_config.physical_config_dedicated.uplink_power_control_dedicated,
                        &p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.uplink_power_control_dedicated,
                        sizeof(rrc_phy_uplink_power_control_dedicated_ue_service_profile_t));
            }
            if(p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask & RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT)
            {
                p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.bitmask |= RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT;
                RRM_MEMCPY(&p_admission_control_info_commit->ue_service_profile.radio_res_config.physical_config_dedicated.cqi_reporting,
                        &p_admission_control_info->ue_service_profile.radio_res_config.physical_config_dedicated.cqi_reporting,
                        sizeof(rrc_phy_cqi_reporting_ue_service_profile_t));
            }
        }
    }
    RRM_MEMCPY(&p_admission_control_info_commit->tnl_capacity,
            &p_admission_control_info->tnl_capacity,
            sizeof(tnl_capacity_t));
    p_admission_control_info_commit->max_eicic_ues =
        p_admission_control_info->max_eicic_ues;
    p_admission_control_info_commit->max_sps_ues =
        p_admission_control_info->max_sps_ues;
    p_admission_control_info_commit->dl_total_bw_prbs =
        p_admission_control_info->dl_total_bw_prbs;
    p_admission_control_info_commit->ul_total_bw_prbs =
        p_admission_control_info->ul_total_bw_prbs;
    p_admission_control_info_commit->ue_sinr_threshold =
        p_admission_control_info->ue_sinr_threshold;
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_commit_ho_oscillation_cfg
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : Void
 * Description    : Update ho_oscillation_cfg for cell reconfig
 ****************************************************************************/

rrm_void_t
rrm_commit_ho_oscillation_cfg( rrm_cell_context_t *p_cell_context )
{

    rrm_ho_oscillation_cfg_t    *p_ho_oscillation_cfg = RRM_PNULL;
    rrm_ho_oscillation_cfg_t    *p_ho_oscillation_cfg_commit = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_ho_oscillation_cfg  =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->operator_info.ho_oscillation_cfg );
    p_ho_oscillation_cfg_commit = &(p_cell_context->operator_info.ho_oscillation_cfg);

    if(p_ho_oscillation_cfg->bitmask & RRMCM_TIME_OF_STAY_THRESHOLD_PRESENT)
    {
        p_ho_oscillation_cfg_commit->bitmask |= RRMCM_TIME_OF_STAY_THRESHOLD_PRESENT;
        p_ho_oscillation_cfg_commit->time_of_stay_threshold = p_ho_oscillation_cfg->time_of_stay_threshold;
    }
    if(p_ho_oscillation_cfg->bitmask & RRMCM_MIN_NUM_OF_OSCILLATION_LOOP_PRESENT)
    {
        p_ho_oscillation_cfg_commit->bitmask |= RRMCM_MIN_NUM_OF_OSCILLATION_LOOP_PRESENT;
        p_ho_oscillation_cfg_commit->min_num_of_oscillation_loop = p_ho_oscillation_cfg->min_num_of_oscillation_loop;
    }
    if(p_ho_oscillation_cfg->bitmask & RRMCM_MAX_LAST_VISITED_CELLS_SEARCHED_PRESENT)
    {
        p_ho_oscillation_cfg_commit->bitmask |= RRMCM_MAX_LAST_VISITED_CELLS_SEARCHED_PRESENT;
        p_ho_oscillation_cfg_commit->max_last_visited_cells_searched = p_ho_oscillation_cfg->max_last_visited_cells_searched;
    }
    if(p_ho_oscillation_cfg->bitmask & RRMCM_HO_OSCILLATION_CIO_STEP_PRESENT)
    {
        p_ho_oscillation_cfg_commit->bitmask |= RRMCM_HO_OSCILLATION_CIO_STEP_PRESENT;
        p_ho_oscillation_cfg_commit->ho_oscillation_cio_step = p_ho_oscillation_cfg->ho_oscillation_cio_step;
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_commit_dynamic_icic_info
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : Void
 * Description    : Update dynamic_icic_info for cell reconfig
 ****************************************************************************/

rrm_void_t
rrm_commit_dynamic_icic_info( rrm_cell_context_t *p_cell_context )
{

    rrm_dynamic_icic_info_t    *p_dynamic_icic_info = RRM_PNULL;
    rrm_dynamic_icic_info_t    *p_dynamic_icic_info_commit = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_dynamic_icic_info  =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->operator_info.dynamic_icic_info );
    p_dynamic_icic_info_commit = &(p_cell_context->operator_info.dynamic_icic_info);

    p_dynamic_icic_info_commit->icic_scheme_type = p_dynamic_icic_info->icic_scheme_type;
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_DL_RESOURCE_PARTITION_INFO_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_DL_RESOURCE_PARTITION_INFO_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->dl_resource_partition_info,
                &p_dynamic_icic_info->dl_resource_partition_info,
                sizeof(rrm_resource_partition_info_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->ul_resource_partition_info,
                &p_dynamic_icic_info->ul_resource_partition_info,
                sizeof(rrm_resource_partition_info_t));
    }
    RRM_MEMCPY(&p_dynamic_icic_info_commit->original_configured_dl_resource_partition_info,
            &p_dynamic_icic_info->original_configured_dl_resource_partition_info,
            sizeof(rrm_resource_partition_info_t));
    RRM_MEMCPY(&p_dynamic_icic_info_commit->original_configured_ul_resource_partition_info,
            &p_dynamic_icic_info->original_configured_ul_resource_partition_info,
            sizeof(rrm_resource_partition_info_t));
    RRM_MEMCPY(&p_dynamic_icic_info_commit->ul_power_mask,
            &p_dynamic_icic_info->ul_power_mask,
            sizeof(rrm_ul_power_mask_t));
    RRM_MEMCPY(&p_dynamic_icic_info_commit->rntp_report_config_info,
            &p_dynamic_icic_info->rntp_report_config_info,
            sizeof(rrm_rntp_report_config_info_t));
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_REPORT_CONFIG_INFO_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_REPORT_CONFIG_INFO_PRESENT;
        if(p_dynamic_icic_info->report_config_info.bitmask & RRM_L2_l1_MEAS_REPORT_CONFIG_INFO)
        {
            p_dynamic_icic_info->report_config_info.bitmask |= RRM_L2_l1_MEAS_REPORT_CONFIG_INFO;
            RRM_MEMCPY(&p_dynamic_icic_info_commit->report_config_info.l1_meas_report_config_info,
                    &p_dynamic_icic_info->report_config_info.l1_meas_report_config_info,
                    sizeof(l2_rrm_layer1_meas_report_config_info_t));
        }
        if(p_dynamic_icic_info->report_config_info.bitmask & RRM_L2_l2_MEAS_REPORT_CONFIG_INFO)
        {
            p_dynamic_icic_info->report_config_info.bitmask |= RRM_L2_l2_MEAS_REPORT_CONFIG_INFO;
            RRM_MEMCPY(&p_dynamic_icic_info_commit->report_config_info.l2_meas_report_config_info,
                    &p_dynamic_icic_info->report_config_info.l2_meas_report_config_info,
                    sizeof(l2_rrm_layer2_meas_report_config_info_t));
        }
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_TPC_FOR_MSG3_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_TPC_FOR_MSG3_PRESENT;
        p_dynamic_icic_info_commit->tpc_for_msg3 = p_dynamic_icic_info->tpc_for_msg3;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_SRS_SUBBAND_GRP_SIZE_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_SRS_SUBBAND_GRP_SIZE_PRESENT;
        p_dynamic_icic_info_commit->srs_subband_group_size = p_dynamic_icic_info->srs_subband_group_size;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUSCH_DCI0_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUSCH_DCI0_PRESENT;
        p_dynamic_icic_info_commit->tpc_trigger_waittime_for_pusch_DCI0 = p_dynamic_icic_info->tpc_trigger_waittime_for_pusch_DCI0;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUCCH_DCI1x2x_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUCCH_DCI1x2x_PRESENT;
        p_dynamic_icic_info_commit->tpc_trigger_waittime_for_pucch_DCI1x2x = p_dynamic_icic_info->tpc_trigger_waittime_for_pucch_DCI1x2x;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUSCH_DCI3A_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUSCH_DCI3A_PRESENT;
        p_dynamic_icic_info_commit->tpc_num_ue_threshold_for_pusch_DCI3A = p_dynamic_icic_info->tpc_num_ue_threshold_for_pusch_DCI3A;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUCCH_DCI3A_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUCCH_DCI3A_PRESENT;
        p_dynamic_icic_info_commit->tpc_num_ue_threshold_for_pucch_DCI3A = p_dynamic_icic_info->tpc_num_ue_threshold_for_pucch_DCI3A;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_COOL_OFF_PRD_FOR_BLER_BIT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_COOL_OFF_PRD_FOR_BLER_BIT;
        p_dynamic_icic_info_commit->cooloff_period_for_bler_triggered_pucchTPC = p_dynamic_icic_info->cooloff_period_for_bler_triggered_pucchTPC;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_COOL_OFF_PERIOD_FOR_PUCCHTPC_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_COOL_OFF_PERIOD_FOR_PUCCHTPC_PRESENT;
        p_dynamic_icic_info_commit->cooloff_period_for_pucchTPC = p_dynamic_icic_info->cooloff_period_for_pucchTPC;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_COOL_OFF_PERIOD_PUSCHTPC_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_COOL_OFF_PERIOD_PUSCHTPC_PRESENT;
        p_dynamic_icic_info_commit->cooloff_period_for_puschTPC = p_dynamic_icic_info->cooloff_period_for_puschTPC;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->alpha_pathloss_target_sinr_map,
                &p_dynamic_icic_info->alpha_pathloss_target_sinr_map,
                sizeof(rrm_alpha_based_pathloss_target_sinr_map_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUSCH_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUSCH_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->delta_sinr_tpc_map_pusch_info,
                &p_dynamic_icic_info->delta_sinr_tpc_map_pusch_info,
                sizeof(rrm_delta_sinr_to_tpc_map_pusch));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_BLER_TO_TPC_MAP_FOR_PUCCH_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_BLER_TO_TPC_MAP_FOR_PUCCH_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->bler_to_tpc_map_for_pucch,
                &p_dynamic_icic_info->bler_to_tpc_map_for_pucch,
                sizeof(rrm_bler_to_tpc_map_for_pucch_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUCCH_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUCCH_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->delta_sinr_tpc_map_pucch_info,
                &p_dynamic_icic_info->delta_sinr_tpc_map_pucch_info,
                sizeof(rrm_delta_sinr_to_tpc_map_pucch_info_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_PDCCH_AGG_AND_POW_OFFSET_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_PDCCH_AGG_AND_POW_OFFSET_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->pdcch_aggregation_power_offset,
                &p_dynamic_icic_info->pdcch_aggregation_power_offset,
                sizeof(rrm_pdcch_aggregation_power_offset_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_CQI_TO_PHICH_POW_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_CQI_TO_PHICH_POW_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->cqi_to_phich_power,
                &p_dynamic_icic_info->cqi_to_phich_power,
                sizeof(rrm_cqi_to_phich_power_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT;
        p_dynamic_icic_info_commit->min_rb_for_pl_phr_calc = p_dynamic_icic_info->min_rb_for_pl_phr_calc;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_SPS_DL_SCHEDULING_INFO_PER_TTI_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_SPS_DL_SCHEDULING_INFO_PER_TTI_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->sps_dl_scheduling_Info_per_tti,
                &p_dynamic_icic_info->sps_dl_scheduling_Info_per_tti,
                sizeof(rrm_sps_dl_scheduling_Info_per_tti_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_SPS_UL_SCHEDULING_INFO_PER_TTI_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_SPS_UL_SCHEDULING_INFO_PER_TTI_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->sps_ul_scheduling_Info_per_tti,
                &p_dynamic_icic_info->sps_ul_scheduling_Info_per_tti,
                sizeof(rrm_sps_ul_scheduling_Info_per_tti_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_SPS_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_SPS_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->alpha_pathloss_target_sinr_map_sps,
                &p_dynamic_icic_info->alpha_pathloss_target_sinr_map_sps,
                sizeof(rrm_alpha_based_pathloss_target_sinr_map_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_DYNAMIC_CFI_EXTENSION_PARAM_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_DYNAMIC_CFI_EXTENSION_PARAM_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->dynamic_cfi_extension_params,
                &p_dynamic_icic_info->dynamic_cfi_extension_params,
                sizeof(rrm_dynamic_cfi_extension_params_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_ATB_CONFIG_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_ATB_CONFIG_PRESENT;
        RRM_MEMCPY(&p_dynamic_icic_info_commit->atb_config,
                &p_dynamic_icic_info->atb_config,
                sizeof(rrm_atb_config_t));
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_UL_MU_MIMO_TYPE_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_UL_MU_MIMO_TYPE_PRESENT;
        p_dynamic_icic_info_commit->ul_mu_mimo_type = p_dynamic_icic_info->ul_mu_mimo_type;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_MSC_THRESHOLD_UL_MU_MIMO_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_MSC_THRESHOLD_UL_MU_MIMO_PRESENT;
        p_dynamic_icic_info_commit->msc_threshold_ul_mu_mimo = p_dynamic_icic_info->msc_threshold_ul_mu_mimo;
    }
    if(p_dynamic_icic_info->bitmask & RRMCM_RMIF_PA_QPSK_INFO_PRESENT)
    {
        p_dynamic_icic_info_commit->bitmask |= RRMCM_RMIF_PA_QPSK_INFO_PRESENT;
        p_dynamic_icic_info_commit->pa_qpsk = p_dynamic_icic_info->pa_qpsk;
    }

    RRM_UT_TRACE_EXIT();
}
/* SPR 21429 Fix End */

rrm_void_t
rrm_commit_operator_info( rrm_cell_context_t *p_cell_context )
{

    operator_info_t    *p_operator_info = RRM_PNULL;
    operator_info_t          *p_operator_info_commit = RRM_PNULL;
    U8                  index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_operator_info  =  &(((rrmcm_rmif_cell_reconfig_req_t *)
                (p_cell_context->p_new_reconfig_data))->operator_info );

    p_operator_info_commit = &(p_cell_context->operator_info);
    /* SPR 21429 Fix Start */
    /* Code Removed */
    /* SPR 21429 Fix End */

    if(p_operator_info->bitmask & RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        /* SPR 21429 Fix Start */
        p_operator_info_commit->cell_params.sub_carrier_spacing = p_operator_info->cell_params.sub_carrier_spacing;
        p_operator_info_commit->cell_params.dl_cyclic_prefix = p_operator_info->cell_params.dl_cyclic_prefix;
        if(p_operator_info_commit->cell_params.bitmask & RRMCM_MAX_RS_EPRE_PRESENT)
        {
            p_operator_info_commit->cell_params.bitmask |= RRMCM_MAX_RS_EPRE_PRESENT;
            p_operator_info_commit->cell_params.max_rs_epre = p_operator_info->cell_params.max_rs_epre;
        }
        if(p_operator_info_commit->cell_params.bitmask & RRMCM_RB_SIZE_PRESENT)
        {
            p_operator_info_commit->cell_params.bitmask |= RRMCM_RB_SIZE_PRESENT;
            p_operator_info_commit->cell_params.rb_size = p_operator_info->cell_params.rb_size;
        }
        /* SPR 21429 Fix End */
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_MAC_CONFIG_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_MAC_CONFIG_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_operator_mac_config(p_cell_context);
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_PHICH_CONFIG_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_PHICH_CONFIG_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        p_operator_info_commit->phich_config = 
            p_operator_info->phich_config;
    }
    /* SPR 18641_18843 fix start */
    if( p_operator_info->bitmask & RRC_SERVICE_PROFILE_UL_SCH_CONFIG_TTI_BUNDLING_INFO_PRESENT)
    {
        p_operator_info_commit->tti_bundling_info = 
        p_operator_info->tti_bundling_info;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "TTI Bitmask  Present, ul_sinr_threshold_to_actv_tti[%d], ul_sinr_threshold_to_deactv_tti[%d], rrm_ue_used_rb_threshold[%d]",
                p_operator_info->tti_bundling_info.ul_sinr_threshold_to_actv_tti,
                p_operator_info->tti_bundling_info.ul_sinr_threshold_to_deactv_tti,
                p_operator_info->tti_bundling_info.rrm_ue_used_rb_threshold);
    }
    /* SPR 18641_18843 fix end */

    p_operator_info_commit->frequency_selective_scheduling.ul_freq_selective_enable = 
        p_operator_info->frequency_selective_scheduling.ul_freq_selective_enable;

    p_operator_info_commit->frequency_selective_scheduling.dl_freq_selective_enable = 
        p_operator_info->frequency_selective_scheduling.dl_freq_selective_enable;

    /* SPR 21429 Fix Start */
    /* Code Removed */
    /* SPR 21429 Fix End */

    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_1_INFO_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_SIB_1_INFO_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_operator_info_sib_1_info( p_cell_context);        
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_SIB_2_INFO_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_operator_info_sib_2_info(p_cell_context);
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_3_INFO_PRESENT)
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_SIB_3_INFO_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_operator_info_sib_3_info(p_cell_context);
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_SIB_4_INFO_PRESENT )
    {
        /* RECONFIG SELF REVIEW FIX START */
        p_operator_info_commit->bitmask |= RRMCM_RMIF_SIB_4_INFO_PRESENT;
        /* RECONFIG SELF REVIEW FIX END */
        rrm_commit_operator_sib_4_info(p_cell_context);
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
            /* SPR 21429 Fix Start */
        rrm_commit_admission_control_info(p_cell_context);
            /* SPR 21429 Fix End */
        /* SPR 11937_11941 Fix start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "New Admission control Information Commited successfully");
        /* SPR 11937_11941 Fix end */
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_FREQ_PRIORITY_LIST)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_FREQ_PRIORITY_LIST;
        RRM_MEMCPY(&p_operator_info_commit->freq_priority_list,
                &p_operator_info->freq_priority_list,
                sizeof(rrm_freq_priority_list_t));
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_PRIORITY_CFG)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_PRIORITY_CFG;
        RRM_MEMCPY(&p_operator_info_commit->priority_cfg,
                &p_operator_info->priority_cfg,
                sizeof(rrm_priority_cfg_t));
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_DAHO_CELL_LIST)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_DAHO_CELL_LIST;
        RRM_MEMCPY(&p_operator_info_commit->daho_cell_config_info,
                &p_operator_info->daho_cell_config_info,
                sizeof(rrm_daho_cell_config_info_t));
    }

    /* SPR 21429 Fix Start */
    if( p_operator_info->bitmask & RRMCM_RMIF_RADIO_CONG_THRESHOLD_PRESENT)
    {
    RRM_MEMCPY(&p_operator_info_commit->radio_cong_threshold,
            &p_operator_info->radio_cong_threshold,
            sizeof(rrm_cellm_radio_congestion_threshold_t));
    }
    /* SPR 21429 Fix End */

    if( p_operator_info->bitmask & RRMCM_SPID_TABLE_PRESENT)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_SPID_TABLE_PRESENT;
        RRM_MEMCPY(&p_operator_info_commit->spid_table,
                &p_operator_info->spid_table,
                sizeof(rrm_oam_spid_table_t));
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_MEASUREMENT_CONFIG_PRESENT)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_MEASUREMENT_CONFIG_PRESENT;
        RRM_MEMCPY(&p_operator_info_commit->meas_config_info,
                &p_operator_info->meas_config_info,
                sizeof(rrm_meas_config_info_t));
    }
    if( p_operator_info->bitmask & RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT;
        RRM_MEMCPY(&p_operator_info_commit->sps_crnti_range_info,
                &p_operator_info->sps_crnti_range_info,
                sizeof(rrm_sps_crnti_range_t));
    }
    RRM_MEMCPY(&p_operator_info_commit->load_congestion_cfg,
            &p_operator_info->load_congestion_cfg,
            sizeof(rrm_load_congestion_cfg_t));
    /* SPR 21429 Fix Start */
    rrm_commit_ho_oscillation_cfg(p_cell_context);
    /* SPR 21429 Fix End */
    if( p_operator_info->bitmask & RRMCM_RMIF_HO_CONFIG_PARAMS_PRESENT)
    {
        p_operator_info_commit->bitmask |=
            RRMCM_RMIF_HO_CONFIG_PARAMS_PRESENT;
        RRM_MEMCPY(&p_operator_info_commit->ho_config_params,
                &p_operator_info->ho_config_params,
                sizeof(rrm_ho_config_params_t));
    }
    /* DYNAMIC ICIC CHANGES START */
    if( p_operator_info->bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT)
    {
        p_operator_info_commit->bitmask |= 
            RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT;
        /* SPR 21429 Fix Start */
        rrm_commit_dynamic_icic_info(p_cell_context);
        /* SPR 21429 Fix End */
    }
    /* DYNAMIC ICIC CHANGES END   */
    /* BUG_371 FIX START */
    if( p_operator_info->bitmask & RRM_RRM_OPERATOR_UL_PWR_CTRL)
    {
        p_operator_info_commit->bitmask |= 
            RRM_RRM_OPERATOR_UL_PWR_CTRL;
        RRM_MEMCPY(&p_operator_info_commit->rrm_operator_ul_pwr_ctrl,
                &p_operator_info->rrm_operator_ul_pwr_ctrl,
                sizeof(rrm_operator_ul_pwr_ctrl_t));
    }
    /* DYNAMIC ICIC CHANGES END   */


    /* BUG_371 FIX END */

    if( p_operator_info->bitmask & RRM_RRM_OPERATOR_UL_PWR_CTRL)
    {
        p_operator_info_commit->bitmask |= 
            RRM_RRM_OPERATOR_UL_PWR_CTRL;
        RRM_MEMCPY(&p_operator_info_commit->rrm_operator_ul_pwr_ctrl,
                &p_operator_info->rrm_operator_ul_pwr_ctrl,
                sizeof(rrm_operator_ul_pwr_ctrl_t));
    }
    /* DYNAMIC ICIC CHANGES END   */


    /* BUG_371 FIX END */

    /** Dynamic UE Scheduling Start **/
    if( p_operator_info->bitmask & RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT )
    {
        p_operator_info_commit->bitmask |= RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT;

        p_operator_info_commit->rrm_ue_scheduling_info.max_ue_scheduled_dl =
            p_operator_info->rrm_ue_scheduling_info.max_ue_scheduled_dl;
        p_operator_info_commit->rrm_ue_scheduling_info.max_ue_scheduled_ul = 
            p_operator_info->rrm_ue_scheduling_info.max_ue_scheduled_ul;

        if( p_operator_info->rrm_ue_scheduling_info.bitmask & RRM_UE_SCHEDULING_HYSTERESIS_PRESENT )
        {
            p_operator_info_commit->rrm_ue_scheduling_info.bitmask |= RRM_UE_SCHEDULING_HYSTERESIS_PRESENT;
            p_operator_info_commit->rrm_ue_scheduling_info.ue_scheduling_hysteresis =
                p_operator_info->rrm_ue_scheduling_info.ue_scheduling_hysteresis;
        }
        else
        {
            if(!( RRM_UE_SCHEDULING_HYSTERESIS_PRESENT & p_operator_info_commit->rrm_ue_scheduling_info.bitmask ))
            {

                p_operator_info_commit->rrm_ue_scheduling_info.bitmask |= RRM_UE_SCHEDULING_HYSTERESIS_PRESENT;
                p_operator_info_commit->rrm_ue_scheduling_info.ue_scheduling_hysteresis =
                    RRM_DEFAULT_HYSTERESIS_DELTA;
            }

        }
    }
    /** Dynamic UE Scheduling End **/

    /* Carrier_Aggregation_Start */
    if( p_operator_info->bitmask & RRMCM_RMIF_CA_CONFIG_INFO_PRESENT)
    {
        rrm_commit_ca_reconfig_info (p_operator_info_commit,
                &p_operator_info->ca_config);
        p_operator_info_commit->bitmask |= RRMCM_RMIF_CA_CONFIG_INFO_PRESENT;
    }
    /* Carrier_Aggregation_End */
    /* Updating tm mode table start */
    if ( p_operator_info->bitmask & RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT)
    {
        if (p_operator_info->rrm_tm_mode_table.bitmask & RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT)
        {
            p_operator_info_commit->rrm_tm_mode_table.tm_mode_for_strngnt_qci =
                p_operator_info->rrm_tm_mode_table.tm_mode_for_strngnt_qci;
            p_operator_info_commit->rrm_tm_mode_table.bitmask |= RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT;
        }
        p_operator_info_commit->rrm_tm_mode_table.count = p_operator_info->rrm_tm_mode_table.count;

        for (index = RRM_ZERO;index < p_operator_info_commit->rrm_tm_mode_table.count;index ++)
        {
            RRM_MEMCPY(&(p_operator_info_commit->rrm_tm_mode_table.rrm_tm_mode_table_row[index]),
                    &(p_operator_info->rrm_tm_mode_table.rrm_tm_mode_table_row[index]),
                    sizeof(rrm_tm_mode_table_row_t));
        }
        p_operator_info_commit->bitmask |= RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT;
    }
    /* Updating tm mode table end*/
    /*CA Stage2:start*/
    if (p_operator_info->bitmask & RRMCM_RMIF_SUBBAND_CQI_PRESENT)
    {
        p_operator_info_commit->k = p_operator_info->k;
        p_operator_info_commit->bitmask |= RRMCM_RMIF_SUBBAND_CQI_PRESENT;
    }
    if (p_operator_info->bitmask & RRMCM_RMIF_SUBBAND_CQI_PERIODCITY_FACTOR_PRESENT)
    {
        p_operator_info_commit->periodicity_factor = p_operator_info->periodicity_factor;
        p_operator_info_commit->bitmask |= RRMCM_RMIF_SUBBAND_CQI_PERIODCITY_FACTOR_PRESENT;
    }
    /*CA Stage2:end*/

    /** eICIC_PHASE_1_2_CHANGES_START */

    /*13956_fix_start*/
    if (RRMCM_RMIF_EICIC_INFO_PRESENT & p_operator_info->bitmask)
    {
        p_operator_info_commit->bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
        /*SPR 14165 start*/
        //code deleted
        /*SPR 14165 end*/
        if (RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT & p_operator_info->eicic_info.bitmask)
        {
            p_operator_info_commit->eicic_info.dl_sinr_threshold_low_mark = p_operator_info->eicic_info.dl_sinr_threshold_low_mark;
            p_operator_info_commit->eicic_info.bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT;
        }
        if (RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT & p_operator_info->eicic_info.bitmask)
        {
            p_operator_info_commit->eicic_info.dl_sinr_threshold_high_mark = p_operator_info->eicic_info.dl_sinr_threshold_high_mark;
            p_operator_info_commit->eicic_info.bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT;
        }
        /*SPR 14456 start*/
        if(RRMCM_RMIF_EICIC_ELIGIBLE_UE_PRESENT & p_operator_info->eicic_info.bitmask)
        {
            p_operator_info_commit->eicic_info.eligible_ue = p_operator_info->eicic_info.eligible_ue;
            p_operator_info_commit->eicic_info.bitmask |= RRMCM_RMIF_EICIC_ELIGIBLE_UE_PRESENT;
        }
        /*SPR 14456 end */

        if ( RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT & p_operator_info->eicic_info.bitmask)
        {
            if(p_operator_info->eicic_info.eicic_timer_info.bitmask & RRMCM_RMIF_AGGRESSOR_SEL_TIMER_PRESENT)
            {
                p_operator_info_commit->eicic_info.eicic_timer_info.aggressor_sel_timer = 
                    p_operator_info->eicic_info.eicic_timer_info.aggressor_sel_timer;

                p_operator_info_commit->eicic_info.eicic_timer_info.bitmask |= RRMCM_RMIF_AGGRESSOR_SEL_TIMER_PRESENT;
            }   

            if(p_operator_info->eicic_info.eicic_timer_info.bitmask & RRMCM_RMIF_LOAD_INFORMATION_GUAURD_TIMER_PRESENT )
            {
                p_operator_info_commit->eicic_info.eicic_timer_info.load_information_guard_timer = 
                    p_operator_info->eicic_info.eicic_timer_info.load_information_guard_timer;

                p_operator_info_commit->eicic_info.eicic_timer_info.bitmask |= RRMCM_RMIF_LOAD_INFORMATION_GUAURD_TIMER_PRESENT;
            }   
            if(p_operator_info->eicic_info.eicic_timer_info.bitmask & RRMCM_RMIF_LOAD_INFORMATION_COLLATION_TIMER )
            {
                p_operator_info_commit->eicic_info.eicic_timer_info.load_information_collation_timer = 
                    p_operator_info->eicic_info.eicic_timer_info.load_information_collation_timer;

                p_operator_info_commit->eicic_info.eicic_timer_info.bitmask |= RRMCM_RMIF_LOAD_INFORMATION_COLLATION_TIMER;
            }   
        } 
        if(p_operator_info->eicic_info.bitmask & RRMCM_RMIF_ABS_INFO_PRESENT)
        {
            if(p_operator_info->eicic_info.abs_info.bitmask & RRMCM_RMIF_NUM_ABS_REPORT_PRESENT)
            {
                p_operator_info_commit->eicic_info.abs_info.num_abs_report = 
                    p_operator_info->eicic_info.abs_info.num_abs_report;

                p_operator_info_commit->eicic_info.abs_info.bitmask |= RRMCM_RMIF_NUM_ABS_REPORT_PRESENT;

            }
            if(p_operator_info->eicic_info.abs_info.bitmask & RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT)
            {
                p_operator_info_commit->eicic_info.abs_info.abs_usage_low_threshold = 
                    p_operator_info->eicic_info.abs_info.abs_usage_low_threshold;

                p_operator_info_commit->eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT;

            }
            if(p_operator_info->eicic_info.abs_info.bitmask & RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT)
            {
                p_operator_info_commit->eicic_info.abs_info.abs_usage_high_threshold = 
                    p_operator_info->eicic_info.abs_info.abs_usage_high_threshold;

                p_operator_info_commit->eicic_info.abs_info.bitmask |= RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT;

            }
            /*SPR 15211 start*/
            /*deleted*/
            /*SPR 15211 send*/
        }
    }
    /*13956_fix_end*/ 
    /** eICIC_PHASE_1_2_CHANGES_END */

    RRM_UT_TRACE_EXIT();
}

rrm_void_t
commit_cell_reconfig_params(rrm_cell_context_t *p_cell_context)
{
    rrmcm_rmif_cell_reconfig_req_t    *p_rrmcm_rmif_cell_reconfig = RRM_PNULL;
    U16                               prev_n1_pucch_an = RRM_ZERO;
    
    RRM_UT_TRACE_ENTER();
    /* Keep the prev n1_pucch_an value for SPS */
    prev_n1_pucch_an = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an;

    p_rrmcm_rmif_cell_reconfig  =  ((rrmcm_rmif_cell_reconfig_req_t *)
                            (p_cell_context->p_new_reconfig_data)) ;
    /*COV_FIX_START_65042*/
    if(p_rrmcm_rmif_cell_reconfig != RRM_PNULL)
        /*COV_FIX_END_65042*/
    { 
    if( p_rrmcm_rmif_cell_reconfig->bitmask & 
                  RRMCM_RMIF_RAN_INFO_PRESENT )
    {
        rrm_commit_ran_info(p_cell_context);
    }
    if(p_rrmcm_rmif_cell_reconfig->bitmask &
                                 RRMCM_RMIF_EPC_INFO_PRESENT)
    {
        rrm_commit_epc_info(p_cell_context);
    }
    if( p_rrmcm_rmif_cell_reconfig->bitmask &
                      RRMCM_RMIF_OPERATOR_INFO_PRESENT)
    {
        rrm_commit_operator_info(p_cell_context);
    }
    if( p_rrmcm_rmif_cell_reconfig->bitmask &
                      RRMCM_RMIF_RRM_ACCESS_MGMT_PARAMS_PRESENT)
    {
       rrm_commit_access_mgmt_params(p_cell_context);
    }
    /* SPS code changes started */
        if(p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an !=  prev_n1_pucch_an) 
        {       
            /* 
             **  This is the case when n1_pucch_an is getting changed by cell_reconfig 
             **  and SPS was already ON by cell_config 
             */
            rrm_reallocate_mem_n1_pucch_an_sps_status (p_cell_context);
            p_cell_context->sps_on = p_rrmcm_rmif_cell_reconfig->cell_reconfig_sps_on;
    }
    /* SPS code changes end */
   /* SPR 9577 CHANGES START */
   if( p_cell_context->sib_present_at_cell_reconfig_time_bitmask !=  p_cell_context->sib_present_at_cell_config_time_bitmask)
   {
            /* SPR 11129 Fix Start */
            p_cell_context->sib_present_at_cell_config_time_bitmask |= p_cell_context->sib_present_at_cell_reconfig_time_bitmask;
            /* SPR 11129 Fix End */
   }
   /* SPR 9577 CHANGES END */    

   /* SPR 20653 Fix Start */
   /* Code Removed */
   /* SPR 20653 Fix End */
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : commit_new_ncl_for_nrt
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the nrt parameters in cell context
 ****************************************************************************/
static rrm_void_t
commit_new_ncl_for_nrt
(
 rrm_cell_context_t *p_cell_ctx,
 U16                bit_mask
 )
{
    RRM_UT_TRACE_ENTER();
    /* Spr 16211 Changes Start*/
    if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
    {
    inter_rat_ncl_t *p_inter_rat_ncl_deleted = RRM_PNULL; 
    inter_rat_ncl_t *p_inter_rat_ncl_added = RRM_PNULL;

    p_inter_rat_ncl_added = (inter_rat_ncl_t *)rrm_mem_get(sizeof(inter_rat_ncl_t));
    if(RRM_PNULL == p_inter_rat_ncl_added)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_inter_rat_ncl_added failed" );
            RRM_UT_TRACE_EXIT();
            return ;

    }
    p_inter_rat_ncl_deleted = (inter_rat_ncl_t *)rrm_mem_get(sizeof(inter_rat_ncl_t));
    if(RRM_PNULL == p_inter_rat_ncl_deleted)
    {

        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_inter_rat_ncl_deleted failed" );
        RRM_MEM_FREE(p_inter_rat_ncl_added);
        RRM_UT_TRACE_EXIT();
        return ;

    }
    rrm_get_delta_ncl_from_updated_nrt(p_cell_ctx,p_inter_rat_ncl_added,p_inter_rat_ncl_deleted);  

    if((RRM_ZERO < p_inter_rat_ncl_deleted->num_valid_geran_cell)||
            (RRM_ZERO < p_inter_rat_ncl_deleted->num_valid_utran_freq_cell))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Sending RIM info req with STOP to Deleted inter rat nbr");
        rrm_request_rim_info_req(p_cell_ctx, p_inter_rat_ncl_deleted, RAN_INFO_REQ_STOP);
    }
    if((RRM_ZERO < p_inter_rat_ncl_added->num_valid_geran_cell)||
            (RRM_ZERO < p_inter_rat_ncl_added->num_valid_utran_freq_cell))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Sending RIM info req with Start to newly added inter rat nbr ");
        rrm_request_rim_info_req(p_cell_ctx,p_inter_rat_ncl_added, RAN_INFO_REQ_MULTI_REPORT);
    }
    RRM_MEM_FREE(p_inter_rat_ncl_added);
    RRM_MEM_FREE(p_inter_rat_ncl_deleted);
    }
    /* Spr 16211 Changes End*/
    
    /* Start: Enh 317 */
    if((bit_mask & RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED) || 
        (bit_mask & RRM_INTRA_FREQ_NON_BROADCAST_NBRS_UPDATED))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Intra-freq Nbrs changed");

        if (bit_mask & RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED)
        {
            /* eICIC_PHASE_1_2_CHANGES_START */
            rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
            /* eICIC_PHASE_1_2_CHANGES_END */
        }

        p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell = 
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell;

        RRM_MEMCPY(&p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells,
            &p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells,
            MAX_INTRA_FREQ_CELLS * sizeof(intra_freq_cells_t));

        if (bit_mask & RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED)
        {
            rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx, p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
        }
    }
    if((bit_mask & RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED) || 
        (bit_mask & RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Inter-freq Nbrs changed");

        if (bit_mask & RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED)
        {
            /* eICIC_PHASE_1_2_CHANGES_START */
            rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
            /* eICIC_PHASE_1_2_CHANGES_END */
        }
        p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell = 
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_inter_freq_cell;

        RRM_MEMCPY(&p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells,
            &p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.inter_freq_cells,
            MAX_INTER_FREQ_CELLS * sizeof(inter_freq_cells_t));

        if (bit_mask & RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED)
        {
            rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx, p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
        }
    }

    /* End: Enh 317 */

    /* Start 7514 NRT Fix - SIB 8 */
    if(bit_mask & RRM_UTRAN_NBRS_UPDATED)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "UTRAN Nbrs changed");

        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_utran_freq_cell =
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_utran_freq_cell;

        RRM_MEMCPY(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells,
                &p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.utran_freq_cells,
                RRM_MAX_UTRAN_NBRS * sizeof(utran_freq_cells_t));
    }
    if(bit_mask & RRM_GERAN_NBRS_UPDATED)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "GERAN Nbrs changed");

        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_geran_cell =
            p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_geran_cell;

        RRM_MEMCPY(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells,
            &p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.geran_freq_cells,
            RRM_MAX_GERAN_NBRS * sizeof(geran_freq_ncl_t));
    }
    /* End 7514 NRT Fix - SIB 8 */

    /* Start: Enh 317 */
    if((RRM_ZERO < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell) ||
        (RRM_ZERO < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell))
    {
        p_cell_ctx->ran_info.ncl_params.bitmask |= RRMCM_RMIF_LTE_NCL_PRESENT;
        p_cell_ctx->ran_info.bitmask |= RRMCM_RMIF_NCL_PARAMS_PRESENT; 
    }
    if((RRM_ZERO < p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_utran_freq_cell) ||
        (RRM_ZERO < p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_geran_cell))
    {
        p_cell_ctx->ran_info.ncl_params.bitmask |= RRMCM_RMIF_INTER_RAT_NCL_PRESENT;
        p_cell_ctx->ran_info.bitmask |= RRMCM_RMIF_NCL_PARAMS_PRESENT; 
    }

    if(!(p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT) &&
        !(p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT))
    {
        p_cell_ctx->ran_info.bitmask ^= RRMCM_RMIF_NCL_PARAMS_PRESENT;
    }
    /* End: Enh 317 */

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
             RRM_DETAILED, "updated ncl info in cell ctx");
    /* BUG_371 FIX START */
    if( p_cell_ctx->sib_present_at_cell_reconfig_time_bitmask !=  p_cell_ctx->sib_present_at_cell_config_time_bitmask)
    {
        p_cell_ctx->sib_present_at_cell_config_time_bitmask |= p_cell_ctx->sib_present_at_cell_reconfig_time_bitmask;     
    }      
    /* BUG_371 FIX END */
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : commit_reconfig_serv_cell_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the reconfig parameters in cell context for
 *                  Reconfig Req triggered by SON meas config feature
 ****************************************************************************/
rrm_void_t
commit_reconfig_serv_cell_param(rrm_cell_context_t *p_cell_ctx)
{
    RRM_UT_TRACE_ENTER();
    RRM_MEMCPY(&(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params),
            &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.idle_mode_mobility_intra_freq_params),
            sizeof(intra_freq_params_t));
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"reconfig: updated idle mode mobility intra freq params in cell ctx");
    RRM_MEMCPY(&(p_cell_ctx->operator_info.sib_3_info.intra_freq_reselection_info),
            &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.cell_reselection_info),
            sizeof(rrm_intra_freq_cell_reselection_info_t));
    if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask &
            RRMCM_SERV_CELL_Q_QUALMIN_R9_PRESENT)
    {
        p_cell_ctx->operator_info.sib_3_info.q_qual_min_r9 =
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.q_qualmin_r9;
        p_cell_ctx->operator_info.sib_3_info.bitmask |= RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1;     
    }
    if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.bitmask &
            RRMCM_SERV_CELL_THRESHX_LOWQ_R9_PRESENT)
    {
        p_cell_ctx->operator_info.sib_3_info.thresh_serving_lowq_r9 =
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->serv_cell_params.threshx_lowq_r9;
        p_cell_ctx->operator_info.sib_3_info.bitmask |= RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT;     
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"reconfig: updated operator cell reselection info params in cell ctx");
    RRM_UT_TRACE_EXIT(); 
}
/****************************************************************************
 * Function Name  : commit_reconfig_inter_freq_params
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the reconfig parameters in cell context for
 *                  Reconfig Req triggered by SON meas config feature
 ****************************************************************************/
rrm_void_t
commit_reconfig_inter_freq_params(rrm_cell_context_t *p_cell_ctx)
{
    U8 cnt = RRM_ZERO;
        meas_eutran_node_t* meas_eutran_ptr = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.num_valid_inter_freq_list = 
        p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list;
    RRM_MEMCPY((p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_freq_params),
            (p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.idle_mode_mobility_inter_freq_params),
            sizeof(inter_freq_params_t) * MAX_NO_INTER_FREQ);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"reconfig: updated idle mode mobility inter freq params in cell ctx");
    /* If Req was for obj add/modify and NOT for obj remove */
    if(RRM_FALSE == p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove)
    {
        /* Search for inter-freq earfcn in eutran meas context list */
        for (cnt = 0; 
                cnt < p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.num_valid_inter_freq_list;
                cnt++)
        {
            meas_eutran_ptr = rrmcm_find_eutran_meas_context(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.
                    idle_mode_mobility_inter_freq_params[cnt].eutra_carrier_arfcn, p_cell_ctx);

            /* OFFSET FREQ CHANGES START */
            if (meas_eutran_ptr)
            {
                /* For the offset frequencies which were updated in reconfig struct and cell ctx 
                   but not in meas object node */
                if(INVALID_OFFSET_FREQ != 
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.offset_freq[cnt])
                {
                    /* Update offset frequency in meas object node */
                    /*coverity 29614, rel2.0.1, aditya*/
                    meas_eutran_ptr->eutran_config.offset_frequency = 
                        (rrm_q_offsetrange_et)p_cell_ctx->p_meas_config_sib_info_for_reconfig->eutran_params.offset_freq[cnt]; 
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Updated offset frequency in meas context list for inter-freq earfcn");
                }
                /* For the offset frequencies which were updated in meas object node and not in reconfig struct */
                else if(FREQ_NOT_CONFIGURED != meas_eutran_ptr->cell_ctx_index)
                {
                    /* Update offset frequency in cell ctx */
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_freq_params[meas_eutran_ptr->cell_ctx_index].cm_offset_freq =
                        meas_eutran_ptr->eutran_config.offset_frequency;

                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_freq_params[meas_eutran_ptr->cell_ctx_index].bitmask |=
                        RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT;

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Updated offset frequency in Cell context for inter-freq earfcn");
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                            "offset frequency was already updated in reconfig param struct for inter-freq earfcn");
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "EARFCN = %d Offset Freq = %d", meas_eutran_ptr->eutran_config.earfcn,
                        meas_eutran_ptr->eutran_config.offset_frequency);
            }
            /* OFFSET FREQ CHANGES END */
        }
    }
RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : commit_reconfig_utra_freq_params
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the reconfig parameters in cell context for
 *                  Reconfig Req triggered by SON meas config feature
 ****************************************************************************/
rrm_void_t
commit_reconfig_utra_freq_params(rrm_cell_context_t *p_cell_ctx)
{
    RRM_UT_TRACE_ENTER();
    U8 cnt = RRM_ZERO;
        meas_utran_node_t*  meas_utran_ptr  = RRM_PNULL;
    /* SPR 22731 Fix Start */
    meas_utran_tdd_node_t*  meas_utran_tdd_ptr  = RRM_PNULL;
    /* SPR 22731 Fix End */
    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.bitmask |= 
        RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT;
    /* Update utra frequency parameters in cell context */
    /* Fix 8172 start */
    RRM_MEMCPY(&(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params),
            &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                idle_mode_mobility_irat_utra_params.irat_eutra_to_utra_reselection_params),
            sizeof(irat_eutra_utra_reselection_params_t));

    if(RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT &
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
            idle_mode_mobility_irat_utra_params.bitmask)
    {
        p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask |= 
            RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT;

        RRM_MEMCPY(&(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list),
                &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list),
                sizeof(irat_eutran_utran_fdd_list_t));
    }
    /* SPR 22731 Fix Start */
    if(RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT &
            p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
            idle_mode_mobility_irat_utra_params.bitmask)
    {
        p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_irat_utra_params.bitmask |= 
            RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT;

        RRM_MEMCPY(&(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list),
                &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list),
                sizeof(irat_eutran_utran_tdd_list_t));

    }
    /* SPR 22731 Fix End */
    /* Fix 8172 end */
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"reconfig: updated idle mode mobility utra params in cell ctx");

    /* Start: Enh 317 */
    /* If Req was for obj add/modify and NOT for obj remove */
    if(RRM_FALSE == p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove)
    {
        /* Search for utran arfcn in utran meas context list */
        for (cnt = 0; 
                cnt < p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                num_irat_eutran_to_utran_fdd_carriers;
                cnt++)
        {
            meas_utran_ptr = rrmcm_find_utran_meas_context(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[cnt].utra_carrier_arfcn, p_cell_ctx);

            /* OFFSET FREQ CHANGES START */
            if (meas_utran_ptr)
            { 
                /* For the offset frequencies which were updated in reconfig struct and cell ctx
                   but not in meas object node */
                if(INVALID_OFFSET_FREQ != 
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.offset_freq[cnt])
                {
                    /* Update offset frequency in meas object node */
                    meas_utran_ptr->utran_config.offset_frequency = 
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.offset_freq[cnt]; 
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Updated offset frequency in meas context list for utran uarfcn");
                }
                /* For the offset frequencies which were updated in meas object node and not in reconfig struct */
                else if(FREQ_NOT_CONFIGURED != meas_utran_ptr->cell_ctx_index)
                {
                    /* Update offset frequency in cell ctx */
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                        irat_eutran_to_utran_fdd_carriers[meas_utran_ptr->cell_ctx_index].offset_freq =
                        meas_utran_ptr->utran_config.offset_frequency;

                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_fdd_list.
                        irat_eutran_to_utran_fdd_carriers[meas_utran_ptr->cell_ctx_index].bitmask |=
                        RRMCM_RMIF_OFFSET_FREQ_PRESENT;

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_BRIEF,"Updated offset frequency in Cell context for Utran arfcn");
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                            "offset frequency was already updated in reconfig param struct for Utran arfcn");
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "UARFCN = %d Offset Freq = %d", meas_utran_ptr->utran_config.uarfcn,
                        meas_utran_ptr->utran_config.offset_frequency);
            }
            /* OFFSET FREQ CHANGES END */
        }
        /* SPR 22731 Fix Start */
        for (cnt = 0; 
                cnt < p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                num_irat_eutran_to_utran_tdd_carriers;
                cnt++)
        {
            meas_utran_tdd_ptr = rrmcm_find_utran_tdd_meas_context(
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.
                    idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                    irat_eutran_to_utran_tdd_carriers[cnt].utra_carrier_arfcn, p_cell_ctx);

            /* OFFSET FREQ CHANGES START */
            if (meas_utran_tdd_ptr)
            { 
                /* For the offset frequencies which were updated in reconfig struct and cell ctx
                   but not in meas object node */
                if(INVALID_OFFSET_FREQ != 
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.offset_freq[cnt])
                {
                    /* Update offset frequency in meas object node */
                    meas_utran_tdd_ptr->utran_tdd_config.offset_frequency = 
                        p_cell_ctx->p_meas_config_sib_info_for_reconfig->utran_params.offset_freq[cnt]; 
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Updated offset frequency in meas context list for utran TDD uarfcn");
                }
                /* For the offset frequencies which were updated in meas object node and not in reconfig struct */
                else if(FREQ_NOT_CONFIGURED != meas_utran_tdd_ptr->cell_ctx_index)
                {
                    /* Update offset frequency in cell ctx */
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                        irat_eutran_to_utran_tdd_carriers[meas_utran_tdd_ptr->cell_ctx_index].offset_freq =
                        meas_utran_tdd_ptr->utran_tdd_config.offset_frequency;

                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_utra_params.irat_eutran_to_utran_tdd_list.
                        irat_eutran_to_utran_tdd_carriers[meas_utran_tdd_ptr->cell_ctx_index].bitmask |=
                        RRMCM_RMIF_OFFSET_FREQ_PRESENT;

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_BRIEF,"Updated offset frequency in Cell context for Utran TDD arfcn");
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                            "offset frequency was already updated in reconfig param struct for Utran TDD arfcn");
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "UARFCN TDD = %d Offset Freq = %d", meas_utran_tdd_ptr->utran_tdd_config.uarfcn_tdd,
                        meas_utran_tdd_ptr->utran_tdd_config.offset_frequency);
            }
            /* OFFSET FREQ CHANGES END */
        }
        /* SPR 22731 Fix End */
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : commit_reconfig_geran_freq_params
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the reconfig parameters in cell context for
 *                  Reconfig Req triggered by SON meas config feature
 ****************************************************************************/
rrm_void_t
commit_reconfig_geran_freq_params(rrm_cell_context_t *p_cell_ctx)
{
    U8 cnt = RRM_ZERO;
        meas_geran_node_t*  meas_geran_ptr  = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.bitmask |= 
        RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT;

    /* Update geran frequency parameters in cell context */
    RRM_MEMCPY(&(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_irat_geran_params),
            &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params),
            sizeof(idle_mode_mobility_irat_geran_params_t));
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"reconfig: updated idle mode mobility geran params in cell ctx");
    /* Search for geran arfcn in geran meas context list */
    for (cnt = RRM_ZERO; 
            cnt < p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers;
            cnt++)
    {
        meas_geran_ptr = rrmcm_find_geran_meas_context(
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                irat_eutran_to_geran_carriers[cnt].geran_car_freqs.starting_arfcn, 
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.
                idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                irat_eutran_to_geran_carriers[cnt].geran_car_freqs.band_ind, p_cell_ctx);

        /* OFFSET FREQ CHANGES START */
        if (meas_geran_ptr)
        {
            if(INVALID_OFFSET_FREQ != p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.offset_freq[cnt])
            {
                /* Update offset frequency in meas object list */
                meas_geran_ptr->geran_config.offset_frequency = 
                    p_cell_ctx->p_meas_config_sib_info_for_reconfig->geran_params.offset_freq[cnt]; 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_BRIEF,"Updated offset frequency in meas context list for geran arfcn");
            }
            else if(FREQ_NOT_CONFIGURED != meas_geran_ptr->cell_ctx_index)
            {
                /* Update offset frequency in cell ctx */
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[meas_geran_ptr->cell_ctx_index].offset_freq =
                    meas_geran_ptr->geran_config.offset_frequency;

                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_geran_params.irat_eutran_to_geran_list.
                    irat_eutran_to_geran_carriers[meas_geran_ptr->cell_ctx_index].bitmask |=
                    RRMCM_GERAN_OFFSET_FREQ_PRESENT;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_BRIEF,"Updated offset frequency in Cell context for Geran arfcn");
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_BRIEF, "offset frequency was already updated in reconfig param struct");
            }
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "GERAN ARFCN =%d Band Ind = %d Offset Freq = %d", 
                    meas_geran_ptr->geran_config.starting_arfcn,
                    meas_geran_ptr->geran_config.band_ind,
                    meas_geran_ptr->geran_config.offset_frequency);
        }
        /* OFFSET FREQ CHANGES END */
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : commit_reconfig_cdma_freq_params
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the reconfig parameters in cell context for
 *                  Reconfig Req triggered by SON meas config feature
 ****************************************************************************/
rrm_void_t
commit_reconfig_cdma_freq_params(rrm_cell_context_t *p_cell_ctx)
{
        meas_cdma_node_t*  meas_cdma_ptr  = RRM_PNULL;
        U8 cnt = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.bitmask |= 
        RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT;

    /* Update geran frequency parameters in cell context */
    RRM_MEMCPY(&(p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_irat_cdma_params),
            &(p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.idle_mode_mobility_irat_cdma_params),
            sizeof(rrmcm_idle_mode_mobility_irat_cdma_params_t));

    rrm_cpy_cdma2000_freq_cells(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
            p_cell_ctx->p_meas_config_sib_info_for_reconfig);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED,"reconfig: updated idle mode mobility cdma params in cell ctx");
    /* Search for cdma arfcn in geran meas context list */
    for (cnt = 0; 
            cnt < p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.num_valid_cdma2000_freq_cells;
            cnt++)
    {
        /* coverity : CID 30987 */
        meas_cdma_ptr = rrmcm_find_cdma_meas_context(
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.cdma2000_freq_cells[cnt].arfcn,
                (rrm_son_cdma_band_class_et)p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.cdma2000_freq_cells[cnt].band_class,
                p_cell_ctx);

        if (meas_cdma_ptr && 
                (INVALID_OFFSET_FREQ != p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.offset_freq[cnt]))
        {
            /* Update offset frequency in meas object list */
            meas_cdma_ptr->cdma_config.offset_frequency = 
                p_cell_ctx->p_meas_config_sib_info_for_reconfig->cdma_params.offset_freq[cnt]; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_BRIEF,"Updated offset frequency in meas context list for cdma arfcn %d::%d",
                    meas_cdma_ptr->cdma_config.arfcn,
                    meas_cdma_ptr->cdma_config.offset_frequency);
        }
    }
  RRM_UT_TRACE_EXIT();
}

/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : commit_reconfig_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the reconfig parameters in cell context for 
 *                  Reconfig Req triggered by SON meas config feature
 ****************************************************************************/
rrm_void_t
commit_reconfig_param
(
  rrm_cell_context_t *p_cell_ctx
)
{
    RRM_UT_TRACE_ENTER();
    /*21481: need to commit reconfig param
     */
    /*Reconfig Crash for Meas Config: Fix Start*/
    /*Reconfig Crash for Meas Config: Fix End*/
        /* Cell reconfig response is for SON */
        if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_SERV_CELL_PARAMS_PRESENT)
        {
            /*Klockwork_fix_start*/
            commit_reconfig_serv_cell_param(p_cell_ctx);
            /*Klockwork_fix_end*/
            /* Update serving frequency parameters in cell context */
        }
        if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_INTER_FREQ_PARAMS_PRESENT)
        {
            /*Klockwork_fix_start*/
            commit_reconfig_inter_freq_params(p_cell_ctx);
            /*Klockwork_fix_end*/
            /* Update inter frequency parameters in cell context */
        }
        /* Start: Enh 317 - Delete */        

        if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_UTRA_FREQ_PARAMS_PRESENT)
        {
            /*Klockwork_fix_start*/
            commit_reconfig_utra_freq_params(p_cell_ctx);
            /*Klockwork_fix_end*/
        }
 
        if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_GERAN_FREQ_PARAMS_PRESENT)
        {
            /*Klockwork_fix_start*/
            commit_reconfig_geran_freq_params(p_cell_ctx);
            /*Klockwork_fix_end*/
        }
        if(!(p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT) &&
            !(p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT))
        {
            p_cell_ctx->ran_info.bitmask ^= RRMCM_RMIF_NCL_PARAMS_PRESENT;
        }

        /*SPR 5676 Fix Start*/
        if(p_cell_ctx->p_new_reconfig_data)
        {
            RRM_MEMCPY(&(p_cell_ctx->operator_info.sib_1_info.scheduling_info_list),
                    &p_cell_ctx->p_new_reconfig_data->operator_info.sib_1_info.scheduling_info_list,
                    sizeof(rrm_scheduling_info_list_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Updated Scheduling Info in Cell Context");
        }
        /*SPR 5676 Fix End*/
        if (p_cell_ctx->p_meas_config_sib_info_for_reconfig->bitmask & RRMCM_CDMA_FREQ_PARAMS_PRESENT)
        {
            /*Klockwork_fix_start*/
            commit_reconfig_cdma_freq_params(p_cell_ctx);
            /*Klockwork_fix_end*/
        }


    /* Start: Enh 317 */
    /* If Req was for obj remove and NCL was updated */
    if((RRM_TRUE == p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove)
        && (p_cell_ctx->p_ncl_built_from_updated_nrt_info)) 
    {
        commit_new_ncl_for_nrt(p_cell_ctx, p_cell_ctx->updated_nrt_bitmask);

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_DETAILED, "reconfig: updated NCL in cell ctx after Meas Obj Removal");
        rrmcm_print_nbr_list_for_nrt(p_cell_ctx);
        /* Check scell Blacklist status after the NCL update commited*/        
         rrmcm_check_updated_ncl_for_csg_id_and_bl_change(p_cell_ctx, p_cell_ctx->updated_nrt_bitmask);

        
    }
    /* End: Enh 317 */

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rmcm_rmif_reconfig_ongoing_reconfig_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles RrmRrcCellStopReconfigResp in FSM
 ****************************************************************************/
rrm_return_et 
rmcm_rmif_reconfig_ongoing_reconfig_resp
(
    rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;
    
    srs_t *p_srs_info_bfr_reconfig = RRM_PNULL;
    pucch_t *p_cqi_sr_info_bfr_reconfig = RRM_PNULL;
    /* +- SPR 18268 */
    U16 max_num_ue_per_cell_bfr_reconfig = RRM_ZERO;
    /* +- SPR 18268 */

    /*DYNAMIC ICIC START*/
    //cell_timer_buf_t timer_buf;
    /*DYNAMIC ICIC END*/


    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
						                                p_cell_ctx->p_incoming_api_info;

    if (RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
    {
       if(RRM_CELLM_REF_SIG_PWR_NOT_UPDATED != p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
       {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                               RRM_BRIEF,"Failure for Dynamic icic reconfig:"
                               " Reconfig Resp From RRC::%d",
                               p_rrc_rrm_cell_reconfig_resp->fail_cause);
               
               ret_val = rmcm_start_for_reconfig(p_cell_ctx);
               if(ret_val == RRM_FAILURE)
               {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                       RRM_ERROR,"failure in rmcm_start_for_reconfig");
               }

       }
       else
       {
        /*need to chk fail cause*/
        switch(p_rrc_rrm_cell_reconfig_resp->fail_cause)
        {
            case RRM_RRC_LL_CONFIG_FAILURE:
            case RRM_RRC_INTERNAL_FAILURE:    
                /*start the cell 
                 */
                p_cell_ctx->stop_reconfig_fail |= RRM_RECONFIG_FAIL;
								p_cell_ctx->ongoing_procedure_fail_cause = 
												          p_rrc_rrm_cell_reconfig_resp->fail_cause;
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                           RRM_BRIEF,"Reconfig Resp From RRC::%d",
                           p_rrc_rrm_cell_reconfig_resp->fail_cause);
                ret_val = rmcm_start_for_reconfig(p_cell_ctx);
                if(ret_val == RRM_FAILURE)
                {
				               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                           RRM_ERROR,"failure in rmcm_start_for_reconfig");
                }
                break;
            case RRM_RRC_UNKNOWN_FAILURE:
                ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
                if(ret_val == RRM_FAILURE)
                {
				                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                           RRM_ERROR,"failure in rmcm_mif_send_reconfig_fail_resp");
                }
                CELL_M_FSM_SET_STATE(p_cell_ctx,
                                  CELL_STATE_W_FOR_CELL_DEL);
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                   RRM_BRIEF,"Reconfig Fail Cell State Is:%s For Cell Index:%d",
					CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
                break;
            default:
                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                          "unknown failure for reconfig from RRC:%d",
                           p_rrc_rrm_cell_reconfig_resp->fail_cause);
        }
    }
    }
    else
    {   
        /* BUG_876_CHANGES_START */
        /** -- Reset the timer maintained for the cell reconfiguration for ICIC
            */
            p_cell_ctx->dynamic_icic_data.num_ues_in_cell_edge = RRM_ZERO;     
            p_cell_ctx->dynamic_icic_data.num_ues_in_cell_center = RRM_ZERO;     
            p_cell_ctx->dynamic_icic_data.num_ues_handout_in_olpc = RRM_ZERO;     
            p_cell_ctx->dynamic_icic_data.num_ues_vd_max_p_a_val = RRM_ZERO;     
            p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;     
            /*Location update fix in UE RECONFIG*/
            p_cell_ctx->dynamic_icic_data.mac_loc_update_triggrd_aftr_ue_reconfig = RRM_FALSE;
            /*Location update fix in UE RECONFIG*/
        /* BUG_876_CHANGES_END*/
            p_cqi_sr_info_bfr_reconfig = (pucch_t*)rrm_mem_get(sizeof(pucch_t));
            if (p_cqi_sr_info_bfr_reconfig == RRM_PNULL)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Memory allocation to p_cqi_sr_info_bfr_reconfig failed" );
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }

            if(p_cell_ctx->ran_info.physical_layer_params.bitmask & 
                    RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)
            {
                p_srs_info_bfr_reconfig = (srs_t*)rrm_mem_get(sizeof(srs_t));
                if (p_srs_info_bfr_reconfig == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_srs_info_bfr_reconfig failed" );
                    RRM_UT_TRACE_EXIT();
                    RRM_MEM_FREE(p_cqi_sr_info_bfr_reconfig);
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(p_srs_info_bfr_reconfig ,&(p_cell_ctx->ran_info.
                            physical_layer_params.physical_layer_param_srs),sizeof(srs_t));
            }

            RRM_MEMCPY(p_cqi_sr_info_bfr_reconfig ,&(p_cell_ctx->ran_info.
                        physical_layer_params.physical_layer_param_pucch),sizeof(pucch_t));

            max_num_ue_per_cell_bfr_reconfig = p_cell_ctx->operator_info.admission_control_info.
                max_num_ue_per_cell; 

            commit_cell_reconfig_params(p_cell_ctx);
            /*
             ** Update the PUCCH/PUSCH resource pool as per the new configuration
             */
            update_pucch_pusch_resources_on_reconfig( p_cell_ctx ,
                    p_srs_info_bfr_reconfig , 
                    p_cqi_sr_info_bfr_reconfig,
                    max_num_ue_per_cell_bfr_reconfig);

            if(RRM_PNULL != p_cqi_sr_info_bfr_reconfig)
            {
                RRM_MEM_FREE(p_cqi_sr_info_bfr_reconfig);
            }
            if(RRM_PNULL != p_srs_info_bfr_reconfig)
            {
                RRM_MEM_FREE(p_srs_info_bfr_reconfig);
            }                
        /* BUG_876_CHANGES_START */
        /* BUG_876_CHANGES_END*/
     /*Coverity_fix_start_54964*/
        ret_val = rmcm_start_for_reconfig(p_cell_ctx);
        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in rmcm_start_for_reconfig");
        }
        ret_val = RRM_SUCCESS;
    }
    /*Coverity_fix_end_54964*/ 
  if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
  {
          RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
          p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
  }
   RRM_UT_TRACE_EXIT();    
   return ret_val;
}

/*********************************************************************
* Function Name  : rmcm_start_for_reconfig
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles start request to RRC in for reconfig in FSM
**********************************************************************/
rrm_return_et
rmcm_start_for_reconfig
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrc_rrm_cell_start_req_t *p_cell_start_req = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "send cell start req for cell :%d",
              p_cell_ctx->cell_index);

    p_cell_start_req = rrm_mem_get(sizeof(rrc_rrm_cell_start_req_t));
    if (p_cell_start_req == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_start_req failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }
 
    /* SPR 21660 changes start */
    ret_val =build_send_start_req(p_cell_ctx->ongoing_trans_id,
            p_cell_ctx->cell_index, p_cell_start_req);
    /* SPR 21660 changes end */
 
    if(RRM_FAILURE == ret_val)
    {						
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed To Send Cell Start Req to RRC");
			generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
			generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
			  		generic_resp_to_mif.response = RRM_FAILURE;
			generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
			ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
			  				  RRMCM_RMIF_CELL_RECONFIG_RESP);
       /*Chnage the cell state*/
       CELL_M_FSM_SET_STATE(p_cell_ctx,
                     CELL_STATE_W_FOR_CELL_DEL);
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Cell Reconfig Failed for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
			ret_val = RRM_FAILURE;
	}
	else
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx,
                     CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_START_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Reconfig Ongoing for Cell Index:%d Cell State is:%s",
                          p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
	   ret_val = RRM_SUCCESS;
    }
    RRM_MEM_FREE(p_cell_start_req);
    RRM_UT_TRACE_EXIT();
	return ret_val;
    
}

rrm_return_et
rmcm_send_rrc_setup_req
(
rrc_rrm_cell_setup_req_t   *p_cell_setup_req,
rrm_cell_context_t         *p_cell_ctx,
rrmcm_rmif_generic_resp_t  *generic_resp_to_mif,
rrm_return_et              *ret_val
)
{
    RRM_UT_TRACE_ENTER();

    p_cell_setup_req = rrm_mem_get(sizeof(rrc_rrm_cell_setup_req_t));
    if (p_cell_setup_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_setup_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /* BUG_876_CHANGES_START*/
    /* This function call will update the modified parameters received in 
       Cell Reconfigration request from MIF to the local Cell Context.
       Intent of doing this is to update the modified parameters in Cell Context
       After the modified parameteres gets updated in Cell Context,
       Cell Manager can call the build_and_send_rrc_setup_req message
       to preapre the RRC Setup Request with the Old cell
       configuration updated with new set of changed values*/
/*SPR 21485 Start*/
    if (RRM_PNULL != p_cell_ctx->p_new_reconfig_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "This is OAm triggered Cell Reconfigration Request to L3. So updating Cell Ctxt");
    if (RRM_PNULL != p_cell_ctx->p_new_reconfig_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "This is OAm triggered Cell Reconfigration Request to L3. So updating Cell Ctxt");
            commit_cell_reconfig_params(p_cell_ctx);
        }
        else if(RRM_PNULL != p_cell_ctx->p_new_update_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "This is internally triggered(Dynamic ICIC) Cell Reconf Requ to L3. So updating Cell Ctxt");
            p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power = 
                ((rrm_cellm_cell_reconfig_params_for_icic_t *)
                 (p_cell_ctx->p_new_update_data))->refrence_signal_power;
        }
    }
    else if(RRM_PNULL != p_cell_ctx->p_new_update_data)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "This is internally triggered(Dynamic ICIC) Cell Reconf Requ to L3. So updating Cell Ctxt");
        p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power = 
            ((rrm_cellm_cell_reconfig_params_for_icic_t *)
             (p_cell_ctx->p_new_update_data))->refrence_signal_power;
    }

    *ret_val = build_send_rrc_setup_req (p_cell_ctx, p_cell_setup_req);
    if (*ret_val == RRM_FAILURE)
    {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	  "Failed To Send ReConfig Req To RRC For Cell Index:%d",
	  p_cell_ctx->cell_index);
      if(RRM_CELLM_REF_SIG_PWR_NOT_UPDATED == p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
      {
      generic_resp_to_mif->cellindex = p_cell_ctx->cell_index; 
      generic_resp_to_mif->transaction_id = p_cell_ctx->ongoing_trans_id;
/*SPR 21485 Start*/
      generic_resp_to_mif->response = RRM_FAILURE;
      generic_resp_to_mif->fail_cause = RRM_ERR_CELL_DELETION_EXPECTED;
      *ret_val = build_and_send_generic_resp_to_mif(generic_resp_to_mif, 
	  RRMCM_RMIF_CELL_RECONFIG_RESP);
      }
      CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_DEL_RECONFIG_FAILED);
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	  "Send Reconfig Req Cell State is:%s[%d]",
	  CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
    }
    else
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CONFIG_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Send Reconfig Req Cell State is:%s[%d]",
                CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_state);
    }

    RRM_MEM_FREE(p_cell_setup_req);
    if (RRM_PNULL != p_cell_ctx->p_new_reconfig_data)
    {
        RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
        p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
    }
    else if (RRM_PNULL != p_cell_ctx->p_new_update_data)
    {
        RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
        p_cell_ctx->p_new_update_data = RRM_PNULL;
    }
    /* BUG_876_CHANGES_END*/
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}        
/*klock_works_changes_start*/
rrm_return_et
rrm_chek_and_send_generic_resp
(
 rrm_cell_context_t         *p_cell_ctx,
 rrmcm_rmif_generic_resp_t  *p_generic_resp,
 rrm_return_et              *ret_val
 )
{
    RRM_UT_TRACE_ENTER();

          p_generic_resp->cellindex = p_cell_ctx->cell_index;
          p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
          p_generic_resp->response = RRM_SUCCESS;

          if (p_cell_ctx->deletion_flag)
          {
              p_generic_resp->fail_cause = fail_cause_mapping(
                      p_cell_ctx->ongoing_procedure_fail_cause);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "Cell Deleted with fail cause:%d for cell index:%d",
                      p_generic_resp->fail_cause, p_cell_ctx->cell_index);
          }
          else
          {
              p_generic_resp->fail_cause = RRM_NO_ERROR;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                      "Cell Deleted Succesfully for cell index:%d",
                      p_cell_ctx->cell_index);
          }

          if (RRM_FAILURE == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                      RRMCM_RMIF_CELL_DELETE_RESP,
                      sizeof(rrmcm_rmif_generic_resp_t),
                      (void *)p_generic_resp))
          {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "failure in sending :%d for cell index:%d",
                      RRMCM_RMIF_CELL_DELETE_RESP,
                      p_cell_ctx->cell_index);
        *ret_val = RRM_FAILURE;
          }
          else
          {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                      "success in sending :%d for cell index:%d",
                      RRMCM_RMIF_CELL_DELETE_RESP,
                      p_cell_ctx->cell_index);
        *ret_val = RRM_SUCCESS;
        CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_IDLE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                      "Cell State is: %s",
                      CELL_FSM_STATE[p_cell_ctx->cell_state]);
          }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*klock_works_changes_end*/

/*********************************************************************
 * Function Name  : rmcm_mif_send_del_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles delete response from UEM in FSM
 *********************************************************************/
rrm_return_et
rmcm_mif_send_del_resp(rrm_cell_context_t  *p_cell_ctx)
{
    rrm_return_et              ret_val = RRM_FAILURE;
    rrmcm_rmif_generic_resp_t  *p_generic_resp = RRM_PNULL;
    rrc_rrm_cell_setup_req_t   *p_cell_setup_req = RRM_PNULL; 
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();

    /* SPR 21412 Cell Reconfig Fix Start */
    /* SPR 21412 Cell Reconfig Fix End*/

    if (p_cell_ctx->cell_reconfig_deletion_required)
    {
        /* SPR 21412 Cell Reconfig Fix Start */
                        /* SPR 21412 Cell Reconfig Fix End*/
                        /*klock_works_changes_start*/
                        if(RRM_FAILURE==rmcm_send_rrc_setup_req(p_cell_setup_req, p_cell_ctx, &generic_resp_to_mif, &ret_val))
                        {
                            RRM_UT_TRACE_EXIT();
                            return RRM_FAILURE;
                        }
                        /*klock_works_changes_end*/
                        /* SPR 21412 Cell Reconfig Fix Start*/
        /* SPR 21412 Cell Reconfig Fix End*/
    }
    else
    {

        /* SPR 13377 start */
        CELL_STATE_CHNAGE_IND(p_cell_ctx, CELL_STATE_DELETE_IN_PROGRESS);
        /* SPR 13377 end */
        p_generic_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_resp_t));

        /* coverity  id :16272 , added NULL check for rrm_mem_get */
        if(p_generic_resp != RRM_PNULL)
        {
            /*klock_works_changes_start*/       
            rrm_chek_and_send_generic_resp(p_cell_ctx, p_generic_resp, &ret_val); 
            /*klock_works_changes_end*/

            RRM_MEM_FREE(p_generic_resp);
        }
        else
        {
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                    "Memory allocation to p_generic_resp failed");
            ret_val = RRM_FAILURE;
        }
        /* CA_Stage3_Change: Start */
        /* When Cell Config Resp is sent as success to OAM,
           then we update this count for total no. of cells configured on eNB and
           reduced when cell is deleted.*/

        p_g_rrm_cell_ctx->enb_cell_count--;

        /* CA_Stage3_Change: End */ 
        #ifdef LTE_EMBMS_SUPPORTED
        p_cell_ctx->operator_info.sib_13_info.num_valid_mcch_info = RRM_ZERO; 
        RRM_MEMSET(p_cell_ctx->operator_info.sib_13_info.embms_sib13_mcch_data, RRM_ZERO, 
            RRM_MAX_MBSFN_ALLOCATIONS * sizeof(m2ap_mcch_related_bcch_info_t));
        #endif
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_start*/
/*********************************************************************
 * Function Name  : rmcm_ue_del_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles delete response from UEM in FSM
 *********************************************************************/
rrm_return_et
rmcm_ue_del_send_generic_resp(rrm_cell_context_t                      *p_cell_ctx ,
                              rrmuem_cm_delete_all_ue_context_res_t   *p_resp)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_cell_generic_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_cell_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /* coverity ,id :16286 , added NULL check for rrm_mem_get return value */
    if(p_cell_generic_resp != RRM_PNULL)
    {
        p_cell_generic_resp->cellindex = p_resp->cell_index;
        p_cell_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_cell_generic_resp->response = RRM_SUCCESS;
        p_cell_generic_resp->fail_cause = RRM_NO_ERROR;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "1.Cell Stop Success For Cell Index:%d",
                p_resp->cell_index);
        if(RRM_FAILURE ==  rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_STOP_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_cell_generic_resp))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "1.Failed to Send Cell Stop Resp:%d For Cell Index:%d",
                    RRMCM_RMIF_CELL_STOP_RESP,p_cell_ctx->cell_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "1.Send Cell Stop Resp :%d To Mif For Cell Index:%d",
                    RRMCM_RMIF_CELL_STOP_RESP,p_cell_ctx->cell_index);
        }
        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_INACTIVE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "1.Cell Stop Succ Resp for Cell Index:%d Cell State is:%s",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state]);
        CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_INACTIVE); 
        /*Unsetting the Flag*/
        p_cell_ctx->cell_stop_ongoing_del_ue_ctxt = RRM_FALSE;
        RRM_MEM_FREE(p_cell_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_generic_resp failed");
        ret_val = RRM_FAILURE; 
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/*********************************************************************
 * Function Name  : rmcm_ue_del_resp
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles delete response from UEM in FSM
 *********************************************************************/
rrm_return_et
rmcm_ue_del_resp
(
    rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
   rrm_return_et ret_val = RRM_SUCCESS;
   rrmuem_cm_delete_all_ue_context_res_t *p_resp = RRM_PNULL;

   RRM_UT_TRACE_ENTER();
 
   p_resp = (rrmuem_cm_delete_all_ue_context_res_t *)
                          (p_cell_ctx->p_incoming_api_info);

   if (RRM_TRUE == p_resp->response) 
   {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
              "UE deleted successfully for cell_index:%d",
                p_cell_ctx->cell_index);
#ifdef RRM_UT_FLAG        
      RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_resp_S_uem);
      RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.delete_all_ue_resp_S);
#endif
      /*Coverity 82620 Fix Start*/
      /*ret_val = RRM_SUCCESS;*/
      /*Coverity 82620 Fix Start*/
   }
   else
   {
     
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
              "UE deleted unsuccefullyfor cell index:%d",
                p_cell_ctx->cell_index);
#ifdef RRM_UT_FLAG        
      RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_resp_F_uem);
#endif        
   }
   /*Send response to MIF
    */ 
   /*BUG:183*/
   if (p_cell_ctx->cell_stop_ongoing_del_ue_ctxt == RRM_FALSE)
   {
       ret_val = rmcm_mif_send_del_resp(p_cell_ctx);
       if (ret_val == RRM_FAILURE)
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                   "Failed to Send Cell del RESp to MIf");
       } 
   }
   else
   {
       /*Klockwork_fix_start*/
       ret_val =rmcm_ue_del_send_generic_resp(p_cell_ctx ,p_resp);
       /*Klockwork_fix_end*/
       
   }
   /*RIM changes start*/
    /* Spr 16211 Changes Start*/
   if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
   {
       RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
               "Sending RIM info req with PDU type as STOP as cell has moved to inactive state");
       rrm_request_rim_info_req(p_cell_ctx,
               &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
               RAN_INFO_REQ_STOP);
   }
    /* Spr 16211 Changes End*/
   /*RIM changes end*/

   /*BUG:183*/
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/*******************************************************************
* Function Name  : rmcm_mif_start_adm_reqResp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : set start admission flag true
********************************************************************/
rrm_return_et
rmcm_mif_send_start_adm_resp
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16274 , added NULL check for rrm_mem_get */
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_generic_resp->response = RRM_SUCCESS;
        p_generic_resp->fail_cause=RRM_NO_ERROR;

        if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_START_ADMISSION_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_generic_resp))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_START_ADMISSION_RESP,
                    p_cell_ctx->cell_index);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_START_ADMISSION_RESP,
                    p_cell_ctx->cell_index);
        }
        RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/*******************************************************************
* Function Name  : rmcm_mif_start_adm_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : set start admission flag true
********************************************************************/

rrm_return_et
rmcm_mif_start_adm_req
(
     rrm_cell_context_t *p_cell_ctx
)
{
   rrm_return_et ret_val = RRM_SUCCESS;
   RRM_UT_TRACE_ENTER();
   
 
   p_cell_ctx->stop_adm_flag = RRM_FALSE;
   /*Send response to MIF
    */
   rmcm_mif_send_start_adm_resp(p_cell_ctx);

   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/*******************************************************************
* Function Name  : rmcm_mif_stop_adm_resp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles delete response from UEM in FSM
********************************************************************/
rrm_return_et
rmcm_mif_stop_adm_resp
(
    rrm_cell_context_t *p_cell_ctx
)
{

    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    void *ptr = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16277 , added NULL check for rrm_mem_get */
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_generic_resp->response = RRM_SUCCESS;
        p_generic_resp->fail_cause =RRM_NO_ERROR;
        ptr = (void *)p_generic_resp;

        if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    ptr))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                    p_cell_ctx->cell_index);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                    p_cell_ctx->cell_index);
        }
        RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
 /*Klockwork_fix_start*/
 /*******************************************************************
 * Function Name  : rmcm_rrm_cell_block_stop_adm
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig response from RRC for Cell Block in FSM
 ********************************************************************/
rrm_void_t
rmcm_rrm_cell_block_stop_adm(rrm_cell_context_t    *p_cell_ctx,
                             void                  *ptr)
{
    RRM_UT_TRACE_ENTER();
    if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                sizeof(rrmcm_rmif_generic_resp_t),
                ptr))

    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "failure in sending :%d for cell index:%d",
                        RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                        p_cell_ctx->cell_index);
            }
            else
            {
                CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
                /*spr 21625 fix start*/
                p_cell_ctx->ran_info.cell_restriction_params.cell_and_access_barring.cell_barred = RRM_OAM_CELL_BARRED;
                /*spr 21625 fix end*/
        	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "success in sending :%d for cell index:%d",
                        RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                        p_cell_ctx->cell_index);
            }
    RRM_UT_TRACE_EXIT();
}
/*******************************************************************
 * Function Name  : rmcm_rrm_cell_block_not_stop_adm
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig response from RRC for Cell Block in FSM
 ********************************************************************/
    rrm_void_t
rmcm_rrm_cell_block_not_stop_adm(rrm_cell_context_t    *p_cell_ctx,
                                 void                  *ptr)
{
    RRM_UT_TRACE_ENTER();
    if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                RRMCM_RMIF_CELL_START_ADMISSION_RESP,
                sizeof(rrmcm_rmif_generic_resp_t),
                ptr))

    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "failure in sending :%d for cell index:%d",
                RRMCM_RMIF_CELL_START_ADMISSION_RESP,
                p_cell_ctx->cell_index);
    }
    else
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
        /*spr 21625 fix start*/
        p_cell_ctx->ran_info.cell_restriction_params.cell_and_access_barring.cell_barred = RRM_OAM_CELL_NOT_BARRED;
        /*spr 21625 fix end*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "success in sending :%d for cell index:%d",
                RRMCM_RMIF_CELL_START_ADMISSION_RESP,
                p_cell_ctx->cell_index);
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/*******************************************************************
 * Function Name  : rmcm_rrm_reconfig_resp_for_cell_block
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig response from RRC for Cell Block in FSM
 ********************************************************************/
rrm_return_et
rmcm_rrm_reconfig_resp_for_cell_block
(
 rrm_cell_context_t *p_cell_ctx /*cell context*/
 )
{
    RRM_UT_TRACE_ENTER();

    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;

    p_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    if(p_generic_resp != RRM_PNULL)
    {
        p_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_generic_resp->response = RRM_SUCCESS;
        p_generic_resp->fail_cause =RRM_NO_ERROR;
/*reconfig response is for cell block*/
        if(p_cell_ctx->stop_adm_flag == RRM_TRUE)
        {
            /*Klockwork_fix_start*/
            rmcm_rrm_cell_block_stop_adm(p_cell_ctx, (void *)p_generic_resp);
            /*Klockwork_fix_end*/
        }
/*reconfig response is for cell unblock*/
        else if(p_cell_ctx->stop_adm_flag == RRM_FALSE)
        {
             /*Klockwork_fix_start*/
            rmcm_rrm_cell_block_not_stop_adm(p_cell_ctx, (void *)p_generic_resp);
            /*Klockwork_fix_end*/

        }
	RRM_MEM_FREE(p_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_generic_resp failed");
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************
* Function Name  : rmcm_mif_stop_adm_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles delete response from UEM in FSM
********************************************************************/
rrm_return_et
rmcm_mif_stop_adm_req
(
  rrm_cell_context_t *p_cell_ctx /*cell context*/
)
{

   rrm_return_et ret_val = RRM_SUCCESS;
   RRM_UT_TRACE_ENTER();
   
   p_cell_ctx->stop_adm_flag = RRM_TRUE;
   /*Send response to MIF
    */
   /* Carrier Aggregation start*/

   p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.
       ca_config_bitmask |= RRM_CA_CELL_STOP_ADM_BITMASK ;
   rrm_broadcast_carrier_agg_configuration_change_event_at_eNB(
           p_cell_ctx->cell_index,
           p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask ,p_cell_ctx->ongoing_trans_id);

   p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;

   /* stopping the timer on cell stop response besides of cell stop req */
   if ( RRM_ZERO != p_cell_ctx->intra_eNB_cell_load_broadcast_timer )
   {
       cell_stop_timer( p_cell_ctx->intra_eNB_cell_load_broadcast_timer );
       p_cell_ctx->intra_eNB_cell_load_broadcast_timer = RRM_ZERO;
   }
   /* Carrier Aggregation end */ 
   rmcm_mif_stop_adm_resp(p_cell_ctx);

   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/*******************************************************************
* Function Name  : RrmMifCellDereqisterResp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles cell deregister response for MIF in FSM
********************************************************************/
rrm_return_et
rmcm_mif_deregister_resp
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrmcm_rmif_generic_resp_t *p_cell_generic_resp = RRM_PNULL;
    void *ptr = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16267 , added NULL check for rrm_mem_get */
    if(p_cell_generic_resp != RRM_PNULL)
    {
        p_cell_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_cell_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_cell_generic_resp->response = RRM_SUCCESS;
        p_cell_generic_resp->fail_cause = RRM_NO_ERROR;
        ptr = (void *)p_cell_generic_resp;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.deregister_resp_S);
#endif        
        /* sending failure response to MIF
         */
        if (RRM_FAILURE == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_DEREGISTER_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    ptr))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_DEREGISTER_RESP,
                    p_cell_ctx->cell_index);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_DEREGISTER_RESP,
                    p_cell_ctx->cell_index);
        }
        RRM_MEM_FREE(p_cell_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_generic_resp failed");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/*******************************************************************
 * Function Name  :  rrm_eutran_list_dequeue
 * Inputs             :  meas_eutran_context_list_t *p_meas_eutran_list
 * Outputs           :  None
 * Returns            :  EUtran node
 * Description       :  Deque the EUtran node from the link list
 ********************************************************************/
meas_eutran_node_t *
rrm_eutran_list_dequeue
( 
 meas_eutran_context_list_t    *p_meas_eutran_list
)
{
    YLNODE *snode = ylPopHead(p_meas_eutran_list);
    if(snode != RRM_PNULL)
    {
        return (meas_eutran_node_t *)YMEMBEROF
            (meas_eutran_node_t, sNode, snode);
    }
    return RRM_PNULL;
}

/*******************************************************************
 * Function Name  :  rrm_utran_list_dequeue
 * Inputs             :  meas_utran_context_list_t *p_meas_utran_list
 * Outputs           :  None
 * Returns            :  Utran node
 * Description       :  Deque the Utran node from the link list
 ********************************************************************/
meas_utran_node_t *
rrm_utran_list_dequeue
( 
 meas_utran_context_list_t    *p_meas_utran_list
)
{
    YLNODE *snode = ylPopHead(p_meas_utran_list);
    if(snode != RRM_PNULL)
    {
        return (meas_utran_node_t *)YMEMBEROF
            (meas_utran_node_t, sNode, snode);
    }

    return RRM_PNULL;
}
/* SPR 20265 Fix Start */
/*******************************************************************
 * Function Name  :  rrm_utran_tdd_list_dequeue
 * Inputs             :  meas_utran_tdd_context_list_t *p_meas_utran_tdd_list
 * Outputs           :  None
 * Returns            :  Utran tdd node
 * Description       :  Deque the Utran tdd node from the link list
 ********************************************************************/
meas_utran_tdd_node_t *
rrm_utran_tdd_list_dequeue
( 
 meas_utran_tdd_context_list_t    *p_meas_utran_tdd_list
)
{
    YLNODE *snode = ylPopHead(p_meas_utran_tdd_list);
    if(snode != RRM_PNULL)
    {
        return (meas_utran_tdd_node_t *)YMEMBEROF
            (meas_utran_tdd_node_t, sNode, snode);
    }

    return RRM_PNULL;
}
/* SPR 20265 Fix End */
/*******************************************************************
 * Function Name  :  rrm_geran_list_dequeue
 * Inputs             :  meas_geran_context_list_t *p_meas_geran_list
 * Outputs           :  None
 * Returns            :  Geran node
 * Description       :  Deque the Geran node from the link list
 ********************************************************************/
meas_geran_node_t *
rrm_geran_list_dequeue
( 
 meas_geran_context_list_t    *p_meas_geran_list
)
{
    YLNODE *snode = ylPopHead(p_meas_geran_list);
    if(snode != RRM_PNULL)
    {
        return (meas_geran_node_t *)YMEMBEROF
            (meas_geran_node_t, sNode, snode);
    }

    return RRM_PNULL;
}

/*******************************************************************
 * Function Name  :  rrmcm_free_meas_config_lists
 * Inputs             :  rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs           :  None
 * Returns            :  RRM_SUCCESS/RRM_FAILURE
 * Description       :  Free the linklist of EUTRA and UTRA stored in cell context
 ********************************************************************/
rrm_return_et
rrmcm_free_meas_config_lists
(
 rrm_cell_context_t    *p_cell_ctx
 )
{
    rrm_return_et                  ret_val              = RRM_SUCCESS;
    meas_eutran_node_t            *p_meas_eutran_node   = RRM_ZERO;
    meas_utran_node_t             *p_meas_utran_node    = RRM_ZERO;
    meas_geran_node_t             *p_meas_geran_node    = RRM_ZERO;
    /* SPR 20265 Fix Start */
    meas_utran_tdd_node_t         *p_meas_utran_tdd_node = RRM_ZERO;
    /* SPR 20265 Fix End */
    p_meas_eutran_node = rrm_eutran_list_dequeue(&p_cell_ctx->meas_eutran_list);

    while(RRM_PNULL != p_meas_eutran_node)
    {
        RRM_MEM_FREE(p_meas_eutran_node);

        p_meas_eutran_node = rrm_eutran_list_dequeue(&p_cell_ctx->meas_eutran_list);
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "EUTRAN LIST DELETED for cell index:%d", p_cell_ctx->cell_index);

    p_meas_utran_node = rrm_utran_list_dequeue(&p_cell_ctx->meas_utran_list);

    while(RRM_PNULL != p_meas_utran_node)
    {
        RRM_MEM_FREE(p_meas_utran_node);

        p_meas_utran_node = rrm_utran_list_dequeue(&p_cell_ctx->meas_utran_list);
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "UTRAN LIST DELETED for cell index:%d", p_cell_ctx->cell_index);

    p_meas_geran_node = rrm_geran_list_dequeue(&p_cell_ctx->meas_geran_list);

    while(RRM_PNULL != p_meas_geran_node)
    {
        RRM_MEM_FREE(p_meas_geran_node);

        p_meas_geran_node = rrm_geran_list_dequeue(&p_cell_ctx->meas_geran_list);
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "GERAN LIST DELETED for cell index:%d", p_cell_ctx->cell_index);

    /* SPR 20265 Fix Start */
    p_meas_utran_tdd_node = rrm_utran_tdd_list_dequeue(&p_cell_ctx->meas_utran_tdd_list);

    while(RRM_PNULL != p_meas_utran_tdd_node)
    {
        RRM_MEM_FREE(p_meas_utran_tdd_node);

        p_meas_utran_tdd_node = rrm_utran_tdd_list_dequeue(&p_cell_ctx->meas_utran_tdd_list);
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "UTRAN TDD LIST DELETED for cell index:%d", p_cell_ctx->cell_index);
    /* SPR 20265 Fix Start */

    return ret_val;
}
/*Klockwork_fix_2431_start*/
/*******************************************************************
 * Function Name  :  rmcm_mif_deregister_req_from_anr
 * Inputs            :  rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs           :  None
 * Returns           :  RRM_SUCCESS/RRM_FAILURE
 * Description       : deregister_req_from_anr 
 ********************************************************************/
rrm_return_et
rmcm_mif_deregister_req_from_anr(rrm_cell_context_t *p_cell_ctx,
                                cell_son_attr_info_list_t  **p_cell_attribute_info)
{
   
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    if (!p_cell_ctx->cell_already_register_anr)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "Cell Already DERegisterd for ANR");

        p_generic_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_resp_t));
        /*  , coverity  id :16266 , added NULL check for rrm_mem_get */
        if(p_generic_resp != RRM_PNULL)
        {
            p_generic_resp->cellindex = p_cell_ctx->cell_index;
            p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
            p_generic_resp->response = RRM_FAILURE;
            p_generic_resp->fail_cause= RRM_ERR_CELL_ALREADY_DEREGISTER_FAILURE;

            ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_DEREGISTER_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_generic_resp);
            RRM_MEM_FREE(p_generic_resp);
        }
        else
        {
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                    "Memory allocation to p_generic_resp failed");
            ret_val = RRM_FAILURE;
        }

        return ret_val;
    }
    else
    {
      /*Unset the bit*/
      p_cell_ctx->cell_already_register_anr = RRM_ZERO; 
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
	  RRM_DETAILED,"Cell deregistered bit is unset:%d",
	  p_cell_ctx->cell_already_register_anr);
    }

    if (p_cell_ctx->p_son_info != RRM_PNULL)
    {
        if ((p_cell_ctx->p_son_info->p_anr_info != RRM_PNULL) &&
                (p_cell_ctx->p_son_info->p_anr_info->is_active == RRM_TRUE))
        {
            *p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_DETAILED, "ANR info pointer is already freed");
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	  "SON info pointer is alredy freed");
      ret_val = RRM_FAILURE;
    }
   RRM_UT_TRACE_EXIT();
   return ret_val;
     
}
/*******************************************************************
 * Function Name  :  rmcm_mif_deregister_req_from_es
 * Inputs            :  rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs           :  None
 * Returns           :  RRM_SUCCESS/RRM_FAILURE
 * Description       : deregister_req_from_anr
 ********************************************************************/
rrm_return_et rmcm_mif_deregister_req_from_es(rrm_cell_context_t *p_cell_ctx,
                                             cell_son_attr_info_list_t  **p_cell_attribute_info)
{

     rrm_return_et ret_val = RRM_SUCCESS;
     rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
     RRM_UT_TRACE_ENTER();
      if(!p_cell_ctx->cell_already_register_es)
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                  "Cell Already DERegisterd");
          p_generic_resp = rrm_mem_get(sizeof
                  (rrmcm_rmif_generic_resp_t));

          if(RRM_PNULL == p_generic_resp) /* Coverity: CID 16266 */
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                      "memory allocation to p_generic_resp failed");
              return RRM_FAILURE;
          }

          p_generic_resp->cellindex = p_cell_ctx->cell_index;
          p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
          p_generic_resp->response = RRM_FAILURE;
          p_generic_resp->fail_cause= RRM_ERR_CELL_ALREADY_DEREGISTER_FAILURE;

          ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                  RRMCM_RMIF_CELL_DEREGISTER_RESP,
                  sizeof(rrmcm_rmif_generic_resp_t),
                  (void *)p_generic_resp);
          RRM_MEM_FREE(p_generic_resp);
          if(ret_val == RRM_FAILURE)

          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                      RRM_ERROR,"failure in sending :%d for cell index:%d",
                      p_cell_ctx->api_id,
                      p_cell_ctx->cell_index);
          }
          return ret_val;
      }
      else
      {
          p_cell_ctx->cell_already_register_es = RRM_ZERO;
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED,"Cell Deregister for ES bit is unset:%d",
                  p_cell_ctx->cell_already_register_es);
      }
      if (p_cell_ctx->p_son_info != RRM_PNULL)
      {
          if ((p_cell_ctx->p_son_info->p_es_info != RRM_PNULL) &&
                  (p_cell_ctx->p_son_info->p_es_info->is_active == RRM_TRUE))
          {
              *p_cell_attribute_info = p_cell_ctx->p_son_info->p_es_info;
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                      RRM_DETAILED, "ES info pointer is already freed");
              ret_val = RRM_FAILURE;
          }
      }
      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED, "SON info pointer is already freed");
          ret_val = RRM_FAILURE;
      }
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/*******************************************************************
 * Function Name  : rmcm_mif_deregister_req_from_mlb 
 * Inputs            :  rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs           :  None
 * Returns           :  RRM_SUCCESS/RRM_FAILURE
 * Description       : deregister_req_from_anr
 ********************************************************************/
rrm_return_et rmcm_mif_deregister_req_from_mlb(rrm_cell_context_t *p_cell_ctx,
                                               cell_son_attr_info_list_t  **p_cell_attribute_info)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();    
      if (!(p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB))
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "Cell Already DERegisterd");
          p_generic_resp = rrm_mem_get(sizeof
                  (rrmcm_rmif_generic_resp_t));

        if(RRM_PNULL == p_generic_resp) /* Coverity: CID 16266 */
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
 	            "memory allocation to p_generic_resp failed");
            return RRM_FAILURE;
        }

          p_generic_resp->cellindex = p_cell_ctx->cell_index;
          p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
          p_generic_resp->response = RRM_FAILURE;
          p_generic_resp->fail_cause= RRM_ERR_CELL_ALREADY_DEREGISTER_FAILURE;

          ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                  RRMCM_RMIF_CELL_DEREGISTER_RESP,
                  sizeof(rrmcm_rmif_generic_resp_t),
                  (void *)p_generic_resp);
          RRM_MEM_FREE(p_generic_resp);
          if(ret_val == RRM_FAILURE)

          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                      RRM_ERROR,"failure in sending :%d for cell index:%d",
                      p_cell_ctx->api_id,
                      p_cell_ctx->cell_index);
          }
          return ret_val;
      }
      else
      {
          p_cell_ctx->registered_mod_by_son ^= CELL_ALREADY_REGISTERD_FOR_MLB;
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_DETAILED,"Cell Deregister for MLB bit is unset:%d",
                  p_cell_ctx->registered_mod_by_son);
      }
      if (p_cell_ctx->p_son_info != RRM_PNULL)
      {
          if (p_cell_ctx->p_son_info->p_mlb_info != RRM_PNULL)
          {
              *p_cell_attribute_info = p_cell_ctx->p_son_info->p_mlb_info;
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                      RRM_DETAILED, "MLB info pointer is already freed");
              ret_val = RRM_FAILURE;
          }
      }
      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_DETAILED, "SON info pointer is already freed");
          ret_val = RRM_FAILURE;
      }
      RRM_UT_TRACE_EXIT();
      return ret_val;
}
/*******************************************************************
 * Function Name  :  rmcm_mif_deregister_req_from_mro
 * Inputs            :  rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs           :  None
 * Returns           :  RRM_SUCCESS/RRM_FAILURE
 * Description       : deregister_req_from_anr
 ********************************************************************/
rrm_return_et
rmcm_mif_deregister_req_from_mro(rrm_cell_context_t *p_cell_ctx,
                                cell_son_attr_info_list_t  **p_cell_attribute_info )
                              
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

      if (!(p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MRO))
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "Cell Already DERegisterd");
          p_generic_resp = rrm_mem_get(sizeof
                  (rrmcm_rmif_generic_resp_t));

        if(RRM_PNULL == p_generic_resp) /* Coverity: CID 16266 */
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
 	            "memory allocation to p_generic_resp failed");
            return RRM_FAILURE;
        }

          p_generic_resp->cellindex = p_cell_ctx->cell_index;
          p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
          p_generic_resp->response = RRM_FAILURE;
          p_generic_resp->fail_cause= RRM_ERR_CELL_ALREADY_DEREGISTER_FAILURE;

          ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                  RRMCM_RMIF_CELL_DEREGISTER_RESP,
                  sizeof(rrmcm_rmif_generic_resp_t),
                  (void *)p_generic_resp);
          if(ret_val == RRM_FAILURE)

          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                      RRM_ERROR,"failure in sending :%d for cell index:%d",
                      p_cell_ctx->api_id,
                      p_cell_ctx->cell_index);
          }
          RRM_MEM_FREE(p_generic_resp);
          return ret_val;
      }
      else
      {
          p_cell_ctx->registered_mod_by_son ^= CELL_ALREADY_REGISTERD_FOR_MRO;
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_DETAILED,"Cell Deregister for MRO bit is unset:%d",
                  p_cell_ctx->registered_mod_by_son);
      }
	  if (p_cell_ctx->p_son_info != RRM_PNULL)
      {
          	if (p_cell_ctx->p_son_info->p_mro_info != RRM_PNULL)
        	{
            	*p_cell_attribute_info = p_cell_ctx->p_son_info->p_mro_info;
        	}
        	else
        	{
            	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    		RRM_DETAILED, "MRO info pointer is already freed");
	            ret_val = RRM_FAILURE;
    	    }
      }
      else
      {
      	  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	  	            "SON info pointer is alredy freed");
      	  ret_val = RRM_FAILURE;
      }
      RRM_UT_TRACE_EXIT();
      return ret_val;
}
/*******************************************************************
 * Function Name  :rrmcm_rmif_cell_reg_dereg_fill_attr_list 
 * Inputs         :  rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        :  None
 * Returns        :  None
 * Description    : rmcm_rmif_cell_reg_dereg_fill_attr_list
 ********************************************************************/
rrm_void_t
rrmcm_rmif_cell_reg_dereg_fill_attr_list(rrm_cell_context_t *p_cell_ctx,
                                         rrmcm_rmif_cell_son_register_deregister_req_t *rrmcm_rmif_cell_reg_dereg_req,
                                         cell_son_attr_info_list_t  *p_cell_attribute_info,
                                         U8                                             att_list)
{
    U8 att_list_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();    
        for (att_list_index = RRM_ZERO; (att_list_index < att_list) 
            /* Coverity 21oct Start : 55003 */
            && (att_list_index < (RRM_ATTR_LIST_SIZE));att_list_index++)
            /* Coverity 21oct End : 55003 */
        {
            switch(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                case RRM_MIF_CELLM_ATTR_CELL_STATE:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_DETAILED,"Deregister:RRM_MIF_CELLM_ATTR_CELL_STATE");     
                        RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                    }    
                    break;

                case RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Deregister:RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT");     
                        /* SPR-17852 START */
                        if(p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]) 
                        {
                          cell_stop_timer(p_cell_attribute_info->
                              cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

                          p_cell_attribute_info->
                            cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;

                          p_cell_attribute_info->timer_status
                            [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                        }
                        /* SPR-17852 END */
                        RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                    }    
                    break;

                case RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Deregister:RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD");     
                        RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                    } 
                    break;

                case RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Deregister:RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION");     
                        RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
                    }
                    break;
                    /* UE MEAS CHANGES : STARTS */
                case RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Deregister: "
                                "RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL");
                        /* SPR-17852 START */
                        if(p_cell_attribute_info->cell_timer_id[SON_UE_MEAS_CONFIG_TIMER])
                        {
                          cell_stop_timer(p_cell_attribute_info->
                              cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]);

                          p_cell_attribute_info->
                              cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] = RRM_PNULL;

                          p_cell_attribute_info->timer_status
                            [SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                        } 
                        /* SPR-17852 END */


                        RRM_MEM_FREE(p_cell_attribute_info->
                                p_ue_meas_result_notification);

                        /* Bug 948 Fix Start */
	                    /* Free the UE MEAS linklist */
	                    rrmcm_free_meas_config_lists(p_cell_ctx);
                        /* Bug 948 Fix End */
                    }
                    break;
                case RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Deregister: "
                                "RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT");

                        p_cell_ctx->ue_meas_cnt = RRM_ZERO;
                    }
                    break;
                    /* UE MEAS CHANGES : ENDS */
                    /* BLR Team HO status report to SON Changes Start */
                case RRM_MIF_CELLM_ATTR_HO_REPORT:
                    {

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                                " RRM_MIF_CELLM_ATTR_HO_REPORT disabled HO report to SON");

                        p_cell_attribute_info->is_ho_report_active = RRM_FALSE;
                    }
                    break;
                    /* BLR Team HO status report to SON Changes End */
                case RRM_MIF_CELLM_ATTR_MLB_SELF:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Attribute RRM_MIF_CELLM_ATTR_MLB_SELF");
                        /* SPR-17852 START */
                        if (RRM_ZERO != p_cell_ctx->self_load_rpt_tmr)
                        {
                            /* SPR-17852 END */

                            cell_stop_timer (p_cell_ctx->self_load_rpt_tmr);
                            p_cell_ctx->self_load_rpt_tmr = RRM_ZERO;
                            /* eICIC_PHASE_1_2_CHANGES_START */
                            rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
                            /* eICIC_PHASE_1_2_CHANGES_END */
                        }
                        else
                        {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "MLB Timer is not Running");
                        }
                    }
                    break;
                case RRM_MIF_CELLM_ATTR_MLB_NBR:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Attribute RRM_MIF_CELLM_ATTR_MLB_NBR");
                        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO] = RRM_ZERO;
                        /* eICIC_PHASE_1_2_CHANGES_START */
                        rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
                        /* eICIC_PHASE_1_2_CHANGES_END */

                    }
                    break;

                /* MRO start */
				case RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND:
					{
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                       			  "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                       			  "RRM_MIF_CELLM_ATTR_ATTEMPT_IND disabled HO attempt indication report to SON");
                       p_cell_attribute_info->is_ho_attempt_ind_active = RRM_FALSE;
					}
					break;

				case RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT:
					{
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                       			  "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                       			  "RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT disabled HO failure report to SON");
                       p_cell_attribute_info->is_ho_failure_report_active = RRM_FALSE;
					}
					break;	
                /* MRO end */
                /* SON ES MLB Started */
                case RRM_MIF_CELLM_ATTR_ES_LD_SELF:
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Attribute RRM_MIF_CELLM_ATTR_ES_LD_SELF");
                        /* SPR-17852 START */
                        if (RRM_ZERO != p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER])
                        {
                            /* SPR-17852 END */

                            cell_stop_timer (p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER]);
                            p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER] = RRM_ZERO;
                        }
                        else
                        {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "ES Self Load Timer is not Running");
                        }
                    }
                    break;
                /* SON ES MLB end */

                default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Invalid attribute [%u]",
                            rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id);
                    break;

            }

        }  
 RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_2431_end*/
/*******************************************************************
 * Function Name  : RrmMifCellDereqisterReq
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles cell deregister request from MIF in FSM
 ********************************************************************/
rrm_return_et
rmcm_mif_deregister_req(rrm_cell_context_t *p_cell_ctx)
{
    U8 att_list = RRM_ZERO;
  rrm_return_et ret_val = RRM_SUCCESS;
  rrmcm_rmif_cell_son_register_deregister_req_t *rrmcm_rmif_cell_reg_dereg_req = RRM_PNULL;
  cell_son_attr_info_list_t  *p_cell_attribute_info = RRM_PNULL;

  RRM_UT_TRACE_ENTER();

  rrmcm_rmif_cell_reg_dereg_req = (rrmcm_rmif_cell_son_register_deregister_req_t *)
                                        p_cell_ctx->p_incoming_api_info; 
  p_cell_ctx->ongoing_trans_id = rrmcm_rmif_cell_reg_dereg_req->transaction_id;

  /* Based on received API(ANR/ES) store store the mem pointer */
  if (RRMCM_RMIF_CELL_DEREGISTER_FROM_ANR_REQ == p_cell_ctx->api_id)
  {
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	      "Cell De-Registeration Request received for ANR");

    /*Klockwork_fix_2431_start*/
    ret_val = rmcm_mif_deregister_req_from_anr(p_cell_ctx ,&p_cell_attribute_info);
    /*Klockwork_fix_2431_end*/ 
  }
  else if(RRMCM_RMIF_CELL_DEREGISTER_FROM_ES_REQ == p_cell_ctx->api_id)
  {
     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
              "Cell De-Registeration Request received for ES");
     
     /*Klockwork_fix_2431_start*/
     ret_val = rmcm_mif_deregister_req_from_es(p_cell_ctx ,&p_cell_attribute_info);
     /*Klockwork_fix_2431_end*/
  }
  else if (RRMCM_RMIF_CELL_DEREGISTER_FROM_MLB_REQ == p_cell_ctx->api_id)
  {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
              "Cell De-Registeration Request received for MLB");

     /*Klockwork_fix_2431_start*/
     ret_val = rmcm_mif_deregister_req_from_mlb(p_cell_ctx ,&p_cell_attribute_info);
     /*Klockwork_fix_2431_end*/
  }
    /* MRO starts */
  else if (RRMCM_RMIF_CELL_DEREGISTER_FROM_MRO_REQ == p_cell_ctx->api_id)
  {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
              "Cell De-Registeration Request received for MRO");

      /*Klockwork_fix_2431_start*/
      ret_val = rmcm_mif_deregister_req_from_mro(p_cell_ctx ,&p_cell_attribute_info);
      /*spr_fix_start_12668*/
      if(RRM_FAILURE == ret_val)
      {
          RRM_UT_TRACE_EXIT();
          return ret_val;
      }
      /*spr_fix_end_12668*/
      /*Klockwork_fix_2431_end*/

  }
    /* MRO ends */
  else
  {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
              "Invalid API(%d) received from SON", p_cell_ctx->api_id);
      ret_val = RRM_FAILURE;
  }
/*COV_FIX_START_21927*/
  if ((RRM_SUCCESS == ret_val) && (p_cell_attribute_info != RRM_PNULL))
/*COV_FIX_END_21927*/
  {
    att_list =  rrmcm_rmif_cell_reg_dereg_req->attr_list_size;

    if (att_list != RRM_ZERO)
    {
        /*Klockwork_fix_2431_start*/
        rrmcm_rmif_cell_reg_dereg_fill_attr_list(p_cell_ctx ,rrmcm_rmif_cell_reg_dereg_req ,
                                                   p_cell_attribute_info, att_list);
        /*Klockwork_fix_2431_end*/
    }
    else
    {
        if (p_cell_attribute_info->p_cell_state != RRM_PNULL)
        {
            RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
        }
        /* SPR-17852 START */
        if ((p_cell_attribute_info->p_active_ue != RRM_PNULL) &&
            (p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]))
        {
            cell_stop_timer(p_cell_attribute_info->
                    cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);

            p_cell_attribute_info->
                    cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;

          /* SPR-17852 END */

            p_cell_attribute_info->timer_status
                [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
            RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
        }
        if (p_cell_attribute_info->p_ue_threshold != RRM_PNULL)
        {
            RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
        }
        if (p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
        {
            RRM_MEM_FREE(p_cell_attribute_info->p_s1_msg_notification);
        }
        /* UE MEAS CHANGES : STARTS */
        /* SPR-17852 START */
        if ((p_cell_attribute_info->p_ue_meas_result_notification != RRM_PNULL) && 
            (p_cell_attribute_info->cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]))
        {
          /* SPR-17852 END */
            cell_stop_timer(p_cell_attribute_info->
                    cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]);
            p_cell_attribute_info->cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] = 
                RRM_PNULL;

            p_cell_attribute_info->timer_status
                [SON_UE_MEAS_CONFIG_TIMER] = STOPPED;

            RRM_MEM_FREE(p_cell_attribute_info->
                    p_ue_meas_result_notification);

        }
    }

    if(RRM_PNULL != p_cell_attribute_info)
    {
	if ((p_cell_attribute_info->p_cell_state == RRM_PNULL) ||
	    (p_cell_attribute_info->p_active_ue == RRM_PNULL)||
	    (p_cell_attribute_info->p_ue_threshold == RRM_PNULL)||
	    (p_cell_attribute_info->p_s1_msg_notification == RRM_PNULL) ||
	    (p_cell_attribute_info->p_ue_meas_result_notification == RRM_PNULL)
	   )
	{
	    switch (p_cell_ctx->api_id)
	    {
		case RRMCM_RMIF_CELL_DEREGISTER_FROM_ANR_REQ:
		    RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            /* Bug 948 Fix Start */
	        /* Free the UE MEAS linklist */
	        rrmcm_free_meas_config_lists(p_cell_ctx);
            /* Bug 948 Fix End */
		    break;

		case RRMCM_RMIF_CELL_DEREGISTER_FROM_ES_REQ:
		    RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
		    break;

		case RRMCM_RMIF_CELL_DEREGISTER_FROM_MLB_REQ:
		    RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mlb_info);
		    break;
            case RRMCM_RMIF_CELL_DEREGISTER_FROM_MRO_REQ:
                RRM_MEM_FREE(p_cell_ctx->p_son_info->p_mro_info);
                break;
	    }
	
	}
    rmcm_mif_deregister_resp(p_cell_ctx);
    /* UE MEAS CHANGES : ENDS */
  }
}
  RRM_UT_TRACE_EXIT();
  return ret_val;
}

/*******************************************************************
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles cell register response for MIF in FSM
********************************************************************/
rrm_return_et
rmcm_mif_register_resp
(
   rrm_cell_context_t *p_cell_ctx
)
{
     rrmcm_rmif_generic_resp_t *p_cell_generic_resp = RRM_PNULL;
     void *ptr = RRM_PNULL;

     RRM_UT_TRACE_ENTER();

     p_cell_generic_resp = rrm_mem_get(sizeof
                                      (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16271 , added NULL check for rrm_mem_get */
    if(p_cell_generic_resp != RRM_PNULL)
   {
     p_cell_generic_resp->cellindex = p_cell_ctx->cell_index;
     p_cell_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
     p_cell_generic_resp->response = RRM_SUCCESS;
     p_cell_generic_resp->fail_cause = RRM_NO_ERROR;
     ptr = (void *)p_cell_generic_resp;
#ifdef RRM_UT_FLAG        
     RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.register_resp_S);
#endif        
     
     /*
      * sending failure response to MIF
      */
     if (RRM_FAILURE == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                             RRMCM_RMIF_CELL_REGISTER_RESP,
                             sizeof(rrmcm_rmif_generic_resp_t),
                             ptr))
   
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "failure in sending :%d for cell index:%d",
                                RRMCM_RMIF_CELL_REGISTER_RESP,
                               p_cell_ctx->cell_index);
    }
    else
    {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED
                  ,"success in sending :%d for cell index:%d",
                              RRMCM_RMIF_CELL_REGISTER_RESP,
                              p_cell_ctx->cell_index);
    }
    RRM_MEM_FREE(p_cell_generic_resp);
   }
   else
   {
         RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
	                       "Memory allocation to p_cell_generic_resp failed");
         RRM_UT_TRACE_EXIT();
         return RRM_FAILURE;
   }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*******************************************************************
* Function Name  : rmcm_mif_set_register_resp 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles cell register request from MIF in FSM
********************************************************************/
rrm_return_et
rmcm_mif_set_register_resp
(
 rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_generic_resp_t *p_cell_generic_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_generic_resp = rrm_mem_get(sizeof
            (rrmcm_rmif_generic_resp_t));
    /*  , coverity  id :16276 , added NULL check for rrm_mem_get */
    if(p_cell_generic_resp != RRM_PNULL)
    {
        p_cell_generic_resp->cellindex = p_cell_ctx->cell_index;
        p_cell_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
        p_cell_generic_resp->response = RRM_SUCCESS;
        p_cell_generic_resp->fail_cause = RRM_NO_ERROR;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.set_attribute_resp_S);
#endif        
        /*
         * sending failure response to MIF
         */
        if (RRM_FAILURE == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_SET_ATTRIBUTE_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)p_cell_generic_resp))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_REGISTER_RESP,
                    p_cell_ctx->cell_index);
            ret_val=RRM_FAILURE;

        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "success in sending :%d for cell index:%d",
                    RRMCM_RMIF_CELL_REGISTER_RESP,
                    p_cell_ctx->cell_index);
            ret_val=RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_cell_generic_resp);
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_generic_resp failed");
        ret_val = RRM_FAILURE;
    }
    /*Coverity_fix_start_54961*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*Coverity_fix_end_54961*/
}

/*******************************************************************
* Function Name  : rmcm_mif_set_attribute_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles cell register request from MIF in FSM
********************************************************************/
rrm_return_et
rmcm_mif_set_attribute_req(rrm_cell_context_t *p_cell_ctx)
{
  /* coverity : CID 16341*/
    /* SPR 20653 Fix Start */
    U8 att_list_index = RRM_ZERO;
    U8 att_list = RRM_ZERO;
    /* SPR 20653 Fix End */
  cell_timer_buf_t    o_cell_timer_buf; 
  rrmcm_rmif_cell_set_attr_req *rrmcm_rmif_cell_set_attr = RRM_PNULL;
  rrm_return_et ret_val = RRM_SUCCESS;
  U8 trgr_list = RRM_ZERO;
  cell_son_attr_info_list_t  *p_cell_attribute_info = RRM_PNULL;
  cell_timer_et  timer_type = CELL_MAX_TIMER_TYPE; 

  RRM_UT_TRACE_ENTER();

  /* coverity : CID 16341*/
  RRM_MEMSET(&o_cell_timer_buf , RRM_ZERO , sizeof(cell_timer_buf_t));
  rrmcm_rmif_cell_set_attr = ( rrmcm_rmif_cell_set_attr_req *)
    p_cell_ctx->p_incoming_api_info;  

  p_cell_ctx->ongoing_trans_id = rrmcm_rmif_cell_set_attr->transaction_id;
  /* Based on received API(ANR/ES) store store the mem pointer */
  if (RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ANR_REQ == p_cell_ctx->api_id)
  {
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	"Cell Set Attribute Request received for ANR");
    if (p_cell_ctx->p_son_info != RRM_PNULL)
    {
      if ((p_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)&&
	  (p_cell_ctx->p_son_info->p_anr_info->is_active == RRM_TRUE))
      {
	p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
	timer_type = CELL_PERIODIC_TIMER_FOR_ANR;
      }
      else
      {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
	    RRM_DETAILED, "ANR info pointer is already freed");
	ret_val = RRM_FAILURE;
      }
    }
    else
    {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
	  RRM_DETAILED, "SON info pointer is alredy freed");
      ret_val = RRM_FAILURE;
    }
  }
  else if (RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ES_REQ == p_cell_ctx->api_id)
  {
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	"Cell Set Attribute Request received for ES");
    if (p_cell_ctx->p_son_info != RRM_PNULL)
    {
      if ((p_cell_ctx->p_son_info->p_es_info != RRM_PNULL) &&
	  (p_cell_ctx->p_son_info->p_es_info->is_active == RRM_TRUE))
      {
	p_cell_attribute_info = p_cell_ctx->p_son_info->p_es_info;
	timer_type = CELL_PERIODIC_TIMER_FOR_ES;
      }
      else
      {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
	    RRM_DETAILED, "ES info pointer is already freed");
	ret_val = RRM_FAILURE;
      }
    }
    else
    {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
	  RRM_DETAILED, "SON info pointer is already freed");
      ret_val = RRM_FAILURE;
    }
  }
  /* MRO changes started */
  else if (RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_MRO_REQ  == p_cell_ctx->api_id )
  {
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	"Cell Set Attribute Request received for MRO ");
    if (p_cell_ctx->p_son_info != RRM_PNULL)
    {
      if (p_cell_ctx->p_son_info->p_mro_info != RRM_PNULL)
      {
	p_cell_attribute_info = p_cell_ctx->p_son_info->p_mro_info;
      }
      else
      {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
	    RRM_DETAILED, "MRO info pointer is already freed");
	ret_val = RRM_FAILURE;
      }
    }
    else
    {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
	  RRM_DETAILED, "SON info pointer is already freed");
      ret_val = RRM_FAILURE;
    }
  }
  /* MRO changes end */
  else if (RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_MLB_REQ  == p_cell_ctx->api_id )
  {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
              "Cell Set Attribute Request received for MLB");
      if (p_cell_ctx->p_son_info != RRM_PNULL)
      {
          if ((p_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)&&
                  (RRM_PNULL != p_cell_ctx->p_son_info->p_mlb_info))
          {
              p_cell_attribute_info = p_cell_ctx->p_son_info->p_anr_info;
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                      RRM_DETAILED, "MLB info pointer is already freed");
              ret_val = RRM_FAILURE;
          }
      }
      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED, "SON info pointer is already freed");
          ret_val = RRM_FAILURE;
      }
  }
  else
  {
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
	RRM_BRIEF, "Invalid API(%d) received from SON", p_cell_ctx->api_id);
    ret_val = RRM_FAILURE;
  }

  if (ret_val == RRM_SUCCESS)
  {
        /* SPR 20653 Fix Start */
        att_list = rrmcm_rmif_cell_set_attr->attr_list_size;
        for (att_list_index = RRM_ZERO;((att_list_index < att_list) &&
                    (att_list_index < RRM_ATTR_LIST_SIZE));
                att_list_index++)    
        {
      if ( RRM_MIF_CELLM_ATTR_CELL_STATE == rrmcm_rmif_cell_set_attr->
                    attribute[att_list_index].id )
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_CELL_STATE");
                if (rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          {
              if( RRM_NULL != p_cell_attribute_info)
              {
                  if (p_cell_attribute_info->p_cell_state == RRM_PNULL)
                  {
                      p_cell_attribute_info->p_cell_state = 
                          rrm_mem_get(sizeof(cell_state_t));
                  }
                  if(RRM_PNULL == p_cell_attribute_info->p_cell_state) /* Coverity: CID 16275 */
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "Failed to allocate memory to p_cell_attribute_info->p_cell_state");
                      return RRM_FAILURE;
                  }
                  /* CID 112951 Start */
                  if (p_cell_attribute_info->p_active_ue == RRM_PNULL)
                  {
                      p_cell_attribute_info->p_active_ue = 
                          rrm_mem_get(sizeof(cell_active_ue_t));
                  }
                  if(RRM_PNULL == p_cell_attribute_info->p_active_ue) /* Coverity: CID 16275 */
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "Failed to allocate memory to p_cell_attribute_info->p_active_ue");
                      RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                      return RRM_FAILURE;
                  }
                  /* CID 112951 End */
                        for(trgr_list = RRM_ZERO;trgr_list < rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
                  {
                            switch(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id)
                      {
                          case RRM_MIF_CELLM_TRGR_PERIODIC:
                              /* Coverity_ID : 30705 */
                              if (timer_type < CELL_MAX_TIMER_TYPE)
                              {
                                  RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"Trigger RRM_MIF_CELLM_TRGR_THRESHOLD");
                                  /* BUG_178:Start Stop the timer if running and start new timer*/
                                  /* SPR-17852 START */
                                  if(p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER])
                                  {
                                  cell_stop_timer(p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);
                                    p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RRM_PNULL;
                                    p_cell_attribute_info->timer_status[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                                  }
                                  /* SPR-17852 END */
                                  RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"Old running timer Stopped");
                                  /*BUG178:end*/
                                  p_cell_attribute_info->p_active_ue->flag_periodic_active_ue= RRM_TRUE; 
                                  o_cell_timer_buf.timer_type = timer_type;
                                  o_cell_timer_buf.cell_index= p_cell_ctx->cell_index;
                                  RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                                          RRM_DETAILED,"Old Timer duration = %d New Timer Duration:%d",
                                          p_cell_ctx->timer_val[timer_type],
                                                rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic);
                                  p_cell_ctx->timer_val[timer_type] = 
                                            rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic;
                                  RRM_ASSERT ( timer_type <= CELL_MAX_TIMER_TYPE);
                                  p_cell_attribute_info->
                                      cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = 
                                      cell_start_timer( timer_type,
                                              (void *)&o_cell_timer_buf,
                                              sizeof(cell_timer_buf_t),
                                              p_cell_ctx);

                                  p_cell_attribute_info->timer_status
                                      [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RUNNING;
                              }
                              else
                              {
                                  RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, \
                                          "Invalid Timer Type [%d]",timer_type);
                                  ret_val = RRM_FAILURE;
                              }
                              break;
                          case RRM_MIF_CELLM_TRGR_THRESHOLD:
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                      RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
                              p_cell_attribute_info->p_cell_state->flag_threshold_cell_state= RRM_TRUE;
                              break;
                          case RRM_MIF_CELLM_TRGR_EVENT:
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                      RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
                              p_cell_attribute_info->p_cell_state->flag_trgr_cell_state=  RRM_TRUE;
                              break;
                          case RRM_MIF_CELLM_TRGR_UNDEF:
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                      RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
                              break;
                      }
                  }
              }
              else
              {
                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                          RRM_BRIEF,"p_cell_attribute_info is NULL");
                  ret_val = RRM_FAILURE;
              }
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                      RRM_BRIEF,"Attribute for cell State is false");
          }

      }    
      if ( RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT==
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id ) 
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT");
                if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          {
              if( RRM_PNULL != p_cell_attribute_info )
              {
                  if (p_cell_attribute_info->p_active_ue == RRM_PNULL)
                  {
                      p_cell_attribute_info->p_active_ue = 
                          rrm_mem_get(sizeof(cell_active_ue_t));
                  }
                  if(RRM_PNULL == p_cell_attribute_info->p_active_ue) /* Coverity: CID 16275 */
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "Failed to allocate memory to p_cell_attribute_info->p_active_ue");
                      RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                      return RRM_FAILURE;
                  }
                        for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
                  {
                            switch(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id)
                      {
                          case RRM_MIF_CELLM_TRGR_PERIODIC:
                              /* Coverity_ID : 30705 */
                              if (timer_type < CELL_MAX_TIMER_TYPE)
                              {
                                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Trigger RRM_MIF_CELLM_TRGR_THRESHOLD");
                                  /* BUG_178:Start Stop the timer if running and start new timer*/
                                  cell_stop_timer(p_cell_attribute_info->cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER]);
                                  p_cell_attribute_info->timer_status[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Old running timer Stopped");
                                  /*BUG178:end*/
                                  p_cell_attribute_info->p_active_ue->flag_periodic_active_ue= RRM_TRUE; 
                                  o_cell_timer_buf.timer_type = timer_type;
                                  o_cell_timer_buf.cell_index= p_cell_ctx->cell_index;
                                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                          RRM_DETAILED,"Old Timer duration = %d New Timer Duration:%d",
                                          p_cell_ctx->timer_val[timer_type],
                                                rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic);
                                  p_cell_ctx->timer_val[timer_type] = 
                                            rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic;
                                  RRM_ASSERT ( timer_type <= CELL_MAX_TIMER_TYPE);
                                  p_cell_attribute_info->
                                      cell_timer_id[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = 
                                      cell_start_timer( timer_type,
                                              (void *)&o_cell_timer_buf,
                                              sizeof(cell_timer_buf_t),
                                              p_cell_ctx);

                                  p_cell_attribute_info->timer_status
                                      [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RUNNING;
                              }
                              else
                              {
                                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, \
                                          "Invalid Timer Type [%d]",timer_type);
                                  ret_val = RRM_FAILURE;
                              }
                              break;

                          case RRM_MIF_CELLM_TRGR_THRESHOLD:
                              p_cell_attribute_info->p_active_ue->flag_threshold_active_ue= RRM_TRUE;
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
                              break;
                          case RRM_MIF_CELLM_TRGR_EVENT:
                              p_cell_attribute_info->p_active_ue->flag_trgr_active_ue = RRM_TRUE;
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
                              break;
                          case RRM_MIF_CELLM_TRGR_UNDEF:
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
                              break;
                      }
                  }
              }
              else
              {
                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                          RRM_DETAILED,"p_cell_attribute_info is NULL");
                  ret_val = RRM_FAILURE;
              }
          }
          else     
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Attribute trigger list is false");
          }
      }    
      if ( RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD==
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id )
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD");
                if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          { 
              if(RRM_PNULL != p_cell_attribute_info)
              {
                  if (p_cell_attribute_info->p_ue_threshold == RRM_PNULL)
                  {
                      p_cell_attribute_info->p_ue_threshold = 
                          rrm_mem_get(sizeof(cell_active_ue_threshold_t));
                  }
                  if(RRM_PNULL == p_cell_attribute_info->p_ue_threshold) /* Coverity: CID 16275 */
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "Failed to allocate memory to p_cell_attribute_info->p_ue_threshold");
                      RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                      RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);  
                      return RRM_FAILURE;
                  }
                        for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
                  {
                            switch(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id)
                      {
                          case RRM_MIF_CELLM_TRGR_PERIODIC:
                              p_cell_attribute_info->p_ue_threshold->flag_periodic_ue_threshold= RRM_TRUE;
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_PERIODIC");
                              break;
                          case RRM_MIF_CELLM_TRGR_THRESHOLD:
                              p_cell_attribute_info->p_ue_threshold->flag_threshold_ue_threshold= RRM_TRUE;
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                      RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_THRESHOLD" 
                                      "old Threshold val:%d New threshold Val :%d",
                                      p_cell_attribute_info->p_ue_threshold->threshold_val,
                                            rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.threshold);
                              p_cell_attribute_info->p_ue_threshold->threshold_val = 
                                        rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.threshold;
                              break;
                          case RRM_MIF_CELLM_TRGR_EVENT:
                              p_cell_attribute_info->p_ue_threshold->flag_trgr_ue_threshold= RRM_TRUE;
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
                              break;
                          case RRM_MIF_CELLM_TRGR_UNDEF:
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
                              break;
                      }
                  }
              }
              else
              {
                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                          RRM_BRIEF,"p_cell_attribute_info is NULL");
                  ret_val = RRM_FAILURE;
              }
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Attribute trigger list is empty");
          }
      } 
      if ( RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION == 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id ) 
      {
          if( RRM_PNULL != p_cell_attribute_info)
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION");
                    if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
              {
                  if (p_cell_attribute_info->p_s1_msg_notification == RRM_PNULL)
                  {
                      p_cell_attribute_info->p_s1_msg_notification = 
                          rrm_mem_get(sizeof(cell_s1_msg_notification_t));
                  }
                  /*coverity 16275, rel2.0.1, */
                  if(RRM_PNULL != p_cell_attribute_info->p_s1_msg_notification)
                  {
                            for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list; trgr_list++)
                      {
                          map_flag_periodic_s1_msg_notification_info(
                                        rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id, 
                                  p_cell_attribute_info);
                      }
                  }
                  else
                  {
                      RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                              "Memory allocation to p_cell_attribute_info->p_s1_msg_notification failed");
                      RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                      RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                      RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);
                      ret_val = RRM_FAILURE;
                  }
              }
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                      RRM_BRIEF,"p_cell_attribute_info is NULL");
              ret_val = RRM_FAILURE;
          }
      }
      else if (RRM_MIF_CELLM_ATTR_MLB_SELF == 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id)
      {
                for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
          {
                    if ((RRM_MIF_CELLM_TRGR_PERIODIC == rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id) && 
                      (p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO]
                       !=
                             rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic))
              {
                  /* SPR-17852 START */
                  if (RRM_ZERO != p_cell_ctx->self_load_rpt_tmr) 
                  {
                      /* SPR-17852 END */
                      cell_stop_timer(p_cell_ctx->self_load_rpt_tmr);
                      /* SPR-17852 START */
                      p_cell_ctx->self_load_rpt_tmr = RRM_PNULL;
                      /* SPR-17852 END */
                  }
                  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO]
                            = rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic;

                  if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO])
                  {
                      o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;
                      o_cell_timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO;
                      /* CID : 60712 6 march coverity cycle code */
                        p_cell_ctx->self_load_rpt_tmr =
                          cell_start_timer ( CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO , (rrm_void_t *)&o_cell_timer_buf,
                                    sizeof (cell_timer_buf_t), p_cell_ctx);

                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                              RRM_BRIEF,"Updated"
                              " CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO with value [%u]",
                              p_cell_ctx->timer_val[o_cell_timer_buf.timer_type]);
                  }

                  /* Updating SON/OAM with the last report that is present */
                  build_and_send_rsu_to_son (p_cell_ctx);
                  build_and_send_rsu_to_oam (p_cell_ctx);
              }
          }
      }
      else if (RRM_MIF_CELLM_ATTR_MLB_NBR == 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id )
      {
                for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
          {
                    if ((RRM_MIF_CELLM_TRGR_PERIODIC == rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id) && 
                      (p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]
                       !=
                             rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic))
              {
                  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]
                            = rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic;

                  /* eICIC_PHASE_1_2_CHANGES_START */
                  rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
                  /* eICIC_PHASE_1_2_CHANGES_END */

                  if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                  {
                      rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx, p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
                  }


                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                          RRM_DETAILED,"Updated"
                          " CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO with value [%u]",
                          p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);

                  /* Updating SON/OAM with the last report that is present */
                  build_and_send_rsu_to_son (p_cell_ctx);
                  build_and_send_rsu_to_oam (p_cell_ctx);
              }
          }
      }
      /* SON ES MLB Started */
            else if (RRM_MIF_CELLM_ATTR_ES_LD_SELF == rrmcm_rmif_cell_set_attr->attribute[att_list_index].id)
      {
                for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
          {
                    if ((RRM_MIF_CELLM_TRGR_PERIODIC == rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id) && 
                      (p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO]
                       !=
                             rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic))
              {
                  /* SPR-17852 START */
                  if (RRM_ZERO != p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER])
                  {
                  /* SPR-17852 END */
                      cell_stop_timer(p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER]);
                      /* SPR-17852 START */
                      p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER] = RRM_PNULL;
                      /* SPR-17852 END */
                  }
                  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO]
                            = rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_type.periodic;

                  if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO])
                  {
                      o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;
                      o_cell_timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO;
                      /* CID : 60712 fix start*/
                        p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER] =
                          cell_start_timer ( CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO , (rrm_void_t *)&o_cell_timer_buf,
                                    sizeof (cell_timer_buf_t), p_cell_ctx);
                      /* CID : 60712 fix end */

                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                              RRM_BRIEF,"Updated"
                              " CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO with value [%u] sec",
                              p_cell_ctx->timer_val[o_cell_timer_buf.timer_type]);
                  }

                  /* Updating SON_ES with the last report that is present */
                  rrmcm_rrm_es_periodic_resrc_update (p_cell_ctx);
              }
          }
      }    
      /* SON ES MLB end */
      /* UE MEAS CHANGES : STARTS */
      else if ( RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL ==
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id ) 
      {
          timer_type = CELL_PERIODIC_TIMER_FOR_UE_MEAS; 
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL");

                if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          {
              /*coverity 24969: null check added for p_cell_attribute_info: , rel 1.3*/
              if(RRM_PNULL != p_cell_attribute_info)
              {
                  if (p_cell_attribute_info->p_ue_meas_result_notification == RRM_PNULL)
                  {
                      p_cell_attribute_info->p_ue_meas_result_notification = 
                          rrm_mem_get(sizeof(cell_ue_meas_result_notification_t));

                      if(RRM_PNULL == p_cell_attribute_info->p_ue_meas_result_notification) /* Coverity: CID 16275 */
                      {
                          RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                                  "Unable to allocate memory to p_cell_attribute_info->p_ue_meas_result_notification");
                          RRM_MEM_FREE(p_cell_attribute_info->p_cell_state);
                          RRM_MEM_FREE(p_cell_attribute_info->p_active_ue);
                          RRM_MEM_FREE(p_cell_attribute_info->p_ue_threshold);

                          return RRM_FAILURE;
                      }
                  }
                        for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list;trgr_list ++)
                  {
                            switch(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id)
                      {
                          case RRM_MIF_CELLM_TRGR_PERIODIC:

                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name
                                      ,RRM_DETAILED,"Trigger RRM_MIF_CELLM_TRGR_THRESHOLD");

                              p_cell_attribute_info->p_ue_meas_result_notification->
                                  flag_periodic_ue_meas_notification = RRM_TRUE; 
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,                            
                                      RRM_DETAILED,"Old Timer duration = %d New Timer "
                                      " Duration:%d", p_cell_ctx->timer_val[timer_type],
                                            rrmcm_rmif_cell_set_attr->attribute[att_list_index].
                                      trigger_type[trgr_list].trigger_type.periodic);

                              /* SPR-17852 START */
                              /* Stop the timer */
                              if(p_cell_attribute_info->cell_timer_id[SON_UE_MEAS_CONFIG_TIMER])
                              {
                              cell_stop_timer(p_cell_attribute_info->
                                      cell_timer_id[SON_UE_MEAS_CONFIG_TIMER]);

                                p_cell_attribute_info->
                                    cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] = RRM_PNULL;

                                p_cell_attribute_info->timer_status
                                  [SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                              }
                              /* SPR-17852 END */


                              /* Restart the timer with modified value */
                              o_cell_timer_buf.timer_type = timer_type;
                              o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;

                              p_cell_ctx->timer_val[timer_type] = 
                                        rrmcm_rmif_cell_set_attr->attribute[att_list_index].
                                  trigger_type[trgr_list].trigger_type.periodic -
                                  RRM_MEAS_RESULT_LATENCY_TIME ;

                              RRM_ASSERT ( timer_type <= CELL_MAX_TIMER_TYPE);

                              p_cell_attribute_info->
                                  cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] = 
                                  cell_start_timer( timer_type,
                                          (void *)&o_cell_timer_buf,
                                          sizeof(cell_timer_buf_t),
                                          p_cell_ctx);

                              p_cell_attribute_info->timer_status
                                  [SON_UE_MEAS_CONFIG_TIMER] = RUNNING;
                              break;

                          case RRM_MIF_CELLM_TRGR_THRESHOLD:
                              p_cell_attribute_info->p_ue_meas_result_notification->
                                  flag_threshold_ue_meas_notification = RRM_TRUE;
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name
                                      , RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
                              break;

                          case RRM_MIF_CELLM_TRGR_EVENT:
                              p_cell_attribute_info->p_ue_meas_result_notification->
                                  flag_trgr_ue_meas_notification = RRM_TRUE;

                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name
                                      , RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
                              break;

                          case RRM_MIF_CELLM_TRGR_UNDEF:
                              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
                              break;
                      }
                  }
              }
              else     
              {
                  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                          RRM_BRIEF,"p_cell_attribute_info is NULL");
                  ret_val = RRM_FAILURE;
              }
          }
          else     
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Attribute trigger list is false");
          }
      }

      else if ( RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT  == 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id )
      {
          /* Store UE MEAS COUNT in Cell Context */
          p_cell_ctx->ue_meas_cnt = 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].value;

          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                  RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT. UE count = %d", p_cell_ctx->ue_meas_cnt);
      }
      /* UE MEAS CHANGES : ENDS */
      /* BLR Team HO status report to SON Changes Start */
      else if (RRM_MIF_CELLM_ATTR_HO_REPORT ==
                    rrmcm_rmif_cell_set_attr-> attribute[att_list_index].id )
      {
                if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          {
                    for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list; trgr_list++)
              {
                        if (RRM_MIF_CELLM_TRGR_EVENT == rrmcm_rmif_cell_set_attr->attribute[att_list_index].\
                          trigger_type[trgr_list].trigger_id )
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                              "RRM_MIF_CELLM_ATTR_HO_REPORT enabled HO report to SON");
                      if( RRM_PNULL != p_cell_attribute_info)
                      {
                          p_cell_attribute_info->is_ho_report_active = RRM_TRUE;
                      }
                      else
                      {
                          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                  "p_cell_attribute_info is NULL");
                      }
                  }
                  else
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "invalid trigger id received[%d] for attribute type "
                              "RRM_MIF_CELLM_ATTR_HO_REPORT",
                                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id);
                  }
              }
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "Trigger list is not present for RRM_MIF_CELLM_ATTR_HO_REPORT");
          }
      }
      /* BLR Team HO status report to SON Changes End */

      /* MRO Changes start */ 
      else if (RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND ==
                    rrmcm_rmif_cell_set_attr-> attribute[att_list_index].id )
      {
                if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          {
                    for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list; trgr_list++)
              {
                        if (RRM_MIF_CELLM_TRGR_EVENT == rrmcm_rmif_cell_set_attr->attribute[att_list_index].\
                          trigger_type[trgr_list].trigger_id )
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                              "RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND enabled HO attempt indication report to SON");
                      if(RRM_PNULL != p_cell_attribute_info)\
                      {
                          p_cell_attribute_info->is_ho_attempt_ind_active = RRM_TRUE;
                      }
                      else
                      {
                          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                  "p_cell_attribute_info is NULL");
                      }
                  }
                  else
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "invalid trigger id received[%d] for attribute type "
                              "RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND",
                                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id);
                  }
              }
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "Trigger list is not present for RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND");
          }
      }

      else if (RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT ==
                    rrmcm_rmif_cell_set_attr-> attribute[att_list_index].id )
      {
                if(rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list)
          {
                    for(trgr_list = RRM_ZERO;trgr_list<rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_list; trgr_list++)
              {
                        if (RRM_MIF_CELLM_TRGR_EVENT == rrmcm_rmif_cell_set_attr->attribute[att_list_index].\
                          trigger_type[trgr_list].trigger_id )
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                              "RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT enabled HO failure report to SON");
                      /*coverity 24970: Null check added :  , rel 1.3*/
                      if(RRM_PNULL != p_cell_attribute_info)
                      {
                          p_cell_attribute_info->is_ho_failure_report_active = RRM_TRUE;
                      }
                      else
                      {
                          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                  "p_cell_attribute_info is NULL");
                      }

                  }
                  else
                  {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                              "invalid trigger id received[%d] for attribute type "
                              "RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT",
                                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].trigger_type[trgr_list].trigger_id);
                  }
              }
          }
          else
          {
              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "Trigger list is not present for RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT");
          }
      }
            /* SPR 20653 Fix Start */
            else if ( RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD  == 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id )
            {
                /* Store UE THROUGHPUT DL ANR THRESHOLD in Cell Context */
                p_cell_ctx->rrm_ue_throughput_dl_anr_threshold = 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].value;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD. DL ANR threshold = %d", p_cell_ctx->rrm_ue_throughput_dl_anr_threshold);
            }
            else if ( RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD  == 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].id )
            {
                /* Store UE THROUGHPUT UL ANR THRESHOLD in Cell Context */
                p_cell_ctx->rrm_ue_throughput_ul_anr_threshold = 
                    rrmcm_rmif_cell_set_attr->attribute[att_list_index].value;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD. UL ANR threshold = %d", p_cell_ctx->rrm_ue_throughput_ul_anr_threshold);
            }

      else
      {
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_BRIEF,"Invalid Attribbute Id [%u]",
                        rrmcm_rmif_cell_set_attr-> attribute[att_list_index].id);
      }
        }
        /* SPR 20653 Fix End */
      /* MRO changes end */
      rmcm_mif_set_register_resp(p_cell_ctx);
      /*BUG:769 start*/
      ret_val = rrm_cell_ue_threshold_rchd_ind(p_cell_ctx);
      /*BUG:769 end*/
  }
  RRM_UT_TRACE_EXIT();
  return ret_val;
}

/* UE MEAS CHANGES : STARTS */
/*******************************************************************
* Function Name  : rmcm_create_serving_cell_meas_node 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles cell register request from MIF in FSM
********************************************************************/
rrm_return_et
rmcm_create_serving_cell_meas_node
(
    rrm_cell_context_t *p_cell_ctx
) 
{
    rrm_return_et                                ret_value = RRM_SUCCESS;
    meas_eutran_context_list_t       *p_meas_eutran_list = PNULL;
    meas_eutran_node_t               *p_meas_eutran_node = PNULL;
    
    p_meas_eutran_list = &(p_cell_ctx->meas_eutran_list);
    
    /* Get memory for serving cell meas node */
    p_meas_eutran_node =
        (meas_eutran_node_t*)rrm_mem_get(sizeof(meas_eutran_node_t));   

    if (RRM_PNULL == p_meas_eutran_node)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "rmcm_create_serving_cell_meas_node: Mem allocation fail");
        ret_value = RRM_FAILURE;        
    }
    else
    {
        RRM_MEMSET(p_meas_eutran_node, RRM_ZERO, sizeof(meas_eutran_node_t));

        p_meas_eutran_node->meas_type = MEAS_TYPE_ANR;

        /* Fill the parameters in the meas node */
        p_meas_eutran_node->eutran_config.earfcn = p_cell_ctx->ran_info.
            rf_params.rf_configurations.dl_earfcn;
        p_meas_eutran_node->eutran_config.offset_frequency = 
            RRM_Q_OFFSET_RANGE_DB0;
        p_meas_eutran_node->eutran_config.prev_offset_frequency = 
            p_meas_eutran_node->eutran_config.offset_frequency;

        ylPushTail(p_meas_eutran_list, &(p_meas_eutran_node)->sNode);
    }
    RRM_UT_TRACE_EXIT();
    return ret_value;
}

/*LTE_RRM_KLOCWORK_WARN_13JUL_START*/
/*******************************************************************
* Function Name  : map_trigger_type_cell_state_info
* Inputs         : trigger_id, cell_attribute_info, event 
* Outputs        : None
* Returns        : void
* Description    : This function maps cell state info.
********************************************************************/
void map_trigger_type_cell_state_info(rrm_cellm_trigger_type_et  trigger_id_val,
                                      cell_son_attr_info_list_t  *p_cell_attr_info,
                                      U8                         event)
{
  RRM_UT_TRACE_ENTER();
  
  RRM_ASSERT (RRM_PNULL != p_cell_attr_info);
  switch(trigger_id_val)
  {
    case RRM_MIF_CELLM_TRGR_PERIODIC:
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_DETAILED, "trgr RRM_MIF_CELLM_TRGR_PERIODIC");
      p_cell_attr_info->p_cell_state->flag_periodic_cell_state= RRM_TRUE;
      break;

    case RRM_MIF_CELLM_TRGR_THRESHOLD:
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_DETAILED, "trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
      p_cell_attr_info->p_cell_state->flag_threshold_cell_state= RRM_TRUE;
      break;

    case RRM_MIF_CELLM_TRGR_EVENT:
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
    /*coverity 16338, typecasted, rel2.0.1, */
      p_cell_attr_info->p_cell_state->flag_trgr_cell_state = (rrm_bool_et)event;
      break;

    case RRM_MIF_CELLM_TRGR_UNDEF:
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
      break;
  }
}

/*******************************************************************
* Function Name  : map_flag_periodic_s1_msg_notification_info
* Inputs         : trigger_id, cell_attribute_info
* Outputs        : None
* Returns        : void
* Description    : This function maps s1 msg notification info
********************************************************************/
void map_flag_periodic_s1_msg_notification_info(rrm_cellm_trigger_type_et  trigger_id,
                                                cell_son_attr_info_list_t  *p_cell_attrbte_info)
{
  RRM_UT_TRACE_ENTER();
  if((RRM_PNULL != p_cell_attrbte_info) && (RRM_PNULL != p_cell_attrbte_info->p_s1_msg_notification))
  {
  switch(trigger_id)
  {
    case RRM_MIF_CELLM_TRGR_PERIODIC:
      p_cell_attrbte_info->p_s1_msg_notification->flag_periodic_s1_msg_notification= RRM_TRUE;
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_PERIODIC");
      break;
    case RRM_MIF_CELLM_TRGR_THRESHOLD:
      p_cell_attrbte_info->p_s1_msg_notification->flag_threshold_s1_msg_notification = RRM_TRUE;
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
      break;
    case RRM_MIF_CELLM_TRGR_EVENT:
      p_cell_attrbte_info->p_s1_msg_notification->flag_trgr_s1_msg_notification = RRM_TRUE;
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
      break;
    case RRM_MIF_CELLM_TRGR_UNDEF:
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
      break;
  }
  }
  else
  {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
	                      "p_cell_attrbte_info or p_cell_attrbte_info->p_s1_msg_notification is NULL");
  }
  RRM_UT_TRACE_EXIT();
}

/*******************************************************************
* Function Name  : map_trigger_type_ue_threshold_info
* Inputs         : trigger_id, cell_attribute_info, threshold
* Outputs        : None
* Returns        : void
* Description    : This function maps trigger type for periodic ue 
                   threshold 
********************************************************************/
void map_trigger_type_ue_threshold_info(rrm_cellm_trigger_type_et  trigger_id,
                                        cell_son_attr_info_list_t  *p_cell_attribute_info,
                                        U16  threshold)
{
  RRM_UT_TRACE_ENTER();

  switch(trigger_id)
  {
    case RRM_MIF_CELLM_TRGR_PERIODIC:
      p_cell_attribute_info->p_ue_threshold->flag_periodic_ue_threshold = RRM_TRUE;
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
       	        RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_PERIODIC");
      break;

    case RRM_MIF_CELLM_TRGR_THRESHOLD:
      p_cell_attribute_info->p_ue_threshold->flag_threshold_ue_threshold = RRM_TRUE;
      p_cell_attribute_info->p_ue_threshold->threshold_val = threshold;
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	        "trgr RRM_MIF_CELLM_TRGR_THRESHOLD thres val:%d",
                 threshold);
      break;

    case RRM_MIF_CELLM_TRGR_EVENT:
      p_cell_attribute_info->p_ue_threshold->flag_trgr_ue_threshold = RRM_TRUE;
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
	        RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_EVENT");
      break;

    case RRM_MIF_CELLM_TRGR_UNDEF:
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
   	        RRM_DETAILED,"trgr RRM_MIF_CELLM_TRGR_UNDEF");
      break;
  }

  RRM_UT_TRACE_EXIT();
}
/*LTE_RRM_KLOCWORK_WARN_13JUL_END*/

/* UE MEAS CHANGES : STARTS */
/*******************************************************************
* Function Name  : rmcm_mif_register_req
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handles cell register request from MIF in FSM
********************************************************************/
rrm_return_et
rmcm_mif_register_req(rrm_cell_context_t *p_cell_ctx)
{
    U8 att_list_index = RRM_ZERO;
    U8 att_list = RRM_ZERO;
    U8 trgr_list = RRM_ZERO;
    cell_timer_buf_t    o_cell_timer_buf = {CELL_PERIODIC_TIMER_FOR_ANR, RRM_ZERO,RRM_ZERO,RRM_ZERO };
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_son_register_deregister_req_t 
        *rrmcm_rmif_cell_reg_dereg_req = RRM_PNULL;
    cell_son_attr_info_list_t  *p_cell_attribute_info = RRM_PNULL;
    rrmcm_rmif_generic_resp_t generic_resp = {RRM_NULL};
    cell_timer_et  timer_type = CELL_MAX_TIMER_TYPE;

    RRM_UT_TRACE_ENTER();

    rrmcm_rmif_cell_reg_dereg_req = (rrmcm_rmif_cell_son_register_deregister_req_t *)
        p_cell_ctx->p_incoming_api_info; 
    p_cell_ctx->ongoing_trans_id = rrmcm_rmif_cell_reg_dereg_req->transaction_id;
    /* Based on received API(ANR/ES) store the mem pointer */
    if (RRMCM_RMIF_CELL_REGISTER_FROM_ANR_REQ == p_cell_ctx->api_id)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "Cell Registeration Request received for ANR");

        if (p_cell_ctx->cell_already_register_anr)
        { 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Cell Already Registerd");
            generic_resp.cellindex = p_cell_ctx->cell_index;
            generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp.response = RRM_FAILURE;
            generic_resp.fail_cause= RRM_ERR_CELL_ALREADY_REGISTER_FAILURE;

            ret_val = rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_REGISTER_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)&generic_resp);
            return ret_val;
        }
        else
        {    
            p_cell_ctx->cell_already_register_anr |= CELL_ALREADY_REGISTERD_FOR_ANR;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_DETAILED,"Cell register for ANR bit is set :%d",
                    p_cell_ctx->cell_already_register_anr);

            if (p_cell_ctx->p_son_info != RRM_PNULL)
            {
                if (p_cell_ctx->p_son_info->p_anr_info == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                            "ANR info pointer is already freed");
                    p_cell_ctx->p_son_info->p_anr_info = 
                        rrm_mem_get(sizeof(cell_son_attr_info_list_t));
                    if (RRM_PNULL == p_cell_ctx->p_son_info->p_anr_info)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR,"Failed to get memory for anr attribute list"
                                "for cell index:%u",
                                p_cell_ctx->cell_index);

                        generic_resp.cellindex = p_cell_ctx->cell_index;
                        generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
                        generic_resp.response = RRM_FAILURE;
                        generic_resp.fail_cause= RRM_ERR_SYS_MEM_ALLOC_FAILURE;

                        ret_val = rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                                RRMCM_RMIF_CELL_REGISTER_RESP,
                                sizeof(rrmcm_rmif_generic_resp_t),
                                (void *)&generic_resp);
                        /*Coverity ID 76600 Fix Start*/
                        if(ret_val != RRM_SUCCESS)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "failure in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                                    p_cell_ctx->cell_index);
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED
                                    ,"success in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                                    p_cell_ctx->cell_index);
                        }
                        /*Coverity ID 76600 Fix End*/
                    }
                    /*SPR 16169 FIX START */
                    p_cell_ctx->p_son_info->p_anr_info->p_ue_meas_result_notification = RRM_PNULL;
                    p_cell_ctx->p_son_info->p_anr_info->p_cell_state = RRM_PNULL;
                    p_cell_ctx->p_son_info->p_anr_info->p_active_ue = RRM_PNULL;
                    p_cell_ctx->p_son_info->p_anr_info->p_ue_threshold = RRM_PNULL;
                    p_cell_ctx->p_son_info->p_anr_info->p_s1_msg_notification = RRM_PNULL;
                    /*SPR 16169 FIX END */
                }
                p_cell_attribute_info = (cell_son_attr_info_list_t *)p_cell_ctx->p_son_info->p_anr_info;
                //p_cell_attribute_info->p_ue_meas_result_notification = RRM_PNULL;
                p_cell_attribute_info->timer_status[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                p_cell_attribute_info->timer_status[SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                p_cell_attribute_info->is_active = RRM_TRUE;

                timer_type = CELL_PERIODIC_TIMER_FOR_ANR;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                        "SON info pointer is alredy freed");
                ret_val = RRM_FAILURE;
            }
        }
    }
    else if(RRMCM_RMIF_CELL_REGISTER_FROM_ES_REQ == p_cell_ctx->api_id)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "Cell Registeration Request received for ES");
        if(p_cell_ctx->cell_already_register_es)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Cell Already Registerd");
            generic_resp.cellindex = p_cell_ctx->cell_index;
            generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp.response = RRM_FAILURE;
            generic_resp.fail_cause= RRM_ERR_CELL_ALREADY_REGISTER_FAILURE;

            ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_REGISTER_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)&generic_resp);
            if(ret_val == RRM_FAILURE)

            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_ERROR,"failure in sending :%d for cell index:%d",
                        p_cell_ctx->api_id,
                        p_cell_ctx->cell_index);
            }
            return ret_val;
        }
        else
        {    
            p_cell_ctx->cell_already_register_es |= CELL_ALREADY_REGISTERD_FOR_ES; 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_DETAILED,"Cell register for ES bit is set :%d",
                    p_cell_ctx->cell_already_register_es);
            if (p_cell_ctx->p_son_info != RRM_PNULL)
            {
                if (p_cell_ctx->p_son_info->p_es_info == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                            "ES info pointer is already freed");
                    p_cell_ctx->p_son_info->p_es_info = 
                        rrm_mem_get(sizeof(cell_son_attr_info_list_t));
                    if(RRM_PNULL == p_cell_ctx->p_son_info->p_es_info)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Failed to allocate memory to p_cell_ctx->p_son_info->p_es_info");
                        generic_resp.cellindex = p_cell_ctx->cell_index;
                        generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
                        generic_resp.response = RRM_FAILURE;
                        generic_resp.fail_cause = RRM_ERR_SYS_MEM_ALLOC_FAILURE;

                        ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                                RRMCM_RMIF_CELL_REGISTER_RESP,
                                sizeof(rrmcm_rmif_generic_resp_t),
                                (void *)&generic_resp);
                        /*Coverity ID 76600 Fix Start*/
                        if(ret_val != RRM_SUCCESS)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "failure in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                                    p_cell_ctx->cell_index);
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED
                                    ,"success in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                                    p_cell_ctx->cell_index);
                        }
                        /*Coverity ID 76600 Fix End*/
                    }
                }
                p_cell_attribute_info = (cell_son_attr_info_list_t *)p_cell_ctx->p_son_info->p_es_info;
                p_cell_attribute_info->is_active = RRM_TRUE;
                p_cell_attribute_info->timer_status[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
                p_cell_attribute_info->timer_status[SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
                timer_type = CELL_PERIODIC_TIMER_FOR_ES;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                        "SON info pointer is alredy freed");
                ret_val = RRM_FAILURE;
            }
        }
    }
    else if (RRMCM_RMIF_CELL_REGISTER_FROM_MLB_REQ == p_cell_ctx->api_id)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "Cell Registeration Request received for MLB");

        if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
        { 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Cell Already Registerd");
            generic_resp.cellindex = p_cell_ctx->cell_index;
            generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp.response = RRM_FAILURE;
            generic_resp.fail_cause = RRM_ERR_CELL_ALREADY_REGISTER_FAILURE;

            ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_REGISTER_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)&generic_resp);
            /*Coverity ID 76600 Fix Start*/
            if(ret_val != RRM_SUCCESS)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "failure in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                        p_cell_ctx->cell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED
                        ,"success in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                        p_cell_ctx->cell_index);
            }
            /*Coverity ID 76600 Fix End*/
        }
        else
        {    
            if (p_cell_ctx->p_son_info != RRM_PNULL)
            {
                if (p_cell_ctx->p_son_info->p_mlb_info == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                            "MLB info pointer is already freed");
                    p_cell_ctx->p_son_info->p_mlb_info = 
                        rrm_mem_get (sizeof(cell_son_attr_info_list_t));
                    if (RRM_PNULL == p_cell_ctx->p_son_info->p_mlb_info)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR,"Failed to get memory for mlb attribute list"
                                " for cell index:%u",
                                p_cell_ctx->cell_index);
                        generic_resp.cellindex = p_cell_ctx->cell_index;
                        generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
                        generic_resp.response = RRM_FAILURE;
                        generic_resp.fail_cause= RRM_ERR_SYS_MEM_ALLOC_FAILURE;

                        ret_val = rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                                RRMCM_RMIF_CELL_REGISTER_RESP,
                                sizeof(rrmcm_rmif_generic_resp_t),
                                (void *)&generic_resp);
                        /*Coverity ID 76600 Fix Start*/
                        if(ret_val != RRM_SUCCESS)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "failure in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                                    p_cell_ctx->cell_index);
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED
                                    ,"success in sending :RRMCM_RMIF_CELL_REGISTER_RESP for cell index:%d",
                                    p_cell_ctx->cell_index);
                        }
                        /*Coverity ID 76600 Fix End*/
                    }
                }
                p_cell_attribute_info = (cell_son_attr_info_list_t *)p_cell_ctx->p_son_info->p_mlb_info;
                p_cell_attribute_info->is_ho_report_active = RRM_FALSE;
                p_cell_attribute_info->p_cell_state = RRM_PNULL;
                p_cell_ctx->registered_mod_by_son |= CELL_ALREADY_REGISTERD_FOR_MLB;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Cell register for MLB bit is set :%d",
                        p_cell_ctx->registered_mod_by_son);

            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                        "SON info pointer is already freed");
                ret_val = RRM_FAILURE;
            }
        }
    }
    /* MRO changes start */
    else if (RRMCM_RMIF_CELL_REGISTER_FROM_MRO_REQ == p_cell_ctx->api_id)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Cell Registeration Request received for MRO");

        if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MRO)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Cell Already Registerd");
            generic_resp.cellindex = p_cell_ctx->cell_index;
            generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp.response = RRM_FAILURE;
            generic_resp.fail_cause = RRM_ERR_CELL_ALREADY_REGISTER_FAILURE;

            ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_REGISTER_RESP,
                    sizeof(rrmcm_rmif_generic_resp_t),
                    (void *)&generic_resp);
            return ret_val;
        }
        else
        {
            p_cell_ctx->registered_mod_by_son |= CELL_ALREADY_REGISTERD_FOR_MRO;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"Cell register for MRO bit is set :%d",
                    p_cell_ctx->registered_mod_by_son);

            if (p_cell_ctx->p_son_info != RRM_PNULL)
            {
                if (p_cell_ctx->p_son_info->p_mro_info == RRM_PNULL)
                {
                    /* Allocating memory for mro info */
                    p_cell_ctx->p_son_info->p_mro_info =
                        rrm_mem_get (sizeof(cell_son_attr_info_list_t));
                    if (RRM_PNULL == p_cell_ctx->p_son_info->p_mro_info)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR,"Failed to get memory for mro attribute list"
                                "for cell index:%u",
                                p_cell_ctx->cell_index);
                        ret_val = RRM_FAILURE;
                    }
                }
                if((ret_val != RRM_FAILURE )&&
                   (RRM_PNULL != p_cell_ctx->p_son_info->p_mro_info))
                {
                    p_cell_attribute_info = (cell_son_attr_info_list_t *)p_cell_ctx->p_son_info->p_mro_info;
                    p_cell_attribute_info->is_ho_attempt_ind_active = RRM_FALSE;
                	p_cell_attribute_info->p_cell_state = RRM_PNULL;
                    p_cell_attribute_info->is_ho_failure_report_active = RRM_FALSE;
                	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    		  RRM_BRIEF,"Cell registered for MRO "); 
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                              "MRO info pointer is already freed");
                    ret_val = RRM_FAILURE;

                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "SON info pointer is already freed");
                ret_val = RRM_FAILURE;
            }
        }
    }

    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                "Invalid API(%d) received from SON", p_cell_ctx->api_id);
        return RRM_FAILURE;
    }
    /* coverity_11116 start */
    if (PNULL == p_cell_attribute_info)
    {
        return RRM_FAILURE;
    }
    /* coverity_11116 stop */
    if (RRM_SUCCESS == ret_val)
    {
        /*bug 827 start*/
        /*SPR 16169 FIX START
         *if(RRM_PNULL != p_cell_attribute_info)
        {
            p_cell_attribute_info->p_cell_state = RRM_PNULL;
            p_cell_attribute_info->p_active_ue = RRM_PNULL;
            p_cell_attribute_info->p_ue_threshold = RRM_PNULL;
            p_cell_attribute_info->p_s1_msg_notification = RRM_PNULL;
        }
        bug 827 end
        SPR 16169 FIX END
        */

        att_list = rrmcm_rmif_cell_reg_dereg_req->attr_list_size;
        /* Coverity_fix_start_55006 */
        for (att_list_index = RRM_ZERO;((att_list_index < att_list) &&
                    (att_list_index < RRM_ATTR_LIST_SIZE));
                att_list_index++)    
            /* Coverity_fix_end_55006 */
        {
            if (RRM_MIF_CELLM_ATTR_CELL_STATE== rrmcm_rmif_cell_reg_dereg_req->
                    attribute_list[att_list_index].id)
            {
                if (RRM_PNULL == p_cell_attribute_info->p_cell_state)
                {
                    p_cell_attribute_info->p_cell_state = 
                        (cell_state_t *)rrm_mem_get(sizeof(cell_state_t));
                    if(RRM_PNULL == p_cell_attribute_info->p_cell_state)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Failed to allocate memory to p_cell_attribute_info->p_cell_state");
                        return RRM_FAILURE;
                    }
                    p_cell_attribute_info->p_cell_state->flag_periodic_cell_state = RRM_FALSE;
                    p_cell_attribute_info->p_cell_state->flag_threshold_cell_state = RRM_FALSE;
                    p_cell_attribute_info->p_cell_state->flag_trgr_cell_state = RRM_FALSE;
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED, "Attribute RRM_MIF_CELLM_ATTR_CELL_STATE");

                /* Coverity 21oct Start : 55006 */
                for (trgr_list = RRM_ZERO; (trgr_list < 
                        rrmcm_rmif_cell_reg_dereg_req->
                        attribute_list[att_list_index].trigger_list)
                        && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                /* Coverity 21oct End : 55006 */
                {
                    /*LTE_RRM_KLOCWORK_WARN_13JUL_START*/
                    map_trigger_type_cell_state_info(
                            rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_id,
                            p_cell_attribute_info, 
                            rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_type.event);
                    /*LTE_RRM_KLOCWORK_WARN_13JUL_END*/
                }/*for loop ends*/
            }    
            else if (RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id) 
            {
                if (RRM_PNULL == p_cell_attribute_info->p_active_ue)
                {
                    p_cell_attribute_info->p_active_ue = (cell_active_ue_t *)rrm_mem_get(
                            sizeof(cell_active_ue_t));
                    if(RRM_PNULL == p_cell_attribute_info->p_active_ue) /* Coverity: CID 16270 */
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Failed to allocate memory to p_cell_attribute_info->p_active_ue");
                        return RRM_FAILURE;
                    }
                    p_cell_attribute_info->p_active_ue->flag_periodic_active_ue = RRM_FALSE;
                    p_cell_attribute_info->p_active_ue->flag_threshold_active_ue = RRM_FALSE;
                    p_cell_attribute_info->p_active_ue->flag_trgr_active_ue = RRM_FALSE;
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED, 
                        "Attribute RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT");

                /* Coverity 21oct Start : 55006 */
                for (trgr_list = RRM_ZERO; 
                        (trgr_list < rrmcm_rmif_cell_reg_dereg_req->
                        attribute_list[att_list_index].trigger_list)
                        && (trgr_list < RRM_TRGR_LIST_SIZE); 
                        trgr_list++)
                /* Coverity 21oct End : 55006 */
                {
                    switch(rrmcm_rmif_cell_reg_dereg_req->
                            attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_id)
                    {

                        case RRM_MIF_CELLM_TRGR_PERIODIC:
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Trigger RRM_MIF_CELLM_TRGR_PERIODIC");
                            p_cell_attribute_info->p_active_ue->flag_periodic_active_ue= RRM_TRUE; 
                            o_cell_timer_buf.timer_type = timer_type;
                            o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;
                            if(timer_type < CELL_MAX_TIMER_TYPE )
                            {
                                p_cell_ctx->timer_val[timer_type] = 
                                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                    trigger_type[trgr_list].trigger_type.periodic;
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                        "Timer duration = %d", p_cell_ctx->timer_val[timer_type]);

                                RRM_ASSERT ( timer_type <= CELL_MAX_TIMER_TYPE);
                                p_cell_attribute_info->cell_timer_id
                                    [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = cell_start_timer( timer_type,
                                            (void *)&o_cell_timer_buf,
                                            sizeof(cell_timer_buf_t),
                                            p_cell_ctx);
                                p_cell_attribute_info->timer_status
                                    [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = RUNNING;
                            }
                            break;
                        case RRM_MIF_CELLM_TRGR_THRESHOLD:
                            p_cell_attribute_info->p_active_ue->flag_threshold_active_ue= RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
                            break;
                        case RRM_MIF_CELLM_TRGR_EVENT:
                            p_cell_attribute_info->p_active_ue->flag_trgr_active_ue = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "trgr RRM_MIF_CELLM_TRGR_EVENT");
                            break;
                        case RRM_MIF_CELLM_TRGR_UNDEF:
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "trgr RRM_MIF_CELLM_TRGR_UNDEF");
                            break;
                    }
                }
            }    
            else if (RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if (RRM_PNULL == p_cell_attribute_info->p_ue_threshold)
                {
                    p_cell_attribute_info->p_ue_threshold= 
                        (cell_active_ue_threshold_t *)rrm_mem_get(sizeof(cell_active_ue_threshold_t));
                    
                    if(RRM_PNULL == p_cell_attribute_info->p_ue_threshold) /* Coverity: CID 16270 */
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                            "Failed to allocate memory to p_cell_attribute_info->p_ue_threshold");
                        return RRM_FAILURE;
                    }
                    p_cell_attribute_info->p_ue_threshold->threshold_val = RRM_ZERO;
                    p_cell_attribute_info->p_ue_threshold->threshold_flag = RRM_FALSE;
                    /*BUG:831 start*/
                    p_cell_attribute_info->p_ue_threshold->threshold_value_down_flag = RRM_FALSE;
                    /*BUG:831 end*/
                    p_cell_attribute_info->p_ue_threshold->flag_periodic_ue_threshold = RRM_FALSE;
                    p_cell_attribute_info->p_ue_threshold->flag_threshold_ue_threshold = RRM_FALSE;
                    p_cell_attribute_info->p_ue_threshold->flag_trgr_ue_threshold = RRM_FALSE;
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD");
                
                /* Coverity 21oct Start : 55006 */
                for (trgr_list = RRM_ZERO; (trgr_list < 
                        rrmcm_rmif_cell_reg_dereg_req->
                        attribute_list[att_list_index].trigger_list)
                        && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                /* Coverity 21oct End : 55006 */
                {
                    /*LTE_RRM_KLOCWORK_WARN_13JUL_START*/
                    map_trigger_type_ue_threshold_info(
                            rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_id, 
                            p_cell_attribute_info, 
                            rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_type.threshold);
                    /*LTE_RRM_KLOCWORK_WARN_13JUL_END*/
                }
            } 
            else if (RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION == 
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id) 
            {
                if (RRM_PNULL == p_cell_attribute_info->p_s1_msg_notification)
                {
                    p_cell_attribute_info->p_s1_msg_notification = 
                        (cell_s1_msg_notification_t *)rrm_mem_get(sizeof(cell_s1_msg_notification_t));
                    /*  , coverity  id :16270 , added NULL check for rrm_mem_get */
                    if(p_cell_attribute_info->p_s1_msg_notification != RRM_PNULL)
                    {
                        p_cell_attribute_info->p_s1_msg_notification->flag_periodic_s1_msg_notification = RRM_FALSE;
                        p_cell_attribute_info->p_s1_msg_notification->flag_trgr_s1_msg_notification = RRM_FALSE;
                        p_cell_attribute_info->p_s1_msg_notification->flag_threshold_s1_msg_notification = RRM_FALSE;
                    }
                    else
                    {
                        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                                "Memory allocation to p_cell_attribute_info->p_s1_msg_notification failed");
                        return RRM_FAILURE;
                    }

                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION");
                /* Coverity 21oct Start : 55006 */
                for (trgr_list = RRM_ZERO; (trgr_list < 
                        rrmcm_rmif_cell_reg_dereg_req->
                        attribute_list[att_list_index].trigger_list)
                        && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                /* Coverity 21oct End : 55006 */
                {
                    /*LTE_RRM_KLOCWORK_WARN_13JUL_START*/
                    map_flag_periodic_s1_msg_notification_info(
                            rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_id, 
                            p_cell_attribute_info);
                    /*LTE_RRM_KLOCWORK_WARN_13JUL_END*/
                }
            }
            /* UE MEAS CHANGES : STARTS */
            else if (RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id) 
            {
                if (RRM_PNULL == p_cell_attribute_info->
                        p_ue_meas_result_notification)
                {
                    p_cell_attribute_info->p_ue_meas_result_notification =
                        rrm_mem_get(sizeof(cell_ue_meas_result_notification_t));
                    if(RRM_PNULL == p_cell_attribute_info->p_ue_meas_result_notification)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Failed to allocate memory to p_cell_attribute_info->p_ue_meas_result_notification");
                        return RRM_FAILURE;
                    }
                    p_cell_attribute_info->p_ue_meas_result_notification->
                        flag_periodic_ue_meas_notification = RRM_FALSE;

                    p_cell_attribute_info->p_ue_meas_result_notification->
                        flag_threshold_ue_meas_notification = RRM_FALSE;

                    p_cell_attribute_info->p_ue_meas_result_notification->
                        flag_trgr_ue_meas_notification = RRM_FALSE;
                }

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute "
                        "RRM_MIF_CELLM_ATTR_UE_MEAS_REPORT");

                /* Coverity 21oct Start : 55006 */
                for (trgr_list = 0; (trgr_list < 
                        rrmcm_rmif_cell_reg_dereg_req->
                        attribute_list[att_list_index].trigger_list)
                        && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                /* Coverity 21oct End : 55006 */
                {
                    switch(rrmcm_rmif_cell_reg_dereg_req->
                            attribute_list[att_list_index].
                            trigger_type[trgr_list].trigger_id)
                    {
                        case RRM_MIF_CELLM_TRGR_PERIODIC:
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                    RRM_DETAILED,"Trigger RRM_MIF_CELLM_TRGR_PERIODIC");

                            p_cell_attribute_info->p_ue_meas_result_notification->
                                flag_periodic_ue_meas_notification = RRM_TRUE; 

                            /* Bug 948 Fix Start */
                            if(RRM_NULL == p_cell_ctx->meas_eutran_list.count)
                            {
                                /* Create Meas Node for Serving Cell EARFCN */
                                ret_val = rmcm_create_serving_cell_meas_node(p_cell_ctx);  
                                if(ret_val == RRM_SUCCESS)
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                            "rmcm_mif_register_req: Meas Node Created for Self Earfcn");
                                }
                                else
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "rmcm_mif_register_req: Fail to create Meas Node for Self Earfcn");
                                }
                            }
                            /* Bug 948 Fix End */

                            p_cell_attribute_info->p_ue_meas_result_notification->trigger_type.
                                trigger_id = 
                                rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_id;
                            p_cell_attribute_info->p_ue_meas_result_notification->trigger_type.
                                trigger_type = 
                                rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_type;
                            /* UE MEAS TIMER  */
                            timer_type = CELL_PERIODIC_TIMER_FOR_UE_MEAS;

                            o_cell_timer_buf.timer_type = timer_type;
                            o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;

                            if(timer_type < CELL_MAX_TIMER_TYPE )
                            {
                                /* This is already in secs */
                                p_cell_ctx->timer_val[timer_type] =  
                                    (rrmcm_rmif_cell_reg_dereg_req->attribute_list
                                     [att_list_index].trigger_type[trgr_list].trigger_type
                                     .periodic - RRM_MEAS_RESULT_LATENCY_TIME);

                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                        RRM_DETAILED,"Timer duration = %d",
                                        p_cell_ctx->timer_val[timer_type]);

                                RRM_ASSERT ( timer_type <= CELL_MAX_TIMER_TYPE);

                                /* Start UE MEAS CONFIG TIMER */
                                p_cell_attribute_info->
                                    cell_timer_id[SON_UE_MEAS_CONFIG_TIMER] =
                                    cell_start_timer( timer_type,
                                            (void *)&o_cell_timer_buf,
                                            sizeof(cell_timer_buf_t),
                                            p_cell_ctx);

                                p_cell_attribute_info->timer_status
                                    [SON_UE_MEAS_CONFIG_TIMER] = RUNNING;
                                /* Start Fix for SPR 14987 */
                                /*When ANR is enabled, Send ANR meas config req to selected Active UEs*/
                                rrm_uem_send_meas_config_req(p_cell_ctx);
                                p_cell_ctx->is_anr_first_cycle = RRM_TRUE;
                                /* End Fix for SPR 14987 */
                            }
                            break;
                        case RRM_MIF_CELLM_TRGR_THRESHOLD:

                            p_cell_attribute_info->p_ue_meas_result_notification->
                                flag_threshold_ue_meas_notification = RRM_TRUE;

                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "trgr RRM_MIF_CELLM_TRGR_THRESHOLD");
                            break;
                        case RRM_MIF_CELLM_TRGR_EVENT:
                            p_cell_attribute_info->p_ue_meas_result_notification->
                                flag_trgr_ue_meas_notification = RRM_TRUE;

                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "trgr RRM_MIF_CELLM_TRGR_EVENT");
                            break;

                        case RRM_MIF_CELLM_TRGR_UNDEF:
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "trgr RRM_MIF_CELLM_TRGR_UNDEF");
                            break;
                    }
                }
            }
            else if (RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT== 
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT");
                /* Store UE MEAS COUNT in Cell Context */
                p_cell_ctx->ue_meas_cnt = 
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                    value;
            }
            /* HO status report to SON Changes Start */
            else if (RRM_MIF_CELLM_ATTR_HO_REPORT ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_list)
                {
                        /* Coverity 21oct Start : 55006 */
                    for (trgr_list = RRM_ZERO; (trgr_list < 
                                rrmcm_rmif_cell_reg_dereg_req->
                                attribute_list[att_list_index].trigger_list)
                                && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                        /* Coverity 21oct End : 55006 */
                    {
                        if (rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_id == RRM_MIF_CELLM_TRGR_EVENT)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                                    "RRM_MIF_CELLM_ATTR_HO_REPORT enabled HO report to SON");
                            p_cell_attribute_info->is_ho_report_active = RRM_TRUE;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "invalid trigger id received[%d] for attribute type "
                                    "RRM_MIF_CELLM_ATTR_HO_REPORT", rrmcm_rmif_cell_reg_dereg_req->\
                                    attribute_list[att_list_index].trigger_type[trgr_list].trigger_id);
                        }
                    }
                }
            }
            /* HO status report to SON Changes End */
            /* Code for MLB start */
            else if (RRM_MIF_CELLM_ATTR_MLB_NBR ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_list)
                {
                    /* Coverity 21oct Start : 55006 */
                    for (trgr_list = RRM_ZERO; (trgr_list < rrmcm_rmif_cell_reg_dereg_req->
                            attribute_list[att_list_index].trigger_list)
                            && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                    /* Coverity 21oct End : 55006 */
                    {
                        if ((rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_id == RRM_MIF_CELLM_TRGR_PERIODIC) &&
                                (rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                 trigger_type[trgr_list].trigger_type.periodic))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "trgr RRM_MIF_CELLM_TRGR_PERIODIC for attribute"
                                    "RRM_MIF_CELLM_ATTR_MLB_NBR to SON");
                            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO] = \
                                rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].\
                                        trigger_type[trgr_list].trigger_type.periodic;
                            /* Coverity ID 77450 Fix Start*/ 
                            rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx,\
                                                    rrmcm_rmif_cell_reg_dereg_req->attribute_list\
                                                    [att_list_index].trigger_type[trgr_list].trigger_type.periodic);
                            /* Coverity ID 77450 Fix End*/ 
                            break;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "invalid trigger id received[%d] for attribute type "
                                    "RRM_MIF_CELLM_MLB", rrmcm_rmif_cell_reg_dereg_req->\
                                    attribute_list[att_list_index].trigger_type[trgr_list].trigger_id);
                        }
                    }
                }
              
            }
            else if (RRM_MIF_CELLM_ATTR_MLB_SELF ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_list)
                {
                    /* Coverity 21oct Start : 55006 */
                    for (trgr_list = RRM_ZERO; (trgr_list < 
                                rrmcm_rmif_cell_reg_dereg_req->
                                attribute_list[att_list_index].trigger_list)
                                && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                    /* Coverity 21oct End : 55006 */
                    {
                        if ((rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_id == RRM_MIF_CELLM_TRGR_PERIODIC) &&
                                (rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].\
                                 trigger_type[trgr_list].trigger_type.periodic))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "trgr RRM_MIF_CELLM_TRGR_PERIODIC for attribute"
                                    "RRM_MIF_CELLM_ATTR_MLB_SELF enabled report to SON");

                                if (RRM_ZERO != rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                            trigger_type[trgr_list].trigger_type.periodic)
                                {
                                o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;
                                o_cell_timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO;
                                p_cell_ctx->timer_val[o_cell_timer_buf.timer_type] =
                                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].\
                                                    trigger_type[trgr_list].trigger_type.periodic;
                                /* CID : 60710 fix start*/
                                /* CID : 60710 Fix Start */
                                p_cell_ctx->self_load_rpt_tmr =
                                    cell_start_timer (CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO, (rrm_void_t *)&o_cell_timer_buf,
                                            sizeof (cell_timer_buf_t), p_cell_ctx);
                                /* CID : 60710 Fix End */
                                    cell_start_timer ( CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO , (rrm_void_t *)&o_cell_timer_buf,
                                            sizeof (cell_timer_buf_t), p_cell_ctx);
                                /* CID : 60710 fix end */
                                }
                                break;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "invalid trigger id [%d] received for attribute type "
                                    "RRM_MIF_CELLM_MLB", rrmcm_rmif_cell_reg_dereg_req->\
                                    attribute_list[att_list_index].trigger_type[trgr_list].trigger_id);
                        }
                    }
                }
            }
            /* Code for MLB End */

            /* SON ES MLB Started */
            else if (RRM_MIF_CELLM_ATTR_ES_LD_SELF ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_list)
                {
                    /* Coverity 21oct Start : 55006 */
                    for (trgr_list = RRM_ZERO; (trgr_list < 
                                rrmcm_rmif_cell_reg_dereg_req->
                                attribute_list[att_list_index].trigger_list)
                                && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                    /* Coverity 21oct End : 55006 */
                    {
                        if ((rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                    trigger_type[trgr_list].trigger_id == RRM_MIF_CELLM_TRGR_PERIODIC) &&
                                (rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].\
                                 trigger_type[trgr_list].trigger_type.periodic))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "trgr RRM_MIF_CELLM_TRGR_PERIODIC for attribute"
                                    " RRM_MIF_CELLM_ATTR_ES_LD_SELF enabled report to SON");

                            o_cell_timer_buf.cell_index = p_cell_ctx->cell_index;
                            o_cell_timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO;
                            p_cell_ctx->timer_val[o_cell_timer_buf.timer_type] =
                                rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].\
                                trigger_type[trgr_list].trigger_type.periodic;
                            /* CID : 60711 fix start*/
                            p_cell_attribute_info->cell_timer_id[SON_ES_LD_SELF_TIMER] =
                                cell_start_timer ( CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO , (rrm_void_t *)&o_cell_timer_buf,
                                        sizeof (cell_timer_buf_t), p_cell_ctx);
                            /* CID : 60711 fix end */
                            break;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Cannot start timer [SON_ES_LD_SELF_TIMER]"
                                    " for trigger id [%d], duration [%u] received for attribute"
                                    " type RRM_MIF_CELLM_ATTR_ES_LD_SELF", rrmcm_rmif_cell_reg_dereg_req->
                                    attribute_list[att_list_index].trigger_type[trgr_list].trigger_id,
                                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_type[trgr_list].trigger_type.periodic);
                        }
                    }
                }
            }
            /* SON ES MLB end */

            /* MRO code changes start */
            else if (RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_list)
                {
                    /* Coverity 21oct Start : 55006 */
                    for (trgr_list = RRM_ZERO; (trgr_list < 
                                rrmcm_rmif_cell_reg_dereg_req->
                                attribute_list[att_list_index].trigger_list)
                                && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                    /* Coverity 21oct End : 55006 */
                    {
                        if (rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_id == RRM_MIF_CELLM_TRGR_EVENT)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                                    "RRM_MIF_CELLM_ATTR_ATTEMPT_IND enabled HO report to SON");
                            p_cell_attribute_info->is_ho_attempt_ind_active = RRM_TRUE;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "invalid trigger id received[%d] for attribute type "
                                    "RRM_MIF_CELLM_ATTR_ATTEMPT_IND", rrmcm_rmif_cell_reg_dereg_req->\
                                    attribute_list[att_list_index].trigger_type[trgr_list].trigger_id);
                        }
                    }
                }
            }
            else if (RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                if(rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].trigger_list)
                {
                    /* Coverity 21oct Start : 55006 */
                    for (trgr_list = RRM_ZERO; (trgr_list < 
                                rrmcm_rmif_cell_reg_dereg_req->
                                attribute_list[att_list_index].trigger_list)
                                && (trgr_list < RRM_TRGR_LIST_SIZE); trgr_list++)
                    /* Coverity 21oct End : 55006 */
                    {
                        if (rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                                trigger_type[trgr_list].trigger_id == RRM_MIF_CELLM_TRGR_EVENT)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "trgr RRM_MIF_CELLM_TRGR_EVENT for attribute"
                                    "RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT enabled HO report to SON");
                            p_cell_attribute_info->is_ho_failure_report_active = RRM_TRUE;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "invalid trigger id received[%d] for attribute type "
                                    "RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT", rrmcm_rmif_cell_reg_dereg_req->\
                                    attribute_list[att_list_index].trigger_type[trgr_list].trigger_id);
                        }
                    }
                }
            }
            /* Code for MRO ends */
            /* SPR 20653 Fix Start */
            else if (RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD");
                /* Store UE THROUGHPUT DL ANR THRESHOLD in Cell Context */
                p_cell_ctx->rrm_ue_throughput_dl_anr_threshold = 
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                    value;
            }

            else if (RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD ==
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].id)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Attribute RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD");
                /* Store UE THROUGHPUT UL ANR THRESHOLD in Cell Context */
                p_cell_ctx->rrm_ue_throughput_ul_anr_threshold = 
                    rrmcm_rmif_cell_reg_dereg_req->attribute_list[att_list_index].
                    value;
            }
            /* SPR 20653 Fix End */
        }/*for loop ends here*/

        rmcm_mif_register_resp(p_cell_ctx);
        /*BUG:769 start*/
        ret_val = rrm_cell_ue_threshold_rchd_ind(p_cell_ctx);
        /*BUG:769 end*/
        /*SPR 14131 start*/
        if ((RRMCM_RMIF_CELL_REGISTER_FROM_MLB_REQ == p_cell_ctx->api_id) && (p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type !=                
                                                                                                                         RRM_OAM_EICIC_DEACTIVATED ))
        {    
            ret_val = rrm_send_enable_disable_ind_to_son(p_cell_ctx);
        }
        /*SPR 14131 end*/
    }
    else
    {
        generic_resp.cellindex = p_cell_ctx->cell_index;
        generic_resp.transaction_id = p_cell_ctx->ongoing_trans_id;
        generic_resp.response = RRM_FAILURE;
        generic_resp.fail_cause= RRM_ERR_CELL_SET_ATTR_FAILURE;

        ret_val = rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                RRMCM_RMIF_CELL_REGISTER_RESP,
                sizeof(rrmcm_rmif_generic_resp_t),
                (void *)&generic_resp);
        /* Coverity Fix 76600 Start */
        /* Code Deleted */
        /* Coverity Fix 76600 End */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Functione Name : send_periodic_ue_active_ind 
 * Inputs         :  rrm_cell_context_t *p_cell_ctx 
 * Outputs        : None
 * Returns        : None
 * Description    : Definition of two dimensional array of functional pointer 
 *		    for FSM
 ****************************************************************************/

rrm_return_et
send_periodic_ue_active_ind
(
  rrm_cell_context_t *p_rrm_cell_ctx,
  rrm_mif_cellm_message_resp_e resp
    /*SPR 17777 +-*/
)
{

   rrm_return_et ret_val = RRM_SUCCESS;
   rrmcm_rmif_cell_active_ue_report_ind_t *p_ind = RRM_PNULL;

   RRM_UT_TRACE_EXIT();
      
   p_ind = rrm_mem_get(sizeof(rrmcm_rmif_cell_active_ue_report_ind_t));
   if(RRM_PNULL == p_ind)
   {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                 "send_periodic_ue_active_ind mem allocation failed");
       return RRM_FAILURE;
   }

   p_ind->cellindex = p_rrm_cell_ctx->cell_index; 
   p_ind->ue_cnt = p_rrm_cell_ctx->cell_resource_info.num_active_ue;
  
   if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
              resp,
              sizeof(rrmcm_rmif_cell_active_ue_report_ind_t),
              (void *)p_ind)) 
   {  
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
               "Send Periodic UE Active Ind: UE Count = %d For Cell Index:%d",
               p_ind->ue_cnt, p_rrm_cell_ctx->cell_index);
       ret_val = RRM_SUCCESS;
   }
   else
   {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "Failed To Send Periodic UE Active Ind: UE Count = %d" 
            "for cell_index %d", p_ind->ue_cnt,p_rrm_cell_ctx->cell_index);
        ret_val = RRM_FAILURE;
   }
   RRM_MEM_FREE(p_ind);
		
   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/****************************************************************************
 * Functione Name : rmcm_timer_expired 
 * Inputs         :  rrm_cell_context_t *p_cell_ctx 
 * Outputs        : None
 * Returns        : None
 * Description    : Definition of two dimensional array of functional pointer 
 *		    for FSM
 ****************************************************************************/

rrm_return_et 
rmcm_timer_expired 
(
  rrm_cell_context_t *p_rrm_cell_ctx
)
{
   rrm_return_et       ret_val            = RRM_SUCCESS; 

   cell_son_attr_info_list_t      *p_attribute_info = RRM_PNULL;  
   /* BLR_MEAS Changes Start 
   meas_eutran_context_list_t     *p_meas_eutran_list = RRM_PNULL;
   meas_utran_context_list_t      *p_meas_utran_list = RRM_PNULL;
   BLR_MEAS Changes Start */
        
   RRM_UT_TRACE_ENTER();

   /* UE MEAS CHANGES : STARTS */
   if (p_rrm_cell_ctx->p_son_info != RRM_PNULL) 
   {
       if (p_rrm_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)
       {
           p_attribute_info = p_rrm_cell_ctx->p_son_info->p_anr_info;
           if(p_attribute_info->timer_status[SON_UE_MEAS_CONFIG_TIMER] == 
                                                               EXPIRED)
           {
              /* Reset the timer status to RUNNING */
              rrm_uem_send_meas_config_req
                          (
                             p_rrm_cell_ctx
                          );
              p_attribute_info->timer_status[SON_UE_MEAS_CONFIG_TIMER] =
                                     RUNNING;
              /* Start fix for SPR 14987 */
              p_rrm_cell_ctx->is_anr_first_cycle = RRM_FALSE;
              /* End fix for SPR 14987 */

           }
           else
           {
               if(p_attribute_info->p_active_ue != RRM_PNULL)
               {
                   if(p_attribute_info->p_active_ue->flag_periodic_active_ue 
                                      == RRM_TRUE)
                   {
                       /* send threshold ind to SON */
                        /*BUG:102 start*/
                       if(p_rrm_cell_ctx->cell_stop_not_send_active_ue_count == RRM_FALSE)
                       {    
                        /*BUG:102 end*/
                           ret_val = send_periodic_ue_active_ind(p_rrm_cell_ctx,
                                   RRMCM_RMIF_CELL_ACTIVE_UE_COUNT_REPORT_FOR_ANR_IND);
                                   /*SPR 17777 +-*/
                           if(ret_val == RRM_FAILURE)
                           {
                               RRM_TRACE(g_cellm_log_on_off, 
                                       p_g_rrm_cellm_facility_name,
                                       RRM_ERROR,"failed to send periodic active "
                                       "ue ind");
                           }
                           RRM_TRACE(g_cellm_log_on_off, 
                                   p_g_rrm_cellm_facility_name, 
                                   RRM_DETAILED,"Periodic change IND send to ANR for" 
                                   "cell index:%d",p_rrm_cell_ctx->cell_index);
                       }
                     }
                 }
           }
       }
       if (p_rrm_cell_ctx->p_son_info->p_es_info != RRM_PNULL)
       {
           p_attribute_info = p_rrm_cell_ctx->p_son_info->p_es_info;
           if(p_attribute_info->p_active_ue != RRM_PNULL)
           {
               if(p_attribute_info->p_active_ue->flag_periodic_active_ue 
                                       == RRM_TRUE)
               {
                   /* send threshold ind to SON */
                    /*BUG:102 start*/
                   if(p_rrm_cell_ctx->cell_stop_not_send_active_ue_count == RRM_FALSE)
                   {    
                    /*BUG:102 end*/
                       ret_val = send_periodic_ue_active_ind(p_rrm_cell_ctx,
                               RRMCM_RMIF_CELL_ACTIVE_UE_COUNT_REPORT_FOR_ES_IND);
                              /*SPR 17777 +-*/
                       if(ret_val == RRM_FAILURE)
                       {
                           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                   RRM_BRIEF,"failed to send periodic active ue ind");
                       }
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                               RRM_DETAILED,"Periodic change IND send to ES for"
                               "cell index:%d",p_rrm_cell_ctx->cell_index);
                   }
               }
            }
        }
    }
    /* UE MEAS CHANGES : ENDS */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* UPDATED NRT INFO CHANGES START */ 
rrm_bool_et rrm_cellm_verify_intra_freq_nrt_info_change(
    rrmcm_rmif_intra_rat_neighbor_cell_t *p_updated_nrt_cell,
    intra_freq_cells_t  *p_new_ncl_cell

)
{
    RRM_UT_TRACE_ENTER();

    /* CSR 81662 : SPR 11861 Fix Start */
    if(RRM_TRUE == p_new_ncl_cell->broadcast_status)
    {
        /* CSR 81662 : SPR 11861 Fix End */
    if(p_new_ncl_cell->phy_cell_id != p_updated_nrt_cell->pci)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "old pci[%d] new pci[%d]", p_new_ncl_cell->phy_cell_id, p_updated_nrt_cell->pci);
        return RRM_TRUE;
    }

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_INTRA_RAT_NR_INFO_OFFSET_PRESENT)
    {
        if(p_new_ncl_cell->q_offset != p_updated_nrt_cell->cell_specific_offset)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "old q_offset[%d] new q_offset[%d]", p_new_ncl_cell->q_offset,
                    p_updated_nrt_cell->cell_specific_offset);
            return RRM_TRUE;
        }
    }
        /* CSR 81662 : SPR 11861 Fix Start */
    }
    /* CSR 81662 : SPR 11861 Fix End */
    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
}
rrm_bool_et rrm_cellm_verify_inter_freq_nrt_info_change
(
    rrmcm_rmif_intra_rat_neighbor_cell_t *p_updated_nrt_cell,
    inter_freq_cells_t       *p_new_ncl_cell
)
{
    RRM_UT_TRACE_ENTER();

    /* CSR 81662 : SPR 11861 Fix Start */
    if(RRM_TRUE == p_new_ncl_cell->broadcast_status)
    {
        /* CSR 81662 : SPR 11861 Fix End */
    if(p_new_ncl_cell->phy_cell_id != p_updated_nrt_cell->pci)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "old pci[%d] new pci[%d]", p_new_ncl_cell->phy_cell_id, p_updated_nrt_cell->pci);
        return RRM_TRUE;
    }

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_INTRA_RAT_NR_INFO_OFFSET_PRESENT)
    {
        /* Coverity 88477-80 Fix Start */
        if(p_new_ncl_cell->q_offset != (rrm_q_offsetrange_et)p_updated_nrt_cell->cell_specific_offset)
       /* Coverity 88477-80 Fix End */
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "old q_offset[%d] new q_offset[%d]", p_new_ncl_cell->q_offset,
                    p_updated_nrt_cell->cell_specific_offset);
            return RRM_TRUE;
        }
    }
        /* CSR 81662 : SPR 11861 Fix Start */
    }
    /* CSR 81662 : SPR 11861 Fix End */

    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
}

/****************************************************************************
 * Function Name  : rrmcm_copy_existing_intra_nbrs_to_updated_list 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context 
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 *                  U8  *bit_mask : To indicate if there is a hange in the 
 *                  intra-freq nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the intra freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist remove list
 ****************************************************************************/
rrm_void_t
rrmcm_copy_existing_intra_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U16                              *bit_mask,
    rrm_bool_et                     *p_reconfig_req
    )
{
    U8          existing_intra_neigh_cnt        = RRM_ZERO;
    U8          remove_intra_neigh_cnt      = RRM_ZERO;
    U8          num_intra_neighs            = RRM_ZERO;
    rrm_bool_et     cell_removed            = RRM_FALSE;
    /* Coverity  55327 fix start*/
    U16          i;
    /* Coverity  55327 fix end*/

    RRM_UT_TRACE_ENTER();

    /* Add existing intra cells from configured ncl list to this list */
    for (existing_intra_neigh_cnt = RRM_ZERO;
        (existing_intra_neigh_cnt < p_cell_context->ran_info.ncl_params.
         lte_ncl.num_valid_intra_freq_cell) && 
        (num_intra_neighs < MAX_INTRA_FREQ_CELLS); ++existing_intra_neigh_cnt)
    {
        cell_removed = RRM_FALSE;
        if(RRM_FALSE == p_cell_context->ran_info.ncl_params.lte_ncl.
                    intra_freq_cells[existing_intra_neigh_cnt].blacklisted)
        {
            /* Check if existing nbr cell is present in the Remove list of Non-Blacklist nbrs */
            for (remove_intra_neigh_cnt = RRM_ZERO;
                    (remove_intra_neigh_cnt < p_updated_nrt_info->intra_rat_ncl.
                     intra_rat_cells_to_remove_list_size) && 
                    (remove_intra_neigh_cnt < RRM_MAX_NO_EARFCN) && !cell_removed;
                    ++remove_intra_neigh_cnt)
            {
                if (p_updated_nrt_info->intra_rat_ncl.
                        intra_rat_cells_to_remove_list[remove_intra_neigh_cnt].earfcn ==
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
                {
                    /*Cov_fix_55327*/
                    for (i = 0; ((i < p_updated_nrt_info->intra_rat_ncl.
                            intra_rat_cells_to_remove_list[remove_intra_neigh_cnt].cell_list_size) && ( i < RRM_MAX_NO_EARFCN)) ; ++i)
                    {
                    /*Cov_fix_55327*/
                        if (!RRM_MEMCMP(&p_updated_nrt_info->intra_rat_ncl.
                                    intra_rat_cells_to_remove_list[remove_intra_neigh_cnt].cell_list[i].cgi,
                                    &p_cell_context->ran_info.ncl_params.lte_ncl.
                                    intra_freq_cells[existing_intra_neigh_cnt].cell_id,
                                    sizeof(rrm_oam_eutran_global_cell_id_t)))
                        {
                            /* This neighbor cell is in removed neighbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            if(RRM_TRUE == p_cell_context->ran_info.ncl_params.lte_ncl.
                                intra_freq_cells[existing_intra_neigh_cnt].broadcast_status)
                            {
                                *p_reconfig_req = RRM_TRUE;
                                *bit_mask |= RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED;
                            }
                            else
                            {
                                *bit_mask |= RRM_INTRA_FREQ_NON_BROADCAST_NBRS_UPDATED;
                            }
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Whitelist Nbr Cell removed for Intra Freq. PCI = %d", p_cell_context->ran_info.
                                ncl_params.lte_ncl.intra_freq_cells[existing_intra_neigh_cnt].phy_cell_id);
                            break;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Nbr cell PCI = %d, not present in remove list",p_cell_context->ran_info.
                                ncl_params.lte_ncl.intra_freq_cells[existing_intra_neigh_cnt].phy_cell_id);
                        }
                    }
                }
            }
        }
        else
        {
            /* Check if existing nbr cell is present in the Remove list of Blacklist nbrs */
            for (remove_intra_neigh_cnt = RRM_ZERO;
                    (remove_intra_neigh_cnt < p_updated_nrt_info->intra_rat_ncl.
                     intra_rat_black_list_cells_to_remove_list_size) && 
                    (remove_intra_neigh_cnt < RRM_MAX_NO_EARFCN) && !cell_removed;
                    ++remove_intra_neigh_cnt)
            {
                if (p_updated_nrt_info->intra_rat_ncl.
                        intra_rat_black_list_cells_to_remove_list[remove_intra_neigh_cnt].earfcn ==
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
                {
    /* Coverity  55327 fix start*/
                    for (i = RRM_ZERO; i < p_updated_nrt_info->intra_rat_ncl.
                            intra_rat_black_list_cells_to_remove_list[remove_intra_neigh_cnt].cell_list_size && (i < RRM_MAX_NO_CELLS_PER_EARFCN); ++i)
                    {
    /* Coverity  55327 fix end*/
                        if (!RRM_MEMCMP(&p_updated_nrt_info->intra_rat_ncl.
                                    intra_rat_black_list_cells_to_remove_list[remove_intra_neigh_cnt].cell_list[i].cgi,
                                    &p_cell_context->ran_info.ncl_params.lte_ncl.
                                    intra_freq_cells[existing_intra_neigh_cnt].cell_id,
                                    sizeof(rrm_oam_eutran_global_cell_id_t)))
                        {
                            /* This neighbor cell is in removed neithbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                             if(RRM_TRUE == p_cell_context->ran_info.ncl_params.lte_ncl.
                                intra_freq_cells[existing_intra_neigh_cnt].broadcast_status)
                            {
                                *p_reconfig_req = RRM_TRUE;
                                *bit_mask |= RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED;
                            }
                            else
                            {
                                *bit_mask |= RRM_INTRA_FREQ_NON_BROADCAST_NBRS_UPDATED;
                            }
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Blacklisted Nbr Cell removed for Intra Freq. PCI = %d", p_cell_context->ran_info.
                                ncl_params.lte_ncl.intra_freq_cells[existing_intra_neigh_cnt].phy_cell_id);
                            break;
                        }
                    }
                }
            }       
        }
        /* If nbr cell is not present in the remove lists */
        if(!cell_removed)
        {
            /* Add the cell in the updated ncl list */
            RRM_MEMCPY(&p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[num_intra_neighs],
                    &p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[existing_intra_neigh_cnt],
                    sizeof(intra_freq_cells_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Existing Nbr Cell copied to Updated Intra-freq NCL. PCI = %d",
                p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.intra_freq_cells[num_intra_neighs].phy_cell_id);
            ++num_intra_neighs;

            /* Fix CSR #15890 : Start */
            *p_reconfig_req = RRM_TRUE;
            *bit_mask |= RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED;
            /* Fix CSR #15890 : End */
        }
    }
    p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell = num_intra_neighs;
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_copy_existing_inter_nbrs_to_updated_list 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context 
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 *                  U8  *bit_mask : To indicate if there is a hange in the 
 *                  inter-freq nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the inter freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist remove list
 ****************************************************************************/
rrm_void_t
rrmcm_copy_existing_inter_nbrs_to_updated_list(
    rrm_cell_context_t    *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t  *p_updated_nrt_info,
    U16                                      *bit_mask,
    rrm_bool_et                     *p_reconfig_req   
    )
{
    U8          existing_inter_neigh_cnt        = RRM_ZERO;
    U8          remove_inter_neigh_cnt      = RRM_ZERO;
    U8          num_inter_neighs            = RRM_ZERO;
    rrm_bool_et     cell_removed            = RRM_FALSE;
    U8          i;

    RRM_UT_TRACE_ENTER();

    for (existing_inter_neigh_cnt = RRM_ZERO;
            (existing_inter_neigh_cnt < p_cell_context->ran_info.ncl_params.
             lte_ncl.num_valid_inter_freq_cell) && (num_inter_neighs < MAX_INTER_FREQ_CELLS);
            ++existing_inter_neigh_cnt)
    {
        /* Add existing inter cells from configured ncl list to this list */
        cell_removed = RRM_FALSE;
        if(RRM_FALSE == p_cell_context->ran_info.ncl_params.lte_ncl.
                inter_freq_cells[existing_inter_neigh_cnt].blacklisted)
        {
            /* Check if existing nbr cell is present in the Remove list of Non-Blacklist nbrs */
            for (remove_inter_neigh_cnt = RRM_ZERO;
                    (remove_inter_neigh_cnt < p_updated_nrt_info->intra_rat_ncl.
                     intra_rat_cells_to_remove_list_size) && (remove_inter_neigh_cnt < RRM_MAX_NO_EARFCN)
                    && !cell_removed; ++remove_inter_neigh_cnt)
            {
                if ((p_updated_nrt_info->intra_rat_ncl.
                        intra_rat_cells_to_remove_list[remove_inter_neigh_cnt].earfcn !=
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn) &&
                        (p_updated_nrt_info->intra_rat_ncl.
                        intra_rat_cells_to_remove_list[remove_inter_neigh_cnt].earfcn ==
                        p_cell_context->ran_info.ncl_params.lte_ncl.
                        inter_freq_cells[existing_inter_neigh_cnt].eutra_carrier_arfcn))
                {
                    /* COVERITY : RESOURCE LEAK : CID : 55327 fix start */
                    for (i = RRM_ZERO; ((i < p_updated_nrt_info->intra_rat_ncl.
                                    intra_rat_cells_to_remove_list[remove_inter_neigh_cnt].cell_list_size) &&
                                ( i < RRM_MAX_NO_EARFCN )); ++i)
                        /* COVERITY : RESOURCE LEAK : CID : 55327 fix end */         
                    {
                        if (!RRM_MEMCMP(&p_updated_nrt_info->intra_rat_ncl.
                                    intra_rat_cells_to_remove_list[remove_inter_neigh_cnt].cell_list[i].cgi,
                                    &p_cell_context->ran_info.ncl_params.lte_ncl.
                                    inter_freq_cells[existing_inter_neigh_cnt].cell_id,
                                    sizeof(rrm_oam_eutran_global_cell_id_t)))
                        {
                            /* This neighbor cell is in removed neithbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            if(RRM_TRUE == p_cell_context->ran_info.ncl_params.lte_ncl.
                                inter_freq_cells[existing_inter_neigh_cnt].broadcast_status)
                            {
                                *p_reconfig_req = RRM_TRUE;
                                *bit_mask |= RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED;
                            }
                            else
                            {
                                *bit_mask |= RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED;
                            }
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Non-Blacklist Nbr Cell removed for Inter Freq = %d, PCI = %d", 
                                p_cell_context->ran_info.ncl_params.lte_ncl.
                                inter_freq_cells[existing_inter_neigh_cnt].eutra_carrier_arfcn,
                                p_cell_context->ran_info.ncl_params.lte_ncl.
                                inter_freq_cells[existing_inter_neigh_cnt].phy_cell_id);
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            /* Check if existing nbr cell is present in the Remove list of Blacklist nbrs */
            for (remove_inter_neigh_cnt = RRM_ZERO;
                    (remove_inter_neigh_cnt < p_updated_nrt_info->intra_rat_ncl.
                     intra_rat_black_list_cells_to_remove_list_size) && (remove_inter_neigh_cnt < RRM_MAX_NO_EARFCN)
                    && !cell_removed; ++remove_inter_neigh_cnt)
            {
                if ((p_updated_nrt_info->intra_rat_ncl.
                        intra_rat_black_list_cells_to_remove_list[remove_inter_neigh_cnt].earfcn !=
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn) &&
                        (p_updated_nrt_info->intra_rat_ncl.
                        intra_rat_black_list_cells_to_remove_list[remove_inter_neigh_cnt].earfcn ==
                        p_cell_context->ran_info.ncl_params.lte_ncl.
                        inter_freq_cells[existing_inter_neigh_cnt].eutra_carrier_arfcn))
                {
                    /*Cov_fix_55327*/
                    for (i = RRM_ZERO; ((i < p_updated_nrt_info->intra_rat_ncl.
                            intra_rat_black_list_cells_to_remove_list[remove_inter_neigh_cnt].cell_list_size) && (i < RRM_MAX_NO_EARFCN)); ++i)
                    /*Cov_fix_55327*/
                    {
                        if (!RRM_MEMCMP(&p_updated_nrt_info->intra_rat_ncl.
                                    intra_rat_black_list_cells_to_remove_list[remove_inter_neigh_cnt].cell_list[i].cgi,
                                    &p_cell_context->ran_info.ncl_params.lte_ncl.
                                    inter_freq_cells[existing_inter_neigh_cnt].cell_id,
                                    sizeof(rrm_oam_eutran_global_cell_id_t)))
                        {
                            /* This neighbor cell is in removed neighbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            if(RRM_TRUE == p_cell_context->ran_info.ncl_params.lte_ncl.
                                inter_freq_cells[existing_inter_neigh_cnt].broadcast_status)
                            {
                                *p_reconfig_req = RRM_TRUE;
                                *bit_mask |= RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED;
                            }
                            else
                            {
                                *bit_mask |= RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED;
                            }
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Blacklisted Nbr Cell removed for Inter Freq = %d, PCI = %d", 
                                p_cell_context->ran_info.ncl_params.lte_ncl.
                                inter_freq_cells[existing_inter_neigh_cnt].eutra_carrier_arfcn,
                                p_cell_context->ran_info.ncl_params.lte_ncl.
                                inter_freq_cells[existing_inter_neigh_cnt].phy_cell_id);
                            break;
                        }
                    }
                }
            }
        }
        /* If nbr cell is not present in the remove lists */
        if (!cell_removed)
        {
            /* Add the cell in the updated ncl list */
            RRM_MEMCPY(&p_cell_context->p_ncl_built_from_updated_nrt_info->
                    lte_ncl.inter_freq_cells[num_inter_neighs],
                    &p_cell_context->ran_info.ncl_params.lte_ncl.
                    inter_freq_cells[existing_inter_neigh_cnt],
                    sizeof(inter_freq_cells_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Existing Nbr cell copied in Updated Inter-freq NCL for Freq = %d, PCI = %d",
                p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.
                inter_freq_cells[num_inter_neighs].eutra_carrier_arfcn,
                p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.
                inter_freq_cells[num_inter_neighs].phy_cell_id);
            ++num_inter_neighs;
            /*SPR_18944_FIX_START*/
               /* code removed */
            /*SPR_18944_FIX_END*/
        }
    }
    p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.
        num_valid_inter_freq_cell = num_inter_neighs;

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_populate_intra_freq_nbr_info
 * Inputs         : intra_freq_cells_t *p_new_ncl_cell : pointer to the nbr
 *                  cell in the new updated NCL
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 * Outputs        : None
 * Returns        : None
 * Description    : this function populates the intra nbr cell info in the new NCL
 *                  from the Updated NRT info recvd from SON
 ****************************************************************************/
rrm_void_t
rrmcm_populate_intra_freq_nbr_info(
    intra_freq_cells_t                      *p_new_ncl_cell,
    rrmcm_rmif_intra_rat_neighbor_cell_t    *p_updated_nrt_cell    
)
{
    RRM_UT_TRACE_ENTER();

    p_new_ncl_cell->phy_cell_id = p_updated_nrt_cell->pci;

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_INTRA_RAT_NR_INFO_OFFSET_PRESENT)
    {
        /*Cov 21757 +*/
        /* Coverity_fix_96484_start */
        p_new_ncl_cell->q_offset = (rrm_q_offsetrange_et)p_updated_nrt_cell->cell_specific_offset;
        /* Coverity_fix_96484_end */
        /*Cov 21757 -*/
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_CM_OFFSET_PRESENT)
    {
        p_new_ncl_cell->bitmask |=
            RRMCM_RMIF_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
        /* coverity : CID 21756*/
        /*Cov 88503 +*/
        p_new_ncl_cell->cio = (rrm_q_offsetrange_et) p_updated_nrt_cell->cm_cell_specific_offset;
        /*Cov 88503 -*/
    }

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_INTRA_RAT_NR_INFO_X2_STATUS_PRESENT)
    {
        p_new_ncl_cell->x2_status = p_updated_nrt_cell->x2_status;
    }
    else
    {
        p_new_ncl_cell->x2_status = X2_UNDEFINED;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_ACCESS_MODE_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT;
        p_new_ncl_cell->cell_access_mode = p_updated_nrt_cell->access_mode;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_TAC_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTRA_FREQ_TAC_PRESENT;
        RRM_MEMCPY(p_new_ncl_cell->tac, p_updated_nrt_cell->tac, sizeof(p_updated_nrt_cell->tac));
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_BROADCAST_STATUS)
    {
        p_new_ncl_cell->broadcast_status = p_updated_nrt_cell->broadcast_status;
    }
    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_CSG_IDENTITY)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT;
        RRM_MEMCPY(&p_new_ncl_cell->csg_identity, &p_updated_nrt_cell->csg_identity,
            sizeof(U8) * RRM_OAM_MAX_NUM_CSG_OCTETS);
    }
    /*SPR 14209 start*/
    p_new_ncl_cell->interference_scheme = p_updated_nrt_cell->interference_scheme;
    /*SPR 14209 end*/

#ifdef LTE_EMBMS_SUPPORTED
    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_MBSFN_INFO_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTRA_MBSFN_CONFIG_LIST_PRESENT;
        RRM_MEMCPY(&p_new_ncl_cell->mbsfn_subframe_config_list, 
            &p_updated_nrt_cell->mbsfn_config_info,
            sizeof(rrmcm_mbsfn_subframe_config_list_t));
    }

    /*SPR 18605:Fix Start*/
     if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_TDD_SF_ASSN_INFO_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTRA_SF_ASSN_INFO_PRESENT;
        p_new_ncl_cell->subframe_assn = p_updated_nrt_cell->subframe_assn;
    }
    /*SPR 18605:Fix End*/

#endif

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "new nbr broadcast status = %d", p_new_ncl_cell->broadcast_status);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_populate_inter_freq_nbr_info
 * Inputs         : inter_freq_cells_t *p_new_ncl_cell : pointer to the nbr
 *                  cell in the new updated NCL
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 * Outputs        : None
 * Returns        : None
 * Description    : This function populates the inter nbr cell info in the new NCL
 *                  from the Updated NRT info recvd from SON
 ****************************************************************************/
rrm_void_t
rrmcm_populate_inter_freq_nbr_info(
    inter_freq_cells_t                      *p_new_ncl_cell,
    rrmcm_rmif_intra_rat_neighbor_cell_t    *p_updated_nrt_cell    
)
{
    RRM_UT_TRACE_ENTER();

    p_new_ncl_cell->phy_cell_id = p_updated_nrt_cell->pci;

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_INTRA_RAT_NR_INFO_OFFSET_PRESENT)
    {
        /*Cov 88504 +*/
        p_new_ncl_cell->q_offset = (rrm_q_offsetrange_et)p_updated_nrt_cell->cell_specific_offset;
        /*Cov 88504 -*/
    }
    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_CM_OFFSET_PRESENT)
    {
        p_new_ncl_cell->bitmask |=
            RRMCM_RMIF_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
        /*Cov 88560 +*/
        p_new_ncl_cell->cio = (rrm_q_offsetrange_et)p_updated_nrt_cell->cm_cell_specific_offset;
        /*Cov 88560 -*/
    }

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_INTRA_RAT_NR_INFO_X2_STATUS_PRESENT)
    {
        p_new_ncl_cell->x2_status = p_updated_nrt_cell->x2_status;
    }
    else
    {
        p_new_ncl_cell->x2_status = X2_UNDEFINED;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_ACCESS_MODE_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT;
        p_new_ncl_cell->cell_access_mode = p_updated_nrt_cell->access_mode;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_TAC_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTER_FREQ_TAC_PRESENT;
        RRM_MEMCPY(p_new_ncl_cell->tac, p_updated_nrt_cell->tac, sizeof(p_updated_nrt_cell->tac));
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_BROADCAST_STATUS)
    {
        p_new_ncl_cell->broadcast_status = p_updated_nrt_cell->broadcast_status;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_NR_INFO_CSG_IDENTITY)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_CSG_ID_PRESENT;
        RRM_MEMCPY(&p_new_ncl_cell->csg_identity, &p_updated_nrt_cell->csg_identity,
            sizeof(U8) * RRM_OAM_MAX_NUM_CSG_OCTETS);
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "new nbr broadcast status = %d", p_new_ncl_cell->broadcast_status);
    #ifdef LTE_EMBMS_SUPPORTED
    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_RAT_MBSFN_INFO_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTER_MBSFN_CONFIG_LIST_PRESENT;
        RRM_MEMCPY(&p_new_ncl_cell->mbsfn_subframe_config_list, 
            &p_updated_nrt_cell->mbsfn_config_info,
            sizeof(rrmcm_mbsfn_subframe_config_list_t));
    }

    /*SPR 18605:Fix Start*/
     if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_INTRA_TDD_SF_ASSN_INFO_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRMCM_RMIF_INTER_SF_ASSN_INFO_PRESENT;
        p_new_ncl_cell->subframe_assn = p_updated_nrt_cell->subframe_assn;
    }
    /*SPR 18605:Fix End*/

    #endif

    RRM_UT_TRACE_EXIT();
}
 

/****************************************************************************
 * Function Name  : rrm_compare_intra_rat_cell_id_for_daho
 * Inputs         : rrmcm_rmif_intra_rat_neighbor_list_t *p_updated_nrt_cgi : Updated NRT
 *                : rrm_cell_context_t *p_cell_context  : cell context
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE
 * Description    : This function compares the existing nbrs of the utra freq
 *                : with those recvd in Updated NRT Info for Daho cell.
 ****************************************************************************/

rrm_bool_et
rrm_compare_intra_rat_cell_id_for_daho(
        rrm_oam_eutran_global_cell_id_t    *p_updated_nrt_cgi,
        rrm_cell_context_t  *p_cell_ctx
        )
{
      rrm_bool_et  ret_val = RRM_FALSE;
      RRM_UT_TRACE_ENTER();
      if ((!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.eutran_daho_cell_config_info.cell_identity),
                     &(p_updated_nrt_cgi->cell_identity), sizeof(U8)*MAX_CELL_IDENTITY_OCTETS))
            &&
            (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.eutran_daho_cell_config_info.plmn_id.mcc),
                         &(p_updated_nrt_cgi->primary_plmn_id.mcc), sizeof(U8) * MAX_MCC_DIGITS))
            &&
            (p_cell_ctx->operator_info.daho_cell_config_info.eutran_daho_cell_config_info.plmn_id.num_mnc_digit ==
             p_updated_nrt_cgi->primary_plmn_id.num_mnc_digit)
            &&
            (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.eutran_daho_cell_config_info.plmn_id.mnc),
                         &(p_updated_nrt_cgi->primary_plmn_id.mnc), sizeof(U8) * MAX_MNC_DIGITS)))
    {
        ret_val = RRM_TRUE;
    }
    else
    {

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "CELL_ID %s is not a DAHO cell",
                p_cell_ctx->operator_info.daho_cell_config_info.eutran_daho_cell_config_info.cell_identity);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_compare_inter_freq_cell_id_for_daho
 * Inputs         : rrmcm_rmif_inter_freq_neighbor_list_t *p_updated_nrt_cgi : Updated NRT
 *                : rrm_cell_context_t *p_cell_context  : cell context
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE
 * Description    : This function compares the existing nbrs of the inter freq
 *                : with those recvd in Updated NRT Info for Daho cell.
 ****************************************************************************/
/* SPR 10498 Fix Start */
rrm_bool_et
rrm_compare_inter_freq_cell_id_for_daho(
        rrm_oam_eutran_global_cell_id_t    *p_updated_nrt_cgi,
        rrm_cell_context_t  *p_cell_ctx
        )
{
    rrm_bool_et  ret_val = RRM_FALSE;
    U8            index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(p_cell_ctx->operator_info.daho_cell_config_info.bitmask & EUTRA_INTER_FREQ_DAHO_CELL_PRESENT)
    {
        for(index = RRM_ZERO;
                (index < p_cell_ctx->operator_info.daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.count)
                && (index < MAX_NO_INTER_FREQ); index++)
        {
            if ((!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                                rrm_eutran_inter_freq_daho_cell_config_info[index].cell_id.cell_identity),
                            &(p_updated_nrt_cgi->cell_identity), sizeof(U8)*MAX_CELL_IDENTITY_OCTETS))
                    &&
                    (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                                   rrm_eutran_inter_freq_daho_cell_config_info[index].cell_id.primary_plmn_id.mcc),
                                 &(p_updated_nrt_cgi->primary_plmn_id.mcc), sizeof(U8) * MAX_MCC_DIGITS))
                    &&
                    (p_cell_ctx->operator_info.daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                     rrm_eutran_inter_freq_daho_cell_config_info[index].cell_id.primary_plmn_id.num_mnc_digit ==
                     p_updated_nrt_cgi->primary_plmn_id.num_mnc_digit)
                    &&
                    (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                                   rrm_eutran_inter_freq_daho_cell_config_info[index].cell_id.primary_plmn_id.mnc),
                                 &(p_updated_nrt_cgi->primary_plmn_id.mnc), sizeof(U8) * MAX_MNC_DIGITS)))
            {
                ret_val = RRM_TRUE;
            }
        }
    }

    if(RRM_FALSE == ret_val)
    {
        /* Klocwork_fix_27_aug_start */
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "CELL_ID is not a DAHO cell");
        /* Klocwork_fix_27_aug_end */
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* SPR 10498 Fix End */


/* CSR 81662 : SPR 11861 Fix Start */
/****************************************************************************
 * Function Name  : rrmcm_check_broadcast_status_intra_freq_pci 
 * Inputs         : nbr_cell_to_be_added - inter-freq nbr to be added
 *                  p_new_ncl - pointer to the already built NCL 
 * Outputs        : None
 * Returns        : TRUE/FALSE
 * Description    : This function searches the PCI of the inter-freq nbr to be
 *                  added in NCL in the existing list copied to new NCL.
 *                  If not found, this nbr needs to be broadcast else not.
 ****************************************************************************/
static rrm_bool_et
rrmcm_check_broadcast_status_intra_freq_pci(
     /*COV_2NOV_START*/
    rrmcm_rmif_intra_rat_neighbor_cell_t    *p_nbr_cell_to_be_added, 
     /*COV_2NOV_STOP*/
    lte_ncl_t                               *p_new_ncl
)
{
    U8          index              = RRM_ZERO;
    rrm_bool_et nbr_needs_broadcast = RRM_TRUE;
    RRM_UT_TRACE_ENTER();

     /*COV_2NOV_START*/
    if(RRM_TRUE == p_nbr_cell_to_be_added->broadcast_status)
    {/*COV_2NOV_STOP*/
        for(index = RRM_ZERO; index < p_new_ncl->num_valid_intra_freq_cell; index++)
        {
            /* If Intra cell to be added in ncl has same pci to the already added Intra ncl, then do 
               not broadcast the cell in SIB-4 */
                        /*COV_2NOV_START*/
            if((p_nbr_cell_to_be_added->pci == p_new_ncl->intra_freq_cells[index].phy_cell_id) &&
                        /*COV_2NOV_STOP*/
                    (p_new_ncl->intra_freq_cells[index].broadcast_status == RRM_TRUE))
            {
                nbr_needs_broadcast = RRM_FALSE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "PCI = %d is present in the new NCL at index = %d to be broadcast in SIB 4",
                        /*COV_2NOV_START*/
                        p_nbr_cell_to_be_added->pci, index);
                      /*COV_2NOV_STOP*/
                break;
            }
        }
    }
    else
    {
        nbr_needs_broadcast = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return nbr_needs_broadcast;
}
/* CSR 81662 : SPR 11861 Fix End */

/* Bug_12689_fix: Start */
/****************************************************************************
 * Function Name  : rrm_check_if_pci_conflict_ncl_present 
 * Inputs         : p_updated_nrt_intra_rat_cell, p_new_ncl, p_reconfig_req
 * Outputs        : None
 * Returns        : None 
 * Description    : This function finds if any ncl neighbour has conflicting 
 *                  PCI issue with serving cell then mark that cell.
 ****************************************************************************/
rrm_return_et
rrm_check_if_pci_conflict_ncl_present(
   rrm_cell_context_t                   *p_cell_context,
   rrmcm_rmif_intra_rat_neighbor_list_t *p_updated_nrt_intra_rat_cell, 
   lte_ncl_t                            *p_new_ncl,     
   rrm_bool_et                          *p_reconfig_req
 )
{
    rrm_bool_et  allow_reconfig = RRM_FALSE;
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 updated_nrt_count = RRM_ZERO;
    U8 intra_lte_ncl_cnt = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(p_updated_nrt_intra_rat_cell->cell_list_size > RRM_ZERO)
    {
        for(updated_nrt_count = RRM_ZERO;
            updated_nrt_count < p_updated_nrt_intra_rat_cell->cell_list_size;
            updated_nrt_count++)
        {
            if(p_cell_context->ran_info.rf_params.rf_configurations.phy_cell_id == 
                        p_updated_nrt_intra_rat_cell->cell_list[updated_nrt_count].pci)
            {
                for(intra_lte_ncl_cnt = RRM_ZERO;
                    intra_lte_ncl_cnt < p_new_ncl->num_valid_intra_freq_cell;
                    intra_lte_ncl_cnt++)
                {
                    if(p_cell_context->ran_info.rf_params.rf_configurations.phy_cell_id == 
                            p_new_ncl->intra_freq_cells[intra_lte_ncl_cnt].phy_cell_id)
                    {
                        p_new_ncl->intra_freq_cells[intra_lte_ncl_cnt].is_pci_conflict = RRM_TRUE;
                    }
                }
            }
            else
            {
                /* In case more than one cell are added through updated_nrt_info then 
                that cell should be broadcasted in SIB-4*/
                allow_reconfig = RRM_TRUE;
            }
        }
    }

    if(RRM_TRUE == allow_reconfig)
    {
        *p_reconfig_req = RRM_TRUE;
    }
    else
    {
        *p_reconfig_req = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Bug_12689_fix: End */

/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrmcm_add_intra_freq_nbrs_to_updated_list
 * Inputs         : p_update_index, p_new_ncl , p_updated_nrt_intra_rat_cell , p_reconfig_req
 * Outputs        : None
 * Returns        : None 
 * Description    : This function searches the inter-freq nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_intra_freq_nbrs_to_updated_list(U8                                      i,
                                          U8                                      *num_intra_neighs,
                                          /* SPR 12522 Start */
                                          U8                                      *p_update_index, 
                                          /* SPR 12522 End */
                                          lte_ncl_t                               *p_new_ncl,     
                                          rrmcm_rmif_intra_rat_neighbor_list_t    *p_updated_nrt_intra_rat_cell,
                                          rrm_bool_et                             *p_reconfig_req)

{
    rrm_return_et     ret_val                 = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    /* SPR 12522 Start */
    if(RRM_INVALID_RETURN == *p_update_index)
    /* SPR 12522 End */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Intra-freq Nbr cell to be added");

        /*Coverity_fix_end_62524*/ 
        /* Addition case */
        if((*num_intra_neighs) < MAX_INTRA_FREQ_CELLS)
        {
            /* CSR 81662 : SPR 11861 Fix Start */
            /* If PCI is already present in NCL, broadcast should not be done
               on the basis of addition of this nbr cell */
            if(RRM_TRUE == rrmcm_check_broadcast_status_intra_freq_pci(
     			/*COV_2NOV_START*/
                        &p_updated_nrt_intra_rat_cell->cell_list[i],  p_new_ncl))
            {          /*COV_2NOV_STOP*/
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "PCI = %d was not broadcast earlier",
                        p_updated_nrt_intra_rat_cell->cell_list[i].pci);
                *p_reconfig_req = RRM_TRUE;
            }
            /* CSR 81662 : SPR 11861 Fix End */

            /* SPR 12522 Start */
            *p_update_index = (*num_intra_neighs); 
            p_new_ncl->intra_freq_cells[*p_update_index].bitmask |=
                RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT;

            RRM_MEMCPY(&p_new_ncl->intra_freq_cells[*p_update_index].cell_id,
                    &p_updated_nrt_intra_rat_cell->cell_list[i].cgi,
                    sizeof(rrm_oam_eutran_global_cell_id_t));
            /* Bug 896 : Start */
            p_new_ncl->intra_freq_cells[*p_update_index].ho_status = HO_ALLOWED;
            /* SPR 12522 End */
            /* Bug 896 : End */
            (*num_intra_neighs)++;
            /* CSR 81662 : SPR 11861 Fix Delete */
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR, "Max list size reached. cannot add"); 
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrmcm_add_mod_intra_freq_nbrs_to_updated_list 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context 
 *                  rrmcm_rmif_intra_rat_neighbor_list_t 
 *                      *p_updated_nrt_intra_rat_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_intra_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  freq nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the inter-freq nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification. 
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_mod_intra_freq_nbrs_to_updated_list(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_intra_rat_neighbor_list_t    *p_updated_nrt_intra_rat_cell,
    U8                                      existing_intra_nbrs_cnt,
    U16                                      *bit_mask,
    rrm_bool_et                             *p_reconfig_req
    )
{
    U8              num_intra_neighs        = RRM_ZERO;
    U8              update_index            = RRM_INVALID_RETURN;
    U8              existing_index          = RRM_ZERO;
    lte_ncl_t       *p_new_ncl              = RRM_PNULL;
    rrm_return_et     ret_val                 = RRM_SUCCESS;
    U8 i;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl;

    num_intra_neighs = p_cell_context->p_ncl_built_from_updated_nrt_info->
        lte_ncl.num_valid_intra_freq_cell;

    /* build add/mod intra-ncl from updated nrt info message from SON */
    for (i = RRM_ZERO; i < p_updated_nrt_intra_rat_cell->cell_list_size; ++i)
    {
        /* 9513 */
        if (RRM_TRUE !=   rrm_compare_intra_rat_cell_id_for_daho(&p_updated_nrt_intra_rat_cell->cell_list[i].cgi,p_cell_context))
        {
            /* CSR 81662 : SPR 11861 Fix Start */
            update_index = RRM_INVALID_RETURN;
            /* CSR 81662 : SPR 11861 Fix End */

            /*Coverity_fix_start_62524*/
            for(existing_index = RRM_ZERO; existing_index < existing_intra_nbrs_cnt;
                    existing_index++)
            {
                if(RRM_FALSE == p_new_ncl->intra_freq_cells[existing_index].blacklisted)
                {
                    if(!RRM_MEMCMP(&p_updated_nrt_intra_rat_cell->cell_list[i].cgi, 
                                &p_new_ncl->intra_freq_cells[existing_index].cell_id,
                                sizeof(rrm_oam_eutran_global_cell_id_t)))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Intra-freq Nbr cell to be modified");
                        /* Modification case */
                        update_index = existing_index;
                        /* CSR 81662 : SPR 11861 Fix Start */
                        if(RRM_TRUE == rrm_cellm_verify_intra_freq_nrt_info_change(&p_updated_nrt_intra_rat_cell->cell_list[i],
                                    &p_new_ncl->intra_freq_cells[existing_index]))
                        {
                            *p_reconfig_req = RRM_TRUE;
                        }
                        /* CSR 81662 : SPR 11861 Fix End */
                        break;
                    }
                }
            }
            /*Klockwork_fix_start*/
            /* SPR 12522 Start */
            ret_val = rrmcm_add_intra_freq_nbrs_to_updated_list(i,&num_intra_neighs, &update_index, 
                    p_new_ncl, p_updated_nrt_intra_rat_cell , p_reconfig_req); 
            /* SPR 12522 End */

            /*Klockwork_fix_end*/
            if(RRM_SUCCESS == ret_val)
            {
                rrmcm_populate_intra_freq_nbr_info(
                        &p_new_ncl->intra_freq_cells[update_index],
                        &p_updated_nrt_intra_rat_cell->cell_list[i]);

                /*SPR 14215 start*/
                if(((p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_status == X2_ALLOWED_DISCONNECTED) ||
                    (p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_status == X2_PROHIBITED_DISCONNECTED))&&
                              ((p_updated_nrt_intra_rat_cell->cell_list[i].x2_status == X2_ALLOWED_CONNECTED) ||
                               (p_updated_nrt_intra_rat_cell->cell_list[i].x2_status == X2_PROHIBITED_CONNECTED)))
                 {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "TEST: need to reset ABS pattern OLD [%d],NEW [%d]", p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_status,p_updated_nrt_intra_rat_cell->cell_list[i].x2_status );
                   *bit_mask |= RRM_INTRA_FREQ_X2_STATUS_UPDATED; 
                 }  

                if(((p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_status == X2_ALLOWED_CONNECTED) ||
                      (p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_status == X2_PROHIBITED_CONNECTED))&&
                      ((p_updated_nrt_intra_rat_cell->cell_list[i].x2_status == X2_ALLOWED_DISCONNECTED) ||
                       (p_updated_nrt_intra_rat_cell->cell_list[i].x2_status == X2_PROHIBITED_DISCONNECTED)))
                 {
                    *bit_mask |= RRM_INTRA_FREQ_X2_STATUS_UPDATED;
                    *bit_mask |=  RRM_INTRA_FREQ_X2_NOT_UP; 
                     p_cell_context->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_RECONFIG_X2_LINK_DOWN_RECONFIG;
                     RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                   " x2 was up and now x2 is down ");
                 }    
                     
                /*SPR 14215 end*/

                if(RRM_TRUE == p_updated_nrt_intra_rat_cell->cell_list[i].broadcast_status)
                {
                    *bit_mask |= RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED;
                }
                else
                {
                    *bit_mask |= RRM_INTRA_FREQ_NON_BROADCAST_NBRS_UPDATED;
                }
            }
        }
        else
        {


            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "LTE IntraFreq NBR cell id matched with DAHO cell id");
        }
    }

    /* Bug_12689_fix: Start */
    rrm_check_if_pci_conflict_ncl_present(p_cell_context,
            p_updated_nrt_intra_rat_cell, 
            p_new_ncl, 
            p_reconfig_req);
    /* Bug_12689_fix: End */

    p_new_ncl->num_valid_intra_freq_cell = num_intra_neighs;

    RRM_UT_TRACE_EXIT();

    return ret_val;
    /* Coverity 62524 fix end */
}

/* SPR 13182 Fix Start */
/****************************************************************************
 * Function Name  : rrmcm_check_broadcast_status_inter_freq_pci
 * Inputs         : nbr_cell_to_be_added - inter-freq nbr to be added
 *                  p_new_ncl - pointer to the already built NCL
 * Outputs        : None
 * Returns        : TRUE/FALSE
 * Description    : This function searches the PCI of the inter-freq nbr to be
 *                  added in NCL in the existing list copied to new NCL.
 *                  If not found, this nbr needs to be broadcast else not.
 ****************************************************************************/
static rrm_bool_et
rrmcm_check_broadcast_status_inter_freq_pci(
    /*COV_2NOV_START*/
    rrmcm_rmif_intra_rat_neighbor_cell_t    *p_nbr_cell_to_be_added,
    /*COV_2NOV_STOP*/
    lte_ncl_t                               *p_new_ncl,
    U16                                     earfcn
)
{
    U8          index               = RRM_ZERO;
    rrm_bool_et nbr_needs_broadcast = RRM_TRUE;

    RRM_UT_TRACE_ENTER();

    /*COV_2NOV_START*/
    if(RRM_TRUE == p_nbr_cell_to_be_added->broadcast_status)
    /*COV_2NOV_STOP*/
    {
        for(index = RRM_ZERO; index < p_new_ncl->num_valid_inter_freq_cell; index++)
        {
            /*COV_2NOV_START*/
            if((p_nbr_cell_to_be_added->pci == p_new_ncl->inter_freq_cells[index].phy_cell_id) &&
            /*COV_2NOV_STOP*/
                (earfcn == p_new_ncl->inter_freq_cells[index].eutra_carrier_arfcn) &&
                    (p_new_ncl->inter_freq_cells[index].broadcast_status == RRM_TRUE))
            {
                nbr_needs_broadcast = RRM_FALSE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Earfcn = %d PCI = %d is present in the new NCL at index = %d to be broadcast in SIB 5",
                        /*COV_2NOV_START*/
                        earfcn, p_nbr_cell_to_be_added->pci, index);
                        /*COV_2NOV_STOP*/
                break;
            }
        }
    }
    else
    {
        nbr_needs_broadcast = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return nbr_needs_broadcast;
}
/* SPR 13182 Fix End */

/*klock_works_changes_starts*/
/****************************************************************************
 * Function Name  : check_for_invalid_updated_index
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_intra_rat_neighbor_list_t
 *                      *p_updated_nrt_intra_rat_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_inter_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the inter-
 *                  freq nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the inter-freq nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/

rrm_return_et
rrm_check_for_invalid_updated_index
(
 rrm_cell_context_t                      *p_cell_context,
 /* SPR 12483 Start */
 U8                                      *p_num_inter_neighs,
 /* SPR 12483 End */
 U8                                      *update_index,
 rrmcm_rmif_intra_rat_neighbor_list_t    *p_updated_nrt_intra_rat_cell,
 lte_ncl_t                               *p_new_ncl,
 rrm_bool_et                             *p_reconfig_req,
 rrm_bool_et                             blacklist_status,
 U8                                      i
 )

{
    /* SPR 12483 Delete */
    rrm_return_et     ret_val                     = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* SPR 12483 Delete */

    if(RRM_INVALID_RETURN == *update_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Inter-freq Nbr cell to be added");

        /* Addition case */
        /* SPR 12483 Start */
        if(*p_num_inter_neighs < MAX_INTRA_FREQ_CELLS)
        /* SPR 12483 End */
        {
            S16 freq_index = rrmcm_search_earfcn_in_cell_context(p_cell_context,
                    p_updated_nrt_intra_rat_cell->earfcn);
            if (FREQ_NOT_CONFIGURED != freq_index)
            {
                /* SPR 13182 Fix Start */
                /* If PCI is already present in NCL, broadcast should not be done
                   on the basis of addition of this nbr cell */
                if(RRM_TRUE == rrmcm_check_broadcast_status_inter_freq_pci(
                            /*COV_2NOV_START*/
                            &p_updated_nrt_intra_rat_cell->cell_list[i],  
                            /*COV_2NOV_STOP*/
                            p_new_ncl,
                            p_updated_nrt_intra_rat_cell->earfcn))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            "PCI = %d was not broadcast earlier in SIB 5",
                            p_updated_nrt_intra_rat_cell->cell_list[i].pci);
                    *p_reconfig_req = RRM_TRUE;
                }
                /* SPR 13182 Fix End */

                /* SPR 12483 Start */
                *update_index = *p_num_inter_neighs;
                /* SPR 12483 End */
                p_new_ncl->inter_freq_cells[*update_index].bitmask |=
                    RRMCM_RMIF_INTER_FREQ_GLOBAL_CELL_ID_PRESENT;
                RRM_MEMCPY(&p_new_ncl->inter_freq_cells[*update_index].cell_id,
                        &p_updated_nrt_intra_rat_cell->cell_list[i].cgi,
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                p_new_ncl->inter_freq_cells[*update_index].blacklisted = blacklist_status;
                if(RRM_TRUE == blacklist_status)
                {
                    /* Bug 896 : Start */
                    p_new_ncl->inter_freq_cells[*update_index].ho_status = HO_PROHIBITED;
                    /* Bug 896 : End */
                }
                else
                {
                    /* Bug 896 : Start */
                    p_new_ncl->inter_freq_cells[*update_index].ho_status = HO_ALLOWED;
                    /* Bug 896 : End */
                }
                
                /* SPR 13182 Fix Start */
                /* Code deleted*/
                /* SPR 13182 Fix End */

                /* SPR 12483 Start */
                (*p_num_inter_neighs)++;
                /* SPR 12483 End */
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR, "Freq NOT configured. Invalid nbr");
            }
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off,
                    p_g_rrm_cellm_facility_name,
                    RRM_ERROR, "Max list size reached. cannot add");
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/

/****************************************************************************
 * Function Name  : rrmcm_add_mod_inter_freq_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_intra_rat_neighbor_list_t
 *                      *p_updated_nrt_intra_rat_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_inter_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the inter-
 *                  freq nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the inter-freq nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_mod_inter_freq_nbrs_to_updated_list(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_intra_rat_neighbor_list_t    *p_updated_nrt_intra_rat_cell,
    U8                                      existing_inter_nbrs_cnt,
    U16                                      *bit_mask,
    rrm_bool_et                             blacklist_status,
    rrm_bool_et                             *p_reconfig_req
    )
{
    U8              num_inter_neighs            = RRM_ZERO;
    U8              update_index                = RRM_INVALID_RETURN;
    U8              existing_index              = RRM_ZERO;
    lte_ncl_t       *p_new_ncl                  = RRM_PNULL;
    rrm_return_et     ret_val                     = RRM_SUCCESS;
    U8 i;
    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl;

    num_inter_neighs = p_new_ncl->num_valid_inter_freq_cell;

    /* build add/mod inter-ncl from updated nrt info message from SON */
    for (i = RRM_ZERO; i < p_updated_nrt_intra_rat_cell->cell_list_size; ++i)
    {
        /* SPR 10498 Fix Start */
       if (RRM_TRUE !=   rrm_compare_inter_freq_cell_id_for_daho(&p_updated_nrt_intra_rat_cell->cell_list[i].cgi,p_cell_context))
       {
       /* SPR 10498 Fix Start */
        /* CSR 81662 : SPR 11861 Fix Start */
        update_index = RRM_INVALID_RETURN;
        /* CSR 81662 : SPR 11861 Fix End */
        for(existing_index = RRM_ZERO; existing_index < existing_inter_nbrs_cnt;
                existing_index++)
        {
            if((S32)blacklist_status == p_new_ncl->inter_freq_cells[existing_index].blacklisted)
            {
                if(!RRM_MEMCMP(&p_updated_nrt_intra_rat_cell->cell_list[i].cgi, 
                            &p_new_ncl->inter_freq_cells[existing_index].cell_id,
                            sizeof(rrm_oam_eutran_global_cell_id_t)))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Inter-freq Nbr cell to be modified");
                    /* Modification case */
                    update_index = existing_index;
                    /* CSR 81662 : SPR 11861 Fix Start */
                    if(RRM_TRUE == rrm_cellm_verify_inter_freq_nrt_info_change(&(p_updated_nrt_intra_rat_cell->cell_list[i]),
                                &(p_new_ncl->inter_freq_cells[existing_index])))
                    {
                        *p_reconfig_req = RRM_TRUE;
                    }
                    /* CSR 81662 : SPR 11861 Fix End */
                    break;
                }
            }
        }
        
        /*klock_works_changes_start*/
        /* SPR 12483 Start */
        ret_val = rrm_check_for_invalid_updated_index(p_cell_context, &num_inter_neighs, 
            &update_index, p_updated_nrt_intra_rat_cell, p_new_ncl, p_reconfig_req, blacklist_status,i);
        /* SPR 12483 End */
        /*klock_works_changes_end*/

        if(RRM_SUCCESS == ret_val)
        {
            /* SPR 12483 Delete */
            rrmcm_populate_inter_freq_nbr_info(
                    &p_new_ncl->inter_freq_cells[update_index],
                    &p_updated_nrt_intra_rat_cell->cell_list[i]);

            p_new_ncl->inter_freq_cells[update_index].eutra_carrier_arfcn =
                p_updated_nrt_intra_rat_cell->earfcn;

            if(RRM_TRUE == p_updated_nrt_intra_rat_cell->cell_list[i].broadcast_status)
            {
                *bit_mask |= RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED;
            }
            else
            {
                *bit_mask |= RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED;
            }
        }
     /* SPR 10498 Fix Start */
     }
     else
     {
         RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                 "LTE InterFreq(%d) NBR cell id matched with DAHO cell id. PCI = %d",
                 p_updated_nrt_intra_rat_cell->earfcn,
                 p_updated_nrt_intra_rat_cell->cell_list[i].pci);
     }
     /* SPR 10498 Fix End */
    }

    p_new_ncl->num_valid_inter_freq_cell = num_inter_neighs;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
    
/****************************************************************************
 * Function Name  : rrmcm_add_mod_intra_rat_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t 
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function identifies the intra & inter-freq nbr rcvd 
 *                  in Updated NRT and calls the respective handlers
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_intra_rat_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U16                              *bit_mask,
    rrm_bool_et                     *p_reconfig_req
    )
{
    U8          add_mod_intra_neigh_cnt     = RRM_ZERO;
    U8          existing_intra_nbrs_cnt     = RRM_ZERO;
    U8          existing_inter_nbrs_cnt     = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    existing_intra_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
        lte_ncl.num_valid_intra_freq_cell;
    existing_inter_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
        lte_ncl.num_valid_inter_freq_cell;

    for (add_mod_intra_neigh_cnt = RRM_ZERO;
            (add_mod_intra_neigh_cnt < p_updated_nrt_info->intra_rat_ncl.
             intra_rat_cells_to_add_mod_list_size) && 
            (add_mod_intra_neigh_cnt < RRM_MAX_NO_EARFCN); ++add_mod_intra_neigh_cnt)
    {
        if (p_updated_nrt_info->intra_rat_ncl.
                intra_rat_cells_to_add_mod_list[add_mod_intra_neigh_cnt].earfcn ==
                p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
        {
            rrmcm_add_mod_intra_freq_nbrs_to_updated_list(p_cell_context, 
                    &p_updated_nrt_info->intra_rat_ncl.
                    intra_rat_cells_to_add_mod_list[add_mod_intra_neigh_cnt], 
                    existing_intra_nbrs_cnt, bit_mask, p_reconfig_req);
        }
        else
        {
            rrmcm_add_mod_inter_freq_nbrs_to_updated_list(p_cell_context, 
                    &p_updated_nrt_info->intra_rat_ncl.
                    intra_rat_cells_to_add_mod_list[add_mod_intra_neigh_cnt],
                    existing_inter_nbrs_cnt, bit_mask, RRM_FALSE, p_reconfig_req);
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_add_mod_intra_freq_bl_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_intra_rat_neighbor_list_t
 *                      *p_updated_nrt_intra_rat_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_inter_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the inter-
 *                  freq nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the intra-freq blacklisted nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_intra_freq_bl_nbrs_to_updated_list(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_intra_rat_neighbor_list_t    *p_updated_nrt_intra_rat_bl_cell,
    U8                                      existing_intra_nbrs_cnt,
    U16                                      *bit_mask,
    rrm_bool_et                             *p_reconfig_req
    )
{
    U8              num_intra_neighs        = RRM_ZERO;
    U8              update_index            = RRM_INVALID_RETURN;
    U8              existing_index          = RRM_ZERO;
    lte_ncl_t       *p_new_ncl              = RRM_PNULL;
    rrm_return_et     ret_val                 = RRM_SUCCESS;
    U8 i;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl;

    num_intra_neighs = p_cell_context->p_ncl_built_from_updated_nrt_info->
        lte_ncl.num_valid_intra_freq_cell;

    /* build add/mod intra-ncl from updated nrt info message from SON */
    for (i = RRM_ZERO; i < p_updated_nrt_intra_rat_bl_cell->cell_list_size; ++i)
    {
        /* CSR 81662 : SPR 11861 Fix Start */
        update_index = RRM_INVALID_RETURN;
        /* CSR 81662 : SPR 11861 Fix End */
        for(existing_index = RRM_ZERO; existing_index < existing_intra_nbrs_cnt;
                existing_index++)
        {
            if(RRM_TRUE == p_new_ncl->intra_freq_cells[existing_index].blacklisted)
            {
                if(!RRM_MEMCMP(&p_updated_nrt_intra_rat_bl_cell->cell_list[i].cgi, 
                            &p_new_ncl->intra_freq_cells[existing_index].cell_id,
                            sizeof(rrm_oam_eutran_global_cell_id_t)))
                {
                    /* Modification case */
                    update_index = existing_index;
                    /* CSR 81662 : SPR 11861 Fix Start */
                    if(RRM_TRUE == rrm_cellm_verify_intra_freq_nrt_info_change(&p_updated_nrt_intra_rat_bl_cell->cell_list[i],
                            &p_new_ncl->intra_freq_cells[existing_index]))
                    {
                        *p_reconfig_req = RRM_TRUE;
                    }
                    /* CSR 81662 : SPR 11861 Fix End */
                    break;
                }
            }
        }
        if(RRM_INVALID_RETURN == update_index)
        {
            /* Addition case */
            if(num_intra_neighs < MAX_INTRA_FREQ_CELLS)
            {
                /* CSR 81662 : SPR 11861 Fix Start */
                /* If PCI is already present in NCL, broadcast should not be done 
                   on the basis of addition of this nbr cell */
                if(RRM_TRUE == rrmcm_check_broadcast_status_intra_freq_pci(
     				/*COV_2NOV_START*/
                            &p_updated_nrt_intra_rat_bl_cell->cell_list[i],  p_new_ncl))
                {		/*COV_2NOV_STOP*/
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            "PCI = %d was not broadcast earlier in SIB 4",
                            p_updated_nrt_intra_rat_bl_cell->cell_list[i].pci);
                    *p_reconfig_req = RRM_TRUE;
                }
                /* CSR 81662 : SPR 11861 Fix End */

                update_index = num_intra_neighs; 
                p_new_ncl->intra_freq_cells[update_index].bitmask |=
                    RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT;

                p_new_ncl->intra_freq_cells[update_index].blacklisted = RRM_TRUE;

                RRM_MEMCPY(&p_new_ncl->intra_freq_cells[update_index].cell_id,
                        &p_updated_nrt_intra_rat_bl_cell->cell_list[i].cgi,
                        sizeof(rrm_oam_eutran_global_cell_id_t));

                /* Bug 896 : Start */
                p_new_ncl->intra_freq_cells[update_index].ho_status = HO_PROHIBITED;
                /* Bug 896 : End */
                num_intra_neighs++;
                /* CSR 81662 : SPR 11861 Fix Delete */
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR, "Max list size reached. cannot add"); 
            }
        }
        if(RRM_SUCCESS == ret_val)
        {
            rrmcm_populate_intra_freq_nbr_info(
                    &p_new_ncl->intra_freq_cells[update_index],
                    &p_updated_nrt_intra_rat_bl_cell->cell_list[i]);


            if(RRM_TRUE == p_updated_nrt_intra_rat_bl_cell->cell_list[i].broadcast_status)
            {
                *bit_mask |= RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED;
            }
            else
            {
                *bit_mask |= RRM_INTRA_FREQ_NON_BROADCAST_NBRS_UPDATED;
            }
        }
    }
    p_new_ncl->num_valid_intra_freq_cell = num_intra_neighs;

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_add_mod_intra_bl_rat_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function identifies the intra & inter-freq blacklisted nbrs rcvd
 *                  in Updated NRT and calls the respective handlers
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_intra_rat_bl_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U16                              *bit_mask,
    rrm_bool_et                     *p_reconfig_req
    )
{
    U8          add_mod_intra_bl_neigh_cnt     = RRM_ZERO;
    U8          existing_intra_nbrs_cnt     = RRM_ZERO;
    U8          existing_inter_nbrs_cnt        = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    existing_intra_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
        lte_ncl.num_valid_intra_freq_cell;
    existing_inter_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
        lte_ncl.num_valid_inter_freq_cell;

    for (add_mod_intra_bl_neigh_cnt = RRM_ZERO;
            (add_mod_intra_bl_neigh_cnt < p_updated_nrt_info->intra_rat_ncl.
             intra_rat_black_list_cells_to_add_mod_list_size) && 
            (add_mod_intra_bl_neigh_cnt < RRM_MAX_NO_EARFCN); ++add_mod_intra_bl_neigh_cnt)
    {
        if (p_updated_nrt_info->intra_rat_ncl.
                intra_rat_black_list_cells_to_add_mod_list[add_mod_intra_bl_neigh_cnt].earfcn ==
                p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
        {
            rrmcm_add_mod_intra_freq_bl_nbrs_to_updated_list(p_cell_context, 
                    &p_updated_nrt_info->intra_rat_ncl.
                    intra_rat_black_list_cells_to_add_mod_list[add_mod_intra_bl_neigh_cnt], 
                    existing_intra_nbrs_cnt, bit_mask, p_reconfig_req);
        }
        else
        {
            rrmcm_add_mod_inter_freq_nbrs_to_updated_list(p_cell_context, 
                    &p_updated_nrt_info->intra_rat_ncl.
                    intra_rat_black_list_cells_to_add_mod_list[add_mod_intra_bl_neigh_cnt],
                    existing_inter_nbrs_cnt, bit_mask, RRM_TRUE, p_reconfig_req);
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_compare_utran_nbr 
 * Inputs         : rrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi:
 *                      CGI Info recvd in Updated NRT Info received from SON
 *                  utran_freq_cells_t *p_utran_neigh:
 *                      Nbr cell configured at RRM
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE
 * Description    : This function compares the existing nbrs of the utra freq
 *                  with those recvd in Updated NRT Info
 ****************************************************************************/
rrm_bool_et
rrmcm_compare_utran_nbr(
        rrm_son_utran_geran_global_cell_id_t    *p_updated_nrt_cgi,
        utran_freq_cells_t                      *p_utran_neigh
        )
{
    rrm_bool_et   ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    /*Start: SPR 9289 */
    /*Deleted lines*/
    /*End: SPR 9289 */
    
    /*Start: SPR 9289 */
    if (!RRM_MEMCMP(p_utran_neigh->uc_id.cell_id_merge, p_updated_nrt_cgi->cell_identity,
                   sizeof(U8)*MAX_CELL_IDENTITY_OCTETS)
    /*End: SPR 9289 */
       &&
       (!RRM_MEMCMP(&(p_utran_neigh->rai.lai.plmn_identity.mcc),
                 &(p_updated_nrt_cgi->plmn_id.mcc), sizeof(U8) * MAX_MCC_DIGITS)) 
       &&
	  (p_utran_neigh->rai.lai.plmn_identity.mnc.count == 
          p_updated_nrt_cgi->plmn_id.num_mnc_digit) 
       &&
	(!RRM_MEMCMP(&(p_utran_neigh->rai.lai.plmn_identity.mnc.mnc),
                     &(p_updated_nrt_cgi->plmn_id.mnc), sizeof(U8) * MAX_MNC_DIGITS)))
    {
        ret_val = RRM_TRUE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_copy_utran_nbr_info
 * Inputs         : rrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi:
 *                      CGI Info recvd in Updated NRT Info received from SON
 *                  utran_freq_cells_t *p_utran_neigh:
 *                      Pointer to Nbr cell of new NCL
 * Outputs        : None
 * Returns        : None 
 * Description    : This function copies the utra freq nbrs cgi recvd in Updated 
 *                  NRT Info to the new NCL
 ****************************************************************************/
rrm_void_t
rrmcm_copy_utran_nbr_info(
        rrm_son_utran_geran_global_cell_id_t    *p_updated_nrt_cgi,
        utran_freq_cells_t                      *p_utran_neigh
        )
{
    U16         rnc_id = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /*Start: SPR 9289 */
    /*Son sends merged rnc id and cell id.
      Extract rnc id from cell id*/
    /*If last bit is set it is extended rnc id*/
    /* Review comments incorp*/
    if( RRM_EIGHT & p_updated_nrt_cgi->cell_identity[RRM_THREE])
    /* Review comments incorp end */
    {
       /*Take 16 bits as rnc id*/
       rnc_id = p_updated_nrt_cgi->cell_identity[RRM_ZERO];
       rnc_id = rnc_id << RRM_EIGHT;
       rnc_id |= p_updated_nrt_cgi->cell_identity[RRM_ONE];
       p_utran_neigh->uc_id.extended_rnc_id = rnc_id;
       p_utran_neigh->uc_id.bitmask |= RRM_UTRAN_EXTN_RNC_ID_PRESENT;
    }
    else
    {
        /*Take 12 bits as rnc id*/
        rnc_id = p_updated_nrt_cgi->cell_identity[RRM_ZERO];
        rnc_id = rnc_id << RRM_EIGHT;
        rnc_id |= p_updated_nrt_cgi->cell_identity[RRM_ONE] & 0xF0;
        rnc_id = rnc_id >> RRM_FOUR;
        p_utran_neigh->uc_id.rnc_id = rnc_id;
    }

    /*Copy the total cell id sent by son in merged cell
      id in rrm ncl*/ 
    RRM_MEMCPY(p_utran_neigh->uc_id.cell_id_merge,
        p_updated_nrt_cgi->cell_identity,
        sizeof(U8) * MAX_CELL_IDENTITY_OCTETS);

    /*End: SPR 9289 */

    /* Fix 9926 Start */
    p_utran_neigh->rai.lai.plmn_identity.presence_bitmask |=
        PLMN_IDENTITY_MCC_PRESENCE_FLAG;
    /* Fix 9926 End */
    
    RRM_MEMCPY(&p_utran_neigh->rai.lai.plmn_identity.mcc,
        &p_updated_nrt_cgi->plmn_id.mcc, sizeof(U8) * MAX_MCC_DIGITS);

    p_utran_neigh->rai.lai.plmn_identity.mnc.count =
        p_updated_nrt_cgi->plmn_id.num_mnc_digit;

    RRM_MEMCPY(&p_utran_neigh->rai.lai.plmn_identity.mnc.mnc,
        &p_updated_nrt_cgi->plmn_id.mnc, sizeof(U8) * MAX_MNC_DIGITS);


    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrmcm_copy_non-blacklisted_utran_nbrs_to_updated_list 
 * Inputs         : p_updated_nrt_info, *bit_mask 
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the non 
                    blacklisted  utran freq
 ****************************************************************************/
rrm_bool_et
rrmcm_copy_non_blacklisted_utran_nbrs_to_updated_list(rrm_cell_context_t              *p_cell_context, 
                                                      rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info ,
                                                      U8                              existing_utran_neigh_cnt,
                                                      U16                              *bit_mask)
{
    rrm_bool_et     cell_removed            = RRM_FALSE;
    U8          remove_utran_neigh_cnt      = RRM_ZERO;
    U8              i                       = RRM_ZERO;
    rrm_bool_et is_same                     = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
            for (remove_utran_neigh_cnt = RRM_ZERO;
                    (remove_utran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
                     cells_to_remove_list_size) &&
                    /* TDD Support SON Start coverity 56715:fix*/
                    (remove_utran_neigh_cnt < RRM_MAX_NUM_UTRA_CARRIERS )
                    /* TDD Support SON End */
                    && !cell_removed;
                    ++remove_utran_neigh_cnt)
            {
                if(p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                        utran_freq_cells[existing_utran_neigh_cnt].uarfcndl ==
                        p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
                        cells_to_remove_list[remove_utran_neigh_cnt].uarfcn)
                {
            /*Cov_fix_55327*/
            for (i = RRM_ZERO; ((i < p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
                            cells_to_remove_list[remove_utran_neigh_cnt].cell_list_size) && (i< RRM_MAX_NUM_UTRA_CARRIERS)); ++i)
            {
                /*Cov_fix_55327*/
                        is_same = rrmcm_compare_utran_nbr(&p_updated_nrt_info->inter_rat_ncl.
                            utran_neighbor_list.cells_to_remove_list[remove_utran_neigh_cnt].
                            cell_list[i].cgi,
                            &p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            utran_freq_cells[existing_utran_neigh_cnt]);

                        if(RRM_TRUE == is_same)
                        {
                            /* This neighbor cell is in removed neighbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            *bit_mask |= RRM_UTRAN_NBRS_UPDATED;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Whitelist Nbr Cell removed for UTRAN Freq = %d, PCI = %d",
                                p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                utran_freq_cells[existing_utran_neigh_cnt].uarfcndl,
                                p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                utran_freq_cells[existing_utran_neigh_cnt].pcpich_scrambling_code); 
                            break;
                        }
                    }
                }
            }
   RRM_UT_TRACE_EXIT();
   return cell_removed;
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrmcm_copy_existing_utran_nbrs_to_updated_list 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the
 *                  nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the utran freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist remove list
 ****************************************************************************/ 
rrm_void_t
rrmcm_copy_existing_utran_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U16                              *bit_mask
    )
{
    U8          existing_utran_neigh_cnt    = RRM_ZERO;
    U8          remove_utran_neigh_cnt      = RRM_ZERO;
    U8          num_utran_neighs            = RRM_ZERO;
    rrm_bool_et     cell_removed            = RRM_FALSE;
    rrm_bool_et is_same                     = RRM_FALSE;
    U8              i                       = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Add existing utran cells from configured ncl list to this list */
    for (existing_utran_neigh_cnt = RRM_ZERO;
            (existing_utran_neigh_cnt < p_cell_context->ran_info.ncl_params.
             inter_rat_ncl.num_valid_utran_freq_cell) &&
            (num_utran_neighs < RRM_MAX_UTRAN_NBRS); 
            ++existing_utran_neigh_cnt)
    {
        cell_removed = RRM_FALSE;
        if(RRM_FALSE == p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                utran_freq_cells[existing_utran_neigh_cnt].blacklisted)
        {
            /*Klockwork_fix_start*/
            cell_removed = rrmcm_copy_non_blacklisted_utran_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, 
                                                                                existing_utran_neigh_cnt ,bit_mask);
            /*Klockwork_fix_end*/
            /* Check if existing nbr cell is present in the Remove list of Non-Blacklist nbrs */
        }
        else
        {
            /* Check if existing nbr cell is present in the Remove list of Blacklist nbrs */
            for (remove_utran_neigh_cnt = RRM_ZERO;
                    (remove_utran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
                     black_list_cells_to_remove_list_size) &&
                    /* TDD Support SON Start coverity 56715: fix*/
                    (remove_utran_neigh_cnt < RRM_MAX_NUM_UTRA_CARRIERS )
                    /* TDD Support SON End */
                    && !cell_removed;
                    ++remove_utran_neigh_cnt)
            {
                if(p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                        utran_freq_cells[existing_utran_neigh_cnt].uarfcndl ==
                        p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
                        black_list_cells_to_remove_list[remove_utran_neigh_cnt].uarfcn)
                {
                    /*Cov_fix_55327*/
                    for (i = RRM_ZERO; ((i < p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
                            black_list_cells_to_remove_list[remove_utran_neigh_cnt].cell_list_size) && (i< RRM_MAX_NUM_UTRA_CARRIERS)); ++i)
                    {
                     /*Cov_fix_55327*/
                        is_same = rrmcm_compare_utran_nbr(&p_updated_nrt_info->inter_rat_ncl.
                            utran_neighbor_list.black_list_cells_to_remove_list[remove_utran_neigh_cnt].
                            cell_list[i].cgi,
                            &p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            utran_freq_cells[existing_utran_neigh_cnt]);

                        if(RRM_TRUE == is_same)
                        {
                            /* This neighbor cell is in removed neighbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            *bit_mask |= RRM_UTRAN_NBRS_UPDATED;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Blacklisted Nbr Cell removed for UTRAN Freq = %d, PCI = %d",
                                p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                utran_freq_cells[existing_utran_neigh_cnt].uarfcndl,
                                p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                utran_freq_cells[existing_utran_neigh_cnt].pcpich_scrambling_code); 
                            break;
                        }
                    }
                }
            }
        }
        /* If nbr cell is not present in the remove lists */
        if(!cell_removed)
        {
            /* Add the cell in the updated ncl list */
            RRM_MEMCPY(&p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                    utran_freq_cells[num_utran_neighs],
                    &p_cell_context->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[existing_utran_neigh_cnt],
                    sizeof(utran_freq_cells_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Existing Nbr cell copied in Updated UTRAN NCL for Freq = %d, PCI = %d",
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                utran_freq_cells[num_utran_neighs].uarfcndl,
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                utran_freq_cells[num_utran_neighs].pcpich_scrambling_code);
            ++num_utran_neighs;
        }
    }
    p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_utran_freq_cell = num_utran_neighs;
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_compare_geran_nbr
 * Inputs         : rrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi:
 *                      CGI Info recvd in Updated NRT Info received from SON
 *                  geran_freq_cells_t *p_geran_neigh:
 *                      Nbr cell configured at RRM
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE 
 * Description    : This function compares the existing nbrs of the geran freq
 *                  with those recvd in Updated NRT Info
 ****************************************************************************/
rrm_bool_et
rrmcm_compare_geran_nbr(
        rrm_son_utran_geran_global_cell_id_t    *p_updated_nrt_cgi,
        geran_freq_ncl_t                        *p_geran_neigh
        )
{
    rrm_bool_et   ret_val = RRM_FALSE;
/* 18031_CHANGES_START */
    U16           cell_id = RRM_ZERO;
/* 18031_CHANGES_END */

    RRM_UT_TRACE_ENTER();

/* 18031_CHANGES_START */
    /*SPR 20324 Fix Start*/
    cell_id = p_updated_nrt_cgi->cell_identity[RRM_THREE];
    cell_id = cell_id << RRM_EIGHT;
    cell_id = cell_id | p_updated_nrt_cgi->cell_identity[RRM_TWO];
    /*SPR 20324 Fix End*/
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,"formatted cellId [%d] cellId in ncl[%d]", cell_id ,p_geran_neigh->cell_id);
/* 18031_CHANGES_END */

    if ((!RRM_MEMCMP(&p_geran_neigh->lai.plmn_identity.mcc,
        &p_updated_nrt_cgi->plmn_id.mcc, sizeof(U8) * MAX_MCC_DIGITS)) &&
        (p_geran_neigh->lai.plmn_identity.mnc.count ==
        p_updated_nrt_cgi->plmn_id.num_mnc_digit) &&
	(!RRM_MEMCMP(&p_geran_neigh->lai.plmn_identity.mnc.mnc,
        &p_updated_nrt_cgi->plmn_id.mnc, sizeof(U8) * MAX_MNC_DIGITS)) &&
            (!RRM_MEMCMP(p_updated_nrt_cgi->cell_identity, p_geran_neigh->lai.lac,
                       sizeof(U8) * RRM_OAM_MAX_NUM_LAC_OCTETS)) && 
/* 18031_CHANGES_START */
            (p_geran_neigh->cell_id == cell_id))
/* 18031_CHANGES_END */
    {
        ret_val = RRM_TRUE;
    } 

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_compare_cdma_nbr
 * Inputs         : rrm_son_utran_cdma_global_cell_id_t *p_updated_nrt_cgi:
 *                      CGI Info recvd in Updated NRT Info received from SON
 *                  geran_freq_cells_t *p_geran_neigh:
 *                      Nbr cell configured at RRM
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE 
 * Description    : This function compares the existing nbrs of the geran freq
 *                  with those recvd in Updated NRT Info
 ****************************************************************************/
rrm_bool_et
rrmcm_compare_cdma_nbr(
        rrmcm_rmif_cdma_global_cell_id_t              *p_updated_nrt_cgi,
        rrmcm_rmif_cdma2000_freq_cells_t                        *p_cdma_neigh
        )
{
    rrm_bool_et   ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    
    if(p_cdma_neigh->type == RRM_OAM_NCL_TYPE_1XRTT)
    {

        if (!RRM_MEMCMP(&p_cdma_neigh->CID,
            &p_updated_nrt_cgi->cell_global_id_1X_RTT, 
            sizeof(U8) * RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE)) 
        {
            ret_val = RRM_TRUE;
        }
    }

    
    if(p_cdma_neigh->type == RRM_OAM_NCL_TYPE_HRPD)
    {

        if (!RRM_MEMCMP(&p_cdma_neigh->CID,
            &p_updated_nrt_cgi->cell_global_id_HRPD, 
            sizeof(U8) * RRM_SON_CDMA_CELL_GLOBAL_ID_HRPD_SIZE)) 
        {
            ret_val = RRM_TRUE;
        }
    }



    RRM_UT_TRACE_EXIT();
    return ret_val;
}



/****************************************************************************
 * Function Name  : rrmcm_copy_cdma_nbr_info
 * Inputs         : rrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi:
 *                      CGI Info recvd in Updated NRT Info received from SON
 *                  geran_freq_cells_t *p_geran_neigh:
 *                      Pointer to Nbr cell of new NCL
 * Outputs        : None
 * Returns        : None 
 * Description    : This function copies the utra freq nbrs cgi recvd in Updated
 *                  NRT Info to the new NCL
 ****************************************************************************/
rrm_void_t
rrmcm_copy_cdma_nbr_info(
        rrmcm_rmif_cdma_global_cell_id_t        *p_updated_nrt_cgi,
        rrmcm_rmif_cdma2000_freq_cells_t        *p_cdma_neigh,
        U8                                       cdma_type
        )
{
    RRM_UT_TRACE_ENTER();
   
    if (cdma_type == RRM_OAM_NCL_TYPE_1XRTT)
    {
            RRM_MEMCPY(&(p_cdma_neigh->CID),
                &(p_updated_nrt_cgi->cell_global_id_1X_RTT),
                sizeof(U8) * RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE);
            p_cdma_neigh->num_valid_count_cid = 
                RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE;

    }
    if (cdma_type == RRM_OAM_NCL_TYPE_HRPD)
    {
            RRM_MEMCPY(&(p_cdma_neigh->CID),
                &(p_updated_nrt_cgi->cell_global_id_HRPD),
                sizeof(U8) * RRM_SON_CDMA_CELL_GLOBAL_ID_HRPD_SIZE);
            p_cdma_neigh->num_valid_count_cid = 
                RRM_SON_CDMA_CELL_GLOBAL_ID_HRPD_SIZE;

    }
 
    RRM_UT_TRACE_EXIT();
}




/****************************************************************************
 * Function Name  : rrmcm_copy_geran_nbr_info
 * Inputs         : rrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi:
 *                      CGI Info recvd in Updated NRT Info received from SON
 *                  geran_freq_cells_t *p_geran_neigh:
 *                      Pointer to Nbr cell of new NCL
 * Outputs        : None
 * Returns        : None 
 * Description    : This function copies the utra freq nbrs cgi recvd in Updated
 *                  NRT Info to the new NCL
 ****************************************************************************/
rrm_void_t
rrmcm_copy_geran_nbr_info(
        rrm_son_utran_geran_global_cell_id_t    *p_updated_nrt_cgi,
        geran_freq_ncl_t                        *p_geran_neigh
        )
{
    RRM_UT_TRACE_ENTER();
    
    RRM_MEMCPY(&p_geran_neigh->lai.plmn_identity.mcc,
        &p_updated_nrt_cgi->plmn_id.mcc, sizeof(U8) * MAX_MCC_DIGITS);

    p_geran_neigh->lai.plmn_identity.mnc.count =
        p_updated_nrt_cgi->plmn_id.num_mnc_digit;

    RRM_MEMCPY(&p_geran_neigh->lai.plmn_identity.mnc.mnc,
        &p_updated_nrt_cgi->plmn_id.mnc, sizeof(U8) * MAX_MNC_DIGITS);

    /* Spr 16211 Changes Start */
    p_geran_neigh->lai.plmn_identity.presence_bitmask |=
        PLMN_IDENTITY_MCC_PRESENCE_FLAG;
    /* Spr 16211 Changes End*/
    RRM_MEMCPY(p_geran_neigh->lai.lac, p_updated_nrt_cgi->cell_identity,
        sizeof(U8) * RRM_OAM_MAX_NUM_LAC_OCTETS);
    /* Spr 16211 Changes Start*/
    p_geran_neigh->cell_id = (U16)((p_updated_nrt_cgi->cell_identity)[RRM_TWO] << RRM_EIGHT);      
    p_geran_neigh->cell_id =  p_geran_neigh->cell_id |(U16)((p_updated_nrt_cgi->cell_identity)[RRM_THREE]);
    /* Spr 16211 Changes End*/

    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrmcm_copy_non_blacklisted_geran_nbrs_to_updated_list
 * Inputs         : p_updated_nrt_info, *bit_mask
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the non
                    blacklisted  utran freq
 ****************************************************************************/
rrm_bool_et
rrmcm_copy_non_blacklisted_geran_nbrs_to_updated_list(rrm_cell_context_t              *p_cell_context,
                                                      rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info ,
                                                      U8                              existing_geran_neigh_cnt,
                                                      U16                              *bit_mask)
{
    rrm_bool_et     cell_removed            = RRM_FALSE;
    U8          remove_geran_neigh_cnt      = RRM_ZERO;
    U8              i                       = RRM_ZERO;
    rrm_bool_et is_same                     = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

            for (remove_geran_neigh_cnt = RRM_ZERO;
                    (remove_geran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                     cells_to_remove_list_size) &&
                    (remove_geran_neigh_cnt < MAX_NO_GERAN_FREQ_GROUUP) && !cell_removed;
                    ++remove_geran_neigh_cnt)
            {
                if((p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                    geran_freq_cells[existing_geran_neigh_cnt].bcch_arfcn ==
                    p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                    cells_to_remove_list[remove_geran_neigh_cnt].arfcn) &&
                    (p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                    geran_freq_cells[existing_geran_neigh_cnt].band_indicator ==
                    p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                    cells_to_remove_list[remove_geran_neigh_cnt].band_ind))

                {
            /*Cov_fix_55327*/
                    for (i = RRM_ZERO; ((i < p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                            cells_to_remove_list[remove_geran_neigh_cnt].cell_list_size) && (i< MAX_NO_GERAN_FREQ_GROUUP)); ++i)
                /*Cov_fix_55327*/
                    {
                        is_same = rrmcm_compare_geran_nbr(&p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                            cells_to_remove_list[remove_geran_neigh_cnt].cell_list[i].cgi,
                            &p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            geran_freq_cells[existing_geran_neigh_cnt]);

                        if(RRM_TRUE == is_same)
                        {
                            /* This neighbor cell is in removed neighbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            *bit_mask |= RRM_GERAN_NBRS_UPDATED;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Whitelist Nbr Cell removed for GERAN Freq = %d, Band-ind = %d PCI = %d",
                                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[existing_geran_neigh_cnt].bcch_arfcn,
                                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[existing_geran_neigh_cnt].band_indicator,
                                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[existing_geran_neigh_cnt].pci);
                            break;
                        }
                    }
                }
            }
    RRM_UT_TRACE_EXIT();
    return cell_removed;

}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrmcm_copy_existing_geran_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the
 *                  nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the geran freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist remove list
 ****************************************************************************/
rrm_void_t
rrmcm_copy_existing_geran_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U16                              *bit_mask
    )
{
    U8          existing_geran_neigh_cnt    = RRM_ZERO;
    U8          remove_geran_neigh_cnt      = RRM_ZERO;
    U8          num_geran_neighs            = RRM_ZERO;
    rrm_bool_et cell_removed                = RRM_FALSE;
    rrm_bool_et is_same                     = RRM_FALSE;
    U8          i                           = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Add existing geran cells from configured ncl list to this list */
    for (existing_geran_neigh_cnt = RRM_ZERO;
        (existing_geran_neigh_cnt < p_cell_context->ran_info.ncl_params.
         inter_rat_ncl.num_valid_geran_cell) && (num_geran_neighs < RRM_MAX_GERAN_NBRS); 
    ++existing_geran_neigh_cnt)
    {
        cell_removed = RRM_FALSE;
        if(RRM_FALSE == p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                    geran_freq_cells[existing_geran_neigh_cnt].blacklisted)
        {
            /*Klockwork_fix_start*/
            cell_removed = rrmcm_copy_non_blacklisted_geran_nbrs_to_updated_list(p_cell_context,
                                         p_updated_nrt_info ,existing_geran_neigh_cnt ,bit_mask);
            /*Klockwork_fix_end*/
            /* Check if existing nbr cell is present in the Remove list of Non-Blacklist nbrs */
        }
        else
        {
            /* Check if existing nbr cell is present in the Remove list of Blacklist nbrs */
            for (remove_geran_neigh_cnt = RRM_ZERO;
                    (remove_geran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                     black_list_cells_to_remove_list_size) &&
                    (remove_geran_neigh_cnt < RRM_MAX_NO_EARFCN) && !cell_removed;
                    ++remove_geran_neigh_cnt)
            {
                if((p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                    geran_freq_cells[existing_geran_neigh_cnt].bcch_arfcn ==
                    p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                    black_list_cells_to_remove_list[remove_geran_neigh_cnt].arfcn) &&
                    (p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                    geran_freq_cells[existing_geran_neigh_cnt].band_indicator ==
                    p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                    black_list_cells_to_remove_list[remove_geran_neigh_cnt].band_ind))
                {
                    /*cov_fix_55327*/
                    for (i = RRM_ZERO; ((i < p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                            black_list_cells_to_remove_list[remove_geran_neigh_cnt].cell_list_size) && ( i< RRM_MAX_NO_EARFCN)); ++i)
                    /*cov_fix_55327*/
                    {
                        is_same = rrmcm_compare_geran_nbr(&p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
                            black_list_cells_to_remove_list[remove_geran_neigh_cnt].cell_list[i].cgi,
                            &p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            geran_freq_cells[existing_geran_neigh_cnt]);

                        if (RRM_TRUE == is_same)
                        {
                            /* This neighbor cell is in removed neighbor cell list, no need to add it */
                            cell_removed = RRM_TRUE;
                            *bit_mask |= RRM_GERAN_NBRS_UPDATED;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Whitelist Nbr Cell removed for GERAN Freq = %d, Band-ind = %d PCI = %d",
                                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[existing_geran_neigh_cnt].bcch_arfcn,
                                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[existing_geran_neigh_cnt].band_indicator,
                                    p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[existing_geran_neigh_cnt].pci);
                            break;
                        }
                    }
                }
            }
        }
        /* If nbr cell is not present in the remove lists */
        if(!cell_removed)
        {
            /* Add the cell in the updated ncl list */
            RRM_MEMCPY(&p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
            geran_freq_cells[num_geran_neighs],
                    &p_cell_context->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[existing_geran_neigh_cnt],
                    sizeof(geran_freq_ncl_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Existing Nbr cell copied in Updated GERAN NCL for Freq = %d, Band-ind = %d, PCI = %d",
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                geran_freq_cells[num_geran_neighs].bcch_arfcn,
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                geran_freq_cells[num_geran_neighs].band_indicator,
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                geran_freq_cells[num_geran_neighs].pci);
            ++num_geran_neighs;
        }
    }
    p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_geran_cell = num_geran_neighs;

    RRM_UT_TRACE_EXIT();
}


/*klock_works_changes_start*/
/****************************************************************************
 * Function Name  : rrm_checking_for_xrtt_type_cdma
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the
 *                  nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the cdma freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist add/remove list
 ****************************************************************************/
rrm_void_t
rrm_checking_for_xrtt_type_cdma
(
 rrm_cell_context_t              *p_cell_context,
 rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
 U16                              *bit_mask,
 U8                               existing_cdma_neigh_cnt,
 rrm_bool_et                     *cell_removed
 )
{
    U8          remove_cdma_neigh_cnt = RRM_ZERO;
    rrm_bool_et is_same               = RRM_FALSE;
    U8     i= RRM_NULL;


    RRM_UT_TRACE_ENTER();

    *cell_removed = RRM_FALSE;

    for (remove_cdma_neigh_cnt = RRM_ZERO;
            (remove_cdma_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_xrtt.
             cells_to_remove_list_size) &&
            (remove_cdma_neigh_cnt < RRM_SON_CDMA_MAX_NO_ARFCN) && !*cell_removed;
            ++remove_cdma_neigh_cnt)
    {
        /*Cov_fix_55327*/
        for(i= RRM_ZERO; ((i < p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_xrtt.
                       cells_to_remove_list[remove_cdma_neigh_cnt].cell_list_size) && (i < RRM_SON_CDMA_MAX_NO_ARFCN));i++)
        /*Cov_fix_55327*/
        {
            if((p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                        cdma2000_freq_cells[existing_cdma_neigh_cnt].arfcn ==
                        p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_xrtt.
                        cells_to_remove_list[remove_cdma_neigh_cnt].cell_list[i].arfcn) &&
                    (p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                     cdma2000_freq_cells[existing_cdma_neigh_cnt].band_class ==
                     p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_xrtt.
                     cells_to_remove_list[remove_cdma_neigh_cnt].band_class))
            {
                is_same = rrmcm_compare_cdma_nbr(&p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_xrtt.
                        cells_to_remove_list[remove_cdma_neigh_cnt].cell_list[i].cgi,
                        &p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                        cdma2000_freq_cells[existing_cdma_neigh_cnt]);

                if (RRM_TRUE == is_same)
                {
                    /* This neighbor cell is in removed neighbor cell list, no need to add it */
                    *cell_removed = RRM_TRUE;
                    *bit_mask |= RRM_CDMA_NBRS_UPDATED;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Whitelist Nbr Cell removed for CDMA Freq = %d, Band_class = %d type = %d",
                            p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            cdma2000_freq_cells[existing_cdma_neigh_cnt].arfcn,
                            p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            cdma2000_freq_cells[existing_cdma_neigh_cnt].band_class,
                            p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            cdma2000_freq_cells[existing_cdma_neigh_cnt].type);
                    break;
                }

            }
        }

    }

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_checking_for_hrpd_type_cdma 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the
 *                  nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the cdma freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist add/remove list
 ****************************************************************************/

rrm_void_t
rrm_checking_for_hrpd_type_cdma
(
 rrm_cell_context_t              *p_cell_context,
 rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
 U16                              *bit_mask,
 U8                               existing_cdma_neigh_cnt,
 rrm_bool_et                     *cell_removed
 )
{
    U8          remove_cdma_neigh_cnt = RRM_ZERO;
    rrm_bool_et is_same               = RRM_FALSE;
    U8     i= RRM_NULL;


    RRM_UT_TRACE_ENTER();


    for (remove_cdma_neigh_cnt = RRM_ZERO;
            (remove_cdma_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_hrpd.
             cells_to_remove_list_size) &&
            (remove_cdma_neigh_cnt < RRM_SON_CDMA_MAX_NO_ARFCN) && !*cell_removed;
            ++remove_cdma_neigh_cnt)
    {
        /*Cov_fix_55327*/
        for(i= RRM_ZERO; ((i < p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_hrpd.
                        cells_to_remove_list[remove_cdma_neigh_cnt].cell_list_size) && (i < RRM_SON_CDMA_MAX_NO_ARFCN));i++)
            /*Cov_fix_55327*/
        {
            if((p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                        cdma2000_freq_cells[existing_cdma_neigh_cnt].arfcn ==
                        p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_hrpd.
                        cells_to_remove_list[remove_cdma_neigh_cnt].cell_list[i].arfcn) &&
                    (p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                     cdma2000_freq_cells[existing_cdma_neigh_cnt].band_class ==
                     p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_hrpd.
                     cells_to_remove_list[remove_cdma_neigh_cnt].band_class))
            {

                is_same = rrmcm_compare_cdma_nbr(&p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_hrpd.
                        cells_to_remove_list[remove_cdma_neigh_cnt].cell_list[i].cgi,
                        &p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                        cdma2000_freq_cells[existing_cdma_neigh_cnt]);

                if (RRM_TRUE == is_same)
                {
                    /* This neighbor cell is in removed neighbor cell list, no need to add it */
                    *cell_removed = RRM_TRUE;
                    *bit_mask |= RRM_CDMA_NBRS_UPDATED;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Whitelist Nbr Cell removed for CDMA Freq = %d, Band_class = %d type = %d",
                            p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            cdma2000_freq_cells[existing_cdma_neigh_cnt].arfcn,
                            p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            cdma2000_freq_cells[existing_cdma_neigh_cnt].band_class,
                            p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                            cdma2000_freq_cells[existing_cdma_neigh_cnt].type);
                    break;
                }

            }

        }

    }

    RRM_UT_TRACE_EXIT();

}
/*klock_works_changes_end*/


/****************************************************************************
 * Function Name  : rrmcm_copy_existing_cdma_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the
 *                  nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function copies the existing nbrs of the cdma freq
 *                  excluding those which are in the Add/Mod remove list or
 *                  Blacklist add/remove list
 ****************************************************************************/
rrm_void_t
rrmcm_copy_existing_cdma_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U16                              *bit_mask
    )
{
    U8          existing_cdma_neigh_cnt    = RRM_ZERO;
    U8          num_cdma_neighs            = RRM_ZERO;
    rrm_bool_et cell_removed;

    RRM_UT_TRACE_ENTER();

    /* Add existing cdma cells from configured ncl list to this list */
    for (existing_cdma_neigh_cnt = RRM_ZERO;existing_cdma_neigh_cnt < p_cell_context->ran_info.ncl_params.
         inter_rat_ncl.num_valid_cdma2000_freq_cells; ++existing_cdma_neigh_cnt)
    {
        cell_removed = RRM_FALSE;
        /* Check if existing nbr cell is present in the Remove list of Blacklist nbrs */
        /*klock_works_changes_start*/

        if(p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                cdma2000_freq_cells[existing_cdma_neigh_cnt].type == RRM_OAM_NCL_TYPE_1XRTT )
        {
            rrm_checking_for_xrtt_type_cdma(p_cell_context, p_updated_nrt_info, bit_mask, existing_cdma_neigh_cnt, &cell_removed);
        }

        // Checking here for CDMA type hrpd
        if(p_cell_context->ran_info.ncl_params.inter_rat_ncl.
                cdma2000_freq_cells[existing_cdma_neigh_cnt].type == RRM_OAM_NCL_TYPE_HRPD )
        {

            rrm_checking_for_hrpd_type_cdma(p_cell_context, p_updated_nrt_info, bit_mask, existing_cdma_neigh_cnt, &cell_removed);

        }
        /*klock_works_changes_end*/

 
        
        /* If nbr cell is not present in the remove lists */
        if(!cell_removed)
        {
            /* Add the cell in the updated ncl list */
            RRM_MEMCPY(&p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
            cdma2000_freq_cells[num_cdma_neighs],
                    &p_cell_context->ran_info.ncl_params.inter_rat_ncl.cdma2000_freq_cells[existing_cdma_neigh_cnt],
                    sizeof(rrmcm_rmif_cdma2000_freq_cells_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Existing Nbr cell copied in Updated CDMA NCL for Freq = %d, Band_Class = %d, type = %d",
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                cdma2000_freq_cells[num_cdma_neighs].arfcn,
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                cdma2000_freq_cells[num_cdma_neighs].band_class,
                p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.
                cdma2000_freq_cells[num_cdma_neighs].type);
            ++num_cdma_neighs;
        }
    }
    p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_cdma2000_freq_cells = num_cdma_neighs;

    RRM_UT_TRACE_EXIT();
}




/****************************************************************************
 * Function Name  : rrmcm_populate_utran_nbr_info
 * Inputs         : utran_freq_cells_t *p_new_ncl_cell : pointer to the nbr
 *                  cell in the new updated NCL
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 * Outputs        : None
 * Returns        : None
 * Description    : This function populates the utran nbr cell info in the new NCL
 *                  from the Updated NRT info recvd from SON
 ****************************************************************************/
rrm_void_t
rrmcm_populate_utran_nbr_info(
    utran_freq_cells_t                      *p_new_ncl_cell,
    rrmcm_rmif_utran_neighbor_cell_t        *p_updated_nrt_cell    
)
{
    RRM_UT_TRACE_ENTER();

    if(p_updated_nrt_cell->pci.bitmask & RRMCM_RMIF_PCI_FDD_PRESENT)
    {
     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                 "FDD Utran pci %d", p_updated_nrt_cell->pci.pci_fdd);
      //p_new_ncl_cell->pci = p_updated_nrt_cell->pci.pci_fdd;
      p_new_ncl_cell->pcpich_scrambling_code = p_updated_nrt_cell->pci.pci_fdd;
    }
    /* TDD Support SON Start */
    else if(p_updated_nrt_cell->pci.bitmask & RRMCM_RMIF_PCI_TDD_PRESENT)
    {
     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                 "TDD Utran pci %d", p_updated_nrt_cell->pci.pci_tdd);
      p_new_ncl_cell->pcpich_scrambling_code = p_updated_nrt_cell->pci.pci_tdd;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "UTRAN Pci missing");
    }
    /* TDD Support SON End */

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_UTRAN_NR_INFO_OFFSET_PRESENT)
    {
        p_new_ncl_cell->offset_freq = p_updated_nrt_cell->cell_specific_offset;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_UTRAN_NR_INFO_ACCESS_MODE_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT;
        p_new_ncl_cell->cell_access_mode = p_updated_nrt_cell->access_mode;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_UTRAN_NR_INFO_LAC_PRESENT)
    {
        RRM_MEMCPY(&p_new_ncl_cell->rai.lai.lac, &p_updated_nrt_cell->lac,
        sizeof(U8) * RRM_OAM_MAX_NUM_LAC_OCTETS);
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_UTRAN_NR_INFO_RAC_PRESENT)
    {
        p_new_ncl_cell->rai.rac = p_updated_nrt_cell->rac;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_UTRAN_NR_INFO_CSG_IDENTITY_PRESENT)
    {
        p_new_ncl_cell->bitmask |= RRM_UTRAN_FREQ_CSG_ID_PRESENT;
        RRM_MEMCPY(&p_new_ncl_cell->csg_identity, &p_updated_nrt_cell->csg_identity,
            sizeof(U8) * RRM_OAM_MAX_NUM_CSG_OCTETS);
    }

    /* SRVCC SUPPORT START */
    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_UTRAN_NR_INFO_PS_HO_SUPPORTED)
    {
        p_new_ncl_cell->ps_ho_supported = p_updated_nrt_cell->ps_ho_supported;
    }

    if (p_updated_nrt_cell->bitmask & RRMCM_RMIF_UTRAN_NR_INFO_VOIP_CAPABLE)
    {
        p_new_ncl_cell->voip_capable = p_updated_nrt_cell->voip_capable;
    }
    /* SRVCC SUPPORT END */

    RRM_UT_TRACE_EXIT();
}
/* SPR-9815-fix start */

/****************************************************************************
 * Function Name  : rrm_compare_merged_cell_id_for_daho
 * Inputs         : irrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi : Updated NRT
 *                : rrm_cell_context_t *p_cell_context  : cell context
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE
 * Description    : This function compares the existing nbrs of the utra freq
 *                : with those recvd in Updated NRT Info for Daho cell.
 ****************************************************************************/

rrm_bool_et
rrm_compare_merged_cell_id_for_daho(
        rrm_son_utran_geran_global_cell_id_t    *p_updated_nrt_cgi,
        rrm_cell_context_t  *p_cell_ctx
        )
{
    utran_cell_id_t daho_cell_uc_id;
    rrm_bool_et  ret_val = RRM_FALSE;
    U16 utran_cell_id    = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(&daho_cell_uc_id,RRM_ZERO,sizeof(utran_cell_id_t));

    daho_cell_uc_id.bitmask           = p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.uc_id.bitmask;
    daho_cell_uc_id.cell_id[RRM_ZERO] = p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.uc_id.cell_id[RRM_ZERO];
    daho_cell_uc_id.cell_id[RRM_ONE]  = p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.uc_id.cell_id[RRM_ONE];
    daho_cell_uc_id.rnc_id            = p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.uc_id.rnc_id;
    daho_cell_uc_id.extended_rnc_id   = p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.uc_id.extended_rnc_id;

    if(daho_cell_uc_id.bitmask)
    {
        rrm_encode_rncid_to_cell_identity (daho_cell_uc_id.cell_id_merge,daho_cell_uc_id.extended_rnc_id);
    }
    else
    {
        rrm_encode_rncid_to_cell_identity (daho_cell_uc_id.cell_id_merge,daho_cell_uc_id.rnc_id);
    }

    utran_cell_id = daho_cell_uc_id.cell_id[RRM_ZERO];
    utran_cell_id |= daho_cell_uc_id.cell_id[RRM_ONE] << RRM_EIGHT;

    rrm_encode_cid_to_cell_identity (daho_cell_uc_id.cell_id_merge,utran_cell_id);

    if ((!RRM_MEMCMP(daho_cell_uc_id.cell_id_merge, p_updated_nrt_cgi->cell_identity,
                    sizeof(U8)*MAX_CELL_IDENTITY_OCTETS))
            &&
            (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.rai.lai.plmn_identity.mcc),
                         &(p_updated_nrt_cgi->plmn_id.mcc), sizeof(U8) * MAX_MCC_DIGITS)) 
            &&
            (p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.rai.lai.plmn_identity.mnc.count == 
             p_updated_nrt_cgi->plmn_id.num_mnc_digit) 
            &&
            (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.utran_daho_cell_config_info.rai.lai.plmn_identity.mnc.mnc),
                         &(p_updated_nrt_cgi->plmn_id.mnc), sizeof(U8) * MAX_MNC_DIGITS)))
    {
        ret_val = RRM_TRUE;
    }
    else
    { 

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "CELL_ID %d %d, RNC_ID %d, ERNC ID %d, cell_merge %d %d %d %d\n",
                daho_cell_uc_id.cell_id[RRM_ONE],
                daho_cell_uc_id.cell_id[RRM_ZERO],
                daho_cell_uc_id.rnc_id,
                daho_cell_uc_id.extended_rnc_id,
                daho_cell_uc_id.cell_id_merge[RRM_ZERO],
                daho_cell_uc_id.cell_id_merge[RRM_ONE],
                daho_cell_uc_id.cell_id_merge[RRM_TWO],
                daho_cell_uc_id.cell_id_merge[RRM_THREE]);
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "compare CID %d %d %d %d \n",

                p_updated_nrt_cgi->cell_identity[RRM_ZERO],
                p_updated_nrt_cgi->cell_identity[RRM_ONE],
                p_updated_nrt_cgi->cell_identity[RRM_TWO],
                p_updated_nrt_cgi->cell_identity[RRM_THREE]);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;

}
/* SPR-9815-fix end */

/****************************************************************************
 * Function Name  : rrmcm_add_mod_utran_freq_nbr_cells_to_updated_list 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_utran_neighbor_list_t 
 *                      *p_updated_nrt_utran_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_utran_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the utran
 *                  nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the utran nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_mod_utran_freq_nbr_cells_to_updated_list(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_utran_neighbor_list_t        *p_updated_nrt_utran_cell,
    U8                                      existing_utran_nbrs_cnt,
    rrm_bool_et                             blacklist_status,
    U16                                      *bit_mask
)
{
    U8          num_utran_neighs            = RRM_ZERO;
    U8              update_index            = RRM_INVALID_RETURN;
    U8              existing_index          = RRM_ZERO;
    inter_rat_ncl_t *p_new_ncl              = RRM_PNULL;
    U8          i                           = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et is_same                     = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;

    num_utran_neighs = p_new_ncl->num_valid_utran_freq_cell;

    /* For each nbr */
    /*Cov_fix_55327*/
    for (i = RRM_ZERO;(( i < p_updated_nrt_utran_cell->cell_list_size) && (i<RRM_MAX_NUM_UTRA_CARRIERS )); ++i)
    {
    /*Cov_fix_55327*/    
        /* Fix-2 9815 Start */
        update_index = RRM_INVALID_RETURN;
        /* Fix-2 9815 End */

        /* SPR-9815-fix start */
        if (RRM_TRUE !=  rrm_compare_merged_cell_id_for_daho(&p_updated_nrt_utran_cell->cell_list[i].cgi,p_cell_context))
        {
            /*spr_19395_changes_start*/
            /*As per 3GPP, 36.413, LAC value as 0000 or FFFE are invalid
            */
            if(((p_updated_nrt_utran_cell->cell_list[i].lac[RRM_ZERO] == RRM_ZERO) &&
                        (p_updated_nrt_utran_cell->cell_list[i].lac[RRM_ONE] == RRM_ZERO)) ||
                    ((p_updated_nrt_utran_cell->cell_list[i].lac[RRM_ZERO] == 0xFE) &&
                     (p_updated_nrt_utran_cell->cell_list[i].lac[RRM_ONE] == 0xFF)))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "Invalid LAC information received for UTRAN cell from SON");

                continue;
                        }
                /*spr_19395_changes_end*/
            /* Traverse the  new built list to search the nbr in already existing nbrs */
            for(existing_index = RRM_ZERO; existing_index < existing_utran_nbrs_cnt;
                    existing_index++)
            {
            /* Spr 16211 Changes Start*/
            /* if condition Removed */
            /* Spr 16211 Changes End*/
                    is_same = rrmcm_compare_utran_nbr(&p_updated_nrt_utran_cell->cell_list[i].cgi,
                            &p_new_ncl->utran_freq_cells[existing_index]);

                    if(RRM_TRUE == is_same) 
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Utran Nbr cell to be modified");
                        /* Modification case */
                        update_index = existing_index;
                        break;
                    }
              /* Spr 16211 Changes Start*/
              /* if end braces Removed */
              /* Spr 16211 Changes End*/
            }
            /* If not Found */
            if(RRM_INVALID_RETURN == update_index)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Utran Nbr cell to be added");

                /* Addition case */
                if(num_utran_neighs < RRM_MAX_UTRAN_NBRS)
                {
                    /* TDD Support SON Start */
                    S16 freq_index = FREQ_NOT_CONFIGURED;

                    if(p_updated_nrt_utran_cell->cell_list[i].pci.bitmask & RRMCM_RMIF_PCI_FDD_PRESENT)
                    {
                        freq_index = rrmcm_search_uarfcn_fdd_in_cell_context(p_cell_context,
                                p_updated_nrt_utran_cell->uarfcn);
                    }
                    else
                    {
                        freq_index = rrmcm_search_uarfcn_tdd_in_cell_context(p_cell_context,
                                p_updated_nrt_utran_cell->uarfcn);
                    }
                    /* TDD Support SON End */

                    if (FREQ_NOT_CONFIGURED != freq_index)
                    {
                        update_index = num_utran_neighs;
                        rrmcm_copy_utran_nbr_info(&p_updated_nrt_utran_cell->cell_list[i].cgi,
                                &p_new_ncl->utran_freq_cells[update_index]);

                        num_utran_neighs++;
                    }
                    else
                    {
                        ret_val = RRM_FAILURE;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR, "Freq NOT configured. Invalid nbr");
                    }
                }
                else
                {
                    ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_ERROR, "Max list size reached. cannot add");
                }
            }
            if(RRM_SUCCESS == ret_val)
            {
                rrmcm_populate_utran_nbr_info(
                        &p_new_ncl->utran_freq_cells[update_index],
                        &p_updated_nrt_utran_cell->cell_list[i]);

                p_new_ncl->utran_freq_cells[update_index].uarfcndl=
                    p_updated_nrt_utran_cell->uarfcn;

                p_new_ncl->utran_freq_cells[update_index].blacklisted = blacklist_status;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Nbr cell updated at index = %d for Utran freq = %d with blacklist status = %d",
                        update_index, p_new_ncl->utran_freq_cells[update_index].uarfcndl, blacklist_status);

                *bit_mask |= RRM_UTRAN_NBRS_UPDATED;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "UTRAN NBR cell id matched with DAHO cell id");
        }
        /* SPR-9815-fix end */
    }
    p_new_ncl->num_valid_utran_freq_cell = num_utran_neighs;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_add_mod_utran_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function scans the utran add mod nbr list rcvd
 *                  in Updated NRT and calls the respective handler to add/mod
 *                  each nbr
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_utran_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U8                              existing_utran_nbrs_cnt, 
    U16                              *bit_mask
    )
{
    U8          add_mod_utran_neigh_cnt     = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Traverse updated NRT info to add/update each utran nbr */
    for (add_mod_utran_neigh_cnt = RRM_ZERO;
            (add_mod_utran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.
             utran_neighbor_list.cells_to_add_mod_list_size) &&
             /* TDD Support SON Start coverity 56714:fix*/
            (add_mod_utran_neigh_cnt < RRM_MAX_NUM_UTRA_CARRIERS);
            /* TDD Support SON End */
            ++add_mod_utran_neigh_cnt)
    {
        rrmcm_add_mod_utran_freq_nbr_cells_to_updated_list(p_cell_context,
            &p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
            cells_to_add_mod_list[add_mod_utran_neigh_cnt],
            existing_utran_nbrs_cnt, RRM_FALSE, bit_mask);
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_add_mod_utran_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function scans the utran add mod Blacklisted nbr list rcvd
 *                  in Updated NRT and calls the respective handler to add/mod
 *                  each Blacklisted nbr
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_utran_bl_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U8                               existing_utran_nbrs_cnt,
    U16                              *bit_mask
    )
{
    U8          add_mod_utran_neigh_cnt     = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Traverse updated NRT info to add/update each utran nbr */
    for (add_mod_utran_neigh_cnt = RRM_ZERO;
            (add_mod_utran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.
             utran_neighbor_list.black_list_cells_to_add_mod_list_size) &&
             /* TDD Support SON Start  Coverity 56713:fix */
            (add_mod_utran_neigh_cnt < RRM_MAX_NUM_UTRA_CARRIERS);
            /* TDD Support SON End */
            ++add_mod_utran_neigh_cnt)
    {
        rrmcm_add_mod_utran_freq_nbr_cells_to_updated_list(p_cell_context,
            &p_updated_nrt_info->inter_rat_ncl.utran_neighbor_list.
            black_list_cells_to_add_mod_list[add_mod_utran_neigh_cnt],
            existing_utran_nbrs_cnt, RRM_TRUE, bit_mask);
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_populate_geran_nbr_info
 * Inputs         : geran_freq_ncl_t *p_new_ncl_cell : pointer to the nbr
 *                  cell in the new updated NCL
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 * Outputs        : None
 * Returns        : None
 * Description    : This function populates the geran nbr cell info in the new NCL
 *                  from the Updated NRT info recvd from SON
 ****************************************************************************/
rrm_void_t
rrmcm_populate_geran_nbr_info(
    geran_freq_ncl_t                      *p_new_ncl_cell,
    rrmcm_rmif_geran_neighbor_cell_t        *p_updated_nrt_cell    
)
{
    RRM_UT_TRACE_ENTER();

    p_new_ncl_cell->bsic = (p_updated_nrt_cell->pci.ncc << RRM_THREE) | p_updated_nrt_cell->pci.bscc;

    /* SPR 18738 fix start */
    /* SPR 20327 fix START */
    p_new_ncl_cell->pci = (U16)p_new_ncl_cell->bsic;
    /* SPR 20327 fix End */
    /* SPR 18738 fix end */

    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_GERAN_NR_INFO_OFFSET_PRESENT)
    {
        p_new_ncl_cell->offset_freq = p_updated_nrt_cell->cell_specific_offset;
    }
    /* SPR-10489-fix start */
    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_GERAN_NR_INFO_DTM_SUPPORTED_PRESENT)
    {
        p_new_ncl_cell->dtm_supported = p_updated_nrt_cell->dtm_supported;
    }
    /* SPR-10489-fix end */

    /* SPR-10489-fix start */
    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_GERAN_NR_INFO_DTM_SUPPORTED_PRESENT)
    {
        p_new_ncl_cell->dtm_supported = p_updated_nrt_cell->dtm_supported;
    }
    /* SPR-10489-fix end */
    /* SPR 15393 Fix Start */
    if (p_updated_nrt_cell->bitmask &
            RRMCM_RMIF_GERAN_RAC_PRESENT)
    {
        p_new_ncl_cell->rac = p_updated_nrt_cell->rac;
	p_new_ncl_cell->bitmask   |= RRM_GERAN_FREQ_CELL_RAC_PRESENT;
    }
    /* SPR 15393 Fix Stop */


    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrmcm_populate_cdma_nbr_info_hrpd
 * Inputs         : rrmcm_rmif_cdma2000_freq_cells_t *p_new_ncl_cell : pointer to the nbr
 *                  cell in the new updated NCL
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 * Outputs        : None
 * Returns        : None
 * Description    : This function populates the geran nbr cell info in the new NCL
 *                  from the Updated NRT info recvd from SON
 ****************************************************************************/
rrm_void_t
rrmcm_populate_cdma_nbr_info_hrpd(
    rrmcm_rmif_cdma2000_freq_cells_t            *p_new_ncl_cell,
    rrmcm_rmif_cdma_neighbor_cell_hrpd_t        *p_updated_nrt_cell    
)
{
    RRM_UT_TRACE_ENTER();
/*
    p_new_ncl_cell->bsic = (p_updated_nrt_cell->pci.ncc << RRM_THREE) | p_updated_nrt_cell->pci.bscc;

    p_new_ncl_cell->pci = (U16)p_new_ncl_cell->bsic;
*/
    if (p_updated_nrt_cell->bitmask &
            RRM_SON_CDMA_NBR_CELL_HRPD_CSO)
    {
        p_new_ncl_cell->pn_offset = p_updated_nrt_cell->cell_specific_offset;
    }
    /* Start Bug Fix 789 */
    if (p_updated_nrt_cell->bitmask &
            RRM_SON_CDMA_HRPD_CELL_SPECIFIC_PARAMS_PRESENT)
    {
         RRM_MEMCPY(&(p_new_ncl_cell->cell_specific_params),
			&(p_updated_nrt_cell->cell_specific_params),
			sizeof(rrmcm_rmif_cell_specific_params_t));
    }
    /* End Bug Fix 789 */

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrmcm_populate_cdma_nbr_info_xrtt
 * Inputs         : rrmcm_rmif_cdma2000_freq_cells_t *p_new_ncl_cell : pointer to the nbr
 *                  cell in the new updated NCL
 *                  rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info :
 *                      Updated NRT Info received from SON
 * Outputs        : None
 * Returns        : None
 * Description    : This function populates the geran nbr cell info in the new NCL
 *                  from the Updated NRT info recvd from SON
 ****************************************************************************/
rrm_void_t
rrmcm_populate_cdma_nbr_info_xrtt(
    rrmcm_rmif_cdma2000_freq_cells_t            *p_new_ncl_cell,
    rrmcm_rmif_cdma_neighbor_cell_xrtt_t        *p_updated_nrt_cell    
)
{
    RRM_UT_TRACE_ENTER();
/*
    p_new_ncl_cell->bsic = (p_updated_nrt_cell->pci.ncc << RRM_THREE) | p_updated_nrt_cell->pci.bscc;

    p_new_ncl_cell->pci = (U16)p_new_ncl_cell->bsic;
*/
    if (p_updated_nrt_cell->bitmask &
            RRM_SON_CDMA_NBR_CELL_XRTT_CSO)
    {
        p_new_ncl_cell->pn_offset = p_updated_nrt_cell->cell_specific_offset;
    }

    /* Start Bug Fix 789 */
    if (p_updated_nrt_cell->bitmask &
            RRM_SON_CDMA_XRTT_CELL_SPECIFIC_PARAMS_PRESENT)
    {
        RRM_MEMCPY(&(p_new_ncl_cell->cell_specific_params),
			&(p_updated_nrt_cell->cell_specific_params),
			sizeof(rrmcm_rmif_cell_specific_params_t));
    }
    /* End Bug Fix 789 */

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : rrm_compare_geran_cell_id_for_daho
 * Inputs         : rrm_son_utran_geran_global_cell_id_t *p_updated_nrt_cgi : Updated NRT
 *                : rrm_cell_context_t *p_cell_context  : cell context
 * Outputs        : None
 * Returns        : RRM_TRUE if same else RRM_FALSE
 * Description    : This function compares the existing nbrs of the utra freq
 *                : with those recvd in Updated NRT Info for Daho cell.
 ****************************************************************************/

rrm_bool_et
rrm_compare_geran_cell_id_for_daho(
        rrm_son_utran_geran_global_cell_id_t    *p_updated_nrt_cgi,
        rrm_cell_context_t  *p_cell_ctx
        )
{
      rrm_bool_et  ret_val = RRM_FALSE;
    /* SPR-12599-fix start */
    U16          geran_cell_id = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /*Fetch the cell_id from the cell_identity, because cell_identity is a combination of the LAC plus CID */
    geran_cell_id  =  p_updated_nrt_cgi->cell_identity[RRM_THREE] << RRM_EIGHT;
    geran_cell_id |=  p_updated_nrt_cgi->cell_identity[RRM_TWO];

    if ((p_cell_ctx->operator_info.daho_cell_config_info.geran_daho_cell_config_info.cell_id == geran_cell_id)
            &&
            (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.geran_daho_cell_config_info.lai.plmn_identity.mcc),
                         &(p_updated_nrt_cgi->plmn_id.mcc), sizeof(U8) * MAX_MCC_DIGITS))
            &&
            (p_cell_ctx->operator_info.daho_cell_config_info.geran_daho_cell_config_info.lai.plmn_identity.mnc.count ==
             p_updated_nrt_cgi->plmn_id.num_mnc_digit)
            &&
            (!RRM_MEMCMP(&(p_cell_ctx->operator_info.daho_cell_config_info.geran_daho_cell_config_info.lai.plmn_identity.mnc.mnc),
                         &(p_updated_nrt_cgi->plmn_id.mnc), sizeof(U8) * p_updated_nrt_cgi->plmn_id.num_mnc_digit)))

    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Requested cell is a DAHO cell DAHO_CID %d REQUESTED_CELL_CID %d",
                p_cell_ctx->operator_info.daho_cell_config_info.geran_daho_cell_config_info.cell_id,geran_cell_id);
        ret_val = RRM_TRUE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Requested cell is not a DAHO cell DAHO_CID %d REQUESTED_CELL_CID %d",
                p_cell_ctx->operator_info.daho_cell_config_info.geran_daho_cell_config_info.cell_id,geran_cell_id);
    }
    /* SPR-12599-fix end */
    RRM_UT_TRACE_EXIT();

    return ret_val;

}



/****************************************************************************
 * Function Name  : rrmcm_add_mod_geran_freq_nbr_cells_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_geran_neighbor_list_t
 *                      *p_updated_nrt_geran_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_geran_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the geran
 *                  nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the geran nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_mod_geran_freq_nbr_cells_to_updated_list(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_geran_neighbor_list_t        *p_updated_nrt_geran_cell,
    U8                                      existing_geran_nbrs_cnt,
    rrm_bool_et                             blacklist_status,
    U16                                      *bit_mask
)
{
    U8          num_geran_neighs            = RRM_ZERO;
    U8              update_index            = RRM_INVALID_RETURN;
    U8              existing_index          = RRM_ZERO;
    inter_rat_ncl_t *p_new_ncl              = RRM_PNULL;
    U8          i                           = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et is_same                     = RRM_FALSE;
    rrm_son_geran_band_indicator_et son_band_ind = RRM_SON_GERAN_DCS_1800;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;

    num_geran_neighs = p_new_ncl->num_valid_geran_cell;

    /* For each nbr */
    /*Cov_fix_55327*/
    for (i = RRM_ZERO; ((i < p_updated_nrt_geran_cell->cell_list_size) && (i < MAX_NO_GERAN_FREQ_GROUUP)); ++i)
    {
        /*SPR_11293_FIX_START */
        update_index = RRM_INVALID_RETURN;
        /*SPR_11293_FIX_END */
    /*Cov_fix_55327*/    
       
        if (RRM_TRUE !=   rrm_compare_geran_cell_id_for_daho(&p_updated_nrt_geran_cell->cell_list[i].cgi,p_cell_context))
        {
        /*spr_19395_changes_start*/
		/*As per 3GPP, 36.413, LAC value as 0000 or FFFE are invalid
		*/
		if(((p_updated_nrt_geran_cell->cell_list[i].cgi.cell_identity[RRM_ZERO] == RRM_ZERO) &&
					(p_updated_nrt_geran_cell->cell_list[i].cgi.cell_identity[RRM_ONE] == RRM_ZERO)) ||
				((p_updated_nrt_geran_cell->cell_list[i].cgi.cell_identity[RRM_ZERO] == 0xFE) &&
				 (p_updated_nrt_geran_cell->cell_list[i].cgi.cell_identity[RRM_ONE] == 0xFF)))
		{
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
					"Invalid LAC information received for GERAN cell from SON");
			continue;
		}
		/*spr_19395_changes_end*/
        /* Traverse the  new built list to search the nbr in already existing nbrs */
        for(existing_index = RRM_ZERO; existing_index < existing_geran_nbrs_cnt;
                existing_index++)
        {
            /* Spr 16211 Changes Start*/
            /* if condition Removed */
            /* Spr 16211 Changes End*/
                is_same = rrmcm_compare_geran_nbr(&p_updated_nrt_geran_cell->cell_list[i].cgi,
                    &p_new_ncl->geran_freq_cells[existing_index]);

                if(RRM_TRUE == is_same)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Geran Nbr cell to be modified");
                    /* Modification case */
                    update_index = existing_index;
                    break;
                }
              /* Spr 16211 Changes Start*/
              /* if end braces Removed */
              /* Spr 16211 Changes End*/
        }
        /* If not Found */
        if(RRM_INVALID_RETURN == update_index)
        {
/* 18031_CHANGES_START */
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                     "Geran Nbr cell to be added at index [%d]", num_geran_neighs);
/* 18031_CHANGES_END */
            /* Addition case */
            if(num_geran_neighs < RRM_MAX_GERAN_NBRS)
            {
		/*function added to remove typecast warning, , rel2.0.1*/
		son_band_ind = rrm_map_son_band_ind_val(p_updated_nrt_geran_cell->band_ind);	
                S16 freq_index = rrmcm_search_geran_arfcn_in_cell_context(p_cell_context,
                        p_updated_nrt_geran_cell->arfcn, son_band_ind);
                if (FREQ_NOT_CONFIGURED != freq_index)
                {
                    update_index = num_geran_neighs;
                    rrmcm_copy_geran_nbr_info(&p_updated_nrt_geran_cell->cell_list[i].cgi,
                        &p_new_ncl->geran_freq_cells[update_index]);
                    /* Spr 16211 Changes Start */
                   rrmcm_populate_geran_nbr_info(
                    &p_new_ncl->geran_freq_cells[update_index],
                    &p_updated_nrt_geran_cell->cell_list[i]);

                    p_new_ncl->geran_freq_cells[update_index].bcch_arfcn =
                        p_updated_nrt_geran_cell->arfcn;

                    p_new_ncl->geran_freq_cells[update_index].band_indicator =
                        p_updated_nrt_geran_cell->band_ind;

                    p_new_ncl->geran_freq_cells[update_index].blacklisted = blacklist_status;
                    /* Spr 16211 Changes End */

                    num_geran_neighs++;
                }
                else
                {
                    ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_ERROR, "Freq NOT configured. Invalid nbr");
                }
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR, "Max list size reached. cannot add");
            }
        }
        if(RRM_SUCCESS == ret_val)
        {
            rrmcm_populate_geran_nbr_info(
                    &p_new_ncl->geran_freq_cells[update_index],
                    &p_updated_nrt_geran_cell->cell_list[i]);

            p_new_ncl->geran_freq_cells[update_index].bcch_arfcn =
                p_updated_nrt_geran_cell->arfcn;

            p_new_ncl->geran_freq_cells[update_index].band_indicator =
                p_updated_nrt_geran_cell->band_ind;

            p_new_ncl->geran_freq_cells[update_index].blacklisted = blacklist_status;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Nbr cell updated at index = %d for Geran freq = %d with blacklist status = %d",
                update_index, p_new_ncl->geran_freq_cells[update_index].bcch_arfcn, blacklist_status);

            *bit_mask |= RRM_GERAN_NBRS_UPDATED;
        }
     }
     else
     {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "LTE Geran NBR cell id matched with DAHO cell id");
     }
    }
    p_new_ncl->num_valid_geran_cell = num_geran_neighs;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}



/****************************************************************************
 * Function Name  : rrmcm_add_mod_geran_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function scans the geran add mod nbr list rcvd
 *                  in Updated NRT and calls the respective handler to add/mod
 *                  each nbr
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_geran_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U8                              existing_geran_nbrs_cnt, 
    U16                              *bit_mask
    )
{
    U8          add_mod_geran_neigh_cnt     = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Traverse updated NRT info to add/update each geran nbr */
    for (add_mod_geran_neigh_cnt = RRM_ZERO;
            (add_mod_geran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.
             geran_neighbor_list.cells_to_add_mod_list_size) &&
            (add_mod_geran_neigh_cnt < MAX_NO_GERAN_FREQ_GROUUP); ++add_mod_geran_neigh_cnt)
    {
        rrmcm_add_mod_geran_freq_nbr_cells_to_updated_list(p_cell_context,
            &p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
            cells_to_add_mod_list[add_mod_geran_neigh_cnt],
            existing_geran_nbrs_cnt, RRM_FALSE, bit_mask);
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrmcm_add_mod_geran_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function scans the geran add mod Blacklisted nbr list rcvd
 *                  in Updated NRT and calls the respective handler to add/mod
 *                  each Blacklisted nbr
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_geran_bl_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U8                               existing_geran_nbrs_cnt,
    /*15011_start*/
    U16                              *bit_mask
    /*15011_end*/
    )
{
    U8          add_mod_geran_neigh_cnt     = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Traverse updated NRT info to add/update each geran nbr */
    for (add_mod_geran_neigh_cnt = RRM_ZERO;
            (add_mod_geran_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.
             geran_neighbor_list.black_list_cells_to_add_mod_list_size) &&
            (add_mod_geran_neigh_cnt < MAX_NO_GERAN_FREQ_GROUUP); ++add_mod_geran_neigh_cnt)
    {
        rrmcm_add_mod_geran_freq_nbr_cells_to_updated_list(p_cell_context,
            &p_updated_nrt_info->inter_rat_ncl.geran_neighbor_list.
            black_list_cells_to_add_mod_list[add_mod_geran_neigh_cnt],
            existing_geran_nbrs_cnt, RRM_TRUE, bit_mask);
    }

    RRM_UT_TRACE_EXIT();
}
/*klock_works_changes_start*/
/****************************************************************************
 * Function Name  : rrmcm_check_the_vailidity_of_updated_index 
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_cdma_neighbor_list_t
 *                      *p_updated_nrt_cdma_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_cdma_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the cdma
 *                  nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the cdma nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/

rrm_return_et
rrmcm_check_the_vailidity_of_updated_index
(
 rrm_cell_context_t                      *p_cell_context,
 inter_rat_ncl_t                         *p_new_ncl,
 U8                                      *update_index,
 rrmcm_rmif_cdma_neighbor_list_xrtt_t    *p_updated_nrt_cdma_cell,
 U8                                       i
 )
{
    U8            num_cdma_neighs    = RRM_ZERO;
    rrm_return_et ret_val            = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;
    num_cdma_neighs = p_new_ncl->num_valid_cdma2000_freq_cells;

    if(RRM_INVALID_RETURN == *update_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "CDMA XRTT Nbr cell to be added");
        /* Addition case */
        if(num_cdma_neighs < RRM_MAX_CDMA_1X_RTT_NBRS)
        {
            U8  cdma_type  = RRM_OAM_NCL_TYPE_1XRTT;
            S16 freq_index = rrmcm_search_cdma_arfcn_in_cell_context_in_ncl_params(p_cell_context,
                    p_updated_nrt_cdma_cell->cell_list[i].arfcn,
                    p_updated_nrt_cdma_cell->band_class);
            if (FREQ_NOT_CONFIGURED != freq_index)
            {
                *update_index = num_cdma_neighs;
                rrmcm_copy_cdma_nbr_info(&p_updated_nrt_cdma_cell->cell_list[i].cgi,
                        &p_new_ncl->cdma2000_freq_cells[*update_index], cdma_type);

                num_cdma_neighs++;
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR, "Freq NOT configured. Invalid nbr");
            }
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR, "Max list size reached. cannot add");
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/*klock_works_changes_end*/


/****************************************************************************
 * Function Name  : rrmcm_add_mod_cdma_freq_nbr_cells_to_updated_list_xrtt
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_cdma_neighbor_list_t
 *                      *p_updated_nrt_cdma_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_cdma_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the cdma
 *                  nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the cdma nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_mod_cdma_freq_nbr_cells_to_updated_list_xrtt(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_cdma_neighbor_list_xrtt_t    *p_updated_nrt_cdma_cell,
    U8                                      existing_cdma_nbrs_cnt,
    /*15011_start*/
    U16                              *bit_mask
    /*15011_end*/
)
{
    U8          num_cdma_neighs            = RRM_ZERO;
    U8              update_index            = RRM_INVALID_RETURN;
    U8              existing_index          = RRM_ZERO;
    inter_rat_ncl_t *p_new_ncl              = RRM_PNULL;
    U8          i                           = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et is_same                     = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;

    num_cdma_neighs = p_new_ncl->num_valid_cdma2000_freq_cells;

    /* For each nbr */
    for (i = RRM_ZERO; i < p_updated_nrt_cdma_cell->cell_list_size; ++i)
    {
        /* Traverse the  new built list to search the nbr in already existing nbrs */
        for(existing_index = 0; existing_index < existing_cdma_nbrs_cnt;
                existing_index++)
        {
            if (p_new_ncl->cdma2000_freq_cells[existing_index].type == RRM_OAM_NCL_TYPE_1XRTT )
            {
                is_same = rrmcm_compare_cdma_nbr(&p_updated_nrt_cdma_cell->cell_list[i].cgi,
                    &p_new_ncl->cdma2000_freq_cells[existing_index]);

                if(RRM_TRUE == is_same)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CDMA Nbr cell to be modified");
                    /* Modification case */
                    update_index = existing_index;
                    break;
                }
		else
		{
			update_index = RRM_INVALID_RETURN; 
		}
            }
        }


        /* If not Found */

        /*klock_works_changes_start*/

        ret_val=rrmcm_check_the_vailidity_of_updated_index(p_cell_context, p_new_ncl, &update_index, p_updated_nrt_cdma_cell, i);

        /*klock_works_changes_end*/

        if(RRM_SUCCESS == ret_val)
        {
            rrmcm_populate_cdma_nbr_info_xrtt(
                    &p_new_ncl->cdma2000_freq_cells[update_index],
                    &p_updated_nrt_cdma_cell->cell_list[i]);

            p_new_ncl->cdma2000_freq_cells[update_index].arfcn =
                p_updated_nrt_cdma_cell->cell_list[i].arfcn;

            p_new_ncl->cdma2000_freq_cells[update_index].band_class =
                p_updated_nrt_cdma_cell->band_class;

            /* Start 7514 NRT Fix - SIB 8 */
            p_new_ncl->cdma2000_freq_cells[update_index].pn_offset =
                p_updated_nrt_cdma_cell->cell_list[i].pci;
            /* End 7514 NRT Fix - SIB 8 */

            /* Bug Fix 787 */
	    p_new_ncl->cdma2000_freq_cells[update_index].type = RRM_OAM_NCL_TYPE_1XRTT;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Nbr cell updated at index = %d for CDMA freq = %d ",
                update_index, p_new_ncl->cdma2000_freq_cells[update_index].arfcn);

            *bit_mask |= RRM_CDMA_NBRS_UPDATED;
        }
    }
    p_new_ncl->num_valid_cdma2000_freq_cells = num_cdma_neighs;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*klock_works_changes_start*/
/****************************************************************************
 * Function Name  : rrmcm_check_for_update_index_invalid
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_cdma_neighbor_list_t
 *                      *p_updated_nrt_cdma_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_cdma_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the cdma
 *                  nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the geran nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/

rrm_return_et
rrmcm_check_for_update_index_invalid
(
 rrm_cell_context_t                    *p_cell_context,
 U8                                    *update_index,
 inter_rat_ncl_t                       *p_new_ncl,
 rrmcm_rmif_cdma_neighbor_list_hrpd_t  *p_updated_nrt_cdma_cell,
 U8                                     i
)
{
    U8              num_cdma_neighs   = RRM_ZERO;
    rrm_return_et   ret_val           = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    num_cdma_neighs = p_new_ncl->num_valid_cdma2000_freq_cells;

    if(RRM_INVALID_RETURN == *update_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "CDMA HRPD Nbr cell to be added");
        /* Addition case */
        if(num_cdma_neighs < RRM_MAX_CDMA_HRPD_NBRS)
        {
            U8  cdma_type  = RRM_OAM_NCL_TYPE_HRPD;
            S16 freq_index = rrmcm_search_cdma_arfcn_in_cell_context_in_ncl_params(p_cell_context,
                    p_updated_nrt_cdma_cell->cell_list[i].arfcn,
                    p_updated_nrt_cdma_cell->band_class);

            if (FREQ_NOT_CONFIGURED != freq_index)
            {
                *update_index = num_cdma_neighs;
                rrmcm_copy_cdma_nbr_info(&p_updated_nrt_cdma_cell->cell_list[i].cgi,
                        &p_new_ncl->cdma2000_freq_cells[*update_index], cdma_type);

                num_cdma_neighs++;
            }
            else
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR, "Freq NOT configured. Invalid nbr");
            }
        }
        else
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR, "Max list size reached. cannot add");
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_end*/
/****************************************************************************
 * Function Name  : rrmcm_add_mod_cdma_freq_nbr_cells_to_updated_list_hrpd
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_cdma_neighbor_list_t
 *                      *p_updated_nrt_cdma_cell: pointer to the intra
 *                  rat cell info recvd in Updated NRT from SON
 *                  existing_cdma_nbrs_cnt : Count of existing nbrs of the
 *                  cell minus no. of nbs in remove list of Add/Mod or Blacklist
 *                  U8 *bit_mask : indicates if there is a change in the cdma
 *                  nbr list
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function searches the geran nbr rcvd in Updated NRT
 *                  in the existing list copied to new NCL for modification.
 *                  If not found, adds it to the new ncl
 ****************************************************************************/
rrm_return_et
rrmcm_add_mod_cdma_freq_nbr_cells_to_updated_list_hrpd(
    rrm_cell_context_t                      *p_cell_context,
    rrmcm_rmif_cdma_neighbor_list_hrpd_t    *p_updated_nrt_cdma_cell,
    U8                                      existing_cdma_nbrs_cnt,
    /*15011_start*/
    U16                              *bit_mask
    /*15011_end*/
)
{
    U8          num_cdma_neighs            = RRM_ZERO;
    U8              update_index            = RRM_INVALID_RETURN;
    U8              existing_index          = RRM_ZERO;
    inter_rat_ncl_t *p_new_ncl              = RRM_PNULL;
    U8          i                           = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et is_same                     = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_new_ncl = &p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;

    num_cdma_neighs = p_new_ncl->num_valid_cdma2000_freq_cells;

    /* For each nbr */
    for (i = RRM_ZERO; i < p_updated_nrt_cdma_cell->cell_list_size; ++i)
    {
        /* Traverse the  new built list to search the nbr in already existing nbrs */
        for(existing_index = 0; existing_index < existing_cdma_nbrs_cnt;
                existing_index++)
        {
            if (p_new_ncl->cdma2000_freq_cells[existing_index].type == RRM_OAM_NCL_TYPE_HRPD )
            {
                is_same = rrmcm_compare_cdma_nbr(&p_updated_nrt_cdma_cell->cell_list[i].cgi,
                    &p_new_ncl->cdma2000_freq_cells[existing_index]);

                if(RRM_TRUE == is_same)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "CDMA Nbr cell to be modified");
                    /* Modification case */
                    update_index = existing_index;
                    break;
                }
		else
		{
		    update_index = RRM_INVALID_RETURN;
                }
            }
        }

        /* If not Found */
        /*klock_works_changes_start*/
        ret_val = rrmcm_check_for_update_index_invalid(p_cell_context, &update_index, p_new_ncl, p_updated_nrt_cdma_cell, i);
        /*klock_works_changes_end*/

        if(RRM_SUCCESS == ret_val)
        {
            rrmcm_populate_cdma_nbr_info_hrpd(
                    &p_new_ncl->cdma2000_freq_cells[update_index],
                    &p_updated_nrt_cdma_cell->cell_list[i]);

            p_new_ncl->cdma2000_freq_cells[update_index].arfcn =
                p_updated_nrt_cdma_cell->cell_list[i].arfcn;

            p_new_ncl->cdma2000_freq_cells[update_index].band_class =
                p_updated_nrt_cdma_cell->band_class;

            /* Start 7514 NRT Fix - SIB 8 */
            p_new_ncl->cdma2000_freq_cells[update_index].pn_offset =
                p_updated_nrt_cdma_cell->cell_list[i].pci;
            /* End 7514 NRT Fix - SIB 8 */

            /* Bug Fix 787 */
	    p_new_ncl->cdma2000_freq_cells[update_index].type = RRM_OAM_NCL_TYPE_HRPD;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Nbr cell updated at index = %d for CDMA freq = %d ",
                update_index, p_new_ncl->cdma2000_freq_cells[update_index].arfcn);

            *bit_mask |= RRM_CDMA_NBRS_UPDATED;
        }
    }
    p_new_ncl->num_valid_cdma2000_freq_cells = num_cdma_neighs;

    RRM_UT_TRACE_EXIT();

    return ret_val;
}



/****************************************************************************
 * Function Name  : rrmcm_add_mod_cdma_nbrs_to_updated_list
 * Inputs         : rrm_cell_context_t *p_cell_context  : cell context
 *                  rrmcm_rmif_updated_nrt_info_t
 *                      *p_updated_nrt_info: pointer to the Updated NRT from SON
 *                  U8 *bit_mask : indicates if there is a change in the intra-
 *                  rat nbr list
 * Outputs        : None
 * Returns        : None
 * Description    : This function scans the geran add mod nbr list rcvd
 *                  in Updated NRT and calls the respective handler to add/mod
 *                  each nbr
 ****************************************************************************/
rrm_void_t
rrmcm_add_mod_cdma_nbrs_to_updated_list(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    U8                              existing_cdma_nbrs_cnt, 
    /*15011_start*/
    U16                              *bit_mask
    /*15011_end*/
    )
{
    U8          add_mod_cdma_neigh_cnt     = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* Traverse updated NRT info to add/update each CDMA XRTT nbr */
    if(p_updated_nrt_info->inter_rat_ncl.bitmask & RRMCM_RMIF_CDMA_NR_LIST_XRTT_PRESENT )
    {
        for (add_mod_cdma_neigh_cnt = RRM_ZERO;
                (add_mod_cdma_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.
                 cdma_neighbor_list_xrtt.cells_to_add_mod_list_size) &&
                (add_mod_cdma_neigh_cnt < MAX_NO_CDMA_FREQ_GROUUP); ++add_mod_cdma_neigh_cnt)
        {
           
            rrmcm_add_mod_cdma_freq_nbr_cells_to_updated_list_xrtt(p_cell_context,
                &p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_xrtt.
                cells_to_add_mod_list[add_mod_cdma_neigh_cnt],
                existing_cdma_nbrs_cnt, bit_mask);

        }
    }
//cdma_neighbor_list_xrtt.cells_to_add_mod_list[add_mod_cdma_neigh_cnt];
    /* Traverse updated NRT info to add/update each CDMA HRPD nbr */
    if(p_updated_nrt_info->inter_rat_ncl.bitmask & RRMCM_RMIF_CDMA_NR_LIST_HRPD_PRESENT )
    {
        for (add_mod_cdma_neigh_cnt = RRM_ZERO;
                (add_mod_cdma_neigh_cnt < p_updated_nrt_info->inter_rat_ncl.
                 cdma_neighbor_list_hrpd.cells_to_add_mod_list_size) &&
                (add_mod_cdma_neigh_cnt < MAX_NO_CDMA_FREQ_GROUUP); ++add_mod_cdma_neigh_cnt)
        {
            
            rrmcm_add_mod_cdma_freq_nbr_cells_to_updated_list_hrpd(p_cell_context,
                &p_updated_nrt_info->inter_rat_ncl.cdma_neighbor_list_hrpd.
                cells_to_add_mod_list[add_mod_cdma_neigh_cnt],
                existing_cdma_nbrs_cnt, bit_mask);
        }
    }
    RRM_UT_TRACE_EXIT();
}





/****************************************************************************
 *   FUNCTION NAME       :  rrmcm_prepare_inter_rat_neighbors_info_from_nrt 
 *
 *   DESCRIPTION :
 *      This function restructures Inter-RAT neighbors info based on nrt received from
 *      SON
 *
 *   RETURNS     : None
 *
 *****************************************************************************/
rrm_void_t
rrmcm_prepare_inter_rat_neighbors_info_from_nrt
(
    rrm_cell_context_t              *p_cell_context,
    rrmcm_rmif_updated_nrt_info_t   *p_updated_nrt_info,
    /*15011_start*/
    U16                              *bit_mask
    /*15011_end*/
 )
{
    U8          existing_utran_nbrs_cnt     = RRM_ZERO;
    U8          existing_geran_nbrs_cnt     = RRM_ZERO;
    U8          existing_cdma_nbrs_cnt     = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if ((p_cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT) &&
        (p_cell_context->ran_info.ncl_params.bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT))
    {
        /* Copy existing nbrs to the new nbr list (excluding the nbrs present in remove list of
           Updated NRT info) */
        if(RRM_ZERO < p_cell_context->ran_info.ncl_params.inter_rat_ncl.num_valid_utran_freq_cell)
        {
            rrmcm_copy_existing_utran_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask);
        }
        if(RRM_ZERO < p_cell_context->ran_info.ncl_params.inter_rat_ncl.num_valid_geran_cell)
        {
            rrmcm_copy_existing_geran_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask);
        }
        if(RRM_ZERO < p_cell_context->ran_info.ncl_params.inter_rat_ncl.num_valid_cdma2000_freq_cells)
        {
            rrmcm_copy_existing_cdma_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask);
        }
    }

    if(p_updated_nrt_info->inter_rat_ncl.bitmask & RRMCM_RMIF_UTRAN_NR_LIST_PRESENT)
    {
        /* existing nbrs which are not present in remove lists of updated NRT */
        existing_utran_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
            inter_rat_ncl.num_valid_utran_freq_cell;

        rrmcm_add_mod_utran_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, existing_utran_nbrs_cnt, bit_mask);
        rrmcm_add_mod_utran_bl_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, existing_utran_nbrs_cnt, bit_mask);
    }

    if(p_updated_nrt_info->inter_rat_ncl.bitmask & RRMCM_RMIF_GERAN_NR_LIST_PRESENT)
    {
        existing_geran_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
            inter_rat_ncl.num_valid_geran_cell;

        rrmcm_add_mod_geran_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, existing_geran_nbrs_cnt, bit_mask);
        rrmcm_add_mod_geran_bl_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, existing_geran_nbrs_cnt, bit_mask);
    }

    if(p_updated_nrt_info->inter_rat_ncl.bitmask & RRMCM_RMIF_CDMA_NR_LIST_XRTT_PRESENT ||
       p_updated_nrt_info->inter_rat_ncl.bitmask & RRMCM_RMIF_CDMA_NR_LIST_HRPD_PRESENT  )
    {
        existing_cdma_nbrs_cnt = p_cell_context->p_ncl_built_from_updated_nrt_info->
            inter_rat_ncl.num_valid_cdma2000_freq_cells;

        rrmcm_add_mod_cdma_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, existing_cdma_nbrs_cnt, bit_mask);
        //rrmcm_add_mod_cdma_bl_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, existing_cdma_nbrs_cnt, bit_mask);
        //the above function is commented because ,there is not any concept for blacklisted arfcn.
    }

    if((p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_utran_freq_cell) ||
        (p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_geran_cell)||
        (p_cell_context->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_cdma2000_freq_cells) 
        )
    {
        p_cell_context->p_ncl_built_from_updated_nrt_info->bitmask |= RRMCM_RMIF_INTER_RAT_NCL_PRESENT;
    }
        
    RRM_UT_TRACE_EXIT();
}
    
/****************************************************************************
 *   FUNCTION NAME       :   prepare_inter_intra_neighbors_info_from_nrt
 *
 *   DESCRIPTION :
 *      This function restructures neighbors info based on nrt received from
 *      SON
 *
 *   RETURNS     : RRM_SUCCESS/RRM_FAILURE
 *       
 *****************************************************************************/
rrm_return_et
prepare_inter_intra_neighbors_info_from_nrt
(
 rrm_cell_context_t *p_cell_context, 
  /*15011_start*/
  U16                              *bit_mask,
 /*15011_end*/
 rrm_bool_et        *p_reconfig_req
 )
{
    rrmcm_rmif_updated_nrt_info_t  *p_updated_nrt_info = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_context->p_ncl_built_from_updated_nrt_info = rrm_mem_get(sizeof(ncl_params_t));
    if (p_cell_context->p_ncl_built_from_updated_nrt_info == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_context->p_ncl_built_from_updated_nrt_info failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }

    RRM_MEMSET(p_cell_context->p_ncl_built_from_updated_nrt_info, RRM_ZERO, sizeof(ncl_params_t));

    p_updated_nrt_info = (rrmcm_rmif_updated_nrt_info_t *)p_cell_context->p_incoming_api_info;

    if((p_cell_context->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT) &&
        (p_cell_context->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT))
    {
        /* Copy existing nbrs to the new nbr list (excluding the nbrs present in remove list of 
           Updated NRT info) */
        rrmcm_copy_existing_intra_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask, p_reconfig_req);
        rrmcm_copy_existing_inter_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask, p_reconfig_req);
    }

    rrmcm_add_mod_intra_rat_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask, p_reconfig_req);

    rrmcm_add_mod_intra_rat_bl_nbrs_to_updated_list(p_cell_context, p_updated_nrt_info, bit_mask, p_reconfig_req);

    if(p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell ||
        p_cell_context->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_inter_freq_cell)
    {
        p_cell_context->p_ncl_built_from_updated_nrt_info->bitmask |= RRMCM_RMIF_LTE_NCL_PRESENT;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "LTE_NCL present in new NCL list");
    }

    rrmcm_prepare_inter_rat_neighbors_info_from_nrt(p_cell_context, p_updated_nrt_info, bit_mask);

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : commit_reconfig_param_for_nrt
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the nrt parameters in cell context
 ****************************************************************************/
rrm_void_t
commit_reconfig_param_for_nrt
(
 rrm_cell_context_t *p_cell_ctx
 )
{
    /*SPR 16494 START*/
    /*code deleted*/
    /*SPR 16494 END*/
    /*SPR 16494 START*/
    rrm_enb_gu_group_id_node_t *p_enb_id_node = RRM_PNULL;
    /*SPR 16494 END */
#ifdef LTE_EMBMS_SUPPORTED
    U8 index            = RRM_ZERO;
#endif

    RRM_UT_TRACE_ENTER();
    /* Spr 16211 Changes Start*/
    if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
    {
        inter_rat_ncl_t *p_inter_rat_ncl_added = RRM_PNULL;
        inter_rat_ncl_t *p_inter_rat_ncl_deleted = RRM_PNULL;
    p_inter_rat_ncl_added = (inter_rat_ncl_t *)rrm_mem_get(sizeof(inter_rat_ncl_t));
    if(RRM_PNULL == p_inter_rat_ncl_added)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_inter_rat_ncl_added failed" );
        RRM_UT_TRACE_EXIT();
        /* Coverity_Fix 96504 ++ */
        return; 
        /* Coverity_Fix 96504 -- */

    }
    p_inter_rat_ncl_deleted = (inter_rat_ncl_t *)rrm_mem_get(sizeof(inter_rat_ncl_t));
    if(RRM_PNULL == p_inter_rat_ncl_deleted)
    {

        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_inter_rat_ncl_deleted failed" );
        RRM_MEM_FREE(p_inter_rat_ncl_added);
        RRM_UT_TRACE_EXIT();
        /* Coverity_Fix 96503 ++ */
        return;
        /* Coverity_Fix 96503 -- */

    }
    rrm_get_delta_ncl_from_updated_nrt(p_cell_ctx,p_inter_rat_ncl_added,p_inter_rat_ncl_deleted); 

    if((RRM_ZERO < p_inter_rat_ncl_deleted->num_valid_geran_cell)||
            (RRM_ZERO < p_inter_rat_ncl_deleted->num_valid_utran_freq_cell))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Sending RIM info req with STOP to Deleted interrat nbr");
        rrm_request_rim_info_req(p_cell_ctx, p_inter_rat_ncl_deleted, RAN_INFO_REQ_STOP);
    }
    if((RRM_ZERO < p_inter_rat_ncl_added->num_valid_geran_cell)||
            (RRM_ZERO < p_inter_rat_ncl_added->num_valid_utran_freq_cell))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Sending RIM info req with Start to newly added inter rat nbr ");
        rrm_request_rim_info_req(p_cell_ctx,p_inter_rat_ncl_added, RAN_INFO_REQ_MULTI_REPORT);
    }
    RRM_MEM_FREE(p_inter_rat_ncl_added);
    RRM_MEM_FREE(p_inter_rat_ncl_deleted);
    }
    /* Spr 16211 Changes End*/

    /* eICIC_PHASE_1_2_CHANGES_START */
    rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
    /* eICIC_PHASE_1_2_CHANGES_END */
    RRM_MEMCPY(&p_cell_ctx->ran_info.ncl_params,
            p_cell_ctx->p_ncl_built_from_updated_nrt_info,
            sizeof(ncl_params_t));
    /*SPR 21192 Fix Start*/
    rrmcm_check_updated_ncl_for_csg_id_and_bl_change(p_cell_ctx, p_cell_ctx->updated_nrt_bitmask);
    /*SPR 21192 Fix Stop*/

    if ((p_cell_ctx->p_ncl_built_from_updated_nrt_info->bitmask & RRMCM_RMIF_LTE_NCL_PRESENT) ||
            (p_cell_ctx->p_ncl_built_from_updated_nrt_info->bitmask & RRMCM_RMIF_INTER_RAT_NCL_PRESENT))
    {
        p_cell_ctx->ran_info.bitmask |= RRMCM_RMIF_NCL_PARAMS_PRESENT;
    }
    /*SPR 10329:start*/
    /*SPR 10329:fix start*/
    /*checks the neighbouring cell enb_id's with the list present in global_context*/
    /*SPR 16494 START*/
    /*code deleted*/
    /*SPR 16494 END*/
    /*SPR 16494 START*/
    p_enb_id_node = (rrm_enb_gu_group_id_node_t*)ylFirst (&p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);
    while(p_enb_id_node)
    {
       updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_FALSE);
       p_enb_id_node = (rrm_enb_gu_group_id_node_t*)ylNext(&p_enb_id_node->s_node);
    }
    /*SPR 16494 END*/
    /*SPR 10329:fix end*/
    /*SPR 10329:end*/
    /*SPR_11797:start*/
    if((RRM_PNULL != p_cell_ctx->p_new_reconfig_data) &&
            (RRM_PNULL != (rrmcm_rmif_cell_reconfig_req_t *)&(p_cell_ctx->p_new_reconfig_data)->operator_info))
        /*SPR_11797:end*/
    {
        RRM_MEMCPY(&(p_cell_ctx->operator_info.sib_1_info.scheduling_info_list),
                &p_cell_ctx->p_new_reconfig_data->operator_info.sib_1_info.scheduling_info_list,
                sizeof(rrm_scheduling_info_list_t));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Updated Scheduling Info in Cell Context");
    }

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED, "reconfig: updated ncl info in cell ctx");
    /* MLB Start */
    rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx, p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
    /* MLB End */

#ifdef LTE_EMBMS_SUPPORTED

    /*Commit neigh cell config to cell context*/
    if (MBMS_SIB_3_SCHEDULE_BROADCAST & p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status)
    {
        p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.neigh_cell_config =
            p_cell_ctx->rrm_cell_embms_data.neigh_cell_config; 

        p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast |= MBMS_SIB_3_ON_BROADCAST; 
        if (!(MBMS_SIB_5_SCHEDULE_BROADCAST & 
                    p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status))
        {
            p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status = RRM_ZERO;        
        }
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "Committing neigh_cell_config[%d] to cell context for updated_nrt",
                p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.neigh_cell_config);
    }
    /*SIB5 Commit*/
    if (MBMS_SIB_5_SCHEDULE_BROADCAST & 
            p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status)
    {
        p_cell_ctx->rrm_cell_embms_data.mbms_broadcast_status = RRM_ZERO;        
        for (index = RRM_ZERO; 
                index < p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                num_valid_inter_freq_list; index++)
        {
            p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_freq_params[index].neigh_cell_config =
                p_cell_ctx->rrm_cell_embms_data.inter_cell_neigh_cell_config[index];
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Storing neigh_cell_config[%d] IE in cell_context for index [%d]",
                    p_cell_ctx->ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_freq_params[index].neigh_cell_config, index);
        }

    }

#endif

    RRM_UT_TRACE_EXIT();
}

/* SPR 16406 Start */
/****************************************************************************
 * Function Name  : rrm_cellm_send_ho_required_for_awaited_ue_to_uem 
 * Inputs         : ho_pending_cgi_node_data
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS\RRM_FAILURE 
 * Description    : This function sends an IND msg to UEM to trigger 
 *                  HO for awaited UE kept in cgi pending list 
 ****************************************************************************/

rrm_return_et
rrm_cellm_send_ho_required_for_awaited_ue_to_uem
(
    ho_pending_cgi_node_data_t ho_pending_cgi_node_data,
    rrm_cell_index_t cell_index
)
{
    rrm_return_et ret_val = RRM_FAILURE;
    rrm_cellm_uem_ho_trigger_ind_t *p_rrm_ho_trigger_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_rrm_ho_trigger_ind = rrm_mem_get(sizeof(rrm_cellm_uem_ho_trigger_ind_t));
    if(RRM_PNULL == p_rrm_ho_trigger_ind)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_rrm_ho_trigger_ind failed" );
        RRM_UT_TRACE_EXIT();
        return ret_val;

    }
    
    p_rrm_ho_trigger_ind->pci = ho_pending_cgi_node_data.pci;
    p_rrm_ho_trigger_ind->earfcn = ho_pending_cgi_node_data.earfcn;
    p_rrm_ho_trigger_ind->cell_index = cell_index;
    /* SPR 16406 18sep Start */
    if(RRM_HO_PENDING_NODE_CGI_PRESENT & ho_pending_cgi_node_data.bitmask)
    {
	    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
			    "CGI pending node with confused pci is encountered" );
	    p_rrm_ho_trigger_ind->bitmask = RRM_UEM_HO_TRIGGER_IND_CGI_PRESENT; 
	    RRM_MEMCPY(&(p_rrm_ho_trigger_ind->cgi),
			    &(ho_pending_cgi_node_data.cgi),
			    sizeof(rrm_oam_eutran_global_cell_id_t));
    }
    /* SPR 16406 18sep End */
    /* SPR 16406 24Sep Start */
    else
    {
	    p_rrm_ho_trigger_ind->bitmask = RRM_ZERO; 
    }
    /* SPR 16406 24Sep End */

    ret_val = rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
            RRMUEM_CM_AWAITED_HO_TRIGGER_IND,
            sizeof(rrm_cellm_uem_ho_trigger_ind_t),
            (void *)p_rrm_ho_trigger_ind);
    RRM_MEM_FREE(p_rrm_ho_trigger_ind);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_check_cgi_pending_list_for_ho 
 * Inputs         : p_cell context
 * Outputs        : None
 * Returns        : None 
 * Description    : checks for UE pending for HO due to CGI procedure 
 *                  and sends HO required for all of the selected UE's
 ****************************************************************************/
rrm_void_t
    rrm_check_cgi_pending_list_for_ho
(
 rrm_cell_context_t *p_cell_context
)
{
    U16 cgi_node_count = RRM_ZERO;
    rrm_counter_t index = RRM_ZERO;
    rrm_bool_et cgi_node_found = RRM_FALSE;
    ho_pending_cgi_node_t *p_temp_cgi_pending_node = RRM_PNULL;
    YLIST ho_pending_cgi_list;


    RRM_UT_TRACE_ENTER();
    ylInit(&ho_pending_cgi_list);

    /* Assigning to actual list kept in cell context */
    ho_pending_cgi_list = p_cell_context->rrm_cgi_pending_list.
        rrm_ho_pending_cgi_list[p_cell_context->cell_index].ho_pending_cgi_list;

    cgi_node_count = ylCount(&ho_pending_cgi_list);

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
            "present count in ho cgi pending list :%u for cell[%u]",
            cgi_node_count,p_cell_context->cell_index);

    if(cgi_node_count)
    {
        p_temp_cgi_pending_node = (ho_pending_cgi_node_t *)ylFirst(&ho_pending_cgi_list);
        while(p_temp_cgi_pending_node)
        {
            if(p_cell_context->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT)
            {
                if(p_temp_cgi_pending_node->ho_pending_cgi_node_data.earfcn == 
                        p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
                {
                    for(index = RRM_ZERO;index< 
                            (p_cell_context->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell);index++)
                    {
                        if(p_temp_cgi_pending_node->ho_pending_cgi_node_data.pci ==
                                p_cell_context->ran_info.ncl_params.lte_ncl.intra_freq_cells[index].phy_cell_id)
                        {
                            cgi_node_found = RRM_TRUE;
                            break;    
                        }
                    }
                }
                else 
                {
                    for(index = RRM_ZERO;index < 
                            (p_cell_context->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell);index++)
                    {
                        /* SPR 16406 10SEP start */
                        if((p_temp_cgi_pending_node->ho_pending_cgi_node_data.pci ==
                                p_cell_context->ran_info.ncl_params.lte_ncl.inter_freq_cells[index].phy_cell_id) &&
                                (p_temp_cgi_pending_node->ho_pending_cgi_node_data.earfcn == 
                                 p_cell_context->ran_info.ncl_params.lte_ncl.inter_freq_cells[index].eutra_carrier_arfcn))
                        {
                            /* SPR 16406 10SEP end */
                            cgi_node_found = RRM_TRUE;
                            break;    
                        }
                    }
                }
                /* CellM will only send IND msg to UEM if 
                 * any CGI node found corresponding to cell 
                 * reported in nrt updated response */
                if(RRM_TRUE == cgi_node_found)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                            "CGI pending node found [PCI:%u + Earfcn:%u] for cell[%u]",
                            p_temp_cgi_pending_node->ho_pending_cgi_node_data.pci,
                            p_temp_cgi_pending_node->ho_pending_cgi_node_data.earfcn,
                            p_cell_context->cell_index);

                    /* Send msg to UEM to indicate that one of the PCI has been 
                     * reported in nrt updated response which had been requested 
                     * for CGI report for HO purpose earlier by UEM */
                    if(RRM_FAILURE == rrm_cellm_send_ho_required_for_awaited_ue_to_uem
                            (p_temp_cgi_pending_node->ho_pending_cgi_node_data, p_cell_context->cell_index))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                                "HO trigger IND for awaited UE sending failed");
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                                "HO trigger IND for awaited UE sending success");
                    }
                    break;
                }
                else
                {
                    p_temp_cgi_pending_node = (ho_pending_cgi_node_t *)ylNext(&p_temp_cgi_pending_node->node);
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                        "IntraRAT neighbors are not present in nrt response for cell[%u]",
                        p_cell_context->cell_index);
                RRM_UT_TRACE_EXIT();
                return;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 16406 End */

/****************************************************************************
 * Function Name  : rmcm_mif_updated_nrt_info
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_updated_nrt_info in FSM
 ****************************************************************************/
rrm_return_et 
rmcm_mif_updated_nrt_info
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    /*15011_start*/
     U16                              bit_mask = RRM_ZERO;
    /*15011_end*/
    rrm_bool_et reconfig_req = RRM_FALSE;
    /* SPR 14215 start*/
    rrm_bool_et sent_to_l2 = RRM_FALSE;
    /* SPR 14215 end*/
    /*SPR 16494 START*/
    rrm_enb_gu_group_id_node_t *p_enb_id_node = RRM_PNULL;
    /*SPR 16494 END */
#ifdef LTE_EMBMS_SUPPORTED
    rrm_bool_et is_reconfig_req = RRM_TRUE;
#endif
    /*Bug 831 Changes Start*/
    S8 num_intra_freq_cells = RRM_ZERO;
    /*Bug 831 Changes Start*/
    /* SPR 14215 end*/
    RRM_UT_TRACE_ENTER();

    /*Bug 831 Changes End*/
    if((p_cell_ctx->ran_info.bitmask & RRMCM_RMIF_NCL_PARAMS_PRESENT) &&
        (p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT))
    {
     num_intra_freq_cells = p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell;
    }
    /*Bug 831 Changes End*/

    prepare_inter_intra_neighbors_info_from_nrt(p_cell_ctx, &bit_mask, &reconfig_req);
    /* CA_Stage3_Change: Start */
    p_cell_ctx->updated_nrt_bitmask = bit_mask;
    /* CA_Stage3_Change: End */
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
        "No. of Intra-freq nbrs = %d, No. of Inter-freq nbrs = %d, "
        "No. of UTRAN nbrs = %d, No. of GERAN nbrs = %d, "
        "No. of CDMA nbrs = %d,"
        " Bitmask = %d"
        ,
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell,
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_inter_freq_cell,
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_utran_freq_cell,
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_geran_cell, 
        p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl.num_valid_cdma2000_freq_cells,
        bit_mask);

    /*SPR 21322 START*/ 
    p_cell_ctx->transition_cell_state = p_cell_ctx->cell_state; 
    /*SPR 21322 END*/

    if ((RRM_TRUE == reconfig_req) && ((bit_mask & RRM_INTRA_FREQ_BROADCAST_NBRS_UPDATED) ||
        /* Start 7514 NRT Fix - SIB 8 */
       (bit_mask & RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED) ||
       (bit_mask & RRM_CDMA_NBRS_UPDATED)))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Intra-RAT Broadcast and/or CDMA nbrs changed");
        /* End 7514 NRT Fix - SIB 8 */
        p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
        if (p_cell_reconfig_req == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_reconfig_req failed" );
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }

#ifdef LTE_EMBMS_SUPPORTED
        is_reconfig_req = rrm_validate_inter_intra_mbsfn(
                    &(p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl));
   
        /** if for any neighbour sf_alloc info received is NULL, then
         ** 1.RRM will not run neigh_cell_config ALGO 
         ** 2.else RRm will calculate Neigh vell config and if updated, then
         **   it will be reconfigured to RRC
         */
        if ((MBMS_SIB_13_ON_BROADCAST &
            p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast))
        {

            if (RRM_TRUE == is_reconfig_req)
            {
                if ( MBMS_SIB_2_ON_BROADCAST &
                        p_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                            "SIB2 is on Broadcast , calculating neigh_cell_config IEi");
                    rrm_process_link_up_down_nrt_for_mbms(p_cell_ctx);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_DETAILED,
                            "SIB2 is not on BROADCAST, So, NO need to calculate"
                            "neigh_cell_config"
                            );
                }
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "sf_alloc is NULL, No need to reconfig neigh_cell_config in SIB3/SIB5");
            }
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "Either NO SIB is on Broadcast or no neighbour is with X2 LINK UP");
        }

#endif

        RRM_MEMSET(p_cell_reconfig_req, RRM_ZERO, sizeof(rrc_rrm_cell_reconfig_req_t));

        if(RRM_FAILURE == build_send_rrc_reconfig_req_for_updated_nrt_info(p_cell_ctx, 
                    p_cell_reconfig_req, bit_mask))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed To Send ReConfig Req To RRC For Cell Index:%d",
                    p_cell_ctx->cell_index);
            /*reconfig send fail cell state*/
	    /*SPR 21322 START*/ 
	    /* Code Deleted */
	    /*SPR 21322 END*/
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell Reconfig Failed for Cell Index:%d Cell State is:%s[%d]",
                    p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                    p_cell_ctx->cell_state);
            RRM_MEM_FREE(p_cell_ctx->p_ncl_built_from_updated_nrt_info);
            p_cell_ctx->p_ncl_built_from_updated_nrt_info = NULL;
            ret_val = RRM_FAILURE;
        }
        else
        {

            /*Bug 831 Changes Start*/
            if((0 == num_intra_freq_cells) && (0 < p_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl.num_valid_intra_freq_cell))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "TEST 1: need to Reset all Victim UE's");
                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_RECONFIG_FIRST_INTRA_CELL;
            }
            /*Bug 831 Changes End*/


            /* SPR 14215 start*/  
            if( RRM_INTRA_FREQ_X2_STATUS_UPDATED & bit_mask )
            {    
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "TEST 2: need to reset ABS pattern");
              p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_RECONFIG_X2_LINK_UP_RECONFIG;
            }
            /* SPR 14215 end*/
            CELL_M_FSM_SET_STATE(p_cell_ctx,
                    CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_NRT);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell ReConfig Send To RRC for Cell Index:%d Cell State is:%s[%d]",
                    p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                    p_cell_ctx->cell_state);
            ret_val = RRM_SUCCESS;
        }

        RRM_MEM_FREE(p_cell_reconfig_req);
    }
    else
    {
        if(bit_mask)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Status of NRT before commit Sending RIM Stop");
            /*SPR 16494 START*/
            /*code deleted*/
            /*SPR 16494 END*/
            commit_new_ncl_for_nrt(p_cell_ctx, bit_mask);

            /* SPR 14215 start*/
            if( RRM_INTRA_FREQ_X2_STATUS_UPDATED & bit_mask )
            {
                if ( RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctx))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "TEST 3: need to reset ABS pattern");

                    if(bit_mask & RRM_INTRA_FREQ_X2_NOT_UP)
                    {
                        if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                                ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.bitmask ) &&
                                ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask))  
                        {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Applying VICTIM_ABS_PATTERN as X2 is DOWN");
                            RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                                    p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                    RRM_MAX_PATTERN_BYTE);
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "VITIM_ABS_PATTERN NOT PRESENT IN CELL_CONTEXT");
                        }   
                    }
                    else
                    {    
                        RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE);
                    }
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;

                    if(RRM_FAILURE ==  build_and_send_l2_cell_config_req( RRM_PNULL,
                                RRM_PNULL,
                                RRM_PNULL,
                                p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                                p_cell_ctx->cell_index,
                                p_cell_ctx->ongoing_trans_id))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR,"unable to send mac cell config.");
                    }   
                    else
                    {
                        sent_to_l2 = RRM_TRUE;
                    }    
                }
                if(RRM_TRUE == rrm_cellm_is_aggressor_node(p_cell_ctx))
                { 
                   if(bit_mask & RRM_INTRA_FREQ_X2_NOT_UP)
                   {    
                       if( RRM_FAILURE != rrm_cellm_get_current_load_abs_pattern(p_cell_ctx, 
                                   p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern))
                       {
                           RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                   " ABS_PATTERN FOR CURRENT LOAD_LEVEL IS PRESENT ");
                       }    
                       else
                       {
                           RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                   " ABS_PATTERN FOR CURRENT LOAD_LEVEL IS NOT PRESENT ");
                       
                           RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,
                                   RRM_MAX_PATTERN_BYTE);
                       }    
                   }
                   else
                   {    
                      RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                   } 
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                        RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                        RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;

                    if(RRM_FAILURE == build_and_send_l2_cell_config_req( RRM_PNULL,
                                RRM_PNULL,
                                p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                                RRM_PNULL,
                                p_cell_ctx->cell_index,
                                p_cell_ctx->ongoing_trans_id))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR,"unable to send mac cell config.");
                    }
                    else
                    {
                      sent_to_l2 = RRM_TRUE;
                    }    
                }
            }
            /* SPR 14215 end*/
            /*SPR 16494 START*/
            p_enb_id_node = (rrm_enb_gu_group_id_node_t*)ylFirst (&p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);
            while(p_enb_id_node)
            {
                 updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_FALSE);
                 p_enb_id_node = (rrm_enb_gu_group_id_node_t*)ylNext(&p_enb_id_node->s_node);
            }

            /*SPR 16494 END*/

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                        "Status of NRT after commit sending Start for RIM");
            rrmcm_print_nbr_list_for_nrt(p_cell_ctx);
            /* SPR 16406 8SEP start */
		    rrm_check_cgi_pending_list_for_ho(p_cell_ctx);
            /* SPR 16406 8SEP end */
	    /*SPR 16211 */
            rrmcm_check_updated_ncl_for_csg_id_and_bl_change(p_cell_ctx, bit_mask);
         
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "No Change in NCL");
        }
        /* SPR_17763_FIX_START */
          /* since there is no change in ncl, we can process next procedure
               enqueued in procedure queue. to dequeue that below mentioned set state macro is called */
        if (CELL_STATE_ACTIVE == p_cell_ctx->cell_state)
        {
            CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
        }
        /* SPR_17763_FIX_END */
        RRM_MEM_FREE(p_cell_ctx->p_ncl_built_from_updated_nrt_info);
        p_cell_ctx->p_ncl_built_from_updated_nrt_info = RRM_PNULL;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Memory freed for updated nrt struct");

        /*SPR_11728_fix_start*/
        /* SPR 14215 start*/
        if(sent_to_l2 == RRM_FALSE)
        {    
            /* SPR-22338 START */
            CELL_M_FSM_SET_STATE(p_cell_ctx,p_cell_ctx->transition_cell_state);
            /* SPR-22338 END */
        }
        else
        {
            CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "NRT Req handled in Active state itself cell index :%d Cell State is:%s[%d]",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                p_cell_ctx->cell_state);
        /*SPR_11728_fix_end*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* UPDATED NRT INFO CHANGES END */

/* TTT_UPDATE_IND changes start */
 
/****************************************************************************
 * Function Name  : rmcm_mif_ttt_update_ind
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_mif_ttt_update_ind_info in FSM
 ****************************************************************************/
rrm_return_et 
rmcm_mif_ttt_update_ind
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_FAILURE;
	rrmcm_rmif_ttt_update_ind_t    *p_ttt_update_ind = RRM_PNULL;
    rrm_common_params_for_eutra_t  *p_common_params_for_eutra = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_cell_ctx)
    {
        p_ttt_update_ind = (rrmcm_rmif_ttt_update_ind_t *) p_cell_ctx->p_incoming_api_info;
        if(RRM_PNULL != p_ttt_update_ind)
        {
				p_common_params_for_eutra = rrm_cellm_get_connected_mode_common_params(p_cell_ctx->cell_index);
				if( RRM_PNULL != p_common_params_for_eutra)
				{
                        /* coverity : CID 29612*/
                        p_common_params_for_eutra->time_to_trigger = (rrmc_time_to_trigger_et) p_ttt_update_ind->updated_ttt; 
                        ret_val = RRM_SUCCESS;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                  RRM_BRIEF,"updated TTT value is %d for cell_idex %d",
                                  p_common_params_for_eutra->time_to_trigger,
                                  p_cell_ctx->cell_index);
				}
                else
                {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                  RRM_BRIEF," p_common_params_for_eutra is NULL for cell_idex %d",
                                  p_cell_ctx->cell_index);
                }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                      RRM_BRIEF," p_ttt_update_ind is NULL for cell_idex %d",
                      p_cell_ctx->cell_index);
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_BRIEF," p_cell_ctx is NULL ");
	}

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TTT_UPDATE_IND changes end */

/****************************************************************************
 * Function Name  : rmcm_rrc_reconfig_resp_for_nrt
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig resp in FSM
 ****************************************************************************/
rrm_return_et 
rmcm_rrc_reconfig_resp_for_nrt
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */

 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et tigger_to_l2 = RRM_FALSE;
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
        p_cell_ctx->p_incoming_api_info;

    if (RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
    {
        /* Fix 916 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
            RRM_BRIEF,"Fail Cause of RRC:%d for cell Index:%d",
            p_rrc_rrm_cell_reconfig_resp->fail_cause,
            p_cell_ctx->cell_index);
        /* Fix 916 End */
        /* SPR 14215 start*/
        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask &= ~RRM_CTXT_RECONFIG_X2_LINK_UP_RECONFIG;
        
        /* SPR 14215 end*/
        ret_val = RRM_FAILURE;
    }
    else
    {
        /*RIM changes start*/
        /* Spr 16211 Changes Start*/
        /* Code Removed */
        /* Spr 16211 Changes End*/
        commit_reconfig_param_for_nrt(p_cell_ctx);

        /* Spr 16211 Changes Start*/
        /* Code Removed */
        /* Spr 16211 Changes End*/
        rrmcm_print_nbr_list_for_nrt(p_cell_ctx);
        /* Fix 916 Start */
        /* Compilation changes Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_BRIEF,"Reconfig Succ For Cell Index:%s",
                CELL_FSM_STATE[p_cell_ctx->cell_state]);
        ret_val = RRM_SUCCESS;
/*Bug 831 Changes Start*/
        if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_RECONFIG_FIRST_INTRA_CELL)
        {
		if(RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctx))
		{
        		if(RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
                		                                   RRMUEM_CELLM_EICIC_RESET_ABS_REQ,
                        		                           (U16)RRM_ZERO,
                                		                   (void *)RRM_PNULL))
            		{
                 		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                           	"failure in sending :%d for cell index:%d",
                            	RRMUEM_CELLM_EICIC_RESET_ABS_REQ,
                            	p_cell_ctx->cell_index);
            		}
        		else
            		{
                 		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                           	"success in sending :%d for cell index:%d",
                           	RRMUEM_CELLM_EICIC_RESET_ABS_REQ,
                           	p_cell_ctx->cell_index);
	    		}
		}
		p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask &= ~RRM_CTXT_RECONFIG_FIRST_INTRA_CELL;

	}
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                           	"p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = %d and bitmask = %d",p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask,RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT);
        if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT)
	{
		if(RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctx))
		{

                    rrm_cellm_find_and_update_common_abs_pattern(p_cell_ctx);
		    if (CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2 == p_cell_ctx->cell_state)
		    {

                         tigger_to_l2 = RRM_TRUE;
		    }
		}
		p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask &= ~RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT;
	}
/*Bug 831 Changes End*/

        /* SPR 14215 start*/
        if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_RECONFIG_X2_LINK_UP_RECONFIG)
        {
            if ( RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctx))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "TEST 3: need to reset ABS pattern");

                if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_RECONFIG_X2_LINK_DOWN_RECONFIG)
                {
                    if(( RRMCM_RMIF_ABS_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.bitmask ) &&
                            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.bitmask ) &&
                            ( RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT &  p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask))  
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Applying VICTIM_ABS_PATTREN as X2 is DOWN");
                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern,
                                RRM_MAX_PATTERN_BYTE);
                        /*SPR 16202 start*/
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;

                        if(RRM_FAILURE ==  build_and_send_l2_cell_config_req( RRM_PNULL,
                                    RRM_PNULL,
                                    RRM_PNULL,
                                    p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                                    p_cell_ctx->cell_index,
                                    p_cell_ctx->ongoing_trans_id))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                    RRM_ERROR,"unable to send mac cell config.");
                        } 
                        else 
                        {
                            tigger_to_l2 = RRM_TRUE;
                        }    
                        /*SPR 16202 end*/

                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "VITIM_ABS_PATTERN NOT PRESENT IN CELL_CONTEXT");
                    }   
                }
                else
                {    
                    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                }

            }
            if(RRM_TRUE == rrm_cellm_is_aggressor_node(p_cell_ctx))
            { 
                if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_RECONFIG_X2_LINK_DOWN_RECONFIG)
                {    
                    if( RRM_FAILURE != rrm_cellm_get_current_load_abs_pattern(p_cell_ctx, 
                                p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern))
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                " ABS_PATTERN FOR CURRENT LOAD_LEVEL IS PRESENT ");
                        /*SPR 16202 start*/
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                            RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                            RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                        if(RRM_FAILURE == build_and_send_l2_cell_config_req( RRM_PNULL,
                                    RRM_PNULL,
                                    p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                                    RRM_PNULL,
                                    p_cell_ctx->cell_index,
                                    p_cell_ctx->ongoing_trans_id))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                    RRM_ERROR,"unable to send mac cell config.");
                        }
                        else
                        {
                            tigger_to_l2 = RRM_TRUE;
                        }   
                        /*SPR 16202 end*/
                    }    
                    else
                    {
                        RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE);
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                " ABS_PATTERN FOR CURRENT LOAD_LEVEL IS NOT PRESENT ");
                    }    
                }
                else
                {    
                    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                    /* SPR 18791 Fix Start */
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                        RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;

                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                        RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;

                    if(RRM_FAILURE == build_and_send_l2_cell_config_req( RRM_PNULL,
                                RRM_PNULL,
                                p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                                RRM_PNULL,
                                p_cell_ctx->cell_index,
                                p_cell_ctx->ongoing_trans_id))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                                RRM_ERROR,"unable to send mac cell config.");
                    }
                    else
                    {
                        tigger_to_l2 = RRM_TRUE;
                    }
                    /* SPR 18791 Fix End */
                } 

            }

            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask &= ~RRM_CTXT_RECONFIG_X2_LINK_UP_RECONFIG;
            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask &= ~RRM_CTXT_RECONFIG_X2_LINK_DOWN_RECONFIG;
        }    
        /* SPR 14215 end*/
    }    

    /* Fix 916 End */

    /* free the memory for new configuration*/

    /* SPR 11492 start */
    if (RRM_PNULL != p_cell_ctx->p_ncl_built_from_updated_nrt_info)
    {
    /* SPR 11492 end */
            RRM_MEM_FREE(p_cell_ctx->p_ncl_built_from_updated_nrt_info);
    }
        /*BUG:9237 start*/
    /*SPR_11797:start*/
    if((CELL_STATE_ACTIVE == p_cell_ctx->cell_state) && (RRM_PNULL != p_cell_ctx->p_new_reconfig_data) )
    /*SPR_11797:end*/
    {
        RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
    }
        /*BUG:9237 end*/
    /*SPR 12315:start*/

    if(tigger_to_l2 == RRM_FALSE) 
    {   
	    /*SPR 21322 START*/
	    CELL_M_FSM_SET_STATE(p_cell_ctx, p_cell_ctx->transition_cell_state);
	    /*SPR 21322 END*/ 
    }
    else
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
            RRM_BRIEF,"New Cell State Is:%s For Cell Index:%u",
        CELL_FSM_STATE[p_cell_ctx->cell_state], p_cell_ctx->cell_index);
    /*SPR 12315:end*/
        /* SPR_14534_fix: start */
    if((CELL_STATE_ACTIVE == p_cell_ctx->cell_state) && (RRM_PNULL != p_cell_ctx->p_new_reconfig_data))
    {
            RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
    }
        /* SPR_14534_fix: end */
   /* SPR 16406 Start */
    /* Below code leg ensure Handover of UE's for those cgi requested for HO purpose earlier */                        
    rrm_check_cgi_pending_list_for_ho(p_cell_ctx);
    /* SPR 16406 End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rrc_pws_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles PWS request 
 ****************************************************************************/
rrm_return_et
rmcm_rrc_pws_req
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_SUCCESS;
    s1ap_rrm_pws_request_t  *p_s1ap_rrm_pws_request = RRM_PNULL;

    p_s1ap_rrm_pws_request = (s1ap_rrm_pws_request_t *)
        p_cell_ctx->p_incoming_api_info;

    /*Process ETWS type of warning message */
    if(!(p_s1ap_rrm_pws_request->bitmask & S1AP_RRM_PWS_CONCURRENT_WARNING_MSG_INDICATOR ))
    {
        if(RRM_FAILURE == rrm_cellm_process_etws_scheduling_req(p_s1ap_rrm_pws_request,p_cell_ctx))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Duplicate Request :Unable to process ETWS scheduling Request");
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Succesfully Handled ETWS scheduling Request");
        }
    }
    /*Process CMAS type of warning message */
    else 
    {
        if(RRM_FAILURE == rrm_cellm_process_cmas_scheduling_req(p_s1ap_rrm_pws_request, p_cell_ctx))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    " Duplicate Request : Unable to process CMAS scheduling Request");
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Succesfully Handled CMAS scheduling Request");
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;			
}
/****************************************************************************
 * Function Name  : rmcm_rrc_pws_cnf
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles PWS cnf in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rrc_pws_cnf
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_SUCCESS;
    s1ap_rrm_pws_cnf_t  *p_s1ap_rrm_pws_cnf = RRM_PNULL;
    p_s1ap_rrm_pws_cnf = (s1ap_rrm_pws_cnf_t *)p_cell_ctx->p_incoming_api_info;

    /*Process ETWS type of warning message */
    if(RRM_SUCCESS == rrm_cellm_update_etws_scheduling_info_list(p_s1ap_rrm_pws_cnf,p_cell_ctx))
    {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Successfully handles the cnf for [ETWS] CEll index = %d", p_cell_ctx->cell_index);
    }
    else if (RRM_SUCCESS == rrm_cellm_update_cmas_scheduling_info_list(p_s1ap_rrm_pws_cnf, p_cell_ctx)) 
    {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Succesfully Handled the cnf for [CMAS] CEll index = %d", p_cell_ctx->cell_index);
    }
    else
    {
        ret_val = RRM_FAILURE;
    }
    
    /* change the state for the cell*/ 
    if(!(p_cell_ctx->scheduled_etws_warning_list.count)
        &&!(p_cell_ctx->scheduled_cmas_warning_list.count))
    {
            p_cell_ctx->pws_substate = PWS_IDLE;
            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
        RRM_MEM_FREE(p_cell_ctx->scheduling_info_list_for_pws);  
            p_cell_ctx->scheduling_info_list_for_pws = RRM_PNULL;
    }
    else
    {
        p_cell_ctx->pws_substate = PWS_ONGOING_ACTIVE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_rrc_kill_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles Kill req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rrc_kill_req
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */

 )
{
    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_SUCCESS;
    s1ap_rrm_kill_request_t  *p_s1ap_rrm_kill_request = RRM_PNULL;
    scheduling_data_key_t shed_data_key;
    YLNODE *p_ylnode = RRM_PNULL;
    scheduling_data_key_t *p_shed_data_key = RRM_PNULL;

    p_s1ap_rrm_kill_request = (s1ap_rrm_kill_request_t *)
        p_cell_ctx->p_incoming_api_info;

    RRM_MEMCPY(&shed_data_key.msg_id,p_s1ap_rrm_kill_request->message_identifier,(MSG_ID_OCTET_SIZE));
    RRM_MEMCPY(&shed_data_key.serial_number,p_s1ap_rrm_kill_request->serial_number,(SERIAL_NUMBER_OCTET_SIZE));
  
    p_shed_data_key = &shed_data_key;
    RRM_ASSERT(RRM_PNULL != p_shed_data_key);

    if (RRM_PNULL != (p_ylnode = ylFind(&(p_cell_ctx->scheduled_cmas_warning_list),
                p_shed_data_key, rrm_cellm_pws_request_sched_data_key ,
                rrm_cellm_shed_data_key_compare)))
    {
        ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status = PWS_BROADCAST_KILLED; 
    }
    else
    {
        /*requested warning message id and serial number are not on broadcast */
        ret_val = RRM_FAILURE;
    }
    return ret_val;			
}

/****************************************************************************
 * Function Name  : rmcm_rrc_kill_cnf
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles kill cnf in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rrc_kill_cnf
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_SUCCESS;
    s1ap_rrm_kill_cnf_t *p_s1ap_rrm_kill_cnf = RRM_PNULL;
    p_s1ap_rrm_kill_cnf = (s1ap_rrm_kill_cnf_t *)p_cell_ctx->p_incoming_api_info;
    U8 si_index_killd_warn = RRM_ZERO;
    scheduling_data_key_t shed_data_key;
    YLNODE *p_ylnode = RRM_PNULL;
    scheduling_data_key_t *p_shed_data_key = RRM_PNULL;

    RRM_MEMCPY(&shed_data_key.msg_id,p_s1ap_rrm_kill_cnf->message_identifier,(MSG_ID_OCTET_SIZE));
    RRM_MEMCPY(&shed_data_key.serial_number,p_s1ap_rrm_kill_cnf->serial_number,(SERIAL_NUMBER_OCTET_SIZE));
    p_shed_data_key = &shed_data_key;
    RRM_ASSERT(RRM_PNULL != p_shed_data_key);

    if (RRM_PNULL != (p_ylnode = ylFind(&(p_cell_ctx->scheduled_cmas_warning_list),
                p_shed_data_key, rrm_cellm_pws_request_sched_data_key ,
                rrm_cellm_shed_data_key_compare)))
    {
        si_index_killd_warn = ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]; 
        ylDelete(&(p_cell_ctx->scheduled_cmas_warning_list), p_ylnode);
        RRM_MEM_FREE(p_ylnode);

        /*Coverity_fix_start_54968*/
    RRM_MEMCPY(&p_cell_ctx->operator_info.sib_1_info.scheduling_info_list,p_cell_ctx->scheduling_info_list_for_pws,sizeof(rrm_scheduling_info_t));
    if( p_cell_ctx->scheduled_etws_warning_list.count &&
          !p_cell_ctx->scheduled_cmas_warning_list.count)
    {
        /* DYNAMIC SIB SCHEDULING START */
        update_si_index_in_etws_warning_list( &(p_cell_ctx->scheduled_etws_warning_list), si_index_killd_warn,p_cell_ctx);
        /* DYNAMIC SIB SCHEDULING END */
    }
    /* Coverity 54968 fix start */
    p_cell_ctx->pws_substate = PWS_ONGOING_ACTIVE;
    /* Coverity 54968 fix end */
    }
    else
    {
        p_ylnode = p_cell_ctx->scheduled_cmas_warning_list.node.next;
        while(p_ylnode)
        {
            if(PWS_BROADCAST_KILLED ==(((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status))
            {
              ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status = PWS_BROADCAST_ONGOING;
            }
            p_ylnode = ((scheduled_pws_data_node_t *)p_ylnode)->pNode.next;
        }
        ret_val = RRM_FAILURE;
    }

    /*check for cell state change */
    if((!(p_cell_ctx->scheduled_cmas_warning_list.count) && !(p_cell_ctx->scheduled_etws_warning_list.count)))
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
        p_cell_ctx->pws_substate = PWS_IDLE;
        RRM_MEM_FREE(p_cell_ctx->scheduling_info_list_for_pws);  
						p_cell_ctx->scheduling_info_list_for_pws = RRM_PNULL;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rmcm_rrc_update_pws_list_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update pws list req in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rrc_update_pws_list_req
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */

 )
{
    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_updated_pws_si_list_req_t  *p_rrc_rrm_updated_pws_si_list_req = RRM_PNULL;
    rrc_rrm_updated_pws_si_list_resp_t *p_rrc_rrm_updated_pws_si_list_resp = RRM_PNULL;

    p_rrc_rrm_updated_pws_si_list_req = (rrc_rrm_updated_pws_si_list_req_t*)p_cell_ctx->p_incoming_api_info;
    p_rrc_rrm_updated_pws_si_list_resp = (rrc_rrm_updated_pws_si_list_resp_t*)rrm_mem_get(sizeof(rrc_rrm_updated_pws_si_list_resp_t));
    if (p_rrc_rrm_updated_pws_si_list_resp == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_rrm_updated_pws_si_list_resp failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }

    RRM_MEMSET(p_rrc_rrm_updated_pws_si_list_resp , RRM_ZERO , sizeof(rrc_rrm_updated_pws_si_list_resp_t));
    /* Updated the ETWS/CMAS list of warnings maintained at RRM */
    if(RRM_FAILURE == rrm_rrc_prepare_update_pws_list_resp(p_rrc_rrm_updated_pws_si_list_req ,p_cell_ctx,p_rrc_rrm_updated_pws_si_list_resp))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Updated PWS request for invalid Msg Id and Serial Num");
        ret_val = RRM_FAILURE;
    }

    if(ret_val)
    {
        if(RRM_FAILURE == build_and_send_update_pws_list_resp(p_rrc_rrm_updated_pws_si_list_resp, p_cell_ctx->ongoing_trans_id))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Unable to send response of API ID :%d",RRC_RRM_UPDATED_PWS_SI_LIST_REQ);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* change the state of the cell to indicate that it is waiting for Updated PWS CNF */
            p_cell_ctx->pws_substate = PWS_W_FOR_UPDATE_CNF;    
        }
    }
    /* COVERITY : RESOURCE LEAK : CID : 54327 fix start*/
    if( RRM_NULL != p_rrc_rrm_updated_pws_si_list_resp )
        RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_resp);
    /* COVERITY : RESOURCE LEAK : CID : 54327 fix end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rmcm_rrc_update_pws_list_cnf
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update pws list cnf  in FSM
 ****************************************************************************/
rrm_return_et
rmcm_rrc_update_pws_list_cnf
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{

    RRM_UT_TRACE_ENTER();
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_updated_pws_si_list_cnf_t  *p_rrc_rrm_updated_pws_si_list_cnf = RRM_PNULL;

    p_rrc_rrm_updated_pws_si_list_cnf = (rrc_rrm_updated_pws_si_list_cnf_t*)p_cell_ctx->p_incoming_api_info;

    if(RRM_SUCCESS == 
            rrm_rrc_update_cell_pws_list_on_cnf(p_rrc_rrm_updated_pws_si_list_cnf,p_cell_ctx))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Successful processed the updaetd CNF");
    }
    else
    {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Unable to process pws cnf message");
      /*change the ctate of cell to indicate that Updated PWS list procedure is complete*/
      p_cell_ctx->pws_substate = PWS_ONGOING_ACTIVE;
      ret_val = RRM_FAILURE;
    }
    return ret_val;
}

/* SON ES MLB Started */
/****************************************************************************
 * Function Name  : rrmcm_rrm_es_periodic_resrc_update
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update SON ES periodic resource in FSM
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_es_periodic_resrc_update
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_son_load_report_ind_t   resrc_upd;

    RRM_UT_TRACE_ENTER();
    //U32 *cell_id = (U32 *)(resrc_upd.serv_cell_load_info.g_cell_id.cell_identity);
    if (p_cell_ctx->cell_already_register_es & CELL_ALREADY_REGISTERD_FOR_ES)
    {
        resrc_upd.serv_cell_load_info.bitmask = RRM_ZERO;
        resrc_upd.count = RRM_ZERO;

        rrm_fill_srv_cell_load_info(p_cell_ctx, &resrc_upd);
        U32 *cell_id = (U32 *)(resrc_upd.serv_cell_load_info.g_cell_id.cell_identity);

        if (RRM_SUCCESS != (ret_val = rrm_son_send_rrm_son_load_report_ind(&resrc_upd, 
                                                                            RRM_MODULE_ID, 
                                                                            RRM_SON_ES_MODULE_ID, 
                                                                            RRM_ZERO,
                                                                            p_cell_ctx->cell_index)))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_ERROR,"Failed to send LOAD Report to SON_ES for serving cell[0x%x]",
                    RRM_NTOHL(*(cell_id)));
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"Successfully sent LOAD Report to SON_ES for serving cell[0x%x]",
                    RRM_NTOHL(*(cell_id)));
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SON ES MLB end */

/****************************************************************************
 * Function Name  : rrmcm_rrm_periodic_resrc_update
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update periodic resource in FSM
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_periodic_resrc_update
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
    {
        build_and_send_rsu_to_son (p_cell_ctx);
    }
    build_and_send_rsu_to_oam (p_cell_ctx);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
   
/****************************************************************************
 * Function Name  : rrmcm_rrm_oam_chng_self_rpt_tmr_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles OAM self report timer
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_oam_chng_self_rpt_tmr_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    cell_timer_buf_t        timer_buf;

    RRM_UT_TRACE_ENTER();

    /* Coverity_ID : 29620 */
    RRM_MEMSET(&timer_buf,RRM_ZERO,sizeof(cell_timer_buf_t));
    /* SPR-17852 START */
    if (RRM_ZERO != p_cell_ctx->self_load_rpt_tmr)
    {
        /* SPR-17852 END */
        cell_stop_timer(p_cell_ctx->self_load_rpt_tmr);
        p_cell_ctx->self_load_rpt_tmr = RRM_ZERO;
    }

    if (RRM_ZERO != p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO])
    {
        timer_buf.cell_index = p_cell_ctx->cell_index;
        timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO;
        p_cell_ctx->self_load_rpt_tmr = cell_start_timer(CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO,
                (rrm_void_t *)&timer_buf,
                sizeof (cell_timer_buf_t), p_cell_ctx);
    }

    /* Updating SON/OAM when timer is getting changed */
    if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
    {
        build_and_send_rsu_to_son (p_cell_ctx);
    }
    build_and_send_rsu_to_oam (p_cell_ctx);

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrmcm_rrm_oam_chng_nbr_rpt_tmr_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles OAM nabour report timer event
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_oam_chng_nbr_rpt_tmr_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /* Stop all reports and restart them with new value */
    /* eICIC_PHASE_1_2_CHANGES_START */
    rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
    /* eICIC_PHASE_1_2_CHANGES_END */

    if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
	{
        rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx, p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_rrm_oam_chng_both_rpt_tmr_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles OAM self and nabour report timer event
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_oam_chng_both_rpt_tmr_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    cell_timer_buf_t        timer_buf; 
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /* coverity : CID 29620*/
    RRM_MEMSET(&timer_buf,RRM_ZERO,sizeof(cell_timer_buf_t));


    /* SPR-17852 START */
    if (RRM_ZERO != p_cell_ctx->self_load_rpt_tmr)
    {
        /* SPR-17852 END */
        cell_stop_timer(p_cell_ctx->self_load_rpt_tmr);
        p_cell_ctx->self_load_rpt_tmr = RRM_ZERO;
    }
    if (RRM_ZERO !=
            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO])
    {
        timer_buf.cell_index = p_cell_ctx->cell_index;
        timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO;
        p_cell_ctx->self_load_rpt_tmr = cell_start_timer(CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO,
                (rrm_void_t *)&timer_buf,
                sizeof (cell_timer_buf_t), p_cell_ctx);
    }

    /* Stop all reports and restart them with new value */
    /* eICIC_PHASE_1_2_CHANGES_START */
    rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
    /* eICIC_PHASE_1_2_CHANGES_END */

    if (RRM_ZERO !=
            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
    {
        rrm_hndl_rsu_start_req_for_ncl (p_cell_ctx,
                p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
    }

    /* Updating SON/OAM when timer is getting changed */
    if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
    {
        build_and_send_rsu_to_son (p_cell_ctx);
    }
    build_and_send_rsu_to_oam (p_cell_ctx);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : restore_cell_barred_params_for_cell_unblock
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : Updates the value of cell barred params for cell unblock
 ****************************************************************************/
rrm_return_et
restore_cell_barred_params_for_cell_unblock
(
    rrm_cell_context_t *p_cell_ctxt
)
{
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL == p_cell_ctxt->p_cell_ld_reconfig_data)
    {
        p_cell_ctxt->p_cell_ld_reconfig_data = rrm_mem_get(sizeof(rrm_cellm_load_ac_barring_t));
        if (p_cell_ctxt->p_cell_ld_reconfig_data == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_ctxt->p_cell_ld_reconfig_data failed" );
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }    
        RRM_MEMSET(p_cell_ctxt->p_cell_ld_reconfig_data, RRM_NULL, sizeof(rrm_cellm_load_ac_barring_t));
        if(p_cell_ctxt->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
        {
            if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.bitmask &
                    RRMCM_RMIF_BARRING_INFO_PRESENT)
            {
                if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                        bitmask & RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT)
                {
                    p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_MMTEL_MOSIGL_PRESENT;
                    p_cell_ctxt->p_cell_ld_reconfig_data->mo_sigl.ac_barring_factor = rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_signalling));
                    p_cell_ctxt->p_cell_ld_reconfig_data->mo_sigl.ac_barring_time =
                        rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                    access_barring_info.ac_barring_for_mo_signalling));
                    p_cell_ctxt->p_cell_ld_reconfig_data->mo_sigl.ac_barring_spec_ac =
                        rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                    access_barring_info.ac_barring_for_mo_signalling));
                }
                if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                        bitmask &
                        RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
                {
                    p_cell_ctxt->p_cell_ld_reconfig_data->bitmask
                        |=
                        RRM_CELLM_LDACB_MMTEL_MODATA_PRESENT;
                    p_cell_ctxt->p_cell_ld_reconfig_data->mo_data.ac_barring_factor
                        = rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data));
                    p_cell_ctxt->p_cell_ld_reconfig_data->mo_data.ac_barring_time
                        =
                        rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                    access_barring_info.ac_barring_for_mo_data));
                    p_cell_ctxt->p_cell_ld_reconfig_data->mo_data.ac_barring_spec_ac
                        =
                        rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                    access_barring_info.ac_barring_for_mo_data));
                }
                if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask &
                        RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT)
                {
                    if (p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask &
                            RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT)
                    {
                        p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_MMTEL_VOICE_PRESENT;
                        p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_voice.ac_barring_factor =
                                rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_voice.ac_barring_time =
                            rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                        access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_voice.ac_barring_spec_ac =
                            rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                        access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
                    }
                    if (p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask &
                            RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT)
                    {
                        p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |=
                            RRM_CELLM_LDACB_MMTEL_VIDEO_PRESENT;
                        p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_video.ac_barring_factor
                            = rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_video.ac_barring_time
                            =
                            rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                        access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_video.ac_barring_spec_ac
                            =
                            rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                        access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
                    }
                }
            }
            /*SPR_17786_Fix_Start */
            if(p_cell_ctxt->operator_info.sib_2_info.presence_bitmask & RRMCM_RMIF_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG)
            {
                    p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_CSFB_R10_PRESENT;
                    p_cell_ctxt->p_cell_ld_reconfig_data->csfb_r10.ac_barring_factor = 
                        rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.ac_barring_for_csfb_r10));
                    p_cell_ctxt->p_cell_ld_reconfig_data->csfb_r10.ac_barring_time =
                        rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.ac_barring_for_csfb_r10));
                    p_cell_ctxt->p_cell_ld_reconfig_data->csfb_r10.ac_barring_spec_ac =
                        rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.ac_barring_for_csfb_r10));


            }
            /*SPR_17786_Fix_End */
        }

    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrmcm_mif_process_cell_reconfig_for_cell_unblock
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Processing cell reconfig for cell block
 ****************************************************************************/
rrm_return_et
rrmcm_mif_process_cell_reconfig_for_cell_unblock
(
rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
    if (p_cell_reconfig_req == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_reconfig_req failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }

    RRM_MEMSET(p_cell_reconfig_req, RRM_NULL, sizeof(rrc_rrm_cell_reconfig_req_t));
    /* SPR 16012 Fix Start */
    p_cell_ctx->cell_block_unblock_ongoing = CELL_UNBLOCK_ONGOING;    
    /* SPR 16012 Fix Stop */

    ret_val = build_send_rrc_reconfig_req (p_cell_ctx,
            p_cell_reconfig_req,
            CELL_MLB_RECONFIG_PROC);
    if (RRM_SUCCESS == ret_val)
    {
        p_cell_ctx->stop_adm_flag = RRM_FALSE;
        CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " Cell ReConfig Sent To RRC for Cell Index:%d Cell State is:%s[%d]",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                p_cell_ctx->cell_state);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                " Cell Reconfig Failed for Cell Index:%d Cell State is:%s[%d]",
                p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                p_cell_ctx->cell_state);
    }
    RRM_MEM_FREE(p_cell_reconfig_req);
    RRM_MEM_FREE(p_cell_ctx->p_cell_ld_reconfig_data);
    p_cell_ctx->p_cell_ld_reconfig_data = RRM_PNULL;
    RRM_UT_TRACE_EXIT();
    return ret_val;


}

/****************************************************************************
 * Function Name  : rrmcm_mif_process_cell_reconfig_for_cell_block
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Processing cell reconfig for cell block
 ****************************************************************************/
rrm_return_et
    rrmcm_rrm_process_cell_reconfig_for_cell_block
(
 rrm_cell_context_t *p_cell_ctx
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    /* SPR 16012 Fix Start */
    rrmcm_rmif_generic_resp_t *p_generic_resp = RRM_PNULL;
    void *ptr = RRM_PNULL;
    /* SPR 16012 Fix Stop */


    p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
    if (p_cell_reconfig_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_reconfig_req failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_cell_reconfig_req, RRM_NULL, sizeof(rrc_rrm_cell_reconfig_req_t));

    /* spr_12100_fix_start*/
    p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.
        ca_config_bitmask |= RRM_CA_CELL_STOP_ADM_BITMASK ;
    rrm_broadcast_carrier_agg_configuration_change_event_at_eNB(
            p_cell_ctx->cell_index,
            p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask ,p_cell_ctx->ongoing_trans_id);

    p_cell_ctx->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;

    /* stopping the timer on cell stop response besides of cell stop req */
    if ( RRM_ZERO != p_cell_ctx->intra_eNB_cell_load_broadcast_timer )
    {
        cell_stop_timer( p_cell_ctx->intra_eNB_cell_load_broadcast_timer );
        p_cell_ctx->intra_eNB_cell_load_broadcast_timer = RRM_ZERO;
    }
    /* spr_12100_fix_end*/
    /* SPR 16012 Fix Start */
    p_cell_ctx->cell_block_unblock_ongoing = CELL_BLOCK_ONGOING;    

    if ( RRM_OAM_CELL_BARRED != p_cell_ctx->ran_info.
            cell_restriction_params.cell_and_access_barring.cell_barred )
    { 
        ret_val = build_send_rrc_reconfig_req (p_cell_ctx,
                p_cell_reconfig_req,
                CELL_MLB_RECONFIG_PROC);
        if (RRM_SUCCESS == ret_val)
        {
            p_cell_ctx->stop_adm_flag = RRM_TRUE;
            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP);
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    " Cell ReConfig Sent To RRC for Cell Index:%d Cell State is:%s[%d]",
                    p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                    p_cell_ctx->cell_state);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    " Cell Reconfig Failed for Cell Index:%d Cell State is:%s[%d]",
                    p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                    p_cell_ctx->cell_state);
        }
    }
    else
    {
        p_generic_resp = rrm_mem_get(sizeof
                (rrmcm_rmif_generic_resp_t));
        if(p_generic_resp != RRM_PNULL)
        {
            p_generic_resp->cellindex = p_cell_ctx->cell_index;
            p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
            p_generic_resp->response = RRM_SUCCESS;
            p_generic_resp->fail_cause = RRM_NO_ERROR;

            ptr = (void *)p_generic_resp;
            if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                        RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                        sizeof(rrmcm_rmif_generic_resp_t),
                        ptr))

            {  
               /* Coverity CID 107095 Fix Start */
                /* Code Deleted */
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "failure in sending :%d for cell index:%d",
                        RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                        p_cell_ctx->cell_index);
                RRM_MEM_FREE(p_cell_reconfig_req);
                /* SPR 19838 : CID 12956 Fix Start */
                /* Code Deleted */
                /* SPR 19838 : CID 12956 Fix End */
                rrm_mem_free(p_cell_ctx->p_cell_ld_reconfig_data);
                p_cell_ctx->p_cell_ld_reconfig_data = RRM_PNULL;
                rrmcm_dequeue_message(p_cell_ctx);
                RRM_MEM_FREE(p_generic_resp);
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
                /* Coverity CID 107095 Fix End */

            }
            else
            {
                CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ALREADY_BLOCKED);
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "success in sending :%d for cell index:%d",
                        RRMCM_RMIF_CELL_STOP_ADMISSION_RESP,
                        p_cell_ctx->cell_index);
            }
            RRM_MEM_FREE(p_generic_resp);
        }
        else
        {
            RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                    "Memory allocation to p_generic_resp failed");
	   /* Coverity CID 74707 Fix Start */
            RRM_MEM_FREE(p_cell_reconfig_req);
            /* SPR 19838 : CID 12956 Fix Start */
            /* Code Deleted */
            /* SPR 19838 : CID 12956 Fix End */
            rrm_mem_free(p_cell_ctx->p_cell_ld_reconfig_data);
            p_cell_ctx->p_cell_ld_reconfig_data = RRM_PNULL;
            /* Coverity CID 74707 Fix End */
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }
    /* SPR 16012 Fix Stop */

    RRM_MEM_FREE(p_cell_reconfig_req);
    /* SPR 19838 : CID 12956 Fix Start */
    /* Code Deleted */
    /* SPR 19838 : CID 12956 Fix End */
    rrm_mem_free(p_cell_ctx->p_cell_ld_reconfig_data);
    p_cell_ctx->p_cell_ld_reconfig_data = RRM_PNULL;
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_rrm_mlb_cell_reconfig_req_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles MLB cell reconfig request event
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_mlb_cell_reconfig_req_event
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    p_cell_reconfig_req = rrm_mem_get(sizeof(rrc_rrm_cell_reconfig_req_t));
    if (p_cell_reconfig_req == RRM_PNULL)
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_reconfig_req failed" );
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
    }

    RRM_MEMSET(p_cell_reconfig_req, RRM_NULL, sizeof(rrc_rrm_cell_reconfig_req_t));
    ret_val = build_send_rrc_reconfig_req (p_cell_ctx,
                                           p_cell_reconfig_req,
                                           CELL_MLB_RECONFIG_PROC);
    if (RRM_SUCCESS == ret_val) 
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_MLB_W_FOR_CELL_RECONFIG_RESP);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                 "MLB: Cell ReConfig Sent To RRC for Cell Index:%d Cell State is:%s[%d]",
                  p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                  p_cell_ctx->cell_state);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                 "MLB: Cell Reconfig Failed for Cell Index:%d Cell State is:%s[%d]",
                  p_cell_ctx->cell_index,CELL_FSM_STATE[p_cell_ctx->cell_state],
                  p_cell_ctx->cell_state); 
    }
    RRM_MEM_FREE(p_cell_reconfig_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrmcm_rrm_mlb_cell_reconfig_resp_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles MLB cell reconfig resp event
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_mlb_cell_reconfig_resp_event
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL; 
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
                                    p_cell_ctx->p_incoming_api_info;
    if (RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "MLB: Cell reconfig Failure Cause of RRC:%d for cell Index:%d",
                p_rrc_rrm_cell_reconfig_resp->fail_cause,
                p_cell_ctx->cell_index);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "MLB: Cell Reconfig Success for cell Index:%d", p_cell_ctx->cell_index);
    }
    CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* MLB Changes end */
/*Klockwork_fix_start*/
/****************************************************************************
* Function Name  : rmcm_rim_info_resp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handling the rim info resp
****************************************************************************/
rrm_void_t
rmcm_rim_info_resp_nacc_app(rrm_cell_context_t   *p_cell_ctx ,
                            rim_information_t    *p_rrc_rrm_rim_info)
{
    rrm_bool_t    return_val = RRM_FALSE;
    U8 count                   = RRM_ZERO;
    U16 cell_id                = RRM_ZERO;
    /*SPR 19765 FIX START*/
    U16 buffer_length          = RRM_ZERO;
    /*SPR 19765 FIX END*/
    U8 num                     = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
        for(count=RRM_ZERO ; count < p_cell_ctx->ran_info.ncl_params.
                inter_rat_ncl.num_valid_geran_cell; count++)
        {
	    U16 *p_temp_geran_cell_idty = RRM_PNULL;
	    p_temp_geran_cell_idty = (U16 *)p_rrc_rrm_rim_info->src_cell.geran_rtng_addr.geran_cell_idty; 
            cell_id = RRM_NTOHS(*(p_temp_geran_cell_idty));
	    if((cell_id == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].cell_id)
              &&
              (!RRM_MEMCMP(p_rrc_rrm_rim_info->src_cell.geran_rtng_addr.routing_idty.lac,
              p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].lai.lac,
					 /*SPR 19765 FIX START*/
					 RRM_OAM_MAX_NUM_LAC_OCTETS*sizeof(U8)))
			    && 
			    (p_rrc_rrm_rim_info->src_cell.geran_rtng_addr.routing_idty.rac == 
			     p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].rac))
		    /*SPR 19765 FIX START*/
            {
                return_val = rrm_check_for_stale_rsn(p_rrc_rrm_rim_info->seq_num,
                        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                        geran_freq_cells[count].last_recd_rsn);
                if((RRM_TRUE == return_val) && (RRM_PNULL == p_cell_ctx->ran_info.
                            ncl_params.inter_rat_ncl.geran_freq_cells[count].
                            rim_geran_info))
                {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "seq no. received is not valid or reporting is OFF"
                            " for corresponding cell");
                }
                                
                /*SPR_18414_START*/
                /*code deleted */
                /*SPR_18414_STOP*/

                else
                {
                    if((p_rrc_rrm_rim_info->bitmask & RIM_INFO_APP_CONTAINER_PRESENT) && 
                            (p_rrc_rrm_rim_info->app_cont.bitmask & RIM_INFO_APP_CONTAINER_NACC_PRESENT))
                    {
                       /*SPR  18869 FIX START*/
                        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].rim_geran_info = rrm_mem_get(sizeof(rrm_rim_geran_info_t));           
                        if (RRM_PNULL == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].rim_geran_info)
                        {   
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                          "Memory allocation to rim_geran_info failed" );
                            RRM_UT_TRACE_EXIT();
                        }
                        RRM_MEMSET(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].rim_geran_info, RRM_ZERO, sizeof(rrm_rim_geran_info_t));
                        /*SPR 18869 FIX END*/
                        if(p_rrc_rrm_rim_info->app_cont.nacc.type == RIM_SI_MSG)
                        {
                            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                               rim_geran_info->bitmask |= RRM_GERAN_SI_PRESENT;
                             /*SPR 20553 FIX START */
                             /*SPR 19765 FIX START*/
                            buffer_length = RIM_MAX_SI_PAYLOAD_INDIV; 
                             /*SPR 19765 FIX END*/
                             /*SPR 20553 FIX END */
                        }
                        else if(p_rrc_rrm_rim_info->app_cont.nacc.type == RIM_PSI_MSG)
                        {
                            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                               rim_geran_info->bitmask |= RRM_GERAN_PSI_PRESENT;
                               /*SPR 20553 FIX START */
                             /*SPR 19765 FIX START*/
                           buffer_length = RRM_RIM_MAX_SI_PSI_PAYLOAD_INDIV; 
                             /*SPR 19765 FIX END*/
                              /*SPR 20553 FIX END */
                        }
                        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                            rim_geran_info->num_si_psi = p_rrc_rrm_rim_info->app_cont.nacc.num_si_psi;
                        for(num = RRM_ZERO; (num < p_rrc_rrm_rim_info->app_cont.nacc.num_si_psi)
                        /* Coverity 19oct Start : 54994 */
                        && (num < RIM_MAX_SI_PSI_PAYLOAD); num++)
                        /* Coverity 19oct End : 54994 */
                        {
                            /* SPR 18738 fix start */
                            RRM_MEMCPY(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                                    geran_freq_cells[count].rim_geran_info->geran_si_psi[num].si_psi,
                                    p_rrc_rrm_rim_info->app_cont.nacc.si_psi_indiv[num].si_psi,
                              /*SPR 20553 FIX START */
                             /*SPR 19765 FIX START*/
                                    buffer_length*(sizeof(U8)));
                             /*SPR 19765 FIX END*/
                             /*SPR 20553 FIX END */
                            /* SPR 18738 fix end */
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_DETAILED,"Updating SI/PSI inforamtion for the respective cell");
                        }
                    }
                    p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                        last_recd_rsn = p_rrc_rrm_rim_info->seq_num;
                    if(p_rrc_rrm_rim_info->pdu_ind.ack == RIM_ACK_REQUESTED)
                    {
                        rrm_send_rim_ack(count, RIM_NACC_APP, p_cell_ctx);
                    }
                    else
                    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"ack is not requested"
                                " so no need to send ack");
                    }
                }
                break;
            }
            else
            {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "There is no reporting cell id present in the list");
            }
        }
   RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/*RIM changes start*/
/****************************************************************************
* Function Name  : rmcm_rim_info_resp
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Handling the rim info resp
****************************************************************************/
rrm_return_et
rmcm_rim_info_resp
(
 rrm_cell_context_t *p_cell_ctx /*cell context*/
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_t    return_val = RRM_FALSE;
    rim_information_t *p_rrc_rrm_rim_info = RRM_PNULL;
    U8 count                   = RRM_ZERO;
    U16 rnc_id                 = RRM_ZERO;
    U16 buffer_length          = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_rim_info = p_cell_ctx->p_incoming_api_info;

    /*Performing action for Geran cell*/
    if(p_rrc_rrm_rim_info->app_idty == RIM_NACC_APP)
    {
        /*Klockwork_fix_start*/
        rmcm_rim_info_resp_nacc_app(p_cell_ctx ,p_rrc_rrm_rim_info);
        /*Klockwork_fix_end*/
    }
    /*Performing action for UTRAN cell*/
    else if(p_rrc_rrm_rim_info->app_idty == RIM_UTRA_SI_APP)
    {
        for(count=RRM_ZERO ; count < p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                num_valid_utran_freq_cell; count++)
        {
	    U16 *p_temp_rnc_id = RRM_PNULL;
	    p_temp_rnc_id = (U16 *)p_rrc_rrm_rim_info->src_cell.utran_rtng_addr.rnc_id;
            rnc_id = RRM_NTOHS(*(p_temp_rnc_id));
            if((rnc_id ==
              p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].uc_id.rnc_id)
              &&
              (!RRM_MEMCMP(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rai.lai.lac,
              p_rrc_rrm_rim_info->src_cell.utran_rtng_addr.routing_idty.lac,
              RRM_OAM_MAX_NUM_LAC_OCTETS*sizeof(U8))) &&
              (p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rai.rac
              == p_rrc_rrm_rim_info->src_cell.utran_rtng_addr.routing_idty.rac))
            {
                return_val = rrm_check_for_stale_rsn(p_rrc_rrm_rim_info->seq_num,
                        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                        utran_freq_cells[count].last_recd_rsn);
                if((RRM_TRUE == return_val) && (RRM_PNULL == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                            utran_freq_cells[count].rim_utran_info))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "seq no. received is already present or reporting is"
                            " OFF for corresponding cell");
                }
                
                /*SPR_18414_START*/
                /*code deleted*/
                /*SPR_18414_STOP*/
                else
                {
                    if((p_rrc_rrm_rim_info->bitmask & RIM_INFO_APP_CONTAINER_PRESENT) && 
                            (p_rrc_rrm_rim_info->app_cont.bitmask & RIM_INFO_APP_CONTAINER_UTRA_SI_PRESENT))
                    {
                       
                 /*SPR_18813_START*/
                        p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rim_utran_info = rrm_mem_get(sizeof(rrm_rim_utran_info_t));
                        buffer_length = p_rrc_rrm_rim_info->app_cont.utra_si.len;
                        if (RRM_PNULL == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rim_utran_info)
                        {     
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                          "Memory allocation to rim_utran_info failed" );
                            RRM_UT_TRACE_EXIT();
                            return RRM_FAILURE;
                        }     
                        RRM_MEMSET(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rim_utran_info, RRM_ZERO, sizeof(rrm_rim_utran_info_t));
                /*SPR_18813_STOP*/
                        if(buffer_length > RRM_RIM_MAX_UTRA_SI_PAYLOAD)
                        {
                       /*SPR_18414_START*/
                       /* code deleted */
                       /*SPR_18414_STOP*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Unsetting the bitmask for utra_si as length received is "
                                    "more than the permissible limit, so buffer cannot be updated");
                        }
                       
                        /*SPR_18414_START*/
                        else if (buffer_length)
                        /*SPR_18414_STOP*/
                        {
                            RRM_MEMCPY(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                                    utran_freq_cells[count].rim_utran_info->utran_si,
                                    p_rrc_rrm_rim_info->app_cont.utra_si.si, (buffer_length*sizeof(U8)));
                            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].
                            rim_utran_info->utran_si_len = buffer_length;
                            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].
                                rim_utran_info->bitmask |= RRM_UTRAN_SI_PRESENT;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_DETAILED,"Updating SI inforamtion for the respective cell");
                        }
                    }
                    p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].
                        last_recd_rsn = p_rrc_rrm_rim_info->seq_num;
                    if(p_rrc_rrm_rim_info->pdu_ind.ack == RIM_ACK_REQUESTED)
                    {
                        rrm_send_rim_ack(count, RIM_UTRA_SI_APP, p_cell_ctx);
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "ack is not requested so no need to send ack");
                    }
                }
                break;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "There is no reporting cell id present");
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*RIM changes end*/


/* DYNAMIC ICIC CHANGES START */

rrm_void_t
get_centre_freq_range
( 
  U32 prbs_configured_in_cell,
  U32 *p_centre_start_prb,
  U32 *p_centre_end_prb
)
{
   RRM_UT_TRACE_ENTER();
   
   switch(prbs_configured_in_cell)
   {
       case PRB_COUNT_6: 
           *p_centre_start_prb = C_PRB_STRT_BW_1_4; 
           *p_centre_end_prb   = C_PRB_END_BW_1_4;
           break;

       case PRB_COUNT_15:
           *p_centre_start_prb = C_PRB_STRT_BW_3; 
           *p_centre_end_prb   = C_PRB_END_BW_3;
           break;

       case PRB_COUNT_25:
           *p_centre_start_prb = C_PRB_STRT_BW_5; 
           *p_centre_end_prb   = C_PRB_END_BW_5;
           break;

       case PRB_COUNT_50:
           *p_centre_start_prb = C_PRB_STRT_BW_10; 
           *p_centre_end_prb   = C_PRB_END_BW_10;
           break;

       case PRB_COUNT_75:
           *p_centre_start_prb = C_PRB_STRT_BW_15; 
           *p_centre_end_prb   = C_PRB_END_BW_15;
           break;

       case PRB_COUNT_100:
           *p_centre_start_prb = C_PRB_STRT_BW_20; 
           *p_centre_end_prb   = C_PRB_END_BW_20;
           break;
       default :
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                   "Incorrect value received for Cell PRB count = %u",prbs_configured_in_cell);
   }
   RRM_UT_TRACE_EXIT();
}


rrm_void_t
map_reported_prbs_arnd_centre_freq
(
  U8  *p_per_prb_map,
  U32 prbs_configured_in_srv_cell,
  U32 prbs_configured_in_neigh_cell
)
{
    U32 srv_centre_start_prb   = RRM_ZERO;
    U32 srv_centre_end_prb     = RRM_ZERO;
    U32 neigh_centre_start_prb = RRM_ZERO;
    U32 neigh_centre_end_prb   = RRM_ZERO;
    U8  tem_per_prb_map[RRM_MAX_PRBS_COUNT] = {RRM_ZERO};
    U32 neigh_cell_start_prb   = RRM_ZERO; 
    U32 neigh_cell_end_prb     = RRM_ZERO;
    U32 temp_per_prb_count     = RRM_ZERO;
    U32 prb_counter            = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /*Get Centre Freq PRBs for Serving cell */
    get_centre_freq_range( prbs_configured_in_srv_cell,
            &srv_centre_start_prb,&srv_centre_end_prb);

    /*Get Centre Freq PRBs for Neighbouring cell */
    get_centre_freq_range( prbs_configured_in_neigh_cell,
            &neigh_centre_start_prb,&neigh_centre_end_prb);

    neigh_cell_start_prb =  neigh_centre_start_prb - srv_centre_start_prb; 
    neigh_cell_end_prb   =  neigh_centre_end_prb +
        (prbs_configured_in_srv_cell - srv_centre_end_prb);

   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
		    "Total PRB count in Neighbour [%d] , CellCentre start PRB [%d] , CellCentre END PRB [%d] ",
             prbs_configured_in_neigh_cell,neigh_cell_start_prb,neigh_cell_end_prb);

    for( prb_counter = neigh_cell_start_prb ; prb_counter <= neigh_cell_end_prb ; prb_counter++)
    {
        tem_per_prb_map[temp_per_prb_count++] = p_per_prb_map[prb_counter];
    }

    RRM_MEMCPY(p_per_prb_map,tem_per_prb_map,RRM_MAX_PRBS_COUNT);

    RRM_UT_TRACE_EXIT();
}

/*****************************************************************************
 * Array Name     : perform_icic_on_serving_cell_in_ul_and_dl 
 * Inputs         : Pointer to Cell Context 
 *                  PRB Count 
 *                  Pointer to RNTP map 
 *                  Pointer to HII map 
 *                  Pointer to OI map 
 *                  Bool value pass for HII, OI and RNTP status 
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : This function will perform actions based on HII, OI and 
 *		            RNTP reports received on X2
 ****************************************************************************/
rrm_return_et 
perform_icic_on_serving_cell_in_ul_and_dl
(
 rrm_cell_context_t *p_cell_ctx,        /* cell context */
 U32                 prb_configured_in_srv_cell,
 U8                 *p_hii_per_prb,
 rrm_bool_et         hii_reported_status,
    /*SPR 17777 +-*/
 rrm_bool_et         oi_reported_status,
 U8                  *p_rntp_per_prb,
 rrm_bool_et         rntp_reported_status
)
{
    rrm_resource_partition_info_t      *p_dl_resource_partition_info = RRM_PNULL;
    rrm_resource_partition_info_t      *p_ul_resource_partition_info = RRM_PNULL;
    rrm_l2_icic_l1_l2_report_info_t    *p_icic_l1_l2_report_info = RRM_PNULL;
    U32                                  prb_counter = RRM_ZERO;
    U32                                  count_of_ce_prbs_common_bw_serving_and_peer = RRM_ZERO;
    U32                                  count_of_prbs_expected_to_be_used_by_peer = RRM_ZERO;
    U32                                 dl_ce_common_prb_percentage_bw_serving_and_peer = RRM_ZERO;
    U32                                 ul_ce_common_prb_percentage_bw_serving_and_peer = RRM_ZERO;
    U32                                 dl_ce_prb_usage_percentage = RRM_ZERO;
    U32                                 ul_ce_prb_usage_percentage = RRM_ZERO;
    U32                                  new_requested_prbs_for_ce = RRM_ZERO;
    U32                                  new_start_rb_for_ce_region = RRM_ZERO;
    U32                                  current_ce_prb_start_index = RRM_ZERO;
    U32                                  current_ce_prb_count = RRM_ZERO;
    U32                                  orig_ce_prb_start_index = RRM_ZERO;
    U32                                  orig_ce_prb_count = RRM_ZERO;
    U32                                  new_start_rb = RRM_ZERO;
    U32                                  total_num_of_rb = RRM_ZERO;
    S32                                  serving_cell_prb_to_modify = RRM_ZERO;

    rrm_resource_partition_info_t      *p_dl_resource_partition_info_new = RRM_PNULL;
    rrm_resource_partition_info_t      *p_ul_resource_partition_info_new = RRM_PNULL;
    rrm_return_et                      ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    RRM_ASSERT(RRM_PNULL != p_rntp_per_prb);
    RRM_ASSERT(RRM_PNULL != p_hii_per_prb);
    /*SPR 17777 +-*/

    /* Fetch Partition Info from Cell Context.
       No Need to check for bitmask presence as 
       it is already validated in caller function
     */
    p_dl_resource_partition_info = 
        &(p_cell_ctx->operator_info.dynamic_icic_info.dl_resource_partition_info);
    /* SPR 22026 +- */

    if (p_cell_ctx->operator_info.dynamic_icic_info.bitmask & 
            RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT)
    {
        p_ul_resource_partition_info = 
            &(p_cell_ctx->operator_info.dynamic_icic_info.ul_resource_partition_info);
    /* SPR 22026 +- */
    }

    p_icic_l1_l2_report_info = 
        &(p_cell_ctx->icic_l1_l2_report_info);
    /* SPR 22026 +- */

    /* Actions performed based on RNTP Reports*/
    if (RRM_TRUE == rntp_reported_status)
    {
        /* SPR 21843 Fix Start */
        /* Code Removed */
        /* SPR 21843 Fix End */
        /* 
           Fetch the intersection of CE PRB Map 
           This operation shall provide the bitmap
           for the CE Partition
           */
        if (p_dl_resource_partition_info->bitmask &
                RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT)
        {
            for (prb_counter = p_dl_resource_partition_info->cell_edge_region.start_rb; 
                    prb_counter < p_dl_resource_partition_info->cell_edge_region.start_rb + 
                    p_dl_resource_partition_info->cell_edge_region.num_of_rb; prb_counter++) 
            {
                /* 
                   This intersection of CE PRBs(serving and Peer) will give the idea
                   of the number of PRBs that may be scheduled by both the eNodeBs
                   in future to transmit the DL data for CE UEs
                   */
                if (p_cell_ctx->icic_l1_l2_report_info.
                        relative_narrowband_tx_power.
                        rntp_per_prb[prb_counter] & p_rntp_per_prb[prb_counter])
                {
                    count_of_ce_prbs_common_bw_serving_and_peer++;
                }
                if (RRM_ONE == p_rntp_per_prb[prb_counter])
                {
                    /* Peer is asking for BW from this Cell */
                    count_of_prbs_expected_to_be_used_by_peer++;
                }
            }
            /* Calculation of %age for the CE RBs that can be allocated by Peer in future for DL */               
            dl_ce_common_prb_percentage_bw_serving_and_peer = (((float)count_of_ce_prbs_common_bw_serving_and_peer /
                        (float)p_dl_resource_partition_info->cell_edge_region.
                        num_of_rb)) * RRM_PERCENTAGE;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "DL CE PRB count reported by peer for future use[%d], DL CE PRB common bw Serving and Peer[%d]  Total Serving CE PRBs[%d]",
                    count_of_prbs_expected_to_be_used_by_peer, 
                    count_of_ce_prbs_common_bw_serving_and_peer, 
                    p_dl_resource_partition_info->cell_edge_region.num_of_rb);

            /* Calculation of %age for the CE PRBs that can be allocated in future. This value is reported from serving L2 */
            dl_ce_prb_usage_percentage = ((float)p_icic_l1_l2_report_info->dl_ce_prb_usage /
                    (float)p_dl_resource_partition_info->cell_edge_region.
                    num_of_rb) * RRM_PERCENTAGE;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "Common CE PRBS percentage between Serving and Peer [%d], Ongoing DL CE Usage of Serving in percentage [%d]",
                    dl_ce_common_prb_percentage_bw_serving_and_peer,  dl_ce_prb_usage_percentage);

            current_ce_prb_start_index = p_dl_resource_partition_info->cell_edge_region.start_rb;
            current_ce_prb_count = p_dl_resource_partition_info->cell_edge_region.num_of_rb;
            orig_ce_prb_start_index = p_cell_ctx->operator_info.dynamic_icic_info.
                original_configured_dl_resource_partition_info.
                cell_edge_region.start_rb;
            orig_ce_prb_count = p_cell_ctx->operator_info.dynamic_icic_info.
                original_configured_dl_resource_partition_info.
                cell_edge_region.num_of_rb;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    " Current DL CE PRB: Start[%d], Number[%d], Original DL CE PRB: Start[%d], Number[%d]",
                    current_ce_prb_start_index, current_ce_prb_count, orig_ce_prb_start_index, orig_ce_prb_count);

            /* 
               "count_of_prbs_expected_to_be_used_by_peer" will give the number of PRBs that are requested by peer for 
               using the data transmission in DL in future. This request is raised only in two cases
               1) If peer has the data requirement for CE UEs and it has confirmed that it can
               use the PRBs of neighbouring cell as they are not using it. In this case, the
               "count_of_ce_prbs_common_bw_serving_and_peer" i.e the intersection of RNTP map
               from serving and peer should be ZERO.
               2) If peer has data requirement for CE UEs and it wants it original configuration back.
               In this case, "count_of_ce_prbs_common_bw_serving_and_peer" i.e the intersection of RNTP map
               from serving and peer may or may not be ZERO. To comply to this case, serving has to
               repartition its info.
               */
            if (RRM_ZERO != count_of_prbs_expected_to_be_used_by_peer)
            {
                /* Case 1 */
                if (RRM_ZERO == count_of_ce_prbs_common_bw_serving_and_peer)
                {
                    serving_cell_prb_to_modify = current_ce_prb_count - count_of_prbs_expected_to_be_used_by_peer;

                    if (serving_cell_prb_to_modify >= MIN_PRBS_LEFT_FOR_NEW_CE_UES)
                    {
                        /* repartition the current configuration to the new one.
                           In this case squeeze the current CE partition and leave
                           atleast 4 RB at CE for serving cell UEs
                           */
                        new_start_rb_for_ce_region = current_ce_prb_start_index;
                        new_requested_prbs_for_ce = serving_cell_prb_to_modify;
                    }
                    else
                    {
                        /* repartition the current configuration to the new one.
                           In this case, move the current CE partition with 4 RB
                           for CE UEs(serving cell). This CE region can be moved to either
                           left or right of originally configured. During the reshuffling
                           of partition, it should be verified that the PRBs should not be
                           used by peer in its RNTP map reported.
                           */
                        if ((serving_cell_prb_to_modify > RRM_ZERO) && 
                                (serving_cell_prb_to_modify < MIN_PRBS_LEFT_FOR_NEW_CE_UES))
                        {
                            serving_cell_prb_to_modify = MIN_PRBS_LEFT_FOR_NEW_CE_UES - serving_cell_prb_to_modify;
                        }
                        else
                        {
                            serving_cell_prb_to_modify = count_of_prbs_expected_to_be_used_by_peer - 
                                current_ce_prb_count + MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                        }
                        /* This condition states that serving has expanded its CE
                           configuration in past because of the requirement.
                           So, now time has come for serving to squeeze down its 
                           configuration to make CE PRBs available for peer
                           */
                        mandate_search_for_region_to_left_or_right_of_cnfg_partition(
                                current_ce_prb_start_index, current_ce_prb_count, 
                                serving_cell_prb_to_modify,
                                &new_start_rb, prb_configured_in_srv_cell);
                        new_start_rb_for_ce_region = new_start_rb;
                        new_requested_prbs_for_ce = MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                    }
                }
                /* This condition will hit when both the serving and peer are using 
                 * the same(not all but some) CE region. 
                 */
                else if (count_of_ce_prbs_common_bw_serving_and_peer < current_ce_prb_count)
                {
                    /* Current has more PRBs allocated against its original configuration
                     * This cell has to give up its extra used configuration and will try
                     * to re shuffle its PRBs in order to fulfill its DL CE PRB Usage
                     * OR in case it wasn't able to do that then it will revert to its
                     * original configuration
                     */
                    if(current_ce_prb_count > orig_ce_prb_count)
                    {
                        if(dl_ce_prb_usage_percentage > MIN_THRESHHOLD_CE_PRB_USAGE_REPORTED_PERCENTAGE)
                        {
                            /* Cut down CE PRBs */
                            new_requested_prbs_for_ce = current_ce_prb_count - count_of_ce_prbs_common_bw_serving_and_peer;
                        }
                        else 
                        {
                            /* Cut down CE PRBs by 50% */
                            new_requested_prbs_for_ce = p_dl_resource_partition_info->cell_edge_region.num_of_rb / RRM_TWO;
                        }
                        get_minimum_interfered_prb_region(
                                &p_rntp_per_prb[p_dl_resource_partition_info->cell_edge_region.start_rb],
                                p_dl_resource_partition_info->cell_edge_region.start_rb,
                                p_dl_resource_partition_info->cell_edge_region.num_of_rb,
                                new_requested_prbs_for_ce,
                                prb_configured_in_srv_cell,
                                &new_start_rb_for_ce_region);
                    }
                    /* This means that serving cell is using those many PRBs which are either equal to
                     * the originally configured or less than that. So, based on the current DL CE usage
                     * RRM will decide to allocate atleast those PRBs which are not common and in addition
                     * 4 PRBs to accomodate new UEs. 
                     */
                    else
                    {
                        /* DL CE PRB Usage is less tha 50% */
                        if(dl_ce_prb_usage_percentage <= MIN_THRESHHOLD_CE_PRB_USAGE_REPORTED_PERCENTAGE)
                        {
                            /* Try to Free those CE PRBs which are used by peer and try to reshufffle 
                             * the CE region with in the range currently going on
                             */
                            if((count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES) < current_ce_prb_count)
                            {
                                /* This block will contract */
                                new_requested_prbs_for_ce = count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                                total_num_of_rb = current_ce_prb_count;
                            }
                            else if ((count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES) < orig_ce_prb_count)
                            {
                                /* This block will expand */
                                new_requested_prbs_for_ce = count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                                total_num_of_rb = orig_ce_prb_count;
                            }
                            else 
                            {
                                /* This block will expand  to original count but not the original configuration*/
                                new_requested_prbs_for_ce = orig_ce_prb_count;
                                total_num_of_rb = orig_ce_prb_count;
                            }
                            get_minimum_interfered_prb_region(
                                    &p_rntp_per_prb[p_dl_resource_partition_info->cell_edge_region.start_rb],
                                    p_dl_resource_partition_info->cell_edge_region.start_rb,
                                    total_num_of_rb,
                                    new_requested_prbs_for_ce,
                                    prb_configured_in_srv_cell,
                                    &new_start_rb_for_ce_region);
                        }
                        else
                        {
                            /* Go to the original configuration */
                            new_requested_prbs_for_ce = orig_ce_prb_count;
                            new_start_rb_for_ce_region = orig_ce_prb_start_index;
                        }
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                                "New DL CE PRBs [%d] Start RB [%d]", new_requested_prbs_for_ce, new_start_rb_for_ce_region);
                    }
                }
                p_dl_resource_partition_info_new = rrm_mem_get(sizeof(rrm_resource_partition_info_t));
                if (p_dl_resource_partition_info_new == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_dl_resource_partition_info_new failed" );
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }         
                p_dl_resource_partition_info_new->bitmask = RRM_ZERO;
                p_dl_resource_partition_info_new->bitmask |= 
                    RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
                p_dl_resource_partition_info_new->num_of_cell_edge_region = RRM_ONE;

                p_dl_resource_partition_info_new->cell_edge_region.start_rb = new_start_rb_for_ce_region;
                p_dl_resource_partition_info_new->cell_edge_region.num_of_rb = new_requested_prbs_for_ce;

                /* This function will reconfigure the cell center region as per new cell edge region
                   parameters 
                   */
                reconfigure_cell_center_region(p_dl_resource_partition_info_new,
                        prb_configured_in_srv_cell);
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                        "Interference from peer is at low level. so no action..");
            }
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "DL Partioning Info not present");
        }
        /* SPR 21843 Fix Start */
        /* Code Removed */
        /* SPR 21843 Fix End */
    }

    /* Actions performed based on OI Reports*/
    if (RRM_TRUE == oi_reported_status)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "No Action defined for OI reprots");
    }
    /* Actions performed based on HII Reports*/
    if (RRM_TRUE == hii_reported_status)
    {
        /* SPR 21843 Fix Start */
        /* Code Removed */
        /* SPR 21843 Fix End */
        /* 
           Fetch the intersection of CE PRB Map 
           This operation shall provide the bitmap
           for the CE Partition
           */
        /* SPR 21843 Fix Start */
        if(RRM_PNULL != p_ul_resource_partition_info)
        {
            /* SPR 21843 Fix End */
            if (p_ul_resource_partition_info->bitmask &
                    RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT)
            {
                for (prb_counter = p_ul_resource_partition_info->cell_edge_region.start_rb; 
                        prb_counter < p_ul_resource_partition_info->cell_edge_region.start_rb + 
                        p_ul_resource_partition_info->cell_edge_region.num_of_rb; prb_counter++)
                {
                    /* 
                       This intersection of CE PRBs(serving and Peer) will give the idea
                       of the number of PRBs that may be scheduled by both the eNodeBs
                       in future to transmit the DL data for CE UEs
                       */
                    /* SPR 21843 Fix Start */
                    if (prb_counter < p_cell_ctx->icic_l1_l2_report_info.ul_high_interference_info.prb_count)
                    {
                        if (p_cell_ctx->icic_l1_l2_report_info.
                                ul_high_interference_info.
                                hii[prb_counter] & p_hii_per_prb[prb_counter])
                        {
                            count_of_ce_prbs_common_bw_serving_and_peer++;
                        }
                        if (RRM_ZERO != p_hii_per_prb[prb_counter])
                        {
                            /* Peer is asking for BW from this Cell */
                            count_of_prbs_expected_to_be_used_by_peer++;
                        }
                    }
                    /* SPR 21843 Fix End */
                }
                /* Calculation of %age for the CE RBs that can be allocated by Peer in future for DL */               
                /*Coverity_fix_start_54967*/
                ul_ce_common_prb_percentage_bw_serving_and_peer = (((float )count_of_ce_prbs_common_bw_serving_and_peer /
                            (float)p_ul_resource_partition_info->cell_edge_region.
                            num_of_rb)) * RRM_PERCENTAGE;
                /*Coverity_fix_end_54967*/            

                /* Calculation of %age for the CE PRBs that can be allocated in future. This value is reported from serving L2 */
                ul_ce_prb_usage_percentage = (((float )p_icic_l1_l2_report_info->ul_ce_prb_usage /
                            (float)p_ul_resource_partition_info->cell_edge_region.
                            num_of_rb)) * RRM_PERCENTAGE;

                current_ce_prb_start_index = p_ul_resource_partition_info->cell_edge_region.start_rb;
                current_ce_prb_count = p_ul_resource_partition_info->cell_edge_region.num_of_rb;
                orig_ce_prb_start_index = p_cell_ctx->operator_info.dynamic_icic_info.original_configured_ul_resource_partition_info.
                    cell_edge_region.start_rb;
                orig_ce_prb_count = p_cell_ctx->operator_info.dynamic_icic_info.original_configured_ul_resource_partition_info.
                    cell_edge_region.num_of_rb;
                /* Coverity 54967 fix end */
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO,
                        "Common UL CE PRBS between Serving and Peer [%d%%], Ongoing UL CE Usage of Serving [%d%%]\n"
                        " %u UL CE PRB common and expected %u to be used by peer for future\n"
                        "Serving --> Current CE PRB %u, Start Idx %u Orig start Idx %u Orig PRB count %u",
                        ul_ce_common_prb_percentage_bw_serving_and_peer,  ul_ce_prb_usage_percentage,
                        count_of_ce_prbs_common_bw_serving_and_peer, count_of_prbs_expected_to_be_used_by_peer, 
                        p_ul_resource_partition_info->cell_edge_region.num_of_rb,
                        current_ce_prb_start_index, orig_ce_prb_start_index,
                        orig_ce_prb_count);

                /* 
                   "count_of_prbs_expected_to_be_used_by_peer" will give the number of PRBs that are requested by peer for 
                   using the data transmission in UL in future. This request is raised only in two cases
                   1) If peer has the data requirement for CE UEs and it has confirmed that it can
                   use the PRBs of neighbouring cell as they are not using it. In this case, the
                   "count_of_ce_prbs_common_bw_serving_and_peer" i.e the intersection of RNTP map
                   from serving and peer should be ZERO.
                   2) If peer has data requirement for CE UEs and it wants it original configuration back.
                   In this case, "count_of_ce_prbs_common_bw_serving_and_peer" i.e the intersection of RNTP map
                   from serving and peer may or may not be ZERO. To comply to this case, serving has to
                   repartition its info.
                   */
                if (RRM_ZERO != count_of_prbs_expected_to_be_used_by_peer)
                {
                    /* Case 1 */
                    if (RRM_ZERO == count_of_ce_prbs_common_bw_serving_and_peer)
                    {
                        serving_cell_prb_to_modify = current_ce_prb_count - count_of_prbs_expected_to_be_used_by_peer;

                        if (serving_cell_prb_to_modify >= MIN_PRBS_LEFT_FOR_NEW_CE_UES)
                        {
                            /* repartition the current configuration to the new one.
                               In this case squeeze the current CE partition and leave
                               atleast 4 RB at CE for serving cell UEs
                               */
                            new_start_rb_for_ce_region = current_ce_prb_start_index;
                            new_requested_prbs_for_ce = serving_cell_prb_to_modify;
                        }
                        else
                        {
                            /* repartition the current configuration to the new one.
                               In this case, move the current CE partition with 4 RB
                               for CE UEs(serving cell). This CE region can be moved to either
                               left or right of originally configured. During the reshuffling
                               of partition, it should be verified that the PRBs should not be
                               used by peer in its RNTP map reported.
                               */
                            if ((serving_cell_prb_to_modify > RRM_ZERO) && (serving_cell_prb_to_modify < MIN_PRBS_LEFT_FOR_NEW_CE_UES))
                            {
                                serving_cell_prb_to_modify = MIN_PRBS_LEFT_FOR_NEW_CE_UES - serving_cell_prb_to_modify;
                            }
                            else
                            {
                                /* SPR 21843 Fix Start */
                                if (count_of_prbs_expected_to_be_used_by_peer < (current_ce_prb_count + MIN_PRBS_LEFT_FOR_NEW_CE_UES))
                                {
                                    serving_cell_prb_to_modify =  current_ce_prb_count + MIN_PRBS_LEFT_FOR_NEW_CE_UES -
                                        count_of_prbs_expected_to_be_used_by_peer;
                                }
                                else
                                {
                                    serving_cell_prb_to_modify = count_of_prbs_expected_to_be_used_by_peer - 
                                        current_ce_prb_count + MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                                }
                                /* SPR 21843 Fix End */
                            }
                            /* This condition states that serving has expanded its CE
                               configuration in past because of the requirement.
                               So, now time has come for serving to squeeze down its 
                               configuration to make CE PRBs available for peer
                               */
                            mandate_search_for_region_to_left_or_right_of_cnfg_partition(
                                    current_ce_prb_start_index, current_ce_prb_count, serving_cell_prb_to_modify,
                                    &new_start_rb, prb_configured_in_srv_cell);
                            new_start_rb_for_ce_region = new_start_rb;
                            new_requested_prbs_for_ce = MIN_PRBS_LEFT_FOR_NEW_CE_UES;

                        }
                    }
                    /* This condition will hit when both the serving and peer are using 
                     * the same(not all but some) CE region. 
                     */
                    /* SPR 21843 Fix Start */
                    else if (count_of_ce_prbs_common_bw_serving_and_peer <= current_ce_prb_count)
                        /* SPR 21843 Fix End */
                    {
                        /* Current has more PRBs allocated against its original configuration
                         * This cell has to give up its extra used configuration and will try
                         * to re shuffle its PRBs in order to fulfill its DL CE PRB Usage
                         * OR in case it wasn't able to do that then it will revert to its
                         * original configuration
                         */
                        if(current_ce_prb_count > orig_ce_prb_count)
                        {
                            if(ul_ce_prb_usage_percentage > MIN_THRESHHOLD_CE_PRB_USAGE_REPORTED_PERCENTAGE)
                            {
                                /* Cut down CE PRBs */
                                new_requested_prbs_for_ce = current_ce_prb_count - count_of_ce_prbs_common_bw_serving_and_peer;
                            }
                            else 
                            {
                                /* Cut down CE PRBs by 50% */
                                new_requested_prbs_for_ce = p_ul_resource_partition_info->cell_edge_region.num_of_rb / RRM_TWO;
                            }
                            get_minimum_interfered_prb_region(
                                    /* SPR 21843 Fix Start */
                                    &p_hii_per_prb[p_ul_resource_partition_info->cell_edge_region.start_rb],
                                    /* SPR 21843 Fix End */
                                    p_ul_resource_partition_info->cell_edge_region.start_rb,
                                    p_ul_resource_partition_info->cell_edge_region.num_of_rb,
                                    new_requested_prbs_for_ce,
                                    prb_configured_in_srv_cell,
                                    &new_start_rb_for_ce_region);
                        }
                        /* This means that serving cell is using those many PRBs which are either equal to
                         * the originally configured or less than that. So, based on the current UL CE usage
                         * RRM will decide to allocate atleast those PRBs which are not common and in addition
                         * 4 PRBs to accomodate new UEs. 
                         */
                        else
                        {
                            /* UL CE PRB Usage is less tha 50% */
                            if(ul_ce_prb_usage_percentage <= MIN_THRESHHOLD_CE_PRB_USAGE_REPORTED_PERCENTAGE)
                            {
                                /* Try to Free those CE PRBs which are used by peer and try to reshufffle 
                                 * the CE region with in the range currently going on
                                 */
                                if((count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES) < current_ce_prb_count)
                                {
                                    /* This block will contract */
                                    new_requested_prbs_for_ce = count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                                    total_num_of_rb = current_ce_prb_count;
                                }
                                else if ((count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES) < orig_ce_prb_count)
                                {
                                    /* This block will expand */
                                    new_requested_prbs_for_ce = count_of_ce_prbs_common_bw_serving_and_peer + MIN_PRBS_LEFT_FOR_NEW_CE_UES;
                                    total_num_of_rb = orig_ce_prb_count;
                                }
                                else 
                                {
                                    /* This block will expand  to original count but not the original configuration*/
                                    new_requested_prbs_for_ce = orig_ce_prb_count;
                                    total_num_of_rb = orig_ce_prb_count;
                                }
                                get_minimum_interfered_prb_region(
                                        /* SPR 21843 Fix Start */
                                        &p_hii_per_prb[p_ul_resource_partition_info->cell_edge_region.start_rb],
                                        /* SPR 21843 Fix End */
                                        p_ul_resource_partition_info->cell_edge_region.start_rb,
                                        total_num_of_rb,
                                        new_requested_prbs_for_ce,
                                        prb_configured_in_srv_cell,
                                        &new_start_rb_for_ce_region);
                            }
                            else
                            {
                                /* Go to the original configuration */
                                new_requested_prbs_for_ce = orig_ce_prb_count;
                                new_start_rb_for_ce_region = orig_ce_prb_start_index;
                            }
                        }
                    }
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO,
                            "New UL CE PRBs [%d] Start RB [%d]", new_requested_prbs_for_ce, new_start_rb_for_ce_region);
                    p_ul_resource_partition_info_new = rrm_mem_get(sizeof(rrm_resource_partition_info_t));
                    if (p_ul_resource_partition_info_new == RRM_PNULL)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Memory allocation to p_ul_resource_partition_info_new failed" );
                        /* COVERITY : RESOURCE LEAK : CID : 54322 fix start */
                        if( RRM_NULL != p_dl_resource_partition_info_new )
                            RRM_MEM_FREE(p_dl_resource_partition_info_new);
                        /* COVERITY : RESOURCE LEAK : CID : 54322 fix end */
                        RRM_UT_TRACE_EXIT();
                        return RRM_FAILURE;
                    }
                    p_ul_resource_partition_info_new->bitmask = RRM_ZERO;
                    p_ul_resource_partition_info_new->bitmask |= 
                        RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
                    p_ul_resource_partition_info_new->num_of_cell_edge_region = RRM_ONE;

                    p_ul_resource_partition_info_new->cell_edge_region.start_rb = new_start_rb_for_ce_region;
                    p_ul_resource_partition_info_new->cell_edge_region.num_of_rb = new_requested_prbs_for_ce;

                    /* This function will reconfigure the cell center region as per new cell edge region
                       parameters 
                       */
                    reconfigure_cell_center_region(p_ul_resource_partition_info_new,
                            prb_configured_in_srv_cell);
                }
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                            "Interference from peer is at low level. so no action..");
                }
            }
            /* SPR 21843 Fix Start */
        }
        /* Code Removed */
        /* SPR 21843 Fix End */
    }

    /* 
       Now this logic will check what action should be taken based on RNTP and OI reports
       If both or any of the DL Repartitioning or UL Repartitioning is required then
       After receiving response from L2, RRM will update partitioning info in cell context.
     */
    p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.bitmask = RRM_ZERO;
    if ((RRM_PNULL != p_dl_resource_partition_info_new) ||
            (RRM_PNULL != p_ul_resource_partition_info_new))
    {
        /* Send Cell Config Request L2 */
        ret_val = build_and_send_l2_cell_config_req((rrm_resource_partition_info_t *) p_dl_resource_partition_info_new,
                (rrm_resource_partition_info_t *)p_ul_resource_partition_info_new,
                 RRM_PNULL,RRM_PNULL,
                p_cell_ctx->cell_index, p_cell_ctx->ongoing_trans_id
                );
        if (RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
                    "Failure returned during the processing of l2_cell_config_req");
            /* COVERITY : RESOURCE LEAK : CID : 54322,54323 fix start */         
            if(RRM_PNULL != p_dl_resource_partition_info_new) 
                RRM_MEM_FREE(p_dl_resource_partition_info_new);
            if(RRM_PNULL != p_ul_resource_partition_info_new) 
                RRM_MEM_FREE(p_ul_resource_partition_info_new);
            /* COVERITY : RESOURCE LEAK : CID : 54322,54323 fix end */    
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "Success returned during the processing of l2_cell_config_req");

            /* Update Cell Context */
            if(RRM_PNULL != p_dl_resource_partition_info_new) 
            {
                p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.bitmask |= 
                    RRM_CTXT_DL_PARTIONING_INFO_PRESENT;
                RRM_MEMCPY(&p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.dl_resource_partition_info_new,
                        p_dl_resource_partition_info_new,
                        sizeof(rrm_resource_partition_info_t));
                /* SPR: 15922 Fix Start */
                /*Code removed*/
                /* SPR: 15922 Fix End */
            }
            if(RRM_PNULL != p_ul_resource_partition_info_new) 
            {
                p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.bitmask |= 
                    RRM_CTXT_UL_PARTIONING_INFO_PRESENT;
                RRM_MEMCPY(&p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.ul_resource_partition_info_new,
                        p_ul_resource_partition_info_new,
                        sizeof(rrm_resource_partition_info_t));
                /* SPR: 15922 Fix Start */
                /*Code removed*/
                /* SPR: 15922 Fix End */
            }
            CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell State:%s[%d]",CELL_FSM_STATE[p_cell_ctx->cell_state],
                    p_cell_ctx->cell_state);
        }

        /* SPR: 15922 Fix Start */
        if(RRM_PNULL != p_dl_resource_partition_info_new)
        {
            RRM_MEM_FREE(p_dl_resource_partition_info_new);
        }
        if(RRM_PNULL != p_ul_resource_partition_info_new)
        {
            RRM_MEM_FREE(p_ul_resource_partition_info_new);
        }
        /* SPR: 15922 Fix End */
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/*********************************************************************
 * Function Name  : rmcm_ignore_event 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_ignore_event in FSM
 *********************************************************************/
rrm_return_et
rmcm_ignore_event 
(
        rrm_cell_context_t *p_cell_ctx   /* cell context */
)
{
   U8 current_cell_state = RRM_NULL;
   rrm_return_et ret_val = RRM_FAILURE;

   RRM_UT_TRACE_ENTER();

   current_cell_state = p_cell_ctx->cell_state;
   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
             "Invalid Cell state [%d] to process the requested API",
              current_cell_state);

   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/*****************************************************************************
 * Array Name     : rmcm_uem_resp_or_l2_resp_event 
 * Inputs         : Pointer to Cell Context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function will  processss the response received from 
 *		            UEM and L2 during dynamic icic implementation.
 ****************************************************************************/
rrm_return_et 
rmcm_uem_resp_or_l2_resp_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
	rrmuem_cm_update_ue_info_resp_t        *p_uem_info_resp = RRM_PNULL;
	rrm_icic_info_stored_t                 *p_decision_info_stored = RRM_PNULL;
	RrmMacCellConfigCnf                    *p_mac_config_cnf = RRM_PNULL;
	/** eICIC_PHASE_1_2_CHANGES_START */
	rrmcm_rmif_generic_resp_t               generic_resp_to_mif = {RRM_ZERO};
	rrmuem_cellm_eicic_provision_reconfig_resp_t *p_cellm_eicic_provision_reconfig_resp = RRM_PNULL;
	/** eICIC_PHASE_1_2_CHANGES_END */
    /* eICIC_PHASE_1_2_CHANGES_START */
    U8                                      ncl_count = RRM_ZERO;
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    //coverity_fix_req
	rrm_return_et                          ret_val = RRM_SUCCESS;
	/* eICIC_PHASE_1_2_CHANGES_END */
	/** eICIC_PHASE_1_2_CHANGES_START */
	generic_resp_to_mif.fail_cause = RRM_NO_ERROR;
	/** eICIC_PHASE_1_2_CHANGES_END */
    /* new_api_element_start */
    U8                    new_meas_abs_pattern[RRM_MAX_PATTERN_BYTE] ;
    /* new_api_element_start */
	RRM_UT_TRACE_ENTER();

	p_decision_info_stored = (rrm_icic_info_stored_t *)
		&p_cell_ctx->icic_l1_l2_report_info.decision_info_stored;
	RRM_ASSERT(RRM_PNULL != p_decision_info_stored);

	/* Check if this response is from UEM or L2. 
	   If response is expected from UEM then below bitmask is present
	   else this message is received from L2 after reconfiguring
	   partitioning info
	 */
/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
     abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
     abs_size = RRM_MAX_PATTERN_BYTE;
#endif
        /*EICIC_TDD_CHANGES_END*/

	if (p_decision_info_stored->bitmask & RRM_CTXT_UEM_UPDATE_INFO_PRESENT)
	{
		p_uem_info_resp = (rrmuem_cm_update_ue_info_resp_t *)
			p_cell_ctx->p_incoming_api_info;
		RRM_ASSERT(RRM_PNULL != p_uem_info_resp);

		if ((p_decision_info_stored->cellm_uem_ue_info_req.bitmask & 
					RRMUEM_CM_UE_LOCATION_UPDATE_ACTION_PRESENT) &&
				(p_decision_info_stored->cellm_uem_ue_info_req.bitmask &
				 RRMUEM_CM_CC_UE_OLPC_REDUCE_POWER_ACTION_PRESENT))
		{
			switch(p_uem_info_resp->response)
			{
				case UE_PARTIAL_SUCCESS_WITH_OLPC_REDUCE_POWER_ACTION_FAILED:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was combined but OLPC Failed");
						break;
					}
				case UE_PARTIAL_SUCCESS_WITH_LOCATION_INFO_ACTION_FAILED:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was combined but Location info update Failed");
						break;
					}
				case UE_COMBINED_ACTION_FAILURE:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was combined but both actions gets failed");
						break;
					}
				case UE_COMBINED_ACTION_SUCCESS:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was combined and received success for both");
						break;
					}
				default:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
								"Expected was combined but un expected value received [%d]",
								p_uem_info_resp->response);
						break;
					}

			}
		}
		else if (p_decision_info_stored->cellm_uem_ue_info_req.bitmask & 
				RRMUEM_CM_UE_LOCATION_UPDATE_ACTION_PRESENT)
		{
			switch(p_uem_info_resp->response)
			{
				case UE_LOCATION_INFO_ACTION_FAILURE:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was Location Update but Failed");
						break;
					}
				case UE_LOCATION_INFO_ACTION_SUCCESS:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was Location Update  and received success ");
						break;
					}
				default:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
								"Expected was Location Update but un expected value received [%d]",
								p_uem_info_resp->response);
						break;
					}
			}
		}
		else if (p_decision_info_stored->cellm_uem_ue_info_req.bitmask &
				RRMUEM_CM_CC_UE_OLPC_REDUCE_POWER_ACTION_PRESENT)
		{
			switch(p_uem_info_resp->response)
			{
				case UE_OLPC_REDUCE_POWER_ACTION_FAILURE:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was OLPC Action but Failed");
						break;
					}
				case UE_OLPC_REDUCE_POWER_ACTION_SUCCESS:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
								"Expected was OLPC Action and received success ");
						break;
					}
				default:
					{
						RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
								"Expected was OLPC Action but un expected value received [%d]",
								p_uem_info_resp->response);
						break;
					}
			}
		}
		else
		{
			RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
					"Some problem in response code from UEM");
		}

		/*Unset the bitmask */
		p_decision_info_stored->bitmask ^= RRM_CTXT_UEM_UPDATE_INFO_PRESENT;
		p_decision_info_stored->cellm_uem_ue_info_req.bitmask = RRM_ZERO;
	}
	/** eICIC_PHASE_1_2_CHANGES_START */
	else if(p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask & RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT)
    {   
        /**13894_fix_start*/
        p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask ^= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_UEM_PRESENT;
        /**13894_fix_end*/
        p_cellm_eicic_provision_reconfig_resp = ( rrmuem_cellm_eicic_provision_reconfig_resp_t *)
            p_cell_ctx->p_incoming_api_info;
        RRM_ASSERT(RRM_PNULL != p_cellm_eicic_provision_reconfig_resp);

        if(p_cellm_eicic_provision_reconfig_resp->response == RRM_SUCCESS)
		{
		    /*eicic_subset_pattern_fix_start*/	
            if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask == RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT)
            {
                RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                        p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern,abs_size);
                rrm_copy_tdd_bits(abs_size ,p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
                RRM_MEMCPY(p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset,
                        p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern,abs_size);
                rrm_copy_tdd_bits(abs_size ,p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset);
                generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
                generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
                generic_resp_to_mif.response = RRM_SUCCESS;
                generic_resp_to_mif.fail_cause = RRM_NO_ERROR;
                ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                        RRMCM_RMIF_CELL_RECONFIG_RESP);
                if (RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
                            "Failed to Send Reconfig Generic Resp To MIF");
                }
                CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
                if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
                {	
                    RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
                    p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
                }
                p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask = RRM_ZERO;
            }
            else
            {
                if(RRM_FAILURE == build_and_send_l2_cell_config_req_for_eicic_reconfig(&p_cell_ctx->rrm_eicic_cell_info.mac_config_data,
                            p_cellm_eicic_provision_reconfig_resp->cell_index,
                            p_cellm_eicic_provision_reconfig_resp->transaction_id))
                {
                    /*SPR 14529 start*/
                    generic_resp_to_mif.cellindex = p_cell_ctx->cell_index;
                    generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
                    generic_resp_to_mif.response = RRM_FAILURE;
                    generic_resp_to_mif.fail_cause = RRM_ERR_CELL_RECONFIG_ONGOING;
                    ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                            RRMCM_RMIF_CELL_RECONFIG_RESP);
                    if (RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
                                "Failed to Send Reconfig Generic Resp To MIF");
                    }
                    CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
                    if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
                    {
                        RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
                        p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
                    }
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask = RRM_ZERO;
                    /*SPR 14529 end*/
                } 
           		else
			    {  
					CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
							"Success returned during the processing of l2_cell_config_req");
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask |= RRM_CTXT_SENDING_EICIC_RECONFIG_TO_MAC_PRESENT;	
                }
           } 
        }
        else
        {
            generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
            generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_CELL_RECONFIG_ONGOING;
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
                    RRMCM_RMIF_CELL_RECONFIG_RESP);
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
                        "Failed to Send Reconfig Generic Resp To MIF");
                /*bug_13894_start*/
                //code_deleted
                /*bug_13894_end*/

            }
            CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);

            /*reseting the reconfig bitmasks for eicic*/
            //coverity_fix_req
            if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
                /*BUG:9237 end*/
            {	
                RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
                p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
            }

            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask = RRM_ZERO;

        }
    }    
	else
	{
		/** eICIC_PHASE_1_2_CHANGES_END */
		if (p_decision_info_stored->bitmask & RRM_CTXT_DL_PARTIONING_INFO_PRESENT)
		{
			p_mac_config_cnf = (RrmMacCellConfigCnf *)
				p_cell_ctx->p_incoming_api_info;
			RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
			if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						"Repartitioning Failed at L2. Resetting old info to zero.. no action");
			}
			else
			{
				if (p_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRM_CTXT_DL_PARTIONING_INFO_PRESENT)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"New Repartitioning info commited in DL");
					RRM_MEMCPY(&p_cell_ctx->operator_info.dynamic_icic_info.dl_resource_partition_info,
							&p_decision_info_stored->dl_resource_partition_info_new,
							sizeof(rrm_resource_partition_info_t));
				}
			}
			/* Unset the bitmask */
			p_decision_info_stored->bitmask ^= RRM_CTXT_DL_PARTIONING_INFO_PRESENT;
			RRM_MEMSET(&(p_decision_info_stored->dl_resource_partition_info_new), RRM_ZERO,
					sizeof(rrm_resource_partition_info_t));
		}
		if (p_decision_info_stored->bitmask & RRM_CTXT_UL_PARTIONING_INFO_PRESENT)
		{
			p_mac_config_cnf = (RrmMacCellConfigCnf *)
				p_cell_ctx->p_incoming_api_info;
			RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
			if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						"Repartitioning Failed at L2. Resetting old info to zero.. no action");
			}
			else
			{
				if (p_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRM_CTXT_UL_PARTIONING_INFO_PRESENT)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"New Repartitioning info commited in UL");
					RRM_MEMCPY(&p_cell_ctx->operator_info.dynamic_icic_info.ul_resource_partition_info,
							&p_decision_info_stored->ul_resource_partition_info_new,
							sizeof(rrm_resource_partition_info_t));
				}
			}
			/* Unset the bitmask */
			p_decision_info_stored->bitmask ^= RRM_CTXT_UL_PARTIONING_INFO_PRESENT;
			RRM_MEMSET(&(p_decision_info_stored->ul_resource_partition_info_new), RRM_ZERO,
					sizeof(rrm_resource_partition_info_t));
		}
        /* eICIC_PHASE_1_2_CHANGES_START */
        if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_ABS_PATTERN_FLAG_PRESENT)
        {
            p_mac_config_cnf = (RrmMacCellConfigCnf *)
                p_cell_ctx->p_incoming_api_info;
            RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
            if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Common ABS pattern after Load info Update is not accepted by the L2. Cleaning up the eICIC related data");

                for(ncl_count = RRM_ZERO; 
                        ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ; 
                        ncl_count++)
                {
                    if( RRM_EICIC_TEMP_ABS == 
                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                            rrm_intra_ncl_eicic_data.abs_pattern_status)
                    {
                        /* bug_13935_start */ 
                        RRM_MEMSET(&(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                                    rrm_intra_ncl_eicic_data), RRM_ZERO,sizeof(rrm_intra_ncl_eicic_data_t)); 
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                            rrm_intra_ncl_eicic_data.abs_pattern_status = RRM_EICIC_NO_ABS;
                        /* bug_13935_end */  
                    }
                    else if ( RRM_EICIC_UPDATE_ABS == 
                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                            rrm_intra_ncl_eicic_data.abs_pattern_status)
                    {
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                            rrm_intra_ncl_eicic_data.abs_pattern_status = RRM_EICIC_CNFRMD_ABS;
                    }
                    /* bug_13935_start */  
                    RRM_MEMSET( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                            rrm_intra_ncl_eicic_data.temp_abs_pattern, RRM_ZERO, RRM_MAX_PATTERN_BYTE);
                    /* bug_13935_end */  
                }

                /*13987_fix_start*/
                if( p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT)
                {
                    rrm_raise_error_event_notification( RRM_EE_VICTM_ABS_NOT_APPLIED);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "VICTIM/USABLE ABS pattern is not Applied on MAC");
                }
                if( p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT)
                {
                    if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_LOW) 
                    {
                        rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_LOW_LOAD);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Serving/Low Load  ABS pattern is not Applied on MAC");
                    }
                    else if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_OVERLOAD)
                    {	
                        rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_OVER_LOAD);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Serving/Over Load ABS pattern is not Applied on MAC");
                    }
                    else if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_HIGH)
                    {	
                        rrm_raise_error_event_notification( RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_HIGH_LOAD );
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Serving/High Load ABS pattern is not Applied on MAC");
                    }
                    else if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_MEDIUM)
                    {	
                        rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_MID_LOAD);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Serving/Mid Load ABS pattern is not Applied on MAC");
                    }

                }
                /*13987_fix_end*/

                /*review comments changes start*/
                if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT)
                {
                    p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CELLM_SERVING_ABS_PATTERN_PRESENT;
                    for(ncl_count = RRM_ZERO;
                            ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ;
                            ncl_count++)
                    {

                        if( (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                    abs_info_sent == RRM_SEND_ABS_PATTERN ) ||
                                ( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                  abs_info_sent == RRM_EICIC_ABS_PATTERN ))
                        {
                            if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                                        p_cell_ctx,LOAD_INFO_EICIC_ABS_INACTIVE,ncl_count))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Successfully shared ABS pattern with Neighbour[%d] because abs_pattern has been discarded by MAC",
                                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                    abs_info_sent = RRM_EICIC_ABS_INACTIVE;
				     
		             /*Bug 586 Changes Start*/
				rrm_hndl_rsu_stop_req_for_ncl(p_cell_ctx,
                                              &(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count]));
                  
		                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                                  "Successfully send RSU STOP to Neighbour[%d]",
                                                  p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
		             /*eICIC_Changes_Start*/
			     /*Bug 783 Changes Start */
                             p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Resetting  abs_usage_rep_status to  [%d] in case of ABS Inactive.",
				        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status);
                  	   /*Bug 783 Changes End */

                            if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                             {
                                   if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctx,ncl_count,
                                               p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO], RRM_FALSE))
                                   {
                                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                               "Successfuly sent RSR start req to Target Cell[%d] in case of ABS Inactive",
                                               p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                   }
                                   else
                                   {
                                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                               "Unable to send RSR start req to Target Cell[%d] in case of ABS Inactive",
                                               p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                       p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                                   }
                               }
			   /*eICIC_Changes_End*/
		             /*Bug 586 Changes End*/

                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Unable to share ABS inactive with Neighbour[%d]",
                                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                            }
                        }
                    }
                }
                /*review comments changes end*/
            }
            else
            {
                if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT )
                {
                    /*SPR 14811 start*/
                    rrm_raise_error_event_notification(RRM_EE_VICTM_ABS_APPLIED);
                    /*SPR 14811 end*/
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Common ABS pattern is accepted by the L2, so sending the SCHEDULE VICTIM IND to UEm");
                    
                    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied,
                            RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                    
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size, 
                            p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern, 
                            p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied);

                    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                            RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,
                            p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern,
                            p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
                    /*bug_13961_start*/
                    if(RRM_FALSE == rrm_check_abs_pattern_is_null( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern)) 
                        /*bug_13962_end*/
                    {
                        /* SPR 14347 start */
                        p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CELLM_USABLE_ABS_PATTERN_PRESENT;
                        /* SPR 14576 start */
                        build_and_send_uem_schedule_victim_ind(p_cell_ctx, RRM_VICTIM_SCHEDULE_WITH_ABS_CHANGE);
                        /* SPR 14576 end */
                        /* SPR 14347 end */
                    }
                    else
                    {
                        p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CELLM_USABLE_ABS_PATTERN_PRESENT;
                    }
                    /* bug_13898_start */  
                    /* bug_13935_start */
                    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                }
                /*bug_13962_start*/
                if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT)
                    /*bug_13962_end*/
                {
                    /*SPR 14811 start*/
                    if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_LOW) 
                    {
                        rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_APPLIED_FOR_LOW_LOAD);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Usable/Low load ABS pattern is applied to MAC");
                    }
                    else if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_OVERLOAD)
                    {	
                        rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_APPLIED_FOR_OVER_LOAD);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Usable/Over load ABS pattern is applied to MAC");
                    }
                    else if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_HIGH)
                    {	
                        rrm_raise_error_event_notification( RRM_EE_AGGR_ABS_APPLIED_FOR_HIGH_LOAD );
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Usable/High load ABS pattern is applied to MAC");
                    }
                    else if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_MEDIUM)
                    {	
                        rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_APPLIED_FOR_MID_LOAD);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Usable/Mid load ABS pattern is applied to MAC");
                    }
                    /*SPR 14811 end*/
                    RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied,
                            p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                            abs_size);
                    rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied);
                    /* bug_14010_start */
                    if( RRM_SUCCESS != rrm_cellm_get_highest_load_abs(p_cell_ctx, new_meas_abs_pattern))
                    {
                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                                p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                                abs_size);
                        rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
                    }
                    /* new_api_element_start */
                    else
                    {
                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                                   new_meas_abs_pattern,
                                abs_size);
                        rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
                    }
                    /* new_api_element_end */
                    /* bug_14010_end */
                    /*bug_13962_start*/ 
                    if(RRM_TRUE == rrm_check_abs_pattern_is_null( p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied))
                    {
                        /* SPR 14347 start */
                        p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CELLM_SERVING_ABS_PATTERN_PRESENT;
                        /* SPR 14347 end */
                        for(ncl_count = RRM_ZERO; 
                                ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ; 
                                ncl_count++)
                        {

                            if( (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                        abs_info_sent == RRM_SEND_ABS_PATTERN ) ||
                                    ( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                      abs_info_sent == RRM_EICIC_ABS_PATTERN ))
                            {
                                if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                                            p_cell_ctx,LOAD_INFO_EICIC_ABS_INACTIVE,ncl_count))
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                            "Successfully shared ABS pattern with Neighbour[%d]",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                        abs_info_sent = RRM_EICIC_ABS_INACTIVE;
		             /*Bug 586 Changes Start*/
				rrm_hndl_rsu_stop_req_for_ncl(p_cell_ctx,
                                              &(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count]));
                  
		                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                                  "Successfully send RSU STOP to Neighbour[%d]",
                                                  p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
		             /*eICIC_Changes_Start*/
			     /*Bug 783 Changes Start */
                             p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Resetting  abs_usage_rep_status to  [%d] in case of ABS Inactive.",
				        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status);
                  	   /*Bug 783 Changes End */

                            if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                             {
                                   if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctx,ncl_count,
                                               p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO], RRM_FALSE))
                                   {
                                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                               "Successfuly sent RSR start req to Target Cell[%d] in case of ABS Inactive",
                                               p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                   }
                                   else
                                   {
                                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                               "Unable to send RSR start req to Target Cell[%d] in case of ABS Inactive",
                                               p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                       p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                                   }
                             }
		           /*Bug 586 Changes End*/
			   /*eICIC_Changes_End*/
                                }
                                else
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                            "Unable to share ABS inactive with Neighbour[%d]",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                }
                            }
                        }
                    } 
                    else
                    {
                        /*bug_13962_end*/
                        p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CELLM_SERVING_ABS_PATTERN_PRESENT;

                        for(ncl_count = RRM_ZERO; 
                                ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ; 
                                ncl_count++)
                        {
                            if( (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                        abs_info_sent == RRM_SEND_ABS_PATTERN ) ||
                                    ( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                      abs_info_sent == RRM_EICIC_ABS_PATTERN ))
                            {
                                /* bug_13898_start */
                                if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                                            p_cell_ctx,LOAD_INFO_EICIC_ABS_PATTERN,ncl_count))
                                    /* bug_13898_end */
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                            "Successfully shared ABS pattern with Neighbour[%d]",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                        abs_info_sent = RRM_EICIC_ABS_PATTERN ;
                                    /* bug_14010_start */  
                                    if( ABS_USAGE_NONE == p_cell_ctx->ran_info.ncl_params.lte_ncl.
                                            intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status)

                                    {
                                        rrm_hndl_rsu_stop_req_for_ncl( p_cell_ctx,
                                                &(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                                                    intra_freq_cells[ncl_count]));

                                        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                                        {
                                            /* BUG 586 Fix Start */
                                            if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctx,ncl_count,
                                                        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO],RRM_TRUE))
                                            {
                                            /* BUG 586 Fix End */    
                                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                                        "Successfuly sent ABS reporting in RSR start req to Target Cell[%d]",
                                                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_START;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                                        "Unable to send ABS reporting in RSR start req to Target Cell[%d]",
                                                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                                            }
                                        }
                                    }
                                    else
                                    {

                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                                "RSU is already started for NCL_COUNT[%d] and PCI [%d]",
                                                ncl_count,p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                    }
                                    /* bug_14010_end */  
                                }
                                else
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                            "Unable to share ABS pattern with Neighbour[%d]",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                }
                            }
                        }
                    }
                    /* bug_13935_start */
                    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,
                            RRM_MAX_PATTERN_BYTE);
                    /* bug_13935_end */
                }
				for(ncl_count = RRM_ZERO; 
						ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ; 
						ncl_count++)
				{
					/*REVIEW_COMMENT: handle l2 cnf when load level changes and ABS is reconfigured */
					if( ( RRM_EICIC_TEMP_ABS == 
								p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
								rrm_intra_ncl_eicic_data.abs_pattern_status ) ||
							( RRM_EICIC_UPDATE_ABS == 
							  p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
							  rrm_intra_ncl_eicic_data.abs_pattern_status ))
					{ 

						p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
							rrm_intra_ncl_eicic_data.abs_pattern_status = RRM_EICIC_CNFRMD_ABS;
						RRM_MEMCPY( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
								rrm_intra_ncl_eicic_data.abs_pattern_recvd,
								p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
								rrm_intra_ncl_eicic_data.temp_abs_pattern, abs_size);
                        rrm_copy_tdd_bits(abs_size,p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                                                        rrm_intra_ncl_eicic_data.abs_pattern_recvd);
						RRM_MEMCPY( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
								rrm_intra_ncl_eicic_data.meas_pattern_recvd,
								p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
								rrm_intra_ncl_eicic_data.temp_meas_pattern, abs_size);
                        rrm_copy_tdd_bits(abs_size,p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                                                        rrm_intra_ncl_eicic_data.meas_pattern_recvd);
						/*SPR 20086 Fix Start*/
                        /*Code Removed*/
						/*SPR 20086 Fix Stop*/
					}
				}
			}
//			p_decision_info_stored->bitmask = 0x00;
			p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask &= ~RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
			p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask &= ~RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
			p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask &= ~RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;

		}
		/* eICIC_PHASE_1_2_CHANGES_END */

		/** eICIC_PHASE_1_2_CHANGES_START */
		if((p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT)||
				(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_REQUIRED_PER_RECONFIG_TO_MAC_PRESENT)||
				/**13894_fix_start*/
				(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_ABS_RECONFIG_LOW_LOAD_ABS_PRESENT)||
				(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_ABS_RECONFIG_VICTIM_ABS_PRESENT) || 
                /*eicic_subset_pattern_fix_start*/
                (p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT) 
                /*eicic_subset_pattern_fix_end*/
                /**13894_fix_end*/
		  )
		{

			p_mac_config_cnf = (RrmMacCellConfigCnf *)
				p_cell_ctx->p_incoming_api_info;
			RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
			if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						"RRM receive failure from mac for EICIC provision reconfig");
				ret_val= RRM_FAILURE;
				/*bug_13894_start*/
				generic_resp_to_mif.fail_cause = RRM_ERR_CELL_RECONFIG_ONGOING;
				/*bug_13894_end*/
                                /* rasie alarms and strt/restart timers */
			}
			else
			{
			    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"RRM receive success from mac for EICIC provision reconfig");
			    /*13987_fix_start*/
			    rrm_cellm_handle_eicic_timer_for_reconfig(p_cell_ctx);
                            /*13987_fix_end*/
			    rrm_commit_eicic_provision_reconfig_info(p_cell_ctx ,&p_cell_ctx->p_new_reconfig_data->operator_info.eicic_info);
			    ret_val= RRM_SUCCESS;
			}
			generic_resp_to_mif.cellindex = p_cell_ctx->cell_index; 
			generic_resp_to_mif.transaction_id = p_cell_ctx->ongoing_trans_id;
			generic_resp_to_mif.response = ret_val;
			ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif, 
					RRMCM_RMIF_CELL_RECONFIG_RESP);
			if (RRM_FAILURE == ret_val)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
						"Failed to Send Reconfig Generic Resp To MIF");
				/*bug_13894_start*/
				//code_deleted
				/*bug_13894_end*/

			}
			CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);

			/*reseting the reconfig bitmasks for eicic*/
			//coverity_fix_req
			if( RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
				/*BUG:9237 end*/
			{	
				RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
				p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
			}

			p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
			p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask = RRM_ZERO;
		}
		if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_SENDING_EICIC_LOAD_ABS_RECONFIG_TO_MAC_PRESENT)
		{
			if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_COMP_OVERLOAD_ABS_RECONFIG_PRESENT)
			{
				p_mac_config_cnf = (RrmMacCellConfigCnf *)
					p_cell_ctx->p_incoming_api_info;
				RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
				if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RRM receive failure from mac for EICIC load abs reconfig");
					/*failure from mac raising alarm and revert back the abs pattern*/
					/*13959_fix_start*/
					rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_OVER_LOAD);
					/*13959_fix_end*/
					RRM_MEMCPY(p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,
							p_cell_ctx->rrm_eicic_cell_info.temp_load_config_abs_pattern,
							abs_size);
                    rrm_copy_tdd_bits(abs_size,p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern);
					/* SPR 19838 : CID 10073 Fix Start */
					p_cell_ctx->rrm_eicic_cell_info.bitmask = (p_cell_ctx->rrm_eicic_cell_info.bitmask & 0x0000F);
					/* SPR 19838 : CID 10073 Fix End */
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RRM receive success from mac for EICIC load abs reconfig");
				}
				/*bug_13961_start*/
				p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CTXT_COMP_OVERLOAD_ABS_RECONFIG_PRESENT;
				/*bug_13961_end*/
			}    

			if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_COMP_HIGHLOAD_ABS_RECONFIG_PRESENT)
			{
				p_mac_config_cnf = (RrmMacCellConfigCnf *)
					p_cell_ctx->p_incoming_api_info;
				RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
				if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RRM receive failure from mac for EICIC load abs reconfig");
					/*failure from mac raising alarm and revert back the abs pattern*/
					/*13959_fix_start*/
					rrm_raise_error_event_notification( RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_HIGH_LOAD );
					/*13959_fix_end*/
					RRM_MEMCPY( p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,
							p_cell_ctx->rrm_eicic_cell_info.temp_load_config_abs_pattern,
							abs_size);
					rrm_copy_tdd_bits(abs_size,p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern);
					/* SPR 19838 : CID 10073 Fix Start */
					p_cell_ctx->rrm_eicic_cell_info.bitmask = (p_cell_ctx->rrm_eicic_cell_info.bitmask & 0x0000F);
					/* SPR 19838 : CID 10073 Fix End */
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RRM receive success from mac for EICIC load abs reconfig");
				}

				/*bug_13961_start*/
				p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CTXT_COMP_HIGHLOAD_ABS_RECONFIG_PRESENT;
				/*bug_13961_end*/


			}    

			if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_COMP_MIDLOAD_ABS_RECONFIG_PRESENT)
			{
				p_mac_config_cnf = (RrmMacCellConfigCnf *)
					p_cell_ctx->p_incoming_api_info;
				RRM_ASSERT(RRM_PNULL != p_mac_config_cnf);
				if (p_mac_config_cnf->responseCode != RRM_SUCCESS)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RRM receive failure from mac for EICIC load abs reconfig");
					/*failure from mac raising alarm and revert back the abs pattern*/
					/*13959_fix_start*/
					rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_MID_LOAD);
					/*13959_fix_end*/
					RRM_MEMCPY( p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,
							p_cell_ctx->rrm_eicic_cell_info.temp_load_config_abs_pattern,
							abs_size);
                     rrm_copy_tdd_bits(abs_size,p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern); 
					/* SPR 19838 : CID 10073 Fix Start */
					p_cell_ctx->rrm_eicic_cell_info.bitmask = (p_cell_ctx->rrm_eicic_cell_info.bitmask & 0x0000F);
					/* SPR 19838 : CID 10073 Fix End */
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RRM receive success from mac for EICIC load abs reconfig");
				}
				/*bug_13961_start*/
				p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CTXT_COMP_MIDLOAD_ABS_RECONFIG_PRESENT;
				/*bug_13961_end*/
			}    
			/*bug_13961_start*/
			p_cell_ctx->rrm_eicic_cell_info.bitmask &= ~RRM_CTXT_SENDING_EICIC_LOAD_ABS_RECONFIG_TO_MAC_PRESENT;
			/*bug_13961_end*/
		} 
	} 
	/** eICIC_PHASE_1_2_CHANGES_END */ 

	/* This check will make sure that if this is the last response
	 * then only set the state to active else wait because a response is
	 * still pending from L2.
	 */
	/*13870_fix_start*/
	if (RRM_ZERO == p_decision_info_stored->bitmask && p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask == RRM_ZERO)
        /*13870_fix_end*/
	{
		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_ACTIVE);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"Cell State:%s[%d]",CELL_FSM_STATE[p_cell_ctx->cell_state],
				p_cell_ctx->cell_state);
	}
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}



/*****************************************************************************
 * Array Name     : rmcm_x2ap_load_info_ind_event 
 * Inputs         : Pointer to Cell Context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function will process the load  
 *		            info exchanged with eNBs on X2.
 ****************************************************************************/
rrm_return_et 
rmcm_x2ap_load_info_ind_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    x2ap_rrm_load_information_ind_t        *p_x2ap_rrm_load_ind = RRM_PNULL;  
    U8                                     cell_count = RRM_ZERO;
    U32                                     prbs_configured_in_neigh_cell = RRM_ZERO;
    U32                                     prbs_configured_in_srv_cell = RRM_ZERO;
    U32                                     prbs_configured_counter = RRM_ZERO;
    U32                                     prb_counter = RRM_ZERO;
    U8                                      rntp_per_prb[RRM_MAX_PRBS_COUNT] = {RRM_ZERO};
    U8                                      hii_per_prb[RRM_MAX_PRBS_COUNT] = {RRM_ZERO};
    U8                                      ul_hii_serving_cell_count = RRM_ZERO;
    U8                                      oi_per_prb[RRM_MAX_PRBS_COUNT] = {RRM_ZERO};
    U32                                     oi_temp_val_per_prb = RRM_ZERO;
    U32                                     temp_prb = RRM_ZERO;
    U32                                     init_prb = RRM_ONE;
    U32                                     counter = RRM_ONE;
    rrm_bool_et                            oi_reported_status = RRM_FALSE;
    rrm_bool_et                            hii_reported_status = RRM_FALSE;
    rrm_bool_et                            rntp_reported_status = RRM_FALSE;
    rrm_return_et                          ret_val = RRM_SUCCESS;
    /* eICIC_PHASE_1_2_CHANGES_START */
    /* bug_13898_start */  
    U8                                     target_ncl_count = RRM_INVALID_TARGET_NCL;
    /* bug_13898_end */  
    rrm_oam_eutran_global_cell_id_t        target_cell_id ;
    cell_timer_buf_t timer_buf;
    rrm_bool_et                            first_invoke_recieved = RRM_FALSE;
    /* eICIC_PHASE_1_2_CHANGES_END */

    RRM_UT_TRACE_ENTER();

    p_x2ap_rrm_load_ind = (x2ap_rrm_load_information_ind_t *)
                              p_cell_ctx->p_incoming_api_info;
    RRM_ASSERT(RRM_PNULL != p_x2ap_rrm_load_ind);

    switch(p_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            prbs_configured_in_srv_cell = PRB_COUNT_6;
            break;
        case RRM_OAM_BW_N_15:
            prbs_configured_in_srv_cell = PRB_COUNT_15;
            break;
        case RRM_OAM_BW_N_25:
            prbs_configured_in_srv_cell = PRB_COUNT_25;
            break;
        case RRM_OAM_BW_N_50:
            prbs_configured_in_srv_cell = PRB_COUNT_50;
            break;
        case RRM_OAM_BW_N_75:
            prbs_configured_in_srv_cell = PRB_COUNT_75;
            break;
        case RRM_OAM_BW_N_100:
            prbs_configured_in_srv_cell = PRB_COUNT_100;
            break;
        default :
            prbs_configured_in_srv_cell = PRB_COUNT_50;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                      "Incorrect value received for dl_bandwith = %u",
                      p_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth);
    }
    
    if ((p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT) &&
        (p_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT) &&
        (ICIC_SCHEME_SFR == p_cell_ctx->operator_info.dynamic_icic_info.icic_scheme_type))
    {
        for (cell_count = RRM_ZERO; (cell_count < p_x2ap_rrm_load_ind->cell_information_count)
            /* Coverity 21oct Start : 55007 */
            && (cell_count < MAX_SERVED_CELLS); cell_count++)
            /* Coverity 21oct End : 55007 */
        {
            /* Take the union of PRB Bitmap received from RNTP reports of multiple cells from eNB2 */
            if (p_x2ap_rrm_load_ind->cell_load_info[cell_count].bitmask & 
                         X2AP_LI_CELL_INFO_ITEM_RELATIVE_NARROWBAND_TX_POWER_PRESENT)
            {
                rntp_reported_status = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                      "RNTP PRBs Configured for reported cell count [%d] = %d",
                      cell_count+RRM_ONE, p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                      relative_narrowband_tx_power.prb_count);
                /* This check is done in order to make sure if the peer cell
                   is configured on low bandwidth then appropriate number of RBs 
                   shall be considered else only those RBs shall be taken into 
                   account which are configured for the serving cell.
                 */
                
                prbs_configured_in_neigh_cell = p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                                                 relative_narrowband_tx_power.prb_count;

                prbs_configured_counter = (prbs_configured_in_neigh_cell/ RRM_EIGHT) + 
                                          (((prbs_configured_in_neigh_cell % RRM_EIGHT) == RRM_ZERO) ?
                                          RRM_ZERO : RRM_ONE);
                for (prb_counter = RRM_ZERO; prb_counter < prbs_configured_counter; prb_counter++)
                {
                   /* All the RNTP Map received has been logical ORed to make 
                      the combined RNTP map reported from peers on X2. 
                      This Map shall be validated with CE region allocated for
                      the serving eNodeB. The bitmap received from L3 is Bit string
                      so, converting it to OCTET string.
                    */
                   temp_prb = 
                          p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                                               relative_narrowband_tx_power.
                                               rntp_per_prb[prb_counter];
                   for (counter = RRM_ZERO; counter < RRM_EIGHT; counter++)
                   {
                       init_prb = init_prb << counter;
                       rntp_per_prb[(prb_counter * RRM_EIGHT) + counter] |= ((init_prb & temp_prb) ? RRM_ONE : RRM_ZERO);
                       init_prb = RRM_ONE;
                   }
                   init_prb = RRM_ONE;
                }
            }

            /* Take the union of PRB Bitmat received from HII reports of multiple cells from eNB2 */
            if (p_x2ap_rrm_load_ind->cell_load_info[cell_count].bitmask & 
                         X2AP_LI_CELL_INFO_ITEM_UL_INTF_INFO_PRESENT)
            {
                /* Coverity_fix_start_55007 */
                for (ul_hii_serving_cell_count = RRM_ZERO; ((ul_hii_serving_cell_count < 
                        p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                        ul_high_interference_info.ul_high_interference_info_count) && 
                        (ul_hii_serving_cell_count < MAX_SERVED_CELLS));
                                               ul_hii_serving_cell_count++)
                /*CID 55007:Coverity_Fix_End*/
                {
                    /* Compare Global cell Id reproted on X2 from eNB2 with all the serving
                       cells for the serving eNodeB. It is possible that HII reported shall 
                       not be targetted for all the serving cells under same eNodeB.
                    */
                    ret_val = compare_x2_reported_global_cell_id_with_serving(
                                      &p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                                       ul_high_interference_info.
                                       ul_high_intf_info[ul_hii_serving_cell_count].
                                       target_cell_id,
                                      &p_cell_ctx->global_cell_id);
                    if (RRM_SUCCESS == ret_val)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                                "Cell Id matched with the Id reported in HII by peer");
                        break;
                    }
                }
                /* Coverity_fix_end_55007 */
                if (RRM_SUCCESS == ret_val)
                {
                    hii_reported_status = RRM_TRUE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                            "PRBs Configured for reported cell count [%d] = %d",
                            cell_count+1, p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                            ul_high_interference_info.ul_high_intf_info[ul_hii_serving_cell_count].
                            ul_high_intf_ind.prb_count);
                        
                        prbs_configured_in_neigh_cell = p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                            ul_high_interference_info.
                            ul_high_intf_info[ul_hii_serving_cell_count].ul_high_intf_ind.
                            prb_count;
                    
                    prbs_configured_counter = (prbs_configured_in_neigh_cell / RRM_EIGHT) + 
                                              (((prbs_configured_in_neigh_cell % RRM_EIGHT) == RRM_ZERO) ?
                                              RRM_ZERO : RRM_ONE);
                    for (prb_counter = RRM_ZERO; prb_counter < prbs_configured_counter; prb_counter++)
                    {
                        temp_prb = 
                            p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                            ul_high_interference_info.ul_high_intf_info[ul_hii_serving_cell_count].
                            ul_high_intf_ind.hii[prb_counter];
                        for (counter = RRM_ZERO; counter < RRM_EIGHT; counter++)
                        {
                            init_prb = init_prb << counter;
                            hii_per_prb[(prb_counter * RRM_EIGHT) + counter] |= ((init_prb & temp_prb) ? RRM_ONE : RRM_ZERO);
                            init_prb = RRM_ONE;
                        }
                        init_prb = RRM_ONE;
                    }
                }
            }
            /* Take the union of PRB Bitmap received from OI reports of multiple cells from eNB2 */
            if (p_x2ap_rrm_load_ind->cell_load_info[cell_count].bitmask & 
                         X2AP_LI_CELL_INFO_ITEM_UL_INTF_OVERLOAD_IND_PRESENT)
            {
                oi_reported_status = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                      "OI PRBs Configured for reported cell count [%d] = %d",
                      cell_count+RRM_ONE, p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                      ul_intf_overload_ind.count);
                
                prbs_configured_in_neigh_cell = p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                                                 ul_intf_overload_ind.count;
                
                for (prb_counter = RRM_ZERO;
                        (prb_counter < prbs_configured_in_neigh_cell) && (prb_counter < X2AP_LI_MAX_PRBS_COUNT);
                        prb_counter++)
                {
                   /* Map the high=0, medium=1 and low=2 received from peer
                      as high & medium = 1 and low = 0 to store it locally nd for further actions
                   */
                   if ((p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                          ul_intf_overload_ind.
                          ul_intf_overload_indication[prb_counter] == RRM_OI_HIGH_INTERFERENCE) || 
                       (p_x2ap_rrm_load_ind->cell_load_info[cell_count].
                          ul_intf_overload_ind.
                          ul_intf_overload_indication[prb_counter] ==  RRM_OI_MEDIUM_INTERFERENCE))
                   {
                       oi_temp_val_per_prb = RRM_ONE;
                   }
                   else
                   {
                       oi_temp_val_per_prb = RRM_ZERO;
                   }

                   oi_per_prb[prb_counter] |= oi_temp_val_per_prb;
                }
            }
        }

        /*
        ** In case Neighbouring Cell is at Higher BW than Serving Cell ,
        ** map the interferece status of only those PRBs of the neighbouring cell 
        ** that map around the centre frequency.
        */
        if(prbs_configured_in_neigh_cell > prbs_configured_in_srv_cell)
        {
            if(rntp_reported_status)
            {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Map RNTP PRBs from neighbour around the centre frequency");
                map_reported_prbs_arnd_centre_freq(rntp_per_prb,
                                                   prbs_configured_in_srv_cell,
                                                   prbs_configured_in_neigh_cell);                                                                  
            }
            if(oi_reported_status)
            {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Map OI PRBs from neighbour around the centre frequency");
                map_reported_prbs_arnd_centre_freq(oi_per_prb ,                                                                 
                                                   prbs_configured_in_srv_cell,
                                                   prbs_configured_in_neigh_cell);                                                                  
            }
            if(hii_reported_status)
            {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "Map HII PRBs from neighbour around the centre frequency");
                map_reported_prbs_arnd_centre_freq(hii_per_prb ,                                                                 
                                                   prbs_configured_in_srv_cell,
                                                   prbs_configured_in_neigh_cell);                                                                  
            }
        }
        
        /* Below written function shall call the logic to take decision
           for the serving cell. This function will take into account 
           the HII, OI and RNTP reports and perform the actions to
           mitigate the interference.
         */
         perform_icic_on_serving_cell_in_ul_and_dl(p_cell_ctx,   prbs_configured_in_srv_cell,
                                                   hii_per_prb,  hii_reported_status,
                                                   oi_reported_status,
                                                   /*SPR 17777 +-*/
                                                   rntp_per_prb, rntp_reported_status);
    }
    
    /* eICIC_PHASE_1_2_CHANGES_START */
    if( ( p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_EICIC_INFO_PRESENT ) 
         &&
        ( RRM_OAM_EICIC_DEACTIVATED != 
                 p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type )
      )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Process X2AP indication for eICIC related processing");

        /*
         ** Check whether it is First invoke Request or not.If its a first request
         ** then fisr apply teh ABS at L2 and then inform the victims
         */
        /* bug_13898_start */  
        //first_invoke_recieved = rrm_cellm_first_invoke_recieved(p_cell_ctx);
        /* bug_13898_end */  

        for (cell_count = RRM_ZERO; (cell_count < p_x2ap_rrm_load_ind->cell_information_count)
                && (cell_count < MAX_SERVED_CELLS); cell_count++)
        {
            rrm_convert_x2ap_cell_id_to_ncl_cell( p_x2ap_rrm_load_ind->cell_load_info[cell_count].source_cell_id,
                    &target_cell_id);
            rrm_cellm_get_target_cell_from_ncl(p_cell_ctx,&target_ncl_count,target_cell_id);


        /* bug_13898_start */  
           if( RRM_INVALID_TARGET_NCL != target_ncl_count)
	   {
		   if( p_x2ap_rrm_load_ind->cell_load_info[cell_count].bitmask &
				   X2AP_LI_INVOKE_INDICATION_PRESENT && ( RRM_TRUE == rrm_cellm_is_aggressor_node(p_cell_ctx)))
        /* bug_13898_end */  
		   {
			   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					   "Process X2AP INVOKE indication" );
			   /*
			    ** Check whether it is First invoke Request or not.If its a first request
			    ** then fisr apply teh ABS at L2 and then inform the victims
			    */
			   /* bug_13898_start */  
			   first_invoke_recieved = rrm_cellm_first_invoke_recieved(p_cell_ctx);
			   /* bug_13898_end */  

			   /*
			    ** Check whether it is First invoke Request or not.If its a first request
			    ** then fisr apply teh ABS at L2 and then inform the victims
			    */
			   if(RRM_TRUE == first_invoke_recieved)
			   {
			        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					   "Received first invoke from victim" );
				   /* Send mac config request */
				   p_cell_ctx->ran_info.ncl_params.lte_ncl.
					   intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent = RRM_SEND_ABS_PATTERN;
				   /* bug_13898_start */ 
				   continue;
			   }
			   else if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
						   p_cell_ctx,LOAD_INFO_EICIC_ABS_PATTERN,target_ncl_count))
				   /* bug_13898_send */ 
               {
                   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                           "Successfully shared ABS pattern with Neighbour[%d]",
                           p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].phy_cell_id);
                   /* bug_14010_start */  
                   if( ABS_USAGE_NONE == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].resrc_report.abs_status.                   abs_usage_rep_status)

                   {
                       rrm_hndl_rsu_stop_req_for_ncl( p_cell_ctx,
                               &(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                                   intra_freq_cells[target_ncl_count]));
                       if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                       {
                           /* BUG 586 Fix Start */
                           if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctx,target_ncl_count,
                                       p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO],RRM_TRUE))
                           {
                           /* BUG 586 Fix End */
                               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                       "Successfuly sent ABS reporting in RSR start req to Target Cell[%d]",
                                       p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].phy_cell_id);
                               //    ret_val = RRM_SUCCESS;
                               p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_START;
                           }
                           else
                           {
                               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                       "Unable to send ABS reporting in RSR start req to Target Cell[%d]",
                                       p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].phy_cell_id);
                               //  ret_val = RRM_FAILURE;
                               p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                               //  ret_val = RRM_FAILURE;
                           }
                       }
                   } 
                   else
                   {
                       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                               "RSU is already started for NCL_COUNT[%d] and PCI [%d]",
                               target_ncl_count,p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].phy_cell_id);

                   }
               }
			   else
			   {
				   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						   "Unable to share ABS pattern with Neighbour[%d]",
						   p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].phy_cell_id);
			   }
		   }
                   /* bug_13898_start */  
		   else if( p_x2ap_rrm_load_ind->cell_load_info[cell_count].bitmask &
				   X2AP_LI_ABS_INFORMATION_PRESENT && ( RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctx))) 
                   /* bug_13898_end */  
		   {
			   if ( ( RRM_ZERO != p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer) &&
					   (RRM_TRUE == qvTimerRunning(p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer)))
			   {
				   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						   "Process X2AP ABS INFORMATION indication from Aggressor");
				   if( RRM_ZERO == (p_x2ap_rrm_load_ind->cell_load_info[cell_count].abs_infomation.bitmask & 
							   X2AP_LI_ABS_INFORMATION_ABS_INACTIVE_PRESENT))
				   {

					   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							   "ABS information FDD/TDD is present in X2AP load ind");

					   rrm_cellm_process_abs_info_frm_aggressor( p_cell_ctx,
							   &(p_x2ap_rrm_load_ind->cell_load_info[cell_count].abs_infomation),
							   target_ncl_count,
							   RRM_EICIC_TEMP_ABS ); 

					   if( (RRM_ZERO != p_cell_ctx->rrm_eicic_cell_info.num_x2ap_invoke_ind_sent) &&
							   ( p_cell_ctx->rrm_eicic_cell_info.num_x2ap_abs_ind_recived == 
							     p_cell_ctx->rrm_eicic_cell_info.num_x2ap_invoke_ind_sent))
					   {
						   /*
						    ** RRM has recived response for all the Sent INVOKE indications.
						    ** So stop the gaurd timer and start combining the recived 
						    ** ABS patterns.
						    */
						   if ((RRM_ZERO != p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer) &&
								   (qvTimerRunning(p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer)))
						   {
							   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
									   "Stopping Load information gaurd Timer ");
							   cell_stop_timer(p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer);
							   p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer = RRM_PNULL;
						   }
						   p_cell_ctx->rrm_eicic_cell_info.num_x2ap_abs_ind_recived = RRM_ZERO;
						   p_cell_ctx->rrm_eicic_cell_info.num_x2ap_invoke_ind_sent = RRM_ZERO;
						   rrm_cellm_find_and_apply_common_abs_pattern(p_cell_ctx);
					   }
				   }
				   else
				   {
					   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							   "ABS_INACTIVE is recieved from neighbour Neither TDD nor FDD ABS information is present in X2AP load ind");
                        /*SPR 15485 start*/
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
                                        rrm_intra_ncl_eicic_data.abs_pattern_status = RRM_EICIC_INACTIVE_ABS;
                        /*SPR 15485 end*/
                        /*SPR 16203 start */
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].\
                            rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_RECVD_PRESENT; 
                        /*SPR 16203 end */
				   }
			   }
			   else
			   {
				   /* Since Load information GUARD timer is not running and still
				    ** ABS information is recived on X2AP from an Aggressor Node, So This is 
				    ** an update from one of the earlier aggressors.Store the details from this aggressor
				    ** and start the Load information Collation timer.
				    */
				   rrm_cellm_process_abs_info_frm_aggressor( p_cell_ctx,
						   &(p_x2ap_rrm_load_ind->cell_load_info[cell_count].abs_infomation),
						   target_ncl_count,RRM_EICIC_UPDATE_ABS); 

				   /*
				    ** Start the Colloation timer to Gaurd the Updates from the aggressor Nodes 
				    ** on X2AP
				    */
				   if( ( p_cell_ctx->operator_info.eicic_info.bitmask & RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT) &&
						   ( p_cell_ctx->operator_info.eicic_info.eicic_timer_info.bitmask &
						     RRMCM_RMIF_LOAD_INFORMATION_COLLATION_TIMER))
				   { 
					   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							   "Starting Load Information Collation timer with [%d] value",
							   p_cell_ctx->operator_info.eicic_info.eicic_timer_info.load_information_collation_timer);
					   p_cell_ctx->timer_val[CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER] = p_cell_ctx->operator_info.eicic_info.
						   eicic_timer_info.load_information_collation_timer; 
					   timer_buf.cell_index = p_cell_ctx->cell_index;
					   timer_buf.timer_type = CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER;
					   p_cell_ctx->rrm_eicic_cell_info.cell_collation_timer=
						   cell_start_timer ( CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER, (rrm_void_t *)&timer_buf,
								   sizeof (cell_timer_buf_t), p_cell_ctx);
				   }
				   else
				   {
					   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							   "Unable to start Load Information Collation timer as Timer "
							   "info is not provided by operator");
				   }
			   }
		   }
           /* bug_13898_start */  
	   }
           else
	   {
		   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "No need to Process X2AP Load indication for cell idx [%u] as Cell Id [%u]]%u][%u][%u]"
                             "is not present in Neighbour List",p_cell_ctx->cell_index,
                             target_cell_id.cell_identity[RRM_ZERO],target_cell_id.cell_identity[RRM_ONE],
                             target_cell_id.cell_identity[RRM_TWO],target_cell_id.cell_identity[RRM_THREE] );
	   }
           /* bug_13898_end */  
        }
        if(RRM_TRUE == first_invoke_recieved)
        {
            /* Send current load levels ABS to L2 in mac config request */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "This is the 1st time invoke is recieved, get the ABS pattern "
                    "as per the cureent load and configure the same at L2");
            /* bug_14010_start */ 
            RRM_MEMSET(p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);

            /*SPR 17875 START*/
            ret_val = rrm_cellm_get_current_load_abs_pattern(p_cell_ctx, p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern); 
            //if( RRM_FAILURE != rrm_cellm_get_current_load_abs_pattern(p_cell_ctx, p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern))
            if((ret_val != RRM_FAILURE)&&(RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern)))
            /*SPR 17875 END*/
            {
            /* _bug_14010_end */  
                /* Send this common ABS pattern to L2 */
                /* bug_13935_start */  
                if( RRM_FALSE == rrm_compare_configured_abs_pattern_vd_new_abs(p_cell_ctx) )
                {
                    /* bug_13935_end */  
                    ret_val = build_and_send_l2_cell_config_req( RRM_PNULL,
                            RRM_PNULL,
                            p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                            RRM_PNULL,
                            p_cell_ctx->cell_index,
                            p_cell_ctx->ongoing_trans_id);

                    if (RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                "Failure returned during the processing of l2_cell_config_req");
                    }
                    else
                    {
                        /* bug_13898_start */  
                        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
                        /* bug_13898_end */  
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                                "Success returned during the processing of l2_cell_config_req");
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                            RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |=
                            RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                    }
                    /* bug_13935_start */  
                }
                /* bug_13935_end */  
            /* bug_14010_start */  
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                          " Send ABS inactive to all the required neighbours ");
                for(cell_count = RRM_ZERO; cell_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ; cell_count++)
                {
                    if( RRM_SEND_ABS_PATTERN == (p_cell_ctx->ran_info.ncl_params.lte_ncl.
					         intra_freq_cells[cell_count].rrm_intra_ncl_eicic_data.abs_info_sent))
                    {
                         if (EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                                                             p_cell_ctx,LOAD_INFO_EICIC_ABS_INACTIVE,
                                                              cell_count))
                         {
                             RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                     " SUCCESS to Send ABS inactive to PCI [%d] ", 
                                      p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);

                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].rrm_intra_ncl_eicic_data.
                                abs_info_sent = RRM_EICIC_ABS_INACTIVE;
                            /*Bug 586 Changes Start*/
                            rrm_hndl_rsu_stop_req_for_ncl(p_cell_ctx,
                                    &(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count]));

                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Successfully send RSU STOP to Neighbour[%d]",
                                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                            /*eICIC_Changes_Start*/
                            /*Bug 783 Changes Start */
                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Resetting  abs_usage_rep_status to  [%d] in case of ABS Inactive.",
                                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].resrc_report.abs_status.abs_usage_rep_status);
                            /*Bug 783 Changes End */

                            if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                            {
                                if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctx,cell_count,
                                            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO], RRM_FALSE))
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "Successfuly sent RSR start req to Target Cell[%d] in case of ABS Inactive",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                                }
                                else
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "Unable to send RSR start req to Target Cell[%d] in case of ABS Inactive",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                                }
                            }
                            /*Bug 586 Changes End*/
                            /*eICIC_Changes_End*/
                         }
                         else
                         {
                             RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                                     " FAILED to Send ABS inactive to PCI [%d] ",
                                     p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[cell_count].phy_cell_id);
                         }
                    }
                }
            }
            /* bug_14010_end */  
        }
    }
    /* eICIC_PHASE_1_2_CHANGES_END */
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
 /*Klockwork_fix_start*/
/*****************************************************************************
 * Array Name     : rrmcm_rrm_dynamic_icic_l1_l2_overload
 * Inputs         : Pointer to Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : This function will start the timer for dynamic icic
 *                  info exchanged with eNBs on X2.
 ****************************************************************************/
rrm_void_t
rrmcm_rrm_dynamic_icic_l1_l2_overload(rrm_cell_context_t              *p_cell_ctx ,
                                      rrmuem_cm_update_ue_info_req_t  *cellm_uem_ue_info_req)
{
    RRM_UT_TRACE_ENTER();

    U32                    ue_reconfiguration_percentage = RRM_ZERO;
    rrm_bool_et                             change_ue_categorization = RRM_FALSE;
    rrm_return_et                           ret_val = RRM_FAILURE;

    if (p_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT)
    {
        ue_reconfiguration_percentage = action_on_oi_reports_from_serving_cell(p_cell_ctx, 
                &change_ue_categorization);
        if ((RRM_TRUE == change_ue_categorization) &&
                (RRM_ZERO != ue_reconfiguration_percentage))
        {
            /* In this case RRM will update UEM to change the location of CE UEs to
               CC UEs. In case the UEM reports SUCCESS then RRM will go ahead with the
               reconfiguration of partition level else no action shall be taken.
             */
            cellm_uem_ue_info_req->bitmask = 0x00;
            cellm_uem_ue_info_req->transaction_id = p_cell_ctx->ongoing_trans_id;
            cellm_uem_ue_info_req->cell_index = p_cell_ctx->cell_index;
            cellm_uem_ue_info_req->bitmask |= RRMUEM_CM_UE_LOCATION_UPDATE_ACTION_PRESENT;
            cellm_uem_ue_info_req->ue_location_update_action = UE_LOCATION_UPDATE_CC_TO_CE;
            cellm_uem_ue_info_req->location_update_percentage = ue_reconfiguration_percentage;

            ret_val = build_and_send_uem_update_ue_info(p_cell_ctx, cellm_uem_ue_info_req);
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
                        "Failure returned during the processing of uem_update_ue_info");
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                        "Success returned during the processing of uem_update_ue_info");
                /* Update Cell Context */
                p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.bitmask |= 
                    RRM_CTXT_UEM_UPDATE_INFO_PRESENT;
                RRM_MEMCPY(&p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.cellm_uem_ue_info_req,
                        cellm_uem_ue_info_req,
                        sizeof(rrmuem_cm_update_ue_info_req_t));
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/
/*****************************************************************************
 * Array Name     : rrmcm_rrm_dynamic_icic_l1_l2_report_info_event 
 * Inputs         : Pointer to Cell Context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function will start the timer for dynamic icic 
 *		            info exchanged with eNBs on X2.
 ****************************************************************************/
rrm_return_et 
rrmcm_rrm_dynamic_icic_l1_l2_report_info_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
	rrm_partitioning_info_action_type_et    action_taken_on_partitioning_in_ul = RRM_UL_PARTITION_NO_CHANGE;
	rrm_partitioning_info_action_type_et    action_taken_on_partitioning_in_dl = RRM_DL_PARTITION_NO_CHANGE;
	rrm_return_et                           ret_val = RRM_FAILURE;
	S32                                      hii_prb_count = RRM_ZERO;
	U32                                      rntp_prb_count = RRM_ZERO;
	U32                                      new_dl_start_rb = RRM_ZERO;
	rrm_resource_partition_info_t           *p_ul_resource_partition_info_new = RRM_PNULL;
	rrm_resource_partition_info_t           *p_dl_resource_partition_info_new = RRM_PNULL;
	rrmuem_cm_update_ue_info_req_t          cellm_uem_ue_info_req = {RRM_ZERO};
	U32                                      prb_configured_in_srv_cell = RRM_ZERO;
	/* SPR 21843 Fix Start */
	U8                                      prb_count = RRM_ZERO;
	/* SPR 21843 Fix End */

	switch(p_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
	{
		case RRM_OAM_BW_N_6:
			prb_configured_in_srv_cell = PRB_COUNT_6;
			break;
		case RRM_OAM_BW_N_15:
			prb_configured_in_srv_cell = PRB_COUNT_15;
			break;
		case RRM_OAM_BW_N_25:
			prb_configured_in_srv_cell = PRB_COUNT_25;
			break;
		case RRM_OAM_BW_N_50:
			prb_configured_in_srv_cell = PRB_COUNT_50;
			break;
		case RRM_OAM_BW_N_75:
			prb_configured_in_srv_cell = PRB_COUNT_75;
			break;
		case RRM_OAM_BW_N_100:
			prb_configured_in_srv_cell = PRB_COUNT_100;
			break;
		default :
			prb_configured_in_srv_cell = PRB_COUNT_50;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
					"Incorrect value received for dl_bandwith = %u",
					p_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth);
	}
	/* This block shall check for the presence of L1 and L2 reports configured 
	   by operator. As the L1 reports leads to OI indicator and
	   L2 reports leads to RNTP + HII indicator so a synchronization is required
	   for the X2AP signalling. During Cell Config request to L2, configured reports 
	   bitmask has been set which is validated with the reports received from L2.
	   X2AP message is sent only when the individually and independently configured
	   reports will be received from L2 and the proper decision is done on that.
	   */

	if (p_cell_ctx->icic_l1_l2_report_info.bitmask & 
			RRM_CTXT_L1_L2_CONFIGURED_REPORT_BITMASK_PRESENT)
	{
		if (p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 == 
				(p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 & 
				 p_cell_ctx->icic_l1_l2_report_info.bitmask))
		{
			/* This block shall evaluate the OI, HII and RNTP reports one by one.
			   The evaluation of these reports shall leads to different actions.

			   OI Reports from serving :- This can result in repartitioning of certain UEs.
			   HII Reports from serving:- This can result in repartitioning of UL partition
			   RNTP Reports from serving:- This can result in repartitioning of DL partition

			   The actions can further be processes after sending the Load Ind on X2AP.
			   */

			/* This block will check for any action related to OI reports */

			/*Klockwork_fix_start*/
			rrmcm_rrm_dynamic_icic_l1_l2_overload(p_cell_ctx ,&cellm_uem_ue_info_req);
			/*Klockwork_fix_end*/

			/* This block will check for any action related to RNTP reports */
			if (p_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT)
			{
				rntp_prb_count = action_on_rntp_reports_from_serving_cell(p_cell_ctx,
						&action_taken_on_partitioning_in_dl,
						&new_dl_start_rb);
				if ((RRM_ZERO != rntp_prb_count) &&
						(RRM_DL_PARTITION_NO_CHANGE != action_taken_on_partitioning_in_dl))
				{
					p_dl_resource_partition_info_new = rrm_mem_get(sizeof(rrm_resource_partition_info_t));
					if (p_dl_resource_partition_info_new == RRM_PNULL)
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
								"Memory allocation to p_dl_resource_partition_info_new failed" );
						RRM_UT_TRACE_EXIT();
						return RRM_FAILURE;
					}
					p_dl_resource_partition_info_new->bitmask = 0x00;

					/* CE Region Partitioning Info */
					p_dl_resource_partition_info_new->bitmask  |=
						RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
					p_dl_resource_partition_info_new->num_of_cell_edge_region = RRM_ONE;

					/* 
					   The start RB for CE Region is kept same, so this value is picked from
					   Cell Context configured originally by operator
					   */
					p_dl_resource_partition_info_new->cell_edge_region.start_rb = new_dl_start_rb;

					/* 
					   The number of RBs allocated for new partitioning info is calculated by 
					   the RNTP reports
					   */
					p_dl_resource_partition_info_new->cell_edge_region.num_of_rb =  (U8)rntp_prb_count;

					/* 
					   This function will reconfigure the cell center
					   region as per new cell edge region  parameters
					   */
					reconfigure_cell_center_region(p_dl_resource_partition_info_new,
							prb_configured_in_srv_cell);
				}
			}

			/* This block will check for any action related to HII reports */
			if (p_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_HIGH_INTF_IND_PRESENT)
			{
				/* 
				   This function will predict the number of CE PRBs
				   based on estimation of CE PRB usage reported from L2
				   */
				/* SPR 22310 CID 115524 Fix Start */
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"p_cell_ctx->cell_resource_info.num_active_ue:[%d]",
						p_cell_ctx->cell_resource_info.num_active_ue);
				/* SPR 20867 Fix Start */
				if((RRM_ZERO != p_cell_ctx->cell_resource_info.num_active_ue) &&
						(RRM_TRUE == p_cell_ctx->icic_l1_l2_report_info.is_sample_valid_for_partioning))
				{
					hii_prb_count = predict_hii_map_based_on_ul_ce_prb_usage(p_cell_ctx,
							&action_taken_on_partitioning_in_ul);
				}
				/* SPR 22310 CID 115524 Fix End */
				/* SPR 20867 Fix End */
				if ((RRM_ZERO != hii_prb_count) &&
						(RRM_UL_PARTITION_NO_CHANGE != action_taken_on_partitioning_in_ul))
				{
					p_ul_resource_partition_info_new = rrm_mem_get(sizeof(rrm_resource_partition_info_t));
					if (p_ul_resource_partition_info_new == RRM_PNULL)
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
								"Memory allocation to p_ul_resource_partition_info_new failed" );
						RRM_UT_TRACE_EXIT();
						RRM_MEM_FREE(p_dl_resource_partition_info_new);
						return RRM_FAILURE;
					}

					p_ul_resource_partition_info_new->bitmask = RRM_ZERO;

					/* CE Region Partitioning Info */
					p_ul_resource_partition_info_new->bitmask  |=
						RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
					p_ul_resource_partition_info_new->num_of_cell_edge_region = RRM_ONE;

					/* 
					   The start RB for CE Region is kept same, so this value is picked from
					   Cell Context configured originally by operator
					   */
					p_ul_resource_partition_info_new->cell_edge_region.start_rb = 
						p_cell_ctx->operator_info.dynamic_icic_info.
						ul_resource_partition_info.cell_edge_region.start_rb;

					/* 
					   The number of RBs allocated for new partitioning info is calculated by 
					   the prediction algo
					   */
					p_ul_resource_partition_info_new->cell_edge_region.num_of_rb =  (U8)hii_prb_count;
					/* SPR 21843 Fix Start */
					for (prb_count = p_ul_resource_partition_info_new->cell_edge_region.start_rb; prb_count < (p_ul_resource_partition_info_new->cell_edge_region.start_rb + hii_prb_count); prb_count++)
					{
						p_cell_ctx->icic_l1_l2_report_info.ul_high_interference_info.hii[prb_count] = RRM_ONE;
					}
					p_cell_ctx->icic_l1_l2_report_info.ul_high_interference_info.prb_count = prb_count;
					/* SPR 21843 Fix End */

					/* 
					   This function will reconfigure the cell center
					   region as per new cell edge region  parameters
					   */
					reconfigure_cell_center_region(p_ul_resource_partition_info_new,
							prb_configured_in_srv_cell);
				}
			}
			if ((RRM_PNULL != p_ul_resource_partition_info_new) ||
					(RRM_PNULL != p_dl_resource_partition_info_new))
			{
				/* Send Cell Config Request L2 */
				ret_val =  build_and_send_l2_cell_config_req(
						(rrm_resource_partition_info_t *) p_dl_resource_partition_info_new,
						(rrm_resource_partition_info_t *) p_ul_resource_partition_info_new,
						RRM_PNULL,RRM_PNULL,
						p_cell_ctx->cell_index,  p_cell_ctx->ongoing_trans_id);
				if (RRM_FAILURE == ret_val)
				{
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
							"Failure returned during the processing of l2_cell_config_req");
					/* COVERITY : RESOURCE LEAK : CID : 54333,54334 fix start*/         
					if (RRM_PNULL != p_ul_resource_partition_info_new)
						RRM_MEM_FREE(p_ul_resource_partition_info_new);
					if (RRM_PNULL != p_dl_resource_partition_info_new)
						RRM_MEM_FREE(p_dl_resource_partition_info_new);
					/* COVERITY : RESOURCE LEAK : CID : 54333,54334 fix end*/    

				}
				else
				{
					RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
							"Success returned during the processing of l2_cell_config_req");
					if (RRM_PNULL != p_ul_resource_partition_info_new)
					{
						/* This means action for reconfiguration of partition info
						   shall be taken. 
						   */
						p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.bitmask
							|= RRM_CTXT_UL_PARTIONING_INFO_PRESENT;
						RRM_MEMCPY(&p_cell_ctx->icic_l1_l2_report_info.
								decision_info_stored.ul_resource_partition_info_new,
								p_ul_resource_partition_info_new,
								sizeof(rrm_resource_partition_info_t));
						/* SPR: 15922 Fix start */
						/*Code removed*/
						/* SPR: 15922 Fix end */
					}
					if (RRM_PNULL != p_dl_resource_partition_info_new)
					{
						/* This means action for reconfiguration of partition info
						   shall be taken. 
						   */
						p_cell_ctx->icic_l1_l2_report_info.decision_info_stored.bitmask
							|= RRM_CTXT_DL_PARTIONING_INFO_PRESENT;
						RRM_MEMCPY(&p_cell_ctx->icic_l1_l2_report_info.
								decision_info_stored.dl_resource_partition_info_new,
								p_dl_resource_partition_info_new,
								sizeof(rrm_resource_partition_info_t));
						/* SPR: 15922 Fix start */
						/*Code removed*/
						/* SPR: 15922 Fix end */
					}
				}
				/* SPR: 15922 Fix start */
				if(p_ul_resource_partition_info_new != RRM_PNULL)
				{
					RRM_MEM_FREE(p_ul_resource_partition_info_new);
				}
				if(p_dl_resource_partition_info_new != RRM_PNULL)
				{
					RRM_MEM_FREE(p_dl_resource_partition_info_new);
				}
				/* SPR: 15922 Fix end */
			}
			build_and_send_x2ap_icic_load_information(p_cell_ctx);
			if ((RRM_CTXT_UL_PARTIONING_INFO_PRESENT & p_cell_ctx->icic_l1_l2_report_info.
						decision_info_stored.bitmask) ||
					(RRM_CTXT_DL_PARTIONING_INFO_PRESENT & p_cell_ctx->icic_l1_l2_report_info.
					 decision_info_stored.bitmask) ||
					(RRM_CTXT_UEM_UPDATE_INFO_PRESENT    & p_cell_ctx->icic_l1_l2_report_info.
					 decision_info_stored.bitmask)
			   )
			{
				CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
			}
		}
		/* SPR 21843 Fix Start */
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
					"Bitmask value received from OAM is [%d] and calculated bitmask value is [%d]", 
					p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2,
					(p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 & p_cell_ctx->icic_l1_l2_report_info.bitmask));

		}
		/* SPR 21843 Fix End */
	}

	return RRM_SUCCESS;
}

/*Klockwork_fix_2431_start*/
/*****************************************************************************
 * Array Name     : rmcm_rrm_process_icic_l1_l2_report
 * Inputs         : Pointer to Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : This function will initially start the timer for dynamic icic
 *                  info exchanged with eNBs on X2.
 ****************************************************************************/
rrm_void_t 
rmcm_rrm_process_icic_l1_l2_report(rrm_cell_context_t *p_cell_ctx)
{
    RRM_UT_TRACE_ENTER();
    p_cell_ctx->icic_l1_l2_report_info.bitmask |= 
        RRM_CTXT_L1_L2_CONFIGURED_REPORT_BITMASK_PRESENT;

    p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 = RRM_ZERO;
    if ((p_cell_ctx->operator_info.dynamic_icic_info.report_config_info.bitmask & 
                RRM_L2_l1_MEAS_REPORT_CONFIG_INFO) &&
            (RRM_TRUE == p_cell_ctx->operator_info.dynamic_icic_info.
             report_config_info.l1_meas_report_config_info.layer1_meas_report_required))
    {
        /* This will show that OI reports must be delivered on X2AP */
        p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 |=
            RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT;
    }
    if ((p_cell_ctx->operator_info.dynamic_icic_info.report_config_info.bitmask & 
                RRM_L2_l2_MEAS_REPORT_CONFIG_INFO) &&
            (RRM_TRUE == p_cell_ctx->operator_info.dynamic_icic_info.
             report_config_info.l2_meas_report_config_info.cell_edge_prb_usage_required))
    {
        /* This will show that HII reports must be delivered on X2AP */
        p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 |=
            RRM_CTXT_HIGH_INTF_IND_PRESENT;
    }
    if ((p_cell_ctx->operator_info.dynamic_icic_info.bitmask & 
                RRMCM_RMIF_RNTP_REPORT_CONFIG_INFO_PRESENT) &&
            (RRM_TRUE == p_cell_ctx->operator_info.dynamic_icic_info.
             rntp_report_config_info.rntp_report_on_X2_required))
    {
        /* This will show that RNTP reports must be delivered on X2AP */
        p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2 |=
            RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT;
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
            "Bitmsk stored for X2AP reporting[%d],OI[0x01], HII[0x02], RNTP[0x04]",
            p_cell_ctx->icic_l1_l2_report_info.bitmask_for_l1_l2_reports_from_l2);
    RRM_UT_TRACE_EXIT();
}

/*****************************************************************************
 * Array Name     : rrm_fill_deletion_cell_config_resp
 * Inputs         : Pointer to Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : This function will initially start the timer for dynamic icic
 *                  info exchanged with eNBs on X2.
 ****************************************************************************/
rrm_return_et
rrm_fill_deletion_cell_config_resp( rrm_cell_context_t *p_cell_ctx)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    cell_son_attr_info_list_t    *p_cell_anr_info = RRM_PNULL;
    cell_son_attr_info_list_t    *p_cell_es_info = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    if (RRM_FALSE == p_cell_ctx->immediate_cell_start)
    {
        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_W_FOR_CELL_START);
        /*BUG:102 start*/
        p_cell_ctx->cell_stop_not_send_active_ue_count=RRM_TRUE; 
        /*BUG:102 end*/

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell State is :%s Cell Start Needed",
                CELL_FSM_STATE[p_cell_ctx->cell_state]);
        ret_val =  RRM_SUCCESS;
    }
    else
    {
        /*State transition*/
        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_BRIEF,"Config Succes Cell State Is:%s For Cell Index:%d",
                CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
        CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                "Cell State is :%s, Cell Start Not Needed",
                CELL_FSM_STATE[p_cell_ctx->cell_state]);
    }

    /*Fill and store load config*/
    p_cell_ctx->cell_load_action.choice = RRM_ONE; /*comp_load_info*/ 	
    p_cell_ctx->cell_load_action.high_actn_applied_lmt  = p_cell_ctx->operator_info.load_congestion_cfg.high_actn_applied_lmt;
    p_cell_ctx->cell_load_action.ld_process_timer  = p_cell_ctx->operator_info.load_congestion_cfg.ld_process_timer;
    /* As these are read from rrm.cfg these values are always present*/
    p_cell_ctx->cell_load_action.u.comp_load_info.bitmask |= RRM_CELLM_OVERLOAD_PRESENT ;
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.bitmask = p_cell_ctx->operator_info.load_congestion_cfg.overload.bitmask;
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.percent = p_cell_ctx->operator_info.load_congestion_cfg.overload.load_perctg;   
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.action = p_cell_ctx->operator_info.load_congestion_cfg.overload.action;
    /* Bug_8718_start */
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.soft_lmt  = p_cell_ctx->operator_info.load_congestion_cfg.soft_lmt;
    /* Bug_8718_end */
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.q_watermark.high_watermark = 
        p_cell_ctx->operator_info.load_congestion_cfg.overload.q_watermark.high_watermark;
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.q_watermark.low_watermark = 
        p_cell_ctx->operator_info.load_congestion_cfg.overload.q_watermark.low_watermark;
    p_cell_ctx->cell_load_action.u.comp_load_info.over_load.num_of_usr = p_cell_ctx->operator_info.load_congestion_cfg.overload.num_usr;

    /*Filling high load */
    p_cell_ctx->cell_load_action.u.comp_load_info.bitmask |=RRM_CELLM_HIGHLOAD_PRESENT;
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.bitmask = p_cell_ctx->operator_info.load_congestion_cfg.highload.bitmask;
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.percent = p_cell_ctx->operator_info.load_congestion_cfg.highload.load_perctg;   
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.action = p_cell_ctx->operator_info.load_congestion_cfg.highload.action;
    /* Bug_8718_start */
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.soft_lmt  = p_cell_ctx->operator_info.load_congestion_cfg.soft_lmt;
    /* Bug_8718_end */
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.q_watermark.high_watermark = 
        p_cell_ctx->operator_info.load_congestion_cfg.highload.q_watermark.high_watermark;
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.q_watermark.low_watermark = 
        p_cell_ctx->operator_info.load_congestion_cfg.highload.q_watermark.low_watermark;
    p_cell_ctx->cell_load_action.u.comp_load_info.high_load.num_of_usr = p_cell_ctx->operator_info.load_congestion_cfg.highload.num_usr;

    /*Filling medium load*/
    p_cell_ctx->cell_load_action.u.comp_load_info.bitmask |=RRM_CELLM_MIDLOAD_PRESENT;
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.bitmask = p_cell_ctx->operator_info.load_congestion_cfg.midload.bitmask;
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.percent = p_cell_ctx->operator_info.load_congestion_cfg.midload.load_perctg;   
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.action = p_cell_ctx->operator_info.load_congestion_cfg.midload.action;
    /* Bug_8718_start */
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.soft_lmt  = p_cell_ctx->operator_info.load_congestion_cfg.soft_lmt;
    /* Bug_8718_end */
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.q_watermark.high_watermark = 
        p_cell_ctx->operator_info.load_congestion_cfg.midload.q_watermark.high_watermark;
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.q_watermark.low_watermark = 
        p_cell_ctx->operator_info.load_congestion_cfg.midload.q_watermark.low_watermark;
    p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.num_of_usr = p_cell_ctx->operator_info.load_congestion_cfg.midload.num_usr;


    p_cell_ctx->cell_load_action.u.comp_load_info.actn_status = RRM_ZERO; 
    p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl = RRM_LOW;
    p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val =RRM_ZERO;

    /* MLB Ph2 Start */
    /* Starting Cell Load processing timer */
    rrm_cellm_start_ld_process_timer (p_cell_ctx);
    /* MLB Ph2 End */

    /*End of filling of load val*/
    /* allocate memory to store parameters from SON */
    if (RRM_PNULL == p_cell_ctx->p_son_info)
    {
        p_cell_ctx->p_son_info = rrm_mem_get(sizeof(cell_son_info_t));
        if (p_cell_ctx->p_son_info == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_ctx->p_son_info failed" );
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        } 
        /* MLB Changes start */
        p_cell_ctx->p_son_info->p_mlb_info = RRM_PNULL;
        /* MLB Changes end */
        /* MRO Changes start */
        p_cell_ctx->p_son_info->p_mro_info = RRM_PNULL;
        /* MRO Changes end */

        /* MRO Changes start */
        p_cell_ctx->p_son_info->p_mro_info = RRM_PNULL;
        /* MRO Changes end */

        p_cell_ctx->p_son_info->p_anr_info = rrm_mem_get
            (sizeof(cell_son_attr_info_list_t));
        if (p_cell_ctx->p_son_info->p_anr_info == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_ctx->p_son_info->p_anr_info failed" );
            RRM_UT_TRACE_EXIT();
            RRM_MEM_FREE(p_cell_ctx->p_son_info);
            return RRM_FAILURE;
        }
        RRM_MEMSET(p_cell_ctx->p_son_info->p_anr_info, RRM_ZERO, sizeof(cell_son_attr_info_list_t));

        p_cell_anr_info = p_cell_ctx->p_son_info->p_anr_info;
        p_cell_anr_info->is_active = RRM_FALSE;

        /* Memory allocation for  ANR Data Structures Starts */
        p_cell_anr_info->p_cell_state = rrm_mem_get(sizeof(cell_state_t));
        if (p_cell_anr_info->p_cell_state == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_anr_info->p_cell_state failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);
            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }
        /*Initialising  to FALSE */
        p_cell_anr_info->p_cell_state->flag_periodic_cell_state = RRM_FALSE;
        p_cell_anr_info->p_cell_state->flag_threshold_cell_state= RRM_FALSE;
        p_cell_anr_info->p_cell_state->flag_trgr_cell_state=  RRM_FALSE;

        p_cell_anr_info->p_active_ue = rrm_mem_get(sizeof(cell_active_ue_t));
        if (p_cell_anr_info->p_active_ue == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_anr_info->p_active_ue failed" );
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_anr_info->p_active_ue->flag_periodic_active_ue= RRM_FALSE; 
        p_cell_anr_info->p_active_ue->flag_threshold_active_ue= RRM_FALSE;
        p_cell_anr_info->p_active_ue->flag_trgr_active_ue = RRM_FALSE;

        p_cell_anr_info->p_ue_threshold = rrm_mem_get(
                sizeof(cell_active_ue_threshold_t));
        if (p_cell_anr_info->p_ue_threshold == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_anr_info->p_ue_threshold failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_anr_info->p_ue_threshold->flag_periodic_ue_threshold= RRM_FALSE;
        p_cell_anr_info->p_ue_threshold->flag_threshold_ue_threshold= RRM_FALSE;
        p_cell_anr_info->p_ue_threshold->flag_trgr_ue_threshold= RRM_FALSE;

        p_cell_anr_info->p_s1_msg_notification = rrm_mem_get
            (sizeof(cell_s1_msg_notification_t));

        if (p_cell_anr_info->p_s1_msg_notification == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_anr_info->p_s1_msg_notification failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_anr_info->p_s1_msg_notification->
            flag_periodic_s1_msg_notification= RRM_FALSE;
        p_cell_anr_info->p_s1_msg_notification->
            flag_trgr_s1_msg_notification= RRM_FALSE;
        p_cell_anr_info->p_s1_msg_notification->
            flag_threshold_s1_msg_notification= RRM_FALSE;

        /* UE MEAS CHANGES : STARTS */
        p_cell_anr_info->p_ue_meas_result_notification = 
            rrm_mem_get(sizeof(cell_ue_meas_result_notification_t));

        if (p_cell_anr_info->p_ue_meas_result_notification == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_anr_info->p_ue_meas_result_notification failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_anr_info->p_s1_msg_notification);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_anr_info->timer_status[SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = STOPPED;
        p_cell_anr_info->timer_status[SON_UE_MEAS_CONFIG_TIMER] = STOPPED;
        p_cell_anr_info->p_ue_meas_result_notification->
            flag_periodic_ue_meas_notification = RRM_FALSE;
        p_cell_anr_info->p_ue_meas_result_notification->
            flag_trgr_ue_meas_notification = RRM_FALSE;
        p_cell_anr_info->p_ue_meas_result_notification->
            flag_threshold_ue_meas_notification= RRM_FALSE;
        /* UE MEAS CHANGES : ENDS */

        /* Memory allocation for ANR Data Structures Ends */
        p_cell_ctx->p_son_info->p_es_info = rrm_mem_get
            (sizeof(cell_son_attr_info_list_t));
        if (p_cell_ctx->p_son_info->p_es_info == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_ctx->p_son_info->p_es_info failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_anr_info->p_s1_msg_notification);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_meas_result_notification);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        RRM_MEMSET(p_cell_ctx->p_son_info->p_es_info, RRM_ZERO, sizeof(cell_son_attr_info_list_t));

        p_cell_es_info = p_cell_ctx->p_son_info->p_es_info;
        p_cell_es_info->is_active = RRM_FALSE;

        /* Memory allocation for  ES Data Structures Starts */
        p_cell_es_info->p_cell_state = rrm_mem_get(sizeof(cell_state_t));
        if (p_cell_es_info->p_cell_state == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_es_info->p_cell_state failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_anr_info->p_s1_msg_notification);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_meas_result_notification);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);
            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_es_info->p_cell_state->flag_periodic_cell_state = RRM_FALSE;
        p_cell_es_info->p_cell_state->flag_threshold_cell_state= RRM_FALSE;
        p_cell_es_info->p_cell_state->flag_trgr_cell_state=  RRM_FALSE;

        p_cell_es_info->p_active_ue = rrm_mem_get(sizeof(cell_active_ue_t));
        if (p_cell_es_info->p_active_ue == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_es_info->p_active_ue failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_anr_info->p_s1_msg_notification);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_meas_result_notification);
            RRM_MEM_FREE(p_cell_es_info->p_cell_state);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_es_info->p_active_ue->flag_periodic_active_ue= RRM_FALSE; 
        p_cell_es_info->p_active_ue->flag_threshold_active_ue= RRM_FALSE;
        p_cell_es_info->p_active_ue->flag_trgr_active_ue = RRM_FALSE;

        p_cell_es_info->p_ue_threshold = rrm_mem_get
            (sizeof(cell_active_ue_threshold_t));
        if (p_cell_es_info->p_ue_threshold == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_es_info->p_ue_threshold failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_anr_info->p_s1_msg_notification);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_meas_result_notification);
            RRM_MEM_FREE(p_cell_es_info->p_cell_state);
            RRM_MEM_FREE(p_cell_es_info->p_active_ue);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        /* SPR 16504 Fix start */
        RRM_MEMSET(p_cell_es_info->p_ue_threshold, RRM_ZERO, sizeof(cell_active_ue_threshold_t));
        /* SPR 16504 Fix stop */
        p_cell_es_info->p_ue_threshold->flag_periodic_ue_threshold= RRM_FALSE;
        p_cell_es_info->p_ue_threshold->flag_threshold_ue_threshold= RRM_FALSE;
        p_cell_es_info->p_ue_threshold->flag_trgr_ue_threshold= RRM_FALSE;

        p_cell_es_info->p_s1_msg_notification = rrm_mem_get
            (sizeof(cell_s1_msg_notification_t));
        if (p_cell_es_info->p_s1_msg_notification == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_es_info->p_s1_msg_notification failed" );
            RRM_UT_TRACE_EXIT();
            /*Coverity fix 57888 start*/
            RRM_MEM_FREE(p_cell_anr_info->p_cell_state);
            RRM_MEM_FREE(p_cell_anr_info->p_active_ue);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_anr_info->p_s1_msg_notification);
            RRM_MEM_FREE(p_cell_anr_info->p_ue_meas_result_notification);
            RRM_MEM_FREE(p_cell_es_info->p_cell_state);
            RRM_MEM_FREE(p_cell_es_info->p_active_ue);
            RRM_MEM_FREE(p_cell_es_info->p_ue_threshold);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_es_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info->p_anr_info);
            RRM_MEM_FREE(p_cell_ctx->p_son_info);

            /*Coverity fix 57888 end*/
            /*SPR 15994 Fix start*/
            p_cell_anr_info = RRM_PNULL;
            /*SPR 15994 Fix stop*/
            return RRM_FAILURE;
        }

        /*Initialising  to FALSE */
        p_cell_es_info->p_s1_msg_notification->
            flag_periodic_s1_msg_notification= RRM_FALSE;

        p_cell_es_info->p_s1_msg_notification->
            flag_trgr_s1_msg_notification= RRM_FALSE;

        p_cell_es_info->p_s1_msg_notification->
            flag_threshold_s1_msg_notification= RRM_FALSE;

        /* Memory allocation for ES Data Structures Ends */

    }
    RRM_UT_TRACE_EXIT();
    /*COV_FIX_START_65048*/
    return ret_val; 
    /*COV_FIX_END_65048*/
}
/*Klockwork_fix_2431_end*/
/* SPR 10450 Fix Start */
U16 
rrm_map_long_drx_cycle
(
  rrm_oam_long_drx_cycle_start_offset_et     long_drx_cycle
)
{
	U16   ret_val = RRM_OAM_SF2560;
	switch(long_drx_cycle)
	{
		case RRM_OAM_SF10:
			ret_val = 10;
			break;

		case RRM_OAM_SF20:
			ret_val = 20;
			break;
		case RRM_OAM_SF32:
			ret_val = 32;
			break;
		case RRM_OAM_SF40:
			ret_val = 40;
			break;
		case RRM_OAM_SF64:
			ret_val = 64;
			break;
		case RRM_OAM_SF80:
			ret_val = 80;
			break;
		case RRM_OAM_SF128:
			ret_val = 128;
			break;
		case RRM_OAM_SF160:
			ret_val = 160;
			break;
		case RRM_OAM_SF256:
			ret_val = 256;
			break;
		case RRM_OAM_SF320:
			ret_val = 320;
			break;
		case RRM_OAM_SF512:
			ret_val = 512;
			break;
		case RRM_OAM_SF640:
			ret_val = 640;
			break;
		case RRM_OAM_SF1024:
			ret_val = 1024;
			break;
		case RRM_OAM_SF1280:
			ret_val = 1280;
			break;
		case RRM_OAM_SF2048:
			ret_val = 2048;
			break;
		case RRM_OAM_SF2560:
			ret_val = 2560;
			break;
        /* SPR 21411 changes start */
		case RRM_OAM_INVALID:
			ret_val = 65535;
			break;
        /* SPR 21411 changes end */
	}
	return ret_val;
}

#ifdef ENDC_ENABLED
U16 
rrm_map_long_drx_cycle_r15
(
    rrm_oam_long_drx_cycle_start_offset_r15_et     long_drx_cycle
)
{
	U16   ret_val = RRM_OAM_R15_SF10240;

	switch ( long_drx_cycle )
	{
		case RRM_OAM_R15_SF10:
			ret_val = 10;
			break;

		case RRM_OAM_R15_SF20:
			ret_val = 20;
			break;
		case RRM_OAM_R15_SF32:
			ret_val = 32;
			break;
		case RRM_OAM_R15_SF40:
			ret_val = 40;
			break;
		case RRM_OAM_R15_SF64:
			ret_val = 64;
			break;
		case RRM_OAM_R15_SF80:
			ret_val = 80;
			break;
		case RRM_OAM_R15_SF128:
			ret_val = 128;
			break;
		case RRM_OAM_R15_SF160:
			ret_val = 160;
			break;
		case RRM_OAM_R15_SF256:
			ret_val = 256;
			break;
		case RRM_OAM_R15_SF320:
			ret_val = 320;
			break;
		case RRM_OAM_R15_SF512:
			ret_val = 512;
			break;
		case RRM_OAM_R15_SF640:
			ret_val = 640;
			break;
		case RRM_OAM_R15_SF1024:
			ret_val = 1024;
			break;
		case RRM_OAM_R15_SF1280:
			ret_val = 1280;
			break;
		case RRM_OAM_R15_SF2048:
			ret_val = 2048;
			break;
		case RRM_OAM_R15_SF2560:
			ret_val = 2560;
			break;
		case RRM_OAM_R15_SF5120:
			ret_val = 5120;
			break;
		case RRM_OAM_R15_SF10240:
			ret_val = 10240;
			break;
		case RRM_OAM_R15_INVALID:
			ret_val = 65535;
			break;
	}

	return ret_val;
}
#endif

U16 
rrm_map_short_drx_cycle
(
  rrm_oam_short_drx_cycle_et   short_drx_cycle
) 
{

	U16 ret_val = RRM_OAM_SHORT_DRX_CYCLE_SF_640;
	switch (short_drx_cycle)
	{
		case  RRM_OAM_SHORT_DRX_CYCLE_SF_2:
			ret_val = 2;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_5:
			ret_val = 5;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_8:
			ret_val = 8;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_10:
			ret_val = 10;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_16:
			ret_val = 16;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_20:
			ret_val = 20;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_32:
			ret_val = 32;
			break;
		case RRM_OAM_SHORT_DRX_CYCLE_SF_40:
			ret_val = 40;
			break;
		case  RRM_OAM_SHORT_DRX_CYCLE_SF_64:
			ret_val = 64;
			break;
		case   RRM_OAM_SHORT_DRX_CYCLE_SF_80:
			ret_val = 80;
			break;
		case  RRM_OAM_SHORT_DRX_CYCLE_SF_128:
			ret_val = 128;
			break;
		case  RRM_OAM_SHORT_DRX_CYCLE_SF_160:
			ret_val = 160;
			break;
		case   RRM_OAM_SHORT_DRX_CYCLE_SF_256:
			ret_val = 256;
			break;
		case  RRM_OAM_SHORT_DRX_CYCLE_SF_320:
			ret_val = 320;
			break;
		case  RRM_OAM_SHORT_DRX_CYCLE_SF_512:
			ret_val = 512;
			break;
        case RRM_OAM_SHORT_DRX_CYCLE_SF_640:
            ret_val = 640;
        /* SPR 21411 changes start */
            break;
        case RRM_OAM_SHORT_DRX_CYCLE_INVALID:
            ret_val = 65535;
            break;
        /* SPR 21411 changes end */
	}
	return ret_val;
}

U16   
rrm_get_on_duration_timer_in_sf
(
    rrm_oam_on_duration_timer_et  *p_on_duration
)
{
	U16 ret_val = RRM_OAM_ON_DURATION_TIMER_PSF_1;

	switch(*p_on_duration)
	{
		case RRM_OAM_ON_DURATION_TIMER_PSF_1:
			ret_val = 1;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_2:
			ret_val = 2;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_3:
			ret_val = 3;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_4:
			ret_val = 4;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_5:
			ret_val = 5;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_6:
			ret_val = 6;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_8:
			ret_val = 8;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_10:
			ret_val = 10;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_20:
			ret_val = 20;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_30:
			ret_val = 30;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_40:
			ret_val = 40;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_50:
			ret_val = 50;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_60:
			ret_val = 60;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_80:
			ret_val = 80;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_100:
			ret_val = 100;
			break;

		case RRM_OAM_ON_DURATION_TIMER_PSF_200:
			ret_val = 200;
			break;
        /* SPR 21411 changes start */
		case RRM_OAM_ON_DURATION_TIMER_INVALID:
			ret_val = 65535;
			break;
        /* SPR 21411 changes end */
        /* Bug 21402 Fix starts */
        default:
            ret_val = 200;
            break;
        /* Bug 21402 Fix ends */
	}
    return ret_val;
}

rrm_bool_et 
rrm_is_drx_offset_already_occupied
(
  drx_res_alloc_tree_per_ue_t  *p_drx_offset_local_array,
  U16 temp_drx_offset,
  U16 ue_counter
)
{
	rrm_bool_et ret_val = RRM_FALSE;
	U16         count   = RRM_ZERO;

	for(count = RRM_ZERO ; count < ue_counter ; count++)
	{
		if(p_drx_offset_local_array[count].drx_start_offset == temp_drx_offset)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "New recieved DRX offset :- [%d] is already present at position [%d] ",
                    temp_drx_offset,count);
            ret_val =  RRM_TRUE;
            break;
        }
	}
	return ret_val;
}

rrm_void_t 
rrm_allocate_drx_offset_for_multiple_ues
(
   U16                            cnfg_drx_offset,
   U8                             configured_num_of_ue,
   drx_res_alloc_tree_per_ue_t   *p_drx_res,
#ifndef LTE_EMBMS_SUPPORTED  
//   rrm_oam_on_duration_timer_et  *p_on_duration,
   rrm_oam_long_drx_cycle_start_offset_et long_drx_cycle
#else
   rrm_oam_long_drx_cycle_start_offset_et long_drx_cycle,
   U8                                     embms_sf_reserved_list
#endif  
)
{

   U16          mapped_on_duration_in_sf = RRM_OAM_ON_DURATION_TIMER_PSF_200; 
   U16          sf_start_value_for_on_duration = RRM_ZERO;
   U16          sf_end_value_for_on_duration = RRM_ZERO;
   S16          total_sf_available = RRM_ZERO;
   U16          counter = RRM_ZERO;
   U16          ue_counter = RRM_ZERO;
   U16          temp_drx_offset = RRM_ZERO;
   rrm_bool_et  is_occupied = RRM_FALSE;
   rrm_bool_et  valid_drx_offfset = RRM_FALSE;
   U16          num_unique_on_duration_per_drx_cycle = RRM_ZERO;
   
   drx_res_alloc_tree_per_ue_t     
                     *p_drx_offset_local_array = RRM_PNULL;


   total_sf_available = rrm_map_long_drx_cycle(long_drx_cycle);
#ifndef LTE_EMBMS_SUPPORTED
   //   mapped_on_duration_in_sf = rrm_get_on_duration_timer_in_sf(p_on_duration);
   mapped_on_duration_in_sf = RRM_ONE;
#endif

   sf_end_value_for_on_duration = total_sf_available - RRM_ONE;
   num_unique_on_duration_per_drx_cycle =  total_sf_available / mapped_on_duration_in_sf;

   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
             "DRX Offset Range[%d to %d], a total of [%d] SF, Unique ON Duration per DRX cycle [%d]",
              sf_start_value_for_on_duration, sf_end_value_for_on_duration, total_sf_available,
              num_unique_on_duration_per_drx_cycle);

   p_drx_offset_local_array = (drx_res_alloc_tree_per_ue_t*)
                                rrm_mem_get(num_unique_on_duration_per_drx_cycle * sizeof(drx_res_alloc_tree_per_ue_t));
   /*Cov_fix_start_65130*/
   if (RRM_PNULL == p_drx_offset_local_array)
   {
       RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
          "Unable to allocate memeory to p_drx_offset_local_array");
       RRM_UT_TRACE_EXIT();
       return ;
   }
   /*Cov_fix_end_65130*/
   /* Initialize the local data structure */
   for (counter = RRM_ZERO; counter < num_unique_on_duration_per_drx_cycle ; counter++)
   {
      p_drx_offset_local_array[counter].drx_start_offset = 0xFFFF;
      p_drx_offset_local_array[counter].res_status = RRM_RES_BUSY;
   }
   
   while ((is_occupied == RRM_FALSE) && (ue_counter < num_unique_on_duration_per_drx_cycle))
   {
       valid_drx_offfset = RRM_FALSE;
	   if( RRM_ZERO == ue_counter )
	   {
		   temp_drx_offset = cnfg_drx_offset ;
                   valid_drx_offfset = RRM_TRUE;
	   }
	   else
	   {
		   temp_drx_offset = temp_drx_offset + mapped_on_duration_in_sf;
		   if(temp_drx_offset > sf_end_value_for_on_duration)
           {
               RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                         "End Range Crossed to [%d]. So restarting from ZERO again",
                          temp_drx_offset);
               
               temp_drx_offset = temp_drx_offset % total_sf_available;
               if( RRM_TRUE == rrm_is_drx_offset_already_occupied(p_drx_offset_local_array,temp_drx_offset,ue_counter) )
               {
                   is_occupied = RRM_TRUE;
               }
               else
               {
                   valid_drx_offfset = RRM_TRUE;
               }
           }
		   else
		   {
			   if( RRM_TRUE == rrm_is_drx_offset_already_occupied(p_drx_offset_local_array,temp_drx_offset,ue_counter) )
			   {
				   is_occupied = RRM_TRUE;
			   }
#ifdef LTE_EMBMS_SUPPORTED
               else if ( (RRM_ZERO != embms_sf_reserved_list) && 
                         (RRM_TRUE == rrm_check_configured_mtch_sf( embms_sf_reserved_list,temp_drx_offset)) )
               {
                   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                             "This DRX offset is not valid as due to collision with MBMS SF ");
               }
#endif
			   else
			   {
				   valid_drx_offfset = RRM_TRUE;
			   }
		   }
	   }

       if( RRM_TRUE == valid_drx_offfset)
       {
           /* SPR 21251 +- */ 
           p_drx_offset_local_array[ue_counter].res_status = RRM_RES_FREE;
           p_drx_offset_local_array[ue_counter].drx_start_offset = temp_drx_offset;
           ue_counter++;
       }
   }

   /*
   ** Populate these valid DRX offsets in the drx_res_tree repeatedly to be used
   ** for the UEs sequentially for a particular QCI
   */
   //*p_drx_res = (drx_res_alloc_tree_per_ue_t*)rrm_mem_get(configured_num_of_ue * 
     //                                                       sizeof(drx_res_alloc_tree_per_ue_t));
   ue_counter = RRM_ZERO;
   counter    = RRM_ZERO;
   while(counter < configured_num_of_ue)
   {
       if(ue_counter == num_unique_on_duration_per_drx_cycle)
       {
           ue_counter = RRM_ZERO;
       }
       RRM_MEMCPY(&(p_drx_res[counter]),&(p_drx_offset_local_array[ue_counter]),sizeof(drx_res_alloc_tree_per_ue_t));
       ue_counter++;
       counter++;
   }
   RRM_MEM_FREE(p_drx_offset_local_array);
   RRM_UT_TRACE_EXIT();

}

#ifdef ENDC_ENABLED
rrm_void_t 
rrm_allocate_drx_offset_for_multiple_ues_r15
(
   U16                            cnfg_drx_offset,
   U8                             configured_num_of_ue,
   drx_res_alloc_tree_per_ue_t   *p_drx_res,
#ifndef LTE_EMBMS_SUPPORTED  
//   rrm_oam_on_duration_timer_et  *p_on_duration,
   rrm_oam_long_drx_cycle_start_offset_r15_et long_drx_cycle
#else
   rrm_oam_long_drx_cycle_start_offset_r15_et long_drx_cycle,
   U8                                     embms_sf_reserved_list
#endif  
)
{

   U16          mapped_on_duration_in_sf = RRM_OAM_ON_DURATION_TIMER_PSF_200; 
   U16          sf_start_value_for_on_duration = RRM_ZERO;
   U16          sf_end_value_for_on_duration = RRM_ZERO;
   S16          total_sf_available = RRM_ZERO;
   U16          counter = RRM_ZERO;
   U16          ue_counter = RRM_ZERO;
   U16          temp_drx_offset = RRM_ZERO;
   rrm_bool_et  is_occupied = RRM_FALSE;
   rrm_bool_et  valid_drx_offfset = RRM_FALSE;
   U16          num_unique_on_duration_per_drx_cycle = RRM_ZERO;
   
   drx_res_alloc_tree_per_ue_t     
                     *p_drx_offset_local_array = RRM_PNULL;


   total_sf_available = rrm_map_long_drx_cycle_r15(long_drx_cycle);
#ifndef LTE_EMBMS_SUPPORTED
   //   mapped_on_duration_in_sf = rrm_get_on_duration_timer_in_sf(p_on_duration);
   mapped_on_duration_in_sf = RRM_ONE;
#endif

   sf_end_value_for_on_duration = total_sf_available - RRM_ONE;
   num_unique_on_duration_per_drx_cycle =  total_sf_available / mapped_on_duration_in_sf;

   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
             "DRX Offset Range[%d to %d], a total of [%d] SF, Unique ON Duration per DRX cycle [%d]",
              sf_start_value_for_on_duration, sf_end_value_for_on_duration, total_sf_available,
              num_unique_on_duration_per_drx_cycle);

   p_drx_offset_local_array = (drx_res_alloc_tree_per_ue_t*)
                                rrm_mem_get(num_unique_on_duration_per_drx_cycle * sizeof(drx_res_alloc_tree_per_ue_t));
   if (RRM_PNULL == p_drx_offset_local_array)
   {
       RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
          "Unable to allocate memeory to p_drx_offset_local_array");
       RRM_UT_TRACE_EXIT();
       return ;
   }
   /* Initialize the local data structure */
   for (counter = RRM_ZERO; counter < num_unique_on_duration_per_drx_cycle ; counter++)
   {
      p_drx_offset_local_array[counter].drx_start_offset = 0xFFFF;
      p_drx_offset_local_array[counter].res_status = RRM_RES_BUSY;
   }
   
   while ((is_occupied == RRM_FALSE) && (ue_counter < num_unique_on_duration_per_drx_cycle))
   {
       valid_drx_offfset = RRM_FALSE;
	   if( RRM_ZERO == ue_counter )
	   {
		   temp_drx_offset = cnfg_drx_offset ;
                   valid_drx_offfset = RRM_TRUE;
	   }
	   else
	   {
		   temp_drx_offset = temp_drx_offset + mapped_on_duration_in_sf;
		   if(temp_drx_offset > sf_end_value_for_on_duration)
           {
               RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                         "End Range Crossed to [%d]. So restarting from ZERO again",
                          temp_drx_offset);
               
               temp_drx_offset = temp_drx_offset % total_sf_available;
               if( RRM_TRUE == rrm_is_drx_offset_already_occupied(p_drx_offset_local_array,temp_drx_offset,ue_counter) )
               {
                   is_occupied = RRM_TRUE;
               }
               else
               {
                   valid_drx_offfset = RRM_TRUE;
               }
           }
		   else
		   {
			   if( RRM_TRUE == rrm_is_drx_offset_already_occupied(p_drx_offset_local_array,temp_drx_offset,ue_counter) )
			   {
				   is_occupied = RRM_TRUE;
			   }
#ifdef LTE_EMBMS_SUPPORTED
               else if ( (RRM_ZERO != embms_sf_reserved_list) && 
                         (RRM_TRUE == rrm_check_configured_mtch_sf( embms_sf_reserved_list,temp_drx_offset)) )
               {
                   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                             "This DRX offset is not valid as due to collision with MBMS SF ");
               }
#endif
			   else
			   {
				   valid_drx_offfset = RRM_TRUE;
			   }
		   }
	   }

       if( RRM_TRUE == valid_drx_offfset)
       {
           p_drx_offset_local_array[ue_counter].res_status = RRM_RES_FREE;
           p_drx_offset_local_array[ue_counter].drx_start_offset = temp_drx_offset;
           ue_counter++;
       }
   }

   /*
   ** Populate these valid DRX offsets in the drx_res_tree repeatedly to be used
   ** for the UEs sequentially for a particular QCI
   */
   //*p_drx_res = (drx_res_alloc_tree_per_ue_t*)rrm_mem_get(configured_num_of_ue * 
     //                                                       sizeof(drx_res_alloc_tree_per_ue_t));
   ue_counter = RRM_ZERO;
   counter    = RRM_ZERO;
   while(counter < configured_num_of_ue)
   {
       if(ue_counter == num_unique_on_duration_per_drx_cycle)
       {
           ue_counter = RRM_ZERO;
       }
       RRM_MEMCPY(&(p_drx_res[counter]),&(p_drx_offset_local_array[ue_counter]),sizeof(drx_res_alloc_tree_per_ue_t));
       ue_counter++;
       counter++;
   }
   RRM_MEM_FREE(p_drx_offset_local_array);
   RRM_UT_TRACE_EXIT();

}
#endif

rrm_void_t    
initialize_cell_context_for_drx_resources
(
rrm_cell_context_t *p_cell_ctx
)
{
	U8 drx_profile_count = RRM_ZERO;
	U8 qci_count = RRM_ZERO;
	U8 qci_num   = RRM_ZERO;
	U8 drx_res_qci_cnt = RRM_ZERO;
	drx_t  *p_drx_config_from_oam = RRM_PNULL;
	rrm_cell_drx_config_resources_t *p_rrm_cell_drx_config_res = RRM_PNULL;
	U8  configured_num_of_ue = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	p_drx_config_from_oam = &(p_cell_ctx->ran_info.mac_layer_params.mac_layer_param_drx);
	p_rrm_cell_drx_config_res = &(p_cell_ctx->rrm_cell_drx_config_resources);
	configured_num_of_ue = p_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell;

	RRM_MEMSET(p_rrm_cell_drx_config_res, RRM_ZERO, sizeof(rrm_cell_drx_config_resources_t));

	for (qci_count = RRM_ZERO; qci_count < RRM_OAM_MAX_NUM_QCI_CLASSES; qci_count++)
	{
		p_rrm_cell_drx_config_res->drx_res_arr[qci_count].drx_enabled = RRM_FALSE;
		p_rrm_cell_drx_config_res->drx_res_arr[qci_count].qci = qci_count + RRM_ONE;
	}

	for (drx_profile_count = RRM_ZERO; drx_profile_count < p_drx_config_from_oam->num_valid_drx_profiles;
			drx_profile_count++)
	{
		for (qci_count = RRM_ZERO; 
				qci_count < p_drx_config_from_oam->drx_config[drx_profile_count].num_qci;
				qci_count++)
		{
			qci_num = p_drx_config_from_oam->drx_config[drx_profile_count].qci[qci_count];
			drx_res_qci_cnt = qci_num - RRM_ONE;

			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
					"Processing QCI[%d] of DRX profile num [%d].Storing DRX config at loc [%d] in DRX Res Pool",
					qci_num,drx_profile_count+RRM_ONE,drx_res_qci_cnt);

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].qci = qci_num;
			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].drx_enabled  = RRM_TRUE;

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].on_duration_timer =
				p_drx_config_from_oam->drx_config[drx_profile_count].on_duration_timer;

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].drx_inactivity_timer =
				p_drx_config_from_oam->drx_config[drx_profile_count].drx_inactivity_timer;

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].drx_retransmission_timer =
				p_drx_config_from_oam->drx_config[drx_profile_count].drx_retransmission_timer;

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].long_drx_cycle =
				p_drx_config_from_oam->drx_config[drx_profile_count].long_drx_cycle;

            #ifdef ENDC_ENABLED
			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].long_drx_cycle_r15 =
				p_drx_config_from_oam->drx_config[drx_profile_count].long_drx_cycle_r15;
            #endif

			if(p_drx_config_from_oam->drx_config[drx_profile_count].bitmask & RRMCM_RMIF_SHORT_DRX_CYCLE_PRESENT)
			{
				p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].bitmask = 0x00;
				p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].bitmask = RRMCM_SHORT_DRX_CONFIG_PRESENT;
				p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].short_drx_cycle_config.short_drx_cycle =
					p_drx_config_from_oam->drx_config[drx_profile_count].short_drx_cycle;
			}

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].short_drx_cycle_config.drx_short_cycle_timer =
				p_drx_config_from_oam->drx_config[drx_profile_count].drx_short_cycle_timer;

			p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].total_drx_offset  = configured_num_of_ue;

            #ifdef ENDC_ENABLED
            if ( RRM_OAM_R15_SF5120 <=
                p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].long_drx_cycle_r15 )
            {
                rrm_allocate_drx_offset_for_multiple_ues_r15(
                        p_drx_config_from_oam->drx_config[drx_profile_count].drx_start_offset,
                        configured_num_of_ue,
                        p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].drx_res_tree,
                        //&p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].on_duration_timer,
                        p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].long_drx_cycle_r15
#ifdef LTE_EMBMS_SUPPORTED
                        ,RRM_ZERO 
#endif
                        );
            }
            else
            {
                rrm_allocate_drx_offset_for_multiple_ues(
                        p_drx_config_from_oam->drx_config[drx_profile_count].drx_start_offset,
                        configured_num_of_ue,
                        p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].drx_res_tree,
                        //&p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].on_duration_timer,
                        p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].long_drx_cycle
#ifdef LTE_EMBMS_SUPPORTED
                        ,RRM_ZERO 
#endif
                        );
            }
            #else
			rrm_allocate_drx_offset_for_multiple_ues(
					p_drx_config_from_oam->drx_config[drx_profile_count].drx_start_offset,
					configured_num_of_ue,
					p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].drx_res_tree,
				        //&p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].on_duration_timer,
					p_rrm_cell_drx_config_res->drx_res_arr[drx_res_qci_cnt].long_drx_cycle
#ifdef LTE_EMBMS_SUPPORTED
                   ,RRM_ZERO 
#endif
                   );
            #endif
		}
	}

	RRM_UT_TRACE_EXIT();
}
/* SPR 10450 Fix End */

/*****************************************************************************
 * Array Name     : rmcm_rrm_process_cell_config_from_l2_event 
 * Inputs         : Pointer to Cell Context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function will initially start the timer for dynamic icic 
 *		            info exchanged with eNBs on X2.
 ****************************************************************************/
rrm_return_et 
rmcm_rrm_process_cell_config_from_l2_event
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
 )
{
    RrmMacCellConfigCnf    *p_mac_cnf = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();

/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = RRM_MAX_PATTERN_BYTE;
#endif
/*EICIC_TDD_CHANGES_END*/

    p_mac_cnf = (RrmMacCellConfigCnf *)
        (p_cell_ctx->p_incoming_api_info);
    rrmcm_rmif_generic_resp_t    *p_generic_resp = RRM_PNULL;
    U16                           alloc_cqi_ri_from_algo_val = RRM_ZERO;
    cqi_ri_map_info_per_ue        cqi_ri_table_map[MAX_PERIODICTY_CQI_N_P];
    /*SPR 17777 +-*/
    /*DYNAMIC ICIC START*/
    cell_timer_buf_t timer_buf;
    U8                    new_meas_abs_pattern[RRM_MAX_PATTERN_BYTE] ;
    /*DYNAMIC ICIC END*/

    if (RRM_SUCCESS == p_mac_cnf->responseCode)
    {
        /*filling parameter for RRMCM_RMIF_CELL_CONFIG_RESP response to MIF*/
        if (p_cell_ctx->cell_reconfig_deletion_required)
        {
            /* BUG_876_CHANGES_START*/
            if (RRM_CELLM_REF_SIG_PWR_NOT_UPDATED == p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
            {
                p_generic_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_resp_t));
                if (p_generic_resp == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_generic_resp failed" );
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                p_generic_resp->cellindex = p_cell_ctx->cell_index;
                p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
                p_generic_resp->response =  p_mac_cnf->responseCode;
                p_generic_resp->fail_cause= RRM_NO_ERROR;
                ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                        RRMCM_RMIF_CELL_RECONFIG_RESP,
                        sizeof(rrmcm_rmif_generic_resp_t),
                        (void *)p_generic_resp);
                /* Coverity 74349 Fix Start */
                if(RRM_SUCCESS != ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Send failed for RRMCM_RMIF_CELL_RECONFIG_RESP");
                }
                /* Coverity 74349 Fix End */
                RRM_MEM_FREE(p_generic_resp);
            }
            else
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                        "Mac Reconfig Success for ICIC");
                p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;
            }
            /* BUG_876_CHANGES_END*/
            /*Cov_fix_57887*/
            /*Cov_fix_57887*/
            /* BUG 9787 Fix Start */
            /* SPR 10855 FIX  */
            /*CSR_00059028_CHANGES_START */
            rrm_l2_build_send_reconfig_schedule_params(p_cell_ctx);
            /*CSR_00059028_CHANGES_END */
            /* BUG 9787 Fix End */
            /* BUG_12416_FIX_START */
            rrm_cellm_start_ld_process_timer(p_cell_ctx);
            /* BUG_12416_FIX_END */

        }
        else
        {
            if (RRM_FAILURE == rmcm_rmif_send_config_resp(p_cell_ctx,
                        p_mac_cnf->responseCode,
                        RRM_NO_ERROR))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_ERROR, "Failed To Send Config Resp to MIF for Cell-Index:%d",
                        p_cell_ctx->cell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                        "Send Config Resp to MIF for Cell index:%d",
                        p_cell_ctx->cell_index);

                /*Bug:9237 start*/
                 rrm_cell_init_queue(&p_cell_ctx->procedure_queue);
                /*Bug:9237 end*/
                /* CA_Stage3_Change: Start */
                /* When Cell Config Resp is sent as success to OAM,
                   then we update this count for total no. of cells configured on eNB and
                   reduced when cell is deleted.*/
                p_g_rrm_cell_ctx->enb_cell_count++;
                /* CA_Stage3_Change: End */
            } 
        }

        /* Unset the bitmask */
        p_cell_ctx->icic_l1_l2_report_info.bitmask ^= 
                   RRM_CTXT_L1_L2_CONFIGURED_REPORT_BITMASK_PRESENT;
        /* Check for conditions */
        if ((p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT) &&
            (p_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT) &&
            (ICIC_SCHEME_SFR == p_cell_ctx->operator_info.dynamic_icic_info.icic_scheme_type))
        {
            /*Klockwork_fix_2431_start*/  
            rmcm_rrm_process_icic_l1_l2_report(p_cell_ctx);
            /*Klockwork_fix_2431_end*/
        }
    
         /* eICIC_PHASE_1_2_CHANGES_START */
         p_cell_ctx->rrm_eicic_cell_info.bitmask = 0x00;
         if( RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT &
                   p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask )
         {
             /* SPR 14811 start */
             rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_APPLIED_FOR_LOW_LOAD);
             /* SPR 14811 end */
             RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied,
                     p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                     abs_size);
              rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied); 
             if( RRM_SUCCESS != rrm_cellm_get_highest_load_abs(p_cell_ctx, new_meas_abs_pattern))
             {
                 RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                         p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                         abs_size);
                 rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
             }
             else
             {
                 RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                         new_meas_abs_pattern,
                         abs_size);
                 rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
             }

             /* bug_13935_start */
             RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,RRM_ZERO,
                     RRM_MAX_PATTERN_BYTE);
             /* bug_13935_end */
             p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CELLM_SERVING_ABS_PATTERN_PRESENT;
         }
         if( RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT &
             p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask )
         {
             /* SPR 14811 start */
             rrm_raise_error_event_notification(RRM_EE_VICTM_ABS_APPLIED);
             /* SPR 14811 end */
             RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied,
                     p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                     abs_size);
             rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied);
             /* bug_13935_start */
             RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,RRM_ZERO,
                     RRM_MAX_PATTERN_BYTE);
             /* bug_13935_end */
             p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CELLM_USABLE_ABS_PATTERN_PRESENT;
         }
         /* eICIC_PHASE_1_2_CHANGES_START */

        /* Carrier Aggregation start*/
        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_CELL_LOAD_MULTICASTING_INFO] =  
            RRM_DEFINED_DEFAULT_VALUE_FOR_CELL_LOAD_MULTICASTING_TIMER;
        timer_buf.cell_index = p_cell_ctx->cell_index;
        timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_CELL_LOAD_MULTICASTING_INFO ;
        p_cell_ctx->intra_eNB_cell_load_broadcast_timer =
            cell_start_timer( CELL_PERIODIC_TIMER_FOR_CELL_LOAD_MULTICASTING_INFO,
                    (rrm_void_t*)(&timer_buf),sizeof (cell_timer_buf_t), p_cell_ctx ); 
        /* Carrier Aggregation end */
    }
    else
    {
        /* SPR 14811 start */
        if( RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT &
                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask )
        {
            rrm_raise_error_event_notification(RRM_EE_VICTM_ABS_NOT_APPLIED);
        }
        if( RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT &
                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask )
        {
            rrm_raise_error_event_notification(RRM_EE_AGGR_ABS_NOT_APPLIED_FOR_LOW_LOAD);
        }
        /* SPR 14811 end */

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "FAILURE received from L2 so not starting any timer");
        /*Building and sending fail response to MIF*/
        if (p_cell_ctx->cell_reconfig_deletion_required)
        {
           /* BUG_876_CHANGES_START*/
           if (RRM_CELLM_REF_SIG_PWR_NOT_UPDATED == p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
           {
               /*Building and sending fail response to MIF for reconfig*/
               p_generic_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_resp_t));
               if (p_generic_resp == RRM_PNULL)
               {
                  RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_generic_resp failed" );
                  RRM_UT_TRACE_EXIT();
                  return RRM_FAILURE;
               }
               /* coverity  id :16285 , added NULL check for rrm_mem_get */
               p_generic_resp->cellindex = p_cell_ctx->cell_index;
               p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
               p_generic_resp->response =  RRM_PARTIAL_SUCCESS;
               p_generic_resp->fail_cause = RRM_ERR_INCORRECT_PARTITION_INFO;
               ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                               RRMCM_RMIF_CELL_RECONFIG_RESP,
                               sizeof(rrmcm_rmif_generic_resp_t),
                               (void *)p_generic_resp);
                /* Coverity 74349 Fix Start */
                if(RRM_SUCCESS != ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Send failed for RRMCM_RMIF_CELL_RECONFIG_RESP");
                }
                /* Coverity 74349 Fix End */
               RRM_MEM_FREE(p_generic_resp);
               RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                               "Cell Reconfig Failed Cell State is:%s",
                               CELL_FSM_STATE[p_cell_ctx->cell_state]);
           }
           else
           {
               RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                         "Mac Reconfig Failed for ICIC");
               p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;
           }
           /* BUG_876_CHANGES_END*/
           /*Cov_fix_start_57887*/
           /*Cov_fix_end_57887*/
            if (RRM_CELLM_REF_SIG_PWR_NOT_UPDATED == p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic)
            {
                /*Building and sending fail response to MIF for reconfig*/
                p_generic_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_resp_t));
                if (p_generic_resp == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_generic_resp failed" );
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                /* overity  id :16285 , added NULL check for rrm_mem_get */
                p_generic_resp->cellindex = p_cell_ctx->cell_index;
                p_generic_resp->transaction_id = p_cell_ctx->ongoing_trans_id;
                p_generic_resp->response =  RRM_PARTIAL_SUCCESS;
                p_generic_resp->fail_cause = RRM_ERR_INCORRECT_PARTITION_INFO;
                ret_val = rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
                        RRMCM_RMIF_CELL_RECONFIG_RESP,
                        sizeof(rrmcm_rmif_generic_resp_t),
                        (void *)p_generic_resp);
                /* Coverity 74349 Fix Start */
                if(RRM_SUCCESS != ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Send failed for RRMCM_RMIF_CELL_RECONFIG_RESP");
                }
                /* Coverity 74349 Fix End */
                RRM_MEM_FREE(p_generic_resp);
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Cell Reconfig Failed Cell State is:%s",
                        CELL_FSM_STATE[p_cell_ctx->cell_state]);
            }
            else
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                        "Mac Reconfig Failed for ICIC");
                p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;
            }
            /* BUG_876_CHANGES_END*/
            /*Cov_fix_63721*/
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell Reconfig Failed Cell State is:%s",
                    CELL_FSM_STATE[p_cell_ctx->cell_state]);
            /*Cov_fix_63721*/
        }
        else
        {
            ret_val = rmcm_rmif_send_config_resp(p_cell_ctx,
                    /*spr 7871 start*/
                    RRM_FAILURE,
                    /*spr 7871 end*/
                    RRM_ERR_INCORRECT_PARTITION_INFO);
            /* Coverity 74349 Fix Start */
            if(RRM_SUCCESS != ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,
                        RRM_BRIEF,"Failed in rmcm_rmif_send_config_resp");
            }
            /* Coverity 74349 Fix End */
        }
        /*spr 7871 start*/
        CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_IDLE);
        return RRM_SUCCESS;
        /*spr 7871 end*/
    }

    /* SPR 10450 Fix Start */
    initialize_cell_context_for_drx_resources(p_cell_ctx); 
    /* SPR 10450 Fix End */
    
    /* 
     * Now SUCCESS has been reported for Cell Configuration/Reconfiguration
     * Resources can be allocated at this point for UEs
     */  
    rrm_cellm_cell_initialize_cqi_res_list(p_cell_ctx,
            cqi_ri_table_map, 
            &alloc_cqi_ri_from_algo_val);
    /*SPR 17777 +-*/
    rrm_cellm_cell_initialize_sr_res_list(p_cell_ctx); 
    /* SRS Start */
    if(RRM_TRUE == p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled)
    {
        rrm_cellm_cell_initialize_srs_res_list(p_cell_ctx);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF,"SRS resources can not be allocated SRS is disabled");
    }
    /* SRS End */
    /*Start:SPR 8715*/
    rrm_assign_num_tpc_id_dci_3_3a(p_cell_ctx);
    /*End:SPR 8715*/
    /*CLPC start*/
    /*Allocate tpc rnti table for pusch*/
    /*SPR 15994 Fix start*/
    if(RRM_PNULL == p_cell_ctx->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch)
    {
        rrm_allocate_tpc_rnti_table_pusch
            (p_cell_ctx);
        /*SPR 15994 Fix start*/
    }
    /*SPR 15994 Fix stop*/
    /*Allocate tpc rnti table for pucch*/
    /*SPR 15994 Fix start*/
    if(RRM_PNULL ==p_cell_ctx->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch)
    {
        /*SPR 15994 Fix stop*/
        rrm_allocate_tpc_rnti_table_pucch
            (p_cell_ctx);
        /*SPR 15994 Fix start*/
    }
    /*SPR 15994 Fix stop*/
    /*CLPC end*/
    /* SPS changes started */
    /*CA start: always allocate SPS data*/    
    /* Coverity_fix_63721_start */
    rrm_allocate_mem_n1_pucch_an_sps_status(p_cell_ctx);
    /* Coverity_fix_63721_end */
    /*CA end: always allocate SPS data*/    
    /* SPS changes End */

    /* Spr 16211 Changes Start*/
    /* Code Removed */
    /* Spr 16211 Changes End*/

    /*DYNAMIC ICIC START*/
    /*
     ** Start the CELL_RECONFIG_TIMER_FOR_ICIC timer with value of
     ** 20 SEC.
     */
    p_cell_ctx->timer_val[CELL_RECONFIG_TIMER_FOR_ICIC] = CELL_RECONFIG_TIMER_VALUE_FOR_ICIC; 
    timer_buf.cell_index = p_cell_ctx->cell_index;
    timer_buf.timer_type = CELL_RECONFIG_TIMER_FOR_ICIC;
    /* BUG_11848_CHANGES_START */
    if (RRM_FALSE == p_cell_ctx->immediate_cell_start)
    {
       p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic = RRM_PNULL;
    }
    else
    {
       p_cell_ctx->dynamic_icic_data.cell_reconfig_time_for_icic =
          cell_start_timer(CELL_RECONFIG_TIMER_FOR_ICIC,
                          (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
    }
    /* Spr 16211 Changes Start*/
    /* Code Removed */
    /* Spr 16211 Changes End*/
    /* BUG_11848_CHANGES_END */
    /*DYNAMIC ICIC END*/
    /* SPR 21419 Fix Start */
    /* Code Deletd */ 
    /* SPR 21419 Fix Stop */
    /*filling parameter for RRMCM_RMIF_CELL_CONFIG_RESP response to MIF*/
    if (p_cell_ctx->cell_reconfig_deletion_required)
    {
        p_cell_ctx->cell_reconfig_deletion_required = RRM_FALSE;
        /*State transition*/
        /*CSR_00059028_CHANGES_START */
        if (RRM_FALSE == p_cell_ctx->immediate_cell_start)
        {
            CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_W_FOR_CELL_START);
        }
        else
        {
            /*State transition*/
            CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_ACTIVE);
        }
        /*CSR_00059028_CHANGES_END */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_BRIEF,"Reconfig Succes Cell State Is:%s For Cell Index:%d",
                CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
        CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_ACTIVE);
        /* SPR-9532-fix start */
        /** RIM changes start */
    /* Spr 16211 Changes Start*/
        if(p_g_rrm_cell_ctx->enb_context.rim_feature_enable == RRM_TRUE)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Sending RIM info req to RRC with PDU ext as STOP as cell has been successfully stopped");
            rrm_request_rim_info_req(p_cell_ctx, 
                    &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl,
                    RAN_INFO_REQ_STOP);
        }
    /* Spr 16211 Changes End*/
        /* RIM changes end */
        /* SPR-9532-fix end */

    }
    else
    {
        /* SRS Start */
        /*if explicit start flag is true */
        /*Klockwork_fix_2431_start*/
        ret_val = rrm_fill_deletion_cell_config_resp(p_cell_ctx);
        if(ret_val == RRM_FAILURE)
        {
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /*Klockwork_fix_2431_end*/

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* DYNAMIC ICIC CHANGES END */

/*Bug:9237 start*/
/******************************************************************************
 *   FUNCTION NAME: rrmcm_queue_message 
 *   DESCRIPTION:
 *          Function to queue the message.
 *   RETURNS:
 *		rrm_return_et
 ******************************************************************************/
rrm_return_et
rrmcm_queue_message
(
rrm_cell_context_t *p_cell_ctx 
)
{
    rrm_cell_procedure_queue_t    cell_proc_msg = {RRM_ZERO};
    rrmcm_rmif_cell_reconfig_req_t  *p_cell_reconfig_req= RRM_PNULL;
    rrmcm_rmif_updated_nrt_info_t  *p_updated_nrt_info = RRM_PNULL;
  /* SPR 18055 Start */
  rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *p_rrmcm_rmif_cell_stop_adm_req_for_cell_block = RRM_PNULL;
  /* SPR 18055 End */
  /*SPR 21322 START*/
  rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t
	  *p_rrmcm_rmif_cell_start_adm_req_for_cell_unblock = RRM_PNULL;
  /*SPR 21322 END*/

        /* SPR_17763_FIX_START */
    rrmcm_rmif_cell_reconfig_req_t  *p_temp_cell_reconfig_req = RRM_PNULL;
    rrmcm_rmif_updated_nrt_info_t  *p_temp_updated_nrt_info = RRM_PNULL;
    rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *p_temp_cell_stop_adm_req_for_cell_block = RRM_PNULL;
    rrm_cell_procedure_record_t    *p_rrm_cell_procedure_record_temp = RRM_PNULL;
    struct timeval  temp_time_val = {RRM_ZERO};
    struct timeval  time_val = {RRM_ZERO};
    rrm_bool_et     push_at_tail = RRM_FALSE;
    rrmcm_rmif_cell_stop_req_t *p_temp_cell_stop_req = RRM_PNULL;
    rrmcm_rmif_rach_info_ind_t   *p_temp_rach_info_ind = RRM_PNULL;
        /* SPR_17763_FIX_END */
        /*SPR 21322 START*/
    rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *p_temp_cell_start_adm_req_for_cell_unblock = RRM_PNULL;
        /*SPR 21322 END*/
    /* BUG_11648_FIX_START */
    rrmcm_rmif_cell_stop_req_t *p_cell_stop_req= RRM_PNULL;
    /* BUG_11648_FIX_END */
    /* bug_13972_start */
    x2ap_rrm_load_information_ind_t *p_rrm_load_ind = RRM_PNULL;
    /* bug_13972_end */
    rrm_return_et  ret_val = RRM_SUCCESS;
#ifdef LTE_EMBMS_SUPPORTED
    m2ap_rrm_mbms_sf_info_req_t *p_rrm_mbms_sf_info = RRM_PNULL;
#endif
    RRM_UT_TRACE_ENTER();
    switch(p_cell_ctx->api_id)
    {
        case RRMCM_RMIF_CELL_RECONFIG_REQ: 
            cell_proc_msg.event_id = RRMCM_RMIF_RECONFIG_REQ_EVENT;
            p_cell_reconfig_req = (rrmcm_rmif_cell_reconfig_req_t *)rrm_mem_get(sizeof(rrmcm_rmif_cell_reconfig_req_t));
            if(RRM_PNULL != p_cell_reconfig_req)
            {
                RRM_MEMCPY(p_cell_reconfig_req, (rrmcm_rmif_cell_reconfig_req_t *)p_cell_ctx->p_incoming_api_info, 
                sizeof(rrmcm_rmif_cell_reconfig_req_t)); 
                cell_proc_msg.p_proc_data = p_cell_reconfig_req; 
        /* SPR_17763_FIX_START */
                time_val = p_cell_reconfig_req->incoming_time_stamp; 
        /* SPR_17763_FIX_END */
            }
            break;
        case RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ: 
            cell_proc_msg.event_id = RRMCM_RMIF_UPDATED_NRT_INFO_EVENT;
            p_updated_nrt_info = (rrmcm_rmif_updated_nrt_info_t *)rrm_mem_get(sizeof(rrmcm_rmif_updated_nrt_info_t));
            if (RRM_PNULL != p_updated_nrt_info)
            {
                RRM_MEMCPY(p_updated_nrt_info,(rrmcm_rmif_updated_nrt_info_t *)p_cell_ctx->p_incoming_api_info,
                sizeof(rrmcm_rmif_updated_nrt_info_t));
                cell_proc_msg.p_proc_data = p_updated_nrt_info; 
        /* SPR_17763_FIX_START */
                time_val = p_updated_nrt_info->incoming_time_stamp; 
        /* SPR_17763_FIX_END */
            }
            break;
      /* SPR 18055 Start */
        case RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK:
            cell_proc_msg.event_id = RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT;
            p_rrmcm_rmif_cell_stop_adm_req_for_cell_block = 
               (rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *)
            rrm_mem_get(sizeof(rrmcm_rmif_cell_stop_adm_req_for_cell_block_t));
            if (RRM_PNULL != p_rrmcm_rmif_cell_stop_adm_req_for_cell_block)
            {
                RRM_MEMCPY(p_rrmcm_rmif_cell_stop_adm_req_for_cell_block,
                  (rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *)p_cell_ctx->p_incoming_api_info,
                    sizeof(rrmcm_rmif_cell_stop_adm_req_for_cell_block_t));
                cell_proc_msg.p_proc_data = p_rrmcm_rmif_cell_stop_adm_req_for_cell_block; 
           /* SPR_17763_FIX_START */
                time_val = p_rrmcm_rmif_cell_stop_adm_req_for_cell_block->incoming_time_stamp; 
           /* SPR_17763_FIX_END */
            }
            break;
      /* SPR 18055 End */
	    /*SPR 21322 START*/
	case RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK:
	    cell_proc_msg.event_id =
		    RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT;
	    p_rrmcm_rmif_cell_start_adm_req_for_cell_unblock = 
		    (rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *)
		    rrm_mem_get(sizeof(rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t));
        if (RRM_PNULL != p_rrmcm_rmif_cell_start_adm_req_for_cell_unblock)
        {
            RRM_MEMCPY(p_rrmcm_rmif_cell_start_adm_req_for_cell_unblock,
                    (rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *)p_cell_ctx->p_incoming_api_info,
                    sizeof(rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t));
            cell_proc_msg.p_proc_data =
                p_rrmcm_rmif_cell_start_adm_req_for_cell_unblock;

            time_val = p_rrmcm_rmif_cell_start_adm_req_for_cell_unblock->incoming_time_stamp;
            /* Bug 4569 start */
            ret_val = RRM_SUCCESS;
            /* Bug 4569 end */
        }
	    break;
	    /*SPR 21322 END*/
        case RRMCM_RMIF_RACH_INFO_IND:
            cell_proc_msg.event_id = RRMCM_RMIF_RACH_INFO_IND_EVENT;
            cell_proc_msg.p_proc_data = (rrmcm_rmif_rach_info_ind_t *)rrm_mem_get(sizeof(rrmcm_rmif_rach_info_ind_t));
            if (RRM_PNULL != cell_proc_msg.p_proc_data)
            {
                RRM_MEMCPY(cell_proc_msg.p_proc_data,(rrmcm_rmif_rach_info_ind_t *)p_cell_ctx->p_incoming_api_info,
                sizeof(rrmcm_rmif_rach_info_ind_t));
           /* SPR_17763_FIX_START */
                time_val = ((rrmcm_rmif_rach_info_ind_t *)cell_proc_msg.p_proc_data)->incoming_time_stamp; 
           /* SPR_17763_FIX_END */
            }
            break;
            /* BUG_11648_FIX_START */
        case RRMCM_RMIF_CELL_STOP_REQ:
            cell_proc_msg.event_id = RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT;
            p_cell_stop_req = (rrmcm_rmif_cell_stop_req_t*)rrm_mem_get(sizeof(rrmcm_rmif_cell_stop_req_t));
            if (p_cell_stop_req != RRM_PNULL)
            {
                RRM_MEMCPY(p_cell_stop_req,(rrmcm_rmif_cell_stop_req_t*)p_cell_ctx->p_incoming_api_info,
                        sizeof(rrmcm_rmif_cell_stop_req_t));
                cell_proc_msg.p_proc_data = p_cell_stop_req;
           /* SPR_17763_FIX_START */
                time_val = p_cell_stop_req->incoming_time_stamp; 
           /* SPR_17763_FIX_END */
            }
            break;
            /* BUG_11648_FIX_END */
            /* 13972_start */
        case X2AP_RRM_LI_ENB_LOAD_INFORMATION_IND: 
            cell_proc_msg.event_id = RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT;
            p_rrm_load_ind = (x2ap_rrm_load_information_ind_t*)rrm_mem_get(sizeof(x2ap_rrm_load_information_ind_t));
            if (p_rrm_load_ind != RRM_PNULL)
            {
                RRM_MEMCPY(p_rrm_load_ind,(x2ap_rrm_load_information_ind_t*)p_cell_ctx->p_incoming_api_info,
                        sizeof(x2ap_rrm_load_information_ind_t));
                cell_proc_msg.p_proc_data = p_rrm_load_ind;
           /* SPR_17763_FIX_START */
                time_val.tv_sec = RRM_ZERO;
                time_val.tv_usec = RRM_ZERO;
           /* SPR_17763_FIX_END */
            }
            break;
            /* 13972_end */        
#ifdef LTE_EMBMS_SUPPORTED
        case M2AP_RRM_MBMS_SF_INFO_REQ: 
            cell_proc_msg.event_id = RRMCM_M2AP_SF_INFO_REQ_EVENT;
            p_rrm_mbms_sf_info = (m2ap_rrm_mbms_sf_info_req_t*)
                    rrm_mem_get(sizeof(m2ap_rrm_mbms_sf_info_req_t));
            if (RRM_PNULL != p_rrm_mbms_sf_info)
            {
                RRM_MEMCPY(p_rrm_mbms_sf_info,(m2ap_rrm_mbms_sf_info_req_t*)p_cell_ctx->p_incoming_api_info,
                        sizeof(m2ap_rrm_mbms_sf_info_req_t));
                cell_proc_msg.p_proc_data = p_rrm_mbms_sf_info;
            }
            /*SPR 18334 : START*/
            p_cell_ctx->rrm_cell_embms_data.m2ap_mbsfn_resp.m2ap_resp_status = RRMCM_CELL_DEQUEUE_SF_INFO_REQ;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Enqueue for SF_INFO_REQ for cell_index [%d]",p_cell_ctx->cell_index);
            /*SPR 18334 : END*/

            break;
#endif

        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Enqueue for api id[%d] is not supported in cell index[%d]", p_cell_ctx->api_id,p_cell_ctx->cell_index);
            ret_val = RRM_FAILURE;
            break;
    }
    if (RRM_SUCCESS == ret_val)
    {
        /*SPR_11293_FIX_START */
        cell_proc_msg.trans_id = p_cell_ctx->ongoing_trans_id; 
        /*TRANS ID FIX */
        cell_proc_msg.api_id = p_cell_ctx->api_id; 


/* SPR_17763_FIX_START */
        p_rrm_cell_procedure_record_temp = (rrm_cell_procedure_record_t *) ylFirst(&p_cell_ctx->procedure_queue);
        if (PNULL != (p_rrm_cell_procedure_record_temp))
        {
            if (RRMCM_RMIF_CELL_RECONFIG_REQ == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               p_temp_cell_reconfig_req = (rrmcm_rmif_cell_reconfig_req_t *)p_rrm_cell_procedure_record_temp->proc_queue.p_proc_data;
               temp_time_val = p_temp_cell_reconfig_req->incoming_time_stamp;
            }
            else if (RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               p_temp_updated_nrt_info = (rrmcm_rmif_updated_nrt_info_t *)p_rrm_cell_procedure_record_temp->proc_queue.p_proc_data;
               temp_time_val = p_temp_updated_nrt_info->incoming_time_stamp;
            }
            else if (RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               p_temp_cell_stop_adm_req_for_cell_block = (rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *)p_rrm_cell_procedure_record_temp->proc_queue.p_proc_data;
               temp_time_val = p_temp_cell_stop_adm_req_for_cell_block->incoming_time_stamp;
            }
            /*SPR 21322 START*/
            else if (RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               p_temp_cell_start_adm_req_for_cell_unblock = (rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *)p_rrm_cell_procedure_record_temp->proc_queue.p_proc_data;
               temp_time_val = p_temp_cell_start_adm_req_for_cell_unblock->incoming_time_stamp;
            }
            /*SPR 21322 END*/
            else if (RRMCM_RMIF_RACH_INFO_IND == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               p_temp_rach_info_ind = (rrmcm_rmif_rach_info_ind_t *)p_rrm_cell_procedure_record_temp->proc_queue.p_proc_data;
               temp_time_val = p_temp_rach_info_ind->incoming_time_stamp;
            }
            else if (RRMCM_RMIF_CELL_STOP_REQ == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               p_temp_cell_stop_req = (rrmcm_rmif_cell_stop_req_t *)p_rrm_cell_procedure_record_temp->proc_queue.p_proc_data;
               temp_time_val = p_temp_cell_stop_req->incoming_time_stamp;
            }
            else if (X2AP_RRM_LI_ENB_LOAD_INFORMATION_IND == p_rrm_cell_procedure_record_temp->proc_queue.api_id)
            {
               temp_time_val.tv_sec = RRM_ZERO;
               temp_time_val.tv_usec = RRM_ZERO;
            }
            if (RRM_ONE == rrm_is_newer_node_getting_inserted(&time_val, &temp_time_val))
            {
                push_at_tail = RRM_TRUE;
            }
        }
        else
        {
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
            "Proc queue is empty");
        }
        ret_val = rrm_cell_mgr_enqueue_req( &cell_proc_msg, p_cell_ctx, push_at_tail);
/* SPR_17763_FIX_END */
        /* SPR 18055 Start */
        if(ret_val == RRM_SUCCESS)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO, 
                    "Enqueue for api id[%d] in cell index[%d] is successful", p_cell_ctx->api_id,p_cell_ctx->cell_index);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                    "Enqueue for api id[%d] in cell index[%d] is unsuccessful", p_cell_ctx->api_id,p_cell_ctx->cell_index);
        }
        /* SPR 18055 End */
    }
    /* SPR_19279_START/END Code Deleted */
    /*SPR_11293_FIX_END */
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*Bug:9237 end*/
/*****************************************************************************
 * Array Name     : rrm_cellm_fsm_tbl
 * Inputs         : CELL_MAX_STATES, RRMCM_CELL_MAX_EVENTS
 * Outputs        : None
 * Returns        : None
 * Description    : Definition of two dimensional array of functional pointer 
 *		    for FSM
 ****************************************************************************/
rrm_cellm_func_ptr rrm_cellm_fsm_tbl[CELL_MAX_STATES][RRMCM_CELL_MAX_EVENTS]=
{
	/* CELL_STATE_IDLE */
	{

        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_rmif_cell_config_req,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event, 
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event, 
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*spr_22250_changes_start*/
        rmcm_rrc_failed_event,
        /*spr_22250_changes_end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /*RRMCM_M2AP_SF_INFO_REQ_EVENT*/
        ,rmcm_ignore_event 
#endif
    
    },

	/* CELL_STATE_W_FOR_CONFIG_RESP */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_rrc_cell_setup_resp,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,       
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event, 
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event, 
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_rrm_process_cell_config_from_l2_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /*RRMCM_M2AP_SF_INFO_REQ_EVENT*/
        ,rrmcm_queue_message 
#endif
    },

	/* CELL_STATE_W_FOR_CELL_START*/
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,        
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_rmif_cell_start_req, 
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        /*CSR_00059028_CHANGES_START */
        rmcm_mif_reconfig_req,
        /*CSR_00059028_CHANGES_END */
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        /*rmcm_mif_stop_adm_req,*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
		/* SPR 17673 - Bug-3763 FIX START */
        rmcm_ignore_event,
		/* SPR 17673 - Bug-3763 FIX END */
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        /* Start CSR 00064477 */
        rmcm_mif_meas_config_req, 
        /* End CSR 00064477 */
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /* SPR 15767 start*/
        rrmcm_queue_message,
        /* SPR 15767 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /*RRMCM_M2AP_SF_INFO_REQ_EVENT*/
        ,rrmcm_sf_info_req_failure
  #endif
    },
	/* CELL_STATE_W_FOR_CELL_START_RESP*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rrm_rrc_cell_start_resp,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req, 
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        /* SPR 20934 - SPR 17673 - Bug-3763 Fix Start */
        rmcm_ignore_event,
        /* SPR 20934 - SPR 17673 - Bug-3763 Fix End */
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event, 
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        /* Start CSR 00064477 */
        rmcm_mif_meas_config_req, 
        /* End CSR 00064477 */
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /* SPR 15767 start*/
        rrmcm_queue_message,
        /* SPR 15767 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /*RRMCM_M2AP_SF_INFO_REQ_EVENT*/
        ,rrmcm_queue_message 
#endif
 
    },

	/* CELL_STATE_ACTIVE */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_reconfig_req,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_rmif_cell_stop_req,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_update_req,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*Cell update end*/
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_updated_nrt_info,
        /*RRC_RRM_PWS_REQ_EVENT*/
        rmcm_rrc_pws_req,      
        /*RRC_RRM_PWS_CNF_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_REQ_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event, 
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rrmcm_rrm_mlb_cell_reconfig_req_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */                    
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_ttt_update_ind,

       /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rim_info_resp,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rrmcm_rrm_dynamic_icic_l1_l2_report_info_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_x2ap_load_info_ind_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rrmcm_rrm_process_cell_reconfig_for_icic_tmr,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rrmcm_rrm_process_cell_reconfig_for_cell_block,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_meas_config_obj_remove_req,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_rach_info_ind,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrm_cellm_find_and_apply_common_abs_pattern,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrm_cellm_find_and_update_common_abs_pattern,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_mac_abs_reconfig_req
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
       /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
       ,rrmcm_process_mbms_sf_info_req
#endif
 
	},

	/* CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_STOP_RESP */
	{
        /* RRMCM_RMIF_CELL_CONFIG_REQ */ 
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_rmif_reconfig_ongoing_stopped_resp,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
	   /* RRC_RRM_PWS_REQ_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_PWS_CNF_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_KILL_REQ_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_KILL_CNF_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
       rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
	},
	/* CELL_STATE_W_FOR_CELL_RECONFIG_RESP */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_rrc_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_pws_req,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
              /* MLB Changes end */
        /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rim_info_resp,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rrmcm_rrm_dynamic_icic_l1_l2_report_info_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,

        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
       /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
 
    },

	/* CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_RECONFIG_RESP */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_rmif_reconfig_ongoing_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rrmcm_rrm_dynamic_icic_l1_l2_report_info_event ,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
         ,rrmcm_queue_message
#endif
 
	},
    /*CELL_STATE_W_FOR_CELL_RECONFIG_ONGOING_START_RESP*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_rmif_reconfig_ongoing_start_resp,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,

            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rrmcm_rrm_dynamic_icic_l1_l2_report_info_event ,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
 
    },

	/* CELL_STATE_W_FOR_CELL_DEL */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
       rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rim_info_resp,
            /*commenting as RIM_info_error is not supported by L3*/
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
        
	},
    
    /*CELL_STATE_W_FOR_CELL_STOP_RESP*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_rmif_cell_stop_resp,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /* SPR 18055 Start */
        rrmcm_queue_message,
        /* SPR 18055 End */
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
         rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rim_info_resp,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /* RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
        /* eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
    },
    /*Cell update start*/
    /* CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_STOP_RESP */
    {
        /* RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_rmif_update_ongoing_stopped_resp,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*Cell update end*/
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
       /* RRC_RRM_PWS_REQ_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_PWS_CNF_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_KILL_REQ_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_KILL_CNF_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
       rmcm_rrc_failed_event,
       /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
       rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* MLB Changes end */
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
    },

    /* CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_UPDATE_RESP */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_rmif_update_ongoing_update_resp,
        /*Cell update start*/
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* MLB Changes end */
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
 

    },
    /*CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_START_RESP*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_rmif_update_ongoing_start_resp,
        /*Cell update end*/
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* MLB Changes end */
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
 

    },
    /*Cell update end*/
 
    /* CELL_STATE_OUT_OF_SERVICE */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_rmif_cell_start_req,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req, 
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
 

    },
    /*CELL_STATE_DELETE_IN_PROGRESS */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,    
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_rmif_cell_del_resp,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        /*spr 7754 start*/
        rmcm_ignore_event, 
        /*spr 7754 end*/
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event, 
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
         /*SPR 20553 FIX START */
        rmcm_rrc_failed_event,
         /*SPR 20553 FIX END */
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
    },
    
    /*CELL_STATE_UEM_DEL*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_ue_del_resp,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event, 
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
    },
    
    /* CELL_STATE_INACTIVE */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_rmif_cell_start_req,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
     /* BUG_11848_CHANGES_START */
        rmcm_mif_reconfig_req,
     /* BUG_11848_CHANGES_END */
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        /*rmcm_mif_stop_adm_req,*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /* SPR-22338 START */
        rmcm_mif_updated_nrt_info,
        /* SPR-22338 END */
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_timer_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
	/*Bug_9946_fix_start */
	    rmcm_mif_rach_info_ind,
	/*Bug_9946_fix_end */        
	/* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rmcm_rrc_failed_event 
        /*eMBMS Feature End*/
#endif
    },

	/* CELL_STATE_W_FOR_CELL_DEL_RECONFIG_FAILED */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req_reconfig_fail,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event, 
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event, 
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
 
	},
	/* CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_NRT */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        /*rmcm_mif_failed_evient,*/
        /*BUG:9237 start*/
        rrmcm_queue_message,
        /*BUG:9237 end*/
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_rrc_reconfig_resp_for_nrt,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req, 
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*BUG:9237 start*/
        rrmcm_queue_message,
        /*BUG:9237 end*/
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
            /* MLB Changes end */
            /* RRC_RRM_RIM_INFO_EVENT */
            /* Bug 4243 start */
            rrmcm_queue_message,
            /* Bug 4243 end */
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        /* SPR_19619 start */
        rmcm_ignore_event,
        /* SPR_19619 stop */
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
		/*Bug 831 Changes Start*/
		//rmcm_ignore_event,
		rrmcm_queue_message,
		/*Bug 831 Changes End*/
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
    /* SPR 18055 Start */
        rrmcm_queue_message,
    /* SPR 18055 End */
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
	/* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
	/*SPR 21322 START*/
	rrmcm_queue_message,
	/*SPR 21322 END*/
	/* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rrmcm_queue_message,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
         ,rrmcm_queue_message 
        /*eMBMS Feature End*/
#endif
 
	},
        
     /*CELL_STATE_PWS_ONGOING*/
     {

        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_rrc_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*SPR_11293_FIX_START */
        rrmcm_queue_message,
        /*SPR_11293_FIX_END */
        /*RRC_RRM_PWS_REQ_EVENT*/
        rmcm_rrc_pws_req,      
        /*RRC_RRM_PWS_CNF_EVENT*/
        rmcm_rrc_pws_cnf, 
        /*RRC_RRM_KILL_REQ_EVENT*/
        rmcm_rrc_kill_req, 
        /*RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_kill_cnf ,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_update_pws_list_req, 
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_update_pws_list_cnf, 
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
  /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        /* SPR 18055 Start */
        rrmcm_queue_message,
        /* SPR 18055 End */
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
 
       },
       /* CELL_STATE_MLB_W_FOR_CELL_RECONFIG_RESP */
       {
        /*RRMCM_RMIF_CONFIG_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_RECONFIG_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ_EVENT*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP_EVENT*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ_EVENT*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ_EVENT*/
        rmcm_mif_start_adm_req,
        /*RRMCM_RMIF_CELL_SON_REGISTER_REQ_EVENT*/
        rmcm_mif_register_req,
        /*RRMCM_RMIF_CELL_SON_DEREGISTER_REQ_EVENT*/
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ_EVENT*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /*RRMCM_RMIF_MEAS_CONFIG_REQ_EVENT*/
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /*Bug:9237 start*/
        rrmcm_queue_message,
        /*Bug:9237 end*/
        /*RRC_RRM_PWS_REQ_EVENT*/
        rmcm_rrc_pws_req,
        /*RRC_RRM_PWS_CNF_EVENT*/
        rmcm_rrc_failed_event,
        /*RRC_RRM_KILL_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_KILL_CNF_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT*/
        rmcm_mif_failed_event,
        /*RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT*/
        rmcm_mif_failed_event,
        /*RRM_PERIODIC_RESRC_UPDATE_EVENT*/
        rrmcm_rrm_periodic_resrc_update,
        /*RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT*/
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /*RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT*/
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /*RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT*/
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /*RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event,
        /*RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT*/
        rrmcm_rrm_mlb_cell_reconfig_resp_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        /* Start :SPR 8671 */
        rmcm_mif_failed_event,
        /* End :SPR 8671 */
        /* MLB Changes end */
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rrmcm_rrm_dynamic_icic_l1_l2_report_info_event ,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        /* SPR 18055 Start */
        rrmcm_queue_message,
        /* SPR 18055 End */
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
         ,rrmcm_queue_message 
        /*eMBMS Feature End*/
#endif
 
    },
	/* CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2 */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_reconfig_req,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        /* BUG_11648_FIX_START */
        rrmcm_queue_message,
        /* BUG_11648_FIX_END */
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_update_req,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*Cell update end*/
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        /* SPR 14215 start*/
        rrmcm_queue_message,
        /* SPR 14215 end*/
        /*RRC_RRM_PWS_REQ_EVENT*/
        rmcm_rrc_pws_req,      
        /*RRC_RRM_PWS_CNF_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_REQ_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event, 
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rrmcm_rrm_mlb_cell_reconfig_req_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */                    
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_ttt_update_ind,

            /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rim_info_resp,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        /* bug_13972_start */ 
        //rmcm_ignore_event,
        rrmcm_queue_message,
        /* _bug_13972_end */ 
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_uem_resp_or_l2_resp_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        /* SPR 18055 Start */
        rrmcm_queue_message,
        /* SPR 18055 End */
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
            /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
         ,rrmcm_queue_message 
        /*eMBMS Feature End*/
#endif
 
	},
	/* CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_reconfig_req,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        /* BUG_11648_FIX_START */
        rrmcm_queue_message,
        /* BUG_11648_FIX_END */
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_update_req,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*Cell update end*/
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_updated_nrt_info,
        /*RRC_RRM_PWS_REQ_EVENT*/
        rmcm_rrc_pws_req,      
        /*RRC_RRM_PWS_CNF_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_REQ_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event, 
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rrmcm_rrm_mlb_cell_reconfig_req_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* MLB Changes end */                    
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_ttt_update_ind,
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rim_info_resp,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_uem_resp_or_l2_resp_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_rrm_reconfig_resp_for_cell_block,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
 
	},
	/* CELL_STATE_ALREADY_BLOCKED */
	{
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_reconfig_req,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_rmif_cell_stop_req,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*Cell update start*/
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_update_req,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*Cell update end*/
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req, 
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_updated_nrt_info,
        /*RRC_RRM_PWS_REQ_EVENT*/
        rmcm_rrc_pws_req,      
        /*RRC_RRM_PWS_CNF_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_REQ_EVENT*/
        rmcm_rrc_failed_event, 
        /*RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event, 
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rrmcm_rrm_mlb_cell_reconfig_req_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* MLB Changes end */                    
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_ttt_update_ind,
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rim_info_resp,
        /* DYNAMIC ICIC CHANGES START */
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_uem_resp_or_l2_resp_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* DYNAMIC ICIC CHANGES END */
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rrmcm_mif_process_cell_reconfig_for_cell_unblock,
        /* SON ES MLB Started */
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* SON ES MLB end */
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_END */
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        rmcm_ignore_event,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rmcm_ignore_event,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rmcm_ignore_event,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rmcm_ignore_event,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
        /*eMBMS Feature Start*/
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
 
	},
   	/*spr 9631 fix start*/
	/*CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_STOP*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_reconfig_resp_during_cell_stop,
        //rmcm_rrc_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        /*rmcm_mif_stop_adm_req,*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_timer_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /*spr 9631 fix end*/
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
            /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_sf_info_req_failure
#endif
    },
    /* CA_Stage3_Change: Start */
    /* CELL_STATE_W_FOR_CELL_INFO_CHANGE_RESP */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        //rmcm_rrc_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        /*rmcm_mif_stop_adm_req,*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_timer_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* CA_Stage3_Change: Start */
        /*RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT*/
        rrmcm_cm_cell_delete_resp,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
    },
    /* CA_Stage3_Change: End */
    /* BUG_11648_FIX_START */
    /* CELL_STATE_W_FOR_CELL_STOP_BROADCAST_RESP */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_mif_failed_event,
        //rmcm_rrc_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        /*rmcm_mif_stop_adm_req,*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_failed_event,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_timer_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* CA_Stage3_Change: Start */
        /*RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT*/
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
       rrmcm_cm_cell_stop_broadcast_resp,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
        /** eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        ,rrmcm_queue_message 
#endif
    },
    /* BUG_11648_FIX_END */
#ifdef LTE_EMBMS_SUPPORTED 
        
    /* CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_MBMS */
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP_EVENT*/
        rmcm_rrc_reconfig_resp_for_mbms,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_rmif_cell_del_req,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        rmcm_mif_stop_adm_req,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_start_adm_req,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_register_req,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_deregister_req,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_set_attribute_req,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_timer_expired, 
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_rac_enable_diable_req,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_meas_config_req,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rrmcm_queue_message,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
       /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_periodic_resrc_update,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_self_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_nbr_rpt_tmr_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rrmcm_rrm_oam_chng_both_rpt_tmr_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_RIM_INFO_EVENT */
            rmcm_rim_info_resp,
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rrmcm_rrm_dynamic_icic_l1_l2_report_info_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rrmcm_rrm_es_periodic_resrc_update,
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
         rmcm_ignore_event,
        /* RRMCM_M2AP_SF_INFO_REQ_EVENT */
        rrmcm_queue_message 
/* SPR 22248 MBMS Changes Start */ 
    },
/* SPR 22248 MBMS Changes Stop */
#endif

       	/*spr 21625 fix start*/
	/*CELL_STATE_W_FOR_CELL_RECONFIG_RESP_DURING_CELL_BLOCK*/
    {
        /*RRMCM_RMIF_CELL_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_SETUP_RESP  */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_START_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_START_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_RECONFIG_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_RECONFIG_RESP*/
        rmcm_rrc_reconfig_resp,
        /*RRMCM_RMIF_CELL_STOP_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_STOP_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_UPDATE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_UPDATE_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_CELL_DELETE_REQ*/
        rmcm_mif_failed_event,
        /*RRC_RRM_CELL_DELETE_RESP*/
        rmcm_mif_failed_event,
        /*RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_STOP_ADMISSION_REQ*/
        /*rmcm_mif_stop_adm_req,*/
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_START_ADMISSION_REQ*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_REGISTER_REQ */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_CELL_SON_DEREGISTER_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_SON_CELL_SET_ATTR_REQ*/
        rmcm_mif_failed_event,
        /*CELL_PERIODIC_TIMER_EXPIRY*/
        rmcm_mif_failed_event,
        /*RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT*/
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_MEAS_CONFIG_REQ */
        rmcm_mif_failed_event,
        /*RRMCM_RMIF_UPDATED_NRT_INFO_EVENT*/
        rmcm_mif_updated_nrt_info,
        /* RRC_RRM_PWS_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_PWS_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_KILL_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT */
        rmcm_rrc_failed_event,
        /* RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT */
        rmcm_rrc_failed_event,
        /* MLB Changes start */
        /* RRM_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT */
        rmcm_ignore_event,
        /* RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT */
        rmcm_ignore_event,
        /* MLB Changes end */
        /* RRMCM_RMIF_TTT_UPDATE_IND_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_RIM_INFO_EVENT */
        rmcm_rrc_failed_event,
        /* RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT */
        rmcm_ignore_timer_event,
        /* RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT*/
        rmcm_ignore_event,
        /* RRM_UEM_OR_L2_RESPONSE_EVENT */
        rmcm_ignore_event,
        /* RRM_CELL_RECONFIG_FOR_ICIC_EVENT */
        rmcm_ignore_timer_event,
        /* RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT */
        rmcm_mif_failed_event,
        /* RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT */
        rmcm_mif_failed_event,
        /* RRM_ES_PERIODIC_RESRC_UPDATE_EVENT */
        rmcm_ignore_event,
        /* RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT */
        rmcm_mif_failed_event,
        /* RACH_OPTIMIZATION_CHANGES_START */
        /* RRMCM_RMIF_RACH_INFO_IND_EVENT */
        rmcm_mif_failed_event,
        /* CA_Stage3_Change: Start */
        /* RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT */
        rmcm_ignore_event,
        /* CA_Stage3_Change: End */
        /* BUG_11648_FIX_START */
        rmcm_ignore_event,
        /* RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT */
        /* BUG_11648_FIX_END */
        /* eICIC_PHASE_1_2_CHANGES_START */
        /* CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT */
        build_and_send_uem_get_aggressor_req,
        /* CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT */
        rrmcm_queue_message,
        /* CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT */
        rrmcm_queue_message,
        /* RRM_UEM_GET_AGGRESSOR_RESP_EVENT */
        rrm_uem_get_aggressor_resp_process_info,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /** eICIC_PHASE_1_2_CHANGES_START*/
        /*RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT*/
        rmcm_ignore_event
            /** eICIC_PHASE_1_2_CHANGES_END */
    }
   	/*spr 21625 fix end*/

};
/* UE MEAS CHANGES : ENDS */

/****************************************************************************
 * Function Name  : update_pucch_pusch_resources_on_reconfig
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function updates the PUCCH/PUSCH resources i.e
 *                  CQI/SR/SRS resources.
 ****************************************************************************/
rrm_void_t
update_pucch_pusch_resources_on_reconfig
(
 rrm_cell_context_t *p_cell_ctx,
 srs_t *p_srs_info_bfr_reconfig,
 pucch_t *p_cqi_sr_info_bfr_reconfig,
 /* +- SPR 18268 */
 U16 max_num_ue_per_cell_bfr_reconfig
 /* +- SPR 18268 */

)
{
   RRM_UT_TRACE_ENTER();
   rrm_srs_action_on_reconfig_et rrm_srs_action_on_reconfig = RRM_SRS_ACT_NO_CHANGE;

   /*
   ** Get the action to be performed on SRS res pool after reconfig.
   */
   /*SPR 21223 START*/ 
   rrm_srs_action_on_reconfig = rrm_get_srs_action_after_reconfig(p_cell_ctx,p_srs_info_bfr_reconfig,max_num_ue_per_cell_bfr_reconfig);
   /*SPR 21223 END*/ 
   
   /*
   ** Update SRS resource pool as per the new cell configuration
   */
   if(RRM_SRS_ACT_NO_CHANGE != rrm_srs_action_on_reconfig)
   {
       update_srs_config_res_on_reconfig(p_cell_ctx,rrm_srs_action_on_reconfig);

       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_BRIEF,"SRS resource pool is modified after reconfig !!");
   }
   else 
   {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_BRIEF,"NO change in SRS resource pool after reconfig!!");
   }

   /*
   ** Update CQI/SR resource pool as per the new cell configuration
   */
   update_cqi_sr_config_res_on_reconfig(p_cell_ctx , p_cqi_sr_info_bfr_reconfig ,
                                        max_num_ue_per_cell_bfr_reconfig);

   RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_get_srs_action_after_reconfig
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 *                  srs_t *p_srs_info_bfr_reconfig
 *                  U16    max_num_ue_per_cell_bfr_reconfig 
 * Outputs        : None
 * Returns        : RRM_SRS_ACT_NO_CHANGE: No change is required in SRS res pool
 *                  RRM_SRS_ACT_FREE_RES : Free the SRS res allocated at the
 *                  time of cell configuration.
 *                  RRM_SRS_ACT_ALLOC_RES : Allocate the new SRS res
 *                  as per the new config.
 *                  RRM_SRS_ACT_FREE_AND_ALLOC_RES : Free the SRS res 
 *                  allocated at the time of cell configuration and
 *                  Allocate the new SRS res as per the new config.
 * Description    : This function decides the action to be taken for the
 *                  SRS resources as per the new configuration.
 ****************************************************************************/
rrm_srs_action_on_reconfig_et
rrm_get_srs_action_after_reconfig
(
 rrm_cell_context_t *p_cell_ctx,
 srs_t *p_srs_info_bfr_reconfig,
 U16    max_num_ue_per_cell_bfr_reconfig
 )
 /*SPR 21223 END*/ 
{
  
   RRM_UT_TRACE_ENTER();
   rrm_srs_action_on_reconfig_et rrm_srs_action_on_reconfig = RRM_SRS_ACT_NO_CHANGE;

   /*
   ** If SRS was enabled at the time of Cell Configuration and SRS is Disabled
   ** at Cell Reconfiguration.
   ** -In this case free all the SRS resources allocated at the time of
   **  cell configuration.
   */
   if(
        ( ( RRM_PNULL != p_srs_info_bfr_reconfig ) && 
          ( p_cell_ctx->ran_info.physical_layer_params.bitmask 
            & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT ) &&
          ( p_srs_info_bfr_reconfig->srsEnabled && 
            !p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled )
        ) 
        ||
        ( ( RRM_PNULL != p_srs_info_bfr_reconfig &&
            p_srs_info_bfr_reconfig->srsEnabled )&& 
         !( p_cell_ctx->ran_info.physical_layer_params.bitmask 
            & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT )
        )
      )
      {
            rrm_srs_action_on_reconfig = RRM_SRS_ACT_FREE_RES; 
      }
    
   /*
   ** If SRS was disabled at the time of Cell Configuration and SRS is Enabled
   ** at Cell Reconfiguration.
   ** - In this case allocate SRS resources i.e. create the SRS resource pool
   */
   else if(
            ( ( RRM_PNULL != p_srs_info_bfr_reconfig ) && 
              ( p_cell_ctx->ran_info.physical_layer_params.bitmask 
                    & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT ) &&
              ( !p_srs_info_bfr_reconfig->srsEnabled && 
                   p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled )
            ) ||
            ( ( RRM_PNULL == p_srs_info_bfr_reconfig ) && 
              ( p_cell_ctx->ran_info.physical_layer_params.bitmask & 
                    RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT ) && 
              ( p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled )
            )
           )
       {
            rrm_srs_action_on_reconfig = RRM_SRS_ACT_ALLOC_RES;
       }
    else 
    {
        if( ( RRM_PNULL != p_srs_info_bfr_reconfig ) && 
                ( p_srs_info_bfr_reconfig->srsEnabled ) && 
                ( p_cell_ctx->ran_info.physical_layer_params.bitmask 
                  & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT ) &&
                ( p_cell_ctx->ran_info.physical_layer_params.
                  physical_layer_param_srs.srsEnabled )
          )
        {   
            /*
            ** If SRS BW configuration or SR SF configuratoin is changed at the time 
            ** of Cell Reconfiguration.
            ** - In this case free all the SRS resources allocated at the time of
            **   cell configuration , and again initilize the the SRS resources using the the new
            **   SRS BW/SRS SF configuration.
            */
            if( ( p_srs_info_bfr_reconfig->srs_bandwidth_config !=  
                        p_cell_ctx->ran_info.physical_layer_params.
                        physical_layer_param_srs.srs_bandwidth_config 
                )
                    || 
                    ( p_srs_info_bfr_reconfig->srs_subframe_config != 
                      p_cell_ctx->ran_info.physical_layer_params.
                      physical_layer_param_srs.srs_subframe_config
                    )
                    /*SPR 21223 START*/ 
                    ||
                    ( max_num_ue_per_cell_bfr_reconfig !=
                      p_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell  
                    )
                    /*SPR 21223 END*/ 

              )
            {
                rrm_srs_action_on_reconfig = RRM_SRS_ACT_FREE_AND_ALLOC_RES;
            }
        }
    }
   
   RRM_UT_TRACE_EXIT();
   return rrm_srs_action_on_reconfig;
}

/****************************************************************************
 * Function Name  : update_srs_config_res_on_reconfig
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 *                  rrm_srs_action_on_reconfig_et rrm_srs_action_on_reconfig
 * Outputs        : None
 * Returns        : None
 * Description    : This function allocates/deallocates the SRS resource pool 
 *                  as per the valu for rrm_srs_action_on_reconfig.
 ****************************************************************************/
rrm_void_t
update_srs_config_res_on_reconfig
(
 rrm_cell_context_t *p_cell_ctx,
 rrm_srs_action_on_reconfig_et rrm_srs_action_on_reconfig
)
{
   RRM_UT_TRACE_ENTER();

   switch(rrm_srs_action_on_reconfig)
   {
       case RRM_SRS_ACT_FREE_RES:
           {
               rrm_set_srs_resources_free(p_cell_ctx);
           }
           break;
       case RRM_SRS_ACT_ALLOC_RES:
           {
               rrm_cellm_cell_initialize_srs_res_list(p_cell_ctx);
           }
           break;
       case RRM_SRS_ACT_FREE_AND_ALLOC_RES:
           {
               rrm_set_srs_resources_free(p_cell_ctx);
               rrm_cellm_cell_initialize_srs_res_list(p_cell_ctx);
           }
           break;
           default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "wrong SRS action on reconfig is  received: [%d]",
                       rrm_srs_action_on_reconfig);
   }

   RRM_UT_TRACE_EXIT();
}

/* SPR_8597_FIX_START*/
rrm_void_t
find_n_one_pucch_an_for_sr
(
 /* SPR 11003 Fix Start */
 rrm_cell_context_t *p_cell_context,
  U16  configured_n1_pucch_an,
  U8   n_cs_an,
 U16   *p_n_one_pucch_an
)
{
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Calculating N1_PUUCH_AN for configured_n1_pucch_an[%u] and configured_n_cs_an[%u]",
            configured_n1_pucch_an, n_cs_an);

    /* This is index so adding 1 to get the total count */
    *p_n_one_pucch_an = configured_n1_pucch_an + RRM_ONE
        + 
        (n_cs_an *
         p_cell_context->ran_info.physical_layer_params.
         physical_layer_param_pucch.delta_pucch_shift + RRM_ONE);
        configured_n1_pucch_an = configured_n1_pucch_an + n_cs_an;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                "N_1_PUCCH_AN[%d] Configured. 3.Factor opt [%d]",
                configured_n1_pucch_an, *p_n_one_pucch_an);

    RRM_UT_TRACE_EXIT();

    /* SPR 11003 Fix End */
}
/* SPR_8597_FIX_END */
/****************************************************************************
 * Function Name  : update_cqi_sr_config_res_on_reconfig
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function re-initializes the CQI/SR resource pool 
 *                  as per the new configuration.
 ****************************************************************************/
rrm_void_t
update_cqi_sr_config_res_on_reconfig
(
 rrm_cell_context_t *p_cell_ctx,
 pucch_t *p_cqi_sr_info_bfr_reconfig,
 /* +- SPR 18268 */
 U16 max_num_ue_per_cell_bfr_reconfig
 /* +- SPR 18268 */
)
{
    RRM_UT_TRACE_ENTER();
    
    rrm_bool_t              update_cqi_info = RRM_FALSE ;
    rrm_bool_t              update_sr_info = RRM_FALSE ;
    U16                     alloc_cqi_ri_from_algo_val = RRM_ZERO;
    cqi_ri_map_info_per_ue  cqi_ri_table_map[MAX_PERIODICTY_CQI_N_P];
    /*SPR 17777 +-*/
    U16                     cqi_ri_index_count = RRM_ZERO;
    U16                     sr_idx = RRM_ZERO;
	/*SPR_8597_FIX_START */
    //U16                     sr_periodicity = RRM_ZERO;
	/*SPR_8597_FIX_END */
    /* SPR 11003 Fix Start */
    U16                     n_one_pucch_an = RRM_ZERO;
    U8                      n2_pucch_res_index_max_value = RRM_ZERO;
    /* SPR 11003 Fix End */
    /* BUG_11848_CHANGES_START */
    U8                      delta_pucch_shift_b4_rcnfg = RRM_ZERO;
    U8                      n_rb_cqi_b4_rcnfg = RRM_ZERO;
    /* BUG_11848_CHANGES_END */

    /*
    ** Decide whether CQI and SR resource pool re-initialization is required 
    ** or not
    */
    update_cqi_sr_res_decision(p_cell_ctx ,p_cqi_sr_info_bfr_reconfig , &update_cqi_info , 
                               &update_sr_info, max_num_ue_per_cell_bfr_reconfig);

    /* 
    ** If CQI resource pool re-initialization is required 
    ** Here , free the resources alloctaed at the time of the the cell configuration
    ** and again initialize the resource pool 
    */
    if(RRM_TRUE == update_cqi_info)
    {
        /* BUG_11848_CHANGES_START */
        /*MEMORY_PROFILING*/
        n_rb_cqi_b4_rcnfg = p_cqi_sr_info_bfr_reconfig->n_rb_cqi;
        delta_pucch_shift_b4_rcnfg = p_cqi_sr_info_bfr_reconfig->delta_pucch_shift;    
        /* OAM has configured the delta pucch values 0,1,2
           RRM needs to map the values to 1,2,3 delta_pucch_shift + 1 is required */
        n2_pucch_res_index_max_value = (N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB * n_rb_cqi_b4_rcnfg)/(delta_pucch_shift_b4_rcnfg + RRM_ONE);
        for(cqi_ri_index_count = RRM_ZERO; cqi_ri_index_count < n2_pucch_res_index_max_value;
                cqi_ri_index_count++)
        {
            if (RRM_PNULL != p_cell_ctx->cqi_ri_res[cqi_ri_index_count])
            {
               RRM_MEM_FREE(p_cell_ctx->cqi_ri_res[cqi_ri_index_count]);
            }
        }

        if (RRM_PNULL != p_cell_ctx->cqi_ri_res)
        {
            RRM_MEM_FREE(p_cell_ctx->cqi_ri_res);
        }
        /*MEMORY_PROFILING*/
        /* BUG_11848_CHANGES_END */

        rrm_cellm_cell_initialize_cqi_res_list(p_cell_ctx,
                cqi_ri_table_map, 
                &alloc_cqi_ri_from_algo_val);
    /*SPR 17777 +-*/

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF,"CQI resource pool is modified after reconfig !!");
    }   
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                  RRM_BRIEF,"NO change in CQI resource pool after reconfig!!");
    }

    /* 
    ** If SR resource pool re-initialization is required 
    ** Here , free the resources alloctaed at the time of the the cell configuration
    ** and again initialize the resource pool 
    */
    if(RRM_TRUE == update_sr_info)
    {
        /*MEMORY_PROFILING*/
        /* SPR_8597_FIX_START*/
	    //find_sr_periodicity_from_cell_context(p_cell_ctx, &sr_periodicity, &n_one_pucch_an);   
        /* SPR 11003 Fix Start */
        find_n_one_pucch_an_for_sr(p_cell_ctx, p_cqi_sr_info_bfr_reconfig->sr_n1_pucch_an_last_indx,
                                    p_cqi_sr_info_bfr_reconfig->n_cs_an, &n_one_pucch_an);
        /* SPR 11003 Fix End */
        /* SPR_8597_FIX_END*/
        /*SPR 23347 Fix Start*/
        if (RRM_PNULL != p_cell_ctx->sr_res)
        {
            /*SPR 23347 Fix End*/
            for(sr_idx = RRM_ZERO;
                    sr_idx < n_one_pucch_an;
                    sr_idx++)
            {
                /*SPR 23347 Fix Start*/
                if(p_cell_ctx->sr_res[sr_idx] != RRM_PNULL)
                {
                    /*SPR 23347 Fix End*/
                    RRM_MEM_FREE(p_cell_ctx->sr_res[sr_idx]);
                }
                /*SPR 23347 Fix Start*/
            }
        }
        if(RRM_PNULL != p_cell_ctx->sr_res)
            RRM_MEM_FREE(p_cell_ctx->sr_res);
        /*SPR 23347 Fix End*/
        /*MEMORY_PROFILING*/

        rrm_cellm_cell_initialize_sr_res_list(p_cell_ctx); 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF,"SR resource pool is modified after reconfig !!");
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                RRM_BRIEF,"NO change in SR resource pool after reconfig!!");
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : update_cqi_sr_res_decision
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : p_update_cqi_info , p_update_sr_info
 * Returns        : None
 * Description    : This function takes the decision whether CQI/SR resource pool
 *                  re-initialization is required or not . 
 ****************************************************************************/
rrm_void_t
update_cqi_sr_res_decision
(
 rrm_cell_context_t  *p_cell_ctx , 
 pucch_t *p_cqi_sr_info_bfr_reconfig,
 rrm_bool_t *p_update_cqi_info , 
 rrm_bool_t *p_update_sr_info,
 /* +- SPR 18268 */
 U16 max_num_ue_per_cell_bfr_reconfig
 /* +- SPR 18268 */
 )
{

    RRM_UT_TRACE_ENTER();

    if ( ( p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.
            delta_pucch_shift != p_cqi_sr_info_bfr_reconfig->delta_pucch_shift )
          ||
         ( p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.
           n_cs_an != p_cqi_sr_info_bfr_reconfig->n_cs_an )
          ||
         ( p_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell
           != max_num_ue_per_cell_bfr_reconfig)
       )
       {
            *p_update_cqi_info = RRM_TRUE;
            *p_update_sr_info = RRM_TRUE;
          
          RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                    "DELTA_SHIFT/N_CS_AN/MAX_UE_COUNT changed  by reconfig cli ");
       }
    else if( p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.
             n_rb_cqi != p_cqi_sr_info_bfr_reconfig->n_rb_cqi )
    {
        *p_update_cqi_info = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                "N_RB_CQI changed  by reconfig cli ");
    }
          
        /* SPR_8597_FIX_START*/
    else if( (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.
             n1_pucch_an != p_cqi_sr_info_bfr_reconfig->n1_pucch_an ) ||
             (p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pucch.
              sr_n1_pucch_an_last_indx !=  p_cqi_sr_info_bfr_reconfig->sr_n1_pucch_an_last_indx))
    {
        *p_update_sr_info = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                 "N1_PUCCH_AN changed eitehr by reconfig cli or by SPS enable/disable");
    }
        /* SPR_8597_FIX_END*/
    else
       {
            *p_update_cqi_info = RRM_FALSE;
            *p_update_sr_info = RRM_FALSE;
         
       }
    RRM_UT_TRACE_EXIT();
}
/* BUG_876_CHANGES_START*/
/*DYNAMIC ICIC START*/
/****************************************************************************
 * Function Name  : rrmcm_rrm_process_cell_reconfig_for_icic_tmr 
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : None
 * Description    : This function is callback for the expiry of the 
 *                  CELL_RECONFIG_TIMER_FOR_ICIC timer. On the basis of the 
 *                  few statistics , it will trigger the cell reconfig request
 *                  with incremented/decremented Refernce Signal Power
 ****************************************************************************/
rrm_return_et
rrmcm_rrm_process_cell_reconfig_for_icic_tmr
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    //RRM_UT_TRACE_ENTER();
    U8 ues_vd_max_p_a_in_cell_edge = RRM_ZERO;
    U16 num_ues_vd_max_p_a = RRM_ZERO;
    U16 num_ues_in_cell_edge =  RRM_ZERO;
    U16 num_ues_in_cell_centre =  RRM_ZERO;
    //rrc_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = RRM_PNULL;
    S16     new_reference_signal_power = RRM_ZERO;
    U8 ue_percentage_in_cell_edge = RRM_ZERO;
    S16    curr_ref_power_at_phy = RRM_ZERO;
    S16    min_ref_power_configurable_at_phy = 0;
    S16    result_min_ref_power_configurable_at_phy = 0;
    S16    max_ref_power_configurable_at_phy = 0xFF;
    S16    result_max_ref_power_configurable_at_phy = 0xFF;
    S16    start = 0;
    rrm_return_et     ret_val = RRM_SUCCESS;

    num_ues_vd_max_p_a = p_cell_ctx->dynamic_icic_data.num_ues_vd_max_p_a_val ;
    num_ues_in_cell_edge = p_cell_ctx->dynamic_icic_data.num_ues_in_cell_edge ;
    num_ues_in_cell_centre = p_cell_ctx->dynamic_icic_data.num_ues_in_cell_center;
    rrm_bool_et reconfig_cell_flag = RRM_FALSE;
    rrm_cellm_ref_sig_pwr_update_type_et update_type = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED;
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
              "UE Counts:- Max pA[%d], CE[%d], CC[%d]",
              num_ues_vd_max_p_a, num_ues_in_cell_edge, num_ues_in_cell_centre);

    /*
     ** Get the percentage of UE's ,out of the CE UE's , who have the p_a
     ** value equal to the max possible value of p_a.
     */
    if(num_ues_vd_max_p_a && num_ues_in_cell_edge && (num_ues_in_cell_edge >= num_ues_vd_max_p_a))
    {
       ues_vd_max_p_a_in_cell_edge = (num_ues_vd_max_p_a / num_ues_in_cell_edge) * 100 ;
    }

    if(num_ues_in_cell_edge)
    {
       ue_percentage_in_cell_edge = (num_ues_in_cell_edge / (num_ues_in_cell_edge + num_ues_in_cell_centre )) * 100; 
    }

    /*
     ** Criteria to reconfig the cell with high reference signal power:
     ** -> Num of UE's handout during OLPC have crossed the threshold value 
     **    specified by user.
     ** -> More the 50 % of UE's ,out of the CE UE's , who have the p_a 
     **    value equal to the max possible value of p_a.
     */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
              "UE Stats:- HO UEs[%d], Threshold[%d], pA CE UEs[%d]",
              p_cell_ctx->dynamic_icic_data.num_ues_handout_in_olpc,
              p_cell_ctx->rrm_olpc_config_params.ue_handover_count_threshold,
              ues_vd_max_p_a_in_cell_edge);
    if( (p_cell_ctx->dynamic_icic_data.num_ues_handout_in_olpc >
                p_cell_ctx->rrm_olpc_config_params.ue_handover_count_threshold) ||
            (ues_vd_max_p_a_in_cell_edge > THRESHOLD_PERCENT_FOR_UES_VD_MAX_P_A ))
    {
        p_cell_ctx->p_new_update_data =(rrm_void_t *)
            rrm_mem_get(sizeof(rrmcm_rmif_cell_update_req_t));
	/* Coverity 93963 Fix Start */
        if (RRM_PNULL == p_cell_ctx->p_new_update_data)
        {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Memory allocation to p_new_update_data failed" );
                return RRM_FAILURE;
        }
        /* Coverity 93963 Fix End */

        RRM_ASSERT(RRM_PNULL != (rrmcm_rmif_cell_update_req_t *)p_cell_ctx->p_new_update_data);
        RRM_ASSERT(RRM_PNULL != (rrmcm_rmif_cell_update_req_t *)p_cell_ctx->p_new_update_data);
        /*
         ** Increment the Refernce Signal power as per the step value.
         ** if (existing ref sig power + step value) is greater then MAX_REFERENCE_SIGNAL_POWER
         ** change the new ref sig power to MAX_REFERENCE_SIGNAL_POWER.
         ** if (existing ref sig power + step value) is lesser than MAX_REFERENCE_SIGNAL_POWER
         ** change the new ref sig power to existing ref sig power + step value.
         */
        for (start = MIN_REFERENCE_SIGNAL_POWER; start <= MAX_REFERENCE_SIGNAL_POWER; start++)
        {
            curr_ref_power_at_phy = -(p_cell_ctx->operator_info.cell_params.max_rs_epre) -
                                      4 * (start);
            if ((curr_ref_power_at_phy >= RRM_ZERO) && (curr_ref_power_at_phy < result_max_ref_power_configurable_at_phy))
            {
               result_max_ref_power_configurable_at_phy = curr_ref_power_at_phy;
               max_ref_power_configurable_at_phy = start;
            }

            if ((curr_ref_power_at_phy <= 0xFF) && (curr_ref_power_at_phy > result_min_ref_power_configurable_at_phy))
            {
               result_min_ref_power_configurable_at_phy = curr_ref_power_at_phy;
               min_ref_power_configurable_at_phy = start;
            }

        }
        curr_ref_power_at_phy = -(p_cell_ctx->operator_info.cell_params.max_rs_epre) -
                                4 * (p_cell_ctx->ran_info.rf_params.
                                rf_configurations.reference_signal_power);
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                  "1.Current Calculations at Phy = [%d], Map-> (Ref Sig Power:Output Power) Max([%d]:[%d]) AND Min([%d]:[%d])", 
                  curr_ref_power_at_phy, max_ref_power_configurable_at_phy, result_max_ref_power_configurable_at_phy,
                  min_ref_power_configurable_at_phy, result_min_ref_power_configurable_at_phy);
        if(max_ref_power_configurable_at_phy != p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power)
        {
            new_reference_signal_power = p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power +
                p_cell_ctx->dynamic_icic_data.pdsch_config_params.pdsch_common_config.ref_sig_powr_ramping_step;

            if(new_reference_signal_power > max_ref_power_configurable_at_phy)
            {
               new_reference_signal_power = max_ref_power_configurable_at_phy;
            }

            (( rrm_cellm_cell_reconfig_params_for_icic_t *)
             (p_cell_ctx->p_new_update_data))->refrence_signal_power = new_reference_signal_power;
            reconfig_cell_flag = RRM_TRUE;
            update_type = RRM_CELLM_REF_SIG_PWR_INCREMENTED;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                      "No Need to increase Reference Signal Power[%d] wrt EPRE[%d] for Dynamic ICIC "
                      "But it has reached the MAXIMUM[%d] possible calculated value at PHY", 
                      p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power,
                      p_cell_ctx->operator_info.cell_params.max_rs_epre,
                      curr_ref_power_at_phy);
        }
    }
    else if((ue_percentage_in_cell_edge >= 20) && (ue_percentage_in_cell_edge <= 20))
    {
        /* p_cell_ctx->p_new_update_data =(rrm_cellm_cell_reconfig_params_for_icic_t*)
           rrm_mem_get(sizeof(rrm_cellm_cell_reconfig_params_for_icic_t)); */
        p_cell_ctx->p_new_update_data =(rrmcm_rmif_cell_update_req_t *)
            rrm_mem_get(sizeof(rrmcm_rmif_cell_update_req_t));
	/* Coverity 93963 Fix Start */
	if (RRM_PNULL == p_cell_ctx->p_new_update_data)
        {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Memory allocation to p_new_update_data failed" );
                return RRM_FAILURE;
        }
	/* Coverity 93963 Fix End */
        RRM_ASSERT(RRM_PNULL != (rrmcm_rmif_cell_update_req_t *)p_cell_ctx->p_new_update_data);

        if( min_ref_power_configurable_at_phy !=  p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power)
        RRM_ASSERT(RRM_PNULL != (rrmcm_rmif_cell_update_req_t *)p_cell_ctx->p_new_update_data);

        if( min_ref_power_configurable_at_phy !=  p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power)
        {
            new_reference_signal_power = p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power -
                p_cell_ctx->dynamic_icic_data.pdsch_config_params.pdsch_common_config.ref_sig_powr_ramping_step;

            if( new_reference_signal_power < min_ref_power_configurable_at_phy)
            {
               new_reference_signal_power = min_ref_power_configurable_at_phy; 
            }

            (( rrm_cellm_cell_reconfig_params_for_icic_t *)(p_cell_ctx->p_new_update_data))->refrence_signal_power = 
                new_reference_signal_power;

            reconfig_cell_flag = RRM_TRUE;
            update_type = RRM_CELLM_REF_SIG_PWR_DECREMENTED;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                      "No Need to decrease Reference Signal Power[%d] wrt EPRE[%d] for Dynamic ICIC "
                      "But it has reached the MINIMUM[%d] possible value",
                      p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power,
                      p_cell_ctx->operator_info.cell_params.max_rs_epre,
                      curr_ref_power_at_phy);
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                  "Cell reconfig is not required for Dynamic ICIC");
    }

    if(RRM_TRUE == reconfig_cell_flag)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "For Reconfig Cell Need to Delete for Cell Index:%d",
                p_cell_ctx->cell_index);
   /*Cov_fix_63684*/
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
        if(RRM_SUCCESS == ret_val)
        {
            if(RRM_FAILURE == rrm_decision_cell_delete(p_cell_ctx))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        "ICIC Reconfig:cell delete failed for cell index:%d",
                        p_cell_ctx->cell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "ICIC Reconfig:cell deleted success for cell_index:%d",
                        p_cell_ctx->cell_index);
            p_cell_ctx->dynamic_icic_data.cell_reconfigured_for_icic = update_type;
        }
    }
        else
        {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "Memory allocation failed for TCB:Failed to allocate transaction id");
        ret_val = RRM_FAILURE ;
     }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*Cov_fix_63684*/
}

/* BUG_876_CHANGES_END*/

/*********************************************************************
 * Function Name  : rmcm_ignore_event
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles rmcm_rrc_failed_event in FSM
 *********************************************************************/
rrm_return_et
rmcm_ignore_timer_event
(
        rrm_cell_context_t *p_cell_ctx   /* cell context */
)
{
   RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
             "Ignore the event...Not recieved in valid state"
             "Unused variable p_cell_ctx=%p",p_cell_ctx);
    /*SPR 17777 +-*/

   RRM_UT_TRACE_EXIT();
   return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : commit_dynamic_icic_param
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : update the parameters reconfigured for dynamic icic in cell context
 ****************************************************************************/
rrm_void_t
commit_dynamic_icic_param
(
  rrm_cell_context_t *p_cell_ctx
)
{
    rrm_cellm_cell_reconfig_params_for_icic_t *p_reconfig_params_for_icic = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_reconfig_params_for_icic = (rrm_cellm_cell_reconfig_params_for_icic_t*)p_cell_ctx->p_new_update_data;
    RRM_ASSERT(RRM_PNULL != p_reconfig_params_for_icic);

    p_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power =
                              p_reconfig_params_for_icic->refrence_signal_power;

    RRM_MEM_FREE(p_cell_ctx->p_new_update_data);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : action_on_rntp_reports_from_serving_cell 
 * Inputs         : rrm_cell_context_t *p_cell_context
 *                  rrm_partitioning_info_action_type_et *p_action
 *                  U16                Pointer to new location of CE PRBs
 * Outputs        : None
 * Returns        : The numbers of PRBs foe new CE region 
 * Description    : This function performs action based on the OI reports
 *                  from the serving cell.
 ****************************************************************************/
U32 action_on_rntp_reports_from_serving_cell 
(
    rrm_cell_context_t  *p_rrm_cell_ctx,
    rrm_partitioning_info_action_type_et     *p_action,
    U32                                      *p_new_ce_start_prb
)
{
    U8                               *p_rntp_array = RRM_PNULL;
    U32                              start_rb = RRM_ZERO;
    U32                              num_of_rb = RRM_ZERO;
    U32                              counter = RRM_ZERO;
    U32                              intf_count = RRM_ZERO;
    U32                              final_num_rbs = RRM_ZERO;
    U32                              old_count_of_low_intf_prbs = RRM_ZERO;
    /*SPR 20613 CHANGES START*/
    U32                              start_of_region_wid_high_intf = RRM_OUT_OF_RANGE;
    U32                              end_of_region_wid_high_intf = RRM_OUT_OF_RANGE;
    /*SPR 20613 CHANGES END*/
    U32                              count_of_low_intf_prbs = RRM_ZERO;
    /*SPR 20613 CHANGES START*/
    /* Code deleted */
    rrm_bool_et                      is_first_prb_intf_not_present = RRM_FALSE;
    /*SPR 20613 CHANGES END*/
    rrm_bool_et                     is_high_intf_prb_present = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_rntp_array = &(p_rrm_cell_ctx->icic_l1_l2_report_info.relative_narrowband_tx_power.rntp_per_prb[RRM_ZERO]);
    RRM_ASSERT(RRM_PNULL != p_rntp_array);
    /* SPR 20613 CHANGES START */
    /* Code Deleted */
    /* SPR 20613 CHANGES END */
    start_rb = p_rrm_cell_ctx->operator_info.dynamic_icic_info.
               dl_resource_partition_info.cell_edge_region.start_rb; 

    num_of_rb = p_rrm_cell_ctx->operator_info.dynamic_icic_info.
                dl_resource_partition_info.cell_edge_region.num_of_rb; 
    /*SPR 20613 CHANGES START*/
    start_of_region_wid_high_intf = start_rb;
    end_of_region_wid_high_intf = start_rb;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
              "Presently Configured DL CE PARTITION Start RB:[%d], Num of RB[%d]", 
              start_rb, num_of_rb);
    /* This condition will check for the interference sensitivity of "0" at the very first
     * index of rntp_array. If interference is present at the very first index of rntp_array
     * set the flag is_first_prb_intf_not_present */
    if (RRM_ZERO == p_rntp_array[RRM_ZERO])
    {
        is_first_prb_intf_not_present = RRM_TRUE;
    }
    /*SPR 20613 CHANGES END*/

    for (counter = start_rb; counter < start_rb + num_of_rb; counter++)
    {
        /* 
           This condition will check for the interference senstivity of "0"
           on the CE PRBs and increment the counter of those PRBs.
        */
        if(RRM_ZERO == p_rntp_array[counter])
        {
           count_of_low_intf_prbs++;
           is_high_intf_prb_present = RRM_FALSE;
        }
        else
        {
            if (RRM_FALSE == is_high_intf_prb_present)
            {
               /*SPR 20613 CHANGES START*/
                /* set the value of start_of_region_wid_high_intf to the very 
                 * first index of rntp_array in which interference is present. */
               if ((start_of_region_wid_high_intf == start_rb) && ( RRM_TRUE == is_first_prb_intf_not_present))
               {
                   old_count_of_low_intf_prbs = count_of_low_intf_prbs;
                   is_high_intf_prb_present = RRM_TRUE;
                   start_of_region_wid_high_intf = counter;
    /*SPR 20613 CHANGES +-*/
               }
            }
            end_of_region_wid_high_intf = counter;
            intf_count++;
    /*SPR 20613 CHANGES END*/
        }
    }

    /*SPR 20613 CHANGES START*/
    *p_new_ce_start_prb = start_rb;
    *p_action = RRM_DL_PARTITION_NO_CHANGE;
    final_num_rbs = RRM_ZERO; 

    /* If PRB count on which interference is present is less than four then set CE region to atleast 4 RB's*/
    if((end_of_region_wid_high_intf + RRM_ONE - start_of_region_wid_high_intf)< RRM_FOUR )
    {
        if((start_rb == end_of_region_wid_high_intf) || 
            (end_of_region_wid_high_intf == (start_rb + RRM_ONE)) || (end_of_region_wid_high_intf == (start_rb + RRM_TWO)))
        {
            start_of_region_wid_high_intf = start_rb;
            end_of_region_wid_high_intf = start_of_region_wid_high_intf + RRM_FOUR;
        }
        else
        {
            start_of_region_wid_high_intf = end_of_region_wid_high_intf - RRM_FOUR;  
        }
    }

    if (RRM_FOUR > intf_count)
    {
        intf_count = RRM_FOUR;
    }


    /*SPR 20613 CHANGES END*/

    /* 
       If this condition is true then it simply means that we have 
       consecutive HIgh interference PRB's and the High inbterference
       region is upto the configured end Rb for CE region
    */
    if (RRM_TRUE == is_high_intf_prb_present) 
    {
    /*SPR 20613 CHANGES START*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "ALL INTEFERENCE RB's ARE COUNTINUOUS");
    /*SPR 20613 CHANGES END*/
        if((old_count_of_low_intf_prbs == count_of_low_intf_prbs) &&
           (RRM_ZERO != count_of_low_intf_prbs))
        {
           *p_new_ce_start_prb = start_of_region_wid_high_intf;
           final_num_rbs = intf_count; 
           *p_action = RRM_DL_PARTITION_CONTRACT;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "A. Estimated DL CE PARTITION CONTRACTED to RB:[%d], Count of PRBs used by serving in future[%d]", 
                     (num_of_rb - intf_count), intf_count);
        }
    /*SPR 20613 CHANGES START*/
        else if((old_count_of_low_intf_prbs == count_of_low_intf_prbs) && (RRM_ZERO == count_of_low_intf_prbs))
        {
            *p_new_ce_start_prb = start_of_region_wid_high_intf;
            final_num_rbs = intf_count;
            *p_action = RRM_DL_PARTITION_NO_CHANGE ;
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Estimated DL CE PARTITION UNCHANGED to RB:[%d], Count of PRBs used by serving in future[%d]", 
                     (num_of_rb - intf_count), intf_count);
           }
        /* Code Deleted */
    /*SPR 20613 CHANGES END*/
        }
    /* In this case interference observed region is not continuous
     * meaning that in Cell edge region we have some Rb's with interference and then some Rb's with no interference
    */
    /*SPR 20613 CHANGES START*/
    else if (RRM_FALSE == is_high_intf_prb_present) 
    /*SPR 20613 CHANGES END*/
    {
        /* This condition will hit when the the consecutive high interference
         * region is squeezed in between low interference region
         */
        *p_new_ce_start_prb = start_of_region_wid_high_intf;
        /*SPR 20613 CHANGES START*/
        final_num_rbs = end_of_region_wid_high_intf - start_of_region_wid_high_intf ; 
        if((start_of_region_wid_high_intf == start_rb) && ((end_of_region_wid_high_intf - start_of_region_wid_high_intf)== num_of_rb ))
        {
            *p_action = RRM_DL_PARTITION_NO_CHANGE;
        }
        else
        {
          *p_action = RRM_DL_PARTITION_CONTRACT;
        }
        /*SPR 20613 CHANGES END*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "C. Estimated DL CE PARTITION CONTRACTED to RB:[%d], Count of PRBs used by serving in future[%d]", 
                 (num_of_rb - intf_count), intf_count);
    }

    RRM_UT_TRACE_EXIT();
    return final_num_rbs;
}


/*klock_works_changes_start*/
/****************************************************************************
 * Function Name  : check_interference_level_on_cc_prbs
 * Inputs         : rrm_cell_context_t *p_cell_context
 *                  rrm_bool_et        *p_change_ue_categorization
 *                  rrm_resource_partition_info_t  *p_ul_resource_partition_info
 * Outputs        : None
 * Returns        : The percentage of UEs whose location needs to be
 *                  reconfigured from CC to CE.
 * Description    : This function performs action based on the OI reports
 *                  from the serving cell.
 ****************************************************************************/

U8
check_interference_level_on_cc_prbs
(
 rrm_cell_context_t                 *p_cell_context,
 rrm_resource_partition_info_t      *p_ul_resource_partition_info,
 rrm_bool_et                        *p_change_ue_categorization
 )
{
    U32   count                    = RRM_ZERO;
    U32   intf_count               = RRM_ZERO;
    U32   ul_cc_intf_percentage    = RRM_ZERO;
    U32                   cc_region_counter = RRM_ZERO;
    U32                   cc_start_rb_for_ul_self = RRM_ZERO;
    U32                   num_cc_prb_for_ul_self = RRM_ZERO;
    U32                   total_cc_prb_for_ul_self = RRM_ZERO;

    /*Kloc fix 706 */
    RRM_ASSERT(RRM_PNULL != p_cell_context);
    RRM_UT_TRACE_ENTER();


    intf_count = RRM_ZERO;
    for (cc_region_counter = RRM_ZERO; cc_region_counter < 
          p_ul_resource_partition_info->num_of_cell_center_region; cc_region_counter++)
    {
        cc_start_rb_for_ul_self = 
            p_ul_resource_partition_info->cell_center_region[cc_region_counter].start_rb;
        num_cc_prb_for_ul_self =  p_ul_resource_partition_info->cell_center_region[cc_region_counter].num_of_rb;
        total_cc_prb_for_ul_self += num_cc_prb_for_ul_self;
        for (count = cc_start_rb_for_ul_self; count < cc_start_rb_for_ul_self + 
                num_cc_prb_for_ul_self; count++)
        {
            if(RRM_OI_LOW_INTERFERENCE == p_cell_context->icic_l1_l2_report_info.ul_intf_overload_ind.
                    ul_intf_overload_indication[count])
            {
                intf_count++;
            }
        }
    }

    /* divide by zero exception : coverity : CID 41383 */
    if( RRM_ZERO != total_cc_prb_for_ul_self )
        ul_cc_intf_percentage = (((float)(total_cc_prb_for_ul_self - intf_count) / (float)total_cc_prb_for_ul_self)) * 100;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
              "Impacted CC PRBs percentage of serving cell [%d].", 
              ul_cc_intf_percentage);
    if (RRM_ZERO != ul_cc_intf_percentage)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "Reconfigure Location of [%d] percent of UEs from CC to CE...", 
                ul_cc_intf_percentage);
        *p_change_ue_categorization = RRM_TRUE;
    }
    /*Kloc fix */

    RRM_UT_TRACE_EXIT();
    return ul_cc_intf_percentage;

}

/*klock_works_changes_end*/



/****************************************************************************
 * Function Name  : action_on_oi_reports_from_serving_cell 
 * Inputs         : rrm_cell_context_t *p_cell_context
 *                  rrm_bool_et        *p_change_ue_categorization
 * Outputs        : None
 * Returns        : The percentage of UEs whose location needs to be 
 *                  reconfigured from CC to CE.
 * Description    : This function performs action based on the OI reports
 *                  from the serving cell.
 ****************************************************************************/
U8 action_on_oi_reports_from_serving_cell 
(
    rrm_cell_context_t  *p_cell_context,
    rrm_bool_et         *p_change_ue_categorization
)
{
    U32                   count = RRM_ZERO;
    U32                   ce_start_rb_for_ul_self = RRM_ZERO;
    U32                   total_ce_prb_for_ul_self = RRM_ZERO;
    U32                   intf_count = RRM_ZERO;
    U32                   ul_ce_intf_percentage = RRM_ZERO;
    U32                   ul_cc_intf_percentage = RRM_ZERO;
    rrm_resource_partition_info_t      *p_ul_resource_partition_info = RRM_PNULL;

    /*Kloc fix 706 */
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_context);
    RRM_ASSERT(RRM_PNULL != p_change_ue_categorization);

    *p_change_ue_categorization = RRM_FALSE;

    /* No need to check for bitmask as it is already validated in caller */
    if ((p_cell_context->operator_info.bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT) &&
            (p_cell_context->operator_info.dynamic_icic_info.bitmask & 
             RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT))
    {
        /* Klocwork_fix_27_aug_start */
        p_ul_resource_partition_info =
            &(p_cell_context->operator_info.dynamic_icic_info.ul_resource_partition_info);
        RRM_ASSERT(RRM_PNULL != p_ul_resource_partition_info);
        if (RRM_ZERO != p_ul_resource_partition_info->num_of_cell_edge_region)
        {
            ce_start_rb_for_ul_self = p_ul_resource_partition_info->cell_edge_region.start_rb;
            total_ce_prb_for_ul_self = p_ul_resource_partition_info->cell_edge_region.num_of_rb;
            /* This loop will check for the intereference senstivity on CE PRBs 
               configured in serving cell. In case any interference is observed on 
               these PRBs then serving will not take any action for this. It is 
               assumed that this situation might arise because of incorrrect
               partitioning info configured for neighbouring cells and same PRBs
               are used in CE by neigbouring cell. Below processing will only
               log the %age of the CE PRBs impacted.
             */
            for (count = ce_start_rb_for_ul_self; count < ce_start_rb_for_ul_self + 
                    total_ce_prb_for_ul_self; count++)
            {
                if(RRM_OI_LOW_INTERFERENCE == p_cell_context->icic_l1_l2_report_info.ul_intf_overload_ind.
                        ul_intf_overload_indication[count])
                {
                    intf_count++;
                }
            }
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "Total CE PRB[%d], Low Intf PRB Count on CE[%d]",total_ce_prb_for_ul_self, intf_count);
        /* divide by zero exception : coverity : 41382 */
        if( RRM_ZERO != total_ce_prb_for_ul_self ) 
            ul_ce_intf_percentage = (((float)(total_ce_prb_for_ul_self - intf_count) / (float )total_ce_prb_for_ul_self)) * 100;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "Impacted CE PRBs percentage of serving cell [%d]. Do nothing...", 
                ul_ce_intf_percentage);

        /* This block will check for the interference level on the CC PRBS. RRM will calculate
           the %age of interference observed with respect to the total number of CC PRBs.
           This results will lead to the fact that some of the CC UEs are facing interference
           because of CE UEs in neighbouring cell. This also leads to a problem that
           some of the CE UEs are wrongly marked as CC UEs in serving cell. If thses CC UEs
           moved to CE partion then interference can be mitigated.
         */

        }
        /*klock_works_changes_start*/
        ul_cc_intf_percentage = check_interference_level_on_cc_prbs(p_cell_context, p_ul_resource_partition_info, p_change_ue_categorization);
    }
    /* Klocwork_fix_27_aug_end */
    /*klock_works_changes_end*/


    RRM_UT_TRACE_EXIT();
    return ul_cc_intf_percentage;
}


/****************************************************************************
 * Function Name  : predict_hii_map_based_on_ul_ce_prb_usage 
 * Inputs         : rrm_oam_cell_plmn_info_t *p_rrm_plmn_id
 *                : x2ap_plmn_identity_t     *p_enb_plmn_id
 * Outputs        : None
 * Returns        : The number of CE PRBS estimated for future use.
 * Description    : This function predicts the number of CE PRBs based on the
 *                  sampling done from the data reported from L2 and the pattern
 *                  followed by looking at the delta of previous CE PRBs usage.
 ****************************************************************************/
S8 predict_hii_map_based_on_ul_ce_prb_usage
(
    rrm_cell_context_t  *p_cell_context,
    rrm_partitioning_info_action_type_et     *p_action
)
{
    U8               num_stored_ce_samples = RRM_ZERO;
    U8               index = RRM_ZERO;
    U8               count = RRM_ZERO;
    U8               ce_region_start_to_left_of_zero = RRM_ZERO;
    U8               ce_region_start_from_zero = RRM_ZERO;
    S32              ul_ce_prb_usage_circular_buf[MAX_NUM_OF_CE_PRB_SAMPLES] = {RRM_ZERO};
    U16              increase_percentage[MAX_NUM_OF_CE_PRB_SAMPLES - RRM_ONE] = {RRM_ZERO};
    U16              decrease_percentage[MAX_NUM_OF_CE_PRB_SAMPLES - RRM_ONE] = {RRM_ZERO};
    S8               delta_ce_prb_usage = RRM_ZERO;
    U8               increase_in_ce_prbs = RRM_ZERO;
    U8               decrease_in_ce_prbs = RRM_ZERO;
    U16              total_increased_ce_percentage = RRM_ZERO;
    U16              total_decreased_ce_percentage = RRM_ZERO;
    S8               final_num_rbs = RRM_ZERO;
    U32              last_reported_prb_usage = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    num_stored_ce_samples = p_cell_context->icic_l1_l2_report_info.num_ce_samples;
    ce_region_start_from_zero = RRM_ZERO;

    ce_region_start_to_left_of_zero = num_stored_ce_samples;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Num of stored CE samples:[%d]",
            num_stored_ce_samples);
    for (count = ce_region_start_to_left_of_zero; count < MAX_NUM_OF_CE_PRB_SAMPLES; count++)
    {
        ul_ce_prb_usage_circular_buf[index] = 
               p_cell_context->icic_l1_l2_report_info.ul_ce_prb_usage_array[count];
        index++;
    }
    for (count = ce_region_start_from_zero; count < num_stored_ce_samples; count++)
    {
        ul_ce_prb_usage_circular_buf[index] = 
               p_cell_context->icic_l1_l2_report_info.ul_ce_prb_usage_array[count];
        index++;
    }

    /* Checking for the pattern in case of stored values for the number of
     * samples and check if the required PRB usage is expected to increase or
     * decrease.
     */
    for (count = RRM_ZERO; count < (MAX_NUM_OF_CE_PRB_SAMPLES - RRM_ONE); count++)
    {
        delta_ce_prb_usage = ul_ce_prb_usage_circular_buf[count+RRM_ONE] - 
                             ul_ce_prb_usage_circular_buf[count];
        if (delta_ce_prb_usage > RRM_ZERO)
        {
            increase_percentage[increase_in_ce_prbs] = ((float)delta_ce_prb_usage /
                                   (float)p_cell_context->operator_info.dynamic_icic_info.
                                   original_configured_ul_resource_partition_info.cell_edge_region.num_of_rb) * RRM_PERCENTAGE;
            total_increased_ce_percentage += increase_percentage[increase_in_ce_prbs];
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
             "Increase: CE Usage sampling percentage bw two consecutive reports stored at index[%d] = [%d]percent, Diff in PRBs =[%d]", 
             increase_in_ce_prbs, increase_percentage[increase_in_ce_prbs],
             delta_ce_prb_usage);
            increase_in_ce_prbs++;
        }
        else
        if (delta_ce_prb_usage < RRM_ZERO)
        {
            delta_ce_prb_usage = ul_ce_prb_usage_circular_buf[count] - 
                ul_ce_prb_usage_circular_buf[count + RRM_ONE];
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
             "Decrease: Dip in PRBs Usage = [%d]", delta_ce_prb_usage);
            decrease_percentage[decrease_in_ce_prbs] = ((float)delta_ce_prb_usage /
                                   (float)p_cell_context->operator_info.dynamic_icic_info.
                                   original_configured_ul_resource_partition_info.cell_edge_region.num_of_rb) * RRM_PERCENTAGE;
            total_decreased_ce_percentage += decrease_percentage[decrease_in_ce_prbs];
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
             "Decrease: CE Usage sampling percentage bw two consecutive reports stored at index[%d] = [%d]percent", 
             decrease_in_ce_prbs, decrease_percentage[decrease_in_ce_prbs]);
             decrease_in_ce_prbs++;
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Presently Configured CE PRBS: [%d], Originally Configured UL CE PRBs: [%d]",
            p_cell_context->operator_info.dynamic_icic_info.
            ul_resource_partition_info.cell_edge_region.num_of_rb,
            p_cell_context->operator_info.dynamic_icic_info.
             original_configured_ul_resource_partition_info.cell_edge_region.num_of_rb);
    if ((RRM_ZERO == total_increased_ce_percentage) && 
        (RRM_ZERO == total_decreased_ce_percentage))
    {
       final_num_rbs = MIN_PRBS_LEFT_FOR_NEW_CE_UES;
       *p_action = RRM_UL_PARTITION_CONTRACT;
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "No CE UE, Final num of PRBs for UL CE region:[%d]", final_num_rbs);
    }
    else if (total_increased_ce_percentage > total_decreased_ce_percentage)
    {
        last_reported_prb_usage = ul_ce_prb_usage_circular_buf[MAX_NUM_OF_CE_PRB_SAMPLES - RRM_ONE];
        /* Averaging down the increased amount of CE PRBs by averaging the %age calculate above */
        final_num_rbs = (float)(((float)total_increased_ce_percentage / (float)increase_in_ce_prbs) *
                          p_cell_context->operator_info.dynamic_icic_info.
                          original_configured_ul_resource_partition_info.cell_edge_region.num_of_rb) / (float)RRM_PERCENTAGE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                          "RB:[%d], Increase[%d], PRBS mandate for cell[%d]", 
                         final_num_rbs, increase_in_ce_prbs, last_reported_prb_usage);
        final_num_rbs += last_reported_prb_usage;
        if(final_num_rbs != RRM_ZERO) 
        {
            /* Check the number of predicted RBs with the original configuration
             * from OAM. In case, the required PRBS is greater than the configured
             * value then RRM will go with the max configured value from OAM.
             */
            if(final_num_rbs >= 
                    (S32)(p_cell_context->operator_info.dynamic_icic_info.
                        original_configured_ul_resource_partition_info.
                        cell_edge_region.num_of_rb))
            {
                *p_action = RRM_UL_PARTITION_EXPAND;
                final_num_rbs = p_cell_context->operator_info.dynamic_icic_info.
                    original_configured_ul_resource_partition_info.
                    cell_edge_region.num_of_rb;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                          "PARTITION EXPANDED to ORIG RB:[%d]", final_num_rbs);
            }
            /* Check the number of predicted RBs with the currently ongoing  configuration
             * In case, the required PRBS is greater than the dynamically configured
             * value then RRM will go with the value which is within the range
             * of configured partition from OAM. So, expanding the partition at run time.
             */
            else 
            {
                if( final_num_rbs > (S32)(p_cell_context->operator_info.dynamic_icic_info.
                            ul_resource_partition_info.cell_edge_region.num_of_rb))
                {
                    *p_action = RRM_UL_PARTITION_EXPAND;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                            "PARTITION EXPANDED to RB:[%d] Operator Configured Num of RB %d",
                            final_num_rbs,
                            p_cell_context->operator_info.dynamic_icic_info.ul_resource_partition_info.cell_edge_region.num_of_rb);
                }
                else
                    if( final_num_rbs < (S32)(p_cell_context->operator_info.dynamic_icic_info.
                                ul_resource_partition_info.cell_edge_region.num_of_rb))
                    {
                        *p_action = RRM_UL_PARTITION_CONTRACT;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                                "PARTITION CONTRACTED to RB %d Operator Configured Num of RB %d",
                                final_num_rbs, p_cell_context->operator_info.dynamic_icic_info.
                                ul_resource_partition_info.cell_edge_region.num_of_rb);
                    }
                if ((final_num_rbs > RRM_ZERO) && (final_num_rbs < MIN_PRBS_LEFT_FOR_NEW_CE_UES))
                {
                    final_num_rbs = MIN_PRBS_LEFT_FOR_NEW_CE_UES; 
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                            "New RB:[%d]", final_num_rbs);
                }
            }
        }
        else
        {
             *p_action = RRM_UL_PARTITION_NO_CHANGE;
             final_num_rbs = RRM_ZERO; 
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                          "NO CHANGE in PARTITION for RB:[%d]", final_num_rbs);
        }
    }
    else
    if (total_increased_ce_percentage < total_decreased_ce_percentage)
    {
        final_num_rbs = (float)(((float)total_decreased_ce_percentage / (float)decrease_in_ce_prbs) *
                          p_cell_context->operator_info.dynamic_icic_info.
                          original_configured_ul_resource_partition_info.cell_edge_region.num_of_rb) / (float)RRM_PERCENTAGE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "final_num_rbs:[%d]", final_num_rbs);
        if(final_num_rbs != RRM_ZERO) 
        {
            final_num_rbs = p_cell_context->operator_info.dynamic_icic_info.
                            ul_resource_partition_info.cell_edge_region.num_of_rb
                            -
                            final_num_rbs;
            if (final_num_rbs < MIN_PRBS_LEFT_FOR_NEW_CE_UES)
            {
                final_num_rbs = RRM_ZERO;
                *p_action = RRM_UL_PARTITION_NO_CHANGE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                          "DEC THROUGHPUT: PARTITION NO CHANGE: [%d]", final_num_rbs);
            }
            else
            {
                *p_action = RRM_UL_PARTITION_CONTRACT;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                          "DEC THROUGHPUT: PARTITION CONTRACTED to UL CE RB: [%d]", final_num_rbs);
            }
        }
        else
        {
             *p_action = RRM_UL_PARTITION_NO_CHANGE;
             final_num_rbs = RRM_ZERO; 
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                          "DEC THROUGHPUT: NO CHANGE IN PARTITION");
        }
    }
    else
    {
         *p_action = RRM_UL_PARTITION_NO_CHANGE;
         final_num_rbs = RRM_ZERO; 
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                          "NO CHANGE IN PARTITION");
    }
    
   if( final_num_rbs == (S32)(p_cell_context->operator_info.dynamic_icic_info.
            ul_resource_partition_info.cell_edge_region.num_of_rb))
   {
	   *p_action = RRM_UL_PARTITION_NO_CHANGE;
	   final_num_rbs = RRM_ZERO; 
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			   "1.NO CHANGE IN PARTITION");
   }
  

    RRM_UT_TRACE_EXIT();

    return final_num_rbs;
}
/****************************************************************************
 * Function Name  : mandate_search_for_region_to_left_or_right_of_cnfg_partition 
 * Inputs         :  U8      Configured Start Indx of CE Region
 *                   U8      Configured number of PRBs for CE Region
                     U8      extra PRBs required by peer
                     U8      New Start Value
                     U8      Total PRBs in cell
 * Outputs        : None
 * Returns        : None.
 * Description    : This function esrtition the number of CE PRBs
 ****************************************************************************/
rrm_void_t mandate_search_for_region_to_left_or_right_of_cnfg_partition 
(
    U32                      current_ce_prb_start_index,
    U32                      current_ce_prb_count,
    U32                      serving_cell_prb_to_modify,
    U32                      *p_new_start_rb,
    U32                      prb_configured_in_srv_cell
)
{
    RRM_UT_TRACE_ENTER();

    if (RRM_ZERO == current_ce_prb_start_index)
    {
       *p_new_start_rb = RRM_ZERO;
    }
    else
    {
        /* This will give PRBs to the left of CE start */
        if ((S32)(current_ce_prb_start_index - serving_cell_prb_to_modify) >= RRM_ZERO)
        {
            *p_new_start_rb = current_ce_prb_start_index - serving_cell_prb_to_modify;
        }
        /* This will give PRBs to the left of CE start and in this case CE partition is at the end */
        else if ((current_ce_prb_start_index + current_ce_prb_count) == 
                 (prb_configured_in_srv_cell) && 
                 (S32)(current_ce_prb_start_index - serving_cell_prb_to_modify) >= RRM_ZERO)
        {
            *p_new_start_rb = current_ce_prb_start_index - serving_cell_prb_to_modify;
        }
        /* This will give PRBs to the right of CE start */
        else if ((current_ce_prb_start_index + current_ce_prb_count + serving_cell_prb_to_modify) <= 
                 (prb_configured_in_srv_cell - RRM_ONE))
        {
            *p_new_start_rb = current_ce_prb_start_index;
        }
        /* This will give some PRBs to left and some to right of CE partition */
        else if ((S32)(current_ce_prb_start_index - serving_cell_prb_to_modify) < RRM_ZERO)
        {
            *p_new_start_rb = RRM_ZERO;
        }
        else
        {
            /* Do Nothing */
        }
    }

    RRM_UT_TRACE_EXIT();
}


/*DYNAMIC ICIC END*/
/*spr 9631 fix start */
/****************************************************************************
 * Function Name  : rmcm_mif_reconfig_resp_during_cell_stop
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles reconfig resp in FSM when cell was stop
 ****************************************************************************/
rrm_return_et 
rmcm_mif_reconfig_resp_during_cell_stop(rrm_cell_context_t *p_cell_ctx /* cell context */)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp = RRM_PNULL;
    U8 max_num_ue_per_cell_bfr_reconfig = RRM_ZERO;
    srs_t *p_srs_info_bfr_reconfig = RRM_PNULL;
    pucch_t *p_cqi_sr_info_bfr_reconfig = RRM_PNULL;
    U16 meas_resp_api_id = RRM_ZERO;
    rrm_error_et fail_cause = RRM_NO_ERROR; /* Coverity_ID: 55833 */

    RRM_UT_TRACE_ENTER();

    p_rrc_rrm_cell_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)
	p_cell_ctx->p_incoming_api_info;

    if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
    {
	if(RRM_FALSE == p_cell_ctx->p_meas_config_sib_info_for_reconfig->req_for_obj_remove)
	{
	    meas_resp_api_id = RRMCM_RMIF_MEAS_CONFIG_RESP;
	}
	else
	{
	    meas_resp_api_id = RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_RESP;
	}
    }

    if (RRM_FAILURE == p_rrc_rrm_cell_reconfig_resp->response)
    {
	/*need to chk fail cause*/
	switch(p_rrc_rrm_cell_reconfig_resp->fail_cause)
	{
	    case RRM_RRC_LL_CONFIG_FAILURE:
	    case RRM_RRC_INTERNAL_FAILURE:
		/* Fix 8219 Start */
	    case RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE:
		/* Fix 8219 End */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_BRIEF,"Fail Cause of RRC:%d for cell Index:%d",
			p_rrc_rrm_cell_reconfig_resp->fail_cause,
			p_cell_ctx->cell_index);
		if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
		{
		    /* send meas config response with failure cause */
		    rmcm_mif_meas_config_resp(p_cell_ctx, p_rrc_rrm_cell_reconfig_resp->response,
			    RRM_ERR_RRC_FAILURE, meas_resp_api_id);  
		    ret_val = RRM_FAILURE;
		}
		else
		{
		    ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
		}

		if(!(p_cell_ctx->scheduled_etws_warning_list.count)&&
			!(p_cell_ctx->scheduled_cmas_warning_list.count))
		{
		    if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
		    {
			/*Handling of cases where the cell was stopped explicitly previosly */
			CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_INACTIVE);
			CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_INACTIVE);
		    }
		    else
		    {
			/*Case where the cell was not started */
			CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
		    }
		}
		else
		{

		    CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_PWS_ONGOING);
		}
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_BRIEF,"Reconfig Fail Cell State Is:%s For Cell Index:%d",
			CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
		break;

	    case RRM_RRC_UNKNOWN_FAILURE:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_BRIEF,"Fail Cause of RRC:%d for cell Index:%d",
			p_rrc_rrm_cell_reconfig_resp->fail_cause,
			p_cell_ctx->cell_index);

		if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
		{
		    /* send meas config response with failure cause */
		    rmcm_mif_meas_config_resp(p_cell_ctx, p_rrc_rrm_cell_reconfig_resp->response,
			    RRM_ERR_RRC_FAILURE, meas_resp_api_id);  
		    ret_val = RRM_FAILURE;
		}
		else
		{
		    ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
		}
		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_DEL);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_BRIEF,"Reconfig Fail Cell State Is:%s For Cell Index:%d",
			CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);
		break;

	    default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			"unknown failure for reconfig from RRC:%d",
			p_rrc_rrm_cell_reconfig_resp->fail_cause);
		ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);
		/*Default  case the state changed to cell delete waiting */
		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_DEL);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_BRIEF,"Reconfig Fail Cell State Is:%s For Cell Index:%d",
			CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);

	}
	ret_val = RRM_FAILURE;
    }
    else
    {
	/* Reconfig Resp recvd corresponding to the req triggered by Meas Config */
	if (p_cell_ctx->p_meas_config_sib_info_for_reconfig)
	{
	    /*Reconfig Crash for Meas Config: Fix Start*/
	    commit_reconfig_param(p_cell_ctx); 
	    /*Reconfig Crash for Meas Config: Fix End*/

	    /* send meas config response with success */
	    /* Coverity_ID : 56236, 55833 */
	    fail_cause = fail_cause_mapping(p_rrc_rrm_cell_reconfig_resp->fail_cause);
	    rmcm_mif_meas_config_resp(p_cell_ctx, p_rrc_rrm_cell_reconfig_resp->response,
		    fail_cause, meas_resp_api_id);

	    /* Start CSR 00064477 */
	    if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
	    {
		/*cell was stopped */
		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_INACTIVE);
	    }
	    else
	    {
		/*cell was not started */
		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);
	    }
	    /* End CSR 00064477 */

	    /* free the memory for new SON cell configuration */
	    RRM_MEM_FREE(p_cell_ctx->p_meas_config_sib_info_for_reconfig);
	    if(p_cell_ctx->p_ncl_built_from_updated_nrt_info)
	    {
		RRM_MEM_FREE(p_cell_ctx->p_ncl_built_from_updated_nrt_info);
		p_cell_ctx->p_ncl_built_from_updated_nrt_info = RRM_PNULL;
	    }
	}
	else
	{
	    p_cqi_sr_info_bfr_reconfig = (pucch_t*)rrm_mem_get(sizeof(pucch_t));
	    if (p_cqi_sr_info_bfr_reconfig == RRM_PNULL)
	    {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			"Memory allocation to p_cqi_sr_info_bfr_reconfig failed" );
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	    }

	    if(p_cell_ctx->ran_info.physical_layer_params.bitmask & 
		    RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)
	    {
		p_srs_info_bfr_reconfig = (srs_t*)rrm_mem_get(sizeof(srs_t));
		if (p_srs_info_bfr_reconfig == RRM_PNULL)
		{
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			    "Memory allocation to p_srs_info_bfr_reconfig failed" );
		    RRM_UT_TRACE_EXIT();
		    RRM_MEM_FREE(p_cqi_sr_info_bfr_reconfig);
		    return RRM_FAILURE;
		}
		RRM_MEMCPY(p_srs_info_bfr_reconfig ,&(p_cell_ctx->ran_info.
			    physical_layer_params.physical_layer_param_srs),sizeof(srs_t));
	    }

	    RRM_MEMCPY(p_cqi_sr_info_bfr_reconfig ,&(p_cell_ctx->ran_info.
			physical_layer_params.physical_layer_param_pucch),sizeof(pucch_t));

	    max_num_ue_per_cell_bfr_reconfig = p_cell_ctx->operator_info.admission_control_info.
		max_num_ue_per_cell; 
	    /*Reconfig Crash for Meas Config: Fix Start*/
	    commit_cell_reconfig_params(p_cell_ctx);
	    /*Reconfig Crash for Meas Config: Fix End*/

	    /*
	     ** Update the PUCCH/PUSCH resource pool as per the new configuration
	     */
	    update_pucch_pusch_resources_on_reconfig( p_cell_ctx ,
		    p_srs_info_bfr_reconfig , 
		    p_cqi_sr_info_bfr_reconfig,
		    max_num_ue_per_cell_bfr_reconfig);

	    if(RRM_PNULL != p_cqi_sr_info_bfr_reconfig)
	    {
		RRM_MEM_FREE(p_cqi_sr_info_bfr_reconfig);
	    }
	    if(RRM_PNULL != p_srs_info_bfr_reconfig)
	    {
		RRM_MEM_FREE(p_srs_info_bfr_reconfig);
	    }                
	    ret_val = rmcm_mif_send_reconfig_resp(p_cell_ctx);

	    /*CSR_00059028_CHANGES_START */
	    if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
	    {
		/*CSR_00059028_CHANGES_END */
		/* DYNAMIC ICIC CHANGES START */  
		if(RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT & (p_cell_ctx->operator_info).bitmask)
		{
		    rrm_l2_build_send_reconfig_schedule_params(p_cell_ctx);
		}
		/* DYNAMIC ICIC CHANGES END */

		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_INACTIVE);
		CELL_STATE_CHNAGE_IND(p_cell_ctx,CELL_STATE_INACTIVE);

		/** Dynamic UE Scheduling Start **/
		if(((rrmcm_rmif_cell_reconfig_req_t *)( p_cell_ctx->p_new_reconfig_data))->bitmask
			& RRMCM_RMIF_OPERATOR_INFO_PRESENT)
		{
		    if(((rrmcm_rmif_cell_reconfig_req_t *)(p_cell_ctx->p_new_reconfig_data))->bitmask 
			    & RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT )
		    {
			rrm_send_active_ue_report_enable_prefs( p_cell_ctx->cell_index );
		    }
		}
		/** Dynamic UE Scheduling End **/
		/*CSR_00059028_CHANGES_START */
	    }
	    else
	    {
		CELL_M_FSM_SET_STATE(p_cell_ctx, CELL_STATE_W_FOR_CELL_START);

	    }
	    /*CSR_00059028_CHANGES_END */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
		    RRM_BRIEF,"Reconfig Succ Cell State Is:%s For Cell Index:%d",
		    CELL_FSM_STATE[p_cell_ctx->cell_state],p_cell_ctx->cell_index);

	    ret_val = RRM_SUCCESS;
	}
    }
    /*SPR 5676 Fix Start*/
    /* free the memory for new configuration*/
    if(RRM_PNULL != p_cell_ctx->p_new_reconfig_data )
    {
	RRM_MEM_FREE(p_cell_ctx->p_new_reconfig_data);
	p_cell_ctx->p_new_reconfig_data = RRM_PNULL;
    }
    /*SPR 5676 Fix End*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
} 
   /*spr 9631 fix end*/

/** eICIC_PHASE_1_2_CHANGES_START */
/*************************************************************************************
 * Array Name     : build_and_send_uem_eicic_provision_reconfig_req
 * Inputs         : Pointer to reconfiguration info
 * Outputs        : None
 * Returns        : None
 * Description    : This function will send the UEM eicic_provision_reconfig_req  API
 *************************************************************************************/
rrm_return_et
build_and_send_uem_eicic_provision_reconfig_req
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
 )
{

    rrm_return_et ret_val = RRM_FAILURE;
    rrmuem_cellm_eicic_provision_reconfig_req_t  eicic_provision_reconfig_req = {RRM_ZERO};
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    RRM_UT_TRACE_ENTER();
    /*eicic_subset_pattern_fix_start*/
    /*SPR 14424 start*/
    /*code deleted*/ 
    /*SPR 14424 end*/
    if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_RECONFIG_VICTIM_MEAS_PATTERN_PRESENT) 
     {
         eicic_provision_reconfig_req.bitmask |= RRMUEM_CELLM_MEAS_SF_PATTERN_RECONFIG;
     }   
    if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT)
     {
       eicic_provision_reconfig_req.bitmask |= RRMUEM_CELLM_EICIC_PROVISION_RECONFIG;
     }    
    /*eicic_subset_pattern_fix_end*/ 
    eicic_provision_reconfig_req.cell_index = p_cell_ctx->cell_index;
    eicic_provision_reconfig_req.eicic_provision_reconfig = p_cell_ctx->rrm_eicic_cell_info.mac_config_data.eicic_provisioned_type;
    eicic_provision_reconfig_req.transaction_id = RRM_ONE; 

    if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
                                              RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_REQ,
                                              sizeof(rrmuem_cellm_eicic_provision_reconfig_req_t),
                                              (void *)&eicic_provision_reconfig_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "failure in sending :%d for cell index:%d",
                RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_REQ,
                p_cell_ctx->cell_index);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "success in sending :%d for cell index:%d",
                RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_REQ,
                p_cell_ctx->cell_index);
        ret_val = RRM_SUCCESS;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*************************************************************************************
 * Array Name     : rmcm_mac_abs_reconfig_req
 * Inputs         : Pointer to reconfiguration info
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : This function will send the MAC mac_cell_config_req  API
 *************************************************************************************/
rrm_return_et
rmcm_mac_abs_reconfig_req
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et   send_to_mac_required = RRM_FALSE ;
    RRM_UT_TRACE_ENTER(); 

    if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_COMP_MIDLOAD_ABS_RECONFIG_PRESENT)   
    { 
        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,RRM_MAX_PATTERN_BYTE);
        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT; 
        send_to_mac_required = RRM_TRUE;
    }    

    if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_COMP_HIGHLOAD_ABS_RECONFIG_PRESENT)   
    {  
        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,RRM_MAX_PATTERN_BYTE);
        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;   
        send_to_mac_required = RRM_TRUE;
    }

    if(p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CTXT_COMP_OVERLOAD_ABS_RECONFIG_PRESENT)   
    {  
        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern,
                p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,RRM_MAX_PATTERN_BYTE);
        p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;   
        send_to_mac_required = RRM_TRUE;
    }

    if(send_to_mac_required == RRM_TRUE)
    {   
        if(RRM_FAILURE == build_and_send_l2_cell_config_req_for_eicic_reconfig(&p_cell_ctx->rrm_eicic_cell_info.mac_config_data,
                    p_cell_ctx->cell_index,
                    RRM_ONE))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "Failure returned during the processing of l2_cell_config_req");
            p_cell_ctx->rrm_eicic_cell_info.reconfig_api_trigger_bitmask = RRM_ZERO;
            ret_val = RRM_FAILURE;
        }
        else
        {  
            CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "Success returned during the processing of l2_cell_config_req");
        
           /*13961_start*/
           RRM_MEMCPY(  p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                     p_cell_ctx->rrm_eicic_cell_info.mac_config_data.serving_abs_pattern, RRM_MAX_PATTERN_BYTE);
            p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CTXT_SENDING_EICIC_LOAD_ABS_RECONFIG_TO_MAC_PRESENT;
            p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
           /*13961_end*/
        }
    }  
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/** eICIC_PHASE_1_2_CHANGES_END */
/* eICIC_PHASE_1_2_CHANGES_START */
/*****************************************************************************
 * Array Name     : build_and_send_uem_get_aggressor_req
 * Inputs         : Pointer to partition info
 * Outputs        : None
 * Returns        : None
 * Description    : This function will send the UEM get_aggressor_req API
 ****************************************************************************/
rrm_return_et
build_and_send_uem_get_aggressor_req
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
 )
{
    /* bug_13898_start */  
    rrm_return_et ret_val = RRM_SUCCESS;
    cell_timer_buf_t timer_buf;
    /* bug_13898_end */

    /* SPR14097START */
    rrm_bool_et x2_up_flag = RRM_FALSE;
    /* SPR14097END */

    rrmuem_cm_get_aggressor_req_t get_aggressor_req = {RRM_ZERO};
    RRM_UT_TRACE_ENTER();
    /* bug_13898_start */  


    if(RRM_ZERO != p_cell_ctx->cell_resource_info.num_active_ue)
    {
        /* SPR14097start */
	    /* SPR14157start */
	    if ((RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) && 
			    (RRM_OAM_EICIC_DEACTIVATED != p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type))
            {
		    x2_up_flag = rrm_check_for_x2_link_status(p_cell_ctx);
		    /* SPR14157end*/
        }
        if(RRM_TRUE == x2_up_flag)
        {
            /* SPR14097end */
            get_aggressor_req.cell_index = p_cell_ctx->cell_index;

            if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
                        RRMUEM_CM_GET_AGGRESSOR_REQ,
                        sizeof(rrmuem_cm_get_aggressor_req_t),
                        (void *)&get_aggressor_req))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "failure in sending :%d for cell index:%d",
                        RRMUEM_CM_GET_AGGRESSOR_REQ,
                        p_cell_ctx->cell_index);
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "success in sending :%d for cell index:%d",
                        RRMUEM_CM_GET_AGGRESSOR_REQ,
                        p_cell_ctx->cell_index);
                ret_val = RRM_SUCCESS;
            }
            /* SPR14097start */
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    " Since no neighbor present, no need to trigger"
                    " RRMUEM_CM_GET_AGGRESSOR_REQ. Restart the Timer" );
            /*SPR 14810 start*/
            /*SPR 21081 Fix Start*/
            if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
            {
            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                eicic_timer_info.aggressor_sel_timer;
            /*SPR 14810 stop*/
            /* Restart the timer */
            if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
            {
                timer_buf.cell_index = p_cell_ctx->cell_index;
                timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
                p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                    cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                            (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
            }
            }
            /*SPR 21081 Fix Stop*/
        }
        /* SPR14097end */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Since NO UE is present in the system, No need to trigger"
                "RRMUEM_CM_GET_AGGRESSOR_REQ. Restart the Timeri" );
        /*SPR 14810 start*/
        /*SPR 21081 Fix Start*/
        if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
        {
        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
            eicic_timer_info.aggressor_sel_timer;
        /*SPR 14810 stop*/
        /* Restart the timer */
        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
        {
            timer_buf.cell_index = p_cell_ctx->cell_index;
            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
            p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                        (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
        }
    }
        /*SPR 21081 Fix Stop*/
    }
    /* bug_13898_end */  

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*****************************************************************************
 * Array Name     : rrm_cellm_find_and_apply_common_abs_pattern
 * Inputs         : Pointer to partition info
 * Outputs        : None
 * Returns        : None
 * Description    : This function will find the common ABS pattern sent by the 
 *                  aggressors.
 ****************************************************************************/

rrm_return_et
rrm_cellm_find_and_apply_common_abs_pattern
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
 )
{
    /* bug_13935_start */
    U8 temp_abs_pattern_applied[RRM_MAX_PATTERN_BYTE] = {RRM_ZERO};
    U8 temp_meas_pattern_applied[RRM_MAX_PATTERN_BYTE] = {RRM_ZERO};
    U8                                ncl_cnt         = RRM_ZERO;
    U8                                temp_ncl_cnt    = RRM_ZERO;
    U8                                index           = RRM_ZERO;
    rrm_return_et                     ret_val         = RRM_FAILURE;
    rrm_bool_t                        abs_rcvd_flag            = RRM_FALSE;
    U8                                  aggressor_priority = RRM_ZERO;
    cell_timer_buf_t timer_buf;
    /* bug_13935_end */
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    /*SPR 16203 start */
    U8 valid_aggressor_count = RRM_ZERO;
    U8 no_of_abs_inactive_recvd = RRM_ZERO;
    /*SPR 16203 end */
    RRM_UT_TRACE_ENTER();

/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = RRM_MAX_PATTERN_BYTE;
#endif
/*EICIC_TDD_CHANGES_END*/

    /* bug_13935_start */
    /*SPR 14332 start*/
    RRM_MEMSET(p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,0XFF,RRM_MAX_PATTERN_BYTE);
    RRM_MEMSET(p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern,0XFF,RRM_MAX_PATTERN_BYTE);
    /*SPR 14332 end*/
    /* bug_13935_end */
    /* Finding the common abs pattern */
    for(ncl_cnt = RRM_ZERO; ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ++ncl_cnt)
    {
	    /*SPR 20086 Fix Start*/
	    if((p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.bitmask &
				    RRMCM_INTRA_NCL_ABS_PATTERN_RECVD_PRESENT)&&
			    (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_status == X2_ALLOWED_CONNECTED))
		    /*SPR 20086 Fix Stop*/
        {
            /*SPR 16203 start */
            valid_aggressor_count++;
            /*SPR 16203 start */
            /* bug_13935_start */
            abs_rcvd_flag = RRM_TRUE;
            if(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                      rrm_intra_ncl_eicic_data.aggressor_priority > aggressor_priority)
            {
                temp_ncl_cnt =  ncl_cnt;
                /*SPR 16203 start */
                if(RRM_EICIC_INACTIVE_ABS == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].\
                        rrm_intra_ncl_eicic_data.abs_pattern_status)
                {
                    no_of_abs_inactive_recvd++;
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                            "ABS_INACTIVE is received for ncl :%d",no_of_abs_inactive_recvd);
                }
                else
                {

                    aggressor_priority = p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                        rrm_intra_ncl_eicic_data.aggressor_priority;
                    RRM_MEMCPY(temp_abs_pattern_applied,
                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.temp_abs_pattern,
                            abs_size);
                    rrm_copy_tdd_bits(abs_size, temp_abs_pattern_applied);
                    RRM_MEMCPY(temp_meas_pattern_applied,
                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.temp_meas_pattern,
                            abs_size);
                    rrm_copy_tdd_bits(abs_size, temp_meas_pattern_applied);
                }
                /*SPR 16203 end */
            }
            /* bug_13935_end */

            for(index = RRM_ZERO; index < abs_size; index++)
            {
                /* bug_13935_start */
                p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] = 
                    p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] & 
                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                    rrm_intra_ncl_eicic_data.temp_abs_pattern[index];

                p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern[index] = 
                    p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern[index] & 
                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                    rrm_intra_ncl_eicic_data.temp_meas_pattern[index];
                /* bug_13935_end */
            }
            rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern);
            rrm_copy_tdd_bits(abs_size,p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern);
            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_ACCEPTED_PRESENT;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                      "Abs pattern is not recieved for ncl :%d",ncl_cnt);
        }
    }

    /*SPR 16203 start */
    if (valid_aggressor_count == no_of_abs_inactive_recvd )
    {
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                "Abs INACTIVE is received for all aggressors %d", no_of_abs_inactive_recvd);
        for(index = RRM_ZERO; index < abs_size; index++)
        {
            p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] =
                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern[index];
        }

        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                "Inactive received from all aggressors. So,"
                "Applying operator configured ABS");

    }
    /*SPR 16203 end */

    /* If the common pattern comes out to be zero */
    /* bug_13935_start */
    if( RRM_TRUE == abs_rcvd_flag)
    {
    /* bug_13935_end */
	    if(RRM_TRUE == rrm_check_abs_pattern_is_null( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern))
	    {
		    RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
				    temp_abs_pattern_applied,
				    abs_size);
            rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern);
		    RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
				    temp_meas_pattern_applied,
				    abs_size);
            rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
		    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
				    "Common ABS pattern couldn't be found, so assigning "
                                    "the ABS of aggressor[%d] whose priority i.e [%d] is highest as "
				    "as per UEM.",p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[temp_ncl_cnt].phy_cell_id,
                                    aggressor_priority
			     );

		    for(ncl_cnt = RRM_ZERO; ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ++ncl_cnt)
		    {
			    if(ncl_cnt != temp_ncl_cnt)
			    {
				    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
					    rrm_intra_ncl_eicic_data.bitmask = 0x00;
			    }
		    }
	    }


            /* Send this common ABS pattern to L2 */
            /* bug_13935_start */  
            if( RRM_FALSE == rrm_compare_configured_abs_pattern_vd_new_abs(p_cell_ctx) )
            {
                /* bug_13935_end */  
                /* Send this common ABS pattern to L2 */
                ret_val = build_and_send_l2_cell_config_req( RRM_PNULL,
                        RRM_PNULL,
                        RRM_PNULL,
                        p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                        p_cell_ctx->cell_index,
                        p_cell_ctx->ongoing_trans_id);

                if (RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                            "Failure returned during the processing of l2_cell_config_req");
                }
                else
                {
                    /* bug_13898_start */  
                    CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                            "Success returned during the processing of l2_cell_config_req");
                    /*SPR 14810 start*/
                    /*SPR 21081 Fix Start*/
                    if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
                    {
                    p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                        eicic_timer_info.aggressor_sel_timer;
                    /*SPR 14810 stop*/
                    /* Restart the timer */
                    if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
                    {
                        cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer );
                        timer_buf.cell_index = p_cell_ctx->cell_index;
                        timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
                        p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                            cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                                    (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
                    }
                    }
                    /*SPR 21081 Fix Stop*/

                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                    p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                    /* bug_13898_end */  
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Common ABS pattern is Not modified.No nned to send request to L2");
                
                if( RRM_ZERO != RRM_MEMCMP(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                            p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, abs_size))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Common MEAS SF pattern is modified.Send the SCHEDULE VICTIM IND to UEm");
                    RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                            p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern,
                            abs_size);
                    rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);
                    /* SPR 14576 start */
                    build_and_send_uem_schedule_victim_ind(p_cell_ctx, RRM_VICTIM_SCHEDULE_WITH_ABS_CHANGE);
                    /* SPR 14576 end */
                }
                else
                {
                    /*SPR 21351 Fix Start*/
                    build_and_send_uem_schedule_victim_ind(p_cell_ctx, RRM_VICTIM_SCHEDULE_WITH_NO_ABS_CHANGE);
                    /*SPR 21351 Fix Stop*/
                }
            }
    /* bug_13935_start */
    }
    else
    {
	    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
			    " ABS pattern is not recieved from any agrressor.No need to configure ABS on L2 ");
	    
        /*SPR 14810 start*/
        /*SPR 21081 Fix Start*/
        if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
        {
         p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                       eicic_timer_info.aggressor_sel_timer;
         /*SPR 14810 stop*/
        /* Restart the timer */
	    if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
	    {
		    cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer );
		    timer_buf.cell_index = p_cell_ctx->cell_index;
		    timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
		    p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
			    cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
					    (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
	    }
    }
        /*SPR 21081 Fix Stop*/
    }
    /* bug_13935_end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*****************************************************************************
 * Array Name     : build_and_send_uem_schedule_victim_ind 
 * Inputs         : p_cell_ctx 
 * Outputs        : None
 * Returns        : None
 * Description    : This function will send the schedule victim ue indicatoion to
 *                  UEM.
 ****************************************************************************/
rrm_void_t
build_and_send_uem_schedule_victim_ind
(
 rrm_cell_context_t *p_cell_ctx,        /* cell context */
 /* SPR 14576 start */ 
 rrm_victim_schedule_cause_et schedule_cause
 /* SPR 14576 end */ 
 )
{
    rrmuem_cm_schedule_victim_ue_ind_t ue_schedule_ind = {RRM_ZERO};
    U8            ncl_cnt = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* bug_13935_start */
    ue_schedule_ind.cell_index = p_cell_ctx->cell_index;
    /* SPR 14576 start */     
    ue_schedule_ind.schedule_cause = schedule_cause;
    /* SPR 14576 end */ 
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Cell Index is [%d] and Valid Aggressor PCI are :- ",  ue_schedule_ind.cell_index );
    for(ncl_cnt = RRM_ZERO; ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ++ncl_cnt)
    {
        if( RRMCM_INTRA_NCL_ABS_PATTERN_ACCEPTED_PRESENT & 
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                rrm_intra_ncl_eicic_data.bitmask)
        {
            /*SPR 21228 Fix Start*/
            ue_schedule_ind.valid_aggressor_list[ue_schedule_ind.aggressor_count] = 
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].phy_cell_id;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Valid Aggressor %d :- PCI[%d]",
                    ue_schedule_ind.aggressor_count,ue_schedule_ind.valid_aggressor_list[ue_schedule_ind.aggressor_count]);
            ue_schedule_ind.aggressor_count++;
            /* bug_13935_end */
            /*SPR 21228 Fix Start*/
        }
    }

    if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
                RRMUEM_CM_SCHEDULE_VICTIM_UE_IND,
                sizeof(rrmuem_cm_schedule_victim_ue_ind_t),
                (void *)&ue_schedule_ind))

    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "failure in sending :%d for cell index:%d",
                RRMUEM_CM_SCHEDULE_VICTIM_UE_IND,
                p_cell_ctx->cell_index);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "success in sending :%d for cell index:%d",
                RRMUEM_CM_SCHEDULE_VICTIM_UE_IND,
                p_cell_ctx->cell_index);
    }

    RRM_UT_TRACE_EXIT();
}

/*****************************************************************************
 * Array Name     : rrm_cellm_get_target_cell_from_ncl 
 * Inputs         : p_cell_ctx,target_cell_id 
 * Outputs        : p_target_ncl_count
 * Returns        : None
 * Description    : This function will find the NCL positition at which specified
 *                  target cell id is present.
 ****************************************************************************/
rrm_void_t
rrm_cellm_get_target_cell_from_ncl
(
  rrm_cell_context_t              *p_cell_ctx, 
  U8                              *p_target_ncl_count,
  rrm_oam_eutran_global_cell_id_t  target_cell_id
  )
{
   lte_ncl_t     *p_ncl_data = RRM_PNULL;
   U8             ncl_count = RRM_ZERO;
   RRM_UT_TRACE_ENTER();

   p_ncl_data = &(p_cell_ctx->ran_info.ncl_params.lte_ncl);
   for(ncl_count = RRM_ZERO; ncl_count < p_ncl_data->num_valid_intra_freq_cell; ncl_count++)
   {
       if(RRM_ZERO == RRM_MEMCMP( &target_cell_id, &(p_ncl_data->intra_freq_cells[ncl_count].cell_id),
                                   sizeof(rrm_oam_eutran_global_cell_id_t)))
       {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                      "Target Cell Id matched with Neighbor Count [%d]", ncl_count);
            *p_target_ncl_count = ncl_count;
            break;
       }
   }

   RRM_UT_TRACE_EXIT();
}

/*****************************************************************************
 * Array Name     : rrm_convert_x2ap_cell_id_to_ncl_cell 
 * Inputs         : x2ap_source_cell_id 
 * Outputs        : p_target_cell_id
 * Returns        : None
 * Description    : This function will convert x2ap cell id in ncl cell id.
 ****************************************************************************/
rrm_void_t
rrm_convert_x2ap_cell_id_to_ncl_cell
(
   rrm_cell_global_id_eutra_t       x2ap_source_cell_id,
   rrm_oam_eutran_global_cell_id_t  *p_target_cell_id
)
{
    RRM_UT_TRACE_ENTER();
    U8   count = RRM_ZERO;

    RRM_MEMSET(p_target_cell_id, RRM_ZERO,sizeof(rrm_oam_eutran_global_cell_id_t));

    if(x2ap_source_cell_id.plmn_identity.presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                  "MCC present in X2AP source cell id");
        for(count = RRM_ZERO ; count < MAX_MCC_DIGITS; count++)
        {
            p_target_cell_id->primary_plmn_id.mcc[count] = x2ap_source_cell_id.plmn_identity.mcc[count]; 
            /* bug_13935_start */   
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                  "Target MCC [%d] : [%d]",count,p_target_cell_id->primary_plmn_id.mcc[count]);
            /* bug_13935_end */  
        }
    }
    for(count = RRM_ZERO ; count < x2ap_source_cell_id.plmn_identity.mnc.count; count++)
    {
        p_target_cell_id->primary_plmn_id.mnc[count] = x2ap_source_cell_id.plmn_identity.mnc.mnc[count]; 
            /* bug_13935_start */   
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                  "Target MNC [%d] : [%d]",count,p_target_cell_id->primary_plmn_id.mnc[count]);
            /* bug_13935_end */  
    }
    p_target_cell_id->primary_plmn_id.num_mnc_digit = x2ap_source_cell_id.plmn_identity.mnc.count;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
                  "Target MNC Digit Count:[%d]",p_target_cell_id->primary_plmn_id.num_mnc_digit);

    RRM_MEMCPY(p_target_cell_id->cell_identity,x2ap_source_cell_id.cell_identity, RRM_FOUR);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
              "Target Cell Identity is [%d][%d][%d][%d]",
              p_target_cell_id->cell_identity[RRM_ZERO], p_target_cell_id->cell_identity[RRM_ONE],
               p_target_cell_id->cell_identity[RRM_TWO],  p_target_cell_id->cell_identity[RRM_THREE]);
    RRM_UT_TRACE_EXIT();
}

/*****************************************************************************
 * Array Name     : rrm_cellm_process_abs_info_frm_aggressor 
 * Inputs         : p_cell_ctx, p_x2ap_abs_info,target_ncl_count,abs_pattern_status
 * Outputs        : None
 * Returns        : None
 * Description    : This function will process abs info from aggressor.
 ****************************************************************************/
rrm_void_t
rrm_cellm_process_abs_info_frm_aggressor
(
 rrm_cell_context_t               *p_cell_ctx,
 x2ap_rrm_li_abs_information_t    *p_x2ap_abs_info,
 U8                                target_ncl_count,
 rrm_abs_pattern_status_et         abs_pattern_status
)
{

    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();

/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = X2AP_ABS_PATTERN_SIZE_TDD;
#endif
/*EICIC_TDD_CHANGES_END*/

/* bug_13935_start */  
    if(p_x2ap_abs_info->bitmask & X2AP_LI_ABS_INFORMATION_FDD_PRESENT )
    {
        RRM_MEMSET(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
                RRM_ZERO,RRM_MAX_PATTERN_BYTE);
        RRM_MEMCPY(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
                p_x2ap_abs_info->abs_info_fdd.abs_pattern_info,
                X2AP_ABS_PATTERN_SIZE_FDD);
        RRM_MEMCPY(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_meas_pattern,
                p_x2ap_abs_info->abs_info_fdd.measurement_subset,
                X2AP_MEASUREMENT_SUBSET_SIZE_FDD);
        
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.abs_pattern_status = abs_pattern_status;
        
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_RECVD_PRESENT; 
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_MEAS_PATTERN_RECVD_PRESENT;
        p_cell_ctx->rrm_eicic_cell_info.num_x2ap_abs_ind_recived++;
        rrm_print_abs_pattern(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern);
    }
    else if(p_x2ap_abs_info->bitmask & X2AP_LI_ABS_INFORMATION_TDD_PRESENT )
    {
        RRM_MEMSET(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
                RRM_ZERO,RRM_MAX_PATTERN_BYTE);
        /*EICIC_TDD_CHANGES_START*/
        RRM_MEMCPY(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
                p_x2ap_abs_info->abs_info_tdd.abs_pattern_info,
                abs_size);
        
        rrm_copy_tdd_bits(abs_size, p_cell_ctx->ran_info.ncl_params.lte_ncl.
                        intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern);
        
        RRM_MEMCPY(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_meas_pattern,
                p_x2ap_abs_info->abs_info_tdd.measurement_subset,
                abs_size);
 
        rrm_copy_tdd_bits(abs_size, p_cell_ctx->ran_info.ncl_params.lte_ncl.
                        intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_meas_pattern);
                 
        
        /*EICIC_TDD_CHANGES_END*/
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.abs_pattern_status = abs_pattern_status;
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_RECVD_PRESENT; 
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_MEAS_PATTERN_RECVD_PRESENT; 
    }
    /*SPR 15485 start*/
    else if (p_x2ap_abs_info->bitmask & X2AP_LI_ABS_INFORMATION_ABS_INACTIVE_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "ABS INACTIVE is present in X2AP load ind");

        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.abs_pattern_status = RRM_EICIC_INACTIVE_ABS;
        /*SPR 21351 Fix Start*/
        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
            rrm_intra_ncl_eicic_data.invoke_ind_status = RRM_EICIC_INVOKE_NOT_SENT;
        /*SPR 21351 Fix Stop*/
        /*SPR 21234 Fix Start*/
        RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.mac_config_data.usable_abs_pattern,
                RRM_ZERO,
                RRM_MAX_PATTERN_BYTE);

        RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied,
                RRM_ZERO,
                RRM_MAX_PATTERN_BYTE);
        /*SPR 21234 Fix Stop*/
    }
    /*SPR 15485 end*/
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Neither TDD nor FDD ABS information is present in X2AP load ind");
    }

    RRM_UT_TRACE_EXIT();
}

rrm_void_t
rrm_cellm_process_abs_info_frm_agg_same_enb
(
 rrm_cell_context_t               *p_srvng_cell_ctx,
 rrm_cell_context_t               *p_neigh_cell_ctx,
 U8                                target_ncl_count,
 rrm_abs_pattern_status_et         abs_pattern_status
)
{
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    U8               abs_size = RRM_ZERO;
#endif
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();

/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_srvng_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#endif
/*EICIC_TDD_CHANGES_END*/

/* bug_13935_start */  
#ifndef TDD_MODE_FLAG
    RRM_MEMSET(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
            RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMCPY(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
            p_neigh_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied,
            RRM_MAX_ABS_PATTERN_BYTE_FDD);
    /*SPR 20531 start*/
    RRM_MEMCPY(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_meas_pattern,
            p_neigh_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
            RRM_MAX_ABS_PATTERN_BYTE_FDD );
    /*SPR 20531 stop*/
#else
    /*EICIC_TDD_CHANGES_START*/
    RRM_MEMSET(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
            RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMCPY(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern,
            p_neigh_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied,
            abs_size);

    rrm_copy_tdd_bits(abs_size, p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern);
    /*SPR 20531 start*/ 
    RRM_MEMCPY(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_meas_pattern,
            p_neigh_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
            abs_size);
    /*SPR 20531 stop*/
    rrm_copy_tdd_bits(abs_size, p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.
            intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_meas_pattern);

    /*EICIC_TDD_CHANGES_END*/
#endif
    /* bug_13935_start */  

    p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
        rrm_intra_ncl_eicic_data.abs_pattern_status = abs_pattern_status;

    p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
        rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_RECVD_PRESENT; 
    p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].
        rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_MEAS_PATTERN_RECVD_PRESENT;
   /* bug_13935_start */  
//    p_srvng_cell_ctx->rrm_eicic_cell_info.num_x2ap_abs_ind_recived++;
   /* bug_13935_end */  

   rrm_print_abs_pattern(p_srvng_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.temp_abs_pattern);
    RRM_UT_TRACE_EXIT();
}

rrm_return_et
rrm_cellm_find_and_update_common_abs_pattern
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
    U8   ncl_cnt         = RRM_ZERO;
    U8   index           = RRM_ZERO; 
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*SPR 15485 start*/
    U8                     no_of_abs_inactive_recvd = RRM_ZERO;
    U8                     valid_aggressor_count = RRM_ZERO;
    /*SPR 15485 end*/
    /*EICIC_TDD_CHANGES_END*/
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = RRM_MAX_PATTERN_BYTE;
#endif
    /*EICIC_TDD_CHANGES_END*/
    //coverity_fix_req
    rrm_return_et  ret_val = RRM_SUCCESS;


    RRM_UT_TRACE_ENTER();    
    /*SPR 14332 start*/
    RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern, 0xFF , RRM_MAX_PATTERN_BYTE);
    /*SPR 14332 end*/
    /* Finding the common abs pattern */
    for(ncl_cnt = RRM_ZERO; ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ++ncl_cnt)
    {
        if(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.bitmask &
                RRMCM_INTRA_NCL_ABS_PATTERN_RECVD_PRESENT )
        {
            /* SPR 15485 Fix start */
            valid_aggressor_count ++;
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                    "valid_aggressor_count  :%d", 
                    valid_aggressor_count);
            /* SPR 15485 Fix end */
            /* bug_13964_start */  
            if( RRM_EICIC_UPDATE_ABS == p_cell_ctx->ran_info.ncl_params.\
                                        lte_ncl.intra_freq_cells[ncl_cnt].\
                                        rrm_intra_ncl_eicic_data.abs_pattern_status)
            {
                for(index = RRM_ZERO; index < abs_size; index++)
                {
                    /* bug_13935_start */  
                    p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] = 
                        p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] &
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                        rrm_intra_ncl_eicic_data.temp_abs_pattern[index];
                    /* bug_13935_end */  

                }
                /*EICIC_TDD_CHANGES_START*/
                rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern);
                /*EICIC_TDD_CHANGES_END*/
            }
            /* SPR 15485 Fix start */
            else if (RRM_EICIC_INACTIVE_ABS == p_cell_ctx->ran_info.\
                                               ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].\
                                               rrm_intra_ncl_eicic_data.abs_pattern_status)
            {
                no_of_abs_inactive_recvd++;
                RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                        "Abs INACTIVE is received for ncl :%d",no_of_abs_inactive_recvd);
            }
            /* SPR 15485 Fix end */
            else
            {
                for(index = RRM_ZERO; index < abs_size; index++)
                {
                    p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] = 
                        p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] &
                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                        rrm_intra_ncl_eicic_data.abs_pattern_recvd[index];

                }
                /*EICIC_TDD_CHANGES_START*/
                rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern);
                /*EICIC_TDD_CHANGES_END*/
            }
            /* bug_13964_end */
            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_ACCEPTED_PRESENT;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                    "Abs pattern is not Updated for ncl :%d",ncl_cnt);
        }
    }

    /* SPR 15485 Fix start */
    if (valid_aggressor_count == no_of_abs_inactive_recvd )
    {
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                                "Abs INACTIVE is received for all aggressors %d", no_of_abs_inactive_recvd);
        for(index = RRM_ZERO; index < abs_size; index++)
        {
            p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern[index] =
                p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern[index];
        }
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                        "Inactive received from all aggressors. So,"
                        "Applying operator configured ABS");

    }
    /* SPR 15485 Fix end */
    /* If the common pattern comes out to be zero */
    if(RRM_TRUE == rrm_check_abs_pattern_is_null( p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern))
    {
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                "Unable to find common abs patern after Updates from Aggressors."
                "Stay with the existing configured ABS pattern at L2 ");
        for(ncl_cnt = RRM_ZERO; ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ++ncl_cnt)
        {
            if( RRM_EICIC_UPDATE_ABS == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                    rrm_intra_ncl_eicic_data.abs_pattern_status )
            {
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                    rrm_intra_ncl_eicic_data.abs_pattern_status = RRM_EICIC_CNFRMD_ABS;
                /*SPR 14332 start*/    
                RRM_MEMSET(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                        rrm_intra_ncl_eicic_data.temp_abs_pattern, 0XFF, RRM_MAX_PATTERN_BYTE);
                /*SPR 14332 start*/
            }
        }
    }
    else
    {
        /* bug_13935_start */  
        /* Send the updated ABS pattern at L2 */
        if( RRM_FALSE == rrm_compare_configured_abs_pattern_vd_new_abs(p_cell_ctx) )
        {
            /* bug_13935_end */  

            ret_val = build_and_send_l2_cell_config_req( RRM_PNULL,
                    RRM_PNULL,
                    RRM_PNULL,
                    p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                    p_cell_ctx->cell_index,
                    p_cell_ctx->ongoing_trans_id);// Ongoing trans id (gur35933)

            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "Failure returned during the processing of l2_cell_config_req");
            }
            else
            {
                /* bug_13898_start */  
                CELL_M_FSM_SET_STATE(p_cell_ctx,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
                /* bug_13898_end */  
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "Success returned during the processing of l2_cell_config_req");
                /* SPR 14415 start */
                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_USABLE_ABS_RECONFIG_INFO_PRESENT;
                /* SPR 14415 end */
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Common ABS pattern is Not modified.No nned to send request to L2");

            if( RRM_ZERO != RRM_MEMCMP(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                        p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, abs_size))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Common MEAS SF pattern is modified.Send the SCHEDULE VICTIM IND to UEm");
                RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                        p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern,
                        abs_size);

                rrm_copy_tdd_bits(abs_size, p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied);

                /* SPR 14576 start */ 
                build_and_send_uem_schedule_victim_ind(p_cell_ctx, RRM_VICTIM_SCHEDULE_WITH_ABS_CHANGE);
                /* SPR 14576 end */ 
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Common MEAS SF pattern is Not modified.No need to send the SCHEDULE VICTIM IND to UEm");
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return  ret_val;
}
/*review comments changes start*/
 /*****************************************************************************
 * Array Name     : rrm_check_abs_pattern_is_null 
 * Inputs         : p_abs_pattern
 * Outputs        : TRUE/FALSE
 * Returns        : None
 * Description    : This function will check abs pattern is null or not.
 ****************************************************************************/
/*review comments changes end*/   
rrm_bool_et
rrm_check_abs_pattern_is_null
(
  U8 *p_abs_pattern
)
{

    U8 count = RRM_ZERO;
    rrm_bool_et abs_is_null = RRM_TRUE;
    RRM_UT_TRACE_ENTER();

    for (count = RRM_ZERO; count < RRM_MAX_PATTERN_BYTE ; count++)
    {

        if(p_abs_pattern[count] != RRM_ZERO)
        {

            abs_is_null = RRM_FALSE;
            break;
        }
    }

    RRM_UT_TRACE_EXIT();
    return abs_is_null;
    
}

rrm_bool_et
rrm_cellm_first_invoke_recieved
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
)
{
     /* bug_13898_start */
     rrm_bool_et  first_invoke_ind = RRM_TRUE;
     RRM_UT_TRACE_ENTER();
  
     if( (p_cell_ctx->rrm_eicic_cell_info.bitmask & RRM_CELLM_SERVING_ABS_PATTERN_PRESENT) )
     {
         RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                 "This is not first invoke ,abs has already been configured on mac" );
	     first_invoke_ind = RRM_FALSE;
     }
     /* bug_13898_end */
     RRM_UT_TRACE_EXIT();
     return first_invoke_ind;
}

rrm_return_et
rrm_cellm_get_current_load_abs_pattern
( 
    rrm_cell_context_t *p_cell_ctx,        /* cell context */
    U8                 *p_load_abs_pattern
)
{
    rrm_return_et    ret_val = RRM_SUCCESS;
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();
/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG    
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else 
    abs_size = RRM_MAX_ABS_PATTERN_BYTE_FDD;
#endif    
/*EICIC_TDD_CHANGES_END*/    
    switch (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl)
    {
        case RRM_LOW: 
            {
               if( ( RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) &&
                   ( RRMCM_RMIF_ABS_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.bitmask) &&
                   ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.abs_info.bitmask) &&
                   /* SPR 14543 start */
                   ( RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT & p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask)
                   /* SPR 14543 end */
                 )
               {
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                           " ABS pattern is selected for  Lowload load level " );
                   /* bug_14010_start */  
                   /*EICIC_TDD_CHANGES_START*/
                   RRM_MEMCPY( p_load_abs_pattern,
                           p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                           abs_size);
                   /*EICIC_TDD_CHANGES_END*/
                   /* bug_14010_end */
               }
               else
               {
                   ret_val = RRM_FAILURE;
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                           "ABS is not configured for Lowload load level"
                           "No ABS can be applied at L2");
               }

                break;
            }

        case RRM_MEDIUM: 
            {
               if( ( RRM_CELLM_MIDLOAD_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.bitmask) &&
                   ( RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.bitmask) &&
                   ( RRM_CELLM_ABS_PATTERN_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.bitmask) 
                 )
               {
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                           " ABS pattern is selected for  Midload load level " );
                   /* bug_14010_start */
                   /*EICIC_TDD_CHANGES_START*/
                     RRM_MEMCPY( p_load_abs_pattern,
                                 p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,
                                abs_size);
                     /*EICIC_TDD_CHANGES_END*/
                   /* bug_14010_end */
               }
               else
               {
                   ret_val = RRM_FAILURE;
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                           "ABS is not configured for MID load level"
                           "No ABS can be applied at L2");
               }
                break;
            }

        case RRM_HIGH: 
            {
               if( ( RRM_CELLM_HIGHLOAD_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.bitmask) &&
                   ( RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.high_load.bitmask) &&
                   ( RRM_CELLM_ABS_PATTERN_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.bitmask) 
                 )
               {
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                           " ABS pattern is selected for  Highload load level " );
                   /* bug_14010_start */
                   /*EICIC_TDD_CHANGES_START*/
                     RRM_MEMCPY( p_load_abs_pattern,
                                 p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,
                                 abs_size);
                     
                     /*EICIC_TDD_CHANGES_END*/
                   /* bug_14010_end */
               }
               else
               {
                   ret_val = RRM_FAILURE;
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                           "ABS is not configured for high load level"
                           "No ABS can be applied at L2");
               }
                break;
            }

        case RRM_OVERLOAD: 
            {
               if( ( RRM_CELLM_OVERLOAD_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.bitmask) &&
                   ( RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.over_load.bitmask) &&
                   ( RRM_CELLM_ABS_PATTERN_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.bitmask) 
                 )
               {
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                           " ABS pattern is selected for  Overload load level " );
                   /* bug_14010_start */
                     /*EICIC_TDD_CHANGES_START*/
                     RRM_MEMCPY( p_load_abs_pattern,
                                 p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,
                                 abs_size);
                     /*EICIC_TDD_CHANGES_END*/
                   /* bug_14010_end */
               }
               else
               {
                   ret_val = RRM_FAILURE;
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                           "ABS is not configured for Overload load level"
                           "No ABS can be applied at L2");
               }
                break;
            }
        default:
            {
                   RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                             "Invalid Load level[%d], Can't get ABS pattern",
                             p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl
                             );
                             
                   RRM_UT_TRACE_EXIT();
                   return RRM_FAILURE;

            }
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            " ABS Pattern found on load[%u]",
            p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl);
    rrm_print_abs_pattern(p_load_abs_pattern);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* bug_13935_start */  
rrm_bool_et
rrm_compare_configured_abs_pattern_vd_new_abs
(
     rrm_cell_context_t *p_cell_ctx
)
{
    rrm_bool_et pattern_matched = RRM_FALSE;
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();
/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG    
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else 
    abs_size = RRM_MAX_ABS_PATTERN_BYTE_FDD;
#endif    
/*EICIC_TDD_CHANGES_END*/

        /* bug_14010_start */  
    if( RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctx)) 
    {

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New ABS Pattern to be applied :-");
        rrm_print_abs_pattern(p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern);

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " Existing Pattern applied :-");
        rrm_print_abs_pattern(p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied);
        /* bug_14010_end */  
       /*EICIC_TDD_CHANGES_START*/
        
        if(RRM_ZERO == RRM_MEMCMP(p_cell_ctx->rrm_eicic_cell_info.temp_usable_abs_pattern,
                    p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied,
                    abs_size))
       /*EICIC_TDD_CHANGES_END*/     
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Already same abs pattern is applied at L2. No need to reconfigure");
            pattern_matched = RRM_TRUE;
        }
    }

        /* bug_14010_start */  
    if(RRM_TRUE == rrm_cellm_is_aggressor_node(p_cell_ctx))
    {

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " New ABS Pattern to be applied :-");
        rrm_print_abs_pattern(p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern);

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                " Existing Pattern applied :-");
        rrm_print_abs_pattern(p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied);
        /* bug_14010_end */  
        /*EICIC_TDD_CHANGES_START*/
       
        if(RRM_ZERO == RRM_MEMCMP(p_cell_ctx->rrm_eicic_cell_info.temp_srv_abs_pattern,
                    p_cell_ctx->rrm_eicic_cell_info.serving_abs_pattern_applied,
                    abs_size))
        /*EICIC_TDD_CHANGES_END*/    
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Already same abs pattern is applied at L2. No need to reconfigure");
            pattern_matched = RRM_TRUE;
        }
    }

    /* CID_69672_FIX_START */
    RRM_UT_TRACE_EXIT();
    /* CID_69672_FIX_END */
    return pattern_matched;
}
/* bug_13935_end */  
/*13987_fix_start*/
rrm_void_t
rrm_cellm_handle_eicic_timer_for_reconfig
(
    rrm_cell_context_t *p_cell_ctx
)
{
    cell_timer_buf_t  timer_buf;
    U8 ncl_cnt = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(p_cell_ctx->rrm_eicic_cell_info.reconfig_param_bitmask & RRM_CTXT_EICIC_PROV_MOD_INFO_PRESENT)
    {
        for(ncl_cnt = RRM_ZERO;ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ;ncl_cnt++)
        {    
            RRM_MEMSET(&(p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].
                    rrm_intra_ncl_eicic_data), RRM_ZERO, sizeof(rrm_intra_ncl_eicic_data_t));
        }
        if((p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)&&
                ( p_cell_ctx->p_new_reconfig_data->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_EICIC_DEACTIVATED  || 
                  p_cell_ctx->p_new_reconfig_data->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR))   
        {
            if(RRM_ZERO != p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
            {
                cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer );
                p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = RRM_ZERO;
            }
            if(RRM_ZERO != p_cell_ctx->timer_val[CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER]) 
            {
                cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_collation_timer); 
                p_cell_ctx->timer_val[CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER] = RRM_ZERO;
            }
            if(RRM_ZERO != p_cell_ctx->timer_val[CELL_GUARD_TIMER_FOR_ABS_PATTERN]) 
            {
                cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer);
                p_cell_ctx->timer_val[CELL_GUARD_TIMER_FOR_ABS_PATTERN] = RRM_ZERO;
            }
        }
        if((p_cell_ctx->p_new_reconfig_data->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)&&
                ( p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_EICIC_DEACTIVATED  || 
                  p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR))   
        {
        /*SPR 14810 start*/
            /*SPR 21081 Fix Start*/
            if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
            {
         p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                       eicic_timer_info.aggressor_sel_timer;
         /*SPR 14810 stop*/
            if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
            {
                cell_stop_timer (p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer);
                timer_buf.cell_index = p_cell_ctx->cell_index;
                timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
                p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                    cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                            (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
            }
            }
            /*SPR 21081 Fix Stop*/
        }
    }   
    RRM_UT_TRACE_EXIT();
}
/*13987_fix_end*/
/* bug_14010_start */
rrm_bool_et
rrm_cellm_overload_abs_configured
(
rrm_cell_load_action_t *p_comp_load_info
)
{
    rrm_bool_et load_configured  = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if( ( RRM_CELLM_OVERLOAD_PRESENT & p_comp_load_info->bitmask) &&
            ( RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT & p_comp_load_info->over_load.bitmask) &&
            ( RRM_CELLM_ABS_PATTERN_PRESENT & p_comp_load_info->over_load.eicic_load_config.bitmask) 
      )
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "OVER LOAD ABS is configured ");
        load_configured = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return load_configured;
}

rrm_bool_et
rrm_cellm_highload_abs_configured
(
rrm_cell_load_action_t *p_comp_load_info
)
{
    rrm_bool_et load_configured  = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if( ( RRM_CELLM_HIGHLOAD_PRESENT & p_comp_load_info->bitmask) &&
            ( RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT & p_comp_load_info->high_load.bitmask) &&
            ( RRM_CELLM_ABS_PATTERN_PRESENT & p_comp_load_info->high_load.eicic_load_config.bitmask) 
      )
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "HIGH LOAD ABS is configured ");
        load_configured = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return load_configured;
}

rrm_bool_et
rrm_cellm_midload_abs_configured
(
rrm_cell_load_action_t *p_comp_load_info
)
{
    rrm_bool_et load_configured  = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if( ( RRM_CELLM_MIDLOAD_PRESENT & p_comp_load_info->bitmask) &&
            ( RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT & p_comp_load_info->mid_load.bitmask) &&
            ( RRM_CELLM_ABS_PATTERN_PRESENT & p_comp_load_info->mid_load.eicic_load_config.bitmask) 
      )
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "MID LOAD ABS is configured ");
        load_configured = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return load_configured;
}

rrm_bool_et
rrm_cellm_lowload_abs_configured
(
    rrm_cell_context_t *p_cell_ctx
)
{
    rrm_bool_et load_configured  = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if( ( RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) &&
            ( RRMCM_RMIF_ABS_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.bitmask) &&
            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.abs_info.bitmask) &&
            /*SPR 16202 start*/
            (RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT & p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask))
            /*SPR 16202 end*/
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "LOW LOAD ABS is configured ");
        load_configured = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return load_configured;
}

rrm_return_et
rrm_cellm_get_highest_load_abs
(
    /* new_api_element_start */
    rrm_cell_context_t *p_cell_ctx,
    U8                 *p_new_meas_abs
    /* new_api_element_end */
)
{
    rrm_return_et    ret_val = RRM_FAILURE;
    /*EICIC_TDD_CHANGES_START*/
    U8                          abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();
/*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
        abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
        abs_size = RRM_MAX_ABS_PATTERN_BYTE_FDD;
#endif
/*EICIC_TDD_CHANGES_END*/ 
    
    /* new_api_element_start */
    /*SPR Fix 15664 Start */
    RRM_MEMSET( p_new_meas_abs,
                RRM_ZERO,
                RRM_MAX_PATTERN_BYTE);
    /*SPR Fix 15664 End */
    /* new_api_element_end */
    if( RRM_TRUE == rrm_cellm_overload_abs_configured( &(p_cell_ctx->cell_load_action.u.comp_load_info)))
    {
        ret_val= RRM_SUCCESS;
    /* new_api_element_start */
        RRM_MEMCPY( p_new_meas_abs,
                p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,
                abs_size);
        rrm_copy_tdd_bits(abs_size,p_new_meas_abs);
    /* new_api_element_end */

    }
    else if ( RRM_TRUE ==  rrm_cellm_highload_abs_configured(&(p_cell_ctx->cell_load_action.u.comp_load_info)))
    {
        ret_val= RRM_SUCCESS;
    /* new_api_element_start */
        RRM_MEMCPY( p_new_meas_abs,
                p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,
                abs_size);
        rrm_copy_tdd_bits(abs_size,p_new_meas_abs);
    /* new_api_element_end */
    }
    else if ( RRM_TRUE ==  rrm_cellm_midload_abs_configured(&(p_cell_ctx->cell_load_action.u.comp_load_info)))
    {
        ret_val= RRM_SUCCESS;
    /* new_api_element_start */
        RRM_MEMCPY( p_new_meas_abs,
                p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,
                abs_size);
        rrm_copy_tdd_bits(abs_size,p_new_meas_abs);
    /* new_api_element_end */
    }
    else if ( RRM_TRUE  ==  rrm_cellm_lowload_abs_configured(p_cell_ctx))
    {
            ret_val = RRM_SUCCESS;
    /* new_api_element_start */
            RRM_MEMCPY( p_new_meas_abs,
                    p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern,
                    abs_size);
            rrm_copy_tdd_bits(abs_size,p_new_meas_abs);
    /* new_api_element_end */
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                  "ABS is not configured for any load ");
    }

   RRM_UT_TRACE_EXIT();
   return ret_val;

}
/* bug_14010_end */
/* eICIC_PHASE_1_2_CHANGES_END */

/* Spr 16211 Changes Start*/
/****************************************************************************
 * Function Name  : rrm_get_delta_ncl_from_updated_nrt
 * Inputs         : p_cell_ctx,inter_rat_ncl_added,inter_rat_ncl_deleted 
 * Outputs        : list of deleted and newly added inter rat cell
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function find the newly addded and deleted cell from 
 *                  Updated nrt from SON   
 ****************************************************************************/
rrm_void_t 
rrm_get_delta_ncl_from_updated_nrt
(
 rrm_cell_context_t * p_cell_ctx, 
 inter_rat_ncl_t * p_inter_rat_ncl_added,
 inter_rat_ncl_t * p_inter_rat_ncl_deleted
 )
{
    RRM_UT_TRACE_ENTER();

    U8 index = RRM_ZERO, index_1 = RRM_ZERO, count= RRM_ZERO; 
    rrm_bool_et is_same = RRM_FALSE; 
    inter_rat_ncl_t  *p_updated_inter_nrt_info = 
        &p_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;
    inter_rat_ncl_t  *p_old_inter_rat_ncl_list = 
        &p_cell_ctx->ran_info.ncl_params.inter_rat_ncl;


    if(RRM_PNULL == p_updated_inter_nrt_info)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_updated_inter_nrt_info is NULL");
        RRM_UT_TRACE_EXIT();
        return;
    }

    /* Loop  to find is any geran neighbour is removed */
    for(index = RRM_ZERO; index< p_old_inter_rat_ncl_list->num_valid_geran_cell;index++)
    {
        for(index_1 = RRM_ZERO; index_1 < p_updated_inter_nrt_info->num_valid_geran_cell; index_1++)
        {
            is_same = rrm_compare_geran_neighbor(&p_updated_inter_nrt_info->geran_freq_cells[index_1],
                    &p_old_inter_rat_ncl_list->geran_freq_cells[index]);

            if(is_same)
            {
                break;
            }
        }
        if(!is_same)
        {
            /* Neighbour is deleted */ 
            RRM_MEMCPY(&p_inter_rat_ncl_deleted->geran_freq_cells[count++],
                    &p_old_inter_rat_ncl_list->geran_freq_cells[index],
                    sizeof(geran_freq_ncl_t));  
        }
        is_same = RRM_FALSE;
    }
    p_inter_rat_ncl_deleted->num_valid_geran_cell = count;           
    if(count)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[%d] geran neighbour deleted in updated nrt",
                p_inter_rat_ncl_deleted->num_valid_geran_cell);
        count = RRM_ZERO;
    }

    /* Loop  to find is any geran neighbour is newly added */
    for(index = RRM_ZERO; index< p_updated_inter_nrt_info->num_valid_geran_cell;index++)
    {
        for(index_1 = RRM_ZERO; index_1 < p_old_inter_rat_ncl_list->num_valid_geran_cell; index_1++)
        {
            is_same = rrm_compare_geran_neighbor(&p_updated_inter_nrt_info->geran_freq_cells[index],
                                                 &p_old_inter_rat_ncl_list->geran_freq_cells[index_1]); 
            if(is_same) 
            {
                break;
            } 
        }
        if(!is_same)
        {
            /* Neighbour is newly added */ 
            RRM_MEMCPY(&p_inter_rat_ncl_added->geran_freq_cells[count++],
                    &p_updated_inter_nrt_info->geran_freq_cells[index],
                    sizeof(geran_freq_ncl_t));  
        }
        is_same = RRM_FALSE;

    }
    p_inter_rat_ncl_added->num_valid_geran_cell = count;           
    if(count)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[%d] geran neighbour new added in updated nrt",
                p_inter_rat_ncl_added->num_valid_geran_cell);
        count = RRM_ZERO;
    }

    /* Loop  to find is any utran neighbour is removed */
    for(index = RRM_ZERO; index< p_old_inter_rat_ncl_list->num_valid_utran_freq_cell;index++)
    {
        for(index_1 = RRM_ZERO; index_1 < p_updated_inter_nrt_info->num_valid_utran_freq_cell; index_1++)
        {     
            is_same = rrm_compare_utran_neighbor(&p_updated_inter_nrt_info->utran_freq_cells[index_1],
                                                 &p_old_inter_rat_ncl_list->utran_freq_cells[index]); 
            if(is_same) 
            {
                break;
            } 
        }
        if(!is_same)
        {
            /* Neighbour is newly removed */
            RRM_MEMCPY(&p_inter_rat_ncl_deleted->utran_freq_cells[count++],
                    &p_old_inter_rat_ncl_list->utran_freq_cells[index],
                    sizeof(utran_freq_cells_t));
        }
        is_same = RRM_FALSE;
    }
    p_inter_rat_ncl_deleted->num_valid_utran_freq_cell = count;         
    if(count)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[%d] UTRAN neighbour deleted in updated nrt",
                p_inter_rat_ncl_deleted->num_valid_utran_freq_cell);
        count = RRM_ZERO;
    }
    /* Loop  to find is any utran neighbour is added */
    for(index = RRM_ZERO; index< p_updated_inter_nrt_info->num_valid_utran_freq_cell;index++)
    {
        for(index_1 = RRM_ZERO; index_1 < p_old_inter_rat_ncl_list->num_valid_utran_freq_cell; index_1++)
        {
            is_same = rrm_compare_utran_neighbor(&p_updated_inter_nrt_info->utran_freq_cells[index],
                                                 &p_old_inter_rat_ncl_list->utran_freq_cells[index_1]); 
            if(is_same)
            {
                break;
            }
        }
        if(!is_same)
        {
            /* Neighbour is newly added */
            RRM_MEMCPY(&p_inter_rat_ncl_added->utran_freq_cells[count++],
                    &p_updated_inter_nrt_info->utran_freq_cells[index],
                    sizeof(utran_freq_cells_t));
        }
        is_same = RRM_FALSE;

    }
    p_inter_rat_ncl_added->num_valid_utran_freq_cell = count;        
    if(count)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "[%d] UTRAN neighbour added in updated nrt",
                p_inter_rat_ncl_added->num_valid_utran_freq_cell);
        /*CID 96510 Start*/
        //code removed
        /*CID 96510 End*/
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_compare_geran_neighbor
 * Inputs         : p_updated_geran_nbr,p_geran_neigh 
 * Outputs        : None  
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function compare two geran neighbour 
 ****************************************************************************/
rrm_bool_et
rrm_compare_geran_neighbor
(
 geran_freq_ncl_t   *p_updated_geran_nbr,
 geran_freq_ncl_t   *p_geran_neigh
 )
{
    rrm_bool_et   ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if ((!RRM_MEMCMP(&p_updated_geran_nbr->lai.plmn_identity.mcc,
                    &p_geran_neigh->lai.plmn_identity.mcc
                    , sizeof(U8) * MAX_MCC_DIGITS)) &&
            (p_updated_geran_nbr->lai.plmn_identity.mnc.count ==
             p_geran_neigh->lai.plmn_identity.mnc.count) &&
            (!RRM_MEMCMP(&p_updated_geran_nbr->
                         lai.plmn_identity.mnc.mnc,
                         &p_geran_neigh->
                         lai.plmn_identity.mnc.mnc,
                         sizeof(U8) * MAX_MNC_DIGITS)) &&
            (!RRM_MEMCMP(p_updated_geran_nbr->lai.lac,
                         p_geran_neigh->lai.lac,
                         sizeof(U8) * RRM_OAM_MAX_NUM_LAC_OCTETS)) &&
            (!RRM_MEMCMP(&p_updated_geran_nbr->cell_id,
                         &p_geran_neigh->cell_id,
                         sizeof(U16))))
    {     

        ret_val = RRM_TRUE;

    }     
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/****************************************************************************
 * Function Name  : rrm_compare_utran_neighbor
 * Inputs         : p_updated_utran_nbr,p_geran_neigh 
 * Outputs        : None  
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function compare two utran neighbour 
 ****************************************************************************/
rrm_bool_et
rrm_compare_utran_neighbor
(
 utran_freq_cells_t *p_updated_utran_nbr,
 utran_freq_cells_t *p_utran_neigh 
 )
{
    rrm_bool_et   ret_val = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if (!RRM_MEMCMP(p_utran_neigh->uc_id.cell_id_merge,
                p_updated_utran_nbr->uc_id.cell_id_merge,
                sizeof(U8)*MAX_CELL_IDENTITY_OCTETS)
            &&
            (!RRM_MEMCMP(&(p_utran_neigh->rai.lai.plmn_identity.mcc),
                         &(p_updated_utran_nbr->rai.lai.plmn_identity.mcc),
                         sizeof(U8) * MAX_MCC_DIGITS))
            &&
            (p_utran_neigh->rai.lai.plmn_identity.mnc.count ==
             p_updated_utran_nbr->rai.lai.plmn_identity.mnc.count)
            &&
            (!RRM_MEMCMP(&(p_utran_neigh->rai.lai.plmn_identity.mnc.mnc),
                         &(p_updated_utran_nbr->rai.lai.plmn_identity.mnc.mnc),
                         sizeof(U8) * MAX_MNC_DIGITS)))
    {
        ret_val = RRM_TRUE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Spr 16211 Changes End*/

/* + SPR 17665 + */
rrm_return_et
validation_mac_reconfig_req(
        rrmcm_rmif_cell_reconfig_req_t  *p_reconfig_req,
        rrm_cell_context_t *p_cell_ctx)
{

    rrm_return_et ret_val = RRM_SUCCESS;

    if(RRMCM_RMIF_DCI_FORMAT_FOR_SI_MSG_PRESENT & p_reconfig_req->operator_info.rrm_mac_config.bitmask)
    {
        if((p_reconfig_req->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A) && 
                (p_reconfig_req->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT))
        {

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Correct value 1A passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A");

            ret_val = RRM_SUCCESS;
        }
        else if ((p_reconfig_req->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A) &&
                 (p_reconfig_req->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect bitmask 1C passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A");
            ret_val = RRM_FAILURE;

        }    
        else if((p_reconfig_req->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C)&&
                (p_reconfig_req->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT)) 
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Correct array 1C passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C");

            ret_val = RRM_SUCCESS;
        }
        else if((p_reconfig_req->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg == RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C)&&
                (p_reconfig_req->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect bitmask 1A passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C");
            ret_val = RRM_FAILURE;

        }    
        else
        {

            switch(p_reconfig_req->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg)
            {                    
                /* Check the cell context */

                case RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A:
                {
                    if(!(p_cell_ctx->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT))
                    {

                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                "Incorrect array 1A passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A");
                        ret_val = RRM_FAILURE;

                    }
                    break ;   
                }

                case RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C:
                {

                    if(!(p_cell_ctx->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT)) 
                    {

                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                "Incorrect array 1C passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C");
                        ret_val = RRM_FAILURE;

                    }    

                    break;   
                }

            }
        }
    }
    else if(p_reconfig_req->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT)
    {
        /* Check the cell context */
        if (RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A != p_cell_ctx->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect array 1A passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A");
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Correct array 1A passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A");

            ret_val = RRM_SUCCESS;

        }    
    }
    else if (p_reconfig_req->operator_info.rrm_mac_config.bitmask & RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT)
    {
        /* Check the cell context */
        if (RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C != p_cell_ctx->operator_info.rrm_mac_config.rrm_dci_format_for_si_msg)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect array 1C passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C");
            ret_val = RRM_FAILURE;
        }
        else
        {    
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Correct array 1C passed dci_format_for_si_msg is RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C");

            ret_val = RRM_SUCCESS;
        }
    }    
    return ret_val;

}

/* - SPR 17665 -*/

/*SPR 21660 changes start*/
/****************************************************************************
* Function Name  : build_and_send_cell_stop_req 
* Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
* Outputs        : None
* Returns        : RRM_SUCCESS/RRM_FAILURE
* Description    : Build and send the cell start request
****************************************************************************/
rrm_return_et
    build_and_send_cell_stop_req
(
 U16  transaction_id,
 U8   cell_index
 )
{
    rrc_rrm_cell_stop_req_t *p_cell_stop_req = RRM_PNULL;
    rrmcm_rmif_generic_resp_t  generic_resp_to_mif = {RRM_ZERO};
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    p_cell_stop_req = rrm_mem_get(sizeof(rrc_rrm_cell_stop_req_t));

    if(p_cell_stop_req == RRM_PNULL)
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_stop_req failed");
        RRM_UT_TRACE_EXIT();
        ret_val = RRM_FAILURE;
    }
    else
    {
        /*Constructing Cell stop request*/
        if(RRM_FAILURE == build_send_stop_req(transaction_id,
                    cell_index, p_cell_stop_req))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed To Send Cell Stop Req To RRC For Cell Index:%d",
                    cell_index);
            generic_resp_to_mif.cellindex = cell_index;
            generic_resp_to_mif.transaction_id = transaction_id;
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_INVALID_PARAMS;
            ret_val = build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
                    RRMCM_RMIF_CELL_STOP_RESP);
            if (RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "cellm_fsm_process_event: Failed to send generic response to MIF");
            }
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                    "Successfull send cell start request");
        }
        RRM_MEM_FREE(p_cell_stop_req);

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/*SPR 21660 changes end*/
